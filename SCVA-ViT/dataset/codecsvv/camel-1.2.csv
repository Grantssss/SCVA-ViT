metric_name,file
org.apache.camel.AlreadyStoppedException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * @version $Revision: $
 */
public class AlreadyStoppedException extends CamelException {
    public AlreadyStoppedException() {
        super(""Already stopped"");
    }
}
"
org.apache.camel.AsyncCallback,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * The callback interface for an {@see AsyncProcessor} so that it can 
 * notify you when an {@see Exchange} has completed. 
 */
public interface AsyncCallback {
    /**
     * This method is invoked once the Exchange is completed.  If an error 
     * occurred while processing the exchange, the exception field of the 
     * {@see Exchange} being processed will hold the error. 
     *  
     * @param doneSynchronously set to true if the processing of the exchange was completed synchronously thread.
     */
    void done(boolean doneSynchronously);    
}
"
org.apache.camel.AsyncProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A more complex version of {@see Processor} which supports asynchronous
 * processing of the {@see Exchange}.  Any processor can be coerced to
 * have an {@see AsyncProcessor} interface by using the {@see AsyncProcessorTypeConverter.convert()}
 * method.
 * 
 * @version $Revision: 575602 $
 */
public interface AsyncProcessor extends Processor {
    /**
     * Processes the message exchange.  Similar to {@see Processor.process}, but
     * the caller supports having the exchange asynchronously processed.
     *
     * @param exchange the exchange to process
     * @param  callback The @{see AsyncCallback} will be invoked when the processing
     *         of the exchange is completed. If the exchange is completed synchronously, then the 
     *         callback is also invoked synchronously.  The callback should therefore be careful of
     *         starting recursive loop.
     *         
     * @return true if the processing was completed synchronously.
     */
    boolean process(Exchange exchange, AsyncCallback callback);
}
"
org.apache.camel.Body,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being the body of an inbound {@link Message}
 * 
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Body {
}
"
org.apache.camel.BodyAndHeaderConvertTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import junit.framework.TestCase;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
/**
 * @version $Revision: 563607 $
 */
public class BodyAndHeaderConvertTest extends TestCase {
    protected Exchange exchange;
    public void testConversionOfBody() throws Exception {
        Document document = exchange.getIn().getBody(Document.class);
        assertNotNull(document);
        Element element = document.getDocumentElement();
        assertEquals(""Root element name"", ""hello"", element.getLocalName());
    }
    public void testConversionOfExchangeProperties() throws Exception {
        String text = exchange.getProperty(""foo"", String.class);
        assertEquals(""foo property"", ""1234"", text);
        // TODO better conversion example when the property editor support is added
    }
    public void testConversionOfMessageHeaders() throws Exception {
        String text = exchange.getIn().getHeader(""bar"", String.class);
        assertEquals(""bar header"", ""567"", text);
        // TODO better conversion example when the property editor support is added
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        exchange = new DefaultExchange(new DefaultCamelContext());
        exchange.setProperty(""foo"", 1234);
        Message message = exchange.getIn();
        message.setBody(""<hello>world!</hello>"");
        message.setHeader(""bar"", 567);
    }
}
"
org.apache.camel.CamelContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.spi.ExchangeConverter;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.spi.Registry;
import org.apache.camel.model.RouteType;
/**
 * Interface used to represent the context used to configure routes and the
 * policies to use during message exchanges between endpoints.
 *
 * @version $Revision: 579301 $
 */
public interface CamelContext extends Service {
    /**
     * Gets the name of the this context.
     */
    String getName();
    // Component Management Methods
    //-----------------------------------------------------------------------
    /**
     * Adds a component to the context.
     */
    void addComponent(String componentName, Component component);
    /**
     * Gets a component from the context by name.
     */
    Component getComponent(String componentName);
    /**
     * Gets a component from the context by name and specifying the expected type of component.
     */
    <T extends Component> T getComponent(String name, Class<T> componentType);
    /**
     * Removes a previously added component.
     *
     * @param componentName
     * @return the previously added component or null if it had not been previously added.
     */
    Component removeComponent(String componentName);
    /**
     * Gets the a previously added component by name or lazily creates the component
     * using the factory Callback.
     *
     * @param componentName the name of the component
     * @param factory       used to create a new component instance if the component was not previously added.
     * @return
     */
    Component getOrCreateComponent(String componentName, Callable<Component> factory);
    // Endpoint Management Methods
    //-----------------------------------------------------------------------
    /**
     * Resolves the given URI to an {@see Endpoint}.  If the URI has a singleton endpoint
     * registered, then the singleton is returned.  Otherwise, a new {@see Endpoint} is created
     * and if the endpoint is a singleton it is registered as a singleton endpoint.
     */
    Endpoint getEndpoint(String uri);
    /**
     * Resolves the given URI to an {@see Endpoint} of the specified type.
     * If the URI has a singleton endpoint registered, then the singleton is returned.
     * Otherwise, a new {@see Endpoint} is created and if the endpoint is a
     * singleton it is registered as a singleton endpoint.
     */
    <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType);
    /**
     * Returns the collection of all registered singleton endpoints.
     */
    Collection<Endpoint> getSingletonEndpoints();
    /**
     * Adds the endpoint to the context using the given URI.  The endpoint will be registered as a singleton.
     *
     * @param uri the URI to be used to resolve this endpoint
     * @param endpoint the endpoint to be added to the context
     * @return the old endpoint that was previously registered to the context if there was
     * already an endpoint for that URI
     * @throws Exception if the new endpoint could not be started or the old endpoint could not be stopped
     */
    Endpoint addSingletonEndpoint(String uri, Endpoint endpoint) throws Exception;
    /**
     * Removes the singleton endpoint with the given URI
     *
     * @param uri the URI to be used to remove
     * @return the endpoint that was removed or null if there is no endpoint for this URI
     * @throws Exception if endpoint could not be stopped
     */
    Endpoint removeSingletonEndpoint(String uri) throws Exception;
    // Route Management Methods
    //-----------------------------------------------------------------------
    /**
     * Returns a list of the current route definitions
     */
    List<RouteType> getRouteDefinitions();
    /**
     * Returns the current routes in this context
     *
     * @return the current routes in this context
     */
    List<Route> getRoutes();
    /**
     * Sets the routes for this context, replacing any current routes
     *
     * @param routes the new routes to use
     */
    void setRoutes(List<Route> routes);
    /**
     * Adds a collection of routes to this context
     *
     * @param routes the routes to add
     */
    void addRoutes(Collection<Route> routes) throws Exception;
    /**
     * Adds a collection of routes to this context using the given builder
     * to build them
     *
     * @param builder the builder which will create the routes and add them to this context
     * @throws Exception if the routes could not be created for whatever reason
     */
    void addRoutes(RouteBuilder builder) throws Exception;
    /**
     * Adds a collection of route definitions to the context
     */
    void addRouteDefinitions(Collection<RouteType> routeDefinitions) throws Exception;
    // Properties
    //-----------------------------------------------------------------------
    /**
     * Returns the converter of exchanges from one type to another
     * @return
     */
    ExchangeConverter getExchangeConverter();
    /**
     * Returns the type converter used to coerce types from one type to another
     */
    TypeConverter getTypeConverter();
    /**
     * Returns the registry used to lookup components by name and type such as the Spring ApplicationContext,
     * JNDI or the OSGi Service Registry
     */
    Registry getRegistry();
    /**
     * Returns the injector used to instantiate objects by type
     */
    Injector getInjector();
    /**
     * Returns the lifecycle strategy used to handle lifecycle notification
     */
    LifecycleStrategy getLifecycleStrategy();
    /**
     * Resolves a language for creating expressions
     */
    Language resolveLanguage(String language);
}
"
org.apache.camel.CamelContextAware,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An interface to represent an object which wishes to be injected with
 * a {@link CamelContext} such as when working with Spring or Guice
 *
 * @version $Revision: $
 */
public interface CamelContextAware {
    /**
     * Injects the {@link CamelContext}
     *
     * @param camelContext
     */
    void setCamelContext(CamelContext camelContext);
}
"
org.apache.camel.CamelException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Base class for all Camel checked exceptions typically thrown by a
 * {@link Processor}
 *
 * @version $Revision: $
 */
public class CamelException extends Exception {
    public CamelException() {
    }
    public CamelException(String message) {
        super(message);
    }
    public CamelException(String message, Throwable cause) {
        super(message, cause);
    }
    public CamelException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.CamelExchangeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An exception caused by a specific message {@ilnk Exchange}
 *
 * @version $Revision: 1.1 $
 */
public class CamelExchangeException extends CamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final Exchange exchange;
    public CamelExchangeException(String message, Exchange exchange) {
        super(message + "" on the exchange: "" +  exchange);
        this.exchange = exchange;
    }
    /**
     * Returns the exchange which caused the exception
     *
     * @return the exchange which caused the exception
     */
    public Exchange getExchange() {
        return exchange;
    }
}
"
org.apache.camel.CamelTemplate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ProducerCache;
/**
 * A client helper object (named like Spring's TransactionTemplate & JmsTemplate
 * et al) for working with Camel and sending {@link Message} instances in an
 * {@link Exchange} to an {@link Endpoint}.
 * 
 * @version $Revision: 579640 $
 */
public class CamelTemplate<E extends Exchange> extends ServiceSupport implements ProducerTemplate<E> {
    private CamelContext context;
    private ProducerCache<E> producerCache = new ProducerCache<E>();
    private boolean useEndpointCache = true;
    private Map<String, Endpoint<E>> endpointCache = new HashMap<String, Endpoint<E>>();
    private Endpoint<E> defaultEndpoint;
    public CamelTemplate(CamelContext context) {
        this.context = context;
    }
    public CamelTemplate(CamelContext context, Endpoint defaultEndpoint) {
        this(context);
        this.defaultEndpoint = defaultEndpoint;
    }
    /**
     * Sends the exchange to the given endpoint
     * 
     * @param endpointUri the endpoint URI to send the exchange to
     * @param exchange the exchange to send
     */
    public E send(String endpointUri, E exchange) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, exchange);
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * 
     * @{link Processor} to populate the exchange
     * 
     * @param endpointUri the endpoint URI to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(String endpointUri, Processor processor) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, processor);
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * @{link Processor} to populate the exchange.  The callback
     * will be called when the exchange is completed.
     * 
     * @param endpointUri the endpoint URI to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(String endpointUri, Processor processor, AsyncCallback callback) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, processor, callback);
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     *
     * @{link Processor} to populate the exchange
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param processor the transformer used to populate the new exchange
     */
    public E send(String endpointUri, ExchangePattern pattern, Processor processor) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return send(endpoint, pattern, processor);
    }
    /**
     * Sends the exchange to the given endpoint
     * 
     * @param endpoint the endpoint to send the exchange to
     * @param exchange the exchange to send
     */
    public E send(Endpoint<E> endpoint, E exchange) {
        E convertedExchange = endpoint.createExchange(exchange);
        producerCache.send(endpoint, convertedExchange);
        return convertedExchange;
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * 
     * @{link Processor} to populate the exchange
     * 
     * @param endpoint the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, Processor processor) {
        return producerCache.send(endpoint, processor);
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * @{link Processor} to populate the exchange.  The callback
     * will be called when the exchange is completed.
     * 
     * @param endpoint the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, Processor processor, AsyncCallback callback) {
        return producerCache.send(endpoint, processor, callback);
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     *
     * @{link Processor} to populate the exchange
     *
     * @param endpoint the endpoint to send the exchange to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, ExchangePattern pattern, Processor processor) {
        return producerCache.send(endpoint, pattern, processor);
    }
    /**
     * Send the body to an endpoint with the given {@link ExchangePattern}
     * returning any result output body
     * 
     * @param endpoint
     * @param body = the payload
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @return the result
     */
    public Object sendBody(Endpoint<E> endpoint, ExchangePattern pattern, Object body) {
        E result = send(endpoint, pattern, createSetBodyProcessor(body));
        return extractResultBody(result);
    }
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param body = the payload
     * @return the result
     */
    public Object sendBody(Endpoint<E> endpoint, Object body) {
        E result = send(endpoint, createSetBodyProcessor(body));
        return extractResultBody(result);
    }
    /**
     * Send the body to an endpoint
     * 
     * @param endpointUri
     * @param body = the payload
     * @return the result
     */
    public Object sendBody(String endpointUri, Object body) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return sendBody(endpoint, body);
    }
    /**
     * Send the body to an endpoint
     *
     * @param endpointUri
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body = the payload
     * @return the result
     */
    public Object sendBody(String endpointUri, ExchangePattern pattern, Object body) {
        Endpoint endpoint = resolveMandatoryEndpoint(endpointUri);
        return sendBody(endpoint, pattern, body);
    }
    /**
     * Sends the body to an endpoint with a specified header and header value
     * 
     * @param endpointUri the endpoint URI to send to
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    public Object sendBodyAndHeader(String endpointUri, final Object body, final String header,
                                    final Object headerValue) {
        return sendBodyAndHeader(resolveMandatoryEndpoint(endpointUri), body, header, headerValue);
    }
    /**
     * Sends the body to an endpoint with a specified header and header value
     * 
     * @param endpoint the Endpoint to send to
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    public Object sendBodyAndHeader(Endpoint endpoint, final Object body, final String header,
                                    final Object headerValue) {
        E result = send(endpoint, createBodyAndHeaderProcessor(body, header, headerValue));
        return extractResultBody(result);
    }
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpoint the Endpoint to send to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    public Object sendBodyAndHeader(Endpoint endpoint, ExchangePattern pattern, final Object body, final String header,
                                    final Object headerValue) {
        E result = send(endpoint, pattern, createBodyAndHeaderProcessor(body, header, headerValue));
        return extractResultBody(result);
    }
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpoint the Endpoint URI to send to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    public Object sendBodyAndHeader(String endpoint, ExchangePattern pattern, final Object body, final String header,
                                    final Object headerValue) {
        E result = send(endpoint, pattern, createBodyAndHeaderProcessor(body, header, headerValue));
        return extractResultBody(result);
    }
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values
     * 
     * @param endpointUri the endpoint URI to send to
     * @param body the payload send
     * @return the result
     */
    public Object sendBodyAndHeaders(String endpointUri, final Object body, final Map<String, Object> headers) {
        return sendBodyAndHeaders(resolveMandatoryEndpoint(endpointUri), body, headers);
    }
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values
     * 
     * @param endpoint the endpoint URI to send to
     * @param body the payload send
     * @return the result
     */
    public Object sendBodyAndHeaders(Endpoint endpoint, final Object body, final Map<String, Object> headers) {
        E result = send(endpoint, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                for (Map.Entry<String, Object> header : headers.entrySet()) {
                    in.setHeader(header.getKey(), header.getValue());
                }
                in.setBody(body);
            }
        });
        return extractResultBody(result);
    }
    // Methods using an InOut ExchangePattern
    // -----------------------------------------------------------------------
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param processor the processor which will populate the exchange before sending
     * @return the result
     */
    public E request(Endpoint<E> endpoint, Processor processor) {
        return send(endpoint, ExchangePattern.InOut, processor);
    }
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param body     = the payload
     * @return the result
     */
    public Object requestBody(Endpoint<E> endpoint, Object body) {
        return sendBody(endpoint, ExchangePattern.InOut, body);
    }
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param body     = the payload
     * @param header
     * @param headerValue
     * @return the result
     */
    public Object requestBodyAndHeader(Endpoint<E> endpoint, Object body, String header, Object headerValue) {
        return sendBodyAndHeader(endpoint, ExchangePattern.InOut, body, header, headerValue);
    }
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param processor the processor which will populate the exchange before sending
     * @return the result
     */
    public E request(String endpoint, Processor processor) {
        return send(endpoint, ExchangePattern.InOut, processor);
    }
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param body     = the payload
     * @return the result
     */
    public Object requestBody(String endpoint, Object body) {
        return sendBody(endpoint, ExchangePattern.InOut, body);
    }
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param body     = the payload
     * @param header
     * @param headerValue
     * @return the result
     */
    public Object requestBodyAndHeader(String endpoint, Object body, String header, Object headerValue) {
        return sendBodyAndHeader(endpoint, ExchangePattern.InOut, body, header, headerValue);
    }
    // Methods using the default endpoint
    // -----------------------------------------------------------------------
    /**
     * Sends the body to the default endpoint and returns the result content
     * 
     * @param body the body to send
     * @return the returned message body
     */
    public Object sendBody(Object body) {
        return sendBody(getMandatoryDefaultEndpoint(), body);
    }
    /**
     * Sends the exchange to the default endpoint
     * 
     * @param exchange the exchange to send
     */
    public E send(E exchange) {
        return send(getMandatoryDefaultEndpoint(), exchange);
    }
    /**
     * Sends an exchange to the default endpoint using a supplied
     * 
     * @{link Processor} to populate the exchange
     * 
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Processor processor) {
        return send(getMandatoryDefaultEndpoint(), processor);
    }
    public Object sendBodyAndHeader(Object body, String header, Object headerValue) {
        return sendBodyAndHeader(getMandatoryDefaultEndpoint(), body, header, headerValue);
    }
    public Object sendBodyAndHeaders(Object body, Map<String, Object> headers) {
        return sendBodyAndHeaders(getMandatoryDefaultEndpoint(), body, headers);
    }
    // Properties
    // -----------------------------------------------------------------------
    public Producer<E> getProducer(Endpoint<E> endpoint) {
        return producerCache.getProducer(endpoint);
    }
    public CamelContext getContext() {
        return context;
    }
    public Endpoint<E> getDefaultEndpoint() {
        return defaultEndpoint;
    }
    public void setDefaultEndpoint(Endpoint<E> defaultEndpoint) {
        this.defaultEndpoint = defaultEndpoint;
    }
    /**
     * Sets the default endpoint to use if none is specified
     */
    public void setDefaultEndpointUri(String endpointUri) {
        setDefaultEndpoint(getContext().getEndpoint(endpointUri));
    }
    public boolean isUseEndpointCache() {
        return useEndpointCache;
    }
    public void setUseEndpointCache(boolean useEndpointCache) {
        this.useEndpointCache = useEndpointCache;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected Processor createBodyAndHeaderProcessor(final Object body, final String header, final Object headerValue) {
        return new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setHeader(header, headerValue);
                in.setBody(body);
            }
        };
    }
    protected Processor createSetBodyProcessor(final Object body) {
        return new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(body);
            }
        };
    }
    protected Endpoint resolveMandatoryEndpoint(String endpointUri) {
        Endpoint endpoint = null;
        if (isUseEndpointCache()) {
            synchronized (endpointCache) {
                endpoint = endpointCache.get(endpointUri);
                if (endpoint == null) {
                    endpoint = context.getEndpoint(endpointUri);
                    if (endpoint != null) {
                        endpointCache.put(endpointUri, endpoint);
                    }
                }
            }
        } else {
            endpoint = context.getEndpoint(endpointUri);
        }
        if (endpoint == null) {
            throw new NoSuchEndpointException(endpointUri);
        }
        return endpoint;
    }
    protected Endpoint<E> getMandatoryDefaultEndpoint() {
        Endpoint<E> answer = getDefaultEndpoint();
        ObjectHelper.notNull(answer, ""defaultEndpoint"");
        return answer;
    }
    protected void doStart() throws Exception {
        producerCache.start();
    }
    protected void doStop() throws Exception {
        producerCache.stop();
    }
    protected Object extractResultBody(E result) {
        Object answer = null;
        if (result != null) {
            answer = result.getOut().getBody();
            if (answer == null) {
                answer = result.getIn().getBody();
            }
        }
        return answer;
    }
}
"
org.apache.camel.Component,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A <a href=""http://activemq.apache.org/camel/component.html"">component</a> is
 * a factory of {@link Endpoint} objects.
 * 
 * @version $Revision: 519901 $
 */
public interface Component<E extends Exchange> {
    /**
     * Returns the context
     * 
     * @return the context of this component
     */
    CamelContext getCamelContext();
    /**
     * The {@link CamelContext} is injected into the component when it is added
     * to it
     */
    void setCamelContext(CamelContext context);
    /**
     * Attempt to resolve an endpoint for the given URI if the component is
     * capable of handling the URI
     * 
     * @param uri the URI to create
     * @return a newly created endpoint or null if this component cannot create
     *         instances of the given uri
     */
    Endpoint<E> createEndpoint(String uri) throws Exception;
}
"
org.apache.camel.Consumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A consumer of message exchanges from an {@link Endpoint}
 *
 * @version $Revision: 563607 $
 */
public interface Consumer<E extends Exchange> extends Service {
}
"
org.apache.camel.ContextTestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.io.File;
import javax.naming.Context;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.JndiRegistry;
import org.apache.camel.spi.Language;
import org.apache.camel.util.jndi.JndiTest;
/**
 * A useful base class which creates a {@link CamelContext} with some routes
 * along with a {@link CamelTemplate} for use in the test case
 *
 * @version $Revision: 1.1 $
 */
public abstract class ContextTestSupport extends TestSupport {
    protected CamelContext context;
    protected CamelTemplate<Exchange> template;
    private boolean useRouteBuilder = true;
    private Service camelContextService;
    public boolean isUseRouteBuilder() {
        return useRouteBuilder;
    }
    public void setUseRouteBuilder(boolean useRouteBuilder) {
        this.useRouteBuilder = useRouteBuilder;
    }
    public Service getCamelContextService() {
        return camelContextService;
    }
    /**
     * Allows a service to be registered a separate lifecycle service to start
     * and stop the context; such as for Spring when the ApplicationContext is
     * started and stopped, rather than directly stopping the CamelContext
     */
    public void setCamelContextService(Service camelContextService) {
        this.camelContextService = camelContextService;
    }
    @Override
    protected void setUp() throws Exception {
        context = createCamelContext();
        assertValidContext(context);
        template = new CamelTemplate<Exchange>(context);
        if (useRouteBuilder) {
            RouteBuilder builder = createRouteBuilder();
            log.debug(""Using created route builder: "" + builder);
            context.addRoutes(builder);
        }
        else {
            log.debug(""Using route builder from the created context: "" + context);
        }
        startCamelContext();
        log.debug(""Routing Rules are: "" + context.getRoutes());
    }
    @Override
    protected void tearDown() throws Exception {
        log.debug(""tearDown test: "" + getName());
        template.stop();
        stopCamelContext();
    }
    protected void stopCamelContext() throws Exception {
        if (camelContextService != null) {
            camelContextService.stop();
        }
        else {
            context.stop();
        }
    }
    protected void startCamelContext() throws Exception {
        if (camelContextService != null) {
            camelContextService.start();
        }
        else {
            if (context instanceof DefaultCamelContext) {
                DefaultCamelContext defaultCamelContext = (DefaultCamelContext) context;
                if (!defaultCamelContext.isStarted()) {
                    defaultCamelContext.start();
                }
            }
            else {
                context.start();
            }
        }
    }
    protected CamelContext createCamelContext() throws Exception {
        return new DefaultCamelContext(createRegistry());
    }
    protected JndiRegistry createRegistry() throws Exception {
        return new JndiRegistry(createJndiContext());
    }
    protected Context createJndiContext() throws Exception {
        return JndiTest.createInitialContext();
    }
    /**
     * Factory method which derived classes can use to create a {@link RouteBuilder}
     * to define the routes for testing
     */
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() {
                // no routes added by default
            }
        };
    }
    /**
     * Resolves a mandatory endpoint for the given URI or an exception is thrown
     *
     * @param uri the Camel <a href="""">URI</a> to use to create or resolve an endpoint
     * @return the endpoint
     */
    protected Endpoint resolveMandatoryEndpoint(String uri) {
        return resolveMandatoryEndpoint(context, uri);
    }
    /**
     * Resolves a mandatory endpoint for the given URI and expected type or an exception is thrown
     *
     * @param uri the Camel <a href="""">URI</a> to use to create or resolve an endpoint
     * @return the endpoint
     */
    protected <T extends Endpoint> T resolveMandatoryEndpoint(String uri, Class<T> endpointType) {
        return resolveMandatoryEndpoint(context, uri, endpointType);
    }
    /**
     * Resolves the mandatory Mock endpoint using a URI of the form <code>mock:someName</code>
     *
     * @param uri the URI which typically starts with ""mock:"" and has some name
     * @return the mandatory mock endpoint or an exception is thrown if it could not be resolved
     */
    protected MockEndpoint getMockEndpoint(String uri) {
        return resolveMandatoryEndpoint(uri, MockEndpoint.class);
    }
    /**
     * Sends a message to the given endpoint URI with the body value
     *
     * @param endpointUri the URI of the endpoint to send to
     * @param body        the body for the message
     */
    protected void sendBody(String endpointUri, final Object body) {
        template.send(endpointUri, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(""testCase"", getName());
            }
        });
    }
    /**
     * Sends messages to the given endpoint for each of the specified bodies
     *
     * @param endpointUri the endpoint URI to send to
     * @param bodies      the bodies to send, one per message
     */
    protected void sendBodies(String endpointUri, Object... bodies) {
        for (Object body : bodies) {
            sendBody(endpointUri, body);
        }
    }
    /**
     * Creates an exchange with the given body
     */
    protected Exchange createExchangeWithBody(Object body) {
        return createExchangeWithBody(context, body);
    }
    /**
     * Asserts that the given language name and expression evaluates to the
     * given value on a specific exchange
     */
    protected void assertExpression(Exchange exchange, String languageName, String expressionText, Object expectedValue) {
        Language language = assertResolveLanguage(languageName);
        Expression<Exchange> expression = language.createExpression(expressionText);
        assertNotNull(""No Expression could be created for text: "" + expressionText + "" language: "" + language, expression);
        assertExpression(expression, exchange, expectedValue);
    }
    /**
     * Asserts that the given language name and predicate expression evaluates
     * to the expected value on the message exchange
     */
    protected void assertPredicate(String languageName, String expressionText, Exchange exchange, boolean expected) {
        Language language = assertResolveLanguage(languageName);
        Predicate<Exchange> predicate = language.createPredicate(expressionText);
        assertNotNull(""No Predicate could be created for text: "" + expressionText + "" language: "" + language, predicate);
        assertPredicate(predicate, exchange, expected);
    }
    /**
     * Asserts that the language name can be resolved
     */
    protected Language assertResolveLanguage(String languageName) {
        Language language = context.resolveLanguage(languageName);
        assertNotNull(""No language found for name: "" + languageName, language);
        return language;
    }
    /**
     * Asserts that all the expectations of the Mock endpoints are valid
     */
    protected void assertMockEndpointsSatisifed() throws InterruptedException {
        MockEndpoint.assertIsSatisfied(context);
    }
    protected void assertValidContext(CamelContext context) {
        assertNotNull(""No context found!"", context);
    }
    protected static void recursiveDelete(File file) {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; i < files.length; i++) {
                recursiveDelete(files[i]);
            }
        }
        file.delete();
    }
}
"
org.apache.camel.Converter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation used to mark classes and methods to indicate code capable of
 * converting from a type to another type which are then auto-discovered using
 * the <a href=""http://activemq.apache.org/camel/type-converter.html"">Type
 * Conversion Support</a>
 * 
 * @version $Revision: 563607 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD })
public @interface Converter {
}
"
org.apache.camel.Endpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An <a href=""http://activemq.apache.org/camel/endpoint.html"">endpoint</a>
 * implements the <a
 * href=""http://activemq.apache.org/camel/message-endpoint.html"">Message
 * Endpoint</a> pattern and represents an endpoint that can send and receive
 * message exchanges
 * 
 * @see Exchange, Message
 * @version $Revision: 572625 $
 */
public interface Endpoint<E extends Exchange> {
    /**
     * Returns if the endpoint should be a CamelContext singleton. If the
     * endpoint is a Singleton, then a single Endpoint instance will be shared
     * by all routes with the same URI. Because the endpoint is shared, it
     * should be treated as an immutable.
     */
    boolean isSingleton();
    /**
     * Returns the string representation of the endpoint URI
     */
    String getEndpointUri();
    /**
     * Create a new exchange for communicating with this endpoint
     */
    E createExchange();
    /**
     * Create a new exchange for communicating with this endpoint
     * with the specified {@link ExchangePattern} such as whether its going
     * to be an {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut} exchange
     *
     * @param pattern the message exchange pattern for the exchange
     */
    E createExchange(ExchangePattern pattern);
    /**
     * Creates a new exchange for communicating with this exchange using the
     * given exchange to pre-populate the values of the headers and messages
     */
    E createExchange(Exchange exchange);
    /**
     * Returns the context which created the endpoint
     * 
     * @return the context which created the endpoint
     */
    CamelContext getContext();
    /**
     * Creates a new producer which is used send messages into the endpoint
     * 
     * @return a newly created producer
     */
    Producer<E> createProducer() throws Exception;
    /**
     * Creates a new <a
     * href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event
     * Driven Consumer</a> which consumes messages from the endpoint using the
     * given processor
     * 
     * @return a newly created consumer
     */
    Consumer<E> createConsumer(Processor processor) throws Exception;
    /**
     * Creates a new <a
     * href=""http://activemq.apache.org/camel/polling-consumer.html"">Polling
     * Consumer</a> so that the caller can poll message exchanges from the
     * consumer using {@link PollingConsumer#receive()},
     * {@link PollingConsumer#receiveNoWait()} or
     * {@link PollingConsumer#receive(long)} whenever it is ready to do so
     * rather than using the <a
     * href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event
     * Based Consumer</a> returned by {@link #createConsumer(Processor)}
     * 
     * @return a newly created pull consumer
     * @throws Exception if the pull consumer could not be created
     */
    PollingConsumer<E> createPollingConsumer() throws Exception;
}
"
org.apache.camel.EndpointInject,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.spi.Registry;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to indicate an injection point of an {@link Endpoint}, {@link Producer},
 * {@link ProducerTemplate} or {@link CamelTemplate} into a POJO.
 *
 * A <a href=""http://activemq.apache.org/camel/uris.html"">URI</a> for an endpoint
 * can be specified on this annotation, or a name can be specified which is resolved in the
 * {@link Registry} such as in your Spring ApplicationContext.
 *
 * If no name or uri is specified then the name is defaulted from the field, property or method name.
 *
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface EndpointInject {
    String uri() default """";
    String name() default """";
}
"
org.apache.camel.Exchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.spi.UnitOfWork;
import java.util.Map;
/**
 * The base message exchange interface providing access to the request, response
 * and fault {@link Message} instances. Different providers such as JMS, JBI,
 * CXF and HTTP can provide their own derived API to expose the underlying
 * transport semantics to avoid the leaky abstractions of generic APIs.
 * 
 * @version $Revision: 581960 $
 */
public interface Exchange {
    /**
     * Returns the {@link ExchangePattern} (MEP) of this exchange.
     *
     * @return the message exchange pattern of this exchange
     */
    ExchangePattern getPattern();
    /**
     * Returns a property associated with this exchange by name
     * 
     * @param name the name of the property
     * @return the value of the given header or null if there is no property for
     *         the given name
     */
    Object getProperty(String name);
    /**
     * Returns a property associated with this exchange by name and specifying
     * the type required
     * 
     * @param name the name of the property
     * @param type the type of the property
     * @return the value of the given header or null if there is no property for
     *         the given name or null if it cannot be converted to the given
     *         type
     */
    <T> T getProperty(String name, Class<T> type);
    /**
     * Sets a property on the exchange
     * 
     * @param name of the property
     * @param value to associate with the name
     */
    void setProperty(String name, Object value);
    /**
     * Removes the given property on the exchange
     *
     * @param name of the property
     * @return the old value of the property
     */
    Object removeProperty(String name);
    /**
     * Returns all of the properties associated with the exchange
     * 
     * @return all the headers in a Map
     */
    Map<String, Object> getProperties();
    /**
     * Returns the inbound request message
     * 
     * @return the message
     */
    Message getIn();
    /**
     * Returns the outbound message, lazily creating one if one has not already
     * been associated with this exchange. If you want to inspect this property
     * but not force lazy creation then invoke the {@link #getOut(boolean)}
     * method passing in null
     * 
     * @return the response
     */
    Message getOut();
    /**
     * Returns the outbound message; optionally lazily creating one if one has
     * not been associated with this exchange
     * 
     * @return the response
     */
    Message getOut(boolean lazyCreate);
    /**
     * Returns the fault message
     * 
     * @return the fault
     */
    Message getFault();
    /**
     * Returns the fault message; optionally lazily creating one if one has
     * not been associated with this exchange
     *
     * @return the response
     */
    Message getFault(boolean lazyCreate);
    /**
     * Returns the exception associated with this exchange
     * 
     * @return the exception (or null if no faults)
     */
    Throwable getException();
    /**
     * Sets the exception associated with this exchange
     * 
     * @param e
     */
    void setException(Throwable e);
    /**
     * Returns true if this exchange failed due to either an exception or fault
     *
     * @see Exchange#getException()
     * @see Exchange#getFault()
     * @return true if this exchange failed due to either an exception or fault
     */
    boolean isFailed();
    /**
     * Returns the container so that a processor can resolve endpoints from URIs
     * 
     * @return the container which owns this exchange
     */
    CamelContext getContext();
    /**
     * Creates a copy of the current message exchange so that it can be
     * forwarded to another destination
     */
    Exchange copy();
    /**
     * Copies the data into this exchange from the given exchange
     * 
     * #param source is the source from which headers and messages will be
     * copied
     */
    void copyFrom(Exchange source);
    /**
     * Returns the unit of work that this exchange belongs to; which may map to
     * zero, one or more physical transactions
     */
    UnitOfWork getUnitOfWork();
    /**
     * Sets the unit of work that this exchange belongs to; which may map to
     * zero, one or more physical transactions
     */
    void setUnitOfWork(UnitOfWork unitOfWork);
    /**
     * Returns the exchange id
     *
     * @return the unique id of the exchange
     */
    String getExchangeId();
    /**
     * Set the exchange id
     *
     * @param id
     */
    void setExchangeId(String id);
}
"
org.apache.camel.ExchangePattern,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.HashMap;
import java.util.Map;
/**
 * Represents the kind of message exchange pattern
 *
 * @version $Revision: 1.1 $
 */
public enum ExchangePattern {
    InOnly,
    RobustInOnly,
    InOut,
    InOptionalOut,
    OutOnly,
    RobustOutOnly,
    OutIn,
    OutOptionalIn;
    protected static final Map<String, ExchangePattern> map = new HashMap<String, ExchangePattern>();
    /**
     * Returns the WSDL URI for this message exchange pattern
     *
     * @return the WSDL URI for this message exchange pattern
     */
    public String getWsdlUri() {
        switch (this) {
            case InOnly:
                return ""http://www.w3.org/ns/wsdl/in-only"";
            case InOptionalOut:
                return ""http://www.w3.org/ns/wsdl/in-optional-out"";
            case InOut:
                return ""http://www.w3.org/ns/wsdl/in-out"";
            case OutIn:
                return ""http://www.w3.org/ns/wsdl/out-in"";
            case OutOnly:
                return ""http://www.w3.org/ns/wsdl/out-only"";
            case OutOptionalIn:
                return ""http://www.w3.org/ns/wsdl/out-optional_in"";
            case RobustInOnly:
                return ""http://www.w3.org/ns/wsdl/robust-in-only"";
            case RobustOutOnly:
                return ""http://www.w3.org/ns/wsdl/robust-out-only"";
            default:
                throw new IllegalArgumentException(""Unknown message exchange pattern: "" + this);
        }
    }
    /**
     * Return true if there can be an IN message
     */
    public boolean isInCapable() {
        switch (this) {
            case OutOnly:
            case RobustOutOnly:
                return true;
            default:
                return false;
        }
    }
    /**
     * Return true if there can be an OUT message
     */
    public boolean isOutCapable() {
        switch (this) {
            case InOnly:
            case RobustInOnly:
                return false;
            default:
                return true;
        }
    }
    /**
     * Return true if there can be a FAULT message
     */
    public boolean isFaultCapable() {
        switch (this) {
            case InOnly:
            case OutOnly:
                return false;
            default:
                return true;
        }
    }
    /**
     * Converts the WSDL URI into a {@link ExchangePattern} instance
     */
    public static ExchangePattern fromWsdlUri(String wsdlUri) {
        return map.get(wsdlUri);
    }
    static {
        for (ExchangePattern mep : values()) {
            String uri = mep.getWsdlUri();
            map.put(uri, mep);
            String name = uri.substring(uri.lastIndexOf('/'));
            map.put(""http://www.w3.org/2004/08/wsdl/"" + name, mep);
            map.put(""http://www.w3.org/2006/01/wsdl/"" + name, mep);
        }
    }
}
"
org.apache.camel.ExchangePatternTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import junit.framework.TestCase;
/**
 * @version $Revision: 1.1 $
 */
public class ExchangePatternTest extends TestCase {
    public void testExchangePattern() throws Exception {
        ExchangePattern mep = ExchangePattern.InOut;
        assertEquals(""WSDL Uri"", ""http://www.w3.org/ns/wsdl/in-out"", mep.getWsdlUri());
    }
    public void testStringToMEP() throws Exception {
        ExchangePattern mep = ExchangePattern.fromWsdlUri(""http://www.w3.org/ns/wsdl/in-only"");
        assertEquals(""MEP"", ExchangePattern.InOnly, mep);
    }
}
"
org.apache.camel.ExchangeTestSupport,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.impl.DefaultExchange;
/**
 * A base class for a test which requires a {@link CamelContext} and
 * a populated {@link Exchange}
 *
 * @version $Revision: 1.1 $
 */
public class ExchangeTestSupport extends ContextTestSupport {
    protected Exchange exchange;
    /**
     * A factory method to create an Exchange implementation
     */
    protected Exchange createExchange() {
        return new DefaultExchange(context);
    }
    /**
     * A strategy method to populate an exchange with some example values for use
     * by language plugins
     */
    protected void populateExchange(Exchange exchange) {
        Message in = exchange.getIn();
        in.setHeader(""foo"", ""abc"");
        in.setHeader(""bar"", 123);
        in.setBody(""<hello id='m123'>world!</hello>"");
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        exchange = createExchange();
        assertNotNull(""No exchange created!"", exchange);
        populateExchange(exchange);
    }
}
"
org.apache.camel.ExpectedBodyTypeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Thrown if the body could not be converted to the required type
 * 
 * @version $Revision: 1.1 $
 */
public class ExpectedBodyTypeException extends RuntimeCamelException {
    private final Exchange exchange;
    private final Class expectedBodyType;
    public ExpectedBodyTypeException(Exchange exchange, Class expectedBodyType) {
        super(""Could not extract IN message body as type: "" + expectedBodyType + "" body is: ""
              + exchange.getIn().getBody());
        this.exchange = exchange;
        this.expectedBodyType = expectedBodyType;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public Class getExpectedBodyType() {
        return expectedBodyType;
    }
}
"
org.apache.camel.Expression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An <a href=""http://activemq.apache.org/camel/expression.html"">expression</a>
 * provides a plugin strategy for evaluating expressions on a message exchange to support things like
 * <a href=""http://activemq.apache.org/camel/scripting-languages.html"">scripting languages</a>,
 * <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery</a>
 * or <a href=""http://activemq.apache.org/camel/sql.html"">SQL</a> as well
 * as any arbitrary Java expression.
 *
 *
 * @version $Revision: $
 */
public interface Expression<E extends Exchange> {
    /**
     * Returns the value of the expression on the given exchange
     *
     * @param exchange the message exchange on which to evaluate the expression
     * @return the value of the expression
     */
    Object evaluate(E exchange);
}
"
org.apache.camel.FailedToCreateProducerException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * @version $Revision: 563607 $
 */
public class FailedToCreateProducerException extends RuntimeCamelException {
    private final Endpoint endpoint;
    public FailedToCreateProducerException(Endpoint endpoint, Throwable cause) {
        super(""Failed to create Producer for endpoint: "" + endpoint + "". Reason: "" + cause, cause);
        this.endpoint = endpoint;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
}
"
org.apache.camel.Header,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being a header on an inbound {@link Message}
 *
 * @see Message#getHeader(String) 
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Header {
    String name();
}
"
org.apache.camel.Headers,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being an injection point of the headers of an inbound {@link Message}
 *
 * @see Message#getHeaders()
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Headers {
}
"
org.apache.camel.InjectorDefaultsToReflectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import junit.framework.TestCase;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.ReflectionInjector;
import org.apache.camel.spi.Injector;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 563607 $
 */
public class InjectorDefaultsToReflectionTest extends TestCase {
    private static final transient Log LOG = LogFactory.getLog(InjectorDefaultsToReflectionTest.class);
    public void testInjectorIsReflectionByDefault() throws Exception {
        Injector injector = new DefaultCamelContext().getInjector();
        assertTrue(""Injector should be reflection based but was: "" + injector,
                   injector instanceof ReflectionInjector);
        LOG.debug(""Found injector: "" + injector);
    }
}
"
org.apache.camel.InvalidHeaderTypeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * @version $Revision: 563607 $
 */
public class InvalidHeaderTypeException extends RuntimeCamelException {
    private static final long serialVersionUID = -8417806626073055262L;
    private final Object headerValue;
    public InvalidHeaderTypeException(Throwable cause, Object headerValue) {
        super(cause.getMessage() + "" headerValue is: "" + headerValue + "" of type: "" + typeName(headerValue),
              cause);
        this.headerValue = headerValue;
    }
    public InvalidHeaderTypeException(String message, Object headerValue) {
        super(message);
        this.headerValue = headerValue;
    }
    /**
     * Returns the actual header value
     */
    public Object getHeaderValue() {
        return headerValue;
    }
    protected static String typeName(Object headerValue) {
        return (headerValue != null) ? headerValue.getClass().getName() : ""null"";
    }
}
"
org.apache.camel.InvalidPayloadException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * @version $Revision: 1.1 $
 */
public class InvalidPayloadException extends CamelExchangeException {
    private final Class<?> type;
    public InvalidPayloadException(Exchange exchange, Class<?> type) {
        super(""No in body available of type: "" + type.getName()
              + NoSuchPropertyException.valueDescription(exchange.getIn().getBody()), exchange);
        this.type = type;
    }
    /**
     * The expected type of the body
     */
    public Class<?> getType() {
        return type;
    }
}
"
org.apache.camel.InvalidTypeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * @version $Revision: 1.1 $
 */
public class InvalidTypeException extends CamelExchangeException {
    private final Object value;
    private final Class<?> type;
    public InvalidTypeException(Exchange exchange, Object value, Class<?> type) {
        super(""Could not convert value: "" + value + "" to type: "" + type.getName()
              + NoSuchPropertyException.valueDescription(value), exchange);
        this.value = value;
        this.type = type;
    }
    /**
     * The value
     */
    public Object getValue() {
        return value;
    }
    /**
     * The expected type of the value
     */
    public Class<?> getType() {
        return type;
    }
}
"
org.apache.camel.LanguageTestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.impl.DefaultExchange;
/**
 * A useful base class for testing the language plugins in Camel
 * @version $Revision: $
 */
public abstract class LanguageTestSupport extends ExchangeTestSupport {
    protected abstract String getLanguageName();
    /**
     * Asserts that the given predicate expression evaluated on the current language and message
     * exchange evaluates to true
     */
    protected void assertPredicate(String expression) {
        assertPredicate(exchange, expression, true);
    }
    /**
     * Asserts that the given predicate expression evaluated on the current language and message
     * exchange evaluates to the expected value
     */
    protected void assertPredicate(String expression, boolean expected) {
        assertPredicate(exchange, expression, expected);
    }
    protected void assertPredicate(Exchange exchange, String expression, boolean expected) {
        assertPredicate(getLanguageName(), expression, exchange, expected);
    }
    /**
     * Asserts that this language expression evaluates to the given value on the given exchange
     */
    protected void assertExpression(Exchange exchange, String expressionText, Object expectedValue) {
        assertExpression(exchange, getLanguageName(), expressionText, expectedValue);
    }
    /**
     * Asserts that this language expression evaluates to the given value on the current exchange
     */
    protected void assertExpression(String expressionText, Object expectedValue) {
        assertExpression(exchange, expressionText, expectedValue);
    }
}
"
org.apache.camel.Message,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import org.apache.camel.impl.MessageSupport;
import java.util.Map;
/**
 * Implements the <a
 * href=""http://activemq.apache.org/camel/message.html"">Message</a> pattern and
 * represents an inbound or outbound message as part of an {@link Exchange}
 * 
 * @version $Revision: 567570 $
 */
public interface Message {
    /**
     * @return the id of the message
     */
    String getMessageId();
    /**
     * set the id of the message
     * 
     * @param messageId
     */
    void setMessageId(String messageId);
    /**
     * Returns the exchange this message is related to
     * 
     * @return
     */
    Exchange getExchange();
    /**
     * Accesses a specific header
     * 
     * @param name
     * @return object header associated with the name
     */
    Object getHeader(String name);
    /**
     * Returns a header associated with this message by name and specifying the
     * type required
     * 
     * @param name the name of the header
     * @param type the type of the header
     * @return the value of the given header or null if there is no property for
     *         the given name or it cannot be converted to the given type
     */
    <T> T getHeader(String name, Class<T> type);
    /**
     * Sets a header on the message
     * 
     * @param name of the header
     * @param value to associate with the name
     */
    void setHeader(String name, Object value);
    /**
     * Removes the named header from this message
     *
     * @param name
     * @return the old value of the header
     */
    Object removeHeader(String name);
    /**
     * Returns all of the headers associated with the message
     * 
     * @return all the headers in a Map
     */
    Map<String, Object> getHeaders();
    /**
     * Set all the headers associated with this message
     * 
     * @param headers
     */
    void setHeaders(Map<String, Object> headers);
    /**
     * Returns the body of the message as a POJO
     * 
     * @return the body of the message
     */
    Object getBody();
    /**
     * Returns the body as the specified type
     * 
     * @param type the type that the body
     * @return the body of the message as the specified type
     */
    <T> T getBody(Class<T> type);
    /**
     * Sets the body of the message
     */
    void setBody(Object body);
    /**
     * Sets the body of the message as a specific type
     */
    <T> void setBody(Object body, Class<T> type);
    /**
     * Creates a copy of this message so that it can be used and possibly
     * modified further in another exchange
     * 
     * @return a new message instance copied from this message
     */
    Message copy();
    /**
     * Copies the contents of the other message into this message
     */
    void copyFrom(Message message);
}
"
org.apache.camel.MessageDriven,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to indicate a method on a POJO which is used as a {@link Consumer} of
 * {@link Exchange} instances to process {@link Message} instances.
 * 
 * Either a <a href=""http://activemq.apache.org/camel/uris.html"">URI</a> for an
 * endpoint should be configured, or a name of an endpoint which refers to a
 * Spring bean name in your Spring ApplicationContext.
 * 
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface MessageDriven {
    String uri() default """";
    String name() default """";
}
"
org.apache.camel.NoSuchEndpointException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception thrown if a routing processor such as a
 * {@link RecipientList} is unable to resolve an {@link Endpoint} from a URI.
 * 
 * @version $Revision: 563607 $
 */
public class NoSuchEndpointException extends RuntimeCamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String uri;
    public NoSuchEndpointException(String uri) {
        super(""No endpoint could be found for: "" + uri);
        this.uri = uri;
    }
    public String getUri() {
        return uri;
    }
}
"
org.apache.camel.NoSuchLanguageException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception thrown if an attempt is made to resolve an unknown
 * language definition.
 * 
 * @see org.apache.camel.CamelContext#resolveLanguage(String)
 * 
 * @version $Revision: 563607 $
 */
public class NoSuchLanguageException extends RuntimeCamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String language;
    public NoSuchLanguageException(String language) {
        super(""No language could be found for: "" + language);
        this.language = language;
    }
    public String getLanguage() {
        return language;
    }
}
"
org.apache.camel.NoSuchPropertyException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An exception caused when a mandatory property is not available on a message
 * {@link Exchange}
 * 
 * @see ExchangeHelper#getMandatoryProperty(Exchange, String, Class)
 * 
 * @version $Revision: 563607 $
 */
public class NoSuchPropertyException extends CamelExchangeException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final String propertyName;
    private final Class<?> type;
    public NoSuchPropertyException(Exchange exchange, String propertyName, Class<?> type) {
        super(""No '"" + propertyName + ""' property available of type: "" + type.getName()
              + reason(exchange, propertyName), exchange);
        this.propertyName = propertyName;
        this.type = type;
    }
    public String getPropertyName() {
        return propertyName;
    }
    public Class<?> getType() {
        return type;
    }
    protected static String reason(Exchange exchange, String propertyName) {
        Object value = exchange.getProperty(propertyName);
        return valueDescription(value);
    }
    static String valueDescription(Object value) {
        if (value == null) {
            return """";
        }
        return "" but has value: "" + value + "" of type: "" + value.getClass().getName();
    }
}
"
org.apache.camel.NoTypeConversionAvailableException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * An exception thrown if a value could not be converted to the required type
 * 
 * @version $Revision: 563607 $
 */
public class NoTypeConversionAvailableException extends RuntimeCamelException {
    private final Object value;
    private final Class type;
    public NoTypeConversionAvailableException(Object value, Class type) {
        super(""No converter available to convert value: "" + value + "" to the required type: ""
              + type.getName());
        this.value = value;
        this.type = type;
    }
    /**
     * Returns the value which could not be converted
     * 
     * @return the value that could not be converted
     */
    public Object getValue() {
        return value;
    }
    /**
     * Returns the required type
     * 
     * @return the required type
     */
    public Class getType() {
        return type;
    }
}
"
org.apache.camel.PollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Represents a <a
 * href=""http://activemq.apache.org/camel/polling-consumer.html"">Polling
 * Consumer</a> where the caller polls for messages when it is ready.
 * 
 * @version $Revision: 1.1 $
 */
public interface PollingConsumer<E extends Exchange> extends Consumer<E> {
    /**
     * Waits until a message is available and then returns it. Warning that this
     * method could block indefinitely if no messages are available.
     * 
     * @return the message exchange received.
     */
    E receive();
    /**
     * Attempts to receive a message exchange immediately without waiting and
     * returning null if a message exchange is not available yet.
     * 
     * @return the message exchange if one is immediately available otherwise
     *         null
     */
    E receiveNoWait();
    /**
     * Attempts to receive a message exchange, waiting up to the given timeout
     * to expire if a message is not yet available
     * 
     * @param timeout the amount of time in milliseconds to wait for a message
     *                before timing out and returning null
     * 
     * @return the message exchange if one iwas available within the timeout
     *         period, or null if the timeout expired
     */
    E receive(long timeout);
}
"
org.apache.camel.Predicate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Evaluates a binary <a
 * href=""http://activemq.apache.org/camel/predicate.html"">predicate</a> on the
 * message exchange to support things like <a
 * href=""http://activemq.apache.org/camel/scripting-languages.html"">scripting
 * languages</a>, <a href=""http://activemq.apache.org/camel/xquery.html"">XQuery</a>
 * or <a href=""http://activemq.apache.org/camel/sql.html"">SQL</a> as well as
 * any arbitrary Java expression.
 * 
 * @version $Revision: 563607 $
 */
public interface Predicate<E> {
    /**
     * Evaluates the predicate on the message exchange and returns true if this
     * exchange matches the predicate
     * 
     * @param exchange the message exchange
     * @return true if the predicate matches
     */
    boolean matches(E exchange);
    /**
     * Allows this predicate to be used nicely in testing to generate a nicely
     * formatted exception and message if this predicate does not match for the
     * given exchange.
     * 
     * @param text the description to use in the exception message
     * @param exchange the exchange to evaluate the expression on
     * @throws AssertionError if the predicate does not match
     */
    void assertMatches(String text, E exchange) throws AssertionError;
}
"
org.apache.camel.Processor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A <a href=""http://activemq.apache.org/camel/processor.html"">processor</a> is
 * used to implement the <a
 * href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event
 * Driven Consumer</a> and <a
 * href=""http://activemq.apache.org/camel/message-translator.html"">Message
 * Translater</a> patterns and to process message exchanges.
 * 
 * @version $Revision: 580990 $
 */
public interface Processor {
    /**
     * Processes the message exchange
     * 
     * @throws Exception if an internal processing error has occurred.
     */
    void process(Exchange exchange) throws Exception;
}
"
org.apache.camel.Producer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Provides a channel on which clients can create and invoke message exchanges
 * on an {@link Endpoint}
 * 
 * @version $Revision: 572712 $
 */
public interface Producer<E extends Exchange> extends Processor, Service {
    Endpoint<E> getEndpoint();
    /**
     * Creates a new exchange to send to this endpoint
     * 
     * @return a newly created exchange
     */
    E createExchange();
    /**
     * Creates a new exchange of the given pattern to send to this endpoint
     *
     * @return a newly created exchange
     */
    E createExchange(ExchangePattern pattern);
    /**
     * Creates a new exchange for communicating with this exchange using the
     * given exchange to pre-populate the values of the headers and messages
     */
    E createExchange(E exchange);
}
"
org.apache.camel.ProducerTemplate,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.Map;
/**
 * @version $Revision: $
 */
public interface ProducerTemplate<E extends Exchange> extends Service {
    /**
     * Sends the exchange to the default endpoint
     *
     * @param exchange the exchange to send
     */
    E send(E exchange);
    /**
     * Sends an exchange to the default endpoint using a supplied
     *
     * @param processor the transformer used to populate the new exchange
     * @{link Processor} to populate the exchange
     */
    E send(Processor processor);
    /**
     * Sends the body to the default endpoint and returns the result content
     *
     * @param body the body to send
     * @return the returned message body
     */
    Object sendBody(Object body);
    /**
     * Sends the body to the default endpoint with a specified header and header
     * value
     *
     * @param body        the payload send
     * @param header      the header name
     * @param headerValue the header value
     * @return the result
     */
    Object sendBodyAndHeader(Object body, String header, Object headerValue);
    /**
     * Sends the body to the default endpoint with the specified headers and
     * header values
     *
     * @param body the payload send
     * @return the result
     */
    Object sendBodyAndHeaders(Object body, Map<String, Object> headers);
    // Allow sending to arbitrary endpoints
    // -----------------------------------------------------------------------
    /**
     * Sends the exchange to the given endpoint
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param exchange    the exchange to send
     */
    E send(String endpointUri, E exchange);
    /**
     * Sends an exchange to an endpoint using a supplied
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param processor   the transformer used to populate the new exchange
     * @{link Processor} to populate the exchange
     */
    E send(String endpointUri, Processor processor);
    /**
     * Sends an exchange to an endpoint using a supplied
     *
     * @param endpointUri the endpoint URI to send the exchange to
     * @param pattern     the message {@link ExchangePattern} such as
     *                    {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param processor   the transformer used to populate the new exchange
     * @{link Processor} to populate the exchange
     */
    E send(String endpointUri, ExchangePattern pattern, Processor processor);
    /**
     * Sends the exchange to the given endpoint
     *
     * @param endpoint the endpoint to send the exchange to
     * @param exchange the exchange to send
     */
    E send(Endpoint<E> endpoint, E exchange);
    /**
     * Sends an exchange to an endpoint using a supplied
     *
     * @param endpoint  the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     * @{link Processor} to populate the exchange
     */
    E send(Endpoint<E> endpoint, Processor processor);
    /**
     * Sends an exchange to an endpoint using a supplied
     *
     * @param endpoint  the endpoint to send the exchange to
     * @param pattern   the message {@link ExchangePattern} such as
     *                  {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param processor the transformer used to populate the new exchange
     * @{link Processor} to populate the exchange
     */
    E send(Endpoint<E> endpoint, ExchangePattern pattern, Processor processor);
    /**
     * Send the body to an endpoint
     *
     * @param endpoint
     * @param body     = the payload
     * @return the result
     */
    Object sendBody(Endpoint<E> endpoint, Object body);
    /**
     * Send the body to an endpoint
     *
     * @param endpointUri
     * @param body        = the payload
     * @return the result
     */
    Object sendBody(String endpointUri, Object body);
    /**
     * Send the body to an endpoint with the given {@link ExchangePattern}
     * returning any result output body
     *
     * @param endpoint
     * @param body = the payload
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @return the result
     */
    Object sendBody(Endpoint<E> endpoint, ExchangePattern pattern, Object body);
    /**
     * Send the body to an endpoint
     *
     * @param endpointUri
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body = the payload
     * @return the result
     */
    Object sendBody(String endpointUri, ExchangePattern pattern, Object body);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpointUri the endpoint URI to send to
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    Object sendBodyAndHeader(String endpointUri, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpoint the Endpoint to send to
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    Object sendBodyAndHeader(Endpoint endpoint, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpoint the Endpoint to send to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    Object sendBodyAndHeader(Endpoint endpoint, ExchangePattern pattern, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with a specified header and header value
     *
     * @param endpoint the Endpoint URI to send to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param body the payload send
     * @param header the header name
     * @param headerValue the header value
     * @return the result
     */
    Object sendBodyAndHeader(String endpoint, ExchangePattern pattern, Object body, String header,
                                    Object headerValue);
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values
     *
     * @param endpointUri the endpoint URI to send to
     * @param body the payload send
     * @return the result
     */
    Object sendBodyAndHeaders(String endpointUri, Object body, Map<String, Object> headers);
    /**
     * Sends the body to an endpoint with the specified headers and header
     * values
     *
     * @param endpoint the endpoint URI to send to
     * @param body the payload send
     * @return the result
     */
    Object sendBodyAndHeaders(Endpoint endpoint, Object body, Map<String, Object> headers);
    // Methods using an InOut ExchangePattern
    // -----------------------------------------------------------------------
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param processor the processor which will populate the exchange before sending
     * @return the result
     */
    E request(Endpoint<E> endpoint, Processor processor);
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param body     = the payload
     * @return the result
     */
    Object requestBody(Endpoint<E> endpoint, Object body);
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param body     = the payload
     * @param header
     * @param headerValue
     * @return the result
     */
    Object requestBodyAndHeader(Endpoint<E> endpoint, Object body, String header, Object headerValue);
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param processor the processor which will populate the exchange before sending
     * @return the result
     */
    E request(String endpoint, Processor processor);
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param body     = the payload
     * @return the result
     */
    Object requestBody(String endpoint, Object body);
    /**
     * Send the body to an endpoint returning any result output body
     *
     * @param endpoint
     * @param body     = the payload
     * @param header
     * @param headerValue
     * @return the result
     */
    Object requestBodyAndHeader(String endpoint, Object body, String header, Object headerValue);
}
"
org.apache.camel.Properties,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being an injection point of the properties of an {@link Exchange}
 *
 * @see Exchange#getProperties()  
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Properties {
}
"
org.apache.camel.Property,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Marks a parameter as being an injection point of a property of an {@link Exchange}
 *
 * @see Exchange#getProperty(String)  
 * @version $Revision: 523756 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface Property {
    String name();
}
"
org.apache.camel.ResolveEndpointFailedException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception thrown if an {@link Endpoint} can not be resolved via URI
 * 
 * @version $Revision: 563607 $
 */
public class ResolveEndpointFailedException extends RuntimeCamelException {
    private final String uri;
    public ResolveEndpointFailedException(String uri, Throwable cause) {
        super(""Failed to resolve endpoint: "" + uri + "" due to: "" + cause, cause);
        this.uri = uri;
    }
    public String getUri() {
        return uri;
    }
}
"
org.apache.camel.Route,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/**
 * A <a href=""http://activemq.apache.org/camel/routes.html"">Route</a>
 * defines the processing used on an inbound message exchange
 * from a specific {@see Endpoint} within a {@link CamelContext}
 *
 * @version $Revision: 563607 $
 */
public class Route<E extends Exchange> {
    private final Map<String, Object> properties = new HashMap<String, Object>(16);
    private Endpoint<E> endpoint;
    private List<Service> services = new ArrayList<Service>();
    public Route(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    public Route(Endpoint<E> endpoint, Service... services) {
        this(endpoint);
        for (Service service : services) {
            addService(service);
        }
    }
    @Override
    public String toString() {
        return ""Route"";
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    /**
     * This property map is used to associate information about
     * the route.
     *
     * @return
     */
    public Map<String, Object> getProperties() {
        return properties;
    }
    public List<Service> getServicesForRoute() throws Exception {
        List<Service> servicesForRoute = new ArrayList<Service>(getServices());
        addServices(servicesForRoute);
        return servicesForRoute;
    }
    /**
     * Returns the additional services required for this particular route
     */
    public List<Service> getServices() {
        return services;
    }
    public void setServices(List<Service> services) {
        this.services = services;
    }
    public void addService(Service service) {
        getServices().add(service);
    }
    /**
     * Strategy method to allow derived classes to lazily load services for the route
     */
    protected void addServices(List<Service> services) throws Exception {
    }
}
"
org.apache.camel.RuntimeCamelException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * @version $Revision: 563607 $
 */
public class RuntimeCamelException extends RuntimeException {
    private static final long serialVersionUID = 8046489554418284257L;
    public RuntimeCamelException() {
    }
    public RuntimeCamelException(String message) {
        super(message);
    }
    public RuntimeCamelException(String message, Throwable cause) {
        super(message, cause);
    }
    public RuntimeCamelException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.RuntimeExchangeException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A runtime exception caused by a specific message {@ilnk Exchange}
 *
 * @version $Revision: 1.1 $
 */
public class RuntimeExchangeException extends RuntimeCamelException {
    private static final long serialVersionUID = -8721487431101572630L;
    private final Exchange exchange;
    public RuntimeExchangeException(String message, Exchange exchange) {
        super(message + "" on the exchange: "" +  exchange);
        this.exchange = exchange;
    }
    public RuntimeExchangeException(Exception e, Exchange exchange) {
        super(e.getMessage(), e);
        this.exchange = exchange;
    }
    /**
     * Returns the exchange which caused the exception
     *
     * @return the exchange which caused the exception
     */
    public Exchange getExchange() {
        return exchange;
    }
}
"
org.apache.camel.RuntimeExpressionException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Thrown if an expression evaluation fails
 * 
 * @version $Revision: 563607 $
 */
public class RuntimeExpressionException extends RuntimeCamelException {
    private static final long serialVersionUID = -8417806626073055262L;
    public RuntimeExpressionException(String message) {
        super(message);
    }
    public RuntimeExpressionException(String message, Throwable cause) {
        super(message, cause);
    }
    public RuntimeExpressionException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.RuntimeTransformException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Thrown if a message transformation fails
 * 
 * @version $Revision: 521156 $
 */
public class RuntimeTransformException extends RuntimeCamelException {
    private static final long serialVersionUID = -8417806626073055262L;
    public RuntimeTransformException(String message) {
        super(message);
    }
    public RuntimeTransformException(String message, Throwable cause) {
        super(message, cause);
    }
    public RuntimeTransformException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.Service,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * Represents the core lifecycle API for POJOs which can be started and stopped
 * 
 * @version $Revision: 563607 $
 */
public interface Service {
    /**
     * Starts the service
     * 
     * @throws Exception
     */
    void start() throws Exception;
    /**
     * Stops the service
     * 
     * @throws Exception
     */
    void stop() throws Exception;
}
"
org.apache.camel.TestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
import java.util.List;
import junit.framework.TestCase;
import org.apache.camel.builder.Builder;
import org.apache.camel.builder.ValueBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.processor.DelegateAsyncProcessor;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A bunch of useful testing methods
 * 
 * @version $Revision: 581937 $
 */
public abstract class TestSupport extends TestCase {
    protected transient Log log = LogFactory.getLog(getClass());
    // Builder methods for expressions used when testing
    // -------------------------------------------------------------------------
    /**
     * Returns a value builder for the given header
     */
    public <E extends Exchange> ValueBuilder<E> header(String name) {
        return Builder.header(name);
    }
    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public ValueBuilder body() {
        return Builder.body();
    }
    /**
     * Returns a predicate and value builder for the inbound message body as a
     * specific type
     */
    public <T> ValueBuilder bodyAs(Class<T> type) {
        return Builder.bodyAs(type);
    }
    /**
     * Returns a predicate and value builder for the outbound body on an
     * exchange
     */
    public ValueBuilder outBody() {
        return Builder.outBody();
    }
    /**
     * Returns a predicate and value builder for the outbound message body as a
     * specific type
     */
    public <T> ValueBuilder outBodyAs(Class<T> type) {
        return Builder.outBodyAs(type);
    }
    /**
     * Returns a predicate and value builder for the fault body on an
     * exchange
     */
    public ValueBuilder faultBody() {
        return Builder.faultBody();
    }
    /**
     * Returns a predicate and value builder for the fault message body as a
     * specific type
     */
    public <T> ValueBuilder faultBodyAs(Class<T> type) {
        return Builder.faultBodyAs(type);
    }
    /**
     * Returns a value builder for the given system property
     */
    public ValueBuilder systemProperty(String name) {
        return Builder.systemProperty(name);
    }
    /**
     * Returns a value builder for the given system property
     */
    public ValueBuilder systemProperty(String name, String defaultValue) {
        return Builder.systemProperty(name, defaultValue);
    }
    // Assertions
    // -----------------------------------------------------------------------
    protected <T> T assertIsInstanceOf(Class<T> expectedType, Object value) {
        assertNotNull(""Expected an instance of type: "" + expectedType.getName() + "" but was null"", value);
        assertTrue(""object should be a "" + expectedType.getName() + "" but was: "" + value + "" with type: ""
                   + value.getClass().getName(), expectedType.isInstance(value));
        return expectedType.cast(value);
    }
    protected void assertEndpointUri(Endpoint<Exchange> endpoint, String uri) {
        assertNotNull(""Endpoint is null when expecting endpoint for: "" + uri, endpoint);
        assertEquals(""Endoint uri for: "" + endpoint, uri, endpoint.getEndpointUri());
    }
    /**
     * Asserts the In message on the exchange contains the expected value
     */
    protected Object assertInMessageHeader(Exchange exchange, String name, Object expected) {
        return assertMessageHeader(exchange.getIn(), name, expected);
    }
    /**
     * Asserts the Out message on the exchange contains the expected value
     */
    protected Object assertOutMessageHeader(Exchange exchange, String name, Object expected) {
        return assertMessageHeader(exchange.getOut(), name, expected);
    }
    /**
     * Asserts that the given exchange has an OUT message of the given body value
     * @param exchange the exchange which should have an OUT message
     * @param expected the expected value of the OUT message
     * @throws InvalidPayloadException
     */
    protected void assertOutMessageBodyEquals(Exchange exchange, Object expected) throws InvalidPayloadException {
        assertNotNull(""Should have a response exchange!"", exchange);
        Object actual;
        if (expected == null) {
            actual = ExchangeHelper.getMandatoryOutBody(exchange);
            assertEquals(""output body of: "" + exchange, expected, actual);
        }
        else {
            actual = ExchangeHelper.getMandatoryOutBody(exchange, expected.getClass());
        }
        assertEquals(""output body of: "" + exchange, expected, actual);
        log.debug(""Received response: "" + exchange + "" with out: "" + exchange.getOut());
    }
    protected Object assertMessageHeader(Message message, String name, Object expected) {
        Object value = message.getHeader(name);
        assertEquals(""Header: "" + name + "" on Message: "" + message, expected, value);
        return value;
    }
    /**
     * Asserts that the given expression when evaluated returns the given answer
     */
    protected Object assertExpression(Expression expression, Exchange exchange, Object expected) {
        Object value = expression.evaluate(exchange);
        // lets try convert to the type of the expected
        if (expected != null) {
            value = ExchangeHelper.convertToType(exchange, expected.getClass(), value);
        }
        log.debug(""Evaluated expression: "" + expression + "" on exchange: "" + exchange + "" result: "" + value);
        assertEquals(""Expression: "" + expression + "" on Exchange: "" + exchange, expected, value);
        return value;
    }
    /**
     * Asserts that the predicate returns the expected value on the exchange
     */
    protected void assertPredicateMatches(Predicate predicate, Exchange exchange) {
        assertPredicate(predicate, exchange, true);
    }
    /**
     * Asserts that the predicate returns the expected value on the exchange
     */
    protected void assertPredicateDoesNotMatch(Predicate predicate, Exchange exchange) {
        try {
            predicate.assertMatches(""Predicate should match"", exchange);
        } catch (AssertionError e) {
            log.debug(""Caught expected assertion error: "" + e);
        }
        assertPredicate(predicate, exchange, false);
    }
    /**
     * Asserts that the predicate returns the expected value on the exchange
     */
    protected boolean assertPredicate(Predicate predicate, Exchange exchange, boolean expected) {
        if (expected) {
            predicate.assertMatches(""Predicate failed"", exchange);
        }
        boolean value = predicate.matches(exchange);
        log.debug(""Evaluated predicate: "" + predicate + "" on exchange: "" + exchange + "" result: "" + value);
        assertEquals(""Predicate: "" + predicate + "" on Exchange: "" + exchange, expected, value);
        return value;
    }
    /**
     * Resolves an endpoint and asserts that it is found
     */
    protected Endpoint resolveMandatoryEndpoint(CamelContext context, String uri) {
        Endpoint endpoint = context.getEndpoint(uri);
        assertNotNull(""No endpoint found for URI: "" + uri, endpoint);
        return endpoint;
    }
    /**
     * Resolves an endpoint and asserts that it is found
     */
    protected <T extends Endpoint> T resolveMandatoryEndpoint(CamelContext context, String uri,
                                                              Class<T> endpointType) {
        T endpoint = context.getEndpoint(uri, endpointType);
        assertNotNull(""No endpoint found for URI: "" + uri, endpoint);
        return endpoint;
    }
    /**
     * Creates an exchange with the given body
     */
    protected Exchange createExchangeWithBody(CamelContext camelContext, Object body) {
        Exchange exchange = new DefaultExchange(camelContext);
        Message message = exchange.getIn();
        message.setHeader(""testName"", getName());
        message.setHeader(""testClass"", getClass().getName());
        message.setBody(body);
        return exchange;
    }
    protected <T> T assertOneElement(List<T> list) {
        assertEquals(""Size of list should be 1: "" + list, 1, list.size());
        return list.get(0);
    }
    /**
     * Asserts that a list is of the given size
     */
    protected <T> List<T> assertListSize(List<T> list, int size) {
        assertEquals(""List should be of size: "" + size + "" but is: "" + list, size, list.size());
        return list;
    }
    /**
     * A helper method to create a list of Route objects for a given route builder
     */
    protected List<Route> getRouteList(RouteBuilder builder) throws Exception {
        CamelContext context = new DefaultCamelContext();
        context.addRoutes(builder);
        context.start();
        List<Route> answer = context.getRoutes();
        context.stop();
        return answer;
    }
    /**
     * Asserts that the text contains the given string
     *
     * @param text the text to compare
     * @param containedText the text which must be contained inside the other text parameter
     */
    protected void assertStringContains(String text, String containedText) {
        assertNotNull(""Text should not be null!"", text);
        assertTrue(""Text: "" + text + "" does not contain: "" + containedText, text.contains(containedText));
    }
    /**
     * If a processor is wrapped with a bunch of DelegateProcessor or DelegateAsyncProcessor objects
     * this call will drill through them and return the wrapped Processor.
     * 
     * @param processor
     * @return
     */
    protected Processor unwrap(Processor processor) {
        while( true ) {
            if( processor instanceof DelegateAsyncProcessor ) {
                processor = ((DelegateAsyncProcessor)processor).getProcessor();
            } else if( processor instanceof DelegateProcessor ) {
                processor = ((DelegateProcessor)processor).getProcessor();
            } else {
                return processor;
            }
        }
    }
}
"
org.apache.camel.TypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * A pluggable strategy to be able to convert objects <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">to different
 * types</a> such as to and from String, InputStream/OutputStream,
 * Reader/Writer, Document, byte[], ByteBuffer etc
 * 
 * @version $Revision: 563607 $
 */
public interface TypeConverter {
    /**
     * Converts the value to the specified type
     * 
     * @param type the requested type
     * @param value the value to be converted
     * @return the converted value or null if it can not be converted
     */
    <T> T convertTo(Class<T> type, Object value);
}
"
org.apache.camel.ValidationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel;
/**
 * The base class for any validation exception, such as
 * {@link org.apache.camel.processor.validation.SchemaValidationException} so
 * that it is easy to treat all validation errors in a similar way irrespective
 * of the particular validation technology used.
 * 
 * @version $Revision: $
 */
public class ValidationException extends CamelExchangeException {
    public ValidationException(Exchange exchange, String message) {
        super(message, exchange);
    }
}
"
org.apache.camel.builder.Builder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * A helper class for including portions of the <a
 * href=""http://activemq.apache.org/camel/expression.html"">expression</a> and
 * <a href=""http://activemq.apache.org/camel/predicate.html"">predicate</a> <a
 * href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a>
 * 
 * @version $Revision: 1.1 $
 */
public class Builder {
    /**
     * Utility classes should not have a public constructor.
     */
    private Builder() {        
    }
    /**
     * Returns a constant expression
     */
    public static <E extends Exchange> ValueBuilder<E> constant(Object value) {
        Expression<E> expression = ExpressionBuilder.constantExpression(value);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for headers on an exchange
     */
    public static <E extends Exchange> ValueBuilder<E> header(String name) {
        Expression<E> expression = ExpressionBuilder.headerExpression(name);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public static <E extends Exchange> ValueBuilder<E> body() {
        Expression<E> expression = ExpressionBuilder.bodyExpression();
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound message body as a
     * specific type
     */
    public static <E extends Exchange, T> ValueBuilder<E> bodyAs(Class<T> type) {
        Expression<E> expression = ExpressionBuilder.<E, T> bodyExpression(type);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound body on an
     * exchange
     */
    public static <E extends Exchange> ValueBuilder<E> outBody() {
        Expression<E> expression = ExpressionBuilder.outBodyExpression();
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound message body as a
     * specific type
     */
    public static <E extends Exchange, T> ValueBuilder<E> outBodyAs(Class<T> type) {
        Expression<E> expression = ExpressionBuilder.<E, T> outBodyExpression(type);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the fault body on an
     * exchange
     */
    public static <E extends Exchange> ValueBuilder<E> faultBody() {
        Expression<E> expression = ExpressionBuilder.faultBodyExpression();
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns a predicate and value builder for the fault message body as a
     * specific type
     */
    public static <E extends Exchange, T> ValueBuilder<E> faultBodyAs(Class<T> type) {
        Expression<E> expression = ExpressionBuilder.<E, T> faultBodyExpression(type);
        return new ValueBuilder<E>(expression);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> ValueBuilder<E> systemProperty(final String name) {
        return systemProperty(name, null);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> ValueBuilder<E> systemProperty(final String name,
                                                                      final String defaultValue) {
        return new ValueBuilder<E>(ExpressionBuilder.<E> systemProperty(name, defaultValue));
    }
}
"
org.apache.camel.builder.BuilderSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.processor.LoggingLevel;
import org.apache.camel.processor.SendProcessor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Base class for implementation inheritance for different clauses in the <a
 * href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a>
 * 
 * @version $Revision: $
 */
public abstract class BuilderSupport {
    private CamelContext context;
    private ErrorHandlerBuilder errorHandlerBuilder;
    private boolean inheritErrorHandler = true;
    protected BuilderSupport(CamelContext context) {
        this.context = context;
    }
    protected BuilderSupport(BuilderSupport parent) {
        this.context = parent.getContext();
        this.inheritErrorHandler = parent.inheritErrorHandler;
        if (inheritErrorHandler && parent.errorHandlerBuilder != null) {
            this.errorHandlerBuilder = parent.errorHandlerBuilder.copy();
        }
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Returns a value builder for the given header
     */
    public ValueBuilder header(String name) {
        return Builder.header(name);
    }
    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public ValueBuilder body() {
        return Builder.body();
    }
    /**
     * Returns a predicate and value builder for the inbound message body as a
     * specific type
     */
    public <T> ValueBuilder body(Class<T> type) {
        return Builder.bodyAs(type);
    }
    /**
     * Returns a predicate and value builder for the outbound body on an
     * exchange
     */
    public ValueBuilder outBody() {
        return Builder.outBody();
    }
    /**
     * Returns a predicate and value builder for the outbound message body as a
     * specific type
     */
    public <T> ValueBuilder outBody(Class<T> type) {
        return Builder.outBodyAs(type);
    }
    /**
     * Returns a predicate and value builder for the fault body on an
     * exchange
     */
    public ValueBuilder faultBody() {
        return Builder.faultBody();
    }
    /**
     * Returns a predicate and value builder for the fault message body as a
     * specific type
     */
    public <T> ValueBuilder faultBodyAs(Class<T> type) {
        return Builder.faultBodyAs(type);
    }
    /**
     * Returns a value builder for the given system property
     */
    public ValueBuilder systemProperty(String name) {
        return Builder.systemProperty(name);
    }
    /**
     * Returns a value builder for the given system property
     */
    public ValueBuilder systemProperty(String name, String defaultValue) {
        return Builder.systemProperty(name, defaultValue);
    }
    /**
     * Returns a constant expression value builder
     */
    public ValueBuilder constant(Object value) {
        return Builder.constant(value);
    }
    /**
     * Resolves the given URI to an endpoint
     * 
     * @throws NoSuchEndpointException if the endpoint URI could not be resolved
     */
    public Endpoint endpoint(String uri) throws NoSuchEndpointException {
        if (uri == null) {
            throw new IllegalArgumentException(""uri parameter cannot be null"");
        }
        Endpoint endpoint = getContext().getEndpoint(uri);
        if (endpoint == null) {
            throw new NoSuchEndpointException(uri);
        }
        return endpoint;
    }
    /**
     * Resolves the list of URIs into a list of {@link Endpoint} instances
     * 
     * @throws NoSuchEndpointException if an endpoint URI could not be resolved
     */
    public List<Endpoint> endpoints(String... uris) throws NoSuchEndpointException {
        List<Endpoint> endpoints = new ArrayList<Endpoint>();
        for (String uri : uris) {
            endpoints.add(endpoint(uri));
        }
        return endpoints;
    }
    /**
     * Helper method to create a list of {@link Endpoint} instances
     */
    public List<Endpoint> endpoints(Endpoint... endpoints) {
        List<Endpoint> answer = new ArrayList<Endpoint>();
        for (Endpoint endpoint : endpoints) {
            answer.add(endpoint);
        }
        return answer;
    }
    /**
     * Creates a disabled error handler for removing the default error handler
     */
    public NoErrorHandlerBuilder noErrorHandler() {
        return new NoErrorHandlerBuilder();
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler() {
        return new LoggingErrorHandlerBuilder();
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler(String log) {
        return loggingErrorHandler(LogFactory.getLog(log));
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler(Log log) {
        return new LoggingErrorHandlerBuilder(log);
    }
    /**
     * Creates an error handler which just logs errors
     */
    public LoggingErrorHandlerBuilder loggingErrorHandler(Log log, LoggingLevel level) {
        return new LoggingErrorHandlerBuilder(log, level);
    }
    public DeadLetterChannelBuilder deadLetterChannel() {
        return new DeadLetterChannelBuilder();
    }
    public DeadLetterChannelBuilder deadLetterChannel(String deadLetterUri) {
        return deadLetterChannel(endpoint(deadLetterUri));
    }
    public DeadLetterChannelBuilder deadLetterChannel(Endpoint deadLetterEndpoint) {
        return new DeadLetterChannelBuilder(new SendProcessor(deadLetterEndpoint));
    }
    // Properties
    // -------------------------------------------------------------------------
    public CamelContext getContext() {
        return context;
    }
    public void setContext(CamelContext context) {
        this.context = context;
    }
    public ErrorHandlerBuilder getErrorHandlerBuilder() {
        if (errorHandlerBuilder == null) {
            errorHandlerBuilder = createErrorHandlerBuilder();
        }
        return errorHandlerBuilder;
    }
    protected ErrorHandlerBuilder createErrorHandlerBuilder() {
        if (isInheritErrorHandler()) {
            return new DeadLetterChannelBuilder();
        } else {
            return new NoErrorHandlerBuilder();
        }
    }
    /**
     * Sets the error handler to use with processors created by this builder
     */
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        this.errorHandlerBuilder = errorHandlerBuilder;
    }
    public boolean isInheritErrorHandler() {
        return inheritErrorHandler;
    }
    public void setInheritErrorHandler(boolean inheritErrorHandler) {
        this.inheritErrorHandler = inheritErrorHandler;
    }
}
"
org.apache.camel.builder.ConstantProcessorBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
/**
 * @version $Revision: 563607 $
 */
public class ConstantProcessorBuilder implements ProcessorFactory {
    private Processor processor;
    public ConstantProcessorBuilder(Processor processor) {
        this.processor = processor;
    }
    public Processor createProcessor() {
        return processor;
    }
}
"
org.apache.camel.builder.DataTypeExpression,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.dataformat.ArtixDSContentType;
import org.apache.camel.model.dataformat.ArtixDSDataFormat;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.model.dataformat.JaxbDataFormat;
import org.apache.camel.model.dataformat.SerializationDataFormat;
import org.apache.camel.model.dataformat.XMLBeansDataFormat;
import org.apache.camel.spi.DataFormat;
/**
 * An expression for constructing the different possible {@link DataFormat}
 * options.
 *
 * @version $Revision: 1.1 $
 */
public class DataTypeExpression<T extends ProcessorType> {
    private final ProcessorType<T> processorType;
    private final Operation operation;
    public enum Operation {
        Marshal, Unmarshal
    };
    public DataTypeExpression(ProcessorType<T> processorType, Operation operation) {
        this.processorType = processorType;
        this.operation = operation;
    }
    /**
     * Uses the Java Serialization data format
     */
    public T serialization() {
        return dataFormat(new SerializationDataFormat());
    }
    /**
     * Uses the JAXB data format
     */
    public T jaxb() {
        return dataFormat(new JaxbDataFormat());
    }
    /**
     * Uses the JAXB data format turning pretty printing on or off
     */
    public T jaxb(boolean prettyPrint) {
        return dataFormat(new JaxbDataFormat(prettyPrint));
    }
    /**
     * Uses the JAXB data format
     */
    public T xmlBeans() {
        return dataFormat(new XMLBeansDataFormat());
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format for dealing with lots of different message formats such as SWIFT etc.
     */
    public T artixDS() {
        return dataFormat(new ArtixDSDataFormat());
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format with the specified type of ComplexDataObject
     * for marshalling and unmarshalling messages using the dataObject's default Source and Sink.
     */
    public T artixDS(Class<?> dataObjectType) {
        return dataFormat(new ArtixDSDataFormat(dataObjectType));
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format with the specified type of ComplexDataObject
     * for marshalling and unmarshalling messages using the dataObject's default Source and Sink.
     */
    public T artixDS(Class<?> elementType, ArtixDSContentType contentType) {
        return dataFormat(new ArtixDSDataFormat(elementType, contentType));
    }
    /**
     * Uses the
     * <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
     * data format with the specified content type
     * for marshalling and unmarshalling messages
     */
    public T artixDS(ArtixDSContentType contentType) {
        return dataFormat(new ArtixDSDataFormat(contentType));
    }
    private T dataFormat(DataFormatType dataFormatType) {
        switch (operation) {
            case Unmarshal:
                return processorType.unmarshal(dataFormatType);
            case Marshal:
                return processorType.marshal(dataFormatType);
            default:
                throw new IllegalArgumentException(""Unknown value: "" + operation);
        }
    }
}
"
org.apache.camel.builder.DeadLetterChannelBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.processor.DeadLetterChannel;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingLevel;
import org.apache.camel.processor.RecipientList;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A builder of a <a
 * href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter
 * Channel</a>
 * 
 * @version $Revision: 573290 $
 */
public class DeadLetterChannelBuilder extends ErrorHandlerBuilderSupport {
    private RedeliveryPolicy redeliveryPolicy = new RedeliveryPolicy();
    private ProcessorFactory deadLetterFactory;
    private Processor defaultDeadLetterEndpoint;
    private Expression defaultDeadLetterEndpointExpression;
    private String defaultDeadLetterEndpointUri = ""log:org.apache.camel.DeadLetterChannel?level=error"";
    private Logger logger = DeadLetterChannel.createDefaultLogger();
    public DeadLetterChannelBuilder() {
    }
    public DeadLetterChannelBuilder(Processor processor) {
        this(new ConstantProcessorBuilder(processor));
    }
    public DeadLetterChannelBuilder(ProcessorFactory deadLetterFactory) {
        this.deadLetterFactory = deadLetterFactory;
    }
    public ErrorHandlerBuilder copy() {
        DeadLetterChannelBuilder answer = new DeadLetterChannelBuilder(deadLetterFactory);
        answer.setRedeliveryPolicy(getRedeliveryPolicy().copy());
        return answer;
    }
    public Processor createErrorHandler(Processor processor) throws Exception {
        Processor deadLetter = getDeadLetterFactory().createProcessor();
        DeadLetterChannel answer = new DeadLetterChannel(processor, deadLetter, getRedeliveryPolicy(), getLogger());
        configure(answer);
        return answer;
    }
    // Builder methods
    // -------------------------------------------------------------------------
    public DeadLetterChannelBuilder backOffMultiplier(double backOffMultiplier) {
        getRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
        return this;
    }
    public DeadLetterChannelBuilder collisionAvoidancePercent(short collisionAvoidancePercent) {
        getRedeliveryPolicy().collisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }
    public DeadLetterChannelBuilder initialRedeliveryDelay(long initialRedeliveryDelay) {
        getRedeliveryPolicy().initialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    public DeadLetterChannelBuilder maximumRedeliveries(int maximumRedeliveries) {
        getRedeliveryPolicy().maximumRedeliveries(maximumRedeliveries);
        return this;
    }
    public DeadLetterChannelBuilder useCollisionAvoidance() {
        getRedeliveryPolicy().useCollisionAvoidance();
        return this;
    }
    public DeadLetterChannelBuilder useExponentialBackOff() {
        getRedeliveryPolicy().useExponentialBackOff();
        return this;
    }
    /**
     * Sets the logger used for caught exceptions
     */
    public DeadLetterChannelBuilder logger(Logger logger) {
        setLogger(logger);
        return this;
    }
    /**
     * Sets the logging level of exceptions caught
     */
    public DeadLetterChannelBuilder loggingLevel(LoggingLevel level) {
        getLogger().setLevel(level);
        return this;
    }
    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(Log log) {
        getLogger().setLog(log);
        return this;
    }
    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(String log) {
        return log(LogFactory.getLog(log));
    }
    /**
     * Sets the log used for caught exceptions
     */
    public DeadLetterChannelBuilder log(Class log) {
        return log(LogFactory.getLog(log));
    }
    // Properties
    // -------------------------------------------------------------------------
    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    /**
     * Sets the redelivery policy
     */
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    public ProcessorFactory getDeadLetterFactory() {
        if (deadLetterFactory == null) {
            deadLetterFactory = new ProcessorFactory() {
                public Processor createProcessor() {
                    return getDefaultDeadLetterEndpoint();
                }
            };
        }
        return deadLetterFactory;
    }
    /**
     * Sets the default dead letter queue factory
     */
    public void setDeadLetterFactory(ProcessorFactory deadLetterFactory) {
        this.deadLetterFactory = deadLetterFactory;
    }
    public Processor getDefaultDeadLetterEndpoint() {
        if (defaultDeadLetterEndpoint == null) {
            defaultDeadLetterEndpoint = new RecipientList(getDefaultDeadLetterEndpointExpression());
        }
        return defaultDeadLetterEndpoint;
    }
    /**
     * Sets the default dead letter endpoint used
     */
    public void setDefaultDeadLetterEndpoint(Processor defaultDeadLetterEndpoint) {
        this.defaultDeadLetterEndpoint = defaultDeadLetterEndpoint;
    }
    public Expression getDefaultDeadLetterEndpointExpression() {
        if (defaultDeadLetterEndpointExpression == null) {
            defaultDeadLetterEndpointExpression = ExpressionBuilder
                .constantExpression(getDefaultDeadLetterEndpointUri());
        }
        return defaultDeadLetterEndpointExpression;
    }
    /**
     * Sets the expression used to decide the dead letter channel endpoint for
     * an exchange if no factory is provided via
     * {@link #setDeadLetterFactory(ProcessorFactory)}
     */
    public void setDefaultDeadLetterEndpointExpression(Expression defaultDeadLetterEndpointExpression) {
        this.defaultDeadLetterEndpointExpression = defaultDeadLetterEndpointExpression;
    }
    public String getDefaultDeadLetterEndpointUri() {
        return defaultDeadLetterEndpointUri;
    }
    /**
     * Sets the default dead letter endpoint URI used if no factory is provided
     * via {@link #setDeadLetterFactory(ProcessorFactory)} and no expression is
     * provided via {@link #setDefaultDeadLetterEndpointExpression(Expression)}
     * 
     * @param defaultDeadLetterEndpointUri the default URI if no deadletter
     *                factory or expression is provided
     */
    public void setDefaultDeadLetterEndpointUri(String defaultDeadLetterEndpointUri) {
        this.defaultDeadLetterEndpointUri = defaultDeadLetterEndpointUri;
    }
    public Logger getLogger() {
        return logger;
    }
    public void setLogger(Logger logger) {
        this.logger = logger;
    }
}
"
org.apache.camel.builder.ErrorHandlerBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.model.ExceptionType;
import java.util.List;
/**
 * @version $Revision: 564644 $
 */
public interface ErrorHandlerBuilder {
    /**
     * Creates a copy of this builder
     */
    ErrorHandlerBuilder copy();
    /**
     * Creates the error handler interceptor
     */
    Processor createErrorHandler(Processor processor) throws Exception;
    void addErrorHandlers(ExceptionType exception);
}
"
org.apache.camel.builder.ErrorHandlerBuilderSupport,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.processor.ErrorHandlerSupport;
import java.util.ArrayList;
import java.util.List;
/**
 * @version $Revision: 1.1 $
 */
public abstract class ErrorHandlerBuilderSupport implements ErrorHandlerBuilder {
    private List<ExceptionType> exceptions = new ArrayList<ExceptionType>();
    public void addErrorHandlers(ExceptionType exception) {
        exceptions.add(exception);
    }
    protected void configure(ErrorHandlerSupport handler) {
        for (ExceptionType exception : exceptions) {
            handler.addExceptionPolicy(exception);
        }
    }
}
"
org.apache.camel.builder.ErrorHandlerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.EventDrivenConsumerRoute;
import org.apache.camel.processor.DeadLetterChannel;
import org.apache.camel.processor.DelegateAsyncProcessor;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.processor.LoggingErrorHandler;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.camel.processor.SendProcessor;
import java.util.List;
/**
 * @version $Revision: 581937 $
 */
public class ErrorHandlerTest extends TestSupport {
    // TODO
    public void TODO_testOverloadingTheDefaultErrorHandler() throws Exception {
        // START SNIPPET: e1
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                errorHandler(loggingErrorHandler(""FOO.BAR""));
                from(""seda:a"").to(""seda:b"");
            }
        };
        // END SNIPPET: e1
        List<Route> list = getRouteList(builder);
        assertEquals(""Number routes created�"" + list, 1, list.size());
        for (Route route : list) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            EventDrivenConsumerRoute consumerRoute = assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
            Processor processor = consumerRoute.getProcessor();
            LoggingErrorHandler loggingProcessor = assertIsInstanceOf(LoggingErrorHandler.class, processor);
            SendProcessor sendProcessor = assertIsInstanceOf(SendProcessor.class, loggingProcessor.getOutput());
            log.debug(""Found sendProcessor: "" + sendProcessor);
        }
    }
    public void   testOverloadingTheHandlerOnASingleRoute() throws Exception {
        // START SNIPPET: e2
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").errorHandler(loggingErrorHandler(""FOO.BAR"")).to(""seda:b"");
                // this route will�use the default error handler, DeadLetterChannel
                from(""seda:b"").to(""seda:c"");
            }
        };
        // END SNIPPET: e2
        List<Route> list = getRouteList(builder);
        assertEquals(""Number routes created�"" + list, 2, list.size());
        for (Route route : list) {
            Endpoint key = route.getEndpoint();
            String endpointUri = key.getEndpointUri();
            EventDrivenConsumerRoute consumerRoute = assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
            Processor processor = unwrap(consumerRoute.getProcessor());
            SendProcessor sendProcessor = null;
            if (endpointUri.equals(""seda:a"")) {
                LoggingErrorHandler
                        loggingProcessor = assertIsInstanceOf(LoggingErrorHandler.class,
                        processor);
                Processor outputProcessor = loggingProcessor.getOutput();
                sendProcessor = assertIsInstanceOf(SendProcessor.class, outputProcessor);
            }
            else {
                assertEquals(""From endpoint"", ""seda:b"",
                        endpointUri);
                DeadLetterChannel deadLetterChannel =
                        assertIsInstanceOf(DeadLetterChannel.class, processor);
                Processor
                        outputProcessor = deadLetterChannel.getOutput();
                sendProcessor = assertIsInstanceOf(SendProcessor.class, outputProcessor);
            }
            log.debug(""For "" + endpointUri + "" using: "" + sendProcessor);
        }
    }
    public void testConfigureDeadLetterChannel() throws Exception {
        // START SNIPPET: e3
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                errorHandler(deadLetterChannel(""seda:errors""));
                from(""seda:a"").to(""seda:b"");
            }
        };
        // END SNIPPET: e3
        List<Route> list = getRouteList(builder);
        assertEquals(""Number routes created�"" + list, 1, list.size());
        for (Route route : list) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            EventDrivenConsumerRoute consumerRoute = assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
            Processor processor = unwrap(consumerRoute.getProcessor());
            assertIsInstanceOf(DeadLetterChannel.class, processor);
        }
    }
    // TODO
    public void TODO_testConfigureDeadLetterChannelWithCustomRedeliveryPolicy() throws Exception {
        // START SNIPPET: e4
        RouteBuilder builder = new
                RouteBuilder() {
                    public void configure() {
                        errorHandler(deadLetterChannel(""seda:errors"").maximumRedeliveries(2).useExponentialBackOff());
                        from(""seda:a"").to(""seda:b"");
                    }
                };
        // END SNIPPET: e4
        List<Route> list = getRouteList(builder);
        assertEquals(""Number routes created�"" + list, 1, list.size());
        for (Route route : list) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            EventDrivenConsumerRoute consumerRoute = assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
            Processor processor = consumerRoute.getProcessor();
            DeadLetterChannel deadLetterChannel = assertIsInstanceOf(DeadLetterChannel.class, processor);
            RedeliveryPolicy redeliveryPolicy = deadLetterChannel.getRedeliveryPolicy();
            assertEquals(""getMaximumRedeliveries()"", 2, redeliveryPolicy.getMaximumRedeliveries());
            assertEquals(""isUseExponentialBackOff()"", true, redeliveryPolicy.isUseExponentialBackOff());
        }
    }
    public void testDisablingInheritenceOfErrorHandlers() throws Exception {
        // START SNIPPET: e5
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").errorHandler(loggingErrorHandler(""FOO.BAR"")).filter(body().isInstanceOf(String.class)).inheritErrorHandler(false).to(""seda:b"");
            }
        };
        // END SNIPPET: e5
        List<Route> routes = getRouteList(builder);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            EventDrivenConsumerRoute consumerRoute = assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
            Processor processor = unwrap(consumerRoute.getProcessor());
            LoggingErrorHandler loggingProcessor = assertIsInstanceOf(LoggingErrorHandler.class, processor);
            FilterProcessor filterProcessor = assertIsInstanceOf(FilterProcessor.class, loggingProcessor.getOutput());
            SendProcessor sendProcessor = assertIsInstanceOf(SendProcessor.class, filterProcessor.getProcessor());
            log.debug(""Found sendProcessor: "" + sendProcessor);
        }
    }
}
"
org.apache.camel.builder.ExpressionBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Collection;
import java.util.regex.Pattern;
/**
 * @version $Revision: $
 */
public class ExpressionBuilder {
    /**
     * Utility classes should not have a public constructor.
     */
    private ExpressionBuilder() {
    }
    /**
     * Returns an expression for the header value with the given name
     *
     * @param headerName the name of the header the expression will return
     * @return an expression object which will return the header value
     */
    public static <E extends Exchange> Expression<E> headerExpression(final String headerName) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Object header = exchange.getIn().getHeader(headerName);
                if (header == null) {
                    // lets try the exchange header
                    header = exchange.getProperty(headerName);
                }
                return header;
            }
            @Override
            public String toString() {
                return ""header("" + headerName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the inbound message headers
     *
     * @see Message#getHeaders()
     * @return an expression object which will return the inbound headers
     */
    public static <E extends Exchange> Expression<E> headersExpresion() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getHeaders();
            }
            @Override
            public String toString() {
                return ""headers"";
            }
        };
    }
    /**
     * Returns an expression for the out header value with the given name
     *
     * @param headerName the name of the header the expression will return
     * @return an expression object which will return the header value
     */
    public static <E extends Exchange> Expression<E> outHeaderExpression(final String headerName) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Object header = exchange.getOut().getHeader(headerName);
                if (header == null) {
                    // lets try the exchange header
                    header = exchange.getProperty(headerName);
                }
                return header;
            }
            @Override
            public String toString() {
                return ""outHeader("" + headerName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the property value with the given name
     *
     * @see Exchange#getProperty(String)
     * @param propertyName the name of the property the expression will return
     * @return an expression object which will return the property value
     */
    public static <E extends Exchange> Expression<E> propertyExpression(final String propertyName) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getProperty(propertyName);
            }
            @Override
            public String toString() {
                return ""property("" + propertyName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the property value with the given name
     *
     * @see Exchange#getProperties()
     * @return an expression object which will return the properties
     */
    public static <E extends Exchange> Expression<E> propertiesExpresion() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getProperties();
            }
            @Override
            public String toString() {
                return ""properties"";
            }
        };
    }
    /**
     * Returns an expression for a system property value with the given name
     *
     * @param propertyName the name of the system property the expression will
     *                return
     * @return an expression object which will return the system property value
     */
    public static <E extends Exchange> Expression<E> systemPropertyExpression(final String propertyName) {
        return systemPropertyExpression(propertyName, null);
    }
    /**
     * Returns an expression for a system property value with the given name
     *
     * @param propertyName the name of the system property the expression will
     *                return
     * @return an expression object which will return the system property value
     */
    public static <E extends Exchange> Expression<E> systemPropertyExpression(final String propertyName,
                                                                              final String defaultValue) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return System.getProperty(propertyName, defaultValue);
            }
            @Override
            public String toString() {
                return ""systemProperty("" + propertyName + "")"";
            }
        };
    }
    /**
     * Returns an expression for the contant value
     *
     * @param value the value the expression will return
     * @return an expression object which will return the constant value
     */
    public static <E extends Exchange> Expression<E> constantExpression(final Object value) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return value;
            }
            @Override
            public String toString() {
                return """" + value;
            }
        };
    }
    /**
     * Returns the expression for the exchanges inbound message body
     */
    public static <E extends Exchange> Expression<E> bodyExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getBody();
            }
            @Override
            public String toString() {
                return ""body"";
            }
        };
    }
    /**
     * Returns the expression for the exchanges inbound message body converted
     * to the given type
     */
    public static <E extends Exchange, T> Expression<E> bodyExpression(final Class<T> type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn().getBody(type);
            }
            @Override
            public String toString() {
                return ""bodyAs["" + type.getName() + ""]"";
            }
        };
    }
    /**
     * Returns the expression for the out messages body
     */
    public static <E extends Exchange> Expression<E> outBodyExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getOut().getBody();
            }
            @Override
            public String toString() {
                return ""outBody"";
            }
        };
    }
    /**
     * Returns the expression for the exchanges outbound message body converted
     * to the given type
     */
    public static <E extends Exchange, T> Expression<E> outBodyExpression(final Class<T> type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getOut().getBody(type);
            }
            @Override
            public String toString() {
                return ""outBodyAs["" + type.getName() + ""]"";
            }
        };
    }
    /**
     * Returns the expression for the fault messages body
     */
    public static <E extends Exchange> Expression<E> faultBodyExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getFault().getBody();
            }
            @Override
            public String toString() {
                return ""faultBody"";
            }
        };
    }
    /**
     * Returns the expression for the exchanges fault message body converted
     * to the given type
     */
    public static <E extends Exchange, T> Expression<E> faultBodyExpression(final Class<T> type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getFault().getBody(type);
            }
            @Override
            public String toString() {
                return ""faultBodyAs["" + type.getName() + ""]"";
            }
        };
    }
    /**
     * Returns the expression for the exchange
     */
    public static <E extends Exchange> Expression<E> exchangeExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange;
            }
            @Override
            public String toString() {
                return ""exchange"";
            }
        };
    }
    /**
     * Returns the expression for the IN message
     */
    public static <E extends Exchange> Expression<E> inMessageExpression() {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return exchange.getIn();
            }
            @Override
            public String toString() {
                return ""inMessage"";
            }
        };
    }
    /**
     * Returns an expression which converts the given expression to the given
     * type
     */
    public static <E extends Exchange> Expression<E> convertTo(final Expression expression, final Class type) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                Object value = expression.evaluate(exchange);
                return exchange.getContext().getTypeConverter().convertTo(type, value);
            }
            @Override
            public String toString() {
                return """" + expression + "".convertTo("" + type.getName() + "".class)"";
            }
        };
    }
    /**
     * Returns a tokenize expression which will tokenize the string with the
     * given token
     */
    public static <E extends Exchange> Expression<E> tokenizeExpression(final Expression<E> expression,
                                                                        final String token) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                if (text == null) {
                    return null;
                }
                StringTokenizer iter = new StringTokenizer(text, token);
                List<String> answer = new ArrayList<String>();
                while (iter.hasMoreTokens()) {
                    answer.add(iter.nextToken());
                }
                return answer;
            }
            @Override
            public String toString() {
                return ""tokenize("" + expression + "", "" + token + "")"";
            }
        };
    }
    /**
     * Returns a tokenize expression which will tokenize the string with the
     * given regex
     */
    public static <E extends Exchange> Expression<E> regexTokenize(final Expression<E> expression,
                                                                   String regexTokenizer) {
        final Pattern pattern = Pattern.compile(regexTokenizer);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                if (text == null) {
                    return null;
                }
                return Arrays.asList(pattern.split(text));
            }
            @Override
            public String toString() {
                return ""regexTokenize("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }
    /**
     * Transforms the expression into a String then performs the regex
     * replaceAll to transform the String and return the result
     */
    public static <E extends Exchange> Expression<E> regexReplaceAll(final Expression<E> expression,
                                                                     String regex, final String replacement) {
        final Pattern pattern = Pattern.compile(regex);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                if (text == null) {
                    return null;
                }
                return pattern.matcher(text).replaceAll(replacement);
            }
            @Override
            public String toString() {
                return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }
    /**
     * Transforms the expression into a String then performs the regex
     * replaceAll to transform the String and return the result
     */
    public static <E extends Exchange> Expression<E> regexReplaceAll(final Expression<E> expression,
                                                                     String regex,
                                                                     final Expression<E> replacementExpression) {
        final Pattern pattern = Pattern.compile(regex);
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                String text = evaluateStringExpression(expression, exchange);
                String replacement = evaluateStringExpression(replacementExpression, exchange);
                if (text == null || replacement == null) {
                    return null;
                }
                return pattern.matcher(text).replaceAll(replacement);
            }
            @Override
            public String toString() {
                return ""regexReplaceAll("" + expression + "", "" + pattern.pattern() + "")"";
            }
        };
    }
    /**
     * Appends the String evaluations of the two expressions together
     */
    public static <E extends Exchange> Expression<E> append(final Expression<E> left,
                                                            final Expression<E> right) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return evaluateStringExpression(left, exchange) + evaluateStringExpression(right, exchange);
            }
            @Override
            public String toString() {
                return ""append("" + left + "", "" + right + "")"";
            }
        };
    }
    /**
     * Evaluates the expression on the given exchange and returns the String
     * representation
     *
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @return the String representation of the expression or null if it could
     *         not be evaluated
     */
    public static <E extends Exchange> String evaluateStringExpression(Expression<E> expression, E exchange) {
        Object value = expression.evaluate(exchange);
        return exchange.getContext().getTypeConverter().convertTo(String.class, value);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> Expression<E> systemProperty(final String name) {
        return systemProperty(name, null);
    }
    /**
     * Returns an expression for the given system property
     */
    public static <E extends Exchange> Expression<E> systemProperty(final String name,
                                                                    final String defaultValue) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                return System.getProperty(name, defaultValue);
            }
        };
    }
    /**
     * Returns an expression which returns the string concatenation value of the various
     * expressions
     *
     * @param expressions the expression to be concatenated dynamically
     * @return an expression which when evaluated will return the concatenated values
     */
    public static <E extends Exchange> Expression<E> concatExpression(final Collection<Expression> expressions) {
        return concatExpression(expressions, null);
    }
    /**
     * Returns an expression which returns the string concatenation value of the various
     * expressions
     *
     * @param expressions the expression to be concatenated dynamically
     * @param expression the text description of the expression
     * @return an expression which when evaluated will return the concatenated values
     */
    public static <E extends Exchange> Expression<E> concatExpression(final Collection<Expression> expressions, final String expression) {
        return new Expression<E>() {
            public Object evaluate(E exchange) {
                StringBuffer buffer = new StringBuffer();
                for (Expression<E> expression : expressions) {
                    String text = evaluateStringExpression(expression, exchange);
                    if (text != null) {
                        buffer.append(text);
                    }
                }
                return buffer.toString();
            }
            @Override
            public String toString() {
                if (expression != null) {
                    return expression;
                }
                else {
                return ""concat"" + expressions;
                }
            }
        };
    }
}
"
org.apache.camel.builder.ExpressionBuilderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.Arrays;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
import static org.apache.camel.builder.ExpressionBuilder.constantExpression;
import static org.apache.camel.builder.ExpressionBuilder.headerExpression;
import static org.apache.camel.builder.ExpressionBuilder.regexReplaceAll;
import static org.apache.camel.builder.ExpressionBuilder.regexTokenize;
import static org.apache.camel.builder.PredicateBuilder.contains;
/**
 * @version $Revision: 563607 $
 */
public class ExpressionBuilderTest extends TestSupport {
    protected Exchange exchange = new DefaultExchange(new DefaultCamelContext());
    public void testRegexTokenize() throws Exception {
        Expression<Exchange> expression = regexTokenize(headerExpression(""location""), "","");
        assertExpression(expression, exchange, Arrays.asList(new String[] {""Islington"", ""London"", ""UK""}));
        Predicate<Exchange> predicate = contains(regexTokenize(headerExpression(""location""), "",""),
                                                 constantExpression(""London""));
        assertPredicate(predicate, exchange, true);
        predicate = contains(regexTokenize(headerExpression(""location""), "",""),
                             constantExpression(""Manchester""));
        assertPredicate(predicate, exchange, false);
    }
    public void testRegexReplaceAll() throws Exception {
        Expression<Exchange> expression = regexReplaceAll(headerExpression(""location""), ""London"",
                                                          ""Westminster"");
        assertExpression(expression, exchange, ""Islington,Westminster,UK"");
        expression = regexReplaceAll(headerExpression(""location""), ""London"", headerExpression(""name""));
        assertExpression(expression, exchange, ""Islington,James,UK"");
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Message in = exchange.getIn();
        in.setBody(""Hello there!"");
        in.setHeader(""name"", ""James"");
        in.setHeader(""location"", ""Islington,London,UK"");
    }
}
"
org.apache.camel.builder.ExpressionClause,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.spi.Language;
/**
 * Represents an expression clause within the DSL
 *
 * @version $Revision: 1.1 $
 */
public class ExpressionClause<T extends ProcessorType> {
    private T result;
    private CamelContext camelContext;
    /**
     * Evaluates the  <a href=""http://activemq.apache.org/camel/el.html"">EL Language from JSP and JSF</a>
     * using the <a href=""http://activemq.apache.org/camel/juel.html"">JUEL library</a>
     *
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T el(String text) {
        return language(""el"", text);
    }
    /**
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T groovy(String text) {
        return language(""groovy"", text);
    }
    /**
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T javaScript(String text) {
        return language(""js"", text);
    }
    /**
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T ognl(String text) {
        return language(""ognl"", text);
    }
    /**
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T php(String text) {
        return language(""php"", text);
    }
    /**
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T python(String text) {
        return language(""python"", text);
    }
    /**
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T ruby(String text) {
        return language(""ruby"", text);
    }
    /**
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T sql(String text) {
        return language(""sql"", text);
    }
    /**
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T simple(String text) {
        return language(""simple"", text);
    }
    /**
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T xpath(String text) {
        return language(""xpath"", text);
    }
    /**
     * @param text the expression to be evaluated
     * @return the builder to continue processing the DSL
     */
    public T xqery(String text) {
        return language(""xqery"", text);
    }
    /**
     * Evaluates a given language name with the expression text
     *
     * @param languageName the name of the language
     * @param text         the expression in the given language
     * @return the builder to continue processing the DSL
     */
    public T language(String languageName, String text) {
        Expression expression = createExpression(""el"", text);
        // TODO set the exception!
        return result;
    }
    protected Expression createExpression(String languageName, String text) {
        // TODO can we share this code with other places we assert mandatory language names?
        Language language = camelContext.resolveLanguage(languageName);
        if (language == null) {
            throw new IllegalArgumentException(""Could not resolve language: "" + languageName);
        }
        return language.createExpression(text);
    }
}
"
org.apache.camel.builder.InterceptorBuilderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.ArrayList;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Producer;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.processor.DelegateProcessor;
/**
 * @version $Revision: 530102 $
 */
public class InterceptorBuilderTest extends TestSupport {
    /**
     * Validates that interceptors are executed in the right order.
     * 
     * @throws Exception
     */
    public void testRouteWithInterceptor() throws Exception {
        CamelContext container = new DefaultCamelContext();
        final ArrayList<String> order = new ArrayList<String>();
        final DelegateProcessor interceptor1 = new DelegateProcessor() {
            @Override
            public void process(Exchange exchange) throws Exception {
                order.add(""START:1"");
                super.process(exchange);
                order.add(""END:1"");
            }
        };
        final DelegateProcessor interceptor2 = new DelegateProcessor() {
            @Override
            public void process(Exchange exchange) throws Exception {
                order.add(""START:2"");
                super.process(exchange);
                order.add(""END:2"");
            }
        };
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                //from(""direct:a"").intercept(interceptor1).intercept(interceptor2).to(""direct:d"");
                from(""direct:a"").intercept(interceptor1).intercept(interceptor2).to(""direct:d"");
                /*
                 * TODO keep old DSL? .intercept() .add(interceptor1)
                 * .add(interceptor2) .target().to(""direct:d"");
                 */
            }
        };
        container.addRoutes(builder);
        container.start();
        Endpoint<Exchange> endpoint = container.getEndpoint(""direct:a"");
        Exchange exchange = endpoint.createExchange();
        Producer<Exchange> producer = endpoint.createProducer();
        producer.process(exchange);
        ArrayList<String> expected = new ArrayList<String>();
        expected.add(""START:1"");
        expected.add(""START:2"");
        expected.add(""END:2"");
        expected.add(""END:1"");
        log.debug(""Interceptor invocation order:"" + order);
        assertEquals(expected, order);
    }
}
"
org.apache.camel.builder.LoggingErrorHandlerBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingErrorHandler;
import org.apache.camel.processor.LoggingLevel;
import org.apache.camel.processor.ErrorHandlerSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Uses the {@link Logger} as an error handler
 *
 * @version $Revision: 564295 $
 */
public class LoggingErrorHandlerBuilder extends ErrorHandlerBuilderSupport {
    private Log log = LogFactory.getLog(Logger.class);
    private LoggingLevel level = LoggingLevel.INFO;
    public LoggingErrorHandlerBuilder() {
    }
    public LoggingErrorHandlerBuilder(Log log) {
        this.log = log;
    }
    public LoggingErrorHandlerBuilder(Log log, LoggingLevel level) {
        this.log = log;
        this.level = level;
    }
    public ErrorHandlerBuilder copy() {
        LoggingErrorHandlerBuilder answer = new LoggingErrorHandlerBuilder();
        answer.setLog(getLog());
        answer.setLevel(getLevel());
        return answer;
    }
    public Processor createErrorHandler(Processor processor) {
        LoggingErrorHandler handler = new LoggingErrorHandler(processor, log, level);
        configure(handler);
        return handler;
    }
    public LoggingLevel getLevel() {
        return level;
    }
    public void setLevel(LoggingLevel level) {
        this.level = level;
    }
    public Log getLog() {
        return log;
    }
    public void setLog(Log log) {
        this.log = log;
    }
}
"
org.apache.camel.builder.MyInterceptorProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class MyInterceptorProcessor extends DelegateProcessor {
    private static final transient Log LOG = LogFactory.getLog(MyInterceptorProcessor.class);
    public void process(Exchange exchange) throws Exception {
        LOG.debug(""START of onExchange: "" + exchange);
        super.process(exchange);
        LOG.debug(""END of onExchange: "" + exchange);
    }
}
"
org.apache.camel.builder.MyProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class MyProcessor implements Processor {
    private static final transient Log LOG = LogFactory.getLog(MyProcessor.class);
    public void process(Exchange exchange) {
        LOG.debug(""Called with exchange: "" + exchange);
    }
    @Override
    public String toString() {
        return ""MyProcessor"";
    }
}
"
org.apache.camel.builder.NoErrorHandlerBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A builder to disable the use of an error handler so that any exceptions are thrown.
 * This not recommended in general, the
 * <a href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter Channel</a> should be used
 * if you are unsure; however it can be useful sometimes to disable an error handler inside a complex route
 * so that exceptions bubble up to the parent {@link Processor}
 *
 * @version $Revision: 564295 $
 */
public class NoErrorHandlerBuilder extends ErrorHandlerBuilderSupport {
    public ErrorHandlerBuilder copy() {
        return this;
    }
    public Processor createErrorHandler(Processor processor) {
        return processor;
    }
}
"
org.apache.camel.builder.PredicateBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.impl.BinaryPredicateSupport;
import org.apache.camel.impl.PredicateSupport;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.compare;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A helper class for working with predicates
 * 
 * @version $Revision: 520261 $
 */
public class PredicateBuilder {
    /**
     * Utility classes should not have a public constructor.
     */
    private PredicateBuilder() {        
    }
    /**
     * Converts the given expression into an {@link Predicate}
     */
    public static <E extends Exchange> Predicate<E> toPredicate(final Expression<E> expression) {
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                Object value = expression.evaluate(exchange);
                return evaluateValuePredicate(value);
            }
            @Override
            public String toString() {
                return expression.toString();
            }
        };
    }
    /**
     * Evaluate the value as a predicate which attempts to convert the value to
     * a boolean otherwise true is returned if the value is not null
     */
    public static boolean evaluateValuePredicate(Object value) {
        if (value instanceof Boolean) {
            Boolean aBoolean = (Boolean)value;
            return aBoolean.booleanValue();
        }
        return value != null;
    }
    /**
     * A helper method to return the logical not of the given predicate
     */
    public static <E extends Exchange> Predicate<E> not(final Predicate<E> predicate) {
        notNull(predicate, ""predicate"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                return !predicate.matches(exchange);
            }
            @Override
            public String toString() {
                return ""not "" + predicate;
            }
        };
    }
    /**
     * A helper method to combine multiple predicates by a logical AND
     */
    public static <E extends Exchange> Predicate<E> and(final Predicate<E> left, final Predicate<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                return left.matches(exchange) && right.matches(exchange);
            }
            @Override
            public String toString() {
                return ""("" + left + "") and ("" + right + "")"";
            }
        };
    }
    /**
     * A helper method to combine multiple predicates by a logical OR
     */
    public static <E extends Exchange> Predicate<E> or(final Predicate<E> left, final Predicate<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                return left.matches(exchange) || right.matches(exchange);
            }
            @Override
            public String toString() {
                return ""("" + left + "") or ("" + right + "")"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isEqualTo(final Expression<E> left,
                                                              final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return ObjectHelper.equals(leftValue, rightValue);
            }
            protected String getOperationText() {
                return ""=="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isNotEqualTo(final Expression<E> left,
                                                                 final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return !ObjectHelper.equals(leftValue, rightValue);
            }
            protected String getOperationText() {
                return ""=="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isLessThan(final Expression<E> left,
                                                               final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) < 0;
            }
            protected String getOperationText() {
                return ""<"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isLessThanOrEqualTo(final Expression<E> left,
                                                                        final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) <= 0;
            }
            protected String getOperationText() {
                return ""<="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isGreaterThan(final Expression<E> left,
                                                                  final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) > 0;
            }
            protected String getOperationText() {
                return "">"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isGreaterThanOrEqualTo(final Expression<E> left,
                                                                           final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return compare(leftValue, rightValue) >= 0;
            }
            protected String getOperationText() {
                return "">="";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> contains(final Expression<E> left,
                                                             final Expression<E> right) {
        return new BinaryPredicateSupport<E>(left, right) {
            protected boolean matches(E exchange, Object leftValue, Object rightValue) {
                return ObjectHelper.contains(leftValue, rightValue);
            }
            protected String getOperationText() {
                return ""contains"";
            }
        };
    }
    public static <E extends Exchange> Predicate<E> isNull(final Expression<E> expression) {
        return isEqualTo(expression, ExpressionBuilder.<E> constantExpression(null));
    }
    public static <E extends Exchange> Predicate<E> isNotNull(final Expression<E> expression) {
        return isNotEqualTo(expression, ExpressionBuilder.<E> constantExpression(null));
    }
    public static <E extends Exchange> Predicate<E> isInstanceOf(final Expression<E> expression,
                                                                 final Class type) {
        notNull(expression, ""expression"");
        notNull(type, ""type"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                Object value = expression.evaluate(exchange);
                return type.isInstance(value);
            }
            @Override
            public String toString() {
                return expression + "" instanceof "" + type.getName();
            }
            @Override
            protected String assertionFailureMessage(E exchange) {
                return super.assertionFailureMessage(exchange) + "" for <"" + expression.evaluate(exchange)
                       + "">"";
            }
        };
    }
    /**
     * Returns a predicate which is true if the expression matches the given
     * regular expression
     * 
     * @param expression the expression to evaluate
     * @param regex the regular expression to match against
     * @return a new predicate
     */
    public static <E extends Exchange> Predicate<E> regex(final Expression<E> expression, final String regex) {
        return regex(expression, Pattern.compile(regex));
    }
    /**
     * Returns a predicate which is true if the expression matches the given
     * regular expression
     * 
     * @param expression the expression to evaluate
     * @param pattern the regular expression to match against
     * @return a new predicate
     */
    public static <E extends Exchange> Predicate<E> regex(final Expression<E> expression,
                                                          final Pattern pattern) {
        notNull(expression, ""expression"");
        notNull(pattern, ""pattern"");
        return new PredicateSupport<E>() {
            public boolean matches(E exchange) {
                Object value = expression.evaluate(exchange);
                if (value != null) {
                    Matcher matcher = pattern.matcher(value.toString());
                    return matcher.matches();
                }
                return false;
            }
            @Override
            public String toString() {
                return expression + "".matches("" + pattern + "")"";
            }
            @Override
            protected String assertionFailureMessage(E exchange) {
                return super.assertionFailureMessage(exchange) + "" for <"" + expression.evaluate(exchange)
                       + "">"";
            }
        };
    }
}
"
org.apache.camel.builder.PredicateBuilderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
import static org.apache.camel.builder.Builder.constant;
/**
 * @version $Revision: 563607 $
 */
public class PredicateBuilderTest extends TestSupport {
    protected Exchange exchange = new DefaultExchange(new DefaultCamelContext());
    public void testRegexPredicates() throws Exception {
        assertMatches(header(""location"").regex(""[a-zA-Z]+,London,UK""));
        assertDoesNotMatch(header(""location"").regex(""[a-zA-Z]+,Westminster,[a-zA-Z]+""));
    }
    public void testPredicates() throws Exception {
        assertMatches(header(""name"").isEqualTo(constant(""James"")));
    }
    public void testFailingPredicates() throws Exception {
        assertDoesNotMatch(header(""name"").isEqualTo(constant(""Hiram"")));
        assertDoesNotMatch(header(""size"").isGreaterThan(constant(100)));
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Message in = exchange.getIn();
        in.setBody(""Hello there!"");
        in.setHeader(""name"", ""James"");
        in.setHeader(""location"", ""Islington,London,UK"");
        in.setHeader(""size"", 10);
    }
    protected void assertMatches(Predicate<Exchange> predicate) {
        assertPredicateMatches(predicate, exchange);
    }
    protected void assertDoesNotMatch(Predicate<Exchange> predicate) {
        assertPredicateDoesNotMatch(predicate, exchange);
    }
}
"
org.apache.camel.builder.PredicateFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
/**
 * A Factory of {@link Predicate} objects typically implemented by a builder such as @{XPathBuilder}
 *
 * @version $Revision: 563607 $
 */
public interface PredicateFactory<E extends Exchange> {
    /**
     * Creates a predicate object
     *
     * @return the newly created expression object
     */
    Predicate<E> createPredicate();
}
"
org.apache.camel.builder.ProcessorBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
/**
 * A builder of a number of different {@link Processor} implementations
 *
 * @version $Revision: 1.1 $
 */
public class ProcessorBuilder {
    /**
     * Utility classes should not have a public constructor.
     */
    private ProcessorBuilder() {        
    }
    /**
     * Creates a processor which sets the body of the IN message to the value of the expression
     */
    public static Processor setBody(final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object newBody = expression.evaluate(exchange);
                exchange.getIn().setBody(newBody);
            }
            @Override
            public String toString() {
                return ""setBody("" + expression + "")"";
            }
        };
    }
    /**
     * Creates a processor which sets the body of the OUT message to the value of the expression
     */
    public static Processor setOutBody(final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object newBody = expression.evaluate(exchange);
                exchange.getOut().setBody(newBody);
            }
            @Override
            public String toString() {
                return ""setOutBody("" + expression + "")"";
            }
        };
    }
    /**
     * Creates a processor which sets the body of the FAULT message to the value of the expression
     */
    public static Processor setFaultBody(final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object newBody = expression.evaluate(exchange);
                exchange.getFault().setBody(newBody);
            }
            @Override
            public String toString() {
                return ""setFaultBody("" + expression + "")"";
            }
        };
    }
    /**
     * Sets the header on the IN message
     */
    public static Processor setHeader(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.getIn().setHeader(name, value);
            }
            @Override
            public String toString() {
                return ""setHeader("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Sets the header on the OUT message
     */
    public static Processor setOutHeader(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.getOut().setHeader(name, value);
            }
            @Override
            public String toString() {
                return ""setOutHeader("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Sets the header on the FAULT message
     */
    public static Processor setFaultHeader(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.getFault().setHeader(name, value);
            }
            @Override
            public String toString() {
                return ""setFaultHeader("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Sets the property on the exchange
     */
    public static Processor setProperty(final String name, final Expression expression) {
        return new Processor() {
            public void process(Exchange exchange) {
                Object value = expression.evaluate(exchange);
                exchange.setProperty(name, value);
            }
            @Override
            public String toString() {
                return ""setProperty("" + name + "", "" + expression + "")"";
            }
        };
    }
    /**
     * Removes the header on the IN message
     */
    public static Processor removeHeader(final String name) {
        return new Processor() {
            public void process(Exchange exchange) {
                exchange.getIn().removeHeader(name);
            }
            @Override
            public String toString() {
                return ""removeHeader("" + name +  "")"";
            }
        };
    }
    /**
     * Removes the header on the OUT message
     */
    public static Processor removeOutHeader(final String name) {
        return new Processor() {
            public void process(Exchange exchange) {
                exchange.getOut().removeHeader(name);
            }
            @Override
            public String toString() {
                return ""removeOutHeader("" + name +  "")"";
            }
        };
    }
    /**
     * Removes the header on the FAULT message
     */
    public static Processor removeFaultHeader(final String name) {
        return new Processor() {
            public void process(Exchange exchange) {
                exchange.getFault().removeHeader(name);
            }
            @Override
            public String toString() {
                return ""removeFaultHeader("" + name +  "")"";
            }
        };
    }
    /**
     * Removes the property on the exchange
     */
    public static Processor removeProperty(final String name) {
        return new Processor() {
            public void process(Exchange exchange) {
                exchange.removeProperty(name);
            }
            @Override
            public String toString() {
                return ""removeProperty("" + name +  "")"";
            }
        };
    }
}
"
org.apache.camel.builder.ProcessorFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Processor;
/**
 * An interface representing a builder of a {@link Processor}
 *
 * @version $Revision: 563607 $
 */
public interface ProcessorFactory {
    Processor createProcessor() throws Exception;
}
"
org.apache.camel.builder.RouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Predicate;
import org.apache.camel.Route;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.model.InterceptType;
import org.apache.camel.model.OtherwiseType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.RoutesType;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.processor.DelegateProcessor;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
/**
 * A <a href=""http://activemq.apache.org/camel/dsl.html"">Java DSL</a> which is
 * used to build {@link Route} instances in a
 * 
 * @{link CamelContext} for smart routing.
 * 
 * @version $Revision: 574788 $
 */
public abstract class RouteBuilder extends BuilderSupport {
    private AtomicBoolean initalized = new AtomicBoolean(false);
    private RoutesType routeCollection = new RoutesType();
    private List<Route> routes = new ArrayList<Route>();
    public RouteBuilder() {
        this(null);
    }
    public RouteBuilder(CamelContext context) {
        super(context);
    }
    @Override
    public String toString() {
        return routeCollection.toString();
    }
    /**
     * Called on initialization to to build the required destinationBuilders
     */
    public abstract void configure() throws Exception;
    /**
     * Creates a new route from the given URI input
     */
    public RouteType from(String uri) {
        RouteType answer = routeCollection.from(uri);
        configureRoute(answer);
        return answer;
    }
    /**
     * Creates a new route from the given endpoint
     */
    public RouteType from(Endpoint endpoint) {
        RouteType answer = routeCollection.from(endpoint);
        configureRoute(answer);
        return answer;
    }
    /**
     * Installs the given error handler builder
     * 
     * @param errorHandlerBuilder the error handler to be used by default for
     *                all child routes
     * @return the current builder with the error handler configured
     */
    public RouteBuilder errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {
        setErrorHandlerBuilder(errorHandlerBuilder);
        return this;
    }
    /**
     * Configures whether or not the error handler is inherited by every
     * processing node (or just the top most one)
     * 
     * @param value the flag as to whether error handlers should be inherited or
     *                not
     * @return the current builder
     */
    public RouteBuilder inheritErrorHandler(boolean value) {
        routeCollection.setInheritErrorHandlerFlag(value);
        return this;
    }
    /**
     * Adds the given interceptor to this route
     */
    public RouteBuilder intercept(DelegateProcessor interceptor) {
        routeCollection.intercept(interceptor);
        return this;
    }
    /**
     * Adds a route for an interceptor; use the {@link ProcessorType#proceed()} method
     * to continue processing the underying route being intercepted.
     *
     * @return
     */
    public InterceptType intercept() {
        return routeCollection.intercept();
    }
    /**
     * Applies a route for an interceptor if the given predicate is true
     * otherwise the interceptor route is not applied
     */
    public OtherwiseType intercept(Predicate predicate) {
        return routeCollection.intercept(predicate);
    }
    /**
     * Adds an exception handler route for the given exception type
     */
    public ExceptionType exception(Class exceptionType) {
        return routeCollection.exception(exceptionType);
    }
    // Properties
    // -----------------------------------------------------------------------
    public CamelContext getContext() {
        CamelContext context = super.getContext();
        if (context == null) {
            context = createContainer();
            setContext(context);
        }
        return context;
    }
    /**
     * Returns the routing map from inbound endpoints to processors
     */
    public List<Route> getRouteList() throws Exception {
        checkInitialized();
        return routes;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected void checkInitialized() throws Exception {
        if (initalized.compareAndSet(false, true)) {
            configure();
            populateRoutes(routes);
        }
    }
    protected void populateRoutes(List<Route> routes) throws Exception {
        CamelContext camelContext = getContext();
        if (camelContext == null) {
            throw new IllegalArgumentException(""No CamelContext has been injected!"");
        }
        routeCollection.setCamelContext(camelContext);
        camelContext.addRouteDefinitions(routeCollection.getRoutes());
    }
    public void setRouteCollection(RoutesType routeCollection) {
        this.routeCollection = routeCollection;
    }
    /**
     * Factory method
     */
    protected CamelContext createContainer() {
        return new DefaultCamelContext();
    }
    protected void configureRoute(RouteType route) {
        route.setGroup(getClass().getName());
    }
}
"
org.apache.camel.builder.RouteBuilderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.Route;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.EventDrivenConsumerRoute;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.processor.ChoiceProcessor;
import org.apache.camel.processor.DeadLetterChannel;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.processor.MulticastProcessor;
import org.apache.camel.processor.RecipientList;
import org.apache.camel.processor.SendProcessor;
import org.apache.camel.processor.Splitter;
import org.apache.camel.processor.idempotent.IdempotentConsumer;
import org.apache.camel.processor.idempotent.MemoryMessageIdRepository;
import static org.apache.camel.processor.idempotent.MemoryMessageIdRepository.memoryMessageIdRepository;
import java.util.ArrayList;
import java.util.List;
/**
 * @version $Revision: 581937 $
 */
public class RouteBuilderTest extends TestSupport {
    protected Processor myProcessor = new MyProcessor();
    protected DelegateProcessor interceptor1;
    protected DelegateProcessor interceptor2;
    protected List<Route> buildSimpleRoute() throws Exception {
        // START SNIPPET: e1
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").to(""seda:b"");
            }
        };
        // END SNIPPET: e1
        return getRouteList(builder);
    }
    public void testSimpleRoute() throws Exception {
        List<Route> routes = buildSimpleRoute();
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route<Exchange> route : routes) {
            Endpoint<Exchange> key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            SendProcessor sendProcessor = assertIsInstanceOf(SendProcessor.class, processor);
            assertEquals(""Endpoint URI"", ""seda:b"", sendProcessor.getDestination().getEndpointUri());
        }
    }
    protected List<Route> buildSimpleRouteWithHeaderPredicate() throws Exception {
        // START SNIPPET: e2
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").filter(header(""foo"").isEqualTo(""bar"")).to(""seda:b"");
            }
        };
        // END SNIPPET: e2
        return getRouteList(builder);
    }
    public void testSimpleRouteWithHeaderPredicate() throws Exception {
        List<Route> routes = buildSimpleRouteWithHeaderPredicate();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            FilterProcessor filterProcessor = assertIsInstanceOf(FilterProcessor.class, processor);
            SendProcessor sendProcessor = assertIsInstanceOf(SendProcessor.class,
                                                             unwrapErrorHandler(filterProcessor
                                                                 .getProcessor()));
            assertEquals(""Endpoint URI"", ""seda:b"", sendProcessor.getDestination().getEndpointUri());
        }
    }
    protected List<Route> buildSimpleRouteWithChoice() throws Exception {
        // START SNIPPET: e3
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").choice().when(header(""foo"").isEqualTo(""bar"")).to(""seda:b"")
                    .when(header(""foo"").isEqualTo(""cheese"")).to(""seda:c"").otherwise().to(""seda:d"");
            }
        };
        // END SNIPPET: e3
        return getRouteList(builder);
    }
    public void testSimpleRouteWithChoice() throws Exception {
        List<Route> routes = buildSimpleRouteWithChoice();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            ChoiceProcessor choiceProcessor = assertIsInstanceOf(ChoiceProcessor.class, processor);
            List<FilterProcessor> filters = choiceProcessor.getFilters();
            assertEquals(""Should be two when clauses"", 2, filters.size());
            FilterProcessor filter1 = filters.get(0);
            assertSendTo(filter1.getProcessor(), ""seda:b"");
            FilterProcessor filter2 = filters.get(1);
            assertSendTo(filter2.getProcessor(), ""seda:c"");
            assertSendTo(choiceProcessor.getOtherwise(), ""seda:d"");
        }
    }
    protected List<Route> buildCustomProcessor() throws Exception {
        // START SNIPPET: e4
        myProcessor = new Processor() {
            public void process(Exchange exchange) {
                log.debug(""Called with exchange: "" + exchange);
            }
        };
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").process(myProcessor);
            }
        };
        // END SNIPPET: e4
        return getRouteList(builder);
    }
    public void testCustomProcessor() throws Exception {
        List<Route> routes = buildCustomProcessor();
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            assertEquals(""Should be called with my processor"", myProcessor, processor);
        }
    }
    protected List<Route> buildCustomProcessorWithFilter() throws Exception {
        // START SNIPPET: e5
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").filter(header(""foo"").isEqualTo(""bar"")).process(myProcessor);
            }
        };
        // END SNIPPET: e5
        return getRouteList(builder);
    }
    public void testCustomProcessorWithFilter() throws Exception {
        List<Route> routes = buildCustomProcessorWithFilter();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            FilterProcessor filterProcessor = assertIsInstanceOf(FilterProcessor.class, processor);
            assertEquals(""Should be called with my processor"", myProcessor,
                         unwrapErrorHandler(filterProcessor.getProcessor()));
        }
    }
    protected List<Route> buildWireTap() throws Exception {
        // START SNIPPET: e6
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").to(""seda:tap"", ""seda:b"");
            }
        };
        // END SNIPPET: e6
        return getRouteList(builder);
    }
    public void testWireTap() throws Exception {
        List<Route> routes = buildWireTap();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            MulticastProcessor multicastProcessor = assertIsInstanceOf(MulticastProcessor.class, processor);
            List<Processor> endpoints = new ArrayList<Processor>(multicastProcessor.getProcessors());
            assertEquals(""Should have 2 endpoints"", 2, endpoints.size());
            assertSendToProcessor(endpoints.get(0), ""seda:tap"");
            assertSendToProcessor(endpoints.get(1), ""seda:b"");
        }
    }
    protected List<Route> buildRouteWithInterceptor() throws Exception {
        interceptor1 = new DelegateProcessor() {
        };
        // START SNIPPET: e7
        interceptor2 = new MyInterceptorProcessor();
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").intercept(interceptor1).intercept(interceptor2).to(""seda:d"");
                /*
                 * 
                 * TODO keep old DSL? .intercept() .add(interceptor1)
                 * .add(interceptor2) .target().to(""seda:d"");
                 */
            }
        };
        // END SNIPPET: e7
        return getRouteList(builder);
    }
    public void testRouteWithInterceptor() throws Exception {
        List<Route> routes = buildRouteWithInterceptor();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            DelegateProcessor p1 = assertIsInstanceOf(DelegateProcessor.class, processor);
            processor = p1.getProcessor();
            DelegateProcessor p2 = assertIsInstanceOf(DelegateProcessor.class, processor);
            assertSendTo(p2.getProcessor(), ""seda:d"");
        }
    }
    public void testComplexExpressions() throws Exception {
        // START SNIPPET: e7
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").filter(header(""foo"").isEqualTo(123)).to(""seda:b"");
                from(""seda:a"").filter(header(""bar"").isGreaterThan(45)).to(""seda:b"");
            }
        };
        // END SNIPPET: e7
        List<Route> routes = getRouteList(builder);
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 2, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            log.debug(""processor: "" + processor);
            /*
             * TODO FilterProcessor filterProcessor =
             * assertIsInstanceOf(FilterProcessor.class, processor);
             * 
             * SendProcessor sendProcessor =
             * assertIsInstanceOf(SendProcessor.class,
             * filterProcessor.getProcessor()); assertEquals(""Endpoint URI"",
             * ""seda:b"", sendProcessor.getDestination().getEndpointUri());
             */
        }
    }
    protected List<Route> buildStaticRecipientList() throws Exception {
        // START SNIPPET: e8
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").to(""seda:b"", ""seda:c"", ""seda:d"");
            }
        };
        // END SNIPPET: e8
        return getRouteList(builder);
    }
    protected List<Route> buildDynamicRecipientList() throws Exception {
        // START SNIPPET: e9
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").recipientList(header(""foo""));
            }
        };
        // END SNIPPET: e9
        return getRouteList(builder);
    }
    public void testRouteDynamicReceipentList() throws Exception {
        List<Route> routes = buildDynamicRecipientList();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            RecipientList p1 = assertIsInstanceOf(RecipientList.class, processor);
        }
    }
    protected List<Route> buildSplitter() throws Exception {
        // START SNIPPET: splitter
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").splitter(bodyAs(String.class).tokenize(""\n"")).to(""seda:b"");
            }
        };
        // END SNIPPET: splitter
        return getRouteList(builder);
    }
    public void testSplitter() throws Exception {
        List<Route> routes = buildSplitter();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            Splitter p1 = assertIsInstanceOf(Splitter.class, processor);
        }
    }
    protected List<Route> buildIdempotentConsumer() throws Exception {
        // START SNIPPET: idempotent
        RouteBuilder builder = new RouteBuilder() {
            public void configure() {
                from(""seda:a"").idempotentConsumer(header(""myMessageId""), memoryMessageIdRepository(200))
                    .to(""seda:b"");
            }
        };
        // END SNIPPET: idempotent
        return getRouteList(builder);
    }
    public void testIdempotentConsumer() throws Exception {
        List<Route> routes = buildIdempotentConsumer();
        log.debug(""Created routes: "" + routes);
        assertEquals(""Number routes created"", 1, routes.size());
        for (Route route : routes) {
            Endpoint key = route.getEndpoint();
            assertEquals(""From endpoint"", ""seda:a"", key.getEndpointUri());
            Processor processor = getProcessorWithoutErrorHandler(route);
            IdempotentConsumer idempotentConsumer = assertIsInstanceOf(IdempotentConsumer.class, processor);
            assertEquals(""messageIdExpression"", ""header(myMessageId)"", idempotentConsumer
                .getMessageIdExpression().toString());
            assertIsInstanceOf(MemoryMessageIdRepository.class, idempotentConsumer.getMessageIdRepository());
            SendProcessor sendProcessor = assertIsInstanceOf(SendProcessor.class,
                                                             unwrapErrorHandler(idempotentConsumer
                                                                 .getNextProcessor()));
            assertEquals(""Endpoint URI"", ""seda:b"", sendProcessor.getDestination().getEndpointUri());
        }
    }
    protected void assertSendTo(Processor processor, String uri) {
        if (!(processor instanceof SendProcessor)) {
            processor = unwrapErrorHandler(processor);
        }
        SendProcessor sendProcessor = assertIsInstanceOf(SendProcessor.class, processor);
        assertEquals(""Endpoint URI"", uri, sendProcessor.getDestination().getEndpointUri());
    }
    protected void assertSendToProcessor(Processor processor, String uri) {
        if (!(processor instanceof Producer)) {
            processor = unwrapErrorHandler(processor);
        }
        if (processor instanceof SendProcessor) {
            assertSendTo(processor, uri);
        } else {
            Producer producer = assertIsInstanceOf(Producer.class, processor);
            assertEquals(""Endpoint URI"", uri, producer.getEndpoint().getEndpointUri());
        }
    }
    /**
     * By default routes should be wrapped in the {@link DeadLetterChannel} so
     * lets unwrap that and return the actual processor
     */
    protected Processor getProcessorWithoutErrorHandler(Route route) {
        EventDrivenConsumerRoute consumerRoute = assertIsInstanceOf(EventDrivenConsumerRoute.class, route);
        Processor processor = unwrap(consumerRoute.getProcessor());
        return unwrapErrorHandler(processor);
    }
    protected Processor unwrapErrorHandler(Processor processor) {
        if (processor instanceof DeadLetterChannel) {
            DeadLetterChannel deadLetter = (DeadLetterChannel)processor;
            return deadLetter.getOutput();
        } else {
            return processor;
        }
    }
}
"
org.apache.camel.builder.ValueBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
/**
 * A builder of expressions or predicates based on values.
 * 
 * @version $Revision: $
 */
public class ValueBuilder<E extends Exchange> implements Expression<E> {
    private Expression<E> expression;
    public ValueBuilder(Expression<E> expression) {
        this.expression = expression;
    }
    public Object evaluate(E exchange) {
        return expression.evaluate(exchange);
    }
    public Expression<E> getExpression() {
        return expression;
    }
    @Override
    public String toString() {
        return expression.toString();
    }
    // Predicate builders
    // -------------------------------------------------------------------------
    public Predicate<E> isNotEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isNotEqualTo(expression, right));
    }
    public Predicate<E> isEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isEqualTo(expression, right));
    }
    public Predicate<E> isLessThan(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isLessThan(expression, right));
    }
    public Predicate<E> isLessThanOrEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isLessThanOrEqualTo(expression, right));
    }
    public Predicate<E> isGreaterThan(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isGreaterThan(expression, right));
    }
    public Predicate<E> isGreaterThanOrEqualTo(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.isGreaterThanOrEqualTo(expression, right));
    }
    public Predicate<E> isInstanceOf(Class type) {
        return onNewPredicate(PredicateBuilder.isInstanceOf(expression, type));
    }
    public Predicate<E> matchesRegex(String regex) {
        return onNewPredicate(PredicateBuilder.regex(expression, regex));
    }
    public Predicate<E> isNull() {
        return onNewPredicate(PredicateBuilder.isNull(expression));
    }
    public Predicate<E> isNotNull() {
        return onNewPredicate(PredicateBuilder.isNotNull(expression));
    }
    /**
     * Create a predicate that the left hand expression contains the value of
     * the right hand expression
     * 
     * @param value the element which is compared to be contained within this
     *                expression
     * @return a predicate which evaluates to true if the given value expression
     *         is contained within this expression value
     */
    public Predicate<E> contains(Object value) {
        Expression<E> right = asExpression(value);
        return onNewPredicate(PredicateBuilder.contains(expression, right));
    }
    /**
     * Creates a predicate which is true if this expression matches the given
     * regular expression
     * 
     * @param regex the regular expression to match
     * @return a predicate which evaluates to true if the expression matches the
     *         regex
     */
    public Predicate<E> regex(String regex) {
        return onNewPredicate(PredicateBuilder.regex(expression, regex));
    }
    // Expression builders
    // -------------------------------------------------------------------------
    public ValueBuilder<E> tokenize() {
        return tokenize(""\n"");
    }
    public ValueBuilder<E> tokenize(String token) {
        Expression<E> newExp = ExpressionBuilder.tokenizeExpression(expression, token);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Tokenizes the string conversion of this expression using the given
     * regular expression
     */
    public ValueBuilder<E> regexTokenize(String regex) {
        Expression<E> newExp = ExpressionBuilder.regexTokenize(expression, regex);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Replaces all occurrencies of the regular expression with the given
     * replacement
     */
    public ValueBuilder<E> regexReplaceAll(String regex, String replacement) {
        Expression<E> newExp = ExpressionBuilder.regexReplaceAll(expression, regex, replacement);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Replaces all occurrencies of the regular expression with the given
     * replacement
     */
    public ValueBuilder<E> regexReplaceAll(String regex, Expression<E> replacement) {
        Expression<E> newExp = ExpressionBuilder.regexReplaceAll(expression, regex, replacement);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Converts the current value to the given type using the registered type
     * converters
     * 
     * @param type the type to convert the value to
     * @return the current builder
     */
    public ValueBuilder<E> convertTo(Class type) {
        Expression<E> newExp = ExpressionBuilder.convertTo(expression, type);
        return new ValueBuilder<E>(newExp);
    }
    /**
     * Converts the current value a String using the registered type converters
     * 
     * @return the current builder
     */
    public ValueBuilder<E> convertToString() {
        return convertTo(String.class);
    }
    /**
     * Appends the string evaluation of this expression with the given value
     * 
     * @param value the value or expression to append
     * @return the current builder
     */
    public ValueBuilder<E> append(Object value) {
        return new ValueBuilder<E>(ExpressionBuilder.append(expression, asExpression(value)));
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A stategy method to allow derived classes to deal with the newly created
     * predicate in different ways
     */
    protected Predicate<E> onNewPredicate(Predicate<E> predicate) {
        return predicate;
    }
    protected Expression<E> asExpression(Object value) {
        if (value instanceof Expression) {
            return (Expression<E>)value;
        } else {
            return ExpressionBuilder.constantExpression(value);
        }
    }
}
"
org.apache.camel.builder.xml.DefaultNamespaceContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import javax.xml.namespace.NamespaceContext;
import javax.xml.xpath.XPathFactory;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
/**
 * An implementation of {@link NamespaceContext} which uses a simple Map where
 * the keys are the prefixes and the values are the URIs
 *
 * @version $Revision: $
 */
public class DefaultNamespaceContext implements NamespaceContext {
    private final Map map;
    private final NamespaceContext parent;
    public DefaultNamespaceContext() {
        this(XPathFactory.newInstance());
    }
    public DefaultNamespaceContext(XPathFactory factory) {
        this.parent = factory.newXPath().getNamespaceContext();
        this.map = new HashMap();
    }
    public DefaultNamespaceContext(NamespaceContext parent, Map map) {
        this.parent = parent;
        this.map = map;
    }
    /**
     * A helper method to make it easy to create newly populated instances
     */
    public DefaultNamespaceContext add(String prefix, String uri) {
        map.put(prefix, uri);
        return this;
    }
    public String getNamespaceURI(String prefix) {
        String answer = (String) map.get(prefix);
        if (answer == null && parent != null) {
            return parent.getNamespaceURI(prefix);
        }
        return answer;
    }
    public String getPrefix(String namespaceURI) {
        for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry) iter.next();
            if (namespaceURI.equals(entry.getValue())) {
                return (String) entry.getKey();
            }
        }
        if (parent != null) {
            return parent.getPrefix(namespaceURI);
        }
        return null;
    }
    public Iterator getPrefixes(String namespaceURI) {
        Set set = new HashSet();
        for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry) iter.next();
            if (namespaceURI.equals(entry.getValue())) {
                set.add(entry.getKey());
            }
        }
        if (parent != null) {
            Iterator iter = parent.getPrefixes(namespaceURI);
            while (iter.hasNext()) {
                set.add(iter.next());
            }
        }
        return set.iterator();
    }
    public void setNamespacesFromDom(Element element) {
        // lets set the parent first in case we overload a prefix here
        Node parentNode = element.getParentNode();
        if (parentNode instanceof Element) {
            setNamespacesFromDom((Element) parentNode);
        }
        NamedNodeMap attributes = element.getAttributes();
        int size = attributes.getLength();
        for (int i = 0; i < size; i++) {
            Attr node = (Attr) attributes.item(i);
            String name = node.getName();
            if (name.startsWith(""xmlns:"")) {
                String prefix = name.substring(""xmlns:"".length());
                String uri = node.getValue();
                add(prefix, uri);
            }
        }
    }
}
"
org.apache.camel.builder.xml.DomResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.transform.Result;
import javax.xml.transform.dom.DOMResult;
import org.apache.camel.Message;
/**
 * Uses DOM to handle results of the transformation
 *
 * @version $Revision: 1.1 $
 */
public class DomResultHandler implements ResultHandler {
    private DOMResult result = new DOMResult();
    public Result getResult() {
        return result;
    }
    public void setBody(Message in) {
        in.setBody(result.getNode());
    }
}
"
org.apache.camel.builder.xml.DomResultHandlerFactory,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * @version $Revision: 1.1 $
 */
public class DomResultHandlerFactory implements ResultHandlerFactory {
    public ResultHandler createResult() {
        return new DomResultHandler();
    }
}
"
org.apache.camel.builder.xml.InvalidXPathExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.xpath.XPathException;
import org.apache.camel.RuntimeExpressionException;
/**
 * An exception thrown if am XPath expression could not be parsed or evaluated
 *
 * @version $Revision: 521180 $
 */
public class InvalidXPathExpression extends RuntimeExpressionException {
    private final String xpath;
    public InvalidXPathExpression(String xpath, XPathException e) {
        super(""Invalid xpath: "" + xpath + "". Reason: "" + e, e);
        this.xpath = xpath;
    }
    public String getXpath() {
        return xpath;
    }
}
"
org.apache.camel.builder.xml.MessageVariableResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.xpath.XPathVariableResolver;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.builder.xml.Namespaces.ENVIRONMENT_VARIABLES;
import static org.apache.camel.builder.xml.Namespaces.EXCHANGE_PROPERTY;
import static org.apache.camel.builder.xml.Namespaces.IN_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.OUT_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.SYSTEM_PROPERTIES_NAMESPACE;
/**
 * A variable resolver for XPath expressions which support properties on the
 * messge, exchange as well as making system properties and environment
 * properties available.
 * 
 * @version $Revision: 521692 $
 */
public class MessageVariableResolver implements XPathVariableResolver {
    private static final transient Log LOG = LogFactory.getLog(MessageVariableResolver.class);
    private Exchange exchange;
    private Map<String, Object> variables = new HashMap<String, Object>();
    public Exchange getExchange() {
        return exchange;
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    public Object resolveVariable(QName name) {
        String uri = name.getNamespaceURI();
        String localPart = name.getLocalPart();
        Object answer = null;
        Message in = exchange.getIn();
        if (uri == null || uri.length() == 0) {
            answer = variables.get(localPart);
            if (answer == null) {
                Message message = in;
                if (message != null) {
                    answer = message.getHeader(localPart);
                }
                if (answer == null) {
                    answer = exchange.getProperty(localPart);
                }
            }
        } else if (uri.equals(SYSTEM_PROPERTIES_NAMESPACE)) {
            try {
                answer = System.getProperty(localPart);
            } catch (Exception e) {
                LOG
                    .debug(""Security exception evaluating system property: "" + localPart + "". Reason: "" + e,
                           e);
            }
        } else if (uri.equals(ENVIRONMENT_VARIABLES)) {
            answer = System.getenv().get(localPart);
        } else if (uri.equals(EXCHANGE_PROPERTY)) {
            answer = exchange.getProperty(localPart);
        } else if (uri.equals(IN_NAMESPACE)) {
            answer = in.getHeader(localPart);
            if (answer == null && localPart.equals(""body"")) {
                answer = in.getBody();
            }
        } else if (uri.equals(OUT_NAMESPACE)) {
            Message out = exchange.getOut();
            answer = out.getHeader(localPart);
            if (answer == null && localPart.equals(""body"")) {
                answer = out.getBody();
            }
        }
        // TODO support exposing CamelContext properties/resources via XPath?
        return answer;
    }
    public void addVariable(String localPart, Object value) {
        variables.put(localPart, value);
    }
}
"
org.apache.camel.builder.xml.NamespaceBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
/**
 * A helper class for creating namespaces which can then be used to create XPath expressions
 *
 * @version $Revision: 1.1 $
 */
public class NamespaceBuilder {
    private Map<String, String> namespaces = new HashMap<String, String>();
    public static NamespaceBuilder namespaceContext() {
        return new NamespaceBuilder();
    }
    public static NamespaceBuilder namespaceContext(String prefix, String uri) {
        return new NamespaceBuilder().namespace(prefix, uri);
    }
    public NamespaceBuilder namespace(String prefix, String uri) {
        namespaces.put(prefix, uri);
        return this;
    }
    /**
     * Creates a new XPath expression using the current namespaces
     *
     * @param xpath the XPath expression
     * @return a new XPath expression
     */
    public XPathBuilder xpath(String xpath) {
        XPathBuilder answer = XPathBuilder.xpath(xpath);
        Set<Map.Entry<String, String>> entries = namespaces.entrySet();
        for (Map.Entry<String, String> entry : entries) {
            answer.namespace(entry.getKey(), entry.getValue());
        }
        return answer;
    }
}
"
org.apache.camel.builder.xml.Namespaces,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import org.apache.camel.util.ObjectHelper;
/**
 * @version $Revision: $
 */
public class Namespaces {
    public static final String DEFAULT_NAMESPACE = ""http://activemq.apache.org/camel/schema/spring"";
    public static final String IN_NAMESPACE = ""http://camel.apache.org/xml/in/"";
    public static final String OUT_NAMESPACE = ""http://camel.apache.org/xml/out/"";
    public static final String SYSTEM_PROPERTIES_NAMESPACE = ""http://camel.apache.org/xml/variables/system-properties"";
    public static final String ENVIRONMENT_VARIABLES = ""http://camel.apache.org/xml/variables/environment-variables"";
    public static final String EXCHANGE_PROPERTY = ""http://camel.apache.org/xml/variables/exchange-property"";
    /**
     * Utility classes should not have a public constructor.
     */
    private Namespaces() {        
    }
    /**
     * Returns true if the given namespaceURI is empty or if it matches the
     * given expected namespace
     */
    public static boolean isMatchingNamespaceOrEmptyNamespace(String namespaceURI, String expectedNamespace) {
        return ObjectHelper.isNullOrBlank(namespaceURI) || namespaceURI.equals(expectedNamespace);
    }
}
"
org.apache.camel.builder.xml.ResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.transform.Result;
import org.apache.camel.Message;
/**
 * A strategy for handling XSLT results
 *
 * @version $Revision: 1.1 $
 */
public interface ResultHandler {
    Result getResult();
    void setBody(Message in);
}
"
org.apache.camel.builder.xml.ResultHandlerFactory,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * @version $Revision: 1.1 $
 */
public interface ResultHandlerFactory {
    ResultHandler createResult();
}
"
org.apache.camel.builder.xml.StreamResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.ByteArrayOutputStream;
import javax.xml.transform.Result;
import javax.xml.transform.stream.StreamResult;
import org.apache.camel.Message;
/**
 * Processes the XSLT result as a byte[]
 *
 * @version $Revision: 1.1 $
 */
public class StreamResultHandler implements ResultHandler {
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    StreamResult result = new StreamResult(buffer);
    public Result getResult() {
        return result;
    }
    public void setBody(Message in) {
        in.setBody(buffer.toByteArray());
    }
}
"
org.apache.camel.builder.xml.StreamResultHandlerFactory,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * @version $Revision: 1.1 $
 */
public class StreamResultHandlerFactory implements ResultHandlerFactory {
    public ResultHandler createResult() {
        return new StreamResultHandler();
    }
}
"
org.apache.camel.builder.xml.StringResultHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.StringWriter;
import javax.xml.transform.Result;
import javax.xml.transform.stream.StreamResult;
import org.apache.camel.Message;
/**
 * Processes the XSLT result as a String
 *
 * @version $Revision: 1.1 $
 */
public class StringResultHandler implements ResultHandler {
    StringWriter buffer = new StringWriter();
    StreamResult result = new StreamResult(buffer);
    public Result getResult() {
        return result;
    }
    public void setBody(Message in) {
        in.setBody(buffer.toString());
    }
}
"
org.apache.camel.builder.xml.StringResultHandlerFactory,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
/**
 * @version $Revision: 1.1 $
 */
public class StringResultHandlerFactory implements ResultHandlerFactory {
    public ResultHandler createResult() {
        return new StringResultHandler();
    }
}
"
org.apache.camel.builder.xml.XPathBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.StringReader;
import java.util.List;
import javax.xml.namespace.QName;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPathFactoryConfigurationException;
import javax.xml.xpath.XPathFunction;
import javax.xml.xpath.XPathFunctionException;
import javax.xml.xpath.XPathFunctionResolver;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.RuntimeExpressionException;
import static org.apache.camel.builder.xml.Namespaces.DEFAULT_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.IN_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.OUT_NAMESPACE;
import static org.apache.camel.builder.xml.Namespaces.isMatchingNamespaceOrEmptyNamespace;
import static org.apache.camel.converter.ObjectConverter.toBoolean;
/**
 * Creates an XPath expression builder which creates a nodeset result by default.
 * If you want to evaluate a String expression then call {@link #stringResult()}
 *
 * @see XPathConstants#NODESET
 * 
 * @version $Revision: 531854 $
 */
public class XPathBuilder<E extends Exchange> implements Expression<E>, Predicate<E> {
    private final String text;
    private XPathFactory xpathFactory;
    private Class documentType = Document.class;
    // For some reason the default expression of ""a/b"" on a document such as
    // <a><b>1</b><b>2</b></a>
    // will evaluate as just ""1"" by default which is bizarre. So by default
    // lets assume XPath expressions result in nodesets.
    private QName resultType = XPathConstants.NODESET;
    private String objectModelUri;
    private DefaultNamespaceContext namespaceContext;
    private XPathFunctionResolver functionResolver;
    private XPathExpression expression;
    private MessageVariableResolver variableResolver = new MessageVariableResolver();
    private E exchange;
    private XPathFunction bodyFunction;
    private XPathFunction headerFunction;
    private XPathFunction outBodyFunction;
    private XPathFunction outHeaderFunction;
    public XPathBuilder(String text) {
        this.text = text;
    }
    public static XPathBuilder xpath(String text) {
        return new XPathBuilder(text);
    }
    @Override
    public String toString() {
        return ""XPath: "" + text;
    }
    public boolean matches(E exchange) {
        Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);
        return toBoolean(booleanResult);
    }
    public void assertMatches(String text, E exchange) throws AssertionError {
        Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);
        if (!toBoolean(booleanResult)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as returned <"" + booleanResult + "">"");
        }
    }
    public Object evaluate(E exchange) {
        return evaluateAs(exchange, resultType);
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Sets the expression result type to boolean
     * 
     * @return the current builder
     */
    public XPathBuilder<E> booleanResult() {
        resultType = XPathConstants.BOOLEAN;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     * 
     * @return the current builder
     */
    public XPathBuilder<E> nodeResult() {
        resultType = XPathConstants.NODE;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     * 
     * @return the current builder
     */
    public XPathBuilder<E> nodeSetResult() {
        resultType = XPathConstants.NODESET;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     * 
     * @return the current builder
     */
    public XPathBuilder<E> numberResult() {
        resultType = XPathConstants.NUMBER;
        return this;
    }
    /**
     * Sets the expression result type to boolean
     * 
     * @return the current builder
     */
    public XPathBuilder<E> stringResult() {
        resultType = XPathConstants.STRING;
        return this;
    }
    /**
     * Sets the object model URI to use
     * 
     * @return the current builder
     */
    public XPathBuilder<E> objectModel(String uri) {
        this.objectModelUri = uri;
        return this;
    }
    /**
     * Sets the {@link XPathFunctionResolver} instance to use on these XPath
     * expressions
     * 
     * @return the current builder
     */
    public XPathBuilder<E> functionResolver(XPathFunctionResolver functionResolver) {
        this.functionResolver = functionResolver;
        return this;
    }
    /**
     * Registers the namespace prefix and URI with the builder so that the
     * prefix can be used in XPath expressions
     * 
     * @param prefix is the namespace prefix that can be used in the XPath
     *                expressions
     * @param uri is the namespace URI to which the prefix refers
     * @return the current builder
     */
    public XPathBuilder<E> namespace(String prefix, String uri) {
        getNamespaceContext().add(prefix, uri);
        return this;
    }
    /**
     * Registers a variable (in the global namespace) which can be referred to
     * from XPath expressions
     */
    public XPathBuilder<E> variable(String name, Object value) {
        variableResolver.addVariable(name, value);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public XPathFactory getXPathFactory() throws XPathFactoryConfigurationException {
        if (xpathFactory == null) {
            if (objectModelUri != null) {
                xpathFactory = XPathFactory.newInstance(objectModelUri);
            }
            xpathFactory = XPathFactory.newInstance();
        }
        return xpathFactory;
    }
    public void setXPathFactory(XPathFactory xpathFactory) {
        this.xpathFactory = xpathFactory;
    }
    public Class getDocumentType() {
        return documentType;
    }
    public void setDocumentType(Class documentType) {
        this.documentType = documentType;
    }
    public String getText() {
        return text;
    }
    public QName getResultType() {
        return resultType;
    }
    public void setResultType(QName resultType) {
        this.resultType = resultType;
    }
    public DefaultNamespaceContext getNamespaceContext() {
        if (namespaceContext == null) {
            try {
                DefaultNamespaceContext defaultNamespaceContext = new DefaultNamespaceContext(
                                                                                              getXPathFactory());
                populateDefaultNamespaces(defaultNamespaceContext);
                namespaceContext = defaultNamespaceContext;
            } catch (XPathFactoryConfigurationException e) {
                throw new RuntimeExpressionException(e);
            }
        }
        return namespaceContext;
    }
    public void setNamespaceContext(DefaultNamespaceContext namespaceContext) {
        this.namespaceContext = namespaceContext;
    }
    public XPathFunctionResolver getFunctionResolver() {
        return functionResolver;
    }
    public void setFunctionResolver(XPathFunctionResolver functionResolver) {
        this.functionResolver = functionResolver;
    }
    public XPathExpression getExpression() throws XPathFactoryConfigurationException,
        XPathExpressionException {
        if (expression == null) {
            expression = createXPathExpression();
        }
        return expression;
    }
    public void setNamespacesFromDom(Element node) {
        getNamespaceContext().setNamespacesFromDom(node);
    }
    public XPathFunction getBodyFunction() {
        if (bodyFunction == null) {
            bodyFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange == null) {
                        return null;
                    }
                    return exchange.getIn().getBody();
                }
            };
        }
        return bodyFunction;
    }
    public void setBodyFunction(XPathFunction bodyFunction) {
        this.bodyFunction = bodyFunction;
    }
    public XPathFunction getHeaderFunction() {
        if (headerFunction == null) {
            headerFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange != null && !list.isEmpty()) {
                        Object value = list.get(0);
                        if (value != null) {
                            return exchange.getIn().getHeader(value.toString());
                        }
                    }
                    return null;
                }
            };
        }
        return headerFunction;
    }
    public void setHeaderFunction(XPathFunction headerFunction) {
        this.headerFunction = headerFunction;
    }
    public XPathFunction getOutBodyFunction() {
        if (outBodyFunction == null) {
            outBodyFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange == null) {
                        return null;
                    }
                    return exchange.getOut().getBody();
                }
            };
        }
        return outBodyFunction;
    }
    public void setOutBodyFunction(XPathFunction outBodyFunction) {
        this.outBodyFunction = outBodyFunction;
    }
    public XPathFunction getOutHeaderFunction() {
        if (outHeaderFunction == null) {
            outHeaderFunction = new XPathFunction() {
                public Object evaluate(List list) throws XPathFunctionException {
                    if (exchange != null && !list.isEmpty()) {
                        Object value = list.get(0);
                        if (value != null) {
                            return exchange.getOut().getHeader(value.toString());
                        }
                    }
                    return null;
                }
            };
        }
        return outHeaderFunction;
    }
    public void setOutHeaderFunction(XPathFunction outHeaderFunction) {
        this.outHeaderFunction = outHeaderFunction;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Evaluates the expression as the given result type
     */
    protected synchronized Object evaluateAs(E exchange, QName resultType) {
        this.exchange = exchange;
        variableResolver.setExchange(exchange);
        try {
            Object document = getDocument(exchange);
            if (resultType != null) {
                if (document instanceof InputSource) {
                    InputSource inputSource = (InputSource)document;
                    return getExpression().evaluate(inputSource, resultType);
                } else {
                    return getExpression().evaluate(document, resultType);
                }
            } else {
                if (document instanceof InputSource) {
                    InputSource inputSource = (InputSource)document;
                    return getExpression().evaluate(inputSource);
                } else {
                    return getExpression().evaluate(document);
                }
            }
        } catch (XPathExpressionException e) {
            throw new InvalidXPathExpression(getText(), e);
        } catch (XPathFactoryConfigurationException e) {
            throw new InvalidXPathExpression(getText(), e);
        }
    }
    protected XPathExpression createXPathExpression() throws XPathExpressionException,
        XPathFactoryConfigurationException {
        XPath xPath = getXPathFactory().newXPath();
        // lets now clear any factory references to avoid keeping them around
        xpathFactory = null;
        xPath.setNamespaceContext(getNamespaceContext());
        xPath.setXPathVariableResolver(variableResolver);
        XPathFunctionResolver parentResolver = getFunctionResolver();
        if (parentResolver == null) {
            parentResolver = xPath.getXPathFunctionResolver();
        }
        xPath.setXPathFunctionResolver(createDefaultFunctionResolver(parentResolver));
        return xPath.compile(text);
    }
    /**
     * Lets populate a number of standard prefixes if they are not already there
     */
    protected void populateDefaultNamespaces(DefaultNamespaceContext context) {
        setNamespaceIfNotPresent(context, ""in"", IN_NAMESPACE);
        setNamespaceIfNotPresent(context, ""out"", OUT_NAMESPACE);
        setNamespaceIfNotPresent(context, ""env"", Namespaces.ENVIRONMENT_VARIABLES);
        setNamespaceIfNotPresent(context, ""system"", Namespaces.SYSTEM_PROPERTIES_NAMESPACE);
    }
    protected void setNamespaceIfNotPresent(DefaultNamespaceContext context, String prefix, String uri) {
        if (context != null) {
            String current = context.getNamespaceURI(prefix);
            if (current == null) {
                context.add(prefix, uri);
            }
        }
    }
    protected XPathFunctionResolver createDefaultFunctionResolver(final XPathFunctionResolver parent) {
        return new XPathFunctionResolver() {
            public XPathFunction resolveFunction(QName qName, int argumentCount) {
                XPathFunction answer = null;
                if (parent != null) {
                    answer = parent.resolveFunction(qName, argumentCount);
                }
                if (answer == null) {
                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), IN_NAMESPACE)
                        || isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), DEFAULT_NAMESPACE)) {
                        String localPart = qName.getLocalPart();
                        if (localPart.equals(""body"") && argumentCount == 0) {
                            return getBodyFunction();
                        }
                        if (localPart.equals(""header"") && argumentCount == 1) {
                            return getHeaderFunction();
                        }
                    }
                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), OUT_NAMESPACE)) {
                        String localPart = qName.getLocalPart();
                        if (localPart.equals(""body"") && argumentCount == 0) {
                            return getOutBodyFunction();
                        }
                        if (localPart.equals(""header"") && argumentCount == 1) {
                            return getOutHeaderFunction();
                        }
                    }
                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), DEFAULT_NAMESPACE)) {
                        String localPart = qName.getLocalPart();
                        if (localPart.equals(""out-body"") && argumentCount == 0) {
                            return getOutBodyFunction();
                        }
                        if (localPart.equals(""out-header"") && argumentCount == 1) {
                            return getOutHeaderFunction();
                        }
                    }
                }
                return answer;
            }
        };
    }
    /**
     * Strategy method to extract the document from the exchange
     */
    protected Object getDocument(E exchange) {
        Message in = exchange.getIn();
        Class type = getDocumentType();
        Object answer = null;
        if (type != null) {
            answer = in.getBody(type);
        }
        if (answer == null) {
            answer = in.getBody();
        }
        // lets try coerce some common types into something JAXP can deal with
        if (answer instanceof String) {
            answer = new InputSource(new StringReader(answer.toString()));
        }
        return answer;
    }
}
"
org.apache.camel.builder.xml.XPathLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
import javax.xml.namespace.QName;
/**
 * @version $Revision: 1.1 $
 */
public class XPathLanguage implements Language {
    private QName resultType;
    public Predicate<Exchange> createPredicate(String expression) {
        XPathBuilder builder = XPathBuilder.xpath(expression);
        configureBuilder(builder);
        return builder;
    }
    public Expression<Exchange> createExpression(String expression) {
        XPathBuilder builder = XPathBuilder.xpath(expression);
        configureBuilder(builder);
        return builder;
    }
    public QName getResultType() {
        return resultType;
    }
    public void setResultType(QName resultType) {
        this.resultType = resultType;
    }
    protected void configureBuilder(XPathBuilder builder) {
        if (resultType != null) {
            builder.setResultType(resultType);
        }
    }
}
"
org.apache.camel.builder.xml.XPathTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import javax.xml.xpath.XPathFunctionResolver;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.TestSupport;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
import static org.apache.camel.builder.xml.XPathBuilder.xpath;
/**
 * @version $Revision: 571489 $
 */
public class XPathTest extends TestSupport {
    public void testXPathExpressions() throws Exception {
        assertExpression(""/foo/bar/@xyz"", ""<foo><bar xyz='cheese'/></foo>"", ""cheese"");
        assertExpression(""$name"", ""<foo><bar xyz='cheese'/></foo>"", ""James"");
        assertExpression(""foo/bar"", ""<foo><bar>cheese</bar></foo>"", ""cheese"");
        assertExpression(""foo/bar/text()"", ""<foo><bar>cheese</bar></foo>"", ""cheese"");
        assertExpression(""/foo/@id"", ""<foo id='cheese'>hey</foo>"", ""cheese"");
    }
    public void testXPathPredicates() throws Exception {
        assertPredicate(""/foo/bar/@xyz"", ""<foo><bar xyz='cheese'/></foo>"", true);
        assertPredicate(""$name = 'James'"", ""<foo><bar xyz='cheese'/></foo>"", true);
        assertPredicate(""$name = 'Hiram'"", ""<foo><bar xyz='cheese'/></foo>"", false);
        assertPredicate(""/foo/notExist"", ""<foo><bar xyz='cheese'/></foo>"", false);
    }
    public void testXPathWithCustomVariable() throws Exception {
        assertExpression(xpath(""$name"").stringResult().variable(""name"", ""Hiram""), ""<foo/>"", ""Hiram"");
    }
    public void testUsingJavaExtensions() throws Exception {
        Object instance = null;
        // we may not have Xalan on the classpath
        try {
            instance = Class.forName(""org.apache.xalan.extensions.XPathFunctionResolverImpl"").newInstance();
        } catch (Throwable e) {
            log.debug(""Could not find Xalan on the classpath so ignoring this test case: "" + e);
        }
        if (instance instanceof XPathFunctionResolver) {
            XPathFunctionResolver functionResolver = (XPathFunctionResolver)instance;
            XPathBuilder builder = xpath(""java:"" + getClass().getName() + "".func(string(/header/value))"").namespace(""java"", ""http://xml.apache.org/xalan/java"").functionResolver(functionResolver);
            String xml = ""<header><value>12</value></header>"";
            Object value = assertExpression(builder, xml, ""modified12"");
            log.debug(""Evaluated xpath: "" + builder.getText() + "" on XML: "" + xml + "" result: "" + value);
        }
    }
    public static String func(String s) {
        return ""modified"" + s;
    }
    protected Object assertExpression(String xpath, String xml, String expected) {
        Expression expression = XPathBuilder.xpath(xpath).stringResult();
        return assertExpression(expression, xml, expected);
    }
    protected Object assertExpression(Expression expression, String xml, String expected) {
        return assertExpression(expression, createExchange(xml), expected);
    }
    protected void assertPredicate(String xpath, String xml, boolean expected) {
        Predicate predicate = XPathBuilder.xpath(xpath);
        assertPredicate(predicate, createExchange(xml), expected);
    }
    protected Exchange createExchange(String xml) {
        CamelContext context = new DefaultCamelContext();
        Exchange exchange = new DefaultExchange(context);
        Message message = exchange.getIn();
        message.setHeader(""name"", ""James"");
        message.setBody(xml);
        return exchange;
    }
}
"
org.apache.camel.builder.xml.XPathWithNamespacesFromDomTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.apache.camel.ContextTestSupport;
/**
 * @version $Revision: 534495 $
 */
public class XPathWithNamespacesFromDomTest extends ContextTestSupport {
    public void testXPathUsingDomForNamespaces() throws Exception {
        Document document = context.getTypeConverter()
            .convertTo(Document.class, ""<x:foo xmlns:x='n1' xmlns:y='n2'><bar id='a' xmlns:y='n3'/></x:foo>"");
        Element element = (Element)document.getElementsByTagName(""bar"").item(0);
        assertNotNull(""Could not find element for id 'a'"", element);
        XPathBuilder builder = XPathBuilder.xpath(""//y:foo[@id='z']"");
        builder.setNamespacesFromDom(element);
        DefaultNamespaceContext namespaceContext = builder.getNamespaceContext();
        assertEquals(""y namespace"", ""n3"", namespaceContext.getNamespaceURI(""y""));
        assertPredicateMatches(builder, createExchangeWithBody(""<blah><foo xmlns='n3' id='z'/></blah>""));
        assertPredicateDoesNotMatch(builder, createExchangeWithBody(""<blah><foo xmlns='n2' id='z'/></blah>""));
    }
}
"
org.apache.camel.builder.xml.XsltBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.Exchange;
import org.apache.camel.ExpectedBodyTypeException;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeTransformException;
import org.apache.camel.converter.jaxp.XmlConverter;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Creates a <a href=""http://activemq.apache.org/camel/processor.html"">Processor</a>
 * which performs an XSLT transformation of the IN message body
 * 
 * @version $Revision: 531854 $
 */
public class XsltBuilder implements Processor {
    private Map<String, Object> parameters = new HashMap<String, Object>();
    private XmlConverter converter = new XmlConverter();
    private Transformer transformer;
    private ResultHandlerFactory resultHandlerFactory = new StringResultHandlerFactory();
    private boolean failOnNullBody = true;
    public XsltBuilder() {
    }
    public XsltBuilder(Transformer transformer) {
        this.transformer = transformer;
    }
    @Override
    public String toString() {
        return ""XSLT["" + transformer + ""]"";
    }
    public synchronized void process(Exchange exchange) throws Exception {
        Transformer transformer = getTransformer();
        if (transformer == null) {
            throw new IllegalArgumentException(""No transformer configured!"");
        }
        configureTransformer(transformer, exchange);
        Source source = getSource(exchange);
        ResultHandler resultHandler = resultHandlerFactory.createResult();
        Result result = resultHandler.getResult();
        transformer.transform(source, result);
        resultHandler.setBody(exchange.getIn());
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Creates an XSLT processor using the given transformer instance
     */
    public static XsltBuilder xslt(Transformer transformer) {
        return new XsltBuilder(transformer);
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(Source xslt) throws TransformerConfigurationException {
        notNull(xslt, ""xslt"");
        XsltBuilder answer = new XsltBuilder();
        answer.setTransformerSource(xslt);
        return answer;
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(File xslt) throws TransformerConfigurationException {
        notNull(xslt, ""xslt"");
        return xslt(new StreamSource(xslt));
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(URL xslt) throws TransformerConfigurationException, IOException {
        notNull(xslt, ""xslt"");
        return xslt(xslt.openStream());
    }
    /**
     * Creates an XSLT processor using the given XSLT source
     */
    public static XsltBuilder xslt(InputStream xslt) throws TransformerConfigurationException, IOException {
        notNull(xslt, ""xslt"");
        return xslt(new StreamSource(xslt));
    }
    /**
     * Sets the output as being a byte[]
     */
    public XsltBuilder outputBytes() {
        setResultHandlerFactory(new StreamResultHandlerFactory());
        return this;
    }
    /**
     * Sets the output as being a String
     */
    public XsltBuilder outputString() {
        setResultHandlerFactory(new StringResultHandlerFactory());
        return this;
    }
    /**
     * Sets the output as being a DOM
     */
    public XsltBuilder outputDOM() {
        setResultHandlerFactory(new DomResultHandlerFactory());
        return this;
    }
    public XsltBuilder parameter(String name, Object value) {
        parameters.put(name, value);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public Map<String, Object> getParameters() {
        return parameters;
    }
    public void setParameters(Map<String, Object> parameters) {
        this.parameters = parameters;
    }
    public Transformer getTransformer() {
        return transformer;
    }
    public void setTransformer(Transformer transformer) {
        this.transformer = transformer;
    }
    public boolean isFailOnNullBody() {
        return failOnNullBody;
    }
    public void setFailOnNullBody(boolean failOnNullBody) {
        this.failOnNullBody = failOnNullBody;
    }
    public ResultHandlerFactory getResultHandlerFactory() {
        return resultHandlerFactory;
    }
    public void setResultHandlerFactory(ResultHandlerFactory resultHandlerFactory) {
        this.resultHandlerFactory = resultHandlerFactory;
    }
    public void setTransformerSource(Source source) throws TransformerConfigurationException {
        setTransformer(converter.getTransformerFactory().newTransformer(source));
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Converts the inbound body to a {@link Source}
     */
    protected Source getSource(Exchange exchange) {
        Message in = exchange.getIn();
        Source source = in.getBody(Source.class);
        if (source == null) {
            if (isFailOnNullBody()) {
                throw new ExpectedBodyTypeException(exchange, Source.class);
            } else {
                try {
                    source = converter.toSource(converter.createDocument());
                } catch (ParserConfigurationException e) {
                    throw new RuntimeTransformException(e);
                }
            }
        }
        return source;
    }
    /**
     * Configures the transformerwith exchange specific parameters
     */
    protected void configureTransformer(Transformer transformer, Exchange exchange) {
        transformer.clearParameters();
        addParameters(transformer, exchange.getProperties());
        addParameters(transformer, exchange.getIn().getHeaders());
        addParameters(transformer, getParameters());
        transformer.setParameter(""exchange"", exchange);
        transformer.setParameter(""in"", exchange.getIn());
        transformer.setParameter(""out"", exchange.getOut());
    }
    protected void addParameters(Transformer transformer, Map<String, Object> map) {
        Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();
        for (Map.Entry<String, Object> entry : propertyEntries) {
            transformer.setParameter(entry.getKey(), entry.getValue());
        }
    }
}
"
org.apache.camel.builder.xml.XsltTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.xml;
import java.net.URL;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.builder.xml.XsltBuilder.xslt;
/**
 * @version $Revision: 1.1 $
 */
public class XsltTest extends ContextTestSupport {
    public void testXslt() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint
            .expectedBodiesReceived(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><goodbye>world!</goodbye>"");
        sendBody(""direct:start"", ""<hello>world!</hello>"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() throws Exception {
                URL styleSheet = getClass().getResource(""example.xsl"");
                from(""direct:start"").process(xslt(styleSheet)).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.bean.AmbiguousMethodCallException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.List;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.Exchange;
/**
 * An exception thrown if an attempted method invocation resulted in an ambiguous method
 * such that multiple methods match the inbound message exchange
 *
 * @version $Revision: $
 */
public class AmbiguousMethodCallException extends CamelExchangeException {
    private final List<MethodInfo> methods;
    public AmbiguousMethodCallException(Exchange exchange, List<MethodInfo> methods) {
        super(""Ambiguous method invocations possible: "" + methods, exchange);
        this.methods = methods;
    }
    /**
     * The ambiguous methods for which a single method could not be chosen
     */
    public List<MethodInfo> getMethods() {
        return methods;
    }
}
"
org.apache.camel.component.bean.AnnotationExpressionFactory,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.Expression;
import org.apache.camel.CamelContext;
import org.apache.camel.language.LanguageAnnotation;
import java.lang.annotation.Annotation;
/**
 * A factory which creates an {@link Expression} object from an annotation on a field, property or method parameter
 * of a specified type.
 *
 * @version $Revision: 1.1 $
 */
public interface AnnotationExpressionFactory {
    Expression createExpression(CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation, Class expressionReturnType);
}
"
org.apache.camel.component.bean.BeanComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An alternative to the <a href=""http://activemq.apache.org/pojo.html"">POJO Component</a>
 * which implements the <a href=""http://activemq.apache.org/bean.html"">Bean Component</a>
 * which will look up the URI in the Spring ApplicationContext and use that to handle message dispatching.
 *
 * @version $Revision: 1.1 $
 */
public class BeanComponent extends DefaultComponent {
    private static final Log LOG = LogFactory.getLog(BeanComponent.class);
    private ParameterMappingStrategy parameterMappingStrategy;
    public BeanComponent() {
    }
    /**
     * A helper method to create a new endpoint from a bean with a generated URI
     */
    public ProcessorEndpoint createEndpoint(Object bean) {
        String uri = ""bean:generated:"" + bean;
        return createEndpoint(bean, uri);
    }
    /**
     * A helper method to create a new endpoint from a bean with a given URI
     */
    public ProcessorEndpoint createEndpoint(Object bean, String uri) {
        BeanProcessor processor = new BeanProcessor(bean, getCamelContext(), getParameterMappingStrategy());
        return createEndpoint(uri, processor);
    }
    public ParameterMappingStrategy getParameterMappingStrategy() {
        if (parameterMappingStrategy == null) {
            parameterMappingStrategy = createParameterMappingStrategy();
        }
        return parameterMappingStrategy;
    }
    public void setParameterMappingStrategy(ParameterMappingStrategy parameterMappingStrategy) {
        this.parameterMappingStrategy = parameterMappingStrategy;
    }
    // Implementation methods
    //-----------------------------------------------------------------------
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Object bean = getBean(remaining);
        BeanProcessor processor = new BeanProcessor(bean, getCamelContext(), getParameterMappingStrategy());
        setProperties(processor, parameters);
        return createEndpoint(uri, processor);
    }
    public Object getBean(String remaining) throws NoBeanAvailableException {
        Registry registry = getCamelContext().getRegistry();
        Object bean = registry.lookup(remaining);
        if (bean == null) {
            throw new NoBeanAvailableException(remaining);
        }
        return bean;
    }
    protected ProcessorEndpoint createEndpoint(String uri, BeanProcessor processor) {
        ProcessorEndpoint answer = new ProcessorEndpoint(uri, this, processor);
        answer.setExchangePattern(ExchangePattern.InOut);
        return answer;
    }
    protected ParameterMappingStrategy createParameterMappingStrategy() {
        return BeanProcessor.createParameterMappingStrategy(getCamelContext());
    }
}
"
org.apache.camel.component.bean.BeanExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * @version $Revision: 519901 $
 */
public class BeanExchange extends DefaultExchange {
    public BeanExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
    public BeanInvocation getInvocation() {
        return getIn().getBody(BeanInvocation.class);
    }
    public void setInvocation(BeanInvocation invocation) {
        getIn().setBody(invocation);
    }
    @Override
    public Exchange newInstance() {
        return new BeanExchange(getContext(), getPattern());
    }
}
"
org.apache.camel.component.bean.BeanInfo,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.*;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.language.LanguageAnnotation;
import static org.apache.camel.util.ExchangeHelper.convertToType;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
/**
 * Represents the metadata about a bean type created via a combination of
 * introspection and annotations together with some useful sensible defaults
 * 
 * @version $Revision: $
 */
public class BeanInfo {
    private static final transient Log LOG = LogFactory.getLog(BeanInfo.class);
    private final CamelContext camelContext;
    private Class type;
    private ParameterMappingStrategy strategy;
    private Map<String, MethodInfo> operations = new ConcurrentHashMap<String, MethodInfo>();
    private MethodInfo defaultMethod;
    private List<MethodInfo> operationsWithBody = new ArrayList<MethodInfo>();
    public BeanInfo(CamelContext camelContext, Class type, ParameterMappingStrategy strategy) {
        this.camelContext = camelContext;
        this.type = type;
        this.strategy = strategy;
        introspect(getType());
        if (operations.size() == 1) {
            Collection<MethodInfo> methodInfos = operations.values();
            for (MethodInfo methodInfo : methodInfos) {
                defaultMethod = methodInfo;
            }
        }
    }
    public Class getType() {
        return type;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public MethodInvocation createInvocation(Method method, Object pojo, Exchange exchange)
        throws RuntimeCamelException {
        MethodInfo methodInfo = introspect(type, method);
        if (methodInfo != null) {
            return methodInfo.createMethodInvocation(pojo, exchange);
        }
        return null;
    }
    public MethodInvocation createInvocation(Object pojo, Exchange exchange) throws RuntimeCamelException,
        AmbiguousMethodCallException {
        MethodInfo methodInfo = null;
        // TODO use some other mechanism?
        String name = exchange.getIn().getHeader(BeanProcessor.METHOD_NAME, String.class);
        if (name != null) {
            methodInfo = operations.get(name);
        }
        if (methodInfo == null) {
            methodInfo = chooseMethod(pojo, exchange);
        }
        if (methodInfo == null) {
            methodInfo = defaultMethod;
        }
        if (methodInfo != null) {
            return methodInfo.createMethodInvocation(pojo, exchange);
        }
        return null;
    }
    protected void introspect(Class clazz) {
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            if (isValidMethod(clazz, method)) {
                introspect(clazz, method);
            }
        }
        Class superclass = clazz.getSuperclass();
        if (superclass != null && !superclass.equals(Object.class)) {
            introspect(superclass);
        }
    }
    protected MethodInfo introspect(Class clazz, Method method) {
        Class[] parameterTypes = method.getParameterTypes();
        Annotation[][] parametersAnnotations = method.getParameterAnnotations();
        final Expression[] parameterExpressions = new Expression[parameterTypes.length];
        List<ParameterInfo> parameters = new ArrayList<ParameterInfo>();
        List<ParameterInfo> bodyParameters = new ArrayList<ParameterInfo>();
        boolean hasCustomAnnotation = false;
        for (int i = 0; i < parameterTypes.length; i++) {
            Class parameterType = parameterTypes[i];
            Annotation[] parameterAnnotations = parametersAnnotations[i];
            Expression expression = createParameterUnmarshalExpression(clazz, method, parameterType,
                                                                       parameterAnnotations);
            hasCustomAnnotation |= expression != null;
            if (expression == null) {
                hasCustomAnnotation |= ObjectHelper.hasAnnotation(parameterAnnotations, Body.class);
                if (bodyParameters.isEmpty()) {
                    // lets assume its the body
                    expression = ExpressionBuilder.bodyExpression(parameterType);
                } else {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""No expression available for method: "" + method.toString()
                                  + "" which already has a body so ignoring parameter: "" + i
                                  + "" so ignoring method"");
                    }
                    return null;
                }
            }
            ParameterInfo parameterInfo = new ParameterInfo(i, parameterType, parameterAnnotations,
                                                            expression);
            parameters.add(parameterInfo);
            if (isPossibleBodyParameter(parameterAnnotations)) {
                bodyParameters.add(parameterInfo);
            }
        }
        // now lets add the method to the repository
        String opName = method.getName();
        /*
         * 
         * TODO allow an annotation to expose the operation name to use
         * 
         * if (method.getAnnotation(Operation.class) != null) { String name =
         * method.getAnnotation(Operation.class).name(); if (name != null &&
         * name.length() > 0) { opName = name; } }
         */
        MethodInfo methodInfo = new MethodInfo(clazz, method, parameters, bodyParameters, hasCustomAnnotation);
        operations.put(opName, methodInfo);
        if (methodInfo.hasBodyParameter()) {
            operationsWithBody.add(methodInfo);
        }
        return methodInfo;
    }
    /**
     * Lets try choose one of the available methods to invoke if we can match
     * the message body to the body parameter
     * 
     * @param pojo the bean to invoke a method on
     * @param exchange the message exchange
     * @return the method to invoke or null if no definitive method could be
     *         matched
     */
    protected MethodInfo chooseMethod(Object pojo, Exchange exchange) throws AmbiguousMethodCallException {
        if (operationsWithBody.size() == 1) {
            return operationsWithBody.get(0);
        } else if (!operationsWithBody.isEmpty()) {
            // lets see if we can find a method who's body param type matches
            // the message body
            Message in = exchange.getIn();
            Object body = in.getBody();
            if (body != null) {
                Class bodyType = body.getClass();
                List<MethodInfo> possibles = new ArrayList<MethodInfo>();
                for (MethodInfo methodInfo : operationsWithBody) {
                    if (methodInfo.bodyParameterMatches(bodyType)) {
                        possibles.add(methodInfo);
                    }
                }
                if (possibles.size() == 1) {
                    return possibles.get(0);
                } else if (possibles.isEmpty()) {
                    // lets try converting
                    Object newBody = null;
                    MethodInfo matched = null;
                    for (MethodInfo methodInfo : operationsWithBody) {
                        Object value = convertToType(exchange, methodInfo.getBodyParameterType(), body);
                        if (value != null) {
                            if (newBody != null) {
                                throw new AmbiguousMethodCallException(exchange, Arrays.asList(matched,
                                                                                               methodInfo));
                            } else {
                                newBody = value;
                                matched = methodInfo;
                            }
                        }
                    }
                    if (matched != null) {
                        in.setBody(newBody);
                        return matched;
                    }
                } else {
                    // if we have only one method with custom annotations lets choose that
                    MethodInfo chosen = null;
                    for (MethodInfo possible : possibles) {
                        if (possible.isHasCustomAnnotation()) {
                            if (chosen != null) {
                                chosen = null;
                                break;
                            }
                            else {
                                chosen = possible;
                            }
                        }
                    }
                    if (chosen != null) {
                        return chosen;
                    }
                    throw new AmbiguousMethodCallException(exchange, possibles);
                }
            }
            return null;
        }
        return null;
    }
    /**
     * Creates an expression for the given parameter type if the parameter can
     * be mapped automatically or null if the parameter cannot be mapped due to
     * unsufficient annotations or not fitting with the default type
     * conventions.
     */
    protected Expression createParameterUnmarshalExpression(Class clazz, Method method, Class parameterType,
                                                            Annotation[] parameterAnnotation) {
        // TODO look for a parameter annotation that converts into an expression
        for (Annotation annotation : parameterAnnotation) {
            Expression answer = createParameterUnmarshalExpressionForAnnotation(clazz, method, parameterType,
                                                                                annotation);
            if (answer != null) {
                return answer;
            }
        }
        return strategy.getDefaultParameterTypeExpression(parameterType);
    }
    protected boolean isPossibleBodyParameter(Annotation[] annotations) {
        if (annotations != null) {
            for (Annotation annotation : annotations) {
                if ((annotation instanceof Property) || (annotation instanceof Header)) {
                    return false;
                }
            }
        }
        return true;
    }
    protected Expression createParameterUnmarshalExpressionForAnnotation(Class clazz, Method method,
                                                                         Class parameterType,
                                                                         Annotation annotation) {
        if (annotation instanceof Property) {
            Property propertyAnnotation = (Property)annotation;
            return ExpressionBuilder.propertyExpression(propertyAnnotation.name());
        } else if (annotation instanceof Properties) {
            return ExpressionBuilder.propertiesExpresion();
        } else if (annotation instanceof Header) {
            Header headerAnnotation = (Header)annotation;
            return ExpressionBuilder.headerExpression(headerAnnotation.name());
        } else if (annotation instanceof Headers) {
            return ExpressionBuilder.headersExpresion();
        } else {
            LanguageAnnotation languageAnnotation = annotation.annotationType().getAnnotation(LanguageAnnotation.class);
            if (languageAnnotation != null) {
                Class<?> type = languageAnnotation.factory();
                Object object = camelContext.getInjector().newInstance(type);
                if (object instanceof AnnotationExpressionFactory) {
                    AnnotationExpressionFactory expressionFactory = (AnnotationExpressionFactory) object;
                    return expressionFactory.createExpression(camelContext, annotation, languageAnnotation, parameterType);
                }
                else {
                    LOG.error(""Ignoring bad annotation: "" + languageAnnotation + ""on method: "" + method
                            + "" which declares a factory: "" + type.getName()
                            + "" which does not implement "" + AnnotationExpressionFactory.class.getName());
                }
            }
        }
        return null;
    }
    protected boolean isValidMethod(Class clazz, Method method) {
        return Modifier.isPublic(method.getModifiers());
    }
}
"
org.apache.camel.component.bean.BeanInvocation,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.camel.Exchange;
public class BeanInvocation {
    private final Object proxy;
    private final Method method;
    private final Object[] args;
    public BeanInvocation(Object proxy, Method method, Object[] args) {
        this.proxy = proxy;
        this.method = method;
        this.args = args;
    }
    public Object[] getArgs() {
        return args;
    }
    public Method getMethod() {
        return method;
    }
    public Object getProxy() {
        return proxy;
    }
    /**
     * This causes us to invoke the endpoint Pojo using reflection.
     * 
     * @param pojo
     */
    public void invoke(Object pojo, Exchange exchange) {
        try {
            Object response = getMethod().invoke(pojo, getArgs());
            exchange.getOut().setBody(response);
        } catch (InvocationTargetException e) {
            exchange.setException(e.getCause());
        } catch (RuntimeException e) {
            throw e;
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
}
"
org.apache.camel.component.bean.BeanProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A {@link Processor} which converts the inbound exchange to a method
 * invocation on a POJO
 * 
 * @version $Revision: $
 */
public class BeanProcessor extends ServiceSupport implements Processor {
    public static final String METHOD_NAME = ""org.apache.camel.MethodName"";
    private static final Log LOG = LogFactory.getLog(BeanProcessor.class);
    private final Object pojo;
    private final BeanInfo beanInfo;
    private Method method;
    private String methodName;
    private final Processor processor;
    public BeanProcessor(Object pojo, BeanInfo beanInfo) {
        this.pojo = pojo;
        this.beanInfo = beanInfo;
        this.processor = CamelContextHelper.convertTo(beanInfo.getCamelContext(), Processor.class, pojo);
    }
    public BeanProcessor(Object pojo, CamelContext camelContext, ParameterMappingStrategy parameterMappingStrategy) {
        this(pojo, new BeanInfo(camelContext, pojo.getClass(), parameterMappingStrategy));
    }
    public BeanProcessor(Object pojo, CamelContext camelContext) {
        this(pojo, camelContext, createParameterMappingStrategy(camelContext));
    }
    public static ParameterMappingStrategy createParameterMappingStrategy(CamelContext camelContext) {
        Registry registry = camelContext.getRegistry();
        ParameterMappingStrategy answer = registry.lookup(ParameterMappingStrategy.class.getName(),
                                                          ParameterMappingStrategy.class);
        if (answer == null) {
            answer = new DefaultParameterMappingStrategy();
        }
        return answer;
    }
    @Override
    public String toString() {
        String description = method != null ? "" "" + method : """";
        return ""BeanProcessor["" + pojo + description + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> invoking method for: "" + exchange);
        }
        // do we have a custom adapter for this POJO to a Processor
        if (processor != null) {
            processor.process(exchange);
            return;
        }
        Message in = exchange.getIn();
        BeanInvocation beanInvoke = in.getBody(BeanInvocation.class);
        if (beanInvoke != null) {
            beanInvoke.invoke(pojo, exchange);
            return;
        }
        MethodInvocation invocation;
        if (method != null) {
            invocation = beanInfo.createInvocation(method, pojo, exchange);
        } else {
            // lets pass in the method name to use if its specified
            if (ObjectHelper.isNotNullAndNonEmpty(methodName)) {
                if (isNullOrBlank(in.getHeader(METHOD_NAME, String.class))) {
                    in.setHeader(METHOD_NAME, methodName);
                }
            }
            invocation = beanInfo.createInvocation(pojo, exchange);
        }
        if (invocation == null) {
            throw new IllegalStateException(""No method invocation could be created, no maching method could be found on: "" + pojo);
        }
        try {
            Object value = invocation.proceed();
            if (value != null) {
                exchange.getOut().setBody(value);
            }
        } catch (InvocationTargetException e) {
            // lets unwrap the exception
            Throwable cause = e.getTargetException();
            if (cause instanceof Exception) {
                throw (Exception) cause;
            }
            else {
                // TODO deal with errors!
                throw e;
            }
        } catch (Exception e) {
            throw e;
        } catch (Throwable throwable) {
            throw new Exception(throwable);
        }
    }
    // Properties
    // -----------------------------------------------------------------------
    public Method getMethod() {
        return method;
    }
    public void setMethod(Method method) {
        this.method = method;
    }
    public String getMethodName() {
        return methodName;
    }
    public void setMethodName(String methodName) {
        this.methodName = methodName;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startService(processor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopService(processor);
    }
}
"
org.apache.camel.component.bean.BeanWithExpressionInjectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.language.Simple;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.naming.Context;
/**
 * @version $Revision: 1.1 $
 */
public class BeanWithExpressionInjectionTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        String expectedBody = ""Wobble"";
        template.sendBodyAndHeader(""direct:in"", expectedBody, ""foo"", ""bar"");
        assertEquals(""bean body: "" + myBean, expectedBody, myBean.body);
        assertEquals(""bean foo: "" + myBean, ""bar"", myBean.foo);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public String body;
        public String foo;
        @Override
        public String toString() {
            return ""MyBean[foo: "" + foo + "" body: "" + body + ""]"";
        }
        public void read(String body, @Simple(""header.foo"") String foo) {
            this.foo = foo;
            this.body = body;
            LOG.info(""read() method called on "" + this);
        }
    }
}
"
org.apache.camel.component.bean.BeanWithPropertiesAndHeadersInjectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Headers;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.Properties;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.naming.Context;
import java.util.Map;
/**
 * @version $Revision: 1.1 $
 */
public class BeanWithPropertiesAndHeadersInjectionTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        template.send(""direct:in"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.setProperty(""p1"", ""abc"");
                exchange.setProperty(""p2"", 123);
                Message in = exchange.getIn();
                in.setHeader(""h1"", ""xyz"");
                in.setHeader(""h2"", 456);
            }
        });
        Map foo = myBean.foo;
        Map bar = myBean.bar;
        assertNotNull(""myBean.foo"", foo);
        assertNotNull(""myBean.bar"", bar);
        assertEquals(""foo.p1"", ""abc"", foo.get(""p1""));
        assertEquals(""foo.p2"", 123, foo.get(""p2""));
        assertEquals(""bar.h1"", ""xyz"", bar.get(""h1""));
        assertEquals(""bar.h2"", 456, bar.get(""h2""));
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public Map foo;
        public Map bar;
        @Override
        public String toString() {
            return ""MyBean[foo: "" + foo + "" bar: "" + bar + ""]"";
        }
        public void myMethod(@Properties Map foo, @Headers Map bar) {
            this.foo = foo;
            this.bar = bar;
            LOG.info(""myMethod() method called on "" + this);
        }
    }
}
"
org.apache.camel.component.bean.BodyAnnotationToDisambiguateMethodsTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.Body;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.naming.Context;
/**
 * @version $Revision: 1.1 $
 */
public class BodyAnnotationToDisambiguateMethodsTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        String expectedBody = ""Wobble"";
        template.sendBodyAndHeader(""direct:in"", expectedBody, ""foo"", ""bar"");
        assertEquals(""bean body: "" + myBean, expectedBody, myBean.body);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public String body;
        public void bar(String body) {
            fail(""bar() called with: "" + body);
        }
        public void foo(@Body String body) {
            this.body = body;
            LOG.info(""foo() method called on "" + this);
        }
        public void wrongMethod(String body) {
            fail(""wrongMethod() called with: "" + body);
        }
    }
}
"
org.apache.camel.component.bean.CamelInvocationHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.camel.Endpoint;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
/**
 * An {@link java.lang.reflect.InvocationHandler} which invokes a
 * message exchange on a camel {@link Endpoint}
 *
 * @version $Revision: $
 */
public class CamelInvocationHandler implements InvocationHandler {
    private final Endpoint endpoint;
    private final Producer producer;
    public CamelInvocationHandler(Endpoint endpoint, Producer producer) {
        this.endpoint = endpoint;
        this.producer = producer;
    }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        BeanInvocation invocation = new BeanInvocation(proxy, method, args);
        BeanExchange exchange = new BeanExchange(endpoint.getContext(), ExchangePattern.InOut);
        exchange.setInvocation(invocation);
        producer.process(exchange);
        Throwable fault = exchange.getException();
        if (fault != null) {
            throw new InvocationTargetException(fault);
        }
        return exchange.getOut().getBody();
    }
}
"
org.apache.camel.component.bean.DefaultAnnotationExpressionFactory,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.spi.Language;
import org.apache.camel.util.ObjectHelper;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
/**
 * @version $Revision: 1.1 $
 */
public class DefaultAnnotationExpressionFactory implements AnnotationExpressionFactory {
    public Expression createExpression(CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation, Class expressionReturnType) {
        String languageName = languageAnnotation.language();
        if (languageName == null) {
            throw new IllegalArgumentException(""Cannot determine the language from the annotation: "" + annotation);
        }
        Language language = camelContext.resolveLanguage(languageName);
        if (language == null) {
            throw new IllegalArgumentException(""Cannot find the language: "" + languageName + "" on the classpath"");
        }
        String expression = getExpressionFromAnnotation(annotation);
        return language.createExpression(expression);
    }
    protected String getExpressionFromAnnotation(Annotation annotation) {
        // lets try the 'value()' method
        try {
            Method method = annotation.getClass().getMethod(""value"");
            Object value = ObjectHelper.invokeMethod(method, annotation);
            if (value == null) {
                throw new IllegalArgumentException(""Cannot determine the expression from the annotation: "" + annotation);
            }
            return value.toString();
        }
        catch (NoSuchMethodException e) {
            throw new IllegalArgumentException(""Cannot determine the expression of the annotation: "" + annotation + "" as it does not have an value() method"");
        }
    }
}
"
org.apache.camel.component.bean.DefaultParameterMappingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.builder.ExpressionBuilder;
/**
 * Represents the strategy used to figure out how to map a message exchange to a POJO method invocation
 *
 * @version $Revision:$
 */
public class DefaultParameterMappingStrategy implements ParameterMappingStrategy {
    private Map<Class, Expression> parameterTypeToExpressionMap = new ConcurrentHashMap<Class, Expression>();
    public DefaultParameterMappingStrategy() {
    }
    public synchronized Expression getDefaultParameterTypeExpression(Class parameterType) {
        return parameterTypeToExpressionMap.get(parameterType);
    }
    /**
     * Adds a default parameter type mapping to an expression
     */
    public synchronized void addParameterMapping(Class parameterType, Expression expression) {
        parameterTypeToExpressionMap.put(parameterType, expression);
    }
    /**
     * Creates an invocation on the given POJO using annotations to decide which method to invoke
     * and to figure out which parameters to use
     */
/*
    public MethodInvocation createInvocation(Object pojo,
                                             BeanInfo beanInfo, 
                                             Exchange messageExchange,
                                             Endpoint pojoEndpoint) throws RuntimeCamelException {
        return beanInfo.createInvocation(pojo, messageExchange);
    }
*/
    public void loadDefaultRegistry() {
        addParameterMapping(Exchange.class, ExpressionBuilder.exchangeExpression());
        addParameterMapping(Message.class, ExpressionBuilder.inMessageExpression());
    }
}
"
org.apache.camel.component.bean.ExpressionAnnotationToDisambiguateMethodsTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.language.Simple;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.processor.BeanRouteTest;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.naming.Context;
/**
 * @version $Revision: 1.1 $
 */
public class ExpressionAnnotationToDisambiguateMethodsTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        template.sendBodyAndHeader(""direct:in"", ""<hello>world!</hello>"", ""foo"", ""bar"");
        assertEquals(""bean body: "" + myBean, ""bar"", myBean.bar);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public String bar;
        public void bar(String body) {
            fail(""bar() called with: "" + body);
        }
        public void foo(@Simple(""header.foo"") String bar) {
            this.bar = bar;
            LOG.info(""foo() method called with: "" + bar);
        }
        public void wrongMethod(String body) {
            fail(""wrongMethod() called with: "" + body);
        }
    }
}
"
org.apache.camel.component.bean.MethodInfo,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ExchangeHelper;
/**
 * @version $Revision: $
 */
public class MethodInfo {
    private Class type;
    private Method method;
    private final List<ParameterInfo> parameters;
    private final List<ParameterInfo> bodyParameters;
    private final boolean hasCustomAnnotation;
    private Expression parametersExpression;
    public MethodInfo(Class type, Method method, List<ParameterInfo> parameters, List<ParameterInfo> bodyParameters, boolean hasCustomAnnotation) {
        this.type = type;
        this.method = method;
        this.parameters = parameters;
        this.bodyParameters = bodyParameters;
        this.hasCustomAnnotation = hasCustomAnnotation;
        this.parametersExpression = createParametersExpression();
    }
    public String toString() {
        return method.toString();
    }
    public MethodInvocation createMethodInvocation(final Object pojo, final Exchange messageExchange) {
        final Object[] arguments = (Object[]) parametersExpression.evaluate(messageExchange);
        return new MethodInvocation() {
            public Method getMethod() {
                return method;
            }
            public Object[] getArguments() {
                return arguments;
            }
            public Object proceed() throws Throwable {
                return invoke(method, pojo, arguments, messageExchange);
            }
            public Object getThis() {
                return pojo;
            }
            public AccessibleObject getStaticPart() {
                return method;
            }
        };
    }
    public Class getType() {
        return type;
    }
    public Method getMethod() {
        return method;
    }
    public Expression getParametersExpression() {
        return parametersExpression;
    }
    public List<ParameterInfo> getBodyParameters() {
        return bodyParameters;
    }
    public Class getBodyParameterType() {
        ParameterInfo parameterInfo = bodyParameters.get(0);
        return parameterInfo.getType();
    }
    public boolean bodyParameterMatches(Class bodyType) {
        Class actualType = getBodyParameterType();
        return actualType != null && ObjectHelper.isAssignableFrom(bodyType, actualType);
    }
    public List<ParameterInfo> getParameters() {
        return parameters;
    }
    public boolean hasBodyParameter() {
        return !bodyParameters.isEmpty();
    }
    public boolean isHasCustomAnnotation() {
        return hasCustomAnnotation;
    }
    protected Object invoke(Method mth, Object pojo, Object[] arguments, Exchange exchange) throws IllegalAccessException, InvocationTargetException {
        return mth.invoke(pojo, arguments);
    }
    protected Expression createParametersExpression() {
        final int size = parameters.size();
        final Expression[] expressions = new Expression[size];
        for (int i = 0; i < size; i++) {
            Expression parameterExpression = parameters.get(i).getExpression();
            expressions[i] = parameterExpression;
        }
        return new Expression<Exchange>() {
            public Object evaluate(Exchange exchange) {
                Object[] answer = new Object[size];
                for (int i = 0; i < size; i++) {
                    Object value = expressions[i].evaluate(exchange);
                    // now lets try to coerce the value to the required type
                    value = ExchangeHelper.convertToType(exchange, parameters.get(i).getType(), value);
                    answer[i] = value;
                }
                return answer;
            }
            @Override
            public String toString() {
                return ""ParametersExpression: "" + Arrays.asList(expressions);
            }
        };
    }
}
"
org.apache.camel.component.bean.MethodInvocation,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Method;
/**
 * @version $Revision: $
 */
public interface MethodInvocation {
    Method getMethod();
    Object[] getArguments();
    Object proceed() throws Throwable;
    Object getThis();
    AccessibleObject getStaticPart();
}
"
org.apache.camel.component.bean.NoBeanAvailableException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelException;
/**
 * @version $Revision: 1.1 $
 */
public class NoBeanAvailableException extends CamelException {
    private final String name;
    public NoBeanAvailableException(String name) {
        super(""No bean available for endpoint: "" + name);
        this.name = name;
    }
    public String getName() {
        return name;
    }
}
"
org.apache.camel.component.bean.ParameterInfo,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.annotation.Annotation;
import org.apache.camel.Expression;
/**
 * @version $Revision: $
 */
public class ParameterInfo {
    private final int index;
    private final Class type;
    private final Annotation[] annotations;
    private final Expression expression;
    public ParameterInfo(int index, Class type, Annotation[] annotations, Expression expression) {
        this.index = index;
        this.type = type;
        this.annotations = annotations;
        this.expression = expression;
    }
    public Annotation[] getAnnotations() {
        return annotations;
    }
    public Expression getExpression() {
        return expression;
    }
    public int getIndex() {
        return index;
    }
    public Class getType() {
        return type;
    }
}
"
org.apache.camel.component.bean.ParameterMappingStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.Expression;
/**
 * A strategy for creating a default parameter expression for a given type
 *
 * @version $Revision: $
 */
public interface ParameterMappingStrategy {
    Expression getDefaultParameterTypeExpression(Class parameterType);
}
"
org.apache.camel.component.bean.ProxyHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import java.lang.reflect.Proxy;
import org.apache.camel.Endpoint;
import org.apache.camel.Producer;
/**
 * A helper class for creating proxies which delegate to Camel
 * 
 * @version $Revision: 519973 $
 */
public class ProxyHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private ProxyHelper() {        
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     * 
     * @throws Exception
     */
    public static Object createProxy(final Endpoint endpoint, ClassLoader cl, Class interfaces[])
        throws Exception {
        final Producer producer = endpoint.createProducer();
        return Proxy.newProxyInstance(cl, interfaces, new CamelInvocationHandler(endpoint, producer));
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     * 
     * @throws Exception
     */
    public static Object createProxy(Endpoint endpoint, Class interfaces[]) throws Exception {
        if (interfaces.length < 1) {
            throw new IllegalArgumentException(""You must provide at least 1 interface class."");
        }
        return createProxy(endpoint, interfaces[0].getClassLoader(), interfaces);
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     * 
     * @throws Exception
     */
    @SuppressWarnings(""unchecked"")
    public static <T> T createProxy(Endpoint endpoint, ClassLoader cl, Class<T> interfaceClass)
        throws Exception {
        return (T)createProxy(endpoint, cl, new Class[] {interfaceClass});
    }
    /**
     * Creates a Proxy which sends PojoExchange to the endpoint.
     * 
     * @throws Exception
     */
    @SuppressWarnings(""unchecked"")
    public static <T> T createProxy(Endpoint endpoint, Class<T> interfaceClass) throws Exception {
        return (T)createProxy(endpoint, new Class[] {interfaceClass});
    }
}
"
org.apache.camel.component.bean.XPathAnnotationExpressionFactory,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.bean;
import org.apache.camel.CamelContext;
import org.apache.camel.Expression;
import org.apache.camel.builder.xml.XPathBuilder;
import org.apache.camel.language.LanguageAnnotation;
import org.apache.camel.language.NamespacePrefix;
import org.apache.camel.language.XPath;
import java.lang.annotation.Annotation;
/**
 * @version $Revision: 1.1 $
 */
public class XPathAnnotationExpressionFactory extends DefaultAnnotationExpressionFactory {
    @Override
    public Expression createExpression(CamelContext camelContext, Annotation annotation, LanguageAnnotation languageAnnotation, Class expressionReturnType) {
        String xpath = getExpressionFromAnnotation(annotation);
        XPathBuilder builder = XPathBuilder.xpath(xpath);
        if (annotation instanceof XPath) {
            XPath xpathAnnotation = (XPath) annotation;
            NamespacePrefix[] namespaces = xpathAnnotation.namespaces();
            if (namespaces != null) {
                for (NamespacePrefix namespacePrefix : namespaces) {
                    builder = builder.namespace(namespacePrefix.prefix(), namespacePrefix.uri());
                }
            }
        }
        return builder;
    }
}
"
org.apache.camel.component.direct.DirectComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import java.util.Map;
/**
 * Represents the component that manages {@link DirectEndpoint}. It holds the
 * list of named direct endpoints.
 *
 * @version $Revision: 519973 $
 */
public class DirectComponent<E extends Exchange> extends DefaultComponent<E> {
    protected Endpoint<E> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Endpoint<E> endpoint = new DirectEndpoint<E>(uri, this);
        setProperties(endpoint, parameters);
        return endpoint;
    }
}
"
org.apache.camel.component.direct.DirectEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;
import java.util.ArrayList;
import java.util.concurrent.CopyOnWriteArrayList;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a direct endpoint that synchronously invokes the consumers of the
 * endpoint when a producer sends a message to it.
 * 
 * @version $Revision: 519973 $
 */
public class DirectEndpoint<E extends Exchange> extends DefaultEndpoint<E> {
    private final class DirectProducer extends DefaultProducer implements AsyncProcessor {
        private DirectProducer(Endpoint endpoint) {
            super(endpoint);
        }
        public void process(Exchange exchange) throws Exception {
            if (consumers.isEmpty()) {
                LOG.warn(""No consumers available on "" + this + "" for "" + exchange);
            } else {
                for (DefaultConsumer<E> consumer : consumers) {
                    consumer.getProcessor().process(exchange);
                }
            }
        }
        public boolean process(Exchange exchange, AsyncCallback callback) {
            int size = consumers.size();
            if (size == 0) {
                LOG.warn(""No consumers available on "" + this + "" for "" + exchange);
            } else {
                if (size > 1) {
                    // Too hard to do multiple async.. do it sync
                    try {
                        for (DefaultConsumer<E> consumer : consumers) {
                            consumer.getProcessor().process(exchange);
                        }
                    } catch (Throwable error) {
                        exchange.setException(error);
                    }
                } else {
                    for (DefaultConsumer<E> consumer : consumers) {
                        AsyncProcessor processor = AsyncProcessorTypeConverter.convert(consumer.getProcessor());
                        return processor.process(exchange, callback);
                    }
                }
            }
            callback.done(true);
            return true;
        }
    }
    private static final Log LOG = LogFactory.getLog(DirectEndpoint.class);
    boolean allowMultipleConsumers = true;
    private final CopyOnWriteArrayList<DefaultConsumer<E>> consumers = new CopyOnWriteArrayList<DefaultConsumer<E>>();
    public DirectEndpoint(String uri, DirectComponent<E> component) {
        super(uri, component);
    }
    public Producer createProducer() throws Exception {
        return new DirectProducer(this);
    }
    public Consumer<E> createConsumer(Processor processor) throws Exception {
        return new DefaultConsumer<E>(this, processor) {
            @Override
            public void start() throws Exception {
                if (!allowMultipleConsumers && !consumers.isEmpty()) {
                    throw new IllegalStateException(""Endpoint "" + getEndpointUri() + "" only allows 1 active consumer but you attempted to start a 2nd consumer."");
                }
                consumers.add(this);
                super.start();
            }
            @Override
            public void stop() throws Exception {
                super.stop();
                consumers.remove(this);
            }
        };
    }
    public boolean isAllowMultipleConsumers() {
        return allowMultipleConsumers;
    }
    public void setAllowMultipleConsumers(boolean allowMutlipleConsumers) {
        this.allowMultipleConsumers = allowMutlipleConsumers;
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.component.direct.DirectRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.direct;
import java.util.concurrent.atomic.AtomicBoolean;
import junit.framework.TestCase;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
/**
 * @version $Revision: 520220 $
 */
public class DirectRouteTest extends TestCase {
    public void testSedaQueue() throws Exception {
        CamelContext container = new DefaultCamelContext();
        final AtomicBoolean invoked = new AtomicBoolean();
        // lets add some routes
        container.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""direct:test.a"").to(""direct:test.b"");
                from(""direct:test.b"").process(new Processor() {
                    public void process(Exchange e) {
                        invoked.set(true);
                    }
                });
            }
        });
        container.start();
        // now lets fire in a message
        Endpoint<Exchange> endpoint = container.getEndpoint(""direct:test.a"");
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setHeader(""cheese"", 123);
        Producer<Exchange> producer = endpoint.createProducer();
        producer.process(exchange);
        // now lets sleep for a while
        assertTrue(""Did not receive the message!"", invoked.get());
        container.stop();
    }
}
"
org.apache.camel.component.file.FileAsyncRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 578206 $
 */
public class FileAsyncRouteTest extends ContextTestSupport {
    protected Object expectedBody = ""Hello there!"";
    protected String uri = ""file:target/test-async-inbox?delete=true"";
    CountDownLatch receivedLatch = new CountDownLatch(1);
    CountDownLatch processingLatch = new CountDownLatch(1);
    AtomicReference<File> file = new AtomicReference<File>();
    @Override
    protected void tearDown() throws Exception {
        processingLatch.countDown();
        receivedLatch.countDown();
        super.tearDown();
    }
    public void testFileRoute() throws Exception {
        MockEndpoint result = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        result.expectedBodiesReceived(expectedBody);
        result.setDefaulResultWaitMillis(5000);
        template.sendBodyAndHeader(uri, expectedBody, ""cheese"", 123);
        // Wait till the exchange is delivered to the processor
        assertTrue(""Async processor received exchange"", receivedLatch.await(5, TimeUnit.SECONDS));
        File file = this.file.get();
        // The file consumer support async processing of the exchange,
        // so the file should not get deleted until the exchange
        // finishes being asynchronously processed.
        Thread.sleep(1000);
        assertTrue(""File should exist"", file.exists());
        // Release the async processing thread so that the exchange completes
        // and the file
        // gets deleted.
        processingLatch.countDown();
        Thread.sleep(1000);
        assertFalse(""File should not exist"", file.exists());
        result.assertIsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(uri).thread(1).to(""direct:a"");
                from(""direct:a"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        file.set((File)exchange.getIn().getBody());
                        // Simulate a processing delay..
                        receivedLatch.countDown();
                        processingLatch.await();
                    }
                }).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.file.FileComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import java.io.File;
import java.util.Map;
/**
 * The <a href=""http://activemq.apache.org/camel/file.html"">File Component</a>
 * for working with file systems
 * 
 * @version $Revision: 523772 $
 */
public class FileComponent extends DefaultComponent<FileExchange> {
    public static final String HEADER_FILE_NAME = ""org.apache.camel.file.name"";
    public FileComponent() {
    }
    public FileComponent(CamelContext context) {
        super(context);
    }
    protected Endpoint<FileExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        File file = new File(remaining);
        FileEndpoint result = new FileEndpoint(file, uri, this);
        setProperties(result, parameters);
        return result;
    }
}
"
org.apache.camel.component.file.FileConfigureTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
import org.apache.camel.ContextTestSupport;
/**
 * @version $Revision: 1.1 $
 */
public class FileConfigureTest extends ContextTestSupport {
    private static final String EXPECT_PATH = ""target"" + File.separator + ""foo"" + File.separator + ""bar"";
    public void testUriConfigurations() throws Exception {
        assertFileEndpoint(""file://target/foo/bar"", EXPECT_PATH);
        assertFileEndpoint(""file://target/foo/bar?delete=true"", EXPECT_PATH);
        assertFileEndpoint(""file:target/foo/bar?delete=true"", EXPECT_PATH);
        assertFileEndpoint(""file:target/foo/bar"", EXPECT_PATH);
        assertFileEndpoint(""file://target/foo/bar/"", EXPECT_PATH);
        assertFileEndpoint(""file://target/foo/bar/?delete=true"", EXPECT_PATH);
        assertFileEndpoint(""file:target/foo/bar/?delete=true"", EXPECT_PATH);
        assertFileEndpoint(""file:target/foo/bar/"", EXPECT_PATH);
        assertFileEndpoint(""file:/target/foo/bar/"", File.separator + EXPECT_PATH);        
        assertFileEndpoint(""file:/"", File.separator);
        assertFileEndpoint(""file:///"", File.separator);
    }
    private void assertFileEndpoint(String endpointUri, String expectedPath) {
        FileEndpoint endpoint = resolveMandatoryEndpoint(endpointUri, FileEndpoint.class);
        assertNotNull(""Could not find endpoint: "" + endpointUri, endpoint);
        File file = endpoint.getFile();
        String path = file.getPath();
        assertEquals(""For uri: "" + endpointUri + "" the file is not equal"", expectedPath, path);
    }
}
"
org.apache.camel.component.file.FileConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.component.file.strategy.FileProcessStrategy;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.io.File;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
/**
 * @version $Revision: 523016 $
 */
public class FileConsumer extends ScheduledPollConsumer<FileExchange> {
    private static final transient Log LOG = LogFactory.getLog(FileConsumer.class);
    private final FileEndpoint endpoint;
    private boolean recursive = true;
    private String regexPattern = """";
    private long lastPollTime;
    boolean generateEmptyExchangeWhenIdle;
    public FileConsumer(final FileEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    protected void poll() throws Exception {
        int rc = pollFileOrDirectory(endpoint.getFile(), isRecursive());
        if( rc == 0 && generateEmptyExchangeWhenIdle ) {
            final FileExchange exchange = endpoint.createExchange((File)null);
            getAsyncProcessor().process(exchange, new AsyncCallback() {
                public void done(boolean sync) {
                }
            });
        }
        lastPollTime = System.currentTimeMillis();
    }
    /**
     * 
     * @param fileOrDirectory
     * @param processDir
     * @return the number of files processed or being processed async.
     */
    protected int pollFileOrDirectory(File fileOrDirectory, boolean processDir) {
        if (!fileOrDirectory.isDirectory()) {
            return pollFile(fileOrDirectory); // process the file
        }
        else if (processDir) {
            int rc = 0;
            if (isValidFile(fileOrDirectory)) {
                LOG.debug(""Polling directory "" + fileOrDirectory);
                File[] files = fileOrDirectory.listFiles();
                for (int i = 0; i < files.length; i++) {
                    rc += pollFileOrDirectory(files[i], isRecursive()); // self-recursion
                }
            }
            return rc; 
        }
        else {
            LOG.debug(""Skipping directory "" + fileOrDirectory);
            return 0;
        }
    }
    ConcurrentHashMap<File, File> filesBeingProcessed = new ConcurrentHashMap<File, File>();
    /**
     * @param file
     * @return the number of files processed or being processed async.
     */
    protected int pollFile(final File file) {
        if (!file.exists()) {
            return 0;
        }
        if( !isValidFile(file) ) {
            return 0;
        }
        // we only care about file modified times if we are not deleting/moving files
        if (endpoint.isNoop()) {
            long fileModified = file.lastModified();
            if (fileModified <= lastPollTime) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Ignoring file: "" + file + "" as modified time: "" + fileModified + "" less than last poll time: "" + lastPollTime);
                }
                return 0;
            }
        } else {
            if (filesBeingProcessed.contains(file)) {
                return 1;
            }
            filesBeingProcessed.put(file, file);
        }
        final FileProcessStrategy processStrategy = endpoint.getFileStrategy();
        final FileExchange exchange = endpoint.createExchange(file);
        endpoint.configureMessage(file, exchange.getIn());
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""About to process file:  "" + file + "" using exchange: "" + exchange);
            }
            if (processStrategy.begin(endpoint, exchange, file)) {
                // Use the async processor interface so that processing of
                // the
                // exchange can happen asynchronously
                getAsyncProcessor().process(exchange, new AsyncCallback() {
                    public void done(boolean sync) {
                        if (exchange.getException() == null) {
                            try {
                                processStrategy.commit(endpoint, (FileExchange)exchange, file);
                            } catch (Exception e) {
                                handleException(e);
                            }
                        } else {
                            handleException(exchange.getException());
                        }
                        filesBeingProcessed.remove(file);
                    }
                });
            }
            else {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(endpoint + "" cannot process file: "" + file);
                }
            }
        }
        catch (Throwable e) {
            handleException(e);
        }
        return 1;
    }
    protected boolean isValidFile(File file) {
        boolean result = false;
        if (file != null && file.exists()) {
            if (isMatched(file)) {
                result = true;
            }
        }
        return result;
    }
    protected boolean isMatched(File file) {
        String name = file.getName();
        if (regexPattern != null && regexPattern.length() > 0) {
            if (!name.matches(getRegexPattern())) {
                return false;
            }
        }
        String[] prefixes = endpoint.getExcludedNamePrefixes();
        if (prefixes != null) {
            for (String prefix : prefixes) {
                if (name.startsWith(prefix)) {
                    return false;
                }
            }
        }
        String[] postfixes = endpoint.getExcludedNamePostfixes();
        if (postfixes != null) {
            for (String postfix : postfixes) {
                if (name.endsWith(postfix)) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * @return the recursive
     */
    public boolean isRecursive() {
        return this.recursive;
    }
    /**
     * @param recursive the recursive to set
     */
    public void setRecursive(boolean recursive) {
        this.recursive = recursive;
    }
    /**
     * @return the regexPattern
     */
    public String getRegexPattern() {
        return this.regexPattern;
    }
    /**
     * @param regexPattern the regexPattern to set
     */
    public void setRegexPattern(String regexPattern) {
        this.regexPattern = regexPattern;
    }
    public boolean isGenerateEmptyExchangeWhenIdle() {
        return generateEmptyExchangeWhenIdle;
    }
    public void setGenerateEmptyExchangeWhenIdle(boolean generateEmptyExchangeWhenIdle) {
        this.generateEmptyExchangeWhenIdle = generateEmptyExchangeWhenIdle;
    }
}
"
org.apache.camel.component.file.FileConsumerProducerRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 529902 $
 */
public class FileConsumerProducerRouteTest extends ContextTestSupport {
    public void testFileRoute() throws Exception {
        MockEndpoint result = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        result.expectedMessageCount(2);
        result.setDefaulResultWaitMillis(10000);
        result.assertIsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""file:src/main/data?noop=true"").to(""file:target/test-consumer-produer-inbox"");
                from(""file:target/test-consumer-produer-inbox"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.file.FileDeleteRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
/**
 * @version $Revision: 1.1 $
 */
public class FileDeleteRouteTest extends FileRouteTest {
    @Override
    protected void setUp() throws Exception {
        uri = ""file:target/test-rename-inbox?delete=true"";
        super.setUp();
    }
}
"
org.apache.camel.component.file.FileEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.component.file.strategy.DefaultFileRenamer;
import org.apache.camel.component.file.strategy.DeleteFileProcessStrategy;
import org.apache.camel.component.file.strategy.FileProcessStrategy;
import org.apache.camel.component.file.strategy.FileProcessStrategySupport;
import org.apache.camel.component.file.strategy.NoOpFileProcessStrategy;
import org.apache.camel.component.file.strategy.RenameFileProcessStrategy;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.io.File;
/**
 * A <a href=""http://activemq.apache.org/camel/file.html"">File Endpoint</a> for
 * working with file systems
 * 
 * @version $Revision: 523016 $
 */
public class FileEndpoint extends ScheduledPollEndpoint<FileExchange> {
    private static final transient Log LOG = LogFactory.getLog(FileEndpoint.class);
    private File file;
    private FileProcessStrategy fileProcessStrategy;
    private boolean autoCreate = true;
    private boolean lock = true;
    private boolean delete;
    private boolean noop;
    private boolean append = true;
    private String moveNamePrefix;
    private String moveNamePostfix;
    private String[] excludedNamePrefixes = {"".""};
    private String[] excludedNamePostfixes = { FileProcessStrategySupport.DEFAULT_LOCK_FILE_POSTFIX };
    private int bufferSize = 128 * 1024;
    private boolean ignoreFileNameHeader;
    protected FileEndpoint(File file, String endpointUri, FileComponent component) {
        super(endpointUri, component);
        this.file = file;
    }
    /**
     * @return a Producer
     * @throws Exception
     * @see org.apache.camel.Endpoint#createProducer()
     */
    public Producer<FileExchange> createProducer() throws Exception {
        Producer<FileExchange> result = new FileProducer(this);
        return result;
    }
    /**
     * @param file
     * @return a Consumer
     * @throws Exception
     * @see org.apache.camel.Endpoint#createConsumer(org.apache.camel.Processor)
     */
    public Consumer<FileExchange> createConsumer(Processor file) throws Exception {
        Consumer<FileExchange> result = new FileConsumer(this, file);
        configureConsumer(result);
        return result;
    }
    /**
     * @param file
     * @return a FileExchange
     * @see org.apache.camel.Endpoint#createExchange()
     */
    public FileExchange createExchange(File file) {
        return new FileExchange(getContext(), getExchangePattern(), file);
    }
    /**
     * @return an Exchange
     * @see org.apache.camel.Endpoint#createExchange()
     */
    public FileExchange createExchange() {
        return createExchange(getFile());
    }
    public FileExchange createExchange(ExchangePattern pattern) {
        return new FileExchange(getContext(), pattern, file);
    }
    /**
     * Configures the given message with the file which sets the body to the file object
     * and sets the {@link FileComponent#HEADER_FILE_NAME} header.
     */
    public void configureMessage(File file, Message message) {
        message.setBody(file);
        String path = file.getPath();
        String relativePath = path.substring(path.length());
        if (relativePath.startsWith(File.separator) || relativePath.startsWith(""/"")) {
            relativePath = relativePath.substring(1);
        }
        message.setHeader(FileComponent.HEADER_FILE_NAME, relativePath);
    }
    public File getFile() {
        if (autoCreate && !file.exists()) {
            file.mkdirs();
        }
        return file;
    }
    public boolean isSingleton() {
        return true;
    }
    /**
     * @return the autoCreate
     */
    public boolean isAutoCreate() {
        return this.autoCreate;
    }
    /**
     * @param autoCreate the autoCreate to set
     */
    public void setAutoCreate(boolean autoCreate) {
        this.autoCreate = autoCreate;
    }
    public FileProcessStrategy getFileStrategy() {
        if (fileProcessStrategy == null) {
            fileProcessStrategy = createFileStrategy();
            LOG.debug("""" + this + "" using strategy: "" + fileProcessStrategy);
        }
        return fileProcessStrategy;
    }
    /**
     * Sets the strategy to be used when the file has been processed such as
     * deleting or renaming it etc.
     * 
     * @param fileProcessStrategy the new stategy to use
     */
    public void setFileStrategy(FileProcessStrategy fileProcessStrategy) {
        this.fileProcessStrategy = fileProcessStrategy;
    }
    public boolean isDelete() {
        return delete;
    }
    public void setDelete(boolean delete) {
        this.delete = delete;
    }
    public boolean isLock() {
        return lock;
    }
    public void setLock(boolean lock) {
        this.lock = lock;
    }
    public String getMoveNamePostfix() {
        return moveNamePostfix;
    }
    /**
     * Sets the name postfix appended to moved files. For example to rename all
     * the files from * to *.done set this value to "".done""
     * 
     * @param moveNamePostfix
     * @see DefaultFileRenamer#setNamePostfix(String)
     */
    public void setMoveNamePostfix(String moveNamePostfix) {
        this.moveNamePostfix = moveNamePostfix;
    }
    public String getMoveNamePrefix() {
        return moveNamePrefix;
    }
    /**
     * Sets the name prefix appended to moved files. For example to move
     * processed files into a hidden directory called "".camel"" set this value to
     * "".camel/""
     * 
     * @see DefaultFileRenamer#setNamePrefix(String)
     */
    public void setMoveNamePrefix(String moveNamePrefix) {
        this.moveNamePrefix = moveNamePrefix;
    }
    public String[] getExcludedNamePrefixes() {
        return excludedNamePrefixes;
    }
    /**
     * Sets the excluded file name prefixes, such as ""."" for hidden files which
     * are excluded by default
     */
    public void setExcludedNamePrefixes(String[] excludedNamePrefixes) {
        this.excludedNamePrefixes = excludedNamePrefixes;
    }
    public String[] getExcludedNamePostfixes() {
        return excludedNamePostfixes;
    }
    /**
     * Sets the excluded file name postfixes, such as {@link FileProcessStrategySupport#DEFAULT_LOCK_FILE_POSTFIX}
     * to ignore lock files by default.
     */
    public void setExcludedNamePostfixes(String[] excludedNamePostfixes) {
        this.excludedNamePostfixes = excludedNamePostfixes;
    }
    public boolean isNoop() {
        return noop;
    }
    /**
     * If set to true then the default {@link FileProcessStrategy} will be to use the
     * {@link NoOpFileProcessStrategy} to not move or copy processed files
     * 
     * @param noop
     */
    public void setNoop(boolean noop) {
        this.noop = noop;
    }
    public boolean isAppend() {
        return append;
    }
    /**
     * When writing do we append to the end of the file, or replace it?
     * The default is to append
     *
     * @param append whether to append (or replace)
     */
    public void setAppend(boolean append) {
        this.append = append;
    }
    public int getBufferSize() {
        return bufferSize;
    }
    /**
     * Sets the buffer size used to read/write files
     */
    public void setBufferSize(int bufferSize) {
        this.bufferSize = bufferSize;
    }
    public boolean isIgnoreFileNameHeader() {
        return ignoreFileNameHeader;
    }
    /**
     * If this flag is enabled then producers will ignore the {@link FileComponent#HEADER_FILE_NAME}
     * header and generate a new dynamic file
     */
    public void setIgnoreFileNameHeader(boolean ignoreFileNameHeader) {
        this.ignoreFileNameHeader = ignoreFileNameHeader;
    }
    /**
     * A strategy method to lazily create the file strategy
     */
    protected FileProcessStrategy createFileStrategy() {
        if (isNoop()) {
            return new NoOpFileProcessStrategy();
        } else if (moveNamePostfix != null || moveNamePrefix != null) {
            if (isDelete()) {
                throw new IllegalArgumentException(
                                                   ""You cannot set the deleteFiles property and a moveFilenamePostfix or moveFilenamePrefix"");
            }
            return new RenameFileProcessStrategy(isLock(), moveNamePrefix, moveNamePostfix);
        } else if (isDelete()) {
            return new DeleteFileProcessStrategy(isLock());
        } else {
            return new RenameFileProcessStrategy(isLock());
        }
    }
}
"
org.apache.camel.component.file.FileExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import java.io.File;
/**
 * A {@link Exchange} for File
 *
 * @version $Revision: 520985 $
 */
public class FileExchange extends DefaultExchange {
    private File file;
    public FileExchange(CamelContext camelContext, ExchangePattern pattern, File file) {
        super(camelContext, pattern);
        setIn(new FileMessage(file));
        this.file = file;
    }
    /**
     * @return the file
     */
    public File getFile() {
        return this.file;
    }
    /**
     * @param file the file to set
     */
    public void setFile(File file) {
        this.file = file;
    }
    public Exchange newInstance() {
        return new FileExchange(getContext(), getPattern(), getFile());
    }
}
"
org.apache.camel.component.file.FileExchangeTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ExchangePattern;
import org.apache.camel.processor.Pipeline;
import java.io.File;
import java.util.Collections;
/**
 * @version $Revision: 1.1 $
 */
public class FileExchangeTest extends ContextTestSupport {
    protected File file;
    protected ExchangePattern pattern = ExchangePattern.InOnly;
    public void testCopy() {
        FileExchange fileExchange = new FileExchange(context, pattern, file);
        Exchange exchange = fileExchange.copy();
        FileExchange copy = assertIsInstanceOf(FileExchange.class, exchange);
        assertEquals(""File"", file, copy.getFile());
        Object body = copy.getIn().getBody();
        assertNotNull(""Should have a body!"", body);
    }
    public void testCopyAfterBodyChanged() throws Exception {
        FileExchange original = new FileExchange(context, pattern, file);
        Object expectedBody = 1234;
        original.getIn().setBody(expectedBody);
        Exchange exchange = original.copy();
        FileExchange copy = assertIsInstanceOf(FileExchange.class, exchange);
        assertEquals(""File"", file, copy.getFile());
        Object body = copy.getIn().getBody();
        assertNotNull(""Should have a body!"", body);
        assertEquals(""Copied exchange in body"", expectedBody, body);
    }
    public void testPipelineCopy() throws Exception {
        Processor myProcessor = new Processor() {
            public void process(Exchange exchange) throws Exception {
                Object body = exchange.getIn().getBody();
                assertNotNull(""Should have a body!"", body);
            }
        };
        Pipeline pipeline = new Pipeline(Collections.singletonList(myProcessor));
        FileExchange exchange = new FileExchange(context, pattern, file);
        pipeline.process(exchange.copy());            
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        file = new File(FileExchangeTest.class.getResource(""FileExchangeTest.class"").getFile());
    }
}
"
org.apache.camel.component.file.FileMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultMessage;
import java.io.File;
/**
 * A {@link Exchange} for File
 * 
 * @version $Revision: 520985 $
 */
public class FileMessage extends DefaultMessage {
    private File file;
    public FileMessage() {
        this(new File("".""));
    }
    public FileMessage(File file) {
        this.file = file;
    }
    @Override
    public String toString() {
        return ""FileMessage: "" + file;
    }
    @Override
    public FileExchange getExchange() {
        return (FileExchange)super.getExchange();
    }
    public File getFile() {
        return file;
    }
    public void setFile(File file) {
        this.file = file;
    }
    @Override
    public FileMessage newInstance() {
        return new FileMessage();
    }
    @Override
    protected Object createBody() {
        return file;
    }
}
"
org.apache.camel.component.file.FileNoOpRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
/**
 * @version $Revision: 1.1 $
 */
public class FileNoOpRouteTest extends FileRouteTest {
    @Override
    protected void setUp() throws Exception {
        uri = ""file:target/test-noop-inbox?noop=true"";
        // lets delete all the files
        File oldDir = new File(""target/test-noop-inbox"");
        if (oldDir.exists()) {
            File parentDir = oldDir.getParentFile();
            File[] files = parentDir.listFiles();
            File newName = new File(parentDir, oldDir.getName() + ""-"" + (files.length + 1));
            log.debug(""renaming old output: "" + oldDir + "" to: "" + newName);
            oldDir.renameTo(newName);
        }
        super.setUp();
    }
}
"
org.apache.camel.component.file.FileProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
/**
 * A {@link Producer} implementation for File
 *
 * @version $Revision: 523016 $
 */
public class FileProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(FileProducer.class);
    private final FileEndpoint endpoint;
    public FileProducer(FileEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public FileEndpoint getEndpoint() {
        return (FileEndpoint) super.getEndpoint();
    }
    /**
     * @param exchange
     * @see org.apache.camel.Processor#process(Exchange)
     */
    public void process(Exchange exchange) throws Exception {
        // TODO is it really worth using a FileExchange as the core type?
        FileExchange fileExchange = endpoint.createExchange(exchange);
        process(fileExchange);
        ExchangeHelper.copyResults(exchange, fileExchange);
    }
    public void process(FileExchange exchange) throws Exception {
        if (ExchangeHelper.isOutCapable(exchange)) {
            // lets poll the file
            Message out = exchange.getOut(true);
            endpoint.configureMessage(endpoint.getFile(), out);
            return;
        }
        InputStream in = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);
        File file = createFileName(exchange.getIn());
        buildDirectory(file);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""About to write to: "" + file + "" from exchange: "" + exchange);
        }
        FileChannel fc = null;
        try {
            if (getEndpoint().isAppend()) {
                fc = new RandomAccessFile(file, ""rw"").getChannel();
                fc.position(fc.size());
            }
            else {
                fc = new FileOutputStream(file).getChannel();
            }
            int size = getEndpoint().getBufferSize();
            byte[] buffer = new byte[size];
            ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);
            while (true) {
                int count = in.read(buffer);
                if (count <= 0) {
                    break;
                }
                else if (count < size) {
                    byteBuffer = ByteBuffer.wrap(buffer, 0, count);
                    fc.write(byteBuffer);
                    break;
                }
                else {
                    fc.write(byteBuffer);
                    byteBuffer.clear();
                }
            }
        }
        finally {
            if (in != null) {
                try {
                    in.close();
                }
                catch (IOException e) {
                    LOG.warn(""Failed to close input: "" + e, e);
                }
            }
            if (fc != null) {
                try {
                    fc.close();
                }
                catch (IOException e) {
                    LOG.warn(""Failed to close output: "" + e, e);
                }
            }
        }
        /*
        ByteBuffer payload = exchange.getIn().getBody(ByteBuffer.class);
        if (payload == null) {
            InputStream in = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);
            payload = ExchangeHelper.convertToMandatoryType(exchange, ByteBuffer.class, in);
        }
        payload.flip();
        File file = createFileName(exchange);
        buildDirectory(file);
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Creating file: "" + file);
        }
        FileChannel fc = null;
        try {
            if (getEndpoint().isAppend()) {
                fc = new RandomAccessFile(file, ""rw"").getChannel();
                fc.position(fc.size());
            }
            else {
                fc = new FileOutputStream(file).getChannel();
            }
            fc.write(payload);
        }
        catch (Throwable e) {
            LOG.error(""Failed to write to File: "" + file, e);
        }
        finally {
            if (fc != null) {
                fc.close();
            }
        }
        */
    }
    protected File createFileName(Message message) {
        File answer;
        File endpointFile = endpoint.getFile();
        String name = null;
        if (!endpoint.isIgnoreFileNameHeader()) {
            name = message.getHeader(FileComponent.HEADER_FILE_NAME, String.class);
        }
        if (endpointFile.isDirectory()) {
            if (name != null) {
                answer = new File(endpointFile, name);
                if (answer.isDirectory()) {
                    answer = new File(answer, message.getMessageId());
                }
            } else {
                answer = new File(endpointFile, message.getMessageId());
            }
        } else {
            answer = endpointFile;
        }
        return answer;
    }
    private void buildDirectory(File file) {
        String dirName = file.getAbsolutePath();
        int index = dirName.lastIndexOf(File.separatorChar);
        if (index > 0) {
            dirName = dirName.substring(0, index);
            File dir = new File(dirName);
            dir.mkdirs();
        }
    }
}
"
org.apache.camel.component.file.FileRenameRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import java.io.File;
/**
 * @version $Revision: 1.1 $
 */
public class FileRenameRouteTest extends FileRouteTest {
    @Override
    protected void setUp() throws Exception {
        recursiveDelete(new File(""target/test-rename-inbox""));
        uri = ""file:target/test-rename-inbox?moveNamePrefix=foo/"";
        super.setUp();
    }
}
"
org.apache.camel.component.file.FileRouteGenerateEmptyExchangeWhenIdleTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 581116 $
 */
public class FileRouteGenerateEmptyExchangeWhenIdleTest extends ContextTestSupport {
    protected Object expectedBody = ""Hello there!"";
    protected String uri = ""file:target/test-default-inbox?consumer.generateEmptyExchangeWhenIdle=true"";
    public void testFileRoute() throws Exception {
        MockEndpoint result = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        result.expectedMinimumMessageCount(2);
        result.setDefaulResultWaitMillis(5000);
        template.sendBodyAndHeader(uri, expectedBody, ""cheese"", 123);
        result.assertIsSatisfied();
        int fileCount=0;
        int nullCount=0;
        for (Exchange exchange : result.getReceivedExchanges()) {
            assertTrue( exchange instanceof FileExchange );
            FileExchange fx = (FileExchange)exchange;
            if( fx.getFile() == null ) {
                nullCount++;
            } else {
                fileCount++;
            }
        }
        assertEquals(1, fileCount);
        assertTrue( nullCount > 0 );
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(uri).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.file.FileRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 529902 $
 */
public class FileRouteTest extends ContextTestSupport {
    protected Object expectedBody = ""Hello there!"";
    protected String uri = ""file:target/test-default-inbox"";
    public void testFileRoute() throws Exception {
        MockEndpoint result = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        result.expectedBodiesReceived(expectedBody);
        result.setDefaulResultWaitMillis(5000);
        template.sendBodyAndHeader(uri, expectedBody, ""cheese"", 123);
        result.assertIsSatisfied();
    }
    @Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(uri).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.file.strategy.DefaultFileRenamer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
/**
 * @version $Revision: 1.1 $
 */
public class DefaultFileRenamer implements FileRenamer {
	private static final boolean ON_WINDOWS = System.getProperty(""os.name"").startsWith(""Windows"");
    private String namePrefix;
    private String namePostfix;
    public DefaultFileRenamer() {
    }
    public DefaultFileRenamer(String namePrefix, String namePostfix) {
        this.namePrefix = namePrefix;
        this.namePostfix = namePostfix;
    }
    public File renameFile(File file) {
        File parent = file.getParentFile();
        String name = renameFileName(file);
        if( ON_WINDOWS && ( name.indexOf("":"")>=0 || name.startsWith(""//"") )) {
            return new File(name);
        }        
        return new File(parent, name);
    }
    public String getNamePostfix() {
        return namePostfix;
    }
    /**
     * Sets the name postfix appended to moved files. For example
     * to rename all the files from * to *.done set this value to "".done""
     */
    public void setNamePostfix(String namePostfix) {
        this.namePostfix = namePostfix;
    }
    public String getNamePrefix() {
        return namePrefix;
    }
    /**
     * Sets the name prefix appended to moved files. For example
     * to move processed files into a hidden directory called "".camel""
     * set this value to "".camel/""
     */
    public void setNamePrefix(String namePrefix) {
        this.namePrefix = namePrefix;
    }
    protected String renameFileName(File file) {
        StringBuffer buffer = new StringBuffer();
        if (namePrefix != null) {
            buffer.append(namePrefix);
        }
        buffer.append(file.getName());
        if (namePostfix != null) {
            buffer.append(namePostfix);
        }
        return buffer.toString();
    }
}
"
org.apache.camel.component.file.strategy.DeleteFileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import org.apache.camel.component.file.FileEndpoint;
import org.apache.camel.component.file.FileExchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A strategy which will delete the file when its processed
 *
 * @version $Revision: 1.1 $
 */
public class DeleteFileProcessStrategy extends FileProcessStrategySupport {
    private static final transient Log LOG = LogFactory.getLog(DeleteFileProcessStrategy.class);
    public DeleteFileProcessStrategy() {
    }
    public DeleteFileProcessStrategy(boolean lockFile) {
        super(lockFile);
    }
    public void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Deleting file: "" + file);
        }
        file.delete();
        super.commit(endpoint, exchange, file);
    }
}
"
org.apache.camel.component.file.strategy.FileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import org.apache.camel.component.file.FileEndpoint;
import org.apache.camel.component.file.FileExchange;
/**
 * Represents a strategy for marking that a file is processed.
 *
 * @version $Revision: 1.1 $
 */
public interface FileProcessStrategy {
    /**
     * Called when work is about to begin on this file. This method may attempt to acquire some file lock before
     * returning true; returning false if the file lock could not be obtained so that the file should be ignored.
     *
     * @return true if the file can be processed (such as if a file lock could be obtained)
     */
    boolean begin(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception;
    /**
     * Releases any file locks and possibly deletes or moves the file
     */
    void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception;
}
"
org.apache.camel.component.file.strategy.FileProcessStrategySupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import java.io.RandomAccessFile;
import java.nio.channels.Channel;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import org.apache.camel.component.file.FileEndpoint;
import org.apache.camel.component.file.FileExchange;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 1.1 $
 */
public abstract class FileProcessStrategySupport implements FileProcessStrategy {
    public static final String DEFAULT_LOCK_FILE_POSTFIX = "".cameLock"";
    private static final transient Log LOG = LogFactory.getLog(FileProcessStrategySupport.class);
    private boolean lockFile;
    private FileRenamer lockFileRenamer;
    protected FileProcessStrategySupport() {
        this(true);
    }
    protected FileProcessStrategySupport(boolean lockFile) {
        this(lockFile, new DefaultFileRenamer(null, DEFAULT_LOCK_FILE_POSTFIX));
    }
    protected FileProcessStrategySupport(boolean lockFile, FileRenamer lockFileRenamer) {
        this.lockFile = lockFile;
        this.lockFileRenamer = lockFileRenamer;
    }
    public boolean begin(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        if (isLockFile()) {
            File newFile = lockFileRenamer.renameFile(file);
            String lockFileName = newFile.getAbsolutePath();
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Locking the file: "" + file + "" using the lock file name: "" + lockFileName);
            }
            FileChannel channel = new RandomAccessFile(lockFileName, ""rw"").getChannel();
            FileLock lock = channel.lock();
            if (lock != null) {
                exchange.setProperty(""org.apache.camel.fileChannel"", channel);
                exchange.setProperty(""org.apache.camel.file.lock"", lock);
                exchange.setProperty(""org.apache.camel.file.lock.name"", lockFileName);
                return true;
            }
            return false;
        }
        return true;
    }
    public void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        if (isLockFile()) {
            Channel channel = ExchangeHelper.getMandatoryProperty(exchange, ""org.apache.camel.fileChannel"", Channel.class);
            String lockfile = ExchangeHelper.getMandatoryProperty(exchange, ""org.apache.camel.file.lock.name"", String.class);
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Unlocking file: "" + file);
            }
            channel.close();
            File lock = new File(lockfile);
            lock.delete();
        }
    }
    public boolean isLockFile() {
        return lockFile;
    }
    public void setLockFile(boolean lockFile) {
        this.lockFile = lockFile;
    }
    public FileRenamer getLockFileRenamer() {
        return lockFileRenamer;
    }
    public void setLockFileRenamer(FileRenamer lockFileRenamer) {
        this.lockFileRenamer = lockFileRenamer;
    }
}
"
org.apache.camel.component.file.strategy.FileRenamer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
/**
 * @version $Revision: 1.1 $
 */
public interface FileRenamer {
    File renameFile(File file);
}
"
org.apache.camel.component.file.strategy.NoOpFileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
/**
 * A simple strategy which just locks the file but does not modify it
 *
 * @version $Revision: 1.1 $
 */
public class NoOpFileProcessStrategy extends FileProcessStrategySupport {
    public NoOpFileProcessStrategy() {
        super(false);
    }
}
"
org.apache.camel.component.file.strategy.RenameFileProcessStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.strategy;
import java.io.File;
import java.io.IOException;
import org.apache.camel.component.file.FileEndpoint;
import org.apache.camel.component.file.FileExchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A strategy to rename a file
 * 
 * @version $Revision: 1.1 $
 */
public class RenameFileProcessStrategy extends FileProcessStrategySupport {
    private static final transient Log LOG = LogFactory.getLog(RenameFileProcessStrategy.class);
    private FileRenamer renamer;
    public RenameFileProcessStrategy() {
        this(true);
    }
    public RenameFileProcessStrategy(boolean lock) {
        this(lock, "".camel/"", """");
    }
    public RenameFileProcessStrategy(boolean lock, String namePrefix, String namePostfix) {
        this(lock, new DefaultFileRenamer(namePrefix, namePostfix));
    }
    public RenameFileProcessStrategy(boolean lock, FileRenamer renamer) {
        super(lock);
        this.renamer = renamer;
    }
    public void commit(FileEndpoint endpoint, FileExchange exchange, File file) throws Exception {
        File newName = renamer.renameFile(file);
        newName.getParentFile().mkdirs();
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Renaming file: "" + file + "" to: "" + newName);
        }
        boolean renamed = file.renameTo(newName);
        if (!renamed) {
            throw new IOException(""Could not rename file from: "" + file + "" to "" + newName);
        }
        super.commit(endpoint, exchange, file);
    }
    public FileRenamer getRenamer() {
        return renamer;
    }
    public void setRenamer(FileRenamer renamer) {
        this.renamer = renamer;
    }
}
"
org.apache.camel.component.jmx.JMXComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import javax.management.MBeanServer;
import java.util.Map;
/**
 * The <a href=""http://activemq.apache.org/camel/jmx.html"">JMX Component</a>
 * for monitoring jmx attributes
 * 
 * @version $Revision: 523772 $
 */
public class JMXComponent extends DefaultComponent<JMXExchange> {
    private MBeanServer mbeanServer;
    public JMXComponent() {
    }
    public JMXComponent(CamelContext context) {
        super(context);
    }
    protected Endpoint<JMXExchange> createEndpoint(String uri, String remaining, Map parameters)
        throws Exception {
        JMXEndpoint result = new JMXEndpoint(remaining, this);
        setProperties(result, parameters);
        result.setMbeanServer(getMbeanServer());
        return result;
    }
    public MBeanServer getMbeanServer() {
        return mbeanServer;
    }
    public void setMbeanServer(MBeanServer mbeanServer) {
        this.mbeanServer = mbeanServer;
    }
}
"
org.apache.camel.component.jmx.JMXConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import javax.management.Notification;
import javax.management.NotificationListener;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * Generate an Exchange after getting a JMX Notification
 * 
 * @version $Revision: 523016 $
 */
public class JMXConsumer extends DefaultConsumer implements NotificationListener {
    JMXEndpoint jmxEndpoint;
    public JMXConsumer(JMXEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.jmxEndpoint = endpoint;
    }
    public void handleNotification(Notification notification, Object handback) {
        try {
            getProcessor().process(jmxEndpoint.createExchange(notification));
        } catch (Throwable e) {
            handleException(e);
        }
    }
}
"
org.apache.camel.component.jmx.JMXEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import javax.management.MBeanServer;
import javax.management.Notification;
import javax.management.ObjectName;
import javax.management.monitor.CounterMonitor;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Creates a CounterMonitor for jmx attributes
 * 
 * @version $Revision: 523016 $
 */
public class JMXEndpoint extends DefaultEndpoint<JMXExchange> {
    private static final Log LOG = LogFactory.getLog(JMXEndpoint.class);
    private String name;
    private ObjectName ourName;
    private String observedObjectName;
    private String attributeName;
    private long granularityPeriod = 5000;
    private Number threshold;
    private Number offset;
    private MBeanServer mbeanServer;
    private CounterMonitor counterMonitor = new CounterMonitor();
    protected JMXEndpoint(String endpointUri, JMXComponent component) {
        super(endpointUri, component);
        observedObjectName = endpointUri;
    }
    /**
     * @return a Producer
     * @throws Exception
     * @see org.apache.camel.Endpoint#createProducer()
     */
    public Producer<JMXExchange> createProducer() throws Exception {
        throw new RuntimeException(""Not supported"");
    }
    /**
     * @param proc
     * @return a Consumer
     * @throws Exception
     * @see org.apache.camel.Endpoint#createConsumer(org.apache.camel.Processor)
     */
    public Consumer<JMXExchange> createConsumer(Processor proc) throws Exception {
        ObjectName observedName = new ObjectName(observedObjectName);
        if (name == null) {
            String type = observedName.getKeyProperty(""type"");
            type = type != null ? type : ""UNKNOWN"";
            name = mbeanServer.getDefaultDomain() + "":type=CounterMonitor_"" + type;
        }
        JMXConsumer result = new JMXConsumer(this, proc);
        ourName = new ObjectName(name);
        counterMonitor.setNotify(true);
        counterMonitor.addObservedObject(observedName);
        counterMonitor.setObservedAttribute(attributeName);
        counterMonitor.setGranularityPeriod(granularityPeriod);
        counterMonitor.setDifferenceMode(false);
        counterMonitor.setInitThreshold(threshold);
        counterMonitor.setOffset(offset);
        mbeanServer.registerMBean(counterMonitor, ourName);
        mbeanServer.addNotificationListener(ourName, result, null, new Object());
        return result;
    }
    public boolean isSingleton() {
        return true;
    }
    public JMXExchange createExchange(Notification notification) {
        return new JMXExchange(getContext(), getExchangePattern(), notification);
    }
    public JMXExchange createExchange() {
        return new JMXExchange(getContext(), getExchangePattern(), null);
    }
    public JMXExchange createExchange(ExchangePattern pattern) {
        return new JMXExchange(getContext(), pattern, null);
    }
    public String getAttributeName() {
        return attributeName;
    }
    public void setAttributeName(String attributeName) {
        this.attributeName = attributeName;
    }
    public long getGranularityPeriod() {
        return granularityPeriod;
    }
    public void setGranularityPeriod(long granularityPeriod) {
        this.granularityPeriod = granularityPeriod;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Number getOffset() {
        return offset;
    }
    public void setOffset(Number offset) {
        this.offset = offset;
    }
    public Number getThreshold() {
        return threshold;
    }
    public void setThreshold(Number threshold) {
        this.threshold = threshold;
    }
    public MBeanServer getMbeanServer() {
        return mbeanServer;
    }
    public void setMbeanServer(MBeanServer mbeanServer) {
        this.mbeanServer = mbeanServer;
    }
}
"
org.apache.camel.component.jmx.JMXExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import javax.management.Notification;
/**
 * A {@link Exchange} for a jmx notification
 * 
 * @version $Revision: 520985 $
 */
public class JMXExchange extends DefaultExchange {
    /**
     * Constructor
     * 
     * @param camelContext
     * @param pattern
     */
    public JMXExchange(CamelContext camelContext, ExchangePattern pattern, Notification notification) {
        super(camelContext, pattern);
        setIn(new JMXMessage(notification));
    }
}
"
org.apache.camel.component.jmx.JMXMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jmx;
import javax.management.Notification;
import org.apache.camel.impl.DefaultMessage;
/**
 * A {@link Message} for a JMX Notification
 * 
 * @version $Revision: 520985 $
 */
public class JMXMessage extends DefaultMessage {
    private Notification notification;
    public JMXMessage() {
        this(null);
    }
    public JMXMessage(Notification notification) {
        this.notification = notification;
    }
    @Override
    public String toString() {
        return ""JMXMessage: "" + notification;
    }
    @Override
    public JMXExchange getExchange() {
        return (JMXExchange)super.getExchange();
    }
    @Override
    public JMXMessage newInstance() {
        return new JMXMessage();
    }
    public Notification getNotification() {
        return notification;
    }
}
"
org.apache.camel.component.log.LogComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.log;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingLevel;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: $
 */
public class LogComponent extends DefaultComponent<Exchange> {
    private static final Log LOG = LogFactory.getLog(LogComponent.class);
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        LoggingLevel level = getLoggingLevel(parameters);
        Logger logger = new Logger(remaining, level);
        return new ProcessorEndpoint(uri, this, logger);
    }
    protected LoggingLevel getLoggingLevel(Map parameters) {
        String levelText = (String) parameters.get(""level"");
        LoggingLevel level = null;
        if (levelText != null) {
            level = LoggingLevel.valueOf(levelText.toUpperCase());
            if (level == null) {
                LOG.warn(""Could not convert level text: "" + levelText + "" to a valid logging level so defaulting to WARN"");
            }
        }
        if (level == null) {
            level = LoggingLevel.INFO;
        }
        return level;
    }
}
"
org.apache.camel.component.log.LogRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.log;
import org.apache.camel.ContextTestSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 520220 $
 */
public class LogRouteTest extends ContextTestSupport {
    private static final Log LOG = LogFactory.getLog(LogRouteTest.class);
    public void testSendMessageToLog() throws Exception {
        template.sendBody(""log:org.apache.camel.TEST"", ""<level>default</level>"");
    }
    public void testSendMessageToInfoLog() throws Exception {
        template.sendBody(""log:org.apache.camel.TEST?level=INFO"", ""<level>INFO</level>"");
    }
    public void testSendMessageToWarnLog() throws Exception {
        template.sendBody(""log:org.apache.camel.TEST?level=warn"", ""<level>WARN</level>"");
    }
    public void testSendMessageToBadLevel() throws Exception {
        try {
            template.sendBody(""log:org.apache.camel.TEST?level=noSuchLevel"", ""<level>noSuchLevel</level>"");
            fail(""Shoudl have failed!"");
        } catch (Exception e) {
            LOG.debug(""Caught expected exception: "" + e, e);
        }
    }
}
"
org.apache.camel.component.mock.AssertionClause,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ValueBuilder;
import static org.apache.camel.builder.ExpressionBuilder.bodyExpression;
import static org.apache.camel.builder.ExpressionBuilder.headerExpression;
/**
 * A builder of assertions on message exchanges
 * 
 * @version $Revision: 1.1 $
 */
public abstract class AssertionClause<E extends Exchange> implements Runnable {
    private List<Predicate<E>> predicates = new ArrayList<Predicate<E>>();
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Adds the given predicate to this assertion clause
     */
    public AssertionClause<E> predicate(Predicate<E> predicate) {
        addPredicate(predicate);
        return this;
    }
    /**
     * Returns a predicate and value builder for headers on an exchange
     */
    public ValueBuilder<E> header(String name) {
        Expression<E> expression = headerExpression(name);
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound body on an exchange
     */
    public PredicateValueBuilder body() {
        Expression<E> expression = bodyExpression();
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the inbound message body as a
     * specific type
     */
    public <T> PredicateValueBuilder bodyAs(Class<T> type) {
        Expression<E> expression = bodyExpression(type);
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound body on an
     * exchange
     */
    public PredicateValueBuilder outBody() {
        Expression<E> expression = bodyExpression();
        return new PredicateValueBuilder(expression);
    }
    /**
     * Returns a predicate and value builder for the outbound message body as a
     * specific type
     */
    public <T> PredicateValueBuilder outBody(Class<T> type) {
        Expression<E> expression = bodyExpression(type);
        return new PredicateValueBuilder(expression);
    }
    /**
     * Performs any assertions on the given exchange
     */
    protected void applyAssertionOn(MockEndpoint endpoint, int index, E exchange) {
        for (Predicate<E> predicate : predicates) {
            predicate.assertMatches(endpoint.getEndpointUri() + "" "", exchange);
        }
    }
    protected void addPredicate(Predicate<E> predicate) {
        predicates.add(predicate);
    }
    public class PredicateValueBuilder extends ValueBuilder<E> {
        public PredicateValueBuilder(Expression<E> expression) {
            super(expression);
        }
        protected Predicate<E> onNewPredicate(Predicate<E> predicate) {
            addPredicate(predicate);
            return predicate;
        }
    }
}
"
org.apache.camel.component.mock.MockComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * A factory of {@link MockEndpoint} instances
 *
 * @version $Revision: 1.1 $
 */
public class MockComponent extends DefaultComponent<Exchange> {
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new MockEndpoint(uri, this);
    }
}
"
org.apache.camel.component.mock.MockEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.*;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ExpressionComparator;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A Mock endpoint which provides a literate, fluent API for testing routes
 * using a <a href=""http://jmock.org/"">JMock style</a> API.
 * 
 * @version $Revision: 1.1 $
 */
public class MockEndpoint extends DefaultEndpoint<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(MockEndpoint.class);
    private int expectedCount = -1;
    private int counter;
    private Map<Integer, Processor> processors = new HashMap<Integer, Processor>();
    private List<Exchange> receivedExchanges = new CopyOnWriteArrayList<Exchange>();
    private List<Throwable> failures = new CopyOnWriteArrayList<Throwable>();
    private List<Runnable> tests = new CopyOnWriteArrayList<Runnable>();
    private CountDownLatch latch;
    private long sleepForEmptyTest = 1000L;
    private long defaulResultWaitMillis = 20000L;
    private int expectedMinimumCount = -1;
    private List expectedBodyValues;
    private List actualBodyValues = new ArrayList();
    public MockEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
    }
    public static void assertWait(long timeout, TimeUnit unit, MockEndpoint... endpoints) throws InterruptedException {
        long start = System.currentTimeMillis();
        long left = unit.toMillis(timeout);
        long end = start + left;
        for (MockEndpoint endpoint : endpoints) {
            if (!endpoint.await(left, TimeUnit.MILLISECONDS)) {
                throw new AssertionError(""Timeout waiting for endpoints to receive enough messages. "" + endpoint.getEndpointUri() + "" timed out."");
            }
            left = end - System.currentTimeMillis();
            if (left <= 0) {
                left = 0;
            }
        }
    }
    public static void assertIsSatisfied(long timeout, TimeUnit unit, MockEndpoint... endpoints) throws InterruptedException {
        assertWait(timeout, unit, endpoints);
        for (MockEndpoint endpoint : endpoints) {
            endpoint.assertIsSatisfied();
        }
    }
    public static void assertIsSatisfied(MockEndpoint... endpoints) throws InterruptedException {
        for (MockEndpoint endpoint : endpoints) {
            endpoint.assertIsSatisfied();
        }
    }
    /**
     * Asserts that all the expectations on any {@link MockEndpoint} instances registered
     * in the given context are valid
     *
     * @param context the camel context used to find all the available endpoints to be asserted
     */
    public static void assertIsSatisfied(CamelContext context) throws InterruptedException {
        Collection<Endpoint> endpoints = context.getSingletonEndpoints();
        for (Endpoint endpoint : endpoints) {
            if (endpoint instanceof MockEndpoint) {
                MockEndpoint mockEndpoint = (MockEndpoint) endpoint;
                mockEndpoint.assertIsSatisfied();
            }
        }
    }
    public static void expectsMessageCount(int count, MockEndpoint... endpoints) throws InterruptedException {
        for (MockEndpoint endpoint : endpoints) {
            endpoint.expectsMessageCount(count);
        }
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        throw new UnsupportedOperationException(""You cannot consume from this endpoint"");
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) {
                onExchange(exchange);
            }
        };
    }
    // Testing API
    // -------------------------------------------------------------------------
    /**
     * Set the processor that will be invoked when the index
     * message is received.
     *
     * @param index
     * @param processor
     */
    public void whenExchangeReceived(int index, Processor processor) {
        this.processors.put(index, processor);
    }
    /**
     * Validates that all the available expectations on this endpoint are
     * satisfied; or throw an exception
     */
    public void assertIsSatisfied() throws InterruptedException {
        assertIsSatisfied(sleepForEmptyTest);
    }
    /**
     * Validates that all the available expectations on this endpoint are
     * satisfied; or throw an exception
     * 
     * @param timeoutForEmptyEndpoints the timeout in milliseconds that we
     *                should wait for the test to be true
     */
    public void assertIsSatisfied(long timeoutForEmptyEndpoints) throws InterruptedException {
        LOG.info(""Asserting: "" + this + "" is satisfied"");
        if (expectedCount >= 0) {
            if (expectedCount != getReceivedCounter()) {
                if (expectedCount == 0) {
                    // lets wait a little bit just in case
                    if (timeoutForEmptyEndpoints > 0) {
                        LOG.debug(""Sleeping for: "" + timeoutForEmptyEndpoints + "" millis to check there really are no messages received"");
                        Thread.sleep(timeoutForEmptyEndpoints);
                    }
                } else {
                    waitForCompleteLatch();
                }
            }
            assertEquals(""Received message count"", expectedCount, getReceivedCounter());
        } else if (expectedMinimumCount > 0 && getReceivedCounter() < expectedMinimumCount) {
            waitForCompleteLatch();
        }
        if (expectedMinimumCount >= 0) {
            int receivedCounter = getReceivedCounter();
            assertTrue(""Received message count "" + receivedCounter + "", expected at least "" + expectedCount, expectedCount <= receivedCounter);
        }
        for (Runnable test : tests) {
            test.run();
        }
        for (Throwable failure : failures) {
            if (failure != null) {
                LOG.error(""Caught on "" + getEndpointUri() + "" Exception: "" + failure, failure);
                fail(""Failed due to caught exception: "" + failure);
            }
        }
    }
    /**
     * Validates that the assertions fail on this endpoint
     */
    public void assertIsNotSatisfied() throws InterruptedException {
        try {
            assertIsSatisfied();
            fail(""Expected assertion failure!"");
        } catch (AssertionError e) {
            LOG.info(""Caught expected failure: "" + e);
        }
    }
    /**
     * Specifies the expected number of message exchanges that should be
     * received by this endpoint
     * 
     * @param expectedCount the number of message exchanges that should be
     *                expected by this endpoint
     */
    public void expectedMessageCount(int expectedCount) {
        this.expectedCount = expectedCount;
        if (expectedCount <= 0) {
            latch = null;
        } else {
            latch = new CountDownLatch(expectedCount);
        }
    }
    /**
     * Specifies the minimum number of expected message exchanges that should be
     * received by this endpoint
     * 
     * @param expectedCount the number of message exchanges that should be
     *                expected by this endpoint
     */
    public void expectedMinimumMessageCount(int expectedCount) {
        this.expectedMinimumCount = expectedCount;
        if (expectedCount <= 0) {
            latch = null;
        } else {
            latch = new CountDownLatch(expectedMinimumCount);
        }
    }
    /**
     * Adds an expectation that the given body values are received by this
     * endpoint
     */
    public void expectedBodiesReceived(final List bodies) {
        expectedMessageCount(bodies.size());
        this.expectedBodyValues = bodies;
        this.actualBodyValues = new ArrayList();
        expects(new Runnable() {
            public void run() {
                for (int i = 0; i < expectedBodyValues.size(); i++) {
                    Exchange exchange = getReceivedExchanges().get(i);
                    assertTrue(""No exchange received for counter: "" + i, exchange != null);
                    Object expectedBody = expectedBodyValues.get(i);
                    Object actualBody = actualBodyValues.get(i);
                    assertEquals(""Body of message: "" + i, expectedBody, actualBody);
                }
            }
        });
    }
    /**
     * Adds an expectation that the given body values are received by this
     * endpoint
     */
    public void expectedBodiesReceived(Object... bodies) {
        List bodyList = new ArrayList();
        for (Object body : bodies) {
            bodyList.add(body);
        }
        expectedBodiesReceived(bodyList);
    }
    /**
     * Adds an expectation that messages received should have ascending values
     * of the given expression such as a user generated counter value
     * 
     * @param expression
     */
    public void expectsAscending(final Expression<Exchange> expression) {
        expects(new Runnable() {
            public void run() {
                assertMessagesAscending(expression);
            }
        });
    }
    /**
     * Adds an expectation that messages received should have descending values
     * of the given expression such as a user generated counter value
     * 
     * @param expression
     */
    public void expectsDescending(final Expression<Exchange> expression) {
        expects(new Runnable() {
            public void run() {
                assertMessagesDescending(expression);
            }
        });
    }
    /**
     * Adds an expectation that no duplicate messages should be received using
     * the expression to determine the message ID
     * 
     * @param expression the expression used to create a unique message ID for
     *                message comparison (which could just be the message
     *                payload if the payload can be tested for uniqueness using
     *                {@link Object#equals(Object)} and
     *                {@link Object#hashCode()}
     */
    public void expectsNoDuplicates(final Expression<Exchange> expression) {
        expects(new Runnable() {
            public void run() {
                assertNoDuplicates(expression);
            }
        });
    }
    /**
     * Asserts that the messages have ascending values of the given expression
     */
    public void assertMessagesAscending(Expression<Exchange> expression) {
        assertMessagesSorted(expression, true);
    }
    /**
     * Asserts that the messages have descending values of the given expression
     */
    public void assertMessagesDescending(Expression<Exchange> expression) {
        assertMessagesSorted(expression, false);
    }
    protected void assertMessagesSorted(Expression<Exchange> expression, boolean ascending) {
        String type = ascending ? ""ascending"" : ""descending"";
        ExpressionComparator comparator = new ExpressionComparator(expression);
        List<Exchange> list = getReceivedExchanges();
        for (int i = 1; i < list.size(); i++) {
            int j = i - 1;
            Exchange e1 = list.get(j);
            Exchange e2 = list.get(i);
            int result = comparator.compare(e1, e2);
            if (result == 0) {
                fail(""Messages not "" + type + "". Messages"" + j + "" and "" + i + "" are equal with value: "" + expression.evaluate(e1) + "" for expression: "" + expression + "". Exchanges: "" + e1 + "" and ""
                     + e2);
            } else {
                if (!ascending) {
                    result = result * -1;
                }
                if (result > 0) {
                    fail(""Messages not "" + type + "". Message "" + j + "" has value: "" + expression.evaluate(e1) + "" and message "" + i + "" has value: "" + expression.evaluate(e2) + "" for expression: ""
                         + expression + "". Exchanges: "" + e1 + "" and "" + e2);
                }
            }
        }
    }
    public void assertNoDuplicates(Expression<Exchange> expression) {
        Map<Object, Exchange> map = new HashMap<Object, Exchange>();
        List<Exchange> list = getReceivedExchanges();
        for (int i = 0; i < list.size(); i++) {
            Exchange e2 = list.get(i);
            Object key = expression.evaluate(e2);
            Exchange e1 = map.get(key);
            if (e1 != null) {
                fail(""Duplicate message found on message "" + i + "" has value: "" + key + "" for expression: "" + expression + "". Exchanges: "" + e1 + "" and "" + e2);
            } else {
                map.put(key, e2);
            }
        }
    }
    /**
     * Adds the expection which will be invoked when enough messages are
     * received
     */
    public void expects(Runnable runnable) {
        tests.add(runnable);
    }
    /**
     * Adds an assertion to the given message index
     * 
     * @param messageIndex the number of the message
     * @return the assertion clause
     */
    public AssertionClause message(final int messageIndex) {
        AssertionClause clause = new AssertionClause() {
            public void run() {
                applyAssertionOn(MockEndpoint.this, messageIndex, assertExchangeReceived(messageIndex));
            }
        };
        expects(clause);
        return clause;
    }
    /**
     * Adds an assertion to all the received messages
     * 
     * @return the assertion clause
     */
    public AssertionClause allMessages() {
        AssertionClause clause = new AssertionClause() {
            public void run() {
                List<Exchange> list = getReceivedExchanges();
                int index = 0;
                for (Exchange exchange : list) {
                    applyAssertionOn(MockEndpoint.this, index++, exchange);
                }
            }
        };
        expects(clause);
        return clause;
    }
    /**
     * Asserts that the given index of message is received (starting at zero)
     */
    public Exchange assertExchangeReceived(int index) {
        int count = getReceivedCounter();
        assertTrue(""Not enough messages received. Was: "" + count, count > index);
        return getReceivedExchanges().get(index);
    }
    // Properties
    // -------------------------------------------------------------------------
    public List<Throwable> getFailures() {
        return failures;
    }
    public int getReceivedCounter() {
        return getReceivedExchanges().size();
    }
    public List<Exchange> getReceivedExchanges() {
        return receivedExchanges;
    }
    public int getExpectedCount() {
        return expectedCount;
    }
    public long getSleepForEmptyTest() {
        return sleepForEmptyTest;
    }
    /**
     * Allows a sleep to be specified to wait to check that this endpoint really
     * is empty when {@link #expectedMessageCount(int)} is called with zero
     * 
     * @param sleepForEmptyTest the milliseconds to sleep for to determine that
     *                this endpoint really is empty
     */
    public void setSleepForEmptyTest(long sleepForEmptyTest) {
        this.sleepForEmptyTest = sleepForEmptyTest;
    }
    public long getDefaulResultWaitMillis() {
        return defaulResultWaitMillis;
    }
    /**
     * Sets the maximum amount of time the {@link #assertIsSatisfied()} will
     * wait on a latch until it is satisfied
     */
    public void setDefaulResultWaitMillis(long defaulResultWaitMillis) {
        this.defaulResultWaitMillis = defaulResultWaitMillis;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected synchronized void onExchange(Exchange exchange) {
        try {
            Message in = exchange.getIn();
            Object actualBody = in.getBody();
            if (expectedBodyValues != null) {
                int index = actualBodyValues.size();
                if (expectedBodyValues.size() > index) {
                    Object expectedBody = expectedBodyValues.get(index);
                    if (expectedBody != null) {
                        actualBody = in.getBody(expectedBody.getClass());
                    }
                    actualBodyValues.add(actualBody);
                }
            }
            LOG.debug(getEndpointUri() + "" >>>> "" + (++counter) + "" : "" + exchange + "" with body: "" + actualBody);
            receivedExchanges.add(exchange);
            Processor processor = processors.get(getReceivedCounter());
            if (processor != null) {
                processor.process(exchange);
            }
            if (latch != null) {
                latch.countDown();
            }
        } catch (Exception e) {
            failures.add(e);
        }
    }
    protected void waitForCompleteLatch() throws InterruptedException {
        if (latch == null) {
            fail(""Should have a latch!"");
        }
        // now lets wait for the results
        LOG.debug(""Waiting on the latch for: "" + defaulResultWaitMillis + "" millis"");
        latch.await(defaulResultWaitMillis, TimeUnit.MILLISECONDS);
    }
    protected void assertEquals(String message, Object expectedValue, Object actualValue) {
        if (!ObjectHelper.equals(expectedValue, actualValue)) {
            fail(message + "". Expected: <"" + expectedValue + ""> but was: <"" + actualValue + "">"");
        }
    }
    protected void assertTrue(String message, boolean predicate) {
        if (!predicate) {
            fail(message);
        }
    }
    protected void fail(Object message) {
        if (LOG.isDebugEnabled()) {
            List<Exchange> list = getReceivedExchanges();
            int index = 0;
            for (Exchange exchange : list) {
                LOG.debug(""Received["" + (++index) + ""]: "" + exchange);
            }
        }
        throw new AssertionError(getEndpointUri() + "" "" + message);
    }
    public int getExpectedMinimumCount() {
        return expectedMinimumCount;
    }
    public void await() throws InterruptedException {
        if (latch != null) {
            latch.await();
        }
    }
    public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
        if (latch != null) {
            return latch.await(timeout, unit);
        }
        return true;
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.component.mock.MockEndpointTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mock;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: $
 */
public class MockEndpointTest extends ContextTestSupport {
    public void testAscendingMessagesPass() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectsAscending(header(""counter"").convertTo(Number.class));
        sendMessages(11, 12, 13, 14, 15);
        resultEndpoint.assertIsSatisfied();
    }
    public void testAscendingMessagesFail() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectsAscending(header(""counter"").convertTo(Number.class));
        sendMessages(11, 12, 13, 15, 14);
        resultEndpoint.assertIsNotSatisfied();
    }
    public void testDescendingMessagesPass() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectsDescending(header(""counter"").convertTo(Number.class));
        sendMessages(15, 14, 13, 12, 11);
        resultEndpoint.assertIsSatisfied();
    }
    public void testDescendingMessagesFail() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectsDescending(header(""counter"").convertTo(Number.class));
        sendMessages(15, 14, 13, 11, 12);
        resultEndpoint.assertIsNotSatisfied();
    }
    public void testNoDuplicateMessagesPass() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectsNoDuplicates(header(""counter""));
        sendMessages(11, 12, 13, 14, 15);
        resultEndpoint.assertIsSatisfied();
    }
    public void testDuplicateMessagesFail() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectsNoDuplicates(header(""counter""));
        sendMessages(11, 12, 13, 14, 12);
        resultEndpoint.assertIsNotSatisfied();
    }
    protected void sendMessages(int... counters) {
        for (int counter : counters) {
            template.sendBodyAndHeader(""direct:a"", ""<message>"" + counter + ""</message>"",
                    ""counter"", counter);
        }
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.component.pojo.ISay,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo;
public interface ISay {
    String say();
}
"
org.apache.camel.component.pojo.PojoRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo;
import junit.framework.TestCase;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.bean.ProxyHelper;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.util.jndi.JndiContext;
/**
 * @version $Revision: 520220 $
 */
public class PojoRouteTest extends TestCase {
    public void testPojoRoutes() throws Exception {
        // START SNIPPET: register
        // lets populate the context with the services we need
        // note that we could just use a spring.xml file to avoid this step
        JndiContext context = new JndiContext();
        context.bind(""bye"", new SayService(""Good Bye!""));
        CamelContext camelContext = new DefaultCamelContext(context);
        // END SNIPPET: register
        // START SNIPPET: route
        // lets add simple route
        camelContext.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""direct:hello"").to(""pojo:bye"");
            }
        });
        // END SNIPPET: route
        camelContext.start();
        // START SNIPPET: invoke
        Endpoint endpoint = camelContext.getEndpoint(""direct:hello"");
        ISay proxy = ProxyHelper.createProxy(endpoint, ISay.class);
        String rc = proxy.say();
        assertEquals(""Good Bye!"", rc);
        // END SNIPPET: invoke
        camelContext.stop();
    }
}
"
org.apache.camel.component.pojo.SayService,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.pojo;
public class SayService implements ISay {
    String message = ""Hello"";
    public SayService() {
    }
    public SayService(String message) {
        this.message = message;
    }
    public String say() {
        return message;
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
}
"
org.apache.camel.component.ref.RefComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ref;
import org.apache.camel.Exchange;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import java.util.Map;
/**
 *
 */
public class RefComponent extends DefaultComponent<Exchange> {
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        String name = uri.substring(4);
        return getCamelContext().getRegistry().lookup(name, Endpoint.class);
    }
}
"
org.apache.camel.component.seda.QueueComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import org.apache.camel.Exchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.util.concurrent.BlockingQueue;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/queue.html"">Queue components</a>
 * for asynchronous SEDA exchanges on a {@link BlockingQueue} within a CamelContext
 *
 * @version $Revision: 519973 $
 */
public class QueueComponent extends SedaComponent {
    private static final transient Log LOG = LogFactory.getLog(QueueComponent.class);
    public QueueComponent() {
        LOG.warn(""This component has been deprecated; please use the seda: URI format instead of queue:"");
    }
}
"
org.apache.camel.component.seda.SedaComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/seda.html"">SEDA components</a>
 * for asynchronous SEDA exchanges on a {@link BlockingQueue} within a CamelContext
 *
 * @version $Revision: 1.1 $
 */
public class SedaComponent extends DefaultComponent {
    public BlockingQueue<Exchange> createQueue() {
        return new LinkedBlockingQueue<Exchange>(1000);
    }
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new SedaEndpoint(uri, this);
    }
}
"
org.apache.camel.component.seda.SedaConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.concurrent.TimeUnit;
import org.apache.camel.AlreadyStoppedException;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 582309 $
 */
public class SedaConsumer extends ServiceSupport implements Consumer, Runnable {
    private static final Log LOG = LogFactory.getLog(SedaConsumer.class);
    private SedaEndpoint endpoint;
    private AsyncProcessor processor;
    private Thread thread;
    public SedaConsumer(SedaEndpoint endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = AsyncProcessorTypeConverter.convert(processor);
    }
    @Override
    public String toString() {
        return ""SedaConsumer: "" + endpoint.getEndpointUri();
    }
    public void run() {
        while (isRunAllowed()) {
            final Exchange exchange;
            try {
                exchange = endpoint.getQueue().poll(1000, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                break;
            }
            if (exchange != null && isRunAllowed()) {
                processor.process(exchange, new AsyncCallback() {
                    public void done(boolean sync) {
                    }
                });
            }
        }
    }
    protected void doStart() throws Exception {
        thread = new Thread(this, getThreadName(endpoint.getEndpointUri()));
        thread.setDaemon(true);
        thread.start();
    }
    protected void doStop() throws Exception {
        thread.join();
    }
}
"
org.apache.camel.component.seda.SedaEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.concurrent.BlockingQueue;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
/**
 * An implementation of the <a
 * href=""http://activemq.apache.org/camel/queue.html"">Queue components</a> for
 * asynchronous SEDA exchanges on a {@link BlockingQueue} within a CamelContext
 * 
 * @version $Revision: 519973 $
 */
public class SedaEndpoint extends DefaultEndpoint<Exchange> {
    private final class SedaProducer extends DefaultProducer implements AsyncProcessor {
        private SedaProducer(Endpoint endpoint) {
            super(endpoint);
        }
        public void process(Exchange exchange) {
            queue.add(exchange.copy());
        }
        public boolean process(Exchange exchange, AsyncCallback callback) {
            queue.add(exchange.copy());
            callback.done(true);
            return true;
        }
    }
    private BlockingQueue<Exchange> queue;
    public SedaEndpoint(String endpointUri, Component component, BlockingQueue<Exchange> queue) {
        super(endpointUri, component);
        this.queue = queue;
    }
    public SedaEndpoint(String uri, SedaComponent component) {
        this(uri, component, component.createQueue());
    }
    public Producer createProducer() throws Exception {
        return new SedaProducer(this);
    }
    public Consumer createConsumer(Processor processor) throws Exception {
        return new SedaConsumer(this, processor);
    }
    public BlockingQueue<Exchange> getQueue() {
        return queue;
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.component.seda.SedaRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.seda;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.TestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
/**
 * @version $Revision: 520220 $
 */
public class SedaRouteTest extends TestSupport {
    public void testSedaQueue() throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        CamelContext context = new DefaultCamelContext();
        // lets add some routes
        context.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""seda:test.a"").to(""seda:test.b"");
                from(""seda:test.b"").process(new Processor() {
                    public void process(Exchange e) {
                        log.debug(""Received exchange: "" + e.getIn());
                        latch.countDown();
                    }
                });
            }
        });
        context.start();
        // now lets fire in a message
        Endpoint<Exchange> endpoint = context.getEndpoint(""seda:test.a"");
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setHeader(""cheese"", 123);
        Producer<Exchange> producer = endpoint.createProducer();
        producer.process(exchange);
        // now lets sleep for a while
        boolean received = latch.await(5, TimeUnit.SECONDS);
        assertTrue(""Did not receive the message!"", received);
        context.stop();
    }
    public void testThatShowsEndpointResolutionIsNotConsistent() throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        CamelContext context = new DefaultCamelContext();
        // lets add some routes
        context.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""seda:test.a"").to(""seda:test.b"");
                from(""seda:test.b"").process(new Processor() {
                    public void process(Exchange e) {
                        log.debug(""Received exchange: "" + e.getIn());
                        latch.countDown();
                    }
                });
            }
        });
        context.start();
        // now lets fire in a message
        Endpoint<Exchange> endpoint = context.getEndpoint(""seda:test.a"");
        Exchange exchange = endpoint.createExchange();
        exchange.getIn().setHeader(""cheese"", 123);
        Producer<Exchange> producer = endpoint.createProducer();
        producer.process(exchange);
        // now lets sleep for a while
        boolean received = latch.await(5, TimeUnit.SECONDS);
        assertTrue(""Did not receive the message!"", received);
        context.stop();
    }
}
"
org.apache.camel.component.timer.TimerComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.timer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Timer;
/**
 * Represents the component that manages {@link TimerEndpoint}.  It holds the
 * list of {@link TimerConsumer} objects that are started.
 *
 * @version $Revision: 519973 $
 */
public class TimerComponent extends DefaultComponent<Exchange> {
    private Map<String, Timer> timers = new HashMap<String, Timer>();
    public Timer getTimer(TimerEndpoint endpoint) {
        String key = endpoint.getTimerName();
        if (! endpoint.isDaemon()) {
           key = ""nonDaemon:"" + key;
        }
        Timer answer = timers.get(key);
        if (answer == null) {
            answer = new Timer(endpoint.getTimerName(), endpoint.isDaemon());
            timers.put(key, answer);
        }
        return answer;
    }
    @Override
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        TimerEndpoint answer = new TimerEndpoint(uri, this, remaining);
        setProperties(answer, parameters);
        return answer;
    }
    @Override
    protected void doStop() throws Exception {
        Collection<Timer> collection = timers.values();
        for (Timer timer : collection) {
            timer.cancel();
        }
        timers.clear();
    }
}
"
org.apache.camel.component.timer.TimerConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.timer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.component.bean.BeanInvocation;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Timer;
import java.util.TimerTask;
/**
 * @version $Revision: 523047 $
 */
public class TimerConsumer extends DefaultConsumer<Exchange> {
    private static final transient Log LOG = LogFactory.getLog(TimerConsumer.class);
    private final TimerEndpoint endpoint;
    private TimerTask task;
    public TimerConsumer(TimerEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        task = new TimerTask() {
            @Override
            public void run() {
                sendTimerExchange();
            }
        };
        Timer timer = endpoint.getTimer();
        configureTask(task, timer);
    }
    @Override
    protected void doStop() throws Exception {
        task.cancel();
    }
    protected void configureTask(TimerTask task, Timer timer) {
        if (endpoint.isFixedRate()) {
            if (endpoint.getTime() != null) {
                timer.scheduleAtFixedRate(task, endpoint.getTime(), endpoint.getPeriod());
            }
            else {
                timer.scheduleAtFixedRate(task, endpoint.getDelay(), endpoint.getPeriod());
            }
        }
        else {
            if (endpoint.getTime() != null) {
                if (endpoint.getPeriod() >= 0) {
                    timer.schedule(task, endpoint.getTime(), endpoint.getPeriod());
                }
                else {
                    timer.schedule(task, endpoint.getTime());
                }
            }
            else {
                if (endpoint.getPeriod() >= 0) {
                    timer.schedule(task, endpoint.getDelay(), endpoint.getPeriod());
                }
                else {
                    timer.schedule(task, endpoint.getDelay());
                }
            }
        }
    }
    protected void sendTimerExchange() {
        Exchange exchange = endpoint.createExchange();
        exchange.setProperty(""org.apache.camel.timer.name"", endpoint.getTimerName());
        exchange.setProperty(""org.apache.camel.timer.time"", endpoint.getTime());
        exchange.setProperty(""org.apache.camel.timer.period"", endpoint.getPeriod());
        try {
            getProcessor().process(exchange);
        }
        catch (Exception e) {
            LOG.error(""Caught: "" + e, e);
        }
    }
}
"
org.apache.camel.component.timer.TimerEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.timer;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.ExchangePattern;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
import java.util.Date;
import java.util.Timer;
/**
 * Represents a timer endpoint that can generate periodic inbound PojoExchanges.
 *
 * @version $Revision: 519973 $
 */
public class TimerEndpoint extends DefaultEndpoint<Exchange> {
    private final TimerComponent component;
    private final String timerName;
    private Date time;
    private long period = 1000;
    private long delay = 0;
    private boolean fixedRate;
    private boolean daemon = true;
    private Timer timer;
    public TimerEndpoint(String fullURI, TimerComponent component, String timerName) {
        super(fullURI, component);
        this.component = component;
        this.timerName = timerName;
    }
    public Producer<Exchange> createProducer() throws Exception {
        throw new RuntimeCamelException(""Cannot produce to a TimerEndpoint: "" + getEndpointUri());
    }
    public Consumer<Exchange> createConsumer(Processor processor) throws Exception {
        return new TimerConsumer(this, processor);
    }
    public TimerComponent getComponent() {
        return component;
    }
    public String getTimerName() {
        return timerName;
    }
    public boolean isDaemon() {
        return daemon;
    }
    public void setDaemon(boolean daemon) {
        this.daemon = daemon;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
    public boolean isFixedRate() {
        return fixedRate;
    }
    public void setFixedRate(boolean fixedRate) {
        this.fixedRate = fixedRate;
    }
    public long getPeriod() {
        return period;
    }
    public void setPeriod(long period) {
        this.period = period;
    }
    public Date getTime() {
        return time;
    }
    public void setTime(Date time) {
        this.time = time;
    }
    public boolean isSingleton() {
        return true;
    }
    public Timer getTimer() {
        if (timer == null) {
            timer = component.getTimer(this);
        }
        return timer;
    }
}
"
org.apache.camel.component.timer.TimerRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.timer;
import org.apache.camel.CamelContext;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.naming.Context;
import java.util.concurrent.atomic.AtomicInteger;
/**
 * @version $Revision: 520220 $
 */
public class TimerRouteTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(TimerRouteTest.class);
    private MyBean bean = new MyBean();
    public void testTimerInvokesBeanMethod() throws Exception {
        // now lets wait for the timer to fire a few times.
        Thread.sleep(1000 * 2);
        assertTrue("""", bean.counter.get() >= 2);
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() {
                from(""timer://foo?fixedRate=true&delay=0&period=500"").to(""bean:myBean"");
            }
        };
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", bean);
        return answer;
    }
    public static class MyBean {
        public AtomicInteger counter = new AtomicInteger(0);
        public void someMethod(){
            LOG.debug(""Invoked someMethod()"");
            counter.incrementAndGet();
        }
    }
}
"
org.apache.camel.component.vm.VmComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.vm;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.component.seda.SedaComponent;
import org.apache.camel.component.seda.SedaEndpoint;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/vm.html"">VM components</a>
 * for asynchronous SEDA exchanges on a {@link BlockingQueue} within the classloader tree containing
 * the camel-core.jar. i.e. to handle communicating across CamelContext instances and possibly across
 * web application contexts, providing that camel-core.jar is on the system classpath.
 *
 * @version $Revision: 1.1 $
 */
public class VmComponent extends SedaComponent {
    private static final AtomicInteger START_COUNTER = new AtomicInteger();
    protected static Map<String, BlockingQueue> queues = new HashMap<String, BlockingQueue>();
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        BlockingQueue<Exchange> blockingQueue = getBlockingQueue(uri);
        return new SedaEndpoint(uri, this, blockingQueue);
    }
    protected BlockingQueue<Exchange> getBlockingQueue(String uri) {
        synchronized (queues) {
            BlockingQueue<Exchange> answer = queues.get(uri);
            if (answer == null) {
                answer = createQueue();
                queues.put(uri, answer);
            }
            return answer;
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        START_COUNTER.incrementAndGet();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        if (START_COUNTER.decrementAndGet() == 0) {
            synchronized (queues) {
                for (BlockingQueue q : queues.values()) {
                    q.clear();
                }
                queues.clear();
            }
        }
    }
}
"
org.apache.camel.component.vm.VmRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.vm;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelTemplate;
import org.apache.camel.TestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.util.ServiceHelper;
/**
 * @version $Revision: 520220 $
 */
public class VmRouteTest extends TestSupport {
    private CamelContext context1 = new DefaultCamelContext();
    private CamelContext context2 = new DefaultCamelContext();
    private CamelTemplate template = new CamelTemplate(context1);
    private Object expectedBody = ""<hello>world!</hello>"";
    public void testSedaQueue() throws Exception {
        MockEndpoint result = context2.getEndpoint(""mock:result"", MockEndpoint.class);
        result.expectedBodiesReceived(expectedBody);
        template.sendBody(""vm:test.a"", expectedBody);
        result.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        context1.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""vm:test.a"").to(""vm:test.b"");
            }
        });
        context2.addRoutes(new RouteBuilder() {
            public void configure() {
                from(""vm:test.b"").to(""mock:result"");
            }
        });
        ServiceHelper.startServices(context1, context2);
    }
    @Override
    protected void tearDown() throws Exception {
        ServiceHelper.stopServices(context2, context1);
        super.tearDown();
    }
}
"
org.apache.camel.converter.CollectionConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import org.apache.camel.Converter;
import java.util.*;
/**
 * Some core java.util Collection based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision: 524215 $
 */
@Converter
public class CollectionConverter {
    /**
     * Utility classes should not have a public constructor.
     */
    private CollectionConverter() {
    }
    /**
     * Converts a collection to an array
     */
    @Converter
    public static Object[] toArray(Collection value) {
        if (value == null) {
            return null;
        }
        return value.toArray();
    }
    /**
     * Converts an array to a collection
     */
    @Converter
    public static List toList(Object[] array) {
        return Arrays.asList(array);
    }
    /**
     * Converts a collection to a List if it is not already
     */
    @Converter
    public static List toList(Collection collection) {
        return new ArrayList(collection);
    }
    @Converter
    public static Set toSet(Object[] array) {
        Set answer = new HashSet();
        for (Object element : array) {
            answer.add(element);
        }
        return answer;
    }
    @Converter
    public static Set toSet(Collection collection) {
        return new HashSet(collection);
    }
    @Converter
    public static Set toSet(Map map) {
        return map.entrySet();
    }
    @Converter
    public static Properties toProperties(Map map) {
        Properties answer = new Properties();
        answer.putAll(map);
        return answer;
    }
    @Converter
    public static Hashtable toHashtable(Map map) {
        return new Hashtable(map);
    }
    @Converter
    public static HashMap toHashMap(Map map) {
        return new HashMap(map);
    }
}
"
org.apache.camel.converter.ConverterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.beans.PropertyEditorManager;
import java.beans.PropertyEditorSupport;
import java.io.File;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.net.URL;
import junit.framework.TestCase;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.impl.ReflectionInjector;
import org.apache.camel.impl.converter.DefaultTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 583081 $
 */
public class ConverterTest extends TestCase {
    private static final transient Log LOG = LogFactory.getLog(ConverterTest.class);
    protected TypeConverter converter = new DefaultTypeConverter(new ReflectionInjector());
    public static class IntegerPropertyEditor extends PropertyEditorSupport {
        public void setAsText(String text) throws IllegalArgumentException {
            setValue(new Integer(text));
        }
        public String getAsText() {
            Integer value = (Integer) getValue();
            return value != null ? value.toString() : """";
        }
    }
    public void testIntegerPropertyEditorConversion() throws Exception {
        Integer value = converter.convertTo(Integer.class, ""1000"");
        assertNotNull(value);
        assertEquals(""Converted to Integer"", new Integer(1000), value);
        String text = converter.convertTo(String.class, value);
        assertEquals(""Converted to String"", ""1000"", text);
    }
    public void testConvertStringAndBytes() throws Exception {
        byte[] array = converter.convertTo(byte[].class, ""foo"");
        assertNotNull(array);
        LOG.debug(""Found array of size: "" + array.length);
        String text = converter.convertTo(String.class, array);
        assertEquals(""Converted to String"", ""foo"", text);
    }
    public void testConvertStringAndStreams() throws Exception {
        InputStream inputStream = converter.convertTo(InputStream.class, ""bar"");
        assertNotNull(inputStream);
        String text = converter.convertTo(String.class, inputStream);
        assertEquals(""Converted to String"", ""bar"", text);
    }
    public void testArrayToListAndSetConversion() throws Exception {
        String[] array = new String[]{""one"", ""two""};
        List list = converter.convertTo(List.class, array);
        assertEquals(""List size: "" + list, 2, list.size());
        Collection collection = converter.convertTo(Collection.class, array);
        assertEquals(""Collection size: "" + collection, 2, collection.size());
        Set set = converter.convertTo(Set.class, array);
        assertEquals(""Set size: "" + set, 2, set.size());
        set = converter.convertTo(Set.class, list);
        assertEquals(""Set size: "" + set, 2, set.size());
    }
    public void testCollectionToArrayConversion() throws Exception {
        List list = new ArrayList();
        list.add(""one"");
        list.add(""two"");
        Object[] objectArray = converter.convertTo(Object[].class, list);
        assertEquals(""Object[] length"", 2, objectArray.length);
        String[] stringArray = converter.convertTo(String[].class, list);
        assertEquals(""String[] length"", 2, stringArray.length);
    }
    public void testCollectionToPrimitiveArrayConversion() throws Exception {
        List list = new ArrayList();
        list.add(5);
        list.add(6);
        Integer[] integerArray = converter.convertTo(Integer[].class, list);
        assertEquals(""Integer[] length"", 2, integerArray.length);
        int[] intArray = converter.convertTo(int[].class, list);
        assertEquals(""int[] length"", 2, intArray.length);
        // lets convert the typesafe array to a larger primitive type
        long[] longArray = converter.convertTo(long[].class, intArray);
        assertEquals(""long[] length"", 2, longArray.length);
        // now lets go back to a List again
        List resultList = converter.convertTo(List.class, intArray);
        assertEquals(""List size"", 2, resultList.size());
        LOG.debug(""From primitive type array we've created the list: "" + resultList);
    }
    public void testStringToFile() throws Exception {
        File file = converter.convertTo(File.class, ""foo.txt"");
        assertNotNull(""Should have converted to a file!"");
        assertEquals(""file name"", ""foo.txt"", file.getName());
    }
    public void testFileToString() throws Exception {
        URL resource = getClass().getResource(""dummy.txt"");
        assertNotNull(""Cannot find resource!"");
        File file = new File(resource.getFile());
        String text = converter.convertTo(String.class, file);
        assertNotNull(""Should have returned a String!"", text);
        text = text.trim();
        assertTrue(""Text not read correctly: "" + text, text.endsWith(""Hello World!""));
    }
    public void testPrimitiveBooleanConversion() throws Exception {
        boolean value = converter.convertTo(boolean.class, null);
        assertFalse(value);
    }
    public void testPrimitiveIntConversion() throws Exception {
        int value = converter.convertTo(int.class, 4);
        assertEquals(""value"", 4, value);
    }
    public void testPrimitiveIntPropertySetter() throws Exception {
        MyBean bean = new MyBean();
        IntrospectionSupport.setProperty(converter, bean, ""foo"", ""4"");
        assertEquals(""bean.foo"", 4, bean.getFoo());
    }
    public void testStringToBoolean() throws Exception {
        Boolean value = converter.convertTo(Boolean.class, ""true"");
        assertEquals(""converted boolean value"", Boolean.TRUE, value);
        value = converter.convertTo(Boolean.class, ""false"");
        assertEquals(""converted boolean value"", Boolean.FALSE, value);
        value = converter.convertTo(Boolean.class, null);
        assertEquals(""converted boolean value"", null, value);
    }
    public static class MyBean {
        private int foo;
        public int getFoo() {
            return foo;
        }
        public void setFoo(int foo) {
            this.foo = foo;
        }
    }
    @Override
    protected void setUp() throws Exception {
        PropertyEditorManager.registerEditor(Integer.class, IntegerPropertyEditor.class);
    }
}
"
org.apache.camel.converter.HasAnnotation,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to indicate that the actual type of a parameter on a converter method must have the given annotation class
 * to be applicable. e.g. this annotation could be used on a JAXB converter which only applies to objects with a
 * JAXB annotation on them
 *
 * @version $Revision: 563607 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER })
public @interface HasAnnotation {
    Class value();
}
"
org.apache.camel.converter.IOConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import org.apache.camel.Converter;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.io.*;
import java.net.URL;
/**
 * Some core java.io based <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 * 
 * @version $Revision: 582840 $
 */
@Converter
public class IOConverter {
    private static final transient Log LOG = LogFactory.getLog(IOConverter.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private IOConverter() {        
    }
    @Converter
    public static InputStream toInputStream(URL url) throws IOException {
        return url.openStream();
    }
    @Converter
    public static InputStream toInputStream(File file) throws FileNotFoundException {
        return new BufferedInputStream(new FileInputStream(file));
    }
    @Converter
    public static BufferedReader toReader(File file) throws FileNotFoundException {
        return new BufferedReader(new FileReader(file));
    }
    @Converter
    public static File toFile(String name) throws FileNotFoundException {
        return new File(name);
    }
    @Converter
    public static OutputStream toOutputStream(File file) throws FileNotFoundException {
        return new BufferedOutputStream(new FileOutputStream(file));
    }
    @Converter
    public static BufferedWriter toWriter(File file) throws IOException {
        return new BufferedWriter(new FileWriter(file));
    }
    @Converter
    public static Reader toReader(InputStream in) throws FileNotFoundException {
        return new InputStreamReader(in);
    }
    @Converter
    public static Writer toWriter(OutputStream out) throws FileNotFoundException {
        return new OutputStreamWriter(out);
    }
    @Converter
    public static StringReader toReader(String text) {
        // TODO could we automatically find this?
        return new StringReader(text);
    }
    @Converter
    public static InputStream toInputStream(String text) {
        return toInputStream(text.getBytes());
    }
    @Converter
    public static byte[] toByteArray(String text) {
        // TODO could we automatically find this?
        return text.getBytes();
    }
    @Converter
    public static String toString(byte[] data) {
        return new String(data);
    }
    @Converter
    public static String toString(File file) throws IOException {
        return toString(toReader(file));
    }
    @Converter
    public static String toString(URL url) throws IOException {
        return toString(toInputStream(url));
    }
    @Converter
    public static String toString(Reader reader) throws IOException {
        if (reader instanceof BufferedReader) {
            return toString((BufferedReader)reader);
        } else {
            return toString(new BufferedReader(reader));
        }
    }
    @Converter
    public static String toString(BufferedReader reader) throws IOException {
        if (reader == null) {
            return null;
        }
        try {
            CollectionStringBuffer builder = new CollectionStringBuffer(""\n"");
            while (true) {
                String line = reader.readLine();
                if (line == null) {
                    return builder.toString();
                }
                builder.append(line);
            }
        } finally {
            try {
                reader.close();
            } catch (IOException e) {
                LOG.warn(""Failed to close stream: "" + e, e);
            }
        }
    }
    @Converter
    public static String toString(InputStream in) throws IOException {
        return toString(toReader(in));
    }
    @Converter
    public static InputStream toInputStream(byte[] data) {
        return new ByteArrayInputStream(data);
    }
    @Converter
    public static ObjectOutput toObjectOutput(OutputStream stream) throws IOException {
        if (stream instanceof ObjectOutput) {
            return (ObjectOutput) stream;
        }
        else {
            return new ObjectOutputStream(stream);
        }
    }
    @Converter
    public static ObjectInput toObjectInput(InputStream stream) throws IOException {
        if (stream instanceof ObjectInput) {
            return (ObjectInput) stream;
        }
        else {
            return new ObjectInputStream(stream);
        }
    }
}
"
org.apache.camel.converter.JaxpTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import javax.xml.transform.Source;
import org.w3c.dom.Document;
import junit.framework.TestCase;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.ReflectionInjector;
import org.apache.camel.impl.converter.DefaultTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 571489 $
 */
public class JaxpTest extends TestCase {
    private static final transient Log LOG = LogFactory.getLog(JaxpTest.class);
    protected TypeConverter converter = new DefaultTypeConverter(new ReflectionInjector());
    public void testConvertToDocument() throws Exception {
        Document document = converter
            .convertTo(Document.class, ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?><hello>world!</hello>"");
        assertNotNull(document);
        LOG.debug(""Found document: "" + document);
        // lets now convert back again
        String text = converter.convertTo(String.class, document);
        // The preamble changes a little under Java 1.6 it adds a
        // standalone=""no"" attribute.
        assertTrue(""Converted to String"", text.endsWith(""<hello>world!</hello>""));
    }
    public void testConvertToSource() throws Exception {
        Source source = converter
            .convertTo(Source.class, ""<hello>world!</hello>"");
        assertNotNull(source);
        LOG.debug(""Found document: "" + source);
    }
}
"
org.apache.camel.converter.NIOConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import org.apache.camel.Converter;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
/**
 * Some core java.nio based 
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision: 564495 $
 */
@Converter
public class NIOConverter {
    /**
     * Utility classes should not have a public constructor.
     */
    private NIOConverter() {        
    }
    @Converter
    public static byte[] toByteArray(ByteBuffer buffer) {
        return buffer.array();
    }
    @Converter
    public static String toString(ByteBuffer buffer) {
        return IOConverter.toString(buffer.array());
    }
    @Converter
    public static ByteBuffer toByteBuffer(byte[] data) {
        return ByteBuffer.wrap(data);
    }
    @Converter
    public static ByteBuffer toByteBuffer(File file) throws IOException {
       byte[] buf = new byte[(int) file.length()];
       InputStream in = new BufferedInputStream(new FileInputStream(file));
       in.read(buf);
       return ByteBuffer.wrap(buf);
    }
    @Converter
    public static ByteBuffer toByteBuffer(String value) {
        ByteBuffer buf = ByteBuffer.allocate(value.length());
        byte[] bytes = value.getBytes();
        buf.put(bytes);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Short value) {
        ByteBuffer buf = ByteBuffer.allocate(2);
        buf.putShort(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Integer value) {
        ByteBuffer buf = ByteBuffer.allocate(4);
        buf.putInt(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Long value) {
        ByteBuffer buf = ByteBuffer.allocate(8);
        buf.putLong(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Float value) {
        ByteBuffer buf = ByteBuffer.allocate(4);
        buf.putFloat(value);
        return buf;
    }
    @Converter
    public static ByteBuffer toByteBuffer(Double value) {
        ByteBuffer buf = ByteBuffer.allocate(8);
        buf.putDouble(value);
        return buf;
    }
    @Converter
    public static InputStream toInputStream(ByteBuffer bufferbuffer) {
        return IOConverter.toInputStream(toByteArray(bufferbuffer));
    }
}
"
org.apache.camel.converter.ObjectConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import org.apache.camel.Converter;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
/**
 * Some core java.lang based <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 * 
 * @version $Revision: 571489 $
 */
@Converter
public class ObjectConverter {
    /**
     * Utility classes should not have a public constructor.
     */
    private ObjectConverter() {        
    }
    public static boolean isCollection(Object value) {
        // TODO we should handle primitive array types?
        return value instanceof Collection || (value != null && value.getClass().isArray());
    }
    /**
     * Creates an iterator over the value if the value is a collection, an
     * Object[] or a primitive type array; otherwise to simplify the caller's
     * code, we just create a singleton collection iterator over a single value
     */
    @Converter
    public static Iterator iterator(Object value) {
        if (value == null) {
            return Collections.EMPTY_LIST.iterator();
        } else if (value instanceof Collection) {
            Collection collection = (Collection)value;
            return collection.iterator();
        } else if (value.getClass().isArray()) {
            // TODO we should handle primitive array types?
            List<Object> list = Arrays.asList((Object[]) value);
            return list.iterator();
        } else if (value instanceof NodeList) {
            // lets iterate through DOM results after performing XPaths
            final NodeList nodeList = (NodeList) value;
            return new Iterator<Node>() {
                int idx = -1;
                public boolean hasNext() {
                    return ++idx < nodeList.getLength();
                }
                public Node next() {
                    return nodeList.item(idx);
                }
                public void remove() {
                    throw new UnsupportedOperationException();
                }
            };
        } else {
            return Collections.singletonList(value).iterator();
        }
    }
    /**
     * Converts the given value to a boolean, handling strings or Boolean
     * objects; otherwise returning false if the value could not be converted to
     * a boolean
     */
    @Converter
    public static boolean toBool(Object value) {
        Boolean answer = toBoolean(value);
        if (answer != null) {
            return answer.booleanValue();
        }
        return false;
    }
    /**
     * Converts the given value to a Boolean, handling strings or Boolean
     * objects; otherwise returning null if the value cannot be converted to a
     * boolean
     */
    @Converter
    public static Boolean toBoolean(Object value) {
        if (value instanceof Boolean) {
            return (Boolean)value;
        }
        if (value instanceof String) {
            return ""true"".equalsIgnoreCase(value.toString()) ? Boolean.TRUE : Boolean.FALSE;
        }
        return null;
    }
    /**
     * Returns the boolean value, or null if the value is null
     */
    @Converter
    public static Boolean toBoolean(Boolean value) {
        if (value != null) {
            return value.booleanValue();
        }
        return false;
    }
}
"
org.apache.camel.converter.ObjectConverterTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter;
import junit.framework.TestCase;
import java.util.Iterator;
/**
 * @version $Revision: 1.1 $
 */
public class ObjectConverterTest extends TestCase {
    public void testArrayAsIterator() throws Exception {
        String[] data = {""a"", ""b""};
        Iterator iter = ObjectConverter.iterator(data);
        assertTrue(""should have next"", iter.hasNext());
        Object a = iter.next();
        assertEquals(""a"", ""a"", a);
        assertTrue(""should have next"", iter.hasNext());
        Object b = iter.next();
        assertEquals(""b"", ""b"", b);
        assertFalse(""should not have a next"", iter.hasNext());
    }
}
"
org.apache.camel.converter.jaxp.BytesSource,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import javax.xml.transform.stream.StreamSource;
/**
 * A helper class which provides a JAXP {@link Source} from a byte[]
 * which can be read as many times as required.
 *
 * @version $Revision: 563607 $
 */
public class BytesSource extends StreamSource {
    private byte[] data;
    public BytesSource(byte[] data) {
        this.data = data;
    }
    public BytesSource(byte[] data, String systemId) {
        this.data = data;
        setSystemId(systemId);
    }
    public InputStream getInputStream() {
        return new ByteArrayInputStream(data);
    }
    public Reader getReader() {
        return new InputStreamReader(getInputStream());
    }
    public byte[] getData() {
        return data;
    }
    public String toString() {
        return ""BytesSource["" + new String(data) + ""]"";
    }
}
"
org.apache.camel.converter.jaxp.StringSource,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import javax.xml.transform.stream.StreamSource;
/**
 * A helper class which provides a JAXP {@link Source} from a String which can
 * be read as many times as required.
 * 
 * @version $Revision: 563607 $
 */
public class StringSource extends StreamSource implements Serializable {
    private final String text;
    private String encoding = ""UTF-8"";
    public StringSource(String text) {
        if (text == null) {
            throw new NullPointerException(""text can not be null"");
        }
        this.text = text;
    }
    public StringSource(String text, String systemId) {
        this(text);
        setSystemId(systemId);
    }
    public StringSource(String text, String systemId, String encoding) {
        this.text = text;
        this.encoding = encoding;
        setSystemId(systemId);
    }
    public InputStream getInputStream() {
        try {
            return new ByteArrayInputStream(text.getBytes(encoding));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }
    public Reader getReader() {
        return new StringReader(text);
    }
    public String toString() {
        return ""StringSource["" + text + ""]"";
    }
    public String getText() {
        return text;
    }
}
"
org.apache.camel.converter.jaxp.XmlConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxp;
import org.apache.camel.Converter;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.converter.NIOConverter;
import org.apache.camel.util.ObjectHelper;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.lang.reflect.Constructor;
import java.nio.ByteBuffer;
/**
 * A helper class to transform to and from various JAXB types such as {@link Source} and {@link Document}
 *
 * @version $Revision: 571489 $
 */
@Converter
public class XmlConverter {
    public static final String DEFAULT_CHARSET_PROPERTY = ""org.apache.camel.default.charset"";
    public static String defaultCharset = ObjectHelper.getSystemProperty(DEFAULT_CHARSET_PROPERTY, ""UTF-8"");
    private DocumentBuilderFactory documentBuilderFactory;
    private TransformerFactory transformerFactory;
    /*
     * When converting a DOM tree to a SAXSource,
     * we try to use Xalan internal DOM parser if
     * available.  Else, transform the DOM tree
     * to a String and build a SAXSource on top of
     * it.
     */
    private static final Class dom2SaxClass;
    static {
        Class cl = null;
        try {
            cl = Class.forName(""org.apache.xalan.xsltc.trax.DOM2SAX"");
        } catch (Throwable t) {}
        dom2SaxClass = cl;
    }
    public XmlConverter() {
    }
    public XmlConverter(DocumentBuilderFactory documentBuilderFactory) {
        this.documentBuilderFactory = documentBuilderFactory;
    }
    /**
     * Converts the given input Source into the required result
     */
    public void toResult(Source source, Result result) throws TransformerException {
        if (source == null) {
            return;
        }
        Transformer transformer = createTransfomer();
        if (transformer == null) {
            throw new TransformerException(""Could not create a transformer - JAXP is misconfigured!"");
        }
        transformer.setOutputProperty(OutputKeys.ENCODING, defaultCharset);
        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""yes"");
        transformer.transform(source, result);
    }
    /**
     * Converts the given byte[] to a Source
     */
    @Converter
    public BytesSource toSource(byte[] data) {
        return new BytesSource(data);
    }
    /**
     * Converts the given String to a Source
     */
    @Converter
    public StringSource toSource(String data) {
        return new StringSource(data);
    }
    /**
     * Converts the given Document to a Source
     */
    @Converter
    public DOMSource toSource(Document document) {
        return new DOMSource(document);
    }
    /**
     * Converts the given input Source into text
     */
    @Converter
    public String toString(Source source) throws TransformerException {
        if (source == null) {
            return null;
        } else if (source instanceof StringSource) {
            return ((StringSource) source).getText();
        } else if (source instanceof BytesSource) {
            return new String(((BytesSource) source).getData());
        } else {
            StringWriter buffer = new StringWriter();
            toResult(source, new StreamResult(buffer));
            return buffer.toString();
        }
    }
    /**
     * Converts the given input Node into text
     */
    @Converter
    public String toString(NodeList nodeList) throws TransformerException {
        StringWriter buffer = new StringWriter();
        for (int i = 0, size = nodeList.getLength(); i < size; i++) {
            Node node = nodeList.item(i);
            Source source = new DOMSource(node);
            toResult(source, new StreamResult(buffer));
        }
        return buffer.toString();
    }
    /**
     * Converts the given input Node into text
     */
    @Converter
    public String toString(Node node) throws TransformerException {
        return toString(new DOMSource(node));
    }
    /**
     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public DOMSource toDOMSource(Source source) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        if (source instanceof DOMSource) {
            return (DOMSource) source;
        }
        else if (source instanceof SAXSource) {
            return toDOMSourceFromSAX((SAXSource) source);
        }
        else if (source instanceof StreamSource) {
            return toDOMSourceFromStream((StreamSource) source);
        }
        else {
            return null;
        }
    }
    /**
     * Converts the source instance to a {@link DOMSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public DOMSource toDOMSource(String text) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        Source source = toSource(text);
        if (source != null) {
            return toDOMSourceFromStream((StreamSource) source);
        }
        else {
            return null;
        }
    }
    /**
     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public SAXSource toSAXSource(String source) throws IOException, SAXException, TransformerException {
        return toSAXSource(toSource(source));
    }
    /**
     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public SAXSource toSAXSource(InputStream source) throws IOException, SAXException, TransformerException {
        return toSAXSource(toStreamSource(source));
    }
    /**
     * Converts the source instance to a {@link SAXSource} or returns null if the conversion is not
     * supported (making it easy to derive from this class to add new kinds of conversion).
     */
    @Converter
    public SAXSource toSAXSource(Source source) throws IOException, SAXException, TransformerException {
        if (source instanceof SAXSource) {
            return (SAXSource) source;
        }
        else if (source instanceof DOMSource) {
            return toSAXSourceFromDOM((DOMSource) source);
        }
        else if (source instanceof StreamSource) {
            return toSAXSourceFromStream((StreamSource) source);
        }
        else {
            return null;
        }
    }
    @Converter
    public StreamSource toStreamSource(Source source) throws TransformerException {
        if (source instanceof StreamSource) {
            return (StreamSource) source;
        } else if (source instanceof DOMSource) {
            return toStreamSourceFromDOM((DOMSource) source);
        } else if (source instanceof SAXSource) {
            return toStreamSourceFromSAX((SAXSource) source);
        } else {
            return null;
        }
    }
    @Converter
    public StreamSource toStreamSource(InputStream in) throws TransformerException {
        if (in != null) {
            return new StreamSource(in);
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(Reader in) throws TransformerException {
        if (in != null) {
            return new StreamSource(in);
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(File in) throws TransformerException {
        if (in != null) {
            return new StreamSource(in);
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(byte[] in) throws TransformerException {
        if (in != null) {
            return new StreamSource(IOConverter.toInputStream(in));
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSource(ByteBuffer in) throws TransformerException {
        if (in != null) {
            return new StreamSource(NIOConverter.toInputStream(in));
        }
        return null;
    }
    @Converter
    public StreamSource toStreamSourceFromSAX(SAXSource source) throws TransformerException {
        InputSource inputSource = source.getInputSource();
        if (inputSource != null) {
            if (inputSource.getCharacterStream() != null) {
                return new StreamSource(inputSource.getCharacterStream());
            }
            if (inputSource.getByteStream() != null) {
                return new StreamSource(inputSource.getByteStream());
            }
        }
        String result = toString(source);
        return new StringSource(result);
    }
    @Converter
    public StreamSource toStreamSourceFromDOM(DOMSource source) throws TransformerException {
        String result = toString(source);
        return new StringSource(result);
    }
    @Converter
    public SAXSource toSAXSourceFromStream(StreamSource source) {
        InputSource inputSource;
        if (source.getReader() != null) {
            inputSource = new InputSource(source.getReader());
        } else {
            inputSource = new InputSource(source.getInputStream());
        }
        inputSource.setSystemId(source.getSystemId());
        inputSource.setPublicId(source.getPublicId());
        return new SAXSource(inputSource);
    }
    @Converter
    public Reader toReaderFromSource(Source src) throws TransformerException {
        StreamSource stSrc = toStreamSource(src);
        Reader r = stSrc.getReader();
        if (r == null) {
            r = new InputStreamReader(stSrc.getInputStream());
        }
        return r;
    }
    @Converter
    public DOMSource toDOMSourceFromStream(StreamSource source) throws ParserConfigurationException, IOException, SAXException {
        DocumentBuilder builder = createDocumentBuilder();
        String systemId = source.getSystemId();
        Document document = null;
        Reader reader = source.getReader();
        if (reader != null) {
            document = builder.parse(new InputSource(reader));
        } else {
            InputStream inputStream = source.getInputStream();
            if (inputStream != null) {
                InputSource inputsource = new InputSource(inputStream);
                inputsource.setSystemId(systemId);
                document = builder.parse(inputsource);
            }
            else {
                throw new IOException(""No input stream or reader available"");
            }
        }
        return new DOMSource(document, systemId);
    }
    @Converter
    public SAXSource toSAXSourceFromDOM(DOMSource source) throws TransformerException {
        if (dom2SaxClass != null) {
            try {
                Constructor cns = dom2SaxClass.getConstructor(new Class[] { Node.class });
                XMLReader converter = (XMLReader) cns.newInstance(new Object[] { source.getNode() });
                return new SAXSource(converter, new InputSource());
            } catch (Exception e) {
                throw new TransformerException(e);
            }
        } else {
            String str = toString(source);
            StringReader reader = new StringReader(str);
            return new SAXSource(new InputSource(reader));
        }
    }
    @Converter
    public DOMSource toDOMSourceFromSAX(SAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {
        return new DOMSource(toDOMNodeFromSAX(source));
    }
    @Converter
    public Node toDOMNodeFromSAX(SAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        DOMResult result = new DOMResult();
        toResult(source, result);
        return result.getNode();
    }
    /**
     * Converts the given TRaX Source into a W3C DOM node
     * @throws SAXException
     * @throws IOException
     * @throws ParserConfigurationException
     */
    @Converter
    public Node toDOMNode(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        DOMSource domSrc = toDOMSource(source);
        return domSrc != null ? domSrc.getNode() :  null;
    }
    /**
     * Create a DOM element from the given source.
     *
     * @param source
     * @return
     * @throws TransformerException
     * @throws ParserConfigurationException
     * @throws IOException
     * @throws SAXException
     */
    @Converter
    public Element toDOMElement(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        Node node = toDOMNode(source);
        return toDOMElement(node);
    }
    /**
     * Create a DOM element from the DOM node.
     * Simply cast if the node is an Element, or
     * return the root element if it is a Document.
     *
     * @param node
     * @return
     * @throws TransformerException
     */
    @Converter
    public Element toDOMElement(Node node) throws TransformerException {
        // If the node is an document, return the root element
        if (node instanceof Document) {
            return ((Document) node).getDocumentElement();
        // If the node is an element, just cast it
        } else if (node instanceof Element) {
            return (Element) node;
        // Other node types are not handled
        } else {
            throw new TransformerException(""Unable to convert DOM node to an Element"");
        }
    }
    /**
     * Converts the given data to a DOM document
     *
     * @param data is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(byte[] data) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(new ByteArrayInputStream(data));
    }
    /**
     * Converts the given {@link InputStream} to a DOM document
     *
     * @param in is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(InputStream in) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(in);
    }
    /**
     * Converts the given {@link InputSource} to a DOM document
     *
     * @param in is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(InputSource in) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(in);
    }
    /**
     * Converts the given {@link String} to a DOM document
     *
     * @param text is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(String text) throws IOException, SAXException, ParserConfigurationException {
        return toDOMDocument(text.getBytes());
    }
    /**
     * Converts the given {@link File} to a DOM document
     *
     * @param file is the data to be parsed
     * @return the parsed document
     */
    @Converter
    public Document toDOMDocument(File file) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilder documentBuilder = getDocumentBuilderFactory().newDocumentBuilder();
        return documentBuilder.parse(file);
    }
    /**
     * Create a DOM document from the given source.
     *
     * @param source
     * @return
     * @throws TransformerException
     * @throws ParserConfigurationException
     * @throws IOException
     * @throws SAXException
     */
    @Converter
    public Document toDOMDocument(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        Node node = toDOMNode(source);
        return toDOMDocument(node);
    }
    /**
     * Create a DOM document from the given Node.
     * If the node is an document, just cast it,
     * if the node is an root element, retrieve its
     * owner element or create a new document and import
     * the node.
     *
     * @param node
     * @return
     * @throws ParserConfigurationException
     * @throws TransformerException
     */
    @Converter
    public Document toDOMDocument(Node node) throws ParserConfigurationException, TransformerException {
        // If the node is the document, just cast it
        if (node instanceof Document) {
            return (Document) node;
        // If the node is an element
        } else if (node instanceof Element) {
            Element elem = (Element) node;
            // If this is the root element, return its owner document
            if (elem.getOwnerDocument().getDocumentElement() == elem) {
                return elem.getOwnerDocument();
            // else, create a new doc and copy the element inside it
            } else {
                Document doc = createDocument();
                doc.appendChild(doc.importNode(node, true));
                return doc;
            }
        // other element types are not handled
        } else {
            throw new TransformerException(""Unable to convert DOM node to a Document"");
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public DocumentBuilderFactory getDocumentBuilderFactory() {
        if (documentBuilderFactory == null) {
            documentBuilderFactory = createDocumentBuilderFactory();
        }
        return documentBuilderFactory;
    }
    public void setDocumentBuilderFactory(DocumentBuilderFactory documentBuilderFactory) {
        this.documentBuilderFactory = documentBuilderFactory;
    }
    // Helper methods
    //-------------------------------------------------------------------------
    public DocumentBuilderFactory createDocumentBuilderFactory() {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true);
        factory.setIgnoringElementContentWhitespace(true);
        factory.setIgnoringComments(true);
        return factory;
    }
    public DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {
        DocumentBuilderFactory factory = getDocumentBuilderFactory();
        return factory.newDocumentBuilder();
    }
    public Document createDocument() throws ParserConfigurationException {
        DocumentBuilder builder = createDocumentBuilder();
        return builder.newDocument();
    }
    public TransformerFactory getTransformerFactory() {
        if (transformerFactory == null) {
            transformerFactory = createTransformerFactory();
        }
        return transformerFactory;
    }
    public void setTransformerFactory(TransformerFactory transformerFactory) {
        this.transformerFactory = transformerFactory;
    }
    public Transformer createTransfomer() throws TransformerConfigurationException {
        TransformerFactory factory = getTransformerFactory();
        return factory.newTransformer();
    }
    public TransformerFactory createTransformerFactory() {
        TransformerFactory answer = TransformerFactory.newInstance();
        return answer;
    }
}
"
org.apache.camel.impl.BinaryPredicateSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A useful base class for {@link Predicate} implementations
 * 
 * @version $Revision: 1.1 $
 */
public abstract class BinaryPredicateSupport<E extends Exchange> implements Predicate<E> {
    private final Expression<E> left;
    private final Expression<E> right;
    protected BinaryPredicateSupport(Expression<E> left, Expression<E> right) {
        notNull(left, ""left"");
        notNull(right, ""right"");
        this.left = left;
        this.right = right;
    }
    @Override
    public String toString() {
        return left + "" "" + getOperationText() + "" "" + right;
    }
    public boolean matches(E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        return matches(exchange, leftValue, rightValue);
    }
    public void assertMatches(String text, E exchange) {
        Object leftValue = left.evaluate(exchange);
        Object rightValue = right.evaluate(exchange);
        if (!matches(exchange, leftValue, rightValue)) {
            throw new AssertionError(text + assertionFailureMessage(exchange, leftValue, rightValue));
        }
    }
    protected abstract boolean matches(E exchange, Object leftValue, Object rightValue);
    protected abstract String getOperationText();
    protected String assertionFailureMessage(E exchange, Object leftValue, Object rightValue) {
        return this + "" failed on "" + exchange + "" with left value <"" + leftValue + ""> right value <""
               + rightValue + "">"";
    }
}
"
org.apache.camel.impl.CachingInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.impl.converter.TypeConverterRegistry;
/**
 * A caching proxy so that a single 
 * @version $Revision: 563607 $
 */
public class CachingInjector<T> {
    private final TypeConverterRegistry repository;
    private final Class<T> type;
    private T instance;
    public CachingInjector(TypeConverterRegistry repository, Class<T> type) {
        this.repository = repository;
        this.type = type;
    }
    public synchronized T newInstance() {
        if (instance == null) {
            instance = createInstance(type);
        }
        return instance;
    }
    protected T createInstance(Class<T> t) {
        return (T) repository.getInjector().newInstance(t);
    }
}
"
org.apache.camel.impl.CustomExchangePatternTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import java.util.List;
/**
 * @version $Revision: 1.1 $
 */
public class CustomExchangePatternTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    public void testInOut() throws Exception {
        final ExchangePattern expectedPattern = ExchangePattern.InOut;
        template.send(""direct:start"", expectedPattern, new Processor() {
            public void process(Exchange exchange) throws Exception {
                assertEquals(""MEP"", expectedPattern, exchange.getPattern());
                exchange.getIn().setBody(""<hello>world!</hello>"");
            }
        });
        resultEndpoint.assertIsSatisfied();
        assertReceivedExpectedPattern(expectedPattern);
    }
    public void testInOnly() throws Exception {
        ExchangePattern expectedPattern = ExchangePattern.InOnly;
        template.send(""direct:start"", expectedPattern, new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody(""<hello>world!</hello>"");
            }
        });
        resultEndpoint.assertIsSatisfied();
        assertReceivedExpectedPattern(expectedPattern);
    }
    public void testInOutViaUri() throws Exception {
        final ExchangePattern expectedPattern = ExchangePattern.InOut;
        template.send(""direct:start?exchangePattern=InOut"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                assertEquals(""MEP"", expectedPattern, exchange.getPattern());
                exchange.getIn().setBody(""<hello>world!</hello>"");
            }
        });
        resultEndpoint.assertIsSatisfied();
        assertReceivedExpectedPattern(expectedPattern);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(1);
    }
    protected void assertReceivedExpectedPattern(ExchangePattern expectedPattern) {
        List<Exchange> list = resultEndpoint.getReceivedExchanges();
        Exchange exchange = list.get(0);
        assertEquals(""MEP"", expectedPattern, exchange.getPattern());
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").to(""mock:result"");
                from(""direct:start?exchangePattern=InOut"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.impl.DefaultCamelContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import javax.naming.Context;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.Processor;
import org.apache.camel.ResolveEndpointFailedException;
import org.apache.camel.Route;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.Service;
import org.apache.camel.TypeConverter;
import org.apache.camel.model.RouteType;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.converter.DefaultTypeConverter;
import org.apache.camel.spi.ComponentResolver;
import org.apache.camel.spi.ExchangeConverter;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LanguageResolver;
import org.apache.camel.spi.Registry;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ServiceHelper.startServices;
import static org.apache.camel.util.ServiceHelper.stopServices;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents the context used to configure routes and the policies to use.
 * 
 * @version $Revision: 520517 $
 */
public class DefaultCamelContext extends ServiceSupport implements CamelContext, Service {
    private static final transient Log LOG = LogFactory.getLog(DefaultCamelContext.class);
    private static final String NAME_PREFIX = ""camel-"";
    private static int NAME_SUFFIX = 0;
    private String name;
    private Map<String, Endpoint> endpoints = new HashMap<String, Endpoint>();
    private Map<String, Component> components = new HashMap<String, Component>();
    private List<Route> routes;
    private List<Service> servicesToClose = new ArrayList<Service>();
    private TypeConverter typeConverter;
    private ExchangeConverter exchangeConverter;
    private Injector injector;
    private ComponentResolver componentResolver;
    private boolean autoCreateComponents = true;
    private LanguageResolver languageResolver = new DefaultLanguageResolver();
    private Registry registry;
	private LifecycleStrategy lifecycleStrategy = new DefaultLifecycleStrategy();
    private List<RouteType> routeDefinitions = new ArrayList<RouteType>();
    public DefaultCamelContext() {
    	name = NAME_PREFIX + ++NAME_SUFFIX;
    }
    /**
     * Creates the {@link CamelContext} using the given JNDI context as the
     * registry
     * 
     * @param jndiContext
     */
    public DefaultCamelContext(Context jndiContext) {
        this(new JndiRegistry(jndiContext));
    }
    /**
     * Creates the {@link CamelContext} using the given registry
     */
    public DefaultCamelContext(Registry registry) {
    	this();
        this.registry = registry;
    }
    /**
     * Gets the name of the this context.
     */
    public String getName() {
    	return name;
    }
    /**
     * Sets the name of the this context.
     */
    public void setName(String name) {
    	this.name = name;
    }
    /**
     * Adds a component to the container.
     */
    public void addComponent(String componentName, final Component component) {
        if (component == null) {
            throw new IllegalArgumentException(""Component cannot be null"");
        }
        synchronized (components) {
            if (components.containsKey(componentName)) {
                throw new IllegalArgumentException(""Component previously added: "" + componentName);
            }
            component.setCamelContext(this);
            components.put(componentName, component);
        }
    }
    public Component getComponent(String name) {
        // synchronize the look up and auto create so that 2 threads can't
        // concurrently auto create the same component.
        synchronized (components) {
            Component component = components.get(name);
            if (component == null && autoCreateComponents) {
                try {
                    component = getComponentResolver().resolveComponent(name, this);
                    if (component != null) {
                        addComponent(name, component);
                        if (isStarted()) {
                            // If the component is looked up after the context
                            // is started,
                            // lets start it up.
                            startServices(component);
                        }
                    }
                } catch (Exception e) {
                    throw new RuntimeCamelException(""Could not auto create component: "" + name, e);
                }
            }
            return component;
        }
    }
    public <T extends Component> T getComponent(String name, Class<T> componentType) {
        Component component = getComponent(name);
        if (componentType.isInstance(component)) {
            return componentType.cast(component);
        } else {
            throw new IllegalArgumentException(""The component is not of type: "" + componentType + "" but is: ""
                                               + component);
        }
    }
    /**
     * Removes a previously added component.
     * 
     * @param componentName
     * @return the previously added component or null if it had not been
     *         previously added.
     */
    public Component removeComponent(String componentName) {
        synchronized (components) {
            return components.remove(componentName);
        }
    }
    /**
     * Gets the a previously added component by name or lazily creates the
     * component using the factory Callback.
     * 
     * @param componentName
     * @param factory used to create a new component instance if the component
     *                was not previously added.
     * @return
     */
    public Component getOrCreateComponent(String componentName, Callable<Component> factory) {
        synchronized (components) {
            Component component = components.get(componentName);
            if (component == null) {
                try {
                    component = factory.call();
                    if (component == null) {
                        throw new RuntimeCamelException(""Factory failed to create the "" + componentName
                                                        + "" component, it returned null."");
                    }
                    components.put(componentName, component);
                    component.setCamelContext(this);
                } catch (Exception e) {
                    throw new RuntimeCamelException(""Factory failed to create the "" + componentName
                                                    + "" component"", e);
                }
            }
            return component;
        }
    }
    // Endpoint Management Methods
    // -----------------------------------------------------------------------
    public Collection<Endpoint> getSingletonEndpoints() {
        synchronized (endpoints) {
            return new ArrayList<Endpoint>(endpoints.values());
        }
    }
    public Endpoint addSingletonEndpoint(String uri, Endpoint endpoint) throws Exception {
        Endpoint oldEndpoint;
        synchronized (endpoints) {
            startServices(endpoint);
            oldEndpoint = endpoints.remove(uri);
            endpoints.put(uri, endpoint);
            stopServices(oldEndpoint);
        }
        return oldEndpoint;
    }
    public Endpoint removeSingletonEndpoint(String uri) throws Exception {
        Endpoint oldEndpoint;
        synchronized (endpoints) {
            oldEndpoint = endpoints.remove(uri);
            stopServices(oldEndpoint);
        }
        return oldEndpoint;
    }
    /**
     * Resolves the given URI to an endpoint
     */
    public Endpoint getEndpoint(String uri) {
        Endpoint answer;
        synchronized (endpoints) {
            answer = endpoints.get(uri);
            if (answer == null) {
                try {
                    // Use the URI prefix to find the component.
                    String splitURI[] = ObjectHelper.splitOnCharacter(uri, "":"", 2);
                    if (splitURI[1] != null) {
                        String scheme = splitURI[0];
                        Component component = getComponent(scheme);
                        // Ask the component to resolve the endpoint.
                        if (component != null) {
                            // Have the component create the endpoint if it can.
                            answer = component.createEndpoint(uri);
                            if (answer != null && LOG.isDebugEnabled()) {
                                LOG.debug(uri + "" converted to endpoint: "" + answer + "" by component: ""+ component);
                            }
                        }
                    }
                    if (answer == null) {
                        answer = createEndpoint(uri);
                    }
                    // If it's a singleton then auto register it.
                    if (answer != null && answer.isSingleton()) {
                        startServices(answer);
                        endpoints.put(uri, answer);
                    	lifecycleStrategy.onEndpointAdd(answer);
                    }
                } catch (Exception e) {
                    throw new ResolveEndpointFailedException(uri, e);
                }
            }
        }
        return answer;
    }
    public <T extends Endpoint> T getEndpoint(String name, Class<T> endpointType) {
        Endpoint endpoint = getEndpoint(name);
        if (endpointType.isInstance(endpoint)) {
            return endpointType.cast(endpoint);
        } else {
            throw new IllegalArgumentException(""The endpoint is not of type: "" + endpointType + "" but is: ""
                                               + endpoint);
        }
    }
    // Route Management Methods
    // -----------------------------------------------------------------------
    public List<Route> getRoutes() {
        return routes;
    }
    public void setRoutes(List<Route> routes) {
        this.routes = routes;
    }
    public void addRoutes(Collection<Route> routes) throws Exception {
        if (this.routes == null) {
            this.routes = new ArrayList<Route>(routes);
        } else {
            this.routes.addAll(routes);
        }
        lifecycleStrategy.onRoutesAdd(routes);
        if (shouldStartRoutes()) {
            startRoutes(routes);
        }
    }
    public void addRoutes(RouteBuilder builder) throws Exception {
        // lets now add the routes from the builder
        builder.setContext(this);
        List<Route> routeList = builder.getRouteList();
        LOG.debug(""Adding routes from: "" + builder + "" routes: "" + routeList);
        addRoutes(routeList);
    }
    public void addRouteDefinitions(Collection<RouteType> routeDefinitions) throws Exception {
        this.routeDefinitions.addAll(routeDefinitions);
        if (shouldStartRoutes()) {
            startRouteDefinitions(routeDefinitions);
        }
    }
    // Helper methods
    // -----------------------------------------------------------------------
    /**
     * Resolves a language for creating expressions
     */
    public Language resolveLanguage(String language) {
        return getLanguageResolver().resolveLanguage(language, this);
    }
    // Properties
    // -----------------------------------------------------------------------
    public ExchangeConverter getExchangeConverter() {
        if (exchangeConverter == null) {
            exchangeConverter = createExchangeConverter();
        }
        return exchangeConverter;
    }
    public void setExchangeConverter(ExchangeConverter exchangeConverter) {
        this.exchangeConverter = exchangeConverter;
    }
    public TypeConverter getTypeConverter() {
        if (typeConverter == null) {
            typeConverter = createTypeConverter();
        }
        return typeConverter;
    }
    public void setTypeConverter(TypeConverter typeConverter) {
        this.typeConverter = typeConverter;
    }
    public Injector getInjector() {
        if (injector == null) {
            injector = createInjector();
        }
        return injector;
    }
    public void setInjector(Injector injector) {
        this.injector = injector;
    }
    public ComponentResolver getComponentResolver() {
        if (componentResolver == null) {
            componentResolver = createComponentResolver();
        }
        return componentResolver;
    }
    public void setComponentResolver(ComponentResolver componentResolver) {
        this.componentResolver = componentResolver;
    }
    public LanguageResolver getLanguageResolver() {
        return languageResolver;
    }
    public void setLanguageResolver(LanguageResolver languageResolver) {
        this.languageResolver = languageResolver;
    }
    public boolean isAutoCreateComponents() {
        return autoCreateComponents;
    }
    public void setAutoCreateComponents(boolean autoCreateComponents) {
        this.autoCreateComponents = autoCreateComponents;
    }
    public Registry getRegistry() {
        if (registry == null) {
            registry = createRegistry();
        }
        return registry;
    }
    public void setRegistry(Registry registry) {
        this.registry = registry;
    }
    public LifecycleStrategy getLifecycleStrategy() {
        return lifecycleStrategy;
    }
    public void setLifecycleStrategy(LifecycleStrategy lifecycleStrategy) {
        this.lifecycleStrategy = lifecycleStrategy;
    }
    public List<RouteType> getRouteDefinitions() {
        return routeDefinitions;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected void doStart() throws Exception {
        forceLazyInitialization();
        if (components != null) {
            for (Component component : components.values()) {
                startServices(component);
            }
        }
        startRouteDefinitions(routeDefinitions);
        startRoutes(routes);
    }
    protected void startRouteDefinitions(Collection<RouteType> list) throws Exception {
        if (list != null) {
            for (RouteType route : list) {
            	lifecycleStrategy.beforeStartRouteType(this, route);
                route.addRoutes(this);
            }
        }
    }
    protected void doStop() throws Exception {
        stopServices(servicesToClose);
        if (components != null) {
            for (Component component : components.values()) {
                stopServices(component);
            }
        }
    }
    protected void startRoutes(Collection<Route> routeList) throws Exception {
        if (routeList != null) {
            for (Route<Exchange> route : routeList) {
                List<Service> services = route.getServicesForRoute();
                servicesToClose.addAll(services);
                startServices(services);
            }
        }
    }
    /**
     * Lets force some lazy initialization to occur upfront before we start any
     * components and create routes
     */
    protected void forceLazyInitialization() {
        getExchangeConverter();
        getInjector();
        getLanguageResolver();
        getTypeConverter();
    }
    /**
     * Lazily create a default implementation
     */
    protected ExchangeConverter createExchangeConverter() {
        return new DefaultExchangeConverter();
    }
    /**
     * Lazily create a default implementation
     */
    protected TypeConverter createTypeConverter() {
        return new DefaultTypeConverter(getInjector());
    }
    /**
     * Lazily create a default implementation
     */
    protected Injector createInjector() {
        FactoryFinder finder = new FactoryFinder();
        try {
            return (Injector)finder.newInstance(""Injector"");
        } catch (NoFactoryAvailableException e) {
            // lets use the default
            return new ReflectionInjector();
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        } catch (InstantiationException e) {
            throw new RuntimeCamelException(e);
        } catch (IOException e) {
            throw new RuntimeCamelException(e);
        } catch (ClassNotFoundException e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * Lazily create a default implementation
     */
    protected ComponentResolver createComponentResolver() {
        return new DefaultComponentResolver();
    }
    /**
     * Lazily create a default implementation
     */
    protected Registry createRegistry() {
        return new JndiRegistry();
    }
    /**
     * A pluggable strategy to allow an endpoint to be created without requiring
     * a component to be its factory, such as for looking up the URI inside some
     * {@link Registry}
     * 
     * @param uri the uri for the endpoint to be created
     * @return the newly created endpoint or null if it could not be resolved
     */
    protected Endpoint createEndpoint(String uri) {
        Object value = getRegistry().lookup(uri);
        if (value instanceof Endpoint) {
            return (Endpoint)value;
        } else if (value instanceof Processor) {
            return new ProcessorEndpoint(uri, this, (Processor)value);
        } else if (value != null) {
            return convertBeanToEndpoint(uri, value);
        }
        return null;
    }
    /**
     * Attempt to convert the bean from a {@link Registry} to an endpoint using
     * some kind of transformation or wrapper
     * 
     * @param uri the uri for the endpoint (and name in the registry)
     * @param bean the bean to be converted to an endpoint, which will be not
     *                null
     * @return a new endpoint
     */
    protected Endpoint convertBeanToEndpoint(String uri, Object bean) {
        throw new IllegalArgumentException(""uri: "" + uri + "" bean: "" + bean
                                           + "" could not be converted to an Endpoint"");
    }
    /**
     * Should we start newly added routes?
     */
    protected boolean shouldStartRoutes() {
        return isStarted() && !isStarting();
    }
}
"
org.apache.camel.impl.DefaultCamelContextTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import junit.framework.TestCase;
import org.apache.camel.Component;
import org.apache.camel.component.bean.BeanComponent;
/**
 * @version $Revision: 525634 $
 */
public class DefaultCamelContextTest extends TestCase {
    public void testAutoCreateComponentsOn() {
        DefaultCamelContext ctx = new DefaultCamelContext();
        Component component = ctx.getComponent(""bean"");
        assertNotNull(component);
        assertEquals(component.getClass(), BeanComponent.class);
    }
    public void testAutoCreateComponentsOff() {
        DefaultCamelContext ctx = new DefaultCamelContext();
        ctx.setAutoCreateComponents(false);
        Component component = ctx.getComponent(""bean"");
        assertNull(component);
    }
}
"
org.apache.camel.impl.DefaultComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.net.URI;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.URISupport;
import org.apache.camel.util.UnsafeUriCharactersEncoder;
/**
 * @version $Revision: 583092 $
 */
public abstract class DefaultComponent<E extends Exchange> extends ServiceSupport implements Component<E> {
    private int defaultThreadPoolSize = 5;
    private CamelContext camelContext;
    private ScheduledExecutorService executorService;
    public DefaultComponent() {
    }
    public DefaultComponent(CamelContext context) {
        this.camelContext = context;
    }
    public Endpoint<E> createEndpoint(String uri) throws Exception {
        ObjectHelper.notNull(getCamelContext(), ""camelContext"");
        //endcode uri sting to the unsafe URI characters        
        URI u = new URI(UnsafeUriCharactersEncoder.encode(uri));
        String path = u.getSchemeSpecificPart();
        // lets trim off any query arguments
        if (path.startsWith(""//"")) {
            path = path.substring(2);
        }
        int idx = path.indexOf('?');
        if (idx > 0) {
            path = path.substring(0, idx);
        }
        Map parameters = URISupport.parseParamters(u);
        Endpoint<E> endpoint = createEndpoint(uri, path, parameters);
        if (endpoint == null) {
            return null;
        }
        if (parameters != null) {
            if (endpoint instanceof ScheduledPollEndpoint) {
                ScheduledPollEndpoint scheduledPollEndpoint = (ScheduledPollEndpoint)endpoint;
                scheduledPollEndpoint.configureProperties(parameters);
            }
            setProperties(endpoint, parameters);
        }
        return endpoint;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext context) {
        this.camelContext = context;
    }
    public ScheduledExecutorService getExecutorService() {
        if (executorService == null) {
            executorService = createExecutorService();
        }
        return executorService;
    }
    public void setExecutorService(ScheduledExecutorService executorService) {
        this.executorService = executorService;
    }
    /**
     * A factory method to create a default thread pool and executor
     */
    protected ScheduledExecutorService createExecutorService() {
        return new ScheduledThreadPoolExecutor(defaultThreadPoolSize, new ThreadFactory() {
            int counter;
            public synchronized Thread newThread(Runnable runnable) {
                Thread thread = new Thread(runnable);
                thread.setName(""Thread: "" + (++counter) + "" "" + DefaultComponent.this.toString());
                return thread;
            }
        });
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
        if (executorService != null) {
            executorService.shutdown();
        }
    }
    /**
     * A factory method allowing derived components to create a new endpoint
     * from the given URI, remaining path and optional parameters
     * 
     * @param uri the full URI of the endpoint
     * @param remaining the remaining part of the URI without the query
     *                parameters or component prefix
     * @param parameters the optional parameters passed in
     * @return a newly created endpoint or null if the endpoint cannot be
     *         created based on the inputs
     */
    protected abstract Endpoint<E> createEndpoint(String uri, String remaining, Map parameters)
        throws Exception;
    /**
     * Sets the bean properties on the given bean
     */
    protected void setProperties(Object bean, Map parameters) throws Exception {
        IntrospectionSupport.setProperties(getCamelContext().getTypeConverter(), bean, parameters);
    }
}
"
org.apache.camel.impl.DefaultComponentResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.spi.ComponentResolver;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * The default implementation of {@link ComponentResolver} which tries to find
 * components by using the URI scheme prefix and searching for a file of the URI
 * scheme name in the <b>META-INF/services/org/apache/camel/component/</b>
 * directory on the classpath.
 *
 * @version $Revision: 572600 $
 */
public class DefaultComponentResolver<E extends Exchange> implements ComponentResolver<E> {
    private static final transient Log LOG = LogFactory.getLog(DefaultComponentResolver.class);
    protected static final FactoryFinder COMPONENT_FACTORY =
            new FactoryFinder(""META-INF/services/org/apache/camel/component/"");
    public Component<E> resolveComponent(String name, CamelContext context) {
        Object bean = null;
        try {
            bean = context.getRegistry().lookup(name);
            if (bean != null && LOG.isDebugEnabled()) {
                LOG.debug(""Found component: "" + name + "" in registry: "" + bean);
            }
        }
        catch (Exception e) {
            LOG.debug(""Ignored error looking up bean: "" + name + "". Error: "" + e);
        }
        if (bean != null) {
            if (bean instanceof Component) {
                return (Component) bean;
            }
            else {
                throw new IllegalArgumentException(""Bean with name: "" + name + "" in registry is not a Component: "" + bean);
            }
        }
        Class type;
        try {
            type = COMPONENT_FACTORY.findClass(name);
        }
        catch (NoFactoryAvailableException e) {
            return null;
        }
        catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Component registered for scheme : ""
                    + name, e);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Found component: "" + name + "" via type: "" + type.getName() + "" via "" + COMPONENT_FACTORY.getPath() + name);
        }
        if (type == null) {
            return null;
        }
        if (Component.class.isAssignableFrom(type)) {
            return (Component<E>) context.getInjector().newInstance(type);
        }
        else {
            throw new IllegalArgumentException(""Type is not a Component implementation. Found: ""
                    + type.getName());
        }
    }
}
"
org.apache.camel.impl.DefaultConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.concurrent.Future;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.util.ServiceHelper;
/**
 * @version $Revision: 570471 $
 */
public class DefaultConsumer<E extends Exchange> extends ServiceSupport implements Consumer<E> {
    private Endpoint<E> endpoint;
    private Processor processor;
    private AsyncProcessor asyncProcessor;
    private ExceptionHandler exceptionHandler;
    public DefaultConsumer(Endpoint<E> endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
    }
    @Override
    public String toString() {
        return ""Consumer on "" + endpoint;
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public Processor getProcessor() {
        return processor;
    }
    /**
     * Provides an {@see AsyncProcessor} interface to the configured
     * processor on the consumer.  If the processor does not implement
     * the interface, it will be adapted so that it does.  
     * 
     * @return
     */
    public AsyncProcessor getAsyncProcessor() {
        if (asyncProcessor == null) {
            asyncProcessor = AsyncProcessorTypeConverter.convert(processor);
        }
        return asyncProcessor;
    }
    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }
    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }
    /**
     * Handles the given exception using the {@link #getExceptionHandler()}
     * 
     * @param t the exception to handle
     */
    protected void handleException(Throwable t) {
        getExceptionHandler().handleException(t);
    }
}
"
org.apache.camel.impl.DefaultEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.PollingConsumer;
import org.apache.camel.util.ObjectHelper;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
/**
 * A default endpoint useful for implementation inheritance
 *
 * @version $Revision: 575600 $
 */
public abstract class DefaultEndpoint<E extends Exchange> implements Endpoint<E> {
    private String endpointUri;
    private CamelContext context;
    private Component component;
    private ScheduledExecutorService executorService;
    private ExchangePattern exchangePattern = ExchangePattern.InOnly;
    protected DefaultEndpoint(String endpointUri, Component component) {
        this(endpointUri, component.getCamelContext());
        this.component = component;
    }
    protected DefaultEndpoint(String endpointUri, CamelContext context) {
        this.endpointUri = endpointUri;
        this.context = context;
    }
    public int hashCode() {
        return endpointUri.hashCode() * 37 + 1;
    }
    @Override
    public boolean equals(Object object) {
        if (object instanceof DefaultEndpoint) {
            DefaultEndpoint that = (DefaultEndpoint) object;
            return ObjectHelper.equals(this.endpointUri, that.endpointUri);
        }
        return false;
    }
    @Override
    public String toString() {
        return ""Endpoint["" + endpointUri + ""]"";
    }
    public String getEndpointUri() {
        return endpointUri;
    }
    public CamelContext getContext() {
        return context;
    }
    public Component getComponent() {
        return component;
    }
    /**
     * @return the executor
     */
    public synchronized ScheduledExecutorService getExecutorService() {
        if (executorService == null) {
            Component c = getComponent();
            if (c != null && c instanceof DefaultComponent) {
                DefaultComponent dc = (DefaultComponent) c;
                executorService = dc.getExecutorService();
            }
            if (executorService == null) {
                executorService = createExecutorService();
            }
        }
        return executorService;
    }
    /**
     * @param executorService the executor to set
     */
    public synchronized void setExecutorService(ScheduledExecutorService executorService) {
        this.executorService = executorService;
    }
    public PollingConsumer<E> createPollingConsumer() throws Exception {
        return new EventDrivenPollingConsumer<E>(this);
    }
    /**
     * Converts the given exchange to the specified exchange type
     */
    public E convertTo(Class<E> type, Exchange exchange) {
        // TODO we could infer type parameter
        if (type.isInstance(exchange)) {
            return type.cast(exchange);
        }
        return getContext().getExchangeConverter().convertTo(type, exchange);
    }
    public E createExchange(Exchange exchange) {
        Class<E> exchangeType = getExchangeType();
        if (exchangeType != null) {
            if (exchangeType.isInstance(exchange)) {
                return exchangeType.cast(exchange);
            }
        }
        E answer = createExchange();
        answer.copyFrom(exchange);
        return answer;
    }
    /**
     * Returns the type of the exchange which is generated by this component
     */
    public Class<E> getExchangeType() {
        Type type = getClass().getGenericSuperclass();
        if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            Type[] arguments = parameterizedType.getActualTypeArguments();
            if (arguments.length > 0) {
                Type argumentType = arguments[0];
                if (argumentType instanceof Class) {
                    return (Class<E>) argumentType;
                }
            }
        }
        return null;
    }
    public E createExchange() {
        return createExchange(getExchangePattern());
    }
    public E createExchange(ExchangePattern pattern) {
        return (E) new DefaultExchange(getContext(), pattern);
    }
    public ExchangePattern getExchangePattern() {
        return exchangePattern;
    }
    public void setExchangePattern(ExchangePattern exchangePattern) {
        this.exchangePattern = exchangePattern;
    }
    protected ScheduledThreadPoolExecutor createExecutorService() {
        return new ScheduledThreadPoolExecutor(10);
    }
}
"
org.apache.camel.impl.DefaultExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.UnitOfWork;
import org.apache.camel.util.UuidGenerator;
import java.util.HashMap;
import java.util.Map;
/**
 * A default implementation of {@link Exchange}
 * 
 * @version $Revision: 581960 $
 */
public class DefaultExchange implements Exchange {
    private static final UuidGenerator DEFAULT_ID_GENERATOR = new UuidGenerator();
    protected final CamelContext context;
    private Map<String, Object> properties;
    private Message in;
    private Message out;
    private Message fault;
    private Throwable exception;
    private String exchangeId = DefaultExchange.DEFAULT_ID_GENERATOR.generateId();
    private UnitOfWork unitOfWork;
    private ExchangePattern pattern;
    public DefaultExchange(CamelContext context) {
        this(context, ExchangePattern.InOnly);
    }
    public DefaultExchange(CamelContext context, ExchangePattern pattern) {
        this.context = context;
        this.pattern = pattern;
    }
    @Override
    public String toString() {
        return ""Exchange["" + in + ""]"";
    }
    public Exchange copy() {
        Exchange exchange = newInstance();
        exchange.copyFrom(this);
        return exchange;
    }
    public void copyFrom(Exchange exchange) {
        if (exchange == this) {
            return;
        }
        setProperties(safeCopy(exchange.getProperties()));
        // this can cause strangeness if we copy, say, a FileMessage onto an FtpExchange with overloaded getExchange() methods etc.
        safeCopy(getIn(), exchange, exchange.getIn());
        Message copyOut = exchange.getOut(false);
        if (copyOut != null) {
            safeCopy(getOut(true), exchange, copyOut);
        }
        Message copyFault = exchange.getFault(false);
        if (copyFault != null) {
            safeCopy(getFault(true), exchange, copyFault);
        }
        setException(exchange.getException());
        unitOfWork = exchange.getUnitOfWork();
        pattern = exchange.getPattern();
    }
    private static void safeCopy(Message message, Exchange exchange, Message that) {
        if (message != null) {
            message.copyFrom(that);
        }
    }
    private static Map<String, Object> safeCopy(Map<String, Object> properties) {
        if (properties == null) {
            return null;
        }
        return new HashMap<String, Object>(properties);
    }
    private static Message safeCopy(Exchange exchange, Message message) {
        if (message == null) {
            return null;
        }
        Message answer = message.copy();
        if (answer instanceof MessageSupport) {
            MessageSupport messageSupport = (MessageSupport) answer;
            messageSupport.setExchange(exchange);
        }
        return answer;
    }
    public Exchange newInstance() {
        return new DefaultExchange(context);
    }
    public CamelContext getContext() {
        return context;
    }
    public Object getProperty(String name) {
        if (properties != null) {
            return properties.get(name);
        }
        return null;
    }
    public <T> T getProperty(String name, Class<T> type) {
        Object value = getProperty(name);
        return getContext().getTypeConverter().convertTo(type, value);
    }
    public void setProperty(String name, Object value) {
        getProperties().put(name, value);
    }
    public Object removeProperty(String name) {
        return getProperties().remove(name);
    }
    public Map<String, Object> getProperties() {
        if (properties == null) {
            properties = new HashMap<String, Object>();
        }
        return properties;
    }
    public void setProperties(Map<String, Object> properties) {
        this.properties = properties;
    }
    public Message getIn() {
        if (in == null) {
            in = createInMessage();
            configureMessage(in);
        }
        return in;
    }
    public void setIn(Message in) {
        this.in = in;
        configureMessage(in);
    }
    public Message getOut() {
        return getOut(true);
    }
    public Message getOut(boolean lazyCreate) {
        if (out == null && lazyCreate) {
            out = createOutMessage();
            configureMessage(out);
        }
        return out;
    }
    public void setOut(Message out) {
        this.out = out;
        configureMessage(out);
    }
    public Throwable getException() {
        return exception;
    }
    public void setException(Throwable exception) {
        this.exception = exception;
    }
    public ExchangePattern getPattern() {
        return pattern;
    }
    public void setPattern(ExchangePattern pattern) {
        this.pattern = pattern;
    }
    public void throwException() throws Exception {
        if (exception == null) {
            return;
        }
        if (exception instanceof Exception) {
            throw (Exception)exception;
        }
        if (exception instanceof RuntimeException) {
            throw (RuntimeException)exception;
        }
        throw new RuntimeCamelException(exception);
    }
    public Message getFault() {
        return getFault(true);
    }
    public Message getFault(boolean lazyCreate) {
        if (fault == null && lazyCreate) {
            fault = createFaultMessage();
            configureMessage(fault);
        }
        return fault;
    }
    public void setFault(Message fault) {
        this.fault = fault;
        configureMessage(fault);
    }
    public String getExchangeId() {
        return exchangeId;
    }
    public void setExchangeId(String id) {
        this.exchangeId = id;
    }
    /**
     * Returns true if this exchange failed due to either an exception or fault
     *
     * @see Exchange#getException()
     * @see Exchange#getFault()
     * @return true if this exchange failed due to either an exception or fault
     */
    public boolean isFailed() {
        Message faultMessage = getFault(false);
        if (faultMessage != null) {
            Object faultBody = faultMessage.getBody();
            if (faultBody != null) {
                return true;
            }
        }
        return getException() != null;
    }
    public UnitOfWork getUnitOfWork() {
        return unitOfWork;
    }
    public void setUnitOfWork(UnitOfWork unitOfWork) {
        this.unitOfWork = unitOfWork;
    }
    /**
     * Factory method used to lazily create the IN message
     */
    protected Message createInMessage() {
        return new DefaultMessage();
    }
    /**
     * Factory method to lazily create the OUT message
     */
    protected Message createOutMessage() {
        return new DefaultMessage();
    }
    /**
     * Factory method to lazily create the FAULT message
     */
    protected Message createFaultMessage() {
        return new DefaultMessage();
    }
    /**
     * Configures the message after it has been set on the exchange
     */
    protected void configureMessage(Message message) {
        if (message instanceof MessageSupport) {
            MessageSupport messageSupport = (MessageSupport)message;
            messageSupport.setExchange(this);
        }
    }
}
"
org.apache.camel.impl.DefaultExchangeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.spi.ExchangeConverter;
/**
 * @version $Revision: 563607 $
 */
public class DefaultExchangeConverter implements ExchangeConverter {
    public <T> T convertTo(Class<T> type, Exchange exchange) {
        // TODO use some kinda introspection to find available exchange conversions
        return null;
    }
}
"
org.apache.camel.impl.DefaultLanguageResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.NoSuchLanguageException;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LanguageResolver;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
/**
 * @version $Revision: 1.1 $
 */
public class DefaultLanguageResolver implements LanguageResolver {
    protected static final FactoryFinder LANGUAGE_FACTORY = new FactoryFinder(""META-INF/services/org/apache/camel/language/"");
    protected static final FactoryFinder LANGUAGE_RESOLVER = new FactoryFinder(""META-INF/services/org/apache/camel/language/resolver/"");
    public Language resolveLanguage(String name, CamelContext context) {
        Class type = null;
        try {
            type = LANGUAGE_FACTORY.findClass(name);
        } catch (NoFactoryAvailableException e) {
            // ignore
        } catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Language registered for scheme : "" + name, e);
        }
        if (type != null) {
            if (Language.class.isAssignableFrom(type)) {
                return (Language)context.getInjector().newInstance(type);
            } else {
                throw new IllegalArgumentException(""Type is not a Language implementation. Found: "" + type.getName());
            }
        }
        return noSpecificLanguageFound(name, context);
    }
    protected Language noSpecificLanguageFound(String name, CamelContext context) {
        Class type = null;
        try {
            type = LANGUAGE_RESOLVER.findClass(""default"");
        } catch (NoFactoryAvailableException e) {
            // ignore
        } catch (Throwable e) {
            throw new IllegalArgumentException(""Invalid URI, no Language registered for scheme : "" + name, e);
        }
        if (type != null) {
            if (LanguageResolver.class.isAssignableFrom(type)) {
                LanguageResolver resolver = (LanguageResolver)context.getInjector().newInstance(type);
                return resolver.resolveLanguage(name, context);
            } else {
                throw new IllegalArgumentException(""Type is not a LanguageResolver implementation. Found: "" + type.getName());
            }
        }
        throw new NoSuchLanguageException(name);
    }
}
"
org.apache.camel.impl.DefaultLifecycleStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Collection;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.model.RouteType;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.Route;
import org.apache.camel.Service;
public class DefaultLifecycleStrategy implements LifecycleStrategy {
	public void onContextCreate(CamelContext context) {
		// do nothing
	}
	public void onEndpointAdd(Endpoint endpoint) {
		// do nothing
	}
	public void onServiceAdd(CamelContext context, Service service) {
		// do nothing
	}
	public void onRoutesAdd(Collection<Route> routes) {
		// do nothing
	}
	public void beforeStartRouteType(CamelContext context, RouteType routeType) {
		// do nothing
	}
}
"
org.apache.camel.impl.DefaultMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Message;
import java.util.HashMap;
import java.util.Map;
/**
 * The default implementation of {@link Message}
 * 
 * @version $Revision: 567570 $
 */
public class DefaultMessage extends MessageSupport {
    private Map<String, Object> headers;
    @Override
    public String toString() {
        return ""Message: "" + getBody();
    }
    public Object getHeader(String name) {
        return getHeaders().get(name);
    }
    public <T> T getHeader(String name, Class<T> type) {
        Object value = getHeader(name);
        return getExchange().getContext().getTypeConverter().convertTo(type, value);
    }
    public void setHeader(String name, Object value) {
        if (headers == null) {
            headers = createHeaders();
        }
        headers.put(name, value);
    }
    public Object removeHeader(String name) {
        if (headers != null) {
            return headers.remove(name);
        }
        else {
            return null;
        }
    }
    public Map<String, Object> getHeaders() {
        if (headers == null) {
            headers = createHeaders();
        }
        return headers;
    }
    public void setHeaders(Map<String, Object> headers) {
        this.headers = headers;
    }
    public DefaultMessage newInstance() {
        return new DefaultMessage();
    }
    /**
     * A factory method to lazily create the headers to make it easy to create
     * efficient Message implementations which only construct and populate the
     * Map on demand
     * 
     * @return return a newly constructed Map possibly containing headers from
     *         the underlying inbound transport
     */
    protected Map<String, Object> createHeaders() {
        HashMap<String, Object> map = new HashMap<String, Object>();
        populateInitialHeaders(map);
        return map;
    }
    /**
     * A strategy method populate the initial set of headers on an inbound
     * message from an underlying binding
     * 
     * @param map is the empty header map to populate
     */
    protected void populateInitialHeaders(Map<String, Object> map) {
    }
}
"
org.apache.camel.impl.DefaultPollingEndpoint,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Component;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
/**
 * A base class for an endpoint which the default consumer mode is to use a {@link PollingConsumer}
 *
 * @version $Revision: 1.1 $
 */
public abstract class DefaultPollingEndpoint<E extends Exchange> extends ScheduledPollEndpoint<E>  {
    protected DefaultPollingEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
    }
    protected DefaultPollingEndpoint(String endpointUri, CamelContext context) {
        super(endpointUri, context);
    }
    public Consumer<E> createConsumer(Processor processor) throws Exception {
        DefaultScheduledPollConsumer result = new DefaultScheduledPollConsumer(this, processor);
        configureConsumer(result);
        return result;
    }
}
"
org.apache.camel.impl.DefaultProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
/**
 * A default implementation of @{link Producer} for implementation inheritence
 *
 * @version $Revision: 572712 $
 */
public abstract class DefaultProducer<E extends Exchange> extends ServiceSupport implements Producer<E> {
    private Endpoint<E> endpoint;
    public DefaultProducer(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public E createExchange() {
        return endpoint.createExchange();
    }
    public E createExchange(ExchangePattern pattern) {
        return endpoint.createExchange(pattern);
    }
    public E createExchange(E exchange) {
        return endpoint.createExchange(exchange);
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.impl.DefaultScheduledPollConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import java.util.concurrent.ScheduledExecutorService;
/**
 * A default implementation of an event driven {@link Consumer} which uses the {@link PollingConsumer}
 *
 * @version $Revision: 1.1 $
 */
public class DefaultScheduledPollConsumer<E extends Exchange> extends ScheduledPollConsumer<E> {
    private PollingConsumer<E> pollingConsumer;
    public DefaultScheduledPollConsumer(DefaultEndpoint<E> defaultEndpoint, Processor processor) {
        super(defaultEndpoint, processor);
    }
    public DefaultScheduledPollConsumer(Endpoint<E> endpoint, Processor processor, ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
    }
    protected void poll() throws Exception {
        while (true) {
            E exchange = pollingConsumer.receiveNoWait();
            if (exchange == null) {
                break;
            }
            getProcessor().process(exchange);
        }
    }
    @Override
    protected void doStart() throws Exception {
        pollingConsumer = getEndpoint().createPollingConsumer();
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        if (pollingConsumer != null) {
            pollingConsumer.stop();
        }
    }
}
"
org.apache.camel.impl.DefaultUnitOfWork,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Exchange;
import org.apache.camel.spi.Synchronization;
import org.apache.camel.spi.UnitOfWork;
/**
 * The default implementation of {@link UnitOfWork}
 *
 * @version $Revision: 1.1 $
 */
public class DefaultUnitOfWork implements UnitOfWork {
    private List<Synchronization> synchronizations;
    private List<AsyncCallback> asyncCallbacks;
    private CountDownLatch latch;
    public DefaultUnitOfWork() {
    }
    public synchronized void addSynchronization(Synchronization synchronization) {
        if (synchronizations == null) {
            synchronizations = new ArrayList<Synchronization>();
        }
        synchronizations.add(synchronization);
    }
    public synchronized void removeSynchronization(Synchronization synchronization) {
        if (synchronizations != null) {
            synchronizations.remove(synchronization);
        }
    }
    public void reset() {
    }
    public void done(Exchange exchange) {
        if (synchronizations != null) {
            boolean failed = exchange.isFailed();
            for (Synchronization synchronization : synchronizations) {
                if (failed) {
                    synchronization.onFailure(exchange);
                }
                else {
                    synchronization.onComplete(exchange);
                }
            }
        }
    }
    public boolean isSynchronous() {
        return asyncCallbacks == null || asyncCallbacks.isEmpty();
    }
    /**
     * Register some asynchronous processing step
     */
    /*
    public synchronized AsyncCallback addAsyncStep() {
        AsyncCallback answer = new AsyncCallback() {
            public void done(boolean doneSynchronously) {
                latch.countDown();
            }
        };
        if (latch == null) {
            latch = new CountDownLatch(1);
        }
        else {
            // TODO increment latch!
        }
        if (asyncCallbacks == null) {
            asyncCallbacks = new ArrayList<AsyncCallback>();
        }
        asyncCallbacks.add(answer);
        return answer;
    }
    */
}
"
org.apache.camel.impl.EventDrivenConsumerRoute,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.List;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.Service;
/**
 * A {@link Route} which starts with an
 * <a href=""http://activemq.apache.org/camel/event-driven-consumer.html"">Event Driven Consumer</a>
 *
 * @version $Revision: 1.1 $
 */
public class EventDrivenConsumerRoute<E extends Exchange> extends Route<E> {
    private Processor processor;
    public EventDrivenConsumerRoute(Endpoint endpoint, Processor processor) {
        super(endpoint);
        this.processor = processor;
    }
    @Override
    public String toString() {
        return ""EventDrivenConsumerRoute["" + getEndpoint() + "" -> "" + processor + ""]"";
    }
    public Processor getProcessor() {
        return processor;
    }
    public void setProcessor(Processor processor) {
        this.processor = processor;
    }
    /**
     * Factory method to lazily create the complete list of services required for this route
     * such as adding the processor or consumer
     */
    @Override
    protected void addServices(List<Service> services) throws Exception {
        Processor processor = getProcessor();
        if (processor instanceof Service) {
            Service service = (Service) processor;
            services.add(service);
        }
        Endpoint<E> endpoint = getEndpoint();
        Consumer<E> consumer = endpoint.createConsumer(processor);
        if (consumer != null) {
            services.add(consumer);
        }
    }
}
"
org.apache.camel.impl.EventDrivenPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.processor.Logger;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
/**
 * A default implementation of the {@link PollingConsumer} which uses the normal
 * asynchronous consumer mechanism along with a {@link BlockingQueue} to allow
 * the caller to pull messages on demand.
 * 
 * @version $Revision: 1.1 $
 */
public class EventDrivenPollingConsumer<E extends Exchange> extends PollingConsumerSupport<E> implements
    Processor {
    private static final transient Log LOG = LogFactory.getLog(EventDrivenPollingConsumer.class);
    private BlockingQueue<E> queue;
    private ExceptionHandler interuptedExceptionHandler = new LoggingExceptionHandler(new Logger(LOG));
    private Consumer<E> consumer;
    public EventDrivenPollingConsumer(Endpoint<E> endpoint) {
        this(endpoint, new ArrayBlockingQueue<E>(1000));
    }
    public EventDrivenPollingConsumer(Endpoint<E> endpoint, BlockingQueue<E> queue) {
        super(endpoint);
        this.queue = queue;
    }
    public E receiveNoWait() {
        return receive(0);
    }
    public E receive() {
        while (isRunAllowed()) {
            try {
                return queue.take();
            } catch (InterruptedException e) {
                handleInteruptedException(e);
            }
        }
        return null;
    }
    public E receive(long timeout) {
        try {
            return queue.poll(timeout, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            handleInteruptedException(e);
            return null;
        }
    }
    public void process(Exchange exchange) throws Exception {
        queue.offer((E)exchange);
    }
    public ExceptionHandler getInteruptedExceptionHandler() {
        return interuptedExceptionHandler;
    }
    public void setInteruptedExceptionHandler(ExceptionHandler interuptedExceptionHandler) {
        this.interuptedExceptionHandler = interuptedExceptionHandler;
    }
    protected void handleInteruptedException(InterruptedException e) {
        getInteruptedExceptionHandler().handleException(e);
    }
    protected void doStart() throws Exception {
        // lets add ourselves as a consumer
        consumer = getEndpoint().createConsumer(this);
        consumer.start();
    }
    protected void doStop() throws Exception {
        if (consumer != null) {
            try {
                consumer.stop();
            } finally {
                consumer = null;
            }
        }
    }
}
"
org.apache.camel.impl.ExpressionSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import static org.apache.camel.builder.PredicateBuilder.evaluateValuePredicate;
/**
 * A useful base class for {@link Predicate} and {@link Expression} implementations
 *
 * @version $Revision: 1.1 $
 */
public abstract class ExpressionSupport<E extends Exchange> implements Expression<E> , Predicate<E> {
    public boolean matches(E exchange) {
        Object value = evaluate(exchange);
        return evaluateValuePredicate(value);
    }
    public void assertMatches(String text, E exchange) {
        if (!matches(exchange)) {
            throw new AssertionError(text + assertionFailureMessage(exchange) + "" for exchange: "" + exchange);
        }
    }
    protected abstract String assertionFailureMessage(E exchange);
}
"
org.apache.camel.impl.JndiRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Hashtable;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NameNotFoundException;
import javax.naming.NamingException;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.Registry;
/**
 * A {@link Registry} implementation which looks up the objects in JNDI
 * 
 * @version $Revision: 1.1 $
 */
public class JndiRegistry implements Registry {
    private Context context;
    public JndiRegistry() {
    }
    public JndiRegistry(Context context) {
        this.context = context;
    }
    public <T> T lookup(String name, Class<T> type) {
        Object value = lookup(name);
        return type.cast(value);
    }
    public Object lookup(String name) {
        try {
            return getContext().lookup(name);
        } catch (NameNotFoundException e) {
            return null;
        } catch (NamingException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public void bind(String s, Object o) {
        try {
            getContext().bind(s, o);
        } catch (NamingException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public void close() throws NamingException {
        getContext().close();
    }
    public Context getContext() throws NamingException {
        if (context == null) {
            context = createContext();
        }
        return context;
    }
    public void setContext(Context context) {
        this.context = context;
    }
    protected Context createContext() throws NamingException {
        Hashtable properties = new Hashtable(System.getProperties());
        return new InitialContext(properties);
    }
}
"
org.apache.camel.impl.LoggingExceptionHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.processor.Logger;
import org.apache.camel.processor.LoggingLevel;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.commons.logging.LogFactory;
/**
 * A default implementation of {@link ExceptionHandler} which uses a {@link Logger} to
 * log to an arbitrary {@link Log} with some {@link LoggingLevel}
 *
 * @version $Revision: 1.1 $
 */
public class LoggingExceptionHandler implements ExceptionHandler {
    private final Logger logger;
    public LoggingExceptionHandler(Class ownerType) {
        this(new Logger(LogFactory.getLog(ownerType), LoggingLevel.ERROR));
    }
    public LoggingExceptionHandler(Logger logger) {
        this.logger = logger;
    }
    public void handleException(Throwable exception) {
        logger.log(exception.getMessage(), exception);
    }
}
"
org.apache.camel.impl.MessageSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.util.UuidGenerator;
/**
 * A base class for implementation inheritence providing the core
 * {@link Message} body handling features but letting the derived class deal
 * with headers.
 * 
 * Unless a specific provider wishes to do something particularly clever with
 * headers you probably want to just derive from {@link DefaultMessage}
 * 
 * @version $Revision: 564677 $
 */
public abstract class MessageSupport implements Message {
    private static final UuidGenerator DEFALT_ID_GENERATOR = new UuidGenerator();
    private Exchange exchange;
    private Object body;
    private String messageId = DEFALT_ID_GENERATOR.generateId();
    public Object getBody() {
        if (body == null) {
            body = createBody();
        }
        return body;
    }
    @SuppressWarnings({""unchecked"" })
    public <T> T getBody(Class<T> type) {
        Exchange e = getExchange();
        if (e != null) {
            return e.getContext().getTypeConverter().convertTo(type, getBody());
        }
        return (T)getBody();
    }
    public void setBody(Object body) {
        this.body = body;
    }
    public <T> void setBody(Object value, Class<T> type) {
        Exchange e = getExchange();
        if (e != null) {
            T v = e.getContext().getTypeConverter().convertTo(type, value);
            if (v != null) {
                value = v;
            }
        }
        setBody(value);
    }
    public Message copy() {
        Message answer = newInstance();
        answer.copyFrom(this);
        return answer;
    }
    public void copyFrom(Message that) {
        setMessageId(that.getMessageId());
        setBody(that.getBody());
        getHeaders().putAll(that.getHeaders());
    }
    public Exchange getExchange() {
        return exchange;
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    /**
     * Returns a new instance
     * 
     * @return
     */
    public abstract Message newInstance();
    /**
     * A factory method to allow a provider to lazily create the message body
     * for inbound messages from other sources
     * 
     * @return the value of the message body or null if there is no value
     *         available
     */
    protected Object createBody() {
        return null;
    }
    /**
     * @return the messageId
     */
    public String getMessageId() {
        return this.messageId;
    }
    /**
     * @param messageId the messageId to set
     */
    public void setMessageId(String messageId) {
        this.messageId = messageId;
    }
}
"
org.apache.camel.impl.MyExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
/**
 * @version $Revision: 1.1 $
 */
public class MyExchange extends DefaultExchange {
    public MyExchange(CamelContext context, ExchangePattern pattern) {
        super(context, pattern);
    }
}
"
org.apache.camel.impl.NoPolicy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Processor;
import org.apache.camel.spi.Policy;
/**
 * Represents an {@link Policy} which adds no interceptors.
 *
 * @version $Revision: 1.1 $
 */
public class NoPolicy<E> implements Policy<E> {
    public Processor wrap(Processor processor) {
        return processor;
    }
}
"
org.apache.camel.impl.NoRouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.builder.RouteBuilder;
/**
 * A helper class, usually used for testing which does not create any routes.
 *
 * @version $Revision: 1.1 $
 */
public class NoRouteBuilder extends RouteBuilder {
    private static final NoRouteBuilder INSTANCE = new NoRouteBuilder();
    public static NoRouteBuilder getInstance() {
        return INSTANCE;
    }
    public void configure() throws Exception {
    }
}
"
org.apache.camel.impl.PollingConsumerSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.spi.ExceptionHandler;
/**
 * A useful base class for implementations of {@link PollingConsumer}
 * 
 * @version $Revision: 1.1 $
 */
public abstract class PollingConsumerSupport<E extends Exchange> extends ServiceSupport implements
    PollingConsumer<E> {
    private final Endpoint<E> endpoint;
    private ExceptionHandler exceptionHandler;
    public PollingConsumerSupport(Endpoint<E> endpoint) {
        this.endpoint = endpoint;
    }
    @Override
    public String toString() {
        return ""PullConsumer on "" + endpoint;
    }
    public Endpoint<E> getEndpoint() {
        return endpoint;
    }
    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }
    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }
    /**
     * Handles the given exception using the {@link #getExceptionHandler()}
     * 
     * @param t the exception to handle
     */
    protected void handleException(Throwable t) {
        getExceptionHandler().handleException(t);
    }
}
"
org.apache.camel.impl.PredicateSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
/**
 * A useful base class for {@link Predicate} implementations
 *
 * @version $Revision: 1.1 $
 */
public abstract class PredicateSupport<E extends Exchange> implements Predicate<E> {
    public void assertMatches(String text, E exchange) {
        if (!matches(exchange)) {
            throw new AssertionError(assertionFailureMessage(exchange)  + "" on "" + exchange);
        }
    }
    protected String assertionFailureMessage(E exchange) {
        return toString();
    }
}
"
org.apache.camel.impl.ProcessorEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.PollingConsumer;
/**
 * An endpoint which allows exchanges to be sent into it which just invokes a
 * given {@link Processor}. This component does not support the use of
 * consumers.
 * 
 * @version $Revision: 1.1 $
 */
public class ProcessorEndpoint extends DefaultPollingEndpoint<Exchange> {
    private final Processor processor;
    public ProcessorEndpoint(String endpointUri, CamelContext context, Processor processor) {
        super(endpointUri, context);
        this.processor = processor;
    }
    public ProcessorEndpoint(String endpointUri, Component component, Processor processor) {
        super(endpointUri, component);
        this.processor = processor;
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) throws Exception {
                onExchange(exchange);
            }
        };
    }
    @Override
    public PollingConsumer<Exchange> createPollingConsumer() throws Exception {
        return new ProcessorPollingConsumer(this, getProcessor());
    }
    public Processor getProcessor() {
        if (processor == null) {
            return new Processor() {
                public void process(Exchange exchange) throws Exception {
                    onExchange(exchange);
                }
            };
        }
        return processor;
    }
    protected void onExchange(Exchange exchange) throws Exception {
        processor.process(exchange);
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.impl.ProcessorPollingConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeExchangeException;
import org.apache.camel.util.ServiceHelper;
/**
 * A simple implementation of {@link PollingConsumer} which just uses
 * a {@link Processor}. This implementation does not support timeout based
 * receive methods such as {@link #receive(long)}
 *
 * @version $Revision: 1.1 $
 */
public class ProcessorPollingConsumer extends PollingConsumerSupport {
    private Processor processor;
    public ProcessorPollingConsumer(Endpoint endpoint, Processor processor) {
        super(endpoint);
        this.processor = processor;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startService(processor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopService(processor);
    }
    public Exchange receive() {
        Exchange exchange = getEndpoint().createExchange();
        try {
            processor.process(exchange);
        }
        catch (Exception e) {
            throw new RuntimeExchangeException(e, exchange);
        }
        return exchange;
    }
    public Exchange receiveNoWait() {
        return receive();
    }
    public Exchange receive(long timeout) {
        return receive();
    }
}
"
org.apache.camel.impl.ProducerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.TestSupport;
import org.apache.camel.ExchangePattern;
/**
 * @version $Revision: 1.1 $
 */
public class ProducerTest extends TestSupport {
    protected CamelContext context = new DefaultCamelContext();
    protected ExchangePattern pattern = ExchangePattern.InOnly;
    public void testUsingADerivedExchange() throws Exception {
        DefaultEndpoint<MyExchange> endpoint = new DefaultEndpoint<MyExchange>(""foo"", new DefaultComponent() {
            @Override
            protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
                return null;
            }
        }) {
            public Consumer<MyExchange> createConsumer(Processor processor) throws Exception {
                return null;
            }
            public MyExchange createExchange(ExchangePattern pattern) {
                return new MyExchange(getContext(), pattern);
            }
            public Producer<MyExchange> createProducer() throws Exception {
                return null;
            }
            public boolean isSingleton() {
                return false;
            }
        };
        DefaultProducer producer = new DefaultProducer(endpoint) {
            public void process(Exchange exchange) throws Exception {
                log.debug(""Received: "" + exchange);
            }
        };
        // now lets try send in a normal exchange
        Exchange exchange = new DefaultExchange(context);
        producer.process(exchange);
        Class type = endpoint.getExchangeType();
        assertEquals(""exchange type"", MyExchange.class, type);
        MyExchange actual = endpoint.createExchange(exchange);
        assertNotNull(actual);
        assertTrue(""Not same exchange"", actual != exchange);
        MyExchange expected = new MyExchange(context, pattern);
        actual = endpoint.createExchange(expected);
        assertSame(""Should not copy an exchange when of the correct type"", expected, actual);
    }
}
"
org.apache.camel.impl.ReflectionInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.Injector;
import org.apache.camel.util.ObjectHelper;
/**
 * A simple implementation of {@link Injector} which just uses reflection to
 * instantiate new objects using their zero argument constructor. For more
 * complex implementations try the Spring or Guice implementations.
 * 
 * @version $Revision: 580248 $
 */
public class ReflectionInjector implements Injector {
    public <T> T newInstance(Class<T> type) {
        return ObjectHelper.newInstance(type);
    }
}
"
org.apache.camel.impl.RegistryTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.Arrays;
import java.util.List;
import junit.framework.TestCase;
import org.apache.camel.util.jndi.JndiTest;
/**
 * @version $Revision: $
 */
public class RegistryTest extends TestCase {
    protected JndiRegistry registry;
    public void testBind() throws Exception {
        List foo = Arrays.asList(""a"", ""b"", ""c"");
        registry.bind(""foo"", foo);
        List list = registry.lookup(""foo"", List.class);
        assertEquals(""Should be same!"", foo, list);
    }
    public void testDefaultProviderAllowsValuesToBeCreatedInThePropertiesFile() throws Exception {
        Object value = registry.lookup(""foo"");
        assertEquals(""lookup of foo"", ""bar"", value);
    }
    public void testLookupOfUnknownName() throws Exception {
        Object value = registry.lookup(""No such entry!"");
        assertNull(""Should not find anything!"", value);
    }
    protected void setUp() throws Exception {
        super.setUp();
        registry = new JndiRegistry(JndiTest.createInitialContext());
    }
}
"
org.apache.camel.impl.RouteContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.model.FromType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import org.apache.camel.processor.Interceptor;
import org.apache.camel.processor.Pipeline;
import org.apache.camel.processor.ProceedProcessor;
import org.apache.camel.processor.UnitOfWorkProcessor;
/**
 * The context used to activate new routing rules
 * 
 * @version $Revision: $
 */
public class RouteContext {
    private final RouteType route;
    private final FromType from;
    private final Collection<Route> routes;
    private Endpoint endpoint;
    private List<Processor> eventDrivenProcessors = new ArrayList<Processor>();
    private Interceptor lastInterceptor;
    public RouteContext(RouteType route, FromType from, Collection<Route> routes) {
        this.route = route;
        this.from = from;
        this.routes = routes;
    }
    public Endpoint getEndpoint() {
        if (endpoint == null) {
            endpoint = from.resolveEndpoint(this);
        }
        return endpoint;
    }
    public FromType getFrom() {
        return from;
    }
    public RouteType getRoute() {
        return route;
    }
    public CamelContext getCamelContext() {
        return getRoute().getCamelContext();
    }
    public Processor createProcessor(ProcessorType node) throws Exception {
        return node.createOutputsProcessor(this);
    }
    public Endpoint resolveEndpoint(String uri) {
        return route.resolveEndpoint(uri);
    }
    /**
     * Resolves an endpoint from either a URI or a named reference
     */
    public Endpoint resolveEndpoint(String uri, String ref) {
        Endpoint endpoint = null;
        if (uri != null) {
            endpoint = resolveEndpoint(uri);
            if (endpoint == null) {
                throw new NoSuchEndpointException(uri);
            }
        }
        if (ref != null) {
            endpoint = lookup(ref, Endpoint.class);
            if (endpoint == null) {
                throw new NoSuchEndpointException(""ref:"" + ref);
            }
        }
        if (endpoint == null) {
            throw new IllegalArgumentException(""Either 'uri' or 'ref' must be specified on: "" + this);
        } else {
            return endpoint;
        }
    }
    /**
     * lookup an object by name and type
     */
    public <T> T lookup(String name, Class<T> type) {
        return getCamelContext().getRegistry().lookup(name, type);
    }
    /**
     * Lets complete the route creation, creating a single event driven route
     * for the current from endpoint with any processors required
     */
    public void commit() {
        // now lets turn all of the event driven consumer processors into a
        // single route
        if (!eventDrivenProcessors.isEmpty()) {
            Processor processor = Pipeline.newInstance(eventDrivenProcessors);
            // lets create the async processor
            final AsyncProcessor asyncProcessor = AsyncProcessorTypeConverter.convert(processor);
            Processor unitOfWorkProcessor = new UnitOfWorkProcessor(asyncProcessor);
            routes.add(new EventDrivenConsumerRoute(getEndpoint(), unitOfWorkProcessor));
            //routes.add(new EventDrivenConsumerRoute(getEndpoint(), processor));
        }
    }
    public void addEventDrivenProcessor(Processor processor) {
        eventDrivenProcessors.add(processor);
    }
    public void intercept(Interceptor interceptor) {
        getRoute().intercept(interceptor);
        lastInterceptor = interceptor;
    }
    public Processor createProceedProcessor() {
        if (lastInterceptor == null) {
            throw new IllegalArgumentException(""Cannot proceed() from outside of an interceptor!"");
        }
        else {
            return new ProceedProcessor(lastInterceptor);
        }
    }
}
"
org.apache.camel.impl.ScheduledPollConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A useful base class for any consumer which is polling based
 * 
 * @version $Revision: 563607 $
 */
public abstract class ScheduledPollConsumer<E extends Exchange> extends DefaultConsumer<E> implements
    Runnable {
    private static final transient Log LOG = LogFactory.getLog(ScheduledPollConsumer.class);
    private final ScheduledExecutorService executor;
    private long initialDelay = 1000;
    private long delay = 500;
    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;
    private boolean useFixedDelay;
    private ScheduledFuture<?> future;
    public ScheduledPollConsumer(DefaultEndpoint<E> endpoint, Processor processor) {
        this(endpoint, processor, endpoint.getExecutorService());
    }
    public ScheduledPollConsumer(Endpoint<E> endpoint, Processor processor, ScheduledExecutorService executor) {
        super(endpoint, processor);
        this.executor = executor;
        if (executor == null) {
            throw new IllegalArgumentException(""A non null ScheduledExecutorService must be provided."");
        }
    }
    /**
     * Invoked whenever we should be polled
     */
    public void run() {
        LOG.debug(""Starting to poll"");
        try {
            poll();
        } catch (Exception e) {
            LOG.warn(""Caught: "" + e, e);
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    public long getInitialDelay() {
        return initialDelay;
    }
    public void setInitialDelay(long initialDelay) {
        this.initialDelay = initialDelay;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
    public TimeUnit getTimeUnit() {
        return timeUnit;
    }
    public void setTimeUnit(TimeUnit timeUnit) {
        this.timeUnit = timeUnit;
    }
    public boolean isUseFixedDelay() {
        return useFixedDelay;
    }
    public void setUseFixedDelay(boolean useFixedDelay) {
        this.useFixedDelay = useFixedDelay;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * The polling method which is invoked periodically to poll this consumer
     * 
     * @throws Exception
     */
    protected abstract void poll() throws Exception;
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (isUseFixedDelay()) {
            future = executor.scheduleWithFixedDelay(this, getInitialDelay(), getDelay(), getTimeUnit());
        } else {
            future = executor.scheduleAtFixedRate(this, getInitialDelay(), getDelay(), getTimeUnit());
        }
    }
    @Override
    protected void doStop() throws Exception {
        if (future != null) {
            future.cancel(false);
        }
        super.doStop();
    }
}
"
org.apache.camel.impl.ScheduledPollEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Component;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.CamelContext;
import org.apache.camel.util.IntrospectionSupport;
import java.util.Map;
/**
 * A base class for {@link Endpoint} which creates a {@link ScheduledPollConsumer}
 *
 * @version $Revision: 1.1 $
 */
public abstract class ScheduledPollEndpoint<E extends Exchange> extends DefaultEndpoint<E> {
    private Map consumerProperties;
    protected ScheduledPollEndpoint(String endpointUri, Component component) {
        super(endpointUri, component);
    }
    protected ScheduledPollEndpoint(String endpointUri, CamelContext context) {
        super(endpointUri, context);
    }
    public Map getConsumerProperties() {
        return consumerProperties;
    }
    public void setConsumerProperties(Map consumerProperties) {
        this.consumerProperties = consumerProperties;
    }
    protected void configureConsumer(Consumer<E> consumer) throws Exception {
        if (consumerProperties != null) {
            // TODO pass in type converter
            IntrospectionSupport.setProperties(getContext().getTypeConverter(), consumer, consumerProperties);
        }
    }
    public void configureProperties(Map options) {
        Map consumerProperties = IntrospectionSupport.extractProperties(options, ""consumer."");
        if (consumerProperties != null) {
            setConsumerProperties(consumerProperties);
        }
    }
}
"
org.apache.camel.impl.SerializationDataFormat,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.OutputStream;
import org.apache.camel.Exchange;
import org.apache.camel.converter.IOConverter;
import org.apache.camel.spi.DataFormat;
/**
 * The <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * using Java Serialiation.
 *
 * @version $Revision: 1.1 $
 */
public class SerializationDataFormat implements DataFormat {
    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws IOException {
        ObjectOutput out = IOConverter.toObjectOutput(stream);
        out.writeObject(graph);
        out.flush();
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws IOException, ClassNotFoundException {
        ObjectInput in = IOConverter.toObjectInput(stream);
        return in.readObject();
    }
}
"
org.apache.camel.impl.ServiceSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl;
import org.apache.camel.Service;
import org.apache.camel.util.ServiceHelper;
import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.atomic.AtomicBoolean;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
/**
 * A useful base class which ensures that a service is only initialized once and
 * provides some helper methods for enquiring of its status
 *
 * @version $Revision: 582309 $
 */
public abstract class ServiceSupport implements Service {
    private static int threadCounter;
    private AtomicBoolean started = new AtomicBoolean(false);
    private AtomicBoolean starting = new AtomicBoolean(false);
    private AtomicBoolean stopping = new AtomicBoolean(false);
    private AtomicBoolean stopped = new AtomicBoolean(false);
    private Collection childServices;
    public void start() throws Exception {
        if (started.compareAndSet(false, true)) {
            starting.set(true);
            try {
                if (childServices != null) {
                    ServiceHelper.startServices(childServices);
                }
                doStart();
            }
            finally {
                starting.set(false);
            }
        }
    }
    public void stop() throws Exception {
        if (started.get() && stopping.compareAndSet(false, true)) {
            try {
                doStop();
            }
            finally {
                if (childServices != null) {
                    ServiceHelper.stopServices(childServices);
                }
                stopped.set(true);
                started.set(false);
                stopping.set(false);
            }
        }
    }
    /**
     * @return true if this service has been started
     */
    public boolean isStarted() {
        return started.get();
    }
    /**
     * @return true if this service is 
     */
    public boolean isStarting() {
        return starting.get();
    }
    /**
     * @return true if this service is in the process of closing
     */
    public boolean isStopping() {
        return stopping.get();
    }
    /**
     * Helper methods so the service knows if it should keep running.  Returns
     * false if the service is being stopped or is stopped.
     *  
     * @return true if the service should continue to run.
     */
    protected boolean isRunAllowed() {
        return !(stopping.get() || stopped.get());
    }
    /**
     * @return true if this service is closed
     */
    public boolean isStopped() {
        return stopped.get();
    }
    protected abstract void doStart() throws Exception;
    protected abstract void doStop() throws Exception;
    /**
     * Creates a new thread name with the given prefix
     */
    protected String getThreadName(String prefix) {
        return prefix + "" thread:"" + nextThreadCounter();
    }
    protected static synchronized int nextThreadCounter() {
        return ++threadCounter;
    }
    protected void addChildService(Object childService) {
        if (childServices == null) {
            childServices = new ArrayList();
        }
        childServices.add(childService);
    }
    protected boolean removeChildService(Object childService) {
        if (childServices != null) {
            return childServices.remove(childService);
        }
        else {
            return false;
        }
    }
}
"
org.apache.camel.impl.converter.AnnotationTypeConverterLoader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.Converter;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.CachingInjector;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.ResolverUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import static java.lang.reflect.Modifier.*;
import java.net.URL;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import java.util.StringTokenizer;
/**
 * A class which will auto-discover converter objects and methods to pre-load
 * the registry of converters on startup
 *
 * @version $Revision: 573793 $
 */
public class AnnotationTypeConverterLoader implements TypeConverterLoader {
    public static final String META_INF_SERVICES = ""META-INF/services/org/apache/camel/TypeConverter"";
    private static final transient Log LOG = LogFactory.getLog(AnnotationTypeConverterLoader.class);
    private ResolverUtil resolver = new ResolverUtil();
    private Set<Class> visitedClasses = new HashSet<Class>();
    public void load(TypeConverterRegistry registry) throws Exception {
        String[] packageNames = findPackageNames();
        resolver.findAnnotated(Converter.class, packageNames);
        Set<Class> classes = resolver.getClasses();
        for (Class type : classes) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Loading converter class: "" + ObjectHelper.name(type));
            }
            loadConverterMethods(registry, type);
        }
    }
    /**
     * Finds the names of the packages to search for on the classpath looking
     * for text files on the classpath at the
     *
     * @return a collection of packages to search for
     * @throws IOException
     * @{link #META_INF_SERVICES} location
     */
    protected String[] findPackageNames() throws IOException {
        Set<String> packages = new HashSet<String>();
        findPackages(packages, Thread.currentThread().getContextClassLoader());
        findPackages(packages, getClass().getClassLoader());
        return packages.toArray(new String[packages.size()]);
    }
    protected void findPackages(Set<String> packages, ClassLoader classLoader) throws IOException {
        Enumeration<URL> resources = classLoader.getResources(META_INF_SERVICES);
        while (resources.hasMoreElements()) {
            URL url = resources.nextElement();
            if (url != null) {
                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));
                try {
                    while (true) {
                        String line = reader.readLine();
                        if (line == null) {
                            break;
                        }
                        line = line.trim();
                        if (line.startsWith(""#"") || line.length() == 0) {
                            continue;
                        }
                        tokenize(packages, line);
                    }
                }
                finally {
                    try {
                        reader.close();
                    }
                    catch (IOException e) {
                        LOG.warn(""Caught exception closing stream: "" + e, e);
                    }
                }
            }
        }
    }
    /**
     * Tokenizes the line from the META-IN/services file using commas and
     * ignoring whitespace between packages
     */
    protected void tokenize(Set<String> packages, String line) {
        StringTokenizer iter = new StringTokenizer(line, "","");
        while (iter.hasMoreTokens()) {
            String name = iter.nextToken().trim();
            if (name.length() > 0) {
                packages.add(name);
            }
        }
    }
    /**
     * Loads all of the converter methods for the given type
     */
    protected void loadConverterMethods(TypeConverterRegistry registry, Class type) {
        if (visitedClasses.contains(type)) {
            return;
        }
        visitedClasses.add(type);
        try {
            Method[] methods = type.getDeclaredMethods();
            CachingInjector injector = null;
            for (Method method : methods) {
                Converter annotation = method.getAnnotation(Converter.class);
                if (annotation != null) {
                    Class<?>[] parameterTypes = method.getParameterTypes();
                    if (parameterTypes == null || parameterTypes.length != 1) {
                        LOG.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: "" + method
                                + "" as a converter method should have one parameter"");
                    }
                    else {
                        int modifiers = method.getModifiers();
                        if (isAbstract(modifiers) || !isPublic(modifiers)) {
                            LOG.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: "" + method
                                    + "" as a converter method is not a public and concrete method"");
                        }
                        else {
                            Class toType = method.getReturnType();
                            if (toType.equals(Void.class)) {
                                LOG.warn(""Ignoring bad converter on type: "" + type.getName() + "" method: ""
                                        + method + "" as a converter method returns a void method"");
                            }
                            else {
                                Class fromType = parameterTypes[0];
                                if (isStatic(modifiers)) {
                                	registerTypeConverter(registry, method, toType, fromType,
                                            new StaticMethodTypeConverter(method));
                                }
                                else {
                                    if (injector == null) {
                                        injector = new CachingInjector(registry, type);
                                    }
                                    registerTypeConverter(registry, method, toType, fromType,
                                            new InstanceMethodTypeConverter(injector, method));
                                }
                            }
                        }
                    }
                }
            }
            Class superclass = type.getSuperclass();
            if (superclass != null && !superclass.equals(Object.class)) {
                loadConverterMethods(registry, superclass);
            }
        }
        catch (NoClassDefFoundError e) {
            LOG.debug(""Ignoring converter type: "" + type.getName() + "" as a dependent class could not be found: "" + e, e);
        }
    }
    protected void registerTypeConverter(TypeConverterRegistry registry, Method method, 
    		Class toType, Class fromType, TypeConverter typeConverter) {
        registry.addTypeConverter(toType, fromType, typeConverter);
    }
}
"
org.apache.camel.impl.converter.ArrayTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import org.apache.camel.TypeConverter;
/**
 * A type converter which is used to convert to and from array types
 * particularly for derived types of array component types and dealing with
 * primitive array types.
 * 
 * @version $Revision: $
 */
public class ArrayTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> type, Object value) {
        if (type.isArray()) {
            if (value instanceof Collection) {
                Collection collection = (Collection)value;
                Object array = Array.newInstance(type.getComponentType(), collection.size());
                if (array instanceof Object[]) {
                    collection.toArray((Object[])array);
                } else {
                    int index = 0;
                    for (Object element : collection) {
                        Array.set(array, index++, element);
                    }
                }
                return (T)array;
            } else if (value != null && value.getClass().isArray()) {
                int size = Array.getLength(value);
                Object answer = Array.newInstance(type.getComponentType(), size);
                for (int i = 0; i < size; i++) {
                    Array.set(answer, i, Array.get(value, i));
                }
                return (T)answer;
            }
        } else if (Collection.class.isAssignableFrom(type)) {
            if (value != null) {
                if (value instanceof Object[]) {
                    return (T)Arrays.asList((Object[])value);
                } else if (value.getClass().isArray()) {
                    int size = Array.getLength(value);
                    List answer = new ArrayList(size);
                    for (int i = 0; i < size; i++) {
                        answer.add(Array.get(value, i));
                    }
                    return (T)answer;
                }
            }
        }
        return null;
    }
}
"
org.apache.camel.impl.converter.AsyncProcessorTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Service;
import org.apache.camel.TypeConverter;
import org.apache.camel.processor.DelegateProcessor;
/**
 * A simple converter that can convert any Processor to an AsyncProcessor.
 * Processing will still occur synchronously but it will provide the required
 * notifications that the caller expects.
 * 
 * @version $Revision: 581937 $
 */
public class AsyncProcessorTypeConverter implements TypeConverter {
    public static final class ProcessorToAsynProcessorBridge extends DelegateProcessor implements AsyncProcessor {
        private ProcessorToAsynProcessorBridge(Processor processor) {
            super(processor);
        }
        public boolean process(Exchange exchange, AsyncCallback callback) {
            try {
                processor.process(exchange);
            } catch (Throwable e) {
                exchange.setException(e);
            }
            // false means processing of the exchange asynchronously,
            callback.done(true);
            return true;
        }
    }
    public <T> T convertTo(Class<T> toType, Object value) {
        if (value != null) {
            if (toType.equals(AsyncProcessor.class)) {
                if (value instanceof AsyncProcessor) {
                    return toType.cast(value);
                } else if (value instanceof Processor) {
                    // Provide an async bridge to the regular processor.
                    final Processor processor = (Processor)value;
                    return toType.cast(new ProcessorToAsynProcessorBridge(processor));
                }
            }
        }
        return null;
    }
    public static AsyncProcessor convert(Processor value) {
        if (value instanceof AsyncProcessor) {
            return (AsyncProcessor)value;
        }
        return new ProcessorToAsynProcessorBridge(value);
    }
}
"
org.apache.camel.impl.converter.DefaultTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.TypeConverterAware;
import org.apache.camel.util.FactoryFinder;
import org.apache.camel.util.NoFactoryAvailableException;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 583081 $
 */
public class DefaultTypeConverter implements TypeConverter, TypeConverterRegistry {
    private static final transient Log LOG = LogFactory.getLog(DefaultTypeConverter.class);
    private Map<TypeMapping, TypeConverter> typeMappings = new HashMap<TypeMapping, TypeConverter>();
    private Injector injector;
    private List<TypeConverterLoader> typeConverterLoaders = new ArrayList<TypeConverterLoader>();
    private List<TypeConverter> fallbackConverters = new ArrayList<TypeConverter>();
    private boolean loaded;
    public DefaultTypeConverter(Injector injector) {
        typeConverterLoaders.add(new AnnotationTypeConverterLoader());
        this.injector = injector;
        addFallbackConverter(new AsyncProcessorTypeConverter());
        addFallbackConverter(new PropertyEditorTypeConverter());
        addFallbackConverter(new ToStringTypeConverter());
        addFallbackConverter(new ArrayTypeConverter());
        addFallbackConverter(new EnumTypeConverter());
    }
    public <T> T convertTo(Class<T> toType, Object value) {
        if (toType.isInstance(value)) {
            return toType.cast(value);
        }
        checkLoaded();
        TypeConverter converter = getOrFindTypeConverter(toType, value);
        if (converter != null) {
            return converter.convertTo(toType, value);
        }
        for (TypeConverter fallback : fallbackConverters) {
            T rc = fallback.convertTo(toType, value);
            if (rc != null) {
                return rc;
            }
        }
        // lets avoid NullPointerException when converting to boolean for null
        // values
        if (boolean.class.isAssignableFrom(toType)) {
            return (T) Boolean.FALSE;
        }
        if (toType.isPrimitive()) {
            Class primitiveType = ObjectHelper.convertPrimitiveTypeToWrapperType(toType);
            if (primitiveType != toType) {
                return (T) convertTo(primitiveType, value);
            }
        }
        return null;
    }
    public void addTypeConverter(Class toType, Class fromType, TypeConverter typeConverter) {
        TypeMapping key = new TypeMapping(toType, fromType);
        synchronized (typeMappings) {
            TypeConverter converter = typeMappings.get(key);
            if (converter != null) {
                LOG.warn(""Overriding type converter from: "" + converter + "" to: "" + typeConverter);
            }
            typeMappings.put(key, typeConverter);
        }
    }
    public void addFallbackConverter(TypeConverter converter) {
        fallbackConverters.add(converter);
        if (converter instanceof TypeConverterAware) {
            TypeConverterAware typeConverterAware = (TypeConverterAware)converter;
            typeConverterAware.setTypeConverter(this);
        }
    }
    public TypeConverter getTypeConverter(Class toType, Class fromType) {
        TypeMapping key = new TypeMapping(toType, fromType);
        synchronized (typeMappings) {
            return typeMappings.get(key);
        }
    }
    public Injector getInjector() {
        return injector;
    }
    public void setInjector(Injector injector) {
        this.injector = injector;
    }
    protected <T> TypeConverter getOrFindTypeConverter(Class toType, Object value) {
        Class fromType = null;
        if (value != null) {
            fromType = value.getClass();
        }
        TypeMapping key = new TypeMapping(toType, fromType);
        TypeConverter converter;
        synchronized (typeMappings) {
            converter = typeMappings.get(key);
            if (converter == null) {
                converter = findTypeConverter(toType, fromType, value);
                if (converter != null) {
                    typeMappings.put(key, converter);
                }
            }
        }
        return converter;
    }
    /**
     * Tries to auto-discover any available type converters
     */
    protected TypeConverter findTypeConverter(Class toType, Class fromType, Object value) {
        // lets try the super classes of the from type
        if (fromType != null) {
            Class fromSuperClass = fromType.getSuperclass();
            if (fromSuperClass != null && !fromSuperClass.equals(Object.class)) {
                TypeConverter converter = getTypeConverter(toType, fromSuperClass);
                if (converter == null) {
                    converter = findTypeConverter(toType, fromSuperClass, value);
                }
                if (converter != null) {
                    return converter;
                }
            }
            for (Class type : fromType.getInterfaces()) {
                TypeConverter converter = getTypeConverter(toType, type);
                if (converter != null) {
                    return converter;
                }
            }
            // lets test for arrays
            if (fromType.isArray() && !fromType.getComponentType().isPrimitive()) {
                // TODO can we try walking the inheritence-tree for the element
                // types?
                if (!fromType.equals(Object[].class)) {
                    fromSuperClass = Object[].class;
                    TypeConverter converter = getTypeConverter(toType, fromSuperClass);
                    if (converter == null) {
                        converter = findTypeConverter(toType, fromSuperClass, value);
                    }
                    if (converter != null) {
                        return converter;
                    }
                }
            }
            // lets test for Object based converters
            if (!fromType.equals(Object.class)) {
                TypeConverter converter = getTypeConverter(toType, Object.class);
                if (converter != null) {
                    return converter;
                }
            }
        }
        // lets try classes derived from this toType
        if (fromType != null) {
            Set<Map.Entry<TypeMapping, TypeConverter>> entries = typeMappings.entrySet();
            for (Map.Entry<TypeMapping, TypeConverter> entry : entries) {
                TypeMapping key = entry.getKey();
                Class aToType = key.getToType();
                if (toType.isAssignableFrom(aToType)) {
                    if (fromType.isAssignableFrom(key.getFromType())) {
                        return entry.getValue();
                    }
                }
            }
        }
        // TODO look at constructors of toType?
        return null;
    }
    /**
     * Checks if the registry is loaded and if not lazily load it
     */
    protected synchronized void checkLoaded() {
        if (!loaded) {
            loaded = true;
            try {
                for (TypeConverterLoader typeConverterLoader : typeConverterLoaders) {
                    typeConverterLoader.load(this);
                }
                // lets try load any other failback converters
                try {
                    loadFallbackTypeConverters();
                } catch (NoFactoryAvailableException e) {
                    // ignore its fine to have none
                }
            } catch (Exception e) {
                throw new RuntimeCamelException(e);
            }
        }
    }
    protected void loadFallbackTypeConverters() throws IOException, ClassNotFoundException {
        FactoryFinder finder = new FactoryFinder();
        List<TypeConverter> converters = finder.newInstances(""FallbackTypeConverter"", getInjector(),
                                                             TypeConverter.class);
        for (TypeConverter converter : converters) {
            addFallbackConverter(converter);
        }
    }
    /**
     * Represents a mapping from one type (which can be null) to another
     */
    protected static class TypeMapping {
        Class toType;
        Class fromType;
        public TypeMapping(Class toType, Class fromType) {
            this.toType = toType;
            this.fromType = fromType;
        }
        public Class getFromType() {
            return fromType;
        }
        public Class getToType() {
            return toType;
        }
        @Override
        public boolean equals(Object object) {
            if (object instanceof TypeMapping) {
                TypeMapping that = (TypeMapping)object;
                return ObjectHelper.equals(this.fromType, that.fromType)
                       && ObjectHelper.equals(this.toType, that.toType);
            }
            return false;
        }
        @Override
        public int hashCode() {
            int answer = toType.hashCode();
            if (fromType != null) {
                answer *= 37 + fromType.hashCode();
            }
            return answer;
        }
        @Override
        public String toString() {
            return ""["" + fromType + ""=>"" + toType + ""]"";
        }
    }
}
"
org.apache.camel.impl.converter.EnumTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
import java.lang.reflect.Method;
/**
 * A type converter which is used to convert to and from array types
 * particularly for derived types of array component types and dealing with
 * primitive array types.
 *
 * @version $Revision: $
 */
public class EnumTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> type, Object value) {
        if (type.isEnum() && value != null) {
            String text = value.toString();
            Method method = null;
            try {
                method = type.getMethod(""valueOf"", String.class);
            }
            catch (NoSuchMethodException e) {
                throw new RuntimeCamelException(""Could not find valueOf method on enum type: "" + type.getName());
            }
            return (T) ObjectHelper.invokeMethod(method, null, text);
        }
        return null;
    }
}
"
org.apache.camel.impl.converter.InstanceMethodTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.lang.reflect.Method;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.CachingInjector;
import org.apache.camel.util.ObjectHelper;
/**
 * A {@link TypeConverter} implementation which instantiates an object
 * so that an instance method can be used as a type converter
 *
 * @version $Revision: 563607 $
 */
public class InstanceMethodTypeConverter implements TypeConverter {
    private final CachingInjector injector;
    private final Method method;
    public InstanceMethodTypeConverter(CachingInjector injector, Method method) {
        this.injector = injector;
        this.method = method;
    }
    @Override
    public String toString() {
        return ""InstanceMethodTypeConverter: "" + method;
    }
    public synchronized <T> T convertTo(Class<T> type, Object value) {
        Object instance = injector.newInstance();
        if (instance == null) {
            throw new RuntimeCamelException(""Could not instantiate aninstance of: "" + type.getName());
        }
        return (T) ObjectHelper.invokeMethod(method, instance, value);
    }
}
"
org.apache.camel.impl.converter.PropertyEditorTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
import java.beans.PropertyEditor;
import java.beans.PropertyEditorManager;
/**
 * Uses the java.beans.PropertyEditor conversion system to convert Objects to
 * and from String values.
 * 
 * @version $Revision: 523731 $
 */
public class PropertyEditorTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> toType, Object value) {
        // We can't convert null values since we can't figure out a property
        // editor for it.
        if (value == null) {
            return null;
        }
        if (value.getClass() == String.class) {
            // No conversion needed.
            if (toType == String.class) {
                return ObjectHelper.cast(toType, value);
            }
            PropertyEditor editor = PropertyEditorManager.findEditor(toType);
            if (editor != null) {
                editor.setAsText(value.toString());
                return ObjectHelper.cast(toType, editor.getValue());
            }
        } else if (toType == String.class) {
            PropertyEditor editor = PropertyEditorManager.findEditor(value.getClass());
            if (editor != null) {
                editor.setValue(value);
                return ObjectHelper.cast(toType, editor.getAsText());
            }
        }
        return null;
    }
}
"
org.apache.camel.impl.converter.StaticMethodTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import java.lang.reflect.Method;
import org.apache.camel.TypeConverter;
import org.apache.camel.util.ObjectHelper;
/**
 * A {@link TypeConverter} implementation which invokes a static method to convert from a type to another type
 *
 * @version $Revision: 563607 $
 */
public class StaticMethodTypeConverter implements TypeConverter {
    private final Method method;
    public StaticMethodTypeConverter(Method method) {
        this.method = method;
    }
    @Override
    public String toString() {
        return ""StaticMethodTypeConverter: "" + method;
    }
    public <T> T convertTo(Class<T> type, Object value) {
        return (T) ObjectHelper.invokeMethod(method, null, value);
    }
}
"
org.apache.camel.impl.converter.ToStringTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.TypeConverter;
/**
 * A simple converter that can convert any object to a String type by using the
 * toString() method of the object.
 * 
 * @version $Revision: 523731 $
 */
public class ToStringTypeConverter implements TypeConverter {
    public <T> T convertTo(Class<T> toType, Object value) {
        if (value != null) {
            if (toType.equals(String.class)) {
                return (T)value.toString();
            }
        }
        return null;
    }
}
"
org.apache.camel.impl.converter.TypeConverterLoader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
/**
 * @version $Revision: 563607 $
 */
public interface TypeConverterLoader {
    /**
     * A pluggable strategy to load type converters into a registry from some kind of mechanism
     *
     * @param registry the registry to load the type converters into
     * @throws Exception if the type converters could not be loaded
     */
    void load(TypeConverterRegistry registry) throws Exception;
}
"
org.apache.camel.impl.converter.TypeConverterRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.impl.converter;
import org.apache.camel.TypeConverter;
import org.apache.camel.spi.Injector;
/**
 * @version $Revision: 563607 $
 */
public interface TypeConverterRegistry {
    /**
     * Allows a new type converter to be bregistered
     *
     * @param toType        the type to convert to
     * @param fromType      the type to convert from
     * @param typeConverter the type converter to use
     */
    void addTypeConverter(Class toType, Class fromType, TypeConverter typeConverter);
    Injector getInjector();
}
"
org.apache.camel.issues.ExceptionTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class ExceptionTest extends ContextTestSupport {
    public void testExceptionWithoutHandler() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""<body/>"");
        assertMockEndpointsSatisifed();
    }
    public void testExceptionWithHandler() throws Exception {
        MockEndpoint resultEndpoint = getMockEndpoint(""mock:result"");
        MockEndpoint exceptionEndpoint = getMockEndpoint(""mock:exception"");
        exceptionEndpoint.expectedMessageCount(1);
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""<body/>"");
        assertMockEndpointsSatisifed();
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        final Processor exceptionThrower = new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody(""<exception/>"");
                throw new IllegalArgumentException(""Exception thrown intentionally."");
            }
        };
        return new RouteBuilder() {
            public void configure() {
                if (getName().endsWith(""WithHandler"")) {
                    log.debug(""Using exception handler"");
                    exception(IllegalArgumentException.class).to(""mock:exception"");
                }
                from(""direct:start"").process(exceptionThrower).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.issues.Issue3Test,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 1.1 $
 */
public class Issue3Test extends ContextTestSupport {
    protected String fromQueue = ""direct:A"";
    public void testIssue() throws Exception {
        sendBody(fromQueue, ""ha!"");
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from(fromQueue).process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        final Message in = exchange.getIn();
                        assertNotNull(""Message is Null"", in);
                        String isDebugString = in.getHeader(""someproperty"", String.class);
                        assertNull(""Header should be null but is: "" + isDebugString, isDebugString);
                        assertNotNull(""Message is Null"", in);
                        // the following line throws an NPE due to null being converted to a boolean
                        //boolean isDebug = in.getHeader(""someproperty"", Boolean.class);
                        //assertFalse(isDebug);
                        Boolean isDebug = in.getHeader(""someproperty"", Boolean.class);
                        assertNull(isDebug);
                        boolean isDebug2 = in.getHeader(""someproperty"", boolean.class);
                        assertFalse(isDebug2);
                    }
                });
            }
        };
    }
}
"
org.apache.camel.issues.NeilSplitterTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.issues;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import static org.apache.camel.builder.xml.XPathBuilder.xpath;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class NeilSplitterTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    class CatFight {
        String name;
        String[] cats;
        public String[] getCats() {
            return cats;
        }
        public void setCats(String[] cats) {
            this.cats = cats;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }
    public void testCustomExpression() throws Exception {
        resultEndpoint.expectedBodiesReceived(""Ginger"", ""Mr Boots"");
        template.send(""direct:custom"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                CatFight catFight = new CatFight();
                catFight.setName(""blueydart"");
                catFight.setCats(new String[]{""Ginger"", ""Mr Boots""});
                in.setBody(catFight);
                in.setHeader(""foo"", ""bar"");
            }
        });
        resultEndpoint.assertIsSatisfied();
    }
    public void testXPathExpression() throws Exception {
        resultEndpoint.expectedBodiesReceived(
                ""<b>Ginger</b>"",
                ""<b>Mr Boots</b>"");
        template.send(""direct:xpath"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""<a><b>Ginger</b><b>Mr Boots</b></a> "");
                in.setHeader(""foo"", ""bar"");
            }
        });
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                Expression catFightCats = new Expression() {
                    public Object evaluate(Exchange exchange) {
                        CatFight catFight = (CatFight)
                                exchange.getIn().getBody();
                        String[] cats = catFight.getCats();
                        return cats;
                    }
                };
                from(""direct:custom"").splitter(catFightCats).to(""mock:result"");
                from(""direct:xpath"").splitter(xpath(""/a/b"")).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.language.ExpressionEvaluationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.RuntimeCamelException;
/**
 * @version $Revision: $
 */
public class ExpressionEvaluationException extends RuntimeCamelException {
    private final Expression<Exchange> expression;
    private final Exchange exchange;
    public ExpressionEvaluationException(Expression<Exchange> expression, Exchange exchange, Throwable cause) {
        super(cause);
        this.expression = expression;
        this.exchange = exchange;
    }
    public Expression<Exchange> getExpression() {
        return expression;
    }
}
"
org.apache.camel.language.IllegalSyntaxException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.spi.Language;
/**
 * An exception thrown if some illegal syntax is rejected by a specific language
 *
 * @version $Revision: $
 */
public class IllegalSyntaxException extends RuntimeCamelException {
    private final Language language;
    private final String expression;
    public IllegalSyntaxException(Language language, String expression) {
        super(""Illegal syntax for language: "" + language + "". Expression: "" + expression);
        this.language = language;
        this.expression = expression;
    }
    public String getExpression() {
        return expression;
    }
    public Language getLanguage() {
        return language;
    }
}
"
org.apache.camel.language.LanguageAnnotation,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import org.apache.camel.component.bean.DefaultAnnotationExpressionFactory;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE })
public @interface LanguageAnnotation {
    public abstract String language();
    public abstract Class<?> factory() default DefaultAnnotationExpressionFactory.class;
}
"
org.apache.camel.language.LanguageExpression,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
/**
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface LanguageExpression {
    String language();
    String expression();
}
"
org.apache.camel.language.NamespacePrefix,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
/**
 * Creates a namespace prefix for an XPath
 * 
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.ANNOTATION_TYPE })
public @interface NamespacePrefix {
    public abstract String prefix();
    public abstract String uri();
}
"
org.apache.camel.language.Simple,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
/**
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })
@LanguageAnnotation(language = ""simple"")
public @interface Simple {
    public String value();
}
"
org.apache.camel.language.SimpleTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import org.apache.camel.LanguageTestSupport;
/**
 * @version $Revision: $
 */
public class SimpleTest extends LanguageTestSupport {
    public void testSimpleExpressions() throws Exception {
        assertExpression(""body"", ""<hello id='m123'>world!</hello>"");
        assertExpression(""in.body"", ""<hello id='m123'>world!</hello>"");
        assertExpression(""in.header.foo"", ""abc"");
        assertExpression(""header.foo"", ""abc"");
    }
    public void testComplexExpressions() throws Exception {
        assertExpression(""hey ${in.header.foo}"", ""hey abc"");
        assertExpression(""hey ${in.header.foo}!"", ""hey abc!"");
        assertExpression(""hey ${in.header.foo}-${in.header.foo}!"", ""hey abc-abc!"");
        assertExpression(""hey ${in.header.foo}${in.header.foo}"", ""hey abcabc"");
        assertExpression(""${in.header.foo}${in.header.foo}"", ""abcabc"");
        assertExpression(""${in.header.foo}"", ""abc"");
        assertExpression(""${in.header.foo}!"", ""abc!"");
    }
    public void testInvalidComplexExpression() throws Exception {
        try {
            assertExpression(""hey ${foo"", ""bad expression!"");
            fail(""Should have thrown an exception!"");
        }
        catch (IllegalArgumentException e) {
            log.debug(""Caught expected exception: "" + e, e);
        }
    }
    public void testPredicates() throws Exception {
        assertPredicate(""body"");
        assertPredicate(""header.foo"");
        assertPredicate(""header.madeUpHeader"", false);
    }
    protected String getLanguageName() {
        return ""simple"";
    }
}
"
org.apache.camel.language.XPath,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import org.apache.camel.component.bean.XPathAnnotationExpressionFactory;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * Used to inject an XPath expression into a field, property, method or parameter.
 *
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""xpath"", factory = XPathAnnotationExpressionFactory.class)
public @interface XPath {
    public String value();
    public NamespacePrefix[] namespaces() default {
    @NamespacePrefix(prefix = ""soap"", uri = ""http://www.w3.org/2003/05/soap-envelope""),
    @NamespacePrefix(prefix = ""xsd"", uri = ""http://www.w3.org/2001/XMLSchema"")};
}
"
org.apache.camel.language.XPathTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language;
import org.apache.camel.LanguageTestSupport;
import org.apache.camel.builder.xml.XPathLanguage;
import org.apache.camel.spi.Language;
import javax.xml.xpath.XPathConstants;
/**
 * @version $Revision: $
 */
public class XPathTest extends LanguageTestSupport {
    public void testExpressions() throws Exception {
        assertExpression(""in:body()"", ""<hello id='m123'>world!</hello>"");
        assertExpression(""in:header('foo')"", ""abc"");
        assertExpression(""$foo"", ""abc"");
    }
    public void testPredicates() throws Exception {
        assertPredicate(""in:header('foo') = 'abc'"");
        assertPredicate(""$foo = 'abc'"");
        assertPredicate(""$foo = 'bar'"", false);
    }
    protected String getLanguageName() {
        return ""xpath"";
    }
    @Override
    protected Language assertResolveLanguage(String languageName) {
        XPathLanguage answer = new XPathLanguage();
        answer.setResultType(XPathConstants.STRING);
        return answer;
    }
}
"
org.apache.camel.language.simple.SimpleLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.simple;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.builder.ExpressionBuilder;
import org.apache.camel.builder.PredicateBuilder;
import org.apache.camel.language.IllegalSyntaxException;
import org.apache.camel.spi.Language;
import org.apache.camel.util.ObjectHelper;
/**
 * A <a href=""http://activemq.apache.org/camel/simple.html>simple language</a>
 * which maps simple property style notations to acces headers and bodies.
 * Examples of supported expressions are <p/>
 * <ul>
 * <li>in.header.foo or header.foo to access an inbound header called 'foo'</li>
 * <li>in.body or body to access the inbound body</li>
 * <li>out.header.foo to access an outbound header called 'foo'</li>
 * <li>out.body to access the inbound body</li>
 * <li>property.foo to access the exchange property called 'foo'</li>
 * <li>sys.foo to access the system property called 'foo'</li>
 * </ul>
 *
 * @version $Revision: $
 */
public class SimpleLanguage implements Language {
    public static Expression simple(String expression) {
        SimpleLanguage language = new SimpleLanguage();
        return language.createExpression(expression);
    }
    public Predicate<Exchange> createPredicate(String expression) {
        return PredicateBuilder.toPredicate(createExpression(expression));
    }
    public Expression<Exchange> createExpression(String expression) {
        if (expression.indexOf(""${"") >= 0) {
            return createComplexExpression(expression);
        }
        return createSimpleExpression(expression);
    }
    protected Expression<Exchange> createComplexExpression(String expression) {
        List<Expression> results = new ArrayList<Expression>();
        int pivot = 0;
        int size = expression.length();
        while (pivot < size) {
            int idx = expression.indexOf(""${"", pivot);
            if (idx < 0) {
                results.add(createConstantExpression(expression, pivot, size));
                break;
            }
            else {
                if (pivot < idx) {
                    results.add(createConstantExpression(expression, pivot, idx));
                }
                pivot = idx + 2;
                int endIdx = expression.indexOf(""}"", pivot);
                if (endIdx < 0) {
                    throw new IllegalArgumentException(""Expecting } but found end of string for simple expression: "" + expression);
                }
                String simpleText = expression.substring(pivot, endIdx);
                Expression simpleExpression = createSimpleExpression(simpleText);
                results.add(simpleExpression);
                pivot = endIdx + 1;
            }
        }
        return ExpressionBuilder.concatExpression(results, expression);
    }
    protected Expression createConstantExpression(String expression, int start, int end) {
        return ExpressionBuilder.constantExpression(expression.substring(start, end));
    }
    protected Expression<Exchange> createSimpleExpression(String expression) {
        if (ObjectHelper.isEqualToAny(expression, ""body"", ""in.body"")) {
            return ExpressionBuilder.bodyExpression();
        }
        else if (ObjectHelper.equals(expression, ""out.body"")) {
            return ExpressionBuilder.outBodyExpression();
        }
        // in header expression
        String remainder = ifStartsWithReturnRemainder(""in.header."", expression);
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""header."", expression);
        }
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""headers."", expression);
        }
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""in.headers."", expression);
        }
        if (remainder != null) {
            return ExpressionBuilder.headerExpression(remainder);
        }
        // out header expression
        remainder = ifStartsWithReturnRemainder(""out.header."", expression);
        if (remainder == null) {
            remainder = ifStartsWithReturnRemainder(""out.headers."", expression);
        }
        if (remainder != null) {
            return ExpressionBuilder.outHeaderExpression(remainder);
        }
        // property
        remainder = ifStartsWithReturnRemainder(""property."", expression);
        if (remainder != null) {
            return ExpressionBuilder.propertyExpression(remainder);
        }
        // system property
        remainder = ifStartsWithReturnRemainder(""sys."", expression);
        if (remainder != null) {
            return ExpressionBuilder.propertyExpression(remainder);
        }
        throw new IllegalSyntaxException(this, expression);
    }
    protected String ifStartsWithReturnRemainder(String prefix, String text) {
        if (text.startsWith(prefix)) {
            String remainder = text.substring(prefix.length());
            if (remainder.length() > 0) {
                return remainder;
            }
        }
        return null;
    }
}
"
org.apache.camel.management.CamelNamingStrategy,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.net.InetAddress;
import java.net.UnknownHostException;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
public class CamelNamingStrategy {
    public static final String VALUE_UNKNOWN = ""unknown"";
    public static final String VALUE_ROUTE = ""route"";
    public static final String KEY_NAME = ""name"";
    public static final String KEY_TYPE = ""type"";
    public static final String KEY_CONTEXT = ""context"";
    public static final String KEY_GROUP = ""group"";
    public static final String KEY_COMPONENT = ""component"";
    public static final String KEY_ROUTE_TYPE = ""routeType"";
    public static final String KEY_ROUTE = ""route"";
    public static final String GROUP_ENDPOINTS = ""endpoints"";
    public static final String GROUP_SERVICES = ""services"";
    public static final String GROUP_ROUTE_BUILDER = ""routeBuilder"";
    public static final String GROUP_ROUTE_TYPE = ""routeType"";
    protected String domainName;
    protected String hostName = ""locahost"";
    public CamelNamingStrategy() {
        this(""org.apache.camel"");
    }
    public CamelNamingStrategy(String domainName) {
        if (domainName != null) {
            this.domainName = domainName;
        }
        try {
            hostName = InetAddress.getLocalHost().getHostName();
        }
        catch (UnknownHostException ex) {
            // ignore, use the default ""locahost""
        }
    }
    /**
     * Implements the naming strategy for a {@see CamelContext}.
     * The convention used for a {@see CamelContext} ObjectName is
     * ""<domain>:context=<context>,name=camel"".
     *
     * @param context the camel context
     * @return generated ObjectName
     * @throws MalformedObjectNameException
     */
    public ObjectName getObjectName(CamelContext context) throws MalformedObjectNameException {
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName + "":"");
        buffer.append(KEY_CONTEXT + ""="" + getContextId(context) + "","");
        buffer.append(KEY_NAME + ""="" + ""context"");
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@see ManagedEndpoint}.
     * The convention used for a {@see ManagedEndpoint} ObjectName is
     * ""<domain>:context=<context>,type=Endpoints,endpoint=[urlPrefix]localPart"".
     *
     * @param mbean
     * @return generated ObjectName
     * @throws MalformedObjectNameException
     */
    public ObjectName getObjectName(ManagedEndpoint mbean) throws MalformedObjectNameException {
        Endpoint ep = mbean.getEndpoint();
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName + "":"");
        buffer.append(KEY_CONTEXT + ""="" + getContextId(ep.getContext()) + "","");
        buffer.append(KEY_GROUP + ""="" + GROUP_ENDPOINTS + "","");
        buffer.append(KEY_COMPONENT + ""="" + getComponentId(ep) + "","");
        buffer.append(KEY_NAME + ""="" + getEndpointId(ep));
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@see ServiceSpport Service}.
     * The convention used for a {@see Service} ObjectName is
     * ""<domain>:context=<context>,type=Services,endpoint=[urlPrefix]localPart"".
     *
     * @param mbean
     * @return generated ObjectName
     * @throws MalformedObjectNameException
     */
    public ObjectName getObjectName(CamelContext context, ManagedService mbean) throws MalformedObjectNameException {
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName + "":"");
        buffer.append(KEY_CONTEXT + ""="" + getContextId(context) + "","");
        buffer.append(KEY_GROUP + ""="" + GROUP_SERVICES + "","");
        buffer.append(KEY_NAME + ""="" + Integer.toHexString(mbean.getService().hashCode()));
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@see ManagedRoute}.
     * The convention used for a {@see ManagedEndpoint} ObjectName is
     * ""<domain>:context=<context>,type=Routes,endpoint=[urlPrefix]localPart"".
     *
     * @param mbean
     * @return generated ObjectName
     * @throws MalformedObjectNameException
     */
    public ObjectName getObjectName(ManagedRoute mbean) throws MalformedObjectNameException {
        Endpoint ep = mbean.getRoute().getEndpoint();
        String ctxid = ep != null ? getContextId(ep.getContext()) : VALUE_UNKNOWN;
        String cid = getComponentId(ep);
        String id = VALUE_UNKNOWN.equals(cid) ? getEndpointId(ep) : 
        	""["" + cid + ""]"" + getEndpointId(ep);
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName + "":"");
        buffer.append(KEY_CONTEXT + ""="" + ctxid + "","");
        buffer.append(KEY_GROUP + ""="" + GROUP_ROUTE_BUILDER + "","");
        buffer.append(KEY_ROUTE_TYPE + ""="" + GROUP_ROUTE_TYPE + "","");
        buffer.append(KEY_ROUTE + ""="" + id + "","");
        buffer.append(KEY_NAME + ""="" + VALUE_ROUTE);
        return createObjectName(buffer);
    }
    /**
     * Implements the naming strategy for a {@see PerformanceCounter}.
     * The convention used for a {@see ManagedEndpoint} ObjectName is
     * ""<domain>:context=<context>,type=Routes,endpoint=[urlPrefix]localPart"".
     *
     * @param mbean
     * @return generated ObjectName
     * @throws MalformedObjectNameException
     */
    public ObjectName getObjectName(CamelContext context, PerformanceCounter mbean) throws MalformedObjectNameException {
        StringBuffer buffer = new StringBuffer();
        buffer.append(domainName + "":"");
        buffer.append(KEY_CONTEXT + ""="" + getContextId(context) + "","");
        buffer.append(KEY_GROUP + ""="" + GROUP_ENDPOINTS + "","");
        buffer.append(KEY_ROUTE + ""="" + ""Route.Counter"" + "","");
        buffer.append(KEY_NAME + ""="" + ""Stats"");
        return createObjectName(buffer);
    }
    public String getDomainName() {
        return domainName;
    }
    public void setDomainName(String domainName) {
        this.domainName = domainName;
    }
    public String getHostName() {
        return hostName;
    }
    public void setHostName(String hostName) {
        this.hostName = hostName;
    }
    protected String getContextId(CamelContext context) {
        String id = context != null ? context.getName() : VALUE_UNKNOWN;
        return hostName + ""/"" + id;
    }
    protected String getComponentId(Endpoint ep) {
        String uri = ep.getEndpointUri();
        int pos = uri.indexOf(':');
        return (pos == -1) ? VALUE_UNKNOWN : uri.substring(0, pos);
    }
    protected String getEndpointId(Endpoint ep) {
        String uri = ep.getEndpointUri();
        int pos = uri.indexOf(':');
        String id = (pos == -1) ? uri : uri.substring(pos + 1);
		if (!ep.isSingleton()) { 
			id += ""."" + Integer.toString(ep.hashCode());
		}
        id = id.replace(""="", ""_eq_"");
        id = id.replace("","", ""_cm_"");
        return id;
	}
    /**
     * Factory method to create an ObjectName escaping any required characters
     */
    protected ObjectName createObjectName(StringBuffer buffer) throws MalformedObjectNameException {
        String text = buffer.toString();
        try {
            text = text.replace(""?"", ""_qe_"");
            return new ObjectName(text);
        }
        catch (MalformedObjectNameException e) {
            throw new MalformedObjectNameException(""Could not create ObjectName from: "" + text + "". Reason: "" + e);
        }
    }
}
"
org.apache.camel.management.Counter,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.concurrent.atomic.AtomicLong;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(
        description=""Counter"", 
        currencyTimeLimit=15)
public class Counter {
	protected AtomicLong numExchanges = new AtomicLong(0L);
	@ManagedOperation(description = ""Reset counters"")
	public void reset() {
		numExchanges.set(0L);
	}
	@ManagedAttribute(description = ""Total number of exchanges"")
	public long getNumExchanges() throws Exception {
		return numExchanges.get();
	}
	public long increment() {
		return numExchanges.incrementAndGet();
	}
}
"
org.apache.camel.management.InstrumentationAgentImpl,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.management.InstanceAlreadyExistsException;
import javax.management.JMException;
import javax.management.MBeanServer;
import javax.management.MBeanServerFactory;
import javax.management.NotCompliantMBeanException;
import javax.management.ObjectInstance;
import javax.management.ObjectName;
import javax.management.modelmbean.InvalidTargetObjectTypeException;
import javax.management.modelmbean.ModelMBeanInfo;
import javax.management.modelmbean.RequiredModelMBean;
import javax.management.remote.JMXConnectorServer;
import javax.management.remote.JMXConnectorServerFactory;
import javax.management.remote.JMXServiceURL;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.InstrumentationAgent;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource;
import org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler;
public class InstrumentationAgentImpl extends ServiceSupport implements InstrumentationAgent, CamelContextAware {
    private static final transient Log LOG = LogFactory.getLog(InstrumentationAgentImpl.class);
	public static final String SYSTEM_PROPERTY_JMX = ""org.apache.camel.jmx"";
	public static final String DEFAULT_DOMAIN = ""org.apache.camel"";
	public static final String DEFAULT_HOST = ""localhost"";
	public static final int DEFAULT_PORT = 1099;
	private MBeanServer server;
	private CamelContext context;
    private Set<ObjectName> mbeans = new HashSet<ObjectName>();
    private MetadataMBeanInfoAssembler assembler;
    private JMXConnectorServer cs;
	private boolean jmxEnabled = false;
	private String jmxDomainName = null;
	private int jmxConnectorPort = 0;
    private CamelNamingStrategy namingStrategy;
    public InstrumentationAgentImpl() {
    	assembler = new MetadataMBeanInfoAssembler();
    	assembler.setAttributeSource(new AnnotationJmxAttributeSource());
            //naming = new CamelNamingStrategy(agent.getMBeanServer().getDefaultDomain());
        namingStrategy = new CamelNamingStrategy();
    }
    public CamelContext getCamelContext() {
		return context;
	}
	public void setCamelContext(CamelContext camelContext) {
		context = camelContext;
	}
	public void setMBeanServer(MBeanServer server) {
		this.server = server;
        jmxEnabled = true;
	}
	public MBeanServer getMBeanServer() {
        if (server == null) {
            server = ManagementFactory.getPlatformMBeanServer();
        }
        return server;
	}
	public void register(Object obj, ObjectName name) throws JMException {
		register(obj, name, false);
	}
	public void register(Object obj, ObjectName name, boolean forceRegistration) throws JMException {
        try {
            registerMBeanWithServer(obj, name, forceRegistration);           
        } catch (NotCompliantMBeanException e) {        
            //If this is not a ""normal"" MBean, then try to deploy it using JMX annotations
        	ModelMBeanInfo mbi = null;
        	mbi = assembler.getMBeanInfo(obj, name.toString());
            RequiredModelMBean mbean = (RequiredModelMBean)server.instantiate(RequiredModelMBean.class.getName());
            mbean.setModelMBeanInfo(mbi);
            try {
            	mbean.setManagedResource(obj, ""ObjectReference"");
            } catch (InvalidTargetObjectTypeException itotex) {
                throw new JMException(itotex.getMessage());
            }
            registerMBeanWithServer(mbean, name, forceRegistration);
        }                
	}
	public void unregister(ObjectName name) throws JMException {
        server.unregisterMBean(name);
    }
    public CamelNamingStrategy getNamingStrategy() {
        return namingStrategy;
    }
    public void setNamingStrategy(CamelNamingStrategy namingStrategy) {
        this.namingStrategy = namingStrategy;
    }
    protected void doStart() throws Exception {
        ObjectHelper.notNull(context, ""camelContext"");
        if (getMBeanServer() == null) {
			// The MBeanServer was not injected
			createMBeanServer();
		}
        if (jmxDomainName == null) {
            jmxDomainName = System.getProperty(SYSTEM_PROPERTY_JMX + "".domain"");
            if (jmxDomainName == null || jmxDomainName.length() == 0) {
                jmxDomainName = DEFAULT_DOMAIN;
            }
        }
        configureDomainName();
        LOG.debug(""Starting JMX agent on server: "" + getMBeanServer());
		if (context instanceof DefaultCamelContext) {
			DefaultCamelContext dc = (DefaultCamelContext)context;
			InstrumentationLifecycleStrategy ls = new InstrumentationLifecycleStrategy(this);
			dc.setLifecycleStrategy(ls);
			ls.onContextCreate(context);
		}
    }
    protected void doStop() throws Exception {
        //Using the array to hold the busMBeans to avoid the CurrentModificationException
        Object[] mBeans = mbeans.toArray();
        int caught = 0;
        for (Object name : mBeans) {
        	mbeans.remove((ObjectName)name);
            try {
                unregister((ObjectName)name);
            } catch (JMException jmex) {
                LOG.info(""Exception unregistering MBean"", jmex);
                caught++;
            }
        }
        if (caught > 0) {
        	LOG.warn(""A number of "" + caught + 
        		"" exceptions caught while unregistering MBeans during stop operation.  "" + 
        		""See INFO log for details.""); 
        }
    }
    private void registerMBeanWithServer(Object obj, ObjectName name, boolean forceRegistration) 
    		throws JMException {
	    ObjectInstance instance = null;
	    try {
	        instance = server.registerMBean(obj, name);           
	    } catch (InstanceAlreadyExistsException e) {            
	        if (forceRegistration) {
	        	server.unregisterMBean(name);               
	            instance = server.registerMBean(obj, name);
	        } else {
	            throw e;
	        }
	    }
	    if (instance != null) {
	    	mbeans.add(name);
	    }
    }
	public void enableJmx(String domainName, int port) {
		jmxEnabled = true;
        jmxDomainName = domainName;
        configureDomainName();
        jmxConnectorPort = port;
	}
    protected void configureDomainName() {
        if (jmxDomainName != null) {
            namingStrategy.setDomainName(jmxDomainName);
        }
    }
    protected void createMBeanServer() {
        String hostName = DEFAULT_HOST;
        boolean canAccessSystemProps = true;
        try {
        	// we'll do it this way mostly to determine if we should lookup the hostName
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPropertiesAccess();
            }
        }
        catch (SecurityException se) {
            canAccessSystemProps = false;
        }
    	if (canAccessSystemProps) {
    		if (!jmxEnabled) {
    			jmxEnabled = null != System.getProperty(SYSTEM_PROPERTY_JMX);
    			if (!jmxEnabled) {
    				// we're done here
    				return;
    			}
    		}
        	if (jmxConnectorPort <= 0) {
        		String portKey = SYSTEM_PROPERTY_JMX + "".port"";
	        	String portValue = System.getProperty(portKey);
	        	if (portValue != null && portValue.length() > 0) {
	        		try {
	        			jmxConnectorPort = Integer.parseInt(portValue);
	        		}
	        		catch (NumberFormatException nfe) {
	        			LOG.info(""Invalid port number specified via System property ["" + 
	        				portKey + ""="" + portValue + ""].  Using default: "" + DEFAULT_PORT);
	        			jmxConnectorPort = DEFAULT_PORT;
	        		}
	        	}
        	}
        	try {
                hostName = InetAddress.getLocalHost().getHostName();
        	}
        	catch (UnknownHostException uhe) {
    			LOG.info(""Cannot determine host name.  Using default: "" + DEFAULT_PORT, uhe);
                hostName = DEFAULT_HOST;
        	}
    	}
    	else {
			jmxDomainName = jmxDomainName != null ? jmxDomainName : DEFAULT_DOMAIN;
			jmxConnectorPort = jmxConnectorPort > 0 ? jmxConnectorPort : DEFAULT_PORT;
            hostName = DEFAULT_HOST;
    	}
    	if (!jmxEnabled) {
    		return;
    	}
    	// jmx is enabled but there's no MBeanServer, so create one
    	List servers = MBeanServerFactory.findMBeanServer(jmxDomainName);
    	if (servers.size() == 0) {
    		server = MBeanServerFactory.createMBeanServer(jmxDomainName);
    	}
    	else {
    		server = (MBeanServer)servers.get(0);
    	}
    	// we need a connector too
    	try {
            createJmxConnector(hostName);
    	}
    	catch (IOException ioe) {
			LOG.warn(""Could not create and start jmx connector."", ioe);
    	}
    }
    protected void createJmxConnector(String host) throws IOException {
    	if (jmxConnectorPort > 0) {
	        try {
	            LocateRegistry.createRegistry(jmxConnectorPort);
	        } catch (RemoteException ex) {
	            // the registry may had been created
	            LocateRegistry.getRegistry(jmxConnectorPort);
	        }
	        // Create an RMI connector and start it
	        JMXServiceURL url = new JMXServiceURL(
        		  ""service:jmx:rmi:///jndi/rmi://"" + host + "":"" + jmxConnectorPort +  ""/jmxrmi"");
			cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, server);
	         // Start the connector server asynchronously (in a separate thread).
	        Thread connectorThread = new Thread() {
	            public void run() {
	                try {
	                    cs.start();
	                } catch (IOException ioe) {
	        			LOG.warn(""Could not start jmx connector thread."", ioe);
	                } 
	            }
	        };
	        connectorThread.setName(""JMX Connector Thread ["" + url + ""]"");
	        connectorThread.start();
			LOG.info(""Jmx connector thread started on "" + url);
    	}
    }    
}
"
org.apache.camel.management.InstrumentationLifecycleStrategy,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.Collection;
import javax.management.JMException;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.spi.InstrumentationAgent;
import org.apache.camel.spi.LifecycleStrategy;
import org.apache.camel.Route;
import org.apache.camel.Service;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.RouteType;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class InstrumentationLifecycleStrategy implements LifecycleStrategy {
    private static final transient Log LOG = LogFactory.getLog(InstrumentationProcessor.class);
    private InstrumentationAgent agent;
    private CamelNamingStrategy namingStrategy;
    public InstrumentationLifecycleStrategy(InstrumentationAgent agent) {
		this.agent = agent;
        setNamingStrategy(agent.getNamingStrategy());
    }
	public void onContextCreate(CamelContext context) {
		if (context instanceof DefaultCamelContext) {
			try {	
				DefaultCamelContext dc = (DefaultCamelContext)context;
				ManagedService ms = new ManagedService(dc);
                agent.register(ms, getNamingStrategy().getObjectName(dc));
			}
			catch(JMException e) {
				LOG.warn(""Could not register CamelContext MBean"", e);
			}
		}
	}
	public void onEndpointAdd(Endpoint endpoint) {
		try {
			ManagedEndpoint me = new ManagedEndpoint(endpoint);
			agent.register(me, getNamingStrategy().getObjectName(me));
		}
		catch(JMException e) {
			LOG.warn(""Could not register Endpoint MBean"", e);
		}
	}
	public void onRoutesAdd(Collection<Route> routes) {
		for (Route route: routes) {
			try {
				ManagedRoute mr = new ManagedRoute(route);
				agent.register(mr, getNamingStrategy().getObjectName(mr));
			}
			catch(JMException e) {
				LOG.warn(""Could not register Route MBean"", e);
			}
		}
	}
	public void onServiceAdd(CamelContext context, Service service) {
		if (service instanceof ServiceSupport) {
			try {
				ManagedService ms = new ManagedService((ServiceSupport)service);
				agent.register(ms, getNamingStrategy().getObjectName(context, ms));
			}
			catch(JMException e) {
				LOG.warn(""Could not register Service MBean"", e);
			}
		}
	}
	public void beforeStartRouteType(CamelContext context, RouteType routeType) {
		PerformanceCounter mc = new PerformanceCounter();
		routeType.intercept(new InstrumentationProcessor(mc));
		/*
		 *  Merge performance counter with the MBean it represents instead 
		 *  of registering a new MBean
		try {
			agent.register(mc, getNamingStrategy().getObjectName(context, mc));
		}
		catch(JMException e) {
			LOG.warn(""Could not register Counter MBean"", e);
		}
		*/
	}
    public CamelNamingStrategy getNamingStrategy() {
        return namingStrategy;
    }
    public void setNamingStrategy(CamelNamingStrategy namingStrategy) {
        this.namingStrategy = namingStrategy;
    }
}
"
org.apache.camel.management.InstrumentationProcessor,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import org.apache.camel.Exchange;
import org.apache.camel.processor.DelegateProcessor;
public class InstrumentationProcessor extends DelegateProcessor {
    private PerformanceCounter counter;
    InstrumentationProcessor(PerformanceCounter counter) {
    	this.counter = counter;
    }
    public void process(Exchange exchange) throws Exception {
    	long startTime = System.nanoTime();
        super.process(exchange);
        if (counter != null) {
            if (exchange.getException() == null) {
            	counter.completedExchange((System.nanoTime() - startTime) / 1000);
            }
            else {
            	counter.completedExchange();
            }
        }
    }
}
"
org.apache.camel.management.JmxInstrumentationUsingDefaultsTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.Iterator;
import java.util.Set;
import javax.management.MBeanServer;
import javax.management.ObjectName;
import org.apache.camel.CamelContext;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.management.InstrumentationAgentImpl;
public class JmxInstrumentationUsingDefaultsTest extends ContextTestSupport {
	public static final int DEFAULT_PORT = 1099;
    protected InstrumentationAgentImpl iAgent;
    protected String domainName = InstrumentationAgentImpl.DEFAULT_DOMAIN;
    protected boolean sleepSoYouCanBrowseInJConsole = false;
    public void testMBeansRegistered() throws Exception {
        assertNotNull(iAgent.getMBeanServer());
        //assertEquals(domainName, iAgent.getMBeanServer().getDefaultDomain());
    	resolveMandatoryEndpoint(""mock:end"", MockEndpoint.class);
        ObjectName name = new ObjectName(domainName + "":group=endpoints,*"");
        Set s = iAgent.getMBeanServer().queryNames(name, null);
        if (sleepSoYouCanBrowseInJConsole) {
            Thread.sleep(100000);
        }
        assertEquals(""Could not find 2 endpoints: "" + s, 2, s.size());
    }
    public void testCounters() throws Exception {
    	MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:end"", MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(""<hello>world!</hello>"");
        sendBody(""direct:start"", ""<hello>world!</hello>"");
        resultEndpoint.assertIsSatisfied();
        /* 
         * Fixme: after stats are merged with the mbean they represent
         * 
        MBeanServer mbs = iAgent.getMBeanServer();
        ObjectName name = new ObjectName(domainName + "":name=Stats,*"");
        Set s = mbs.queryNames(name, null);
        assertEquals(""Found mbeans: "" + s, 1, s.size());
        Iterator iter = s.iterator();
        ObjectName pcob = (ObjectName)iter.next();
        Long valueofNumExchanges = (Long)mbs.getAttribute(pcob, ""NumExchanges"");
        assertNotNull(""Expected attribute not found. MBean registerred under a "" +
        		""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"", valueofNumExchanges);
        assertTrue(valueofNumExchanges == 1);
        Long valueofNumCompleted = (Long)mbs.getAttribute(pcob, ""NumCompleted"");
        assertNotNull(""Expected attribute not found. MBean registerred under a "" +
        		""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"", valueofNumCompleted);
        assertTrue(valueofNumCompleted == 1);
        Long valueofNumFailed = (Long)mbs.getAttribute(pcob, ""NumFailed"");
        assertNotNull(""Expected attribute not found. MBean registerred under a "" +
        		""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"", valueofNumFailed);
        assertTrue(valueofNumFailed == 0);
        Long valueofMinProcessingTime = (Long)mbs.getAttribute(pcob, ""MinProcessingTime"");
        assertNotNull(""Expected attribute not found. MBean registerred under a "" +
        		""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"", valueofMinProcessingTime);
        assertTrue(valueofMinProcessingTime > 0);
        Long valueofMaxProcessingTime = (Long)mbs.getAttribute(pcob, ""MaxProcessingTime"");
        assertNotNull(""Expected attribute not found. MBean registerred under a "" +
        		""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"", valueofMaxProcessingTime);
        assertTrue(valueofMaxProcessingTime > 0);
        Long valueofMeanProcessingTime = (Long)mbs.getAttribute(pcob, ""MeanProcessingTime"");
        assertNotNull(""Expected attribute not found. MBean registerred under a "" +
        		""'<domain>:name=Stats,*' key must be of type PerformanceCounter.class"", valueofMeanProcessingTime);
        assertTrue(valueofMeanProcessingTime >= valueofMinProcessingTime &&
        		valueofMeanProcessingTime <= valueofMaxProcessingTime);
         */
    }
    protected void enableJmx() {
		iAgent.enableJmx(null, 0);
	}
    protected CamelContext createCamelContext() throws Exception {
    	CamelContext context = super.createCamelContext();
    	createInstrumentationAgent(context, DEFAULT_PORT);
    	return context;
    }
    protected void createInstrumentationAgent(CamelContext context, int port) throws Exception {
    	iAgent = new InstrumentationAgentImpl();
    	iAgent.setCamelContext(context);
    	enableJmx();
    	iAgent.start();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").to(""mock:end"");
            }
        };
    }
    @Override
    protected void tearDown() throws Exception {
        iAgent.stop();
        super.tearDown();
    }
}
"
org.apache.camel.management.JmxInstrumentationUsingPropertiesTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import org.apache.camel.management.InstrumentationAgentImpl;
public class JmxInstrumentationUsingPropertiesTest extends JmxInstrumentationUsingDefaultsTest {
    @Override
    protected void setUp() throws Exception {
		domainName = ""org.apache.camel-properties"";
    	System.setProperty(InstrumentationAgentImpl.SYSTEM_PROPERTY_JMX, """");
    	System.setProperty(InstrumentationAgentImpl.SYSTEM_PROPERTY_JMX + "".domain"", domainName);
    	System.setProperty(InstrumentationAgentImpl.SYSTEM_PROPERTY_JMX + "".port"", ""1099"");
    	super.setUp();
    }
    @Override
    protected void tearDown() throws Exception {
    	// restore environment to original state
    	System.setProperty(InstrumentationAgentImpl.SYSTEM_PROPERTY_JMX, """");
    	System.setProperty(InstrumentationAgentImpl.SYSTEM_PROPERTY_JMX + "".domain"", """");
    	System.setProperty(InstrumentationAgentImpl.SYSTEM_PROPERTY_JMX + "".port"", """");
    	super.tearDown();
    }
    @Override
	protected void enableJmx() {
		// do not enable here, System properties should do the job
	}
}
"
org.apache.camel.management.JmxInstrumentationWithConnectorTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
public class JmxInstrumentationWithConnectorTest extends JmxInstrumentationUsingDefaultsTest {
    @Override
	protected void enableJmx() {
		domainName = ""org.apache.camel-explicit"";
		iAgent.enableJmx(domainName, 1099);
	}
}
"
org.apache.camel.management.ManagedEndpoint,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import org.apache.camel.Endpoint;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(
        description=""Managed Endpoint"", 
        currencyTimeLimit=15)
public class ManagedEndpoint {
	private Endpoint endpoint;
	public ManagedEndpoint(Endpoint endpoint) {
		this.endpoint = endpoint;
	}
	public Endpoint getEndpoint() {
		return endpoint;
	}
	@ManagedAttribute(description = ""Endpoint Uri"")
	public String getUri() throws Exception {
		return endpoint.getEndpointUri();
	}
}
"
org.apache.camel.management.ManagedRoute,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.io.IOException;
import org.apache.camel.Endpoint;
import org.apache.camel.Route;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(
        description=""Managed Route"", 
        currencyTimeLimit=15)
public class ManagedRoute{
	public static final String VALUE_UNKNOWN = ""Unknown"";
	private Route route;
	private String description;
	ManagedRoute(Route route) {
		this.route = route;
		this.description = route.toString();
	}
	public Route getRoute() {
		return route;
	}
	@ManagedAttribute(description = ""Route Endpoint Uri"")
	public String getEndpointUri() {
		Endpoint ep = route.getEndpoint();
		return ep != null ? ep.getEndpointUri() : VALUE_UNKNOWN;
	}
	@ManagedAttribute(description = ""Route description"")
	public String getDescription() {
		return description;
	}
	@ManagedOperation(description = ""Start Route"")
    public void start() throws IOException {
		throw new IOException(""Not supported"");
    }
	@ManagedOperation(description = ""Stop Route"")
    public void stop() throws IOException {
		throw new IOException(""Not supported"");
    }
}
"
org.apache.camel.management.ManagedService,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.io.IOException;
import org.apache.camel.Service;
import org.apache.camel.impl.ServiceSupport;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(
        description=""Managed Service"", 
        currencyTimeLimit=15)
public class ManagedService {
	private ServiceSupport service;
	public ManagedService(ServiceSupport service) {
		this.service = service;
	}
	public Service getService() {
		return service;
	}
	@ManagedAttribute(description = ""Service running state"")
    public boolean isStarted() throws IOException {
    	return service.isStarted();
    }
	@ManagedOperation(description = ""Start Service"")
    public void start() throws IOException {
    	try {
    		service.start();
    	}
    	catch (Exception e) {
    		throw new IOException(e.getMessage());
    	}
	}
	@ManagedOperation(description = ""Stop Service"")
	public void stop() throws IOException {
    	try {
    		service.stop();
    	}
    	catch (Exception e) {
    		throw new IOException(e.getMessage());
    	}
	}
}
"
org.apache.camel.management.PerformanceCounter,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.management;
import java.util.concurrent.atomic.AtomicLong;
import org.springframework.jmx.export.annotation.ManagedAttribute;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedResource;
@ManagedResource(
        description=""PerformanceCounter"", 
        currencyTimeLimit=15)
public class PerformanceCounter extends Counter {
	private AtomicLong numCompleted = new AtomicLong(0L);
	private long minProcessingTime = -1L;
	private long maxProcessingTime = -1L;
	private double totalProcessingTime = 0;
	@Override
	@ManagedOperation(description = ""Reset counters"")
	public synchronized void reset() {
		super.reset();
		numCompleted.set(0L);
		minProcessingTime = 0L;
		maxProcessingTime = 0L;
		totalProcessingTime = 0;
	}
	@ManagedAttribute(description = ""Number of successful exchanges"")
	public long getNumCompleted() throws Exception {
		return numCompleted.get();
	}
	@ManagedAttribute(description = ""Number of failed exchanges"")
	public long getNumFailed() throws Exception {
		return numExchanges.get() - numCompleted.get();
	}
	@ManagedAttribute(description = ""Min Processing Time [usec]"")
	public synchronized long getMinProcessingTime() throws Exception {
		return minProcessingTime;
	}
	@ManagedAttribute(description = ""Mean Processing Time [usec]"")
	public synchronized long getMeanProcessingTime() throws Exception {
		long count = numCompleted.get();
		return count > 0 ? (long)totalProcessingTime / count : 0L;
	}
	@ManagedAttribute(description = ""Max Processing Time [usec]"")
	public synchronized long getMaxProcessingTime() throws Exception {
		return maxProcessingTime;
	}
	public synchronized void completedExchange(long time) {
		increment();
		numCompleted.incrementAndGet();
		totalProcessingTime += time;
		if (minProcessingTime < 0 || time < minProcessingTime) {
			minProcessingTime = time;
		}
		if (time > maxProcessingTime) {
			maxProcessingTime = time;
		}
	}
	public void completedExchange() {
		numExchanges.incrementAndGet();
	}
}
"
org.apache.camel.model.AggregatorType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.Collection;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Aggregator;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.aggregate.UseLatestAggregationStrategy;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""aggregator"")
@XmlAccessorType(XmlAccessType.FIELD)
public class AggregatorType extends ExpressionNode {
    @XmlTransient
    private AggregationStrategy aggregationStrategy = new UseLatestAggregationStrategy();
    private int batchSize;
    private long batchTimeout;
    public AggregatorType() {
    }
    public AggregatorType(Expression correlationExpression) {
        super(correlationExpression);
    }
    public AggregatorType(ExpressionType correlationExpression) {
        super(correlationExpression);
    }
    public AggregatorType(Expression correlationExpression, AggregationStrategy aggregationStrategy) {
        super(correlationExpression);
        this.aggregationStrategy = aggregationStrategy;
    }
    @Override
    public String toString() {
        return ""Aggregator[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {
        Endpoint from = routeContext.getEndpoint();
        final Processor processor = routeContext.createProcessor(this);
        final Aggregator service = new Aggregator(from, processor, getExpression()
            .createExpression(routeContext), aggregationStrategy);
        if (batchSize != 0) {
            service.setBatchSize(batchSize);
        }
        if (batchSize != 0) {
            service.setBatchTimeout(batchTimeout);
        }
        Route route = new Route<Exchange>(from, service) {
            @Override
            public String toString() {
                return ""AggregatorRoute["" + getEndpoint() + "" -> "" + processor + ""]"";
            }
        };
        routes.add(route);
    }
    public AggregationStrategy getAggregationStrategy() {
        return aggregationStrategy;
    }
    public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {
        this.aggregationStrategy = aggregationStrategy;
    }
    public int getBatchSize() {
        return batchSize;
    }
    public void setBatchSize(int batchSize) {
        this.batchSize = batchSize;
    }
    public long getBatchTimeout() {
        return batchTimeout;
    }
    public void setBatchTimeout(long batchTimeout) {
        this.batchTimeout = batchTimeout;
    }
    // Fluent API
    //-------------------------------------------------------------------------
    public AggregatorType batchSize(int batchSize){
        setBatchSize(batchSize);
        return this;
    }
    public AggregatorType batchTimeout(long batchTimeout){
        setBatchTimeout(batchTimeout);
        return this;
    }
}
"
org.apache.camel.model.BeanRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.ObjectHelper;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""bean"")
@XmlAccessorType(XmlAccessType.FIELD)
public class BeanRef extends OutputType {
    @XmlAttribute(required = true)
    private String ref;
    @XmlAttribute(required = false)
    private String method;
    @XmlAttribute(required = false)
    private Class beanType;
    @XmlTransient
    private Object bean;
    public BeanRef() {
    }
    public BeanRef(String ref) {
        this.ref = ref;
    }
    public BeanRef(String ref, String method) {
        this.ref = ref;
        this.method = method;
    }
    @Override
    public String toString() {
        return ""Bean["" + getLabel() + ""]"";
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public String getMethod() {
        return method;
    }
    public void setMethod(String method) {
        this.method = method;
    }
    public void setBean(Object bean) {
        this.bean = bean;
    }
    public Class getBeanType() {
        return beanType;
    }
    public void setBeanType(Class beanType) {
        this.beanType = beanType;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        if (bean == null) {
            String reference = getRef();
            if (reference != null) {
                bean = routeContext.lookup(reference, Object.class);
            }
            else {
                ObjectHelper.notNull(beanType, ""bean, ref or beanType"");
                bean = CamelContextHelper.newInstance(routeContext.getCamelContext(), beanType);
            }
        }
        BeanProcessor answer = new BeanProcessor(bean, routeContext.getCamelContext());
        if (method != null) {
            answer.setMethodName(method);
        }
        return answer;
    }
    @Override
    public String getLabel() {
        if (ref != null) {
           String methodText = """";
            if (method != null) {
                methodText = "" method: "" + method;
            }
            return ""ref: "" + ref + methodText;
        }
        else if (bean != null) {
            return bean.toString();
        }
        else if (beanType != null) {
            return beanType.getName();
        }
        else {
            return """";
        }
    }
}
"
org.apache.camel.model.CatchType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.processor.CatchProcessor;
import org.apache.camel.util.ObjectHelper;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""catch"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CatchType extends ProcessorType {
    @XmlElementRef
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    @XmlElement(name = ""exception"")
    private List<String> exceptions = new ArrayList<String>();
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    @XmlTransient
    private List<Class> exceptionClasses;
    public CatchType() {
    }
    public CatchType(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public CatchType(Class exceptionType) {
        exceptionClasses = new ArrayList<Class>();
        exceptionClasses.add(exceptionType);
    }
    @Override
    public String toString() {
        return ""Catch[ "" + getExceptionClasses() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getLabel() {
        return getExceptionClasses().toString();
    }
    @Override
    public CatchProcessor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new CatchProcessor(getExceptionClasses(), childProcessor);
    }
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    public List<Class> getExceptionClasses() {
        if (exceptionClasses == null) {
            exceptionClasses = createExceptionClasses();
        }
        return exceptionClasses;
    }
    public void setExceptionClasses(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public List<String> getExceptions() {
        return exceptions;
    }
    public void setExceptions(List<String> exceptions) {
        this.exceptions = exceptions;
    }
    protected List<Class> createExceptionClasses() {
        List<String> list = getExceptions();
        List<Class> answer = new ArrayList<Class>(list.size());
        for (String name : list) {
            Class type = ObjectHelper.loadClass(name, getClass().getClassLoader());
            answer.add(type);
        }
        return answer;
    }
}
"
org.apache.camel.model.ChoiceType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.Endpoint;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.processor.ChoiceProcessor;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.FilterProcessor;
import org.apache.camel.util.CollectionStringBuffer;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""choice"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ChoiceType extends ProcessorType<ChoiceType> {
    @XmlElementRef
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    @XmlElementRef
    private List<WhenType> whenClauses = new ArrayList<WhenType>();
    @XmlElement(required = false)
    private OtherwiseType otherwise;
    @Override
    public String toString() {
        return ""Choice[ "" + getWhenClauses() + "" "" + getOtherwise() + ""]"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        List<FilterProcessor> filters = new ArrayList<FilterProcessor>();
        for (WhenType whenClaus : whenClauses) {
            filters.add(whenClaus.createProcessor(routeContext));
        }
        Processor otherwiseProcessor = null;
        if (otherwise != null) {
            otherwiseProcessor = otherwise.createProcessor(routeContext);
        }
        return new ChoiceProcessor(filters, otherwiseProcessor);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    public ChoiceType when(Predicate predicate) {
        getWhenClauses().add(new WhenType(predicate));
        return this;
    }
    public OtherwiseType otherwise() {
        OtherwiseType answer = new OtherwiseType();
        setOtherwise(answer);
        return answer;
    }
    // Properties
    // -------------------------------------------------------------------------
    @Override
    public String getLabel() {
        CollectionStringBuffer buffer = new CollectionStringBuffer();
        List<WhenType> list = getWhenClauses();
        for (WhenType whenType : list) {
            buffer.append(whenType.getLabel());
        }
        return buffer.toString();
    }
    public List<WhenType> getWhenClauses() {
        return whenClauses;
    }
    public void setWhenClauses(List<WhenType> whenClauses) {
        this.whenClauses = whenClauses;
    }
    public List<ProcessorType<?>> getOutputs() {
        if (otherwise != null) {
            return otherwise.getOutputs();
        }
        else if (whenClauses.isEmpty()) {
            return Collections.EMPTY_LIST;
        }
        else {
            WhenType when = whenClauses.get(whenClauses.size() - 1);
            return when.getOutputs();
        }
    }
    public OtherwiseType getOtherwise() {
        return otherwise;
    }
    public void setOtherwise(OtherwiseType otherwise) {
        this.otherwise = otherwise;
    }
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
}
"
org.apache.camel.model.DelayerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Delayer;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""delayer"")
@XmlAccessorType(XmlAccessType.FIELD)
public class DelayerType extends ExpressionNode {
    private Long delay = 0L;
    public DelayerType() {
    }
    public DelayerType(Expression processAtExpression) {
        super(processAtExpression);
    }
    public DelayerType(ExpressionType processAtExpression) {
        super(processAtExpression);
    }
    public DelayerType(Expression processAtExpression, long delay) {
        super(processAtExpression);
        this.delay = delay;
    }
    @Override
    public String toString() {
        return ""Delayer[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    public Long getDelay() {
        return delay;
    }
    public void setDelay(Long delay) {
        this.delay = delay;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        Expression processAtExpression = getExpression().createExpression(routeContext);
        return new Delayer(childProcessor, processAtExpression, delay);
    }
}
"
org.apache.camel.model.ExceptionType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import java.util.Collection;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.processor.CatchProcessor;
import org.apache.camel.processor.RedeliveryPolicy;
import org.apache.camel.util.ObjectHelper;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""onException"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ExceptionType extends ProcessorType<ProcessorType> {
    @XmlElementRef
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    @XmlElement(name = ""exception"")
    private List<String> exceptions = new ArrayList<String>();
    @XmlElement(name = ""redeliveryPolicy"", required = false)
    private RedeliveryPolicyType redeliveryPolicy;
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    @XmlTransient
    private List<Class> exceptionClasses;
    @XmlTransient
    private Processor errorHandler;
    public ExceptionType() {
    }
    public ExceptionType(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public ExceptionType(Class exceptionType) {
        exceptionClasses = new ArrayList<Class>();
        exceptionClasses.add(exceptionType);
    }
    @Override
    public String toString() {
        return ""Exception[ "" + getExceptionClasses() + "" -> "" + getOutputs() + ""]"";
    }
    /**
     * Allows an exception handler to create a new redelivery policy for this exception type
     * @param parentPolicy the current redelivery policy
     * @return a newly created redelivery policy, or return the original policy if no customization is required
     * for this exception handler.
     */
    public RedeliveryPolicy createRedeliveryPolicy(RedeliveryPolicy parentPolicy) {
        if (redeliveryPolicy != null) {
            return redeliveryPolicy.createRedeliveryPolicy(parentPolicy);
        }
        else if (errorHandler != null) {
            // lets create a new error handler that has no retries
            RedeliveryPolicy answer = parentPolicy.copy();
            answer.setMaximumRedeliveries(0);
            return answer;
        }
        return parentPolicy;
    }
    public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {
        // lets attach a processor to an error handler
        errorHandler = routeContext.createProcessor(this);
        ErrorHandlerBuilder builder = routeContext.getRoute().getErrorHandlerBuilder();
        builder.addErrorHandlers(this);
    }
    @Override
    public CatchProcessor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new CatchProcessor(getExceptionClasses(), childProcessor);
    }
    // Fluent API
    //-------------------------------------------------------------------------
    public ExceptionType backOffMultiplier(double backOffMultiplier) {
        getOrCreateRedeliveryPolicy().backOffMultiplier(backOffMultiplier);
        return this;
    }
    public ExceptionType collisionAvoidanceFactor(double collisionAvoidanceFactor) {
        getOrCreateRedeliveryPolicy().collisionAvoidanceFactor(collisionAvoidanceFactor);
        return this;
    }
    public ExceptionType collisionAvoidancePercent(short collisionAvoidancePercent) {
        getOrCreateRedeliveryPolicy().collisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }
    public ExceptionType initialRedeliveryDelay(long initialRedeliveryDelay) {
        getOrCreateRedeliveryPolicy().initialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    public ExceptionType maximumRedeliveries(int maximumRedeliveries) {
        getOrCreateRedeliveryPolicy().maximumRedeliveries(maximumRedeliveries);
        return this;
    }
    public ExceptionType useCollisionAvoidance() {
        getOrCreateRedeliveryPolicy().useCollisionAvoidance();
        return this;
    }
    public ExceptionType useExponentialBackOff() {
        getOrCreateRedeliveryPolicy().useExponentialBackOff();
        return this;
    }
    // Properties
    //-------------------------------------------------------------------------
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    public List<Class> getExceptionClasses() {
        if (exceptionClasses == null) {
            exceptionClasses = createExceptionClasses();
        }
        return exceptionClasses;
    }
    public void setExceptionClasses(List<Class> exceptionClasses) {
        this.exceptionClasses = exceptionClasses;
    }
    public List<String> getExceptions() {
        return exceptions;
    }
    public void setExceptions(List<String> exceptions) {
        this.exceptions = exceptions;
    }
    public Processor getErrorHandler() {
        return errorHandler;
    }
    public RedeliveryPolicyType getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    public void setRedeliveryPolicy(RedeliveryPolicyType redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected RedeliveryPolicyType getOrCreateRedeliveryPolicy() {
        if (redeliveryPolicy == null) {
            redeliveryPolicy = new RedeliveryPolicyType();
        }
        return redeliveryPolicy;
    }
    protected List<Class> createExceptionClasses() {
        List<String> list = getExceptions();
        List<Class> answer = new ArrayList<Class>(list.size());
        for (String name : list) {
            Class type = ObjectHelper.loadClass(name, getClass().getClassLoader());
            answer.add(type);
        }
        return answer;
    }
}
"
org.apache.camel.model.ExpressionNode,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElementRef;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.FilterProcessor;
/**
 * A base class for nodes which contain an expression and a number of outputs
 *
 * @version $Revision: $
 */
@XmlAccessorType(XmlAccessType.FIELD)
public class ExpressionNode extends ProcessorType<ProcessorType> {
    @XmlElementRef
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    @XmlElementRef
    private ExpressionType expression;
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    public ExpressionNode() {
    }
    public ExpressionNode(ExpressionType expression) {
        this.expression = expression;
    }
    public ExpressionNode(Expression expression) {
        setExpression(new ExpressionType(expression));
    }
    public ExpressionNode(Predicate predicate) {
        setExpression(new ExpressionType(predicate));
    }
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    public ExpressionType getExpression() {
        return expression;
    }
    public void setExpression(ExpressionType expression) {
        this.expression = expression;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    @Override
    public String getLabel() {
        if (getExpression() == null) {
            return """";
        }
        return getExpression().getLabel();
    }
    protected FilterProcessor createFilterProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new FilterProcessor(getExpression().createPredicate(routeContext), childProcessor);
    }
    @Override
    protected void configureChild(ProcessorType output) {
        super.configureChild(output);
        if (isInheritErrorHandler()) {
            output.setErrorHandlerBuilder(getErrorHandlerBuilder());
        }
    }
}
"
org.apache.camel.model.FilterType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Predicate;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.FilterProcessor;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""filter"")
@XmlAccessorType(XmlAccessType.FIELD)
public class FilterType extends ExpressionNode {
    public FilterType() {
    }
    public FilterType(ExpressionType expression) {
        super(expression);
    }
    public FilterType(Predicate predicate) {
        super(predicate);
    }
    @Override
    public String toString() {
        return ""Filter[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public FilterProcessor createProcessor(RouteContext routeContext) throws Exception {
        return createFilterProcessor(routeContext);
    }
}
"
org.apache.camel.model.FinallyType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""finally"")
@XmlAccessorType(XmlAccessType.FIELD)
public class FinallyType extends OutputType {
    @Override
    public String toString() {
        return ""Finally["" + getOutputs() + ""]"";
    }
    @Override
    public String getLabel() {
        return """";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return routeContext.createProcessor(this);
    }
}
"
org.apache.camel.model.FromType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.util.ObjectHelper;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
/**
 * Represents an XML &lt;to/&gt; element
 * 
 * @version $Revision: $
 */
@XmlRootElement(name = ""from"")
@XmlAccessorType(XmlAccessType.FIELD)
public class FromType {
    @XmlAttribute
    private String uri;
    @XmlAttribute
    private String ref;
    @XmlTransient
    private Endpoint endpoint;
    public FromType() {
    }
    public FromType(String uri) {
        setUri(uri);
    }
    public FromType(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    @Override
    public String toString() {
        return ""From["" + getLabel() + ""]"";
    }
    public String getLabel() {
        return description(getUri(), getRef(), getEndpoint());
    }
    public Endpoint resolveEndpoint(RouteContext context) {
        if (endpoint == null) {
            endpoint = context.resolveEndpoint(getUri(), getRef());
        }
        return endpoint;
    }
    // Properties
    // -----------------------------------------------------------------------
    public String getUri() {
        return uri;
    }
    /**
     * Sets the URI of the endpoint to use
     * 
     * @param uri the endpoint URI to use
     */
    public void setUri(String uri) {
        this.uri = uri;
    }
    public String getRef() {
        return ref;
    }
    /**
     * Sets the name of the endpoint within the registry (such as the Spring
     * ApplicationContext or JNDI) to use
     * 
     * @param ref the reference name to use
     */
    public void setRef(String ref) {
        this.ref = ref;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    /**
     * Returns the endpoint URI or the name of the reference to it
     */
    public Object getUriOrRef() {
        if (ObjectHelper.isNullOrBlank(uri)) {
            return uri;
        }
        else if (endpoint != null) {
            return endpoint.getEndpointUri();
        }
        return ref;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected static String description(String uri, String ref, Endpoint endpoint) {
        if (ref != null) {
            return ""ref:"" + ref;
        } else if (endpoint != null) {
            return endpoint.getEndpointUri();
        } else if (uri != null) {
            return uri;
        } else {
            return ""no uri or ref supplied!"";
        }
    }
}
"
org.apache.camel.model.GenerateXmlTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.io.StringWriter;
import java.util.List;
import javax.xml.bind.Marshaller;
import org.apache.camel.model.language.GroovyExpression;
/**
 * @version $Revision: 1.1 $
 */
public class GenerateXmlTest extends XmlTestSupport {
    public void testCreateSimpleXml() throws Exception {
        RoutesType context = new RoutesType();
        RouteType route = context.route();
        route.from(""seda:a"");
        route.filter(""juel"", ""in.header.foo == 'bar'"").
                to(""seda:b"");
        dump(context);
    }
    public void testGroovyFilterXml() throws Exception {
        RoutesType context = new RoutesType();
        RouteType route = context.route();
        route.from(""seda:a"");
        route.interceptors(""interceptor1"", ""interceptor2"");
        route.filter(new GroovyExpression(""in.headers.any { h -> h.startsWith('foo') }"")).
                to(""seda:b"");
        List<ProcessorType> list = route.getOutputs();
        assertEquals(""Size of list: "" + list, 1, list.size());
        dump(context);
    }
    protected void dump(RouteContainer context) throws Exception {
        Marshaller marshaller = jaxbContext.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
        StringWriter buffer = new StringWriter();
        marshaller.marshal(context, buffer);
        log.info(""Created: "" + buffer);
    }
}
"
org.apache.camel.model.IdempotentConsumerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.processor.idempotent.IdempotentConsumer;
import org.apache.camel.processor.idempotent.MessageIdRepository;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""idempotentConsumer"")
@XmlAccessorType(XmlAccessType.FIELD)
public class IdempotentConsumerType extends ExpressionNode {
    @XmlAttribute
    private String messageIdRepositoryRef;
    @XmlTransient
    private MessageIdRepository messageIdRepository;
    public IdempotentConsumerType() {
    }
    public IdempotentConsumerType(Expression messageIdExpression, MessageIdRepository messageIdRepository) {
        super(messageIdExpression);
        this.messageIdRepository = messageIdRepository;
    }
    @Override
    public String toString() {
        return ""IdempotentConsumer[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    public String getMessageIdRepositoryRef() {
        return messageIdRepositoryRef;
    }
    public void setMessageIdRepositoryRef(String messageIdRepositoryRef) {
        this.messageIdRepositoryRef = messageIdRepositoryRef;
    }
    public MessageIdRepository getMessageIdRepository() {
        return messageIdRepository;
    }
    public void setMessageIdRepository(MessageIdRepository messageIdRepository) {
        this.messageIdRepository = messageIdRepository;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        MessageIdRepository messageIdRepository = resolveMessageIdRepository(routeContext);
        return new IdempotentConsumer(getExpression().createExpression(routeContext), messageIdRepository,
                                      childProcessor);
    }
    public MessageIdRepository resolveMessageIdRepository(RouteContext routeContext) {
        if (messageIdRepository == null) {
            messageIdRepository = routeContext.lookup(messageIdRepositoryRef, MessageIdRepository.class);
        }
        return messageIdRepository;
    }
}
"
org.apache.camel.model.IdentifiedType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
/**
 * The unique identifier for a bean. The scope of the identifier
 * is the enclosing bean factory.
 * <p/>
 * <p/>
 * <p>Java class for identifiedType complex type.
 * <p/>
 * <p>The following schema fragment specifies the expected content contained within this class.
 * <p/>
 * <pre>
 * &lt;complexType name=""identifiedType"">
 *   &lt;complexContent>
 *     &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
 *       &lt;attribute name=""id"" type=""{http://www.w3.org/2001/XMLSchema}ID"" />
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 *
 * @version $Revision: 1.1 $
 */
@XmlType(name = ""identifiedType"")
@XmlAccessorType(XmlAccessType.FIELD)
public abstract class IdentifiedType {
    @XmlAttribute
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    private String id;
    /**
     * Gets the value of the id property.
     *
     * @return possible object is
     *         {@link String }
     */
    public String getId() {
        return id;
    }
    /**
     * Sets the value of the id property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setId(String value) {
        this.id = value;
    }
}
"
org.apache.camel.model.InterceptorRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.processor.DelegateProcessor;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""interceptor"")
@XmlAccessorType(XmlAccessType.FIELD)
public class InterceptorRef extends InterceptorType {
    @XmlAttribute(required = true)
    private String ref;
    @XmlTransient
    private DelegateProcessor interceptor;
    public InterceptorRef() {
    }
    public InterceptorRef(String ref) {
        setRef(ref);
    }
    public InterceptorRef(DelegateProcessor interceptor) {
        this.interceptor = interceptor;
    }
    @Override
    public String toString() {
        return ""Interceptor["" + getLabel() + ""]"";
    }
    public DelegateProcessor createInterceptor(RouteContext routeContext) {
        if (interceptor == null) {
            interceptor = routeContext.lookup(getRef(), DelegateProcessor.class);
        }
        if (interceptor == null) {
            throw new IllegalArgumentException(""No DelegateProcessor bean available for reference: "" + getRef());
        }
        return interceptor;
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public String getLabel() {
        if (ref != null) {
            return ""ref:  "" + ref;
        }
        else if (interceptor != null) {
            return interceptor.toString();
        }
        else {
            return """";
        }
    }
}
"
org.apache.camel.model.InterceptorType,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.impl.RouteContext;
import javax.xml.bind.annotation.XmlType;
/**
 * @version $Revision: 1.1 $
 */
@XmlType(name = ""interceptorType"")
public abstract class InterceptorType {
    public abstract DelegateProcessor createInterceptor(RouteContext routeContext) throws Exception;
}
"
org.apache.camel.model.InterceptType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.Predicate;
import org.apache.camel.builder.PredicateBuilder;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.processor.Interceptor;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import java.util.Collection;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""intercept"")
@XmlAccessorType(XmlAccessType.FIELD)
public class InterceptType extends OutputType<ProcessorType> {
    @Override
    public String toString() {
        return ""Intercept["" + getOutputs() + ""]"";
    }
    public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {
        Interceptor interceptor = new Interceptor();
        routeContext.intercept(interceptor);
        final Processor interceptRoute = routeContext.createProcessor(this);
        interceptor.setInterceptorLogic(interceptRoute);
    }
    /**
     * Applies this interceptor only if the given predicate is true
     */
    public OtherwiseType when(Predicate predicate) {
        return choice().when(PredicateBuilder.not(predicate)).proceed().otherwise();
    }
}
"
org.apache.camel.model.MarshalType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.processor.MarshalProcessor;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.model.dataformat.DataFormatType;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Marshals to a binary payload using the given {@link DataFormatType}
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""marshal"")
@XmlAccessorType(XmlAccessType.FIELD)
public class MarshalType extends OutputType {
    @XmlAttribute(required = false)
    private String ref;
    @XmlElementRef
    private DataFormatType dataFormatType;
    public MarshalType() {
    }
    public MarshalType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    public MarshalType(String ref) {
        this.ref = ref;
    }
    @Override
    public String toString() {
        if (dataFormatType != null) {
            return ""Marshal["" + dataFormatType + ""]"";
        }
        else {
            return ""Marshal[ref:  "" + ref + ""]"";
        }
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public DataFormatType getDataFormatType() {
        return dataFormatType;
    }
    public void setDataFormatType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        DataFormatType type = getDataFormatType();
        if (type == null) {
            notNull(ref, ""ref or dataFormatType"");
            type = routeContext.lookup(ref, DataFormatType.class);
        }
        DataFormat dataFormat = type.getDataFormat(routeContext);
        return new MarshalProcessor(dataFormat);
    }
}
"
org.apache.camel.model.MulticastType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.processor.MulticastProcessor;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""multicast"")
@XmlAccessorType(XmlAccessType.FIELD)
public class MulticastType extends OutputType<ProcessorType> {
    @Override
    public String toString() {
        return ""Multicast["" + getOutputs() + ""]"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return createOutputsProcessor(routeContext);
    }
    protected Processor createCompositeProcessor(List<Processor> list) {
        return new MulticastProcessor(list);
    }
}
"
org.apache.camel.model.NodeFactory,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
/**
 * A simple factory used to create new child nodes which allows pluggable extension points
 * such as to add extra DSL helper methods such as for the Groovy or Ruby DSLs
 *
 * @version $Revision: 1.1 $
 */
public class NodeFactory {
    public FilterType createFilter() {
        return new FilterType();
    }
    public RouteType createRoute() {
        return new RouteType();
    }
}
"
org.apache.camel.model.OtherwiseType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""otherwise"")
@XmlAccessorType(XmlAccessType.FIELD)
public class OtherwiseType extends OutputType {
    @Override
    public String toString() {
        return ""Otherwise["" + getOutputs() + ""]"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return routeContext.createProcessor(this);
    }
    @Override
    public String getLabel() {
        return ""otherwise"";
    }
}
"
org.apache.camel.model.OutputType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A useful base class for output types
 *
 * @version $Revision: 1.1 $
 */
@XmlType(name = ""outputType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class OutputType<Type extends ProcessorType> extends ProcessorType<Type> {
    private static final transient Log LOG = LogFactory.getLog(OutputType.class);
    @XmlElementRef
    protected List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    @XmlElementRef
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                configureChild(output);
            }
        }
    }
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    @Override
    protected void configureChild(ProcessorType output) {
        super.configureChild(output);
        if (isInheritErrorHandler()) {
            output.setErrorHandlerBuilder(getErrorHandlerBuilder());
        }
        // don't inherit interceptors by default
/*
        List<InterceptorType> list = output.getInterceptors();
        if (list == null) {
            log.warn(""No interceptor collection: "" + output);
        }
        else {
            list.addAll(getInterceptors());
        }
*/
    }
}
"
org.apache.camel.model.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model;
"
org.apache.camel.model.PolicyRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.spi.Policy;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""policy"")
@XmlAccessorType(XmlAccessType.FIELD)
public class PolicyRef extends OutputType {
    @XmlAttribute(required = true)
    private String ref;
    @XmlTransient
    private Policy policy;
    public PolicyRef() {
    }
    public PolicyRef(Policy policy) {
        this.policy = policy;
    }
    @Override
    public String toString() {
        return ""Policy["" + description() + ""]"";
    }
    @Override
    public String getLabel() {
        if (ref != null) {
            return ""ref:  "" + ref;
        }
        else if (policy != null) {
            return policy.toString();
        }
        else {
            return """";
        }
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = createOutputsProcessor(routeContext);
        Policy policy = resolvePolicy(routeContext);
        if (policy == null) {
            throw new IllegalArgumentException(""No policy configured: "" + this);
        }
        return policy.wrap(childProcessor);
    }
    protected Policy resolvePolicy(RouteContext routeContext) {
        if (policy == null) {
            policy = routeContext.lookup(getRef(), Policy.class);
        }
        return policy;
    }
    protected String description() {
        if (policy != null) {
            return policy.toString();
        } else {
            return ""ref:  "" + ref;
        }
    }
}
"
org.apache.camel.model.ProceedType,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import java.util.Collections;
import java.util.List;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""proceed"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ProceedType extends ProcessorType {
    public List<ProcessorType> getOutputs() {
        return Collections.EMPTY_LIST;
    }
    public List<InterceptorType> getInterceptors() {
        return Collections.EMPTY_LIST;
    }
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return routeContext.createProceedProcessor();
    }
}
"
org.apache.camel.model.ProcessorRef,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""process"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ProcessorRef extends OutputType {
    @XmlAttribute(required = true)
    private String ref;
    @XmlTransient
    private Processor processor;
    public ProcessorRef() {
    }
    public ProcessorRef(Processor processor) {
        this.processor = processor;
    }
    @Override
    public String toString() {
        return ""Processor[ref:  "" + ref + ""]"";
    }
    @Override
    public String getLabel() {
        if (ref != null) {
            return ""ref:  "" + ref;
        }
        else if (processor != null) {
            return processor.toString();
        }
        else {
            return """";
        }
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        if (processor == null) {
            processor = routeContext.lookup(getRef(), Processor.class);
        }
        return processor;
    }
}
"
org.apache.camel.model.ProcessorType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ThreadPoolExecutor;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.Builder;
import org.apache.camel.builder.DataTypeExpression;
import org.apache.camel.builder.DeadLetterChannelBuilder;
import org.apache.camel.builder.ErrorHandlerBuilder;
import org.apache.camel.builder.NoErrorHandlerBuilder;
import org.apache.camel.builder.ProcessorBuilder;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.model.language.LanguageExpression;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.processor.MulticastProcessor;
import org.apache.camel.processor.Pipeline;
import org.apache.camel.processor.RecipientList;
import org.apache.camel.processor.aggregate.AggregationStrategy;
import org.apache.camel.processor.idempotent.IdempotentConsumer;
import org.apache.camel.processor.idempotent.MessageIdRepository;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.spi.Policy;
import org.apache.camel.spi.Registry;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 1.1 $
 */
public abstract class ProcessorType<Type extends ProcessorType> {
    public static final String DEFAULT_TRACE_CATEGORY = ""org.apache.camel.TRACE"";
    private ErrorHandlerBuilder errorHandlerBuilder;
    private Boolean inheritErrorHandlerFlag = Boolean.TRUE; // TODO not sure how
    private DelegateProcessor lastInterceptor;
    private NodeFactory nodeFactory;
    // else to use an
                                                            // optional
                                                            // attribute in
                                                            // JAXB2
    public abstract List<ProcessorType<?>> getOutputs();
    public abstract List<InterceptorType> getInterceptors();
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        throw new UnsupportedOperationException(""Not implemented yet for class: "" + getClass().getName());
    }
    public Processor createOutputsProcessor(RouteContext routeContext) throws Exception {
        Collection<ProcessorType<?>> outputs = getOutputs();
        return createOutputsProcessor(routeContext, outputs);
    }
    public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {
        Processor processor = makeProcessor(routeContext);
        routeContext.addEventDrivenProcessor(processor);
    }
    /**
     * Wraps the child processor in whatever necessary interceptors and error
     * handlers
     */
    public Processor wrapProcessor(RouteContext routeContext, Processor processor) throws Exception {
        processor = wrapProcessorInInterceptors(routeContext, processor);
        return wrapInErrorHandler(processor);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    /**
     * Sends the exchange to the given endpoint URI
     */
    public Type to(String uri) {
        addOutput(new ToType(uri));
        return (Type) this;
    }
    /**
     * Sends the exchange to the given endpoint
     */
    public Type to(Endpoint endpoint) {
        addOutput(new ToType(endpoint));
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoints using the
     * {@link MulticastProcessor} pattern
     */
    public Type to(String... uris) {
        for (String uri : uris) {
            addOutput(new ToType(uri));
        }
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoints using the
     * {@link MulticastProcessor} pattern
     */
    public Type to(Endpoint... endpoints) {
        for (Endpoint endpoint : endpoints) {
            addOutput(new ToType(endpoint));
        }
        return (Type) this;
    }
    /**
     * Sends the exchange to a list of endpoint using the
     * {@link MulticastProcessor} pattern
     */
    public Type to(Collection<Endpoint> endpoints) {
        for (Endpoint endpoint : endpoints) {
            addOutput(new ToType(endpoint));
        }
        return (Type) this;
    }
    /**
     * Multicasts messages to all its child outputs; so that each processor and
     * destination gets a copy of the original message to avoid the processors
     * interfering with each other.
     */
    public MulticastType multicast() {
        MulticastType answer = new MulticastType();
        addOutput(answer);
        return answer;
    }
    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message
     * will get processed by each endpoint in turn and for request/response the
     * output of one endpoint will be the input of the next endpoint
     */
    public Type pipeline(String... uris) {
        // TODO pipeline v mulicast
        return to(uris);
    }
    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message
     * will get processed by each endpoint in turn and for request/response the
     * output of one endpoint will be the input of the next endpoint
     */
    public Type pipeline(Endpoint... endpoints) {
        // TODO pipeline v mulicast
        return to(endpoints);
    }
    /**
     * Creates a {@link Pipeline} of the list of endpoints so that the message
     * will get processed by each endpoint in turn and for request/response the
     * output of one endpoint will be the input of the next endpoint
     */
    public Type pipeline(Collection<Endpoint> endpoints) {
        // TODO pipeline v mulicast
        return to(endpoints);
    }
    /**
     * Creates an {@link IdempotentConsumer} to avoid duplicate messages
     */
    public IdempotentConsumerType idempotentConsumer(Expression messageIdExpression,
                                                     MessageIdRepository messageIdRepository) {
        IdempotentConsumerType answer = new IdempotentConsumerType(messageIdExpression, messageIdRepository);
        addOutput(answer);
        return answer;
    }
    /**
     * Creates a predicate which is applied and only if it is true then the
     * exchange is forwarded to the destination
     * 
     * @return the builder for a predicate
     */
    public FilterType filter(Predicate predicate) {
        FilterType filter = new FilterType(predicate);
        addOutput(filter);
        return filter;
    }
    /**
     * Creates a choice of one or more predicates with an otherwise clause
     * 
     * @return the builder for a choice expression
     */
    public ChoiceType choice() {
        ChoiceType answer = new ChoiceType();
        addOutput(answer);
        return answer;
    }
    /**
     * Creates a try/catch block
     * 
     * @return the builder for a tryBlock expression
     */
    public TryType tryBlock() {
        TryType answer = new TryType();
        addOutput(answer);
        return answer;
    }
    /**
     * Creates a dynamic <a
     * href=""http://activemq.apache.org/camel/recipient-list.html"">Recipient
     * List</a> pattern.
     * 
     * @param receipients is the builder of the expression used in the
     *                {@link RecipientList} to decide the destinations
     */
    public Type recipientList(Expression receipients) {
        RecipientListType answer = new RecipientListType(receipients);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * A builder for the <a
     * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a>
     * pattern where an expression is evaluated to iterate through each of the
     * parts of a message and then each part is then send to some endpoint.
     * 
     * @param receipients the expression on which to split
     * @return the builder
     */
    public SplitterType splitter(Expression receipients) {
        SplitterType answer = new SplitterType(receipients);
        addOutput(answer);
        return answer;
    }
    /**
     * A builder for the <a
     * href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
     * pattern where an expression is evaluated to be able to compare the
     * message exchanges to reorder them. e.g. you may wish to sort by some
     * header
     * 
     * @param expression the expression on which to compare messages in order
     * @return the builder
     */
    public ResequencerType resequencer(Expression<Exchange> expression) {
        return resequencer(Collections.<Expression> singletonList(expression));
    }
    /**
     * A builder for the <a
     * href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
     * pattern where a list of expressions are evaluated to be able to compare
     * the message exchanges to reorder them. e.g. you may wish to sort by some
     * headers
     * 
     * @param expressions the expressions on which to compare messages in order
     * @return the builder
     */
    public ResequencerType resequencer(List<Expression> expressions) {
        ResequencerType answer = new ResequencerType(expressions);
        addOutput(answer);
        return answer;
    }
    /**
     * A builder for the <a
     * href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
     * pattern where a list of expressions are evaluated to be able to compare
     * the message exchanges to reorder them. e.g. you may wish to sort by some
     * headers
     * 
     * @param expressions the expressions on which to compare messages in order
     * @return the builder
     */
    public ResequencerType resequencer(Expression... expressions) {
        List<Expression> list = new ArrayList<Expression>();
        for (Expression expression : expressions) {
            list.add(expression);
        }
        return resequencer(list);
    }
    /**
     * A builder for the <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern where a batch of messages are processed (up to a maximum amount
     * or until some timeout is reached) and messages for the same correlation
     * key are combined together using some kind of
     * {@link AggregationStrategy ) (by default the latest message is used) to compress many message exchanges
     * into a smaller number of exchanges. <p/> A good example of this is stock
     * market data; you may be receiving 30,000 messages/second and you may want
     * to throttle it right down so that multiple messages for the same stock
     * are combined (or just the latest message is used and older prices are
     * discarded). Another idea is to combine line item messages together into a
     * single invoice message.
     * 
     * @param correlationExpression the expression used to calculate the
     *                correlation key. For a JMS message this could be the
     *                expression <code>header(""JMSDestination"")</code> or
     *                <code>header(""JMSCorrelationID"")</code>
     */
    public AggregatorType aggregator(Expression correlationExpression) {
        AggregatorType answer = new AggregatorType(correlationExpression);
        addOutput(answer);
        return answer;
    }
    /**
     * A builder for the <a
     * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
     * pattern where a batch of messages are processed (up to a maximum amount
     * or until some timeout is reached) and messages for the same correlation
     * key are combined together using some kind of
     * {@link AggregationStrategy ) (by default the latest message is used) to compress many message exchanges
     * into a smaller number of exchanges. <p/> A good example of this is stock
     * market data; you may be receiving 30,000 messages/second and you may want
     * to throttle it right down so that multiple messages for the same stock
     * are combined (or just the latest message is used and older prices are
     * discarded). Another idea is to combine line item messages together into a
     * single invoice message.
     * 
     * @param correlationExpression the expression used to calculate the
     *                correlation key. For a JMS message this could be the
     *                expression <code>header(""JMSDestination"")</code> or
     *                <code>header(""JMSCorrelationID"")</code>
     */
    public AggregatorType aggregator(Expression correlationExpression, AggregationStrategy aggregationStrategy) {
        AggregatorType answer = new AggregatorType(correlationExpression, aggregationStrategy);
        addOutput(answer);
        return answer;
    }
    /**
     * A builder for the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where an expression is used to calculate the time which the message will
     * be dispatched on
     * 
     * @param processAtExpression an expression to calculate the time at which
     *                the messages should be processed
     * @return the builder
     */
    public DelayerType delayer(Expression<Exchange> processAtExpression) {
        return delayer(processAtExpression, 0L);
    }
    /**
     * A builder for the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where an expression is used to calculate the time which the message will
     * be dispatched on
     * 
     * @param processAtExpression an expression to calculate the time at which
     *                the messages should be processed
     * @param delay the delay in milliseconds which is added to the
     *                processAtExpression to determine the time the message
     *                should be processed
     * @return the builder
     */
    public DelayerType delayer(Expression<Exchange> processAtExpression, long delay) {
        DelayerType answer = new DelayerType(processAtExpression, delay);
        addOutput(answer);
        return answer;
    }
    /**
     * A builder for the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where a fixed amount of milliseconds are used to delay processing of a
     * message exchange
     * 
     * @param delay the default delay in milliseconds
     * @return the builder
     */
    public DelayerType delayer(long delay) {
        return delayer(null, delay);
    }
    /**
     * A builder for the <a
     * href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> pattern
     * where an expression is used to calculate the time which the message will
     * be dispatched on
     * 
     * @return the builder
     */
    public ThrottlerType throttler(long maximumRequestCount) {
        ThrottlerType answer = new ThrottlerType(maximumRequestCount);
        addOutput(answer);
        return answer;
    }
    public Type interceptor(String ref) {
        getInterceptors().add(new InterceptorRef(ref));
        return (Type) this;
    }
    public InterceptType intercept() {
        InterceptType answer = new InterceptType();
        addOutput(answer);
        return answer;
    }
    public Type proceed() {
        addOutput(new ProceedType());
        return (Type) this;
    }
    public ExceptionType exception(Class exceptionType) {
        ExceptionType answer = new ExceptionType(exceptionType);
        addOutput(answer);
        return answer;
    }
    /**
     * Apply an interceptor route if the predicate is true
     */
    public OtherwiseType intercept(Predicate predicate) {
        InterceptType answer = new InterceptType();
        addOutput(answer);
        return answer.when(predicate);
    }
    public Type interceptors(String... refs) {
        for (String ref : refs) {
            interceptor(ref);
        }
        return (Type) this;
    }
    public FilterType filter(ExpressionType expression) {
        FilterType filter = getNodeFactory().createFilter();
        filter.setExpression(expression);
        addOutput(filter);
        return filter;
    }
    public FilterType filter(String language, String expression) {
        return filter(new LanguageExpression(language, expression));
    }
    /**
     * Trace logs the exchange before it goes to the next processing step using
     * the {@link #DEFAULT_TRACE_CATEGORY} logging category.
     * 
     * @return
     */
    public Type trace() {
        return trace(DEFAULT_TRACE_CATEGORY);
    }
    /**
     * Trace logs the exchange before it goes to the next processing step using
     * the specified logging category.
     * 
     * @param category the logging category trace messages will sent to.
     * @return
     */
    public Type trace(String category) {
        final Log log = LogFactory.getLog(category);
        return intercept(new DelegateProcessor() {
            @Override
            public void process(Exchange exchange) throws Exception {
                log.trace(exchange);
                processNext(exchange);
            }
        });
    }
    public PolicyRef policies() {
        PolicyRef answer = new PolicyRef();
        addOutput(answer);
        return answer;
    }
    public PolicyRef policy(Policy policy) {
        PolicyRef answer = new PolicyRef(policy);
        addOutput(answer);
        return answer;
    }
    public Type intercept(DelegateProcessor interceptor) {
        getInterceptors().add(new InterceptorRef(interceptor));
        lastInterceptor = interceptor;
        return (Type) this;
    }
    /**
     * Installs the given error handler builder
     * 
     * @param errorHandlerBuilder the error handler to be used by default for
     *                all child routes
     * @return the current builder with the error handler configured
     */
    public Type errorHandler(ErrorHandlerBuilder errorHandlerBuilder) {
        setErrorHandlerBuilder(errorHandlerBuilder);
        return (Type) this;
    }
    /**
     * Configures whether or not the error handler is inherited by every
     * processing node (or just the top most one)
     * 
     * @param condition the falg as to whether error handlers should be
     *                inherited or not
     * @return the current builder
     */
    public Type inheritErrorHandler(boolean condition) {
        setInheritErrorHandlerFlag(condition);
        return (Type) this;
    }
    // Transformers
    // -------------------------------------------------------------------------
    /**
     * Adds the custom processor to this destination which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type process(Processor processor) {
        ProcessorRef answer = new ProcessorRef(processor);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds the custom processor reference to this destination which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type processRef(String ref) {
        ProcessorRef answer = new ProcessorRef();
        answer.setRef(ref);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean which is invoked which could be a final destination, or could
     * be a transformation in a pipeline
     */
    public Type bean(Object bean) {
        BeanRef answer = new BeanRef();
        answer.setBean(bean);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean and method which is invoked which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type bean(Object bean, String method) {
        BeanRef answer = new BeanRef();
        answer.setBean(bean);
        answer.setMethod(method);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean by type which is invoked which could be a final destination, or could
     * be a transformation in a pipeline
     */
    public Type bean(Class beanType) {
        BeanRef answer = new BeanRef();
        answer.setBeanType(beanType);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean type and method which is invoked which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type bean(Class beanType, String method) {
        BeanRef answer = new BeanRef();
        answer.setBeanType(beanType);
        answer.setMethod(method);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean which is invoked which could be a final destination, or could
     * be a transformation in a pipeline
     */
    public Type beanRef(String ref) {
        BeanRef answer = new BeanRef(ref);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a bean and method which is invoked which could be a final
     * destination, or could be a transformation in a pipeline
     */
    public Type beanRef(String ref, String method) {
        BeanRef answer = new BeanRef(ref, method);
        addOutput(answer);
        return (Type) this;
    }
    /**
     * Adds a processor which sets the body on the IN message
     */
    public Type setBody(Expression expression) {
        return process(ProcessorBuilder.setBody(expression));
    }
    /**
     * Adds a processor which sets the body on the OUT message
     */
    public Type setOutBody(Expression expression) {
        return process(ProcessorBuilder.setOutBody(expression));
    }
    /**
     * Adds a processor which sets the body on the FAULT message
     */
    public Type setFaultBody(Expression expression) {
        return process(ProcessorBuilder.setFaultBody(expression));
    }
    /**
     * Adds a processor which sets the header on the IN message
     */
    public Type setHeader(String name, Expression expression) {
        return process(ProcessorBuilder.setHeader(name, expression));
    }
    /**
     * Adds a processor which sets the header on the OUT message
     */
    public Type setOutHeader(String name, Expression expression) {
        return process(ProcessorBuilder.setOutHeader(name, expression));
    }
    /**
     * Adds a processor which sets the header on the FAULT message
     */
    public Type setFaultHeader(String name, Expression expression) {
        return process(ProcessorBuilder.setFaultHeader(name, expression));
    }
    /**
     * Adds a processor which sets the exchange property
     */
    public Type setProperty(String name, Expression expression) {
        return process(ProcessorBuilder.setProperty(name, expression));
    }
    /**
     * Adds a processor which removes the header on the IN message
     */
    public Type removeHeader(String name) {
        return process(ProcessorBuilder.removeHeader(name));
    }
    /**
     * Adds a processor which removes the header on the OUT message
     */
    public Type removeOutHeader(String name) {
        return process(ProcessorBuilder.removeOutHeader(name));
    }
    /**
     * Adds a processor which removes the header on the FAULT message
     */
    public Type removeFaultHeader(String name) {
        return process(ProcessorBuilder.removeFaultHeader(name));
    }
    /**
     * Adds a processor which removes the exchange property
     */
    public Type removeProperty(String name) {
        return process(ProcessorBuilder.removeProperty(name));
    }
    /**
     * Converts the IN message body to the specified type
     */
    public Type convertBodyTo(Class type) {
        return process(ProcessorBuilder.setBody(Builder.body().convertTo(type)));
    }
    /**
     * Converts the OUT message body to the specified type
     */
    public Type convertOutBodyTo(Class type) {
        return process(ProcessorBuilder.setOutBody(Builder.outBody().convertTo(type)));
    }
    /**
     * Converts the FAULT message body to the specified type
     */
    public Type convertFaultBodyTo(Class type) {
        return process(ProcessorBuilder.setFaultBody(Builder.faultBody().convertTo(type)));
    }
    // DataFormat support
    // -------------------------------------------------------------------------
    /**
     * Unmarshals the in body using a {@link DataFormat} expression to define
     * the format of the input message and the output will be set on the out message body.
     *
     * @return the expression to create the {@link DataFormat}
     */
    public DataTypeExpression<Type> unmarshal() {
        return new DataTypeExpression<Type>(this, DataTypeExpression.Operation.Unmarshal);
    }
    /**
     * Unmarshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type unmarshal(DataFormatType dataFormatType) {
        addOutput(new UnmarshalType(dataFormatType));
        return (Type) this;
    }
    /**
     * Unmarshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type unmarshal(DataFormat dataFormat) {
        return unmarshal(new DataFormatType(dataFormat));
    }
    /**
     * Unmarshals the in body using the specified {@link DataFormat}
     * reference in the {@link Registry} and sets the output on the out message body.
     *
     * @return this object
     */
    public Type unmarshal(String dataTypeRef) {
        addOutput(new UnmarshalType(dataTypeRef));
        return (Type) this;
    }
    /**
     * Marshals the in body using a {@link DataFormat} expression to define
     * the format of the output which will be added to the out body.
     *
     * @return the expression to create the {@link DataFormat}
     */
    public DataTypeExpression<Type> marshal() {
        return new DataTypeExpression<Type>(this, DataTypeExpression.Operation.Marshal);
    }
    /**
     * Marshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type marshal(DataFormatType dataFormatType) {
        addOutput(new MarshalType(dataFormatType));
        return (Type) this;
    }
    /**
     * Marshals the in body using the specified {@link DataFormat}
     * and sets the output on the out message body.
     *
     * @return this object
     */
    public Type marshal(DataFormat dataFormat) {
        return marshal(new DataFormatType(dataFormat));
    }
    /**
     * Marshals the in body the specified {@link DataFormat}
     * reference in the {@link Registry} and sets the output on the out message body.
     *
     * @return this object
     */
    public Type marshal(String dataTypeRef) {
        addOutput(new MarshalType(dataTypeRef));
        return (Type) this;
    }
    // Properties
    // -------------------------------------------------------------------------
    @XmlTransient
    public ErrorHandlerBuilder getErrorHandlerBuilder() {
        if (errorHandlerBuilder == null) {
            errorHandlerBuilder = createErrorHandlerBuilder();
        }
        return errorHandlerBuilder;
    }
    /**
     * Sets the error handler to use with processors created by this builder
     */
    public void setErrorHandlerBuilder(ErrorHandlerBuilder errorHandlerBuilder) {
        this.errorHandlerBuilder = errorHandlerBuilder;
    }
    @XmlTransient
    public boolean isInheritErrorHandler() {
        return ObjectConverter.toBoolean(getInheritErrorHandlerFlag());
    }
    @XmlAttribute(name = ""inheritErrorHandler"", required = false)
    public Boolean getInheritErrorHandlerFlag() {
        return inheritErrorHandlerFlag;
    }
    public void setInheritErrorHandlerFlag(Boolean inheritErrorHandlerFlag) {
        this.inheritErrorHandlerFlag = inheritErrorHandlerFlag;
    }
    @XmlTransient
    public NodeFactory getNodeFactory() {
        if (nodeFactory == null) {
            nodeFactory = new NodeFactory();
        }
        return nodeFactory;
    }
    public void setNodeFactory(NodeFactory nodeFactory) {
        this.nodeFactory = nodeFactory;
    }
    /**
     * Returns a label to describe this node such as the expression if some kind of expression node
     *
     * @return
     */
    public String getLabel() {
        return """";
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Creates the processor and wraps it in any necessary interceptors and
     * error handlers
     */
    protected Processor makeProcessor(RouteContext routeContext) throws Exception {
        Processor processor = createProcessor(routeContext);
        return wrapProcessor(routeContext, processor);
    }
    /**
     * A strategy method which allows derived classes to wrap the child
     * processor in some kind of interceptor
     * 
     * @param routeContext
     * @param target the processor which can be wrapped
     * @return the original processor or a new wrapped interceptor
     */
    protected Processor wrapProcessorInInterceptors(RouteContext routeContext, Processor target) throws Exception {
        // The target is required.
        if (target == null) {
            throw new RuntimeCamelException(""target provided."");
        }
        // Interceptors are optional
        DelegateProcessor first = null;
        DelegateProcessor last = null;
        List<InterceptorType> interceptors = new ArrayList<InterceptorType>(routeContext.getRoute()
            .getInterceptors());
        List<InterceptorType> list = getInterceptors();
        for (InterceptorType interceptorType : list) {
            if (!interceptors.contains(interceptorType)) {
                interceptors.add(interceptorType);
            }
        }
        for (InterceptorType interceptorRef : interceptors) {
            DelegateProcessor p = interceptorRef.createInterceptor(routeContext);
            if (first == null) {
                first = p;
            }
            if (last != null) {
                last.setProcessor(p);
            }
            last = p;
        }
        if (last != null) {
            last.setProcessor(target);
        }
        return first == null ? target : first;
    }
    /**
     * A strategy method to allow newly created processors to be wrapped in an
     * error handler.
     */
    protected Processor wrapInErrorHandler(Processor processor) throws Exception {
        return getErrorHandlerBuilder().createErrorHandler(processor);
    }
    protected ErrorHandlerBuilder createErrorHandlerBuilder() {
        if (isInheritErrorHandler()) {
            return new DeadLetterChannelBuilder();
        } else {
            return new NoErrorHandlerBuilder();
        }
    }
    protected void configureChild(ProcessorType output) {
        output.setNodeFactory(getNodeFactory());
    }
    protected void addOutput(ProcessorType processorType) {
        configureChild(processorType);
        getOutputs().add(processorType);
    }
    /**
     * Creates a new instance of some kind of composite processor which defaults
     * to using a {@link Pipeline} but derived classes could change the
     * behaviour
     */
    protected Processor createCompositeProcessor(List<Processor> list) {
        // return new MulticastProcessor(list);
        return new Pipeline(list);
    }
    protected Processor createOutputsProcessor(RouteContext routeContext, Collection<ProcessorType<?>> outputs)
        throws Exception {
        List<Processor> list = new ArrayList<Processor>();
        for (ProcessorType output : outputs) {
            Processor processor = output.createProcessor(routeContext);
            list.add(processor);
        }
        Processor processor = null;
        if (!list.isEmpty()) {
            if (list.size() == 1) {
                processor = list.get(0);
            } else {
                processor = createCompositeProcessor(list);
            }
        }
        return processor;
    }
    /**
     * Causes subsequent processors to be called asynchronously 
     * 
     * @param coreSize the number of threads that will be used to process
     *          messages in subsequent processors.
     * @return a ThreadType builder that can be used to futher configure the
     *         the thread pool.
     */
    public ThreadType thread(int coreSize) {
        ThreadType answer = new ThreadType(coreSize);
        addOutput(answer);
        return answer;
    }
    /**
     * Causes subsequent processors to be called asynchronously 
     * 
     * @param executor the executor that will be used to process
     *          messages in subsequent processors.
     * @return a ThreadType builder that can be used to further configure the
     *         the thread pool.
     */
    public ProcessorType<Type> thread(ThreadPoolExecutor executor) {
        ThreadType answer = new ThreadType(executor);
        addOutput(answer);
        return this;
    }
}
"
org.apache.camel.model.RecipientListType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.RecipientList;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""recipientList"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RecipientListType extends ExpressionNode {
    public RecipientListType() {
    }
    public RecipientListType(ExpressionType expression) {
        super(expression);
    }
    public RecipientListType(Expression expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""RecipientList[ "" + getExpression() + ""]"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return new RecipientList(getExpression().createExpression(routeContext));
    }
}
"
org.apache.camel.model.RedeliveryPolicyType,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.processor.RedeliveryPolicy;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""redeliveryPolicy"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RedeliveryPolicyType {
    private Integer maximumRedeliveries;
    private Long initialRedeliveryDelay;
    private Double backOffMultiplier;
    private Boolean useExponentialBackOff;
    private Double collisionAvoidanceFactor;
    private Boolean useCollisionAvoidance;
    public RedeliveryPolicy createRedeliveryPolicy(RedeliveryPolicy parentPolicy) {
        RedeliveryPolicy answer =  parentPolicy.copy();
        // copy across the properties - if they are set
        if (maximumRedeliveries != null) {
            answer.setMaximumRedeliveries(maximumRedeliveries);
        }
        if (initialRedeliveryDelay != null) {
            answer.setInitialRedeliveryDelay(initialRedeliveryDelay);
        }
        if (backOffMultiplier != null) {
            answer.setBackOffMultiplier(backOffMultiplier);
        }
        if (useExponentialBackOff != null) {
            answer.setUseExponentialBackOff(useExponentialBackOff);
        }
        if (collisionAvoidanceFactor != null) {
            answer.setCollisionAvoidanceFactor(collisionAvoidanceFactor);
        }
        if (useCollisionAvoidance != null) {
            answer.setUseCollisionAvoidance(useCollisionAvoidance);
        }
        return answer;
    }
    public String toString() {
        return ""RedeliveryPolicy[maxRedeliveries: "" + maximumRedeliveries + ""]"";
    }
    // Fluent API
    //-------------------------------------------------------------------------
    public RedeliveryPolicyType backOffMultiplier(double backOffMultiplier) {
        setBackOffMultiplier(backOffMultiplier);
        return this;
    }
    public RedeliveryPolicyType collisionAvoidancePercent(double collisionAvoidancePercent) {
        setCollisionAvoidanceFactor(collisionAvoidancePercent * 0.01d);
        return this;
    }
    public RedeliveryPolicyType collisionAvoidanceFactor(double collisionAvoidanceFactor) {
        setCollisionAvoidanceFactor(collisionAvoidanceFactor);
        return this;
    }
    public RedeliveryPolicyType initialRedeliveryDelay(long initialRedeliveryDelay) {
        setInitialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    public RedeliveryPolicyType maximumRedeliveries(int maximumRedeliveries) {
        setMaximumRedeliveries(maximumRedeliveries);
        return this;
    }
    public RedeliveryPolicyType useCollisionAvoidance() {
        setUseCollisionAvoidance(true);
        return this;
    }
    public RedeliveryPolicyType useExponentialBackOff() {
        setUseExponentialBackOff(true);
        return this;
    }
    // Properties
    //-------------------------------------------------------------------------
    public Double getBackOffMultiplier() {
        return backOffMultiplier;
    }
    public void setBackOffMultiplier(Double backOffMultiplier) {
        this.backOffMultiplier = backOffMultiplier;
    }
    public Double getCollisionAvoidanceFactor() {
        return collisionAvoidanceFactor;
    }
    public void setCollisionAvoidanceFactor(Double collisionAvoidanceFactor) {
        this.collisionAvoidanceFactor = collisionAvoidanceFactor;
    }
    public Long getInitialRedeliveryDelay() {
        return initialRedeliveryDelay;
    }
    public void setInitialRedeliveryDelay(Long initialRedeliveryDelay) {
        this.initialRedeliveryDelay = initialRedeliveryDelay;
    }
    public Integer getMaximumRedeliveries() {
        return maximumRedeliveries;
    }
    public void setMaximumRedeliveries(Integer maximumRedeliveries) {
        this.maximumRedeliveries = maximumRedeliveries;
    }
    public Boolean getUseCollisionAvoidance() {
        return useCollisionAvoidance;
    }
    public void setUseCollisionAvoidance(Boolean useCollisionAvoidance) {
        this.useCollisionAvoidance = useCollisionAvoidance;
    }
    public Boolean getUseExponentialBackOff() {
        return useExponentialBackOff;
    }
    public void setUseExponentialBackOff(Boolean useExponentialBackOff) {
        this.useExponentialBackOff = useExponentialBackOff;
    }
}
"
org.apache.camel.model.ResequencerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.model.config.BatchResequencerConfig;
import org.apache.camel.model.config.StreamResequencerConfig;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Resequencer;
import org.apache.camel.processor.StreamResequencer;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""resequencer"")
public class ResequencerType extends ProcessorType<ProcessorType> {
    @XmlElementRef
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    @XmlElementRef
    private List<ExpressionType> expressions = new ArrayList<ExpressionType>();
    @XmlElementRef
    private List<ProcessorType<?>> outputs = new ArrayList<ProcessorType<?>>();
    // Binding annotation at setter 
    private BatchResequencerConfig batchConfig;
    // Binding annotation at setter 
    private StreamResequencerConfig streamConfig;
    @XmlTransient
    private List<Expression> expressionList;
    public ResequencerType() {
        this(null);
    }
    public ResequencerType(List<Expression> expressions) {
        this.expressionList = expressions;
        this.batch();
    }
    /**
     * Configures the stream-based resequencing algorithm using the default
     * configuration.
     * 
     * @return <code>this</code> instance.
     */
    public ResequencerType stream() {
        return stream(StreamResequencerConfig.getDefault());
    }
    /**
     * Configures the batch-based resequencing algorithm using the default
     * configuration.
     * 
     * @return <code>this</code> instance.
     */
    public ResequencerType batch() {
        return batch(BatchResequencerConfig.getDefault());
    }
    /**
     * Configures the stream-based resequencing algorithm using the given
     * {@link StreamResequencerConfig}.
     * 
     * @return <code>this</code> instance.
     */
    public ResequencerType stream(StreamResequencerConfig config) {
        this.streamConfig = config;
        this.batchConfig = null;
        return this;
    }
    /**
     * Configures the batch-based resequencing algorithm using the given
     * {@link BatchResequencerConfig}.
     * 
     * @return <code>this</code> instance.
     */
    public ResequencerType batch(BatchResequencerConfig config) {
        this.batchConfig = config;
        this.streamConfig = null;
        return this;
    }
    @Override
    public String toString() {
        return ""Resequencer[ "" + getExpressions() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getLabel() {
        return ExpressionType.getLabel(getExpressions());
    }
    public List<ExpressionType> getExpressions() {
        return expressions;
    }
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    public List<ProcessorType<?>> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        this.outputs = outputs;
    }
    public BatchResequencerConfig getBatchConfig() {
        return batchConfig;
    }
    public BatchResequencerConfig getBatchConfig(BatchResequencerConfig defaultConfig) {
        return batchConfig;
    }
    public StreamResequencerConfig getStreamConfig() {
        return streamConfig;
    }
    //
    // TODO: find out how to have these two within an <xsd:choice>
    //
    @XmlElement(name=""batch-config"", required=false)
    public void setBatchConfig(BatchResequencerConfig batchConfig) {
        batch(batchConfig);
    }
    @XmlElement(name=""stream-config"", required=false)
    public void setStreamConfig(StreamResequencerConfig streamConfig) {
        stream(streamConfig);
    }
    //
    // END_TODO
    //
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        return createStreamResequencer(routeContext, streamConfig);
    }
    @Override
    public void addRoutes(RouteContext routeContext, Collection<Route> routes) throws Exception {
        if (batchConfig != null) {
            routes.add(createBatchResequencerRoute(routeContext));
        } else {
            // StreamResequencer created via createProcessor method
            super.addRoutes(routeContext, routes);
        }
    }
    private Route<Exchange> createBatchResequencerRoute(RouteContext routeContext) throws Exception {
        final Resequencer resequencer = createBatchResequencer(routeContext, batchConfig);
        return new Route<Exchange>(routeContext.getEndpoint(), resequencer) {
            @Override
            public String toString() {
                return ""BatchResequencerRoute["" + getEndpoint() + "" -> "" + resequencer.getProcessor() + ""]"";
            }
        };
    }
    protected Resequencer createBatchResequencer(RouteContext routeContext, 
            BatchResequencerConfig config) throws Exception {
        Processor processor = routeContext.createProcessor(this);
        Resequencer resequencer = new Resequencer(routeContext.getEndpoint(), 
                processor, resolveExpressionList(routeContext));
        resequencer.setBatchSize(config.getBatchSize());
        resequencer.setBatchTimeout(config.getBatchTimeout());
        return resequencer;
    }
    protected StreamResequencer createStreamResequencer(RouteContext routeContext, 
            StreamResequencerConfig config) throws Exception {
        config.getComparator().setExpressions(resolveExpressionList(routeContext));
        Processor processor = routeContext.createProcessor(this);
        StreamResequencer resequencer = new StreamResequencer(processor, 
                config.getComparator(), config.getCapacity());
        resequencer.setTimeout(config.getTimeout());
        return resequencer;
    }
    private List<Expression> resolveExpressionList(RouteContext routeContext) {
        if (expressionList == null) {
            expressionList = new ArrayList<Expression>();
            for (ExpressionType expression : expressions) {
                expressionList.add(expression.createExpression(routeContext));
            }
        }
        if (expressionList.isEmpty()) {
            throw new IllegalArgumentException(""No expressions configured for: "" + this);
        }
        return expressionList;
    }
}
"
org.apache.camel.model.RouteContainer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.List;
import javax.xml.bind.annotation.XmlElementRef;
/**
 * @version $Revision: 1.1 $
 */
public interface RouteContainer {
    /**
     * A list of routes
     *
     * @return
     */
    @XmlElementRef
    List<RouteType> getRoutes();
    /**
     * Sets the routes to use
     *
     * @param routes
     */
    void setRoutes(List<RouteType> routes);
}
"
org.apache.camel.model.RoutesType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Route;
import org.apache.camel.Predicate;
import org.apache.camel.processor.DelegateProcessor;
/**
 * Represents a collection of routes
 *
 * @version $Revision: $
 */
@XmlRootElement(name = ""routes"")
@XmlAccessorType(XmlAccessType.FIELD)
public class RoutesType implements RouteContainer {
    // TODO: not sure how else to use an optional attribute in JAXB2
    @XmlAttribute
    private Boolean inheritErrorHandlerFlag = Boolean.TRUE; 
    @XmlElementRef
    private List<RouteType> routes = new ArrayList<RouteType>();
    @XmlElementRef
    private List<ServiceActivationType> activations = new ArrayList<ServiceActivationType>();
    @XmlTransient
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    @XmlTransient
    private List<InterceptType> intercepts = new ArrayList<InterceptType>();
    @XmlTransient
    private List<ExceptionType> exceptions = new ArrayList<ExceptionType>();
    @XmlTransient
    private CamelContext camelContext;
    @Override
    public String toString() {
        return ""Routes: "" + routes;
    }
    public void populateRoutes(List<Route> answer) throws Exception {
        for (RouteType route : routes) {
            route.addRoutes(camelContext, answer);
        }
    }
    // Properties
    //-----------------------------------------------------------------------
    public List<RouteType> getRoutes() {
        return routes;
    }
    public void setRoutes(List<RouteType> routes) {
        this.routes = routes;
    }
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    public List<InterceptType> getIntercepts() {
        return intercepts;
    }
    public void setIntercepts(List<InterceptType> intercepts) {
        this.intercepts = intercepts;
    }
    public List<ExceptionType> getExceptions() {
        return exceptions;
    }
    public void setExceptions(List<ExceptionType> exceptions) {
        this.exceptions = exceptions;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public Boolean getInheritErrorHandlerFlag() {
        return inheritErrorHandlerFlag;
    }
    public void setInheritErrorHandlerFlag(Boolean inheritErrorHandlerFlag) {
        this.inheritErrorHandlerFlag = inheritErrorHandlerFlag;
    }
    // Fluent API
    //-------------------------------------------------------------------------
    /**
     * Creates a new route
     */
    public RouteType route() {
        RouteType route = createRoute();
        return route(route);
    }
    /**
     * Creates a new route from the given URI input
     */
    public RouteType from(String uri) {
        RouteType route = createRoute();
        route.from(uri);
        return route(route);
    }
    /**
     * Creates a new route from the given endpoint
     */
    public RouteType from(Endpoint endpoint) {
        RouteType route = createRoute();
        route.from(endpoint);
        return route(route);
    }
    public RouteType route(RouteType route) {
        // lets configure the route
        route.setCamelContext(getCamelContext());
        route.setInheritErrorHandlerFlag(getInheritErrorHandlerFlag());
        route.getInterceptors().addAll(getInterceptors());
        route.getOutputs().addAll(getIntercepts());
        route.getOutputs().addAll(getExceptions());
        getRoutes().add(route);
        return route;
    }
    public RoutesType intercept(DelegateProcessor interceptor) {
        getInterceptors().add(new InterceptorRef(interceptor));
        return this;
    }
    public InterceptType intercept() {
        InterceptType answer = new InterceptType();
        getIntercepts().add(answer);
        return answer;
    }
    public OtherwiseType intercept(Predicate predicate) {
        InterceptType answer = new InterceptType();
        getIntercepts().add(answer);
        return answer.when(predicate);
    }
    public ExceptionType exception(Class exceptionType) {
        ExceptionType answer = new ExceptionType(exceptionType);
        getExceptions().add(answer);
        return answer;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected RouteType createRoute() {
        return new RouteType();
    }
}
"
org.apache.camel.model.RouteType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.*;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.util.CamelContextHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.xml.bind.annotation.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
/**
 * Represents an XML &lt;route/&gt; element
 * 
 * @version $Revision: $
 */
@XmlRootElement(name = ""route"")
@XmlType(propOrder = {""interceptors"", ""inputs"", ""outputs"" })
@XmlAccessorType(XmlAccessType.FIELD)
public class RouteType extends ProcessorType implements CamelContextAware {
    private static final transient Log LOG = LogFactory.getLog(RouteType.class);
    @XmlElementRef
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    @XmlElementRef
    private List<FromType> inputs = new ArrayList<FromType>();
    @XmlElementRef
    private List<ProcessorType> outputs = new ArrayList<ProcessorType>();
    @XmlAttribute
    private String group;
    @XmlTransient
    private CamelContext camelContext;
    public RouteType() {
    }
    public RouteType(String uri) {
        from(uri);
    }
    public RouteType(Endpoint endpoint) {
        from(endpoint);
    }
    @Override
    public String toString() {
        return ""Route[ "" + inputs + "" -> "" + outputs + ""]"";
    }
    // TODO should we zap this and replace with next method?
    public void addRoutes(CamelContext context) throws Exception {
        Collection<Route> routes = new ArrayList<Route>();
        addRoutes(context, routes);
        context.addRoutes(routes);
    }
    public void addRoutes(CamelContext context, Collection<Route> routes) throws Exception {
        setCamelContext(context);
        for (FromType fromType : inputs) {
            addRoutes(routes, fromType);
        }
    }
    public Endpoint resolveEndpoint(String uri) throws NoSuchEndpointException {
        CamelContext context = getCamelContext();
        if (context == null) {
            throw new IllegalArgumentException(""No CamelContext has been injected!"");
        }
        return CamelContextHelper.getMandatoryEndpoint(context, uri);
    }
    // Fluent API
    // -----------------------------------------------------------------------
    /**
     * Creates an input to the route
     */
    public RouteType from(String uri) {
        getInputs().add(new FromType(uri));
        return this;
    }
    /**
     * Creates an input to the route
     */
    public RouteType from(Endpoint endpoint) {
        getInputs().add(new FromType(endpoint));
        return this;
    }
    /**
     * Set the group name for this route
     */
    public RouteType group(String name) {
        setGroup(name);
        return this;
    }
    // Properties
    // -----------------------------------------------------------------------
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    public List<FromType> getInputs() {
        return inputs;
    }
    public void setInputs(List<FromType> inputs) {
        this.inputs = inputs;
    }
    public List<ProcessorType> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType> outputs) {
        this.outputs = outputs;
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                configureChild(output);
            }
        }
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    /**
     * The group that this route belongs to; could be the name of the RouteBuilder class
     * or be explicitly configured in the XML.
     *
     * May be null.
     */
    public String getGroup() {
        return group;
    }
    public void setGroup(String group) {
        this.group = group;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void addRoutes(Collection<Route> routes, FromType fromType) throws Exception {
        RouteContext routeContext = new RouteContext(this, fromType, routes);
        Endpoint endpoint = routeContext.getEndpoint();
        for (ProcessorType output : outputs) {
            output.addRoutes(routeContext, routes);
        }
        routeContext.commit();
    }
    @Override
    protected void configureChild(ProcessorType output) {
        super.configureChild(output);
        if (isInheritErrorHandler()) {
            output.setErrorHandlerBuilder(getErrorHandlerBuilder());
        }
        List<InterceptorType> list = output.getInterceptors();
        if (list == null) {
            LOG.warn(""No interceptor collection: "" + output);
        } else {
            list.addAll(getInterceptors());
        }
    }
}
"
org.apache.camel.model.ServiceActivationType,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.model.language.ExpressionType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import java.util.ArrayList;
import java.util.List;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""serviceActivation"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ServiceActivationType {
    @XmlAttribute
    private String group = ""default"";
    @XmlElementRef
    private List<ExpressionType> uris = new ArrayList<ExpressionType>();
    public String getGroup() {
        return group;
    }
    public void setGroup(String group) {
        this.group = group;
    }
    public List<ExpressionType> getUris() {
        return uris;
    }
    public void setUris(List<ExpressionType> uris) {
        this.uris = uris;
    }
}
"
org.apache.camel.model.SplitterType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.Splitter;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""splitter"")
@XmlAccessorType(XmlAccessType.FIELD)
public class SplitterType extends ExpressionNode {
    public SplitterType() {
    }
    public SplitterType(Expression expression) {
        super(expression);
    }
    public SplitterType(ExpressionType expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""Splitter[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new Splitter(getExpression().createExpression(routeContext), childProcessor);
    }
}
"
org.apache.camel.model.ThreadType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.processor.Pipeline;
import org.apache.camel.processor.ThreadProcessor;
/**
 * Represents an XML &lt;thread/&gt; element
 * @version $Revision: 576920 $
 */
@XmlRootElement(name = ""thread"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ThreadType extends ProcessorType {
    @XmlAttribute
    private int coreSize = 1;
    @XmlAttribute
    private boolean daemon = true;
    @XmlAttribute
    private long keepAliveTime;
    @XmlAttribute
    private int maxSize = 1;
    @XmlAttribute
    private String name = ""Thread Processor"";
    @XmlAttribute
    private int priority = Thread.NORM_PRIORITY;
    @XmlAttribute
    private long stackSize;
    @XmlElementRef
    private List<ProcessorType> outputs = new ArrayList<ProcessorType>();
    @XmlTransient
    private BlockingQueue<Runnable> taskQueue;
    @XmlTransient
    private ThreadGroup threadGroup;
    @XmlTransient
    private ThreadPoolExecutor executor;
    public ThreadType() {
    }
    public ThreadType(int coreSize) {
        this.coreSize = coreSize;
        this.maxSize = coreSize;
    }
    public ThreadType(ThreadPoolExecutor executor) {
        this.executor = executor;
    }
    @Override
    public List getInterceptors() {
        return Collections.EMPTY_LIST;
    }
    @Override
    public List getOutputs() {
        return outputs;
    }
    @Override
    public String toString() {
        return ""Thread["" + getLabel() + ""]"";
    }
    @Override
    public String getLabel() {
        return ""coreSize=""+coreSize;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        ThreadProcessor thread = new ThreadProcessor();
        thread.setExecutor(executor);
        thread.setCoreSize(coreSize);
        thread.setDaemon(daemon);
        thread.setKeepAliveTime(keepAliveTime);
        thread.setMaxSize(maxSize);
        thread.setName(name);
        thread.setPriority(priority);
        thread.setStackSize(stackSize);
        thread.setTaskQueue(taskQueue);
        thread.setThreadGroup(threadGroup);
        // TODO: see if we can avoid creating so many nested pipelines 
        ArrayList<Processor> pipe = new ArrayList<Processor>(2);
        pipe.add(thread);
        pipe.add(createOutputsProcessor(routeContext, outputs));
        return new Pipeline(pipe);
    }
    ///////////////////////////////////////////////////////////////////
    //
    // Fluent Methods
    //
    ///////////////////////////////////////////////////////////////////
    public ThreadType coreSize(int coreSize) {
        setCoreSize(coreSize);
        return this;
    }
    public ThreadType daemon(boolean daemon) {
        setDaemon(daemon);
        return this;
    }
    public ThreadType keepAliveTime(long keepAliveTime) {
        setKeepAliveTime(keepAliveTime);
        return this;
    }
    public ThreadType maxSize(int maxSize) {
        setMaxSize(maxSize);
        return this;
    }
    public ThreadType name(String name) {
        setName(name);
        return this;
    }
    public ThreadType priority(int priority) {
        setPriority(priority);
        return this;
    }
    public ThreadType stackSize(long stackSize) {
        setStackSize(stackSize);
        return this;
    }
    public ThreadType taskQueue(BlockingQueue<Runnable> taskQueue) {
        setTaskQueue(taskQueue);
        return this;
    }
    public ThreadType threadGroup(ThreadGroup threadGroup) {
        setThreadGroup(threadGroup);
        return this;
    }
    public ThreadType executor(ThreadPoolExecutor executor) {
        setExecutor(executor);
        return this;
    }
    ///////////////////////////////////////////////////////////////////
    //
    // Property Accessors
    //
    ///////////////////////////////////////////////////////////////////
    public void setCoreSize(int coreSize) {
        this.coreSize = coreSize;
    }
    public void setDaemon(boolean daemon) {
        this.daemon = daemon;
    }
    public void setKeepAliveTime(long keepAliveTime) {
        this.keepAliveTime = keepAliveTime;
    }
    public void setMaxSize(int maxSize) {
        this.maxSize = maxSize;
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setPriority(int priority) {
        this.priority = priority;
    }
    public void setStackSize(long stackSize) {
        this.stackSize = stackSize;
    }
    public void setTaskQueue(BlockingQueue<Runnable> taskQueue) {
        this.taskQueue = taskQueue;
    }
    public void setThreadGroup(ThreadGroup threadGroup) {
        this.threadGroup = threadGroup;
    }
    public ThreadPoolExecutor getExecutor() {
        return executor;
    }
    public void setExecutor(ThreadPoolExecutor executor) {
        this.executor = executor;
    }
}
"
org.apache.camel.model.ThrottlerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.processor.Throttler;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""throttler"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ThrottlerType extends ProcessorType {
    @XmlAttribute
    private Long maximumRequestsPerPeriod;
    @XmlAttribute
    private long timePeriodMillis = 1000;
    @XmlElementRef
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    @XmlElementRef
    private List<ProcessorType> outputs = new ArrayList<ProcessorType>();
    public ThrottlerType() {
    }
    public ThrottlerType(long maximumRequestsPerPeriod) {
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
    }
    @Override
    public String toString() {
        return ""Throttler["" + getMaximumRequestsPerPeriod() + "" request per "" + getTimePeriodMillis()
               + "" millis -> "" + getOutputs() + ""]"";
    }
    @Override
    public String getLabel() {
        return """" + getMaximumRequestsPerPeriod() + "" per "" + getTimePeriodMillis() + "" (ms)"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor childProcessor = routeContext.createProcessor(this);
        return new Throttler(childProcessor, maximumRequestsPerPeriod, timePeriodMillis);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    /**
     * Sets the time period during which the maximum request count is valid for
     */
    public ThrottlerType timePeriodMillis(long timePeriodMillis) {
        this.timePeriodMillis = timePeriodMillis;
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public Long getMaximumRequestsPerPeriod() {
        return maximumRequestsPerPeriod;
    }
    public void setMaximumRequestsPerPeriod(Long maximumRequestsPerPeriod) {
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
    }
    public long getTimePeriodMillis() {
        return timePeriodMillis;
    }
    public void setTimePeriodMillis(long timePeriodMillis) {
        this.timePeriodMillis = timePeriodMillis;
    }
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    public List<ProcessorType> getOutputs() {
        return outputs;
    }
    public void setOutputs(List<ProcessorType> outputs) {
        this.outputs = outputs;
    }
}
"
org.apache.camel.model.ToType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlElementRef;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.processor.SendProcessor;
/**
 * Represents an XML &lt;to/&gt; element
 * 
 * @version $Revision: $
 */
@XmlRootElement(name = ""to"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ToType extends ProcessorType {
    @XmlAttribute
    private String uri;
    @XmlAttribute
    private String ref;
    @XmlElementRef
    private List<InterceptorType> interceptors = new ArrayList<InterceptorType>();
    @XmlTransient
    private Endpoint endpoint;
    public ToType() {
    }
    public ToType(String uri) {
        setUri(uri);
    }
    public ToType(Endpoint endpoint) {
        setEndpoint(endpoint);
    }
    @Override
    public String toString() {
        return ""To["" + getLabel() + ""]"";
    }
    @Override
    public String getLabel() {
        return FromType.description(getUri(), getRef(), getEndpoint());
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Endpoint endpoint = resolveEndpoint(routeContext);
        return new SendProcessor(endpoint);
    }
    public Endpoint resolveEndpoint(RouteContext context) {
        if (endpoint == null) {
            endpoint = context.resolveEndpoint(getUri(), getRef());
        }
        return endpoint;
    }
    // Properties
    // -----------------------------------------------------------------------
    public String getUri() {
        return uri;
    }
    /**
     * Sets the URI of the endpoint to use
     * 
     * @param uri the endpoint URI to use
     */
    public void setUri(String uri) {
        this.uri = uri;
    }
    public String getRef() {
        return ref;
    }
    /**
     * Sets the name of the endpoint within the registry (such as the Spring
     * ApplicationContext or JNDI) to use
     * 
     * @param ref the reference name to use
     */
    public void setRef(String ref) {
        this.ref = ref;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    public List<ProcessorType> getOutputs() {
        return Collections.EMPTY_LIST;
    }
    public List<InterceptorType> getInterceptors() {
        return interceptors;
    }
    public void setInterceptors(List<InterceptorType> interceptors) {
        this.interceptors = interceptors;
    }
    /**
     * Returns the endpoint URI or the name of the reference to it
     */
    public Object getUriOrRef() {
        if (ObjectHelper.isNullOrBlank(uri)) {
            return uri;
        }
        else if (endpoint != null) {
            return endpoint.getEndpointUri();
        }
        return ref;
    }
}
"
org.apache.camel.model.TryType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.processor.CatchProcessor;
import org.apache.camel.processor.TryProcessor;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""try"")
@XmlAccessorType(XmlAccessType.FIELD)
public class TryType extends OutputType<TryType> {
    @XmlTransient
    private List<CatchType> catchClauses;
    @XmlTransient
    private FinallyType finallyClause;
    @XmlTransient
    private boolean initialized;
    @XmlTransient
    private List<ProcessorType<?>> outputsWithoutCatches;
    @Override
    public String toString() {
        return ""Try[ "" + getOutputs() + ""]"";
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) throws Exception {
        Processor tryProcessor = createOutputsProcessor(routeContext, getOutputsWithoutCatches());
        Processor finallyProcessor = null;
        if (finallyClause != null) {
            finallyProcessor = finallyClause.createProcessor(routeContext);
        }
        List<CatchProcessor> catchProcessors = new ArrayList<CatchProcessor>();
        if (catchClauses != null) {
            for (CatchType catchClause : catchClauses) {
                catchProcessors.add(catchClause.createProcessor(routeContext));
            }
        }
        return new TryProcessor(tryProcessor, catchProcessors, finallyProcessor);
    }
    // Fluent API
    // -------------------------------------------------------------------------
    public CatchType handle(Class<?> exceptionType) {
        CatchType answer = new CatchType(exceptionType);
        addOutput(answer);
        return answer;
    }
    public FinallyType handleAll() {
        FinallyType answer = new FinallyType();
        addOutput(answer);
        return answer;
    }
    // Properties
    // -------------------------------------------------------------------------
    public List<CatchType> getCatchClauses() {
        if (catchClauses == null) {
            checkInitialized();
        }
        return catchClauses;
    }
    public FinallyType getFinallyClause() {
        if (finallyClause == null) {
            checkInitialized();
        }
        return finallyClause;
    }
    public List<ProcessorType<?>> getOutputsWithoutCatches() {
        if (outputsWithoutCatches == null) {
            checkInitialized();
        }
        return outputsWithoutCatches;
    }
    public void setOutputs(List<ProcessorType<?>> outputs) {
        initialized = false;
        super.setOutputs(outputs);
    }
    public void addOutput(ProcessorType output) {
        initialized = false;
        getOutputs().add(output);
    }
    /**
     * Checks whether or not this object has been initialized
     */
    protected void checkInitialized() {
        if (!initialized) {
            initialized = true;
            outputsWithoutCatches = new ArrayList<ProcessorType<?>>();
            catchClauses = new ArrayList<CatchType>();
            finallyClause = null;
            for (ProcessorType output : outputs) {
                if (output instanceof CatchType) {
                    catchClauses.add((CatchType)output);
                } else if (output instanceof FinallyType) {
                    if (finallyClause != null) {
                        throw new IllegalArgumentException(""Multiple finally clauses added: "" + finallyClause
                                                           + "" and "" + output);
                    } else {
                        finallyClause = (FinallyType)output;
                    }
                } else {
                    outputsWithoutCatches.add(output);
                }
            }
        }
    }
}
"
org.apache.camel.model.UnmarshalType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Processor;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.model.dataformat.DataFormatType;
import org.apache.camel.processor.UnmarshalProcessor;
import org.apache.camel.spi.DataFormat;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Unmarshals the binary payload using the given {@link DataFormatType}
 * 
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""unmarshal"")
@XmlAccessorType(XmlAccessType.FIELD)
public class UnmarshalType extends OutputType {
    @XmlAttribute(required = false)
    private String ref;
    @XmlElementRef
    private DataFormatType dataFormatType;
    public UnmarshalType() {
    }
    public UnmarshalType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    public UnmarshalType(String ref) {
        this.ref = ref;
    }
    @Override
    public String toString() {
        if (dataFormatType != null) {
            return ""Marshal["" + dataFormatType + ""]"";
        }
        else {
            return ""Marshal[ref:  "" + ref + ""]"";
        }
    }
    public String getRef() {
        return ref;
    }
    public void setRef(String ref) {
        this.ref = ref;
    }
    public DataFormatType getDataFormatType() {
        return dataFormatType;
    }
    public void setDataFormatType(DataFormatType dataFormatType) {
        this.dataFormatType = dataFormatType;
    }
    @Override
    public Processor createProcessor(RouteContext routeContext) {
        DataFormatType type = getDataFormatType();
        if (type == null) {
            notNull(ref, ""ref or dataFormatType"");
            type = routeContext.lookup(ref, DataFormatType.class);
        }
        DataFormat dataFormat = type.getDataFormat(routeContext);
        return new UnmarshalProcessor(dataFormat);
    }
}
"
org.apache.camel.model.WhenType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.Predicate;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.model.language.ExpressionType;
import org.apache.camel.processor.FilterProcessor;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""when"")
public class WhenType<Type extends ProcessorType> extends ExpressionNode {
    public WhenType() {
    }
    public WhenType(Predicate predicate) {
        super(predicate);
    }
    public WhenType(ExpressionType expression) {
        super(expression);
    }
    @Override
    public String toString() {
        return ""When[ "" + getExpression() + "" -> "" + getOutputs() + ""]"";
    }
    @Override
    public FilterProcessor createProcessor(RouteContext routeContext) throws Exception {
        return createFilterProcessor(routeContext);
    }
}
"
org.apache.camel.model.XmlParseTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import org.apache.camel.model.language.ExpressionType;
import javax.xml.bind.JAXBException;
import java.util.List;
/**
 * @version $Revision: 1.1 $
 */
public class XmlParseTest extends XmlTestSupport {
    public void testParseSimpleRouteXml() throws Exception {
        RouteType route = assertOneRoute(""simpleRoute.xml"");
        assertFrom(route, ""seda:a"");
        assertChildTo(""to"", route, ""seda:b"");
    }
    public void testParseProcessorXml() throws Exception {
        RouteType route = assertOneRoute(""processor.xml"");
        assertFrom(route, ""seda:a"");
        assertProcessor(route, ""myProcessor"");
    }
    public void testParseProcessorWithFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertFilter(route);
        assertExpression(filter.getExpression(), ""juel"", ""in.header.foo == 'bar'"");
    }
    public void testParseProcessorWithHeaderFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithHeaderFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertFilter(route);
        assertExpression(filter.getExpression(), ""header"", ""foo"");
    }
    public void testParseProcessorWithElFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithElFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertFilter(route);
        assertExpression(filter.getExpression(), ""el"", ""$in.header.foo == 'bar'"");
    }
    public void testParseProcessorWithGroovyFilterXml() throws Exception {
        RouteType route = assertOneRoute(""processorWithGroovyFilter.xml"");
        assertFrom(route, ""seda:a"");
        FilterType filter = assertFilter(route);
        assertExpression(filter.getExpression(), ""groovy"", ""in.headers.any { h -> h.startsWith('foo')}"");
    }
    public void testParseRecipientListXml() throws Exception {
        RouteType route = assertOneRoute(""dynamicRecipientList.xml"");
        assertFrom(route, ""seda:a"");
        RecipientListType node = assertRecipientList(route);
        assertExpression(node.getExpression(), ""header"", ""foo"");
    }
    public void testParseStaticRecipientListXml() throws Exception {
        RouteType route = assertOneRoute(""staticRecipientList.xml"");
        assertFrom(route, ""seda:a"");
        assertChildTo(route, ""seda:b"", ""seda:c"", ""seda:d"");
    }
    public void testParseRouteWithInterceptorXml() throws Exception {
        RouteType route = assertOneRoute(""routeWithInterceptor.xml"");
        assertFrom(route, ""seda:a"");
        assertChildTo(""to"", route, ""seda:d"");
        assertInterceptorRefs(route, ""interceptor1"", ""interceptor2"");
    }
    public void testParseRouteWithChoiceXml() throws Exception {
        RouteType route = assertOneRoute(""routeWithChoice.xml"");
        assertFrom(route, ""seda:a"");
        ChoiceType choice = assertChoice(route);
        List<WhenType> whens = assertListSize(choice.getWhenClauses(), 2);
        assertChildTo(""when(0)"", whens.get(0), ""seda:b"");
        assertChildTo(""when(1)"", whens.get(1), ""seda:c"");
        OtherwiseType otherwise = choice.getOtherwise();
        assertNotNull(""Otherwise is null"", otherwise);
        assertChildTo(""otherwise"", otherwise, ""seda:d"");
    }
    public void testParseSplitterXml() throws Exception {
        RouteType route = assertOneRoute(""splitter.xml"");
        assertFrom(route, ""seda:a"");
        SplitterType splitter = assertSplitter(route);
        assertExpression(splitter.getExpression(), ""xpath"", ""/foo/bar"");
        assertChildTo(""to"", splitter, ""seda:b"");
    }
    public void testParseBatchResequencerXml() throws Exception {
        RouteType route = assertOneRoute(""resequencerBatch.xml"");
        ResequencerType resequencer = assertResequencer(route);
        assertNull(resequencer.getStreamConfig());
        assertNotNull(resequencer.getBatchConfig());
        assertEquals(500, resequencer.getBatchConfig().getBatchSize());
        assertEquals(2000L, resequencer.getBatchConfig().getBatchTimeout());
    }
    public void testParseStreamResequencerXml() throws Exception {
        RouteType route = assertOneRoute(""resequencerStream.xml"");
        ResequencerType resequencer = assertResequencer(route);
        assertNotNull(resequencer.getStreamConfig());
        assertNull(resequencer.getBatchConfig());
        assertEquals(100, resequencer.getStreamConfig().getCapacity());
        assertEquals(2000L, resequencer.getStreamConfig().getTimeout());
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected RouteType assertOneRoute(String uri) throws JAXBException {
        RouteContainer context = assertParseAsJaxb(uri);
        RouteType route = assertOneElement(context.getRoutes());
        return route;
    }
    protected void assertFrom(RouteType route, String uri) {
        FromType from = assertOneElement(route.getInputs());
        assertEquals(""From URI"", uri, from.getUri());
    }
    protected void assertChildTo(String message, ProcessorType<?> route, String uri) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        ToType value = assertIsInstanceOf(ToType.class, processor);
        String text = message + ""To URI"";
        log.info(""Testing: "" + text + "" is equal to: "" + uri + "" for processor: "" + processor);
        assertEquals(text, uri, value.getUri());
    }
    protected void assertTo(String message, ProcessorType processor, String uri) {
        ToType value = assertIsInstanceOf(ToType.class, processor);
        String text = message + ""To URI"";
        log.info(""Testing: "" + text + "" is equal to: "" + uri + "" for processor: "" + processor);
        assertEquals(text, uri, value.getUri());
    }
    protected void assertChildTo(ProcessorType route, String... uris) {
        List<ProcessorType<?>> list = assertListSize(route.getOutputs(), uris.length);
        int idx = 0;
        for (String uri : uris) {
            assertTo(""output["" + idx + ""] "", list.get(idx++), uri);
        }
    }
    protected void assertProcessor(ProcessorType<?> route, String processorRef) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        ProcessorRef to = assertIsInstanceOf(ProcessorRef.class, processor);
        assertEquals(""Processor ref"", processorRef, to.getRef());
    }
    protected FilterType assertFilter(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(FilterType.class, processor);
    }
    protected RecipientListType assertRecipientList(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(RecipientListType.class, processor);
    }
    protected ChoiceType assertChoice(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(ChoiceType.class, processor);
    }
    protected SplitterType assertSplitter(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(SplitterType.class, processor);
    }
    protected ResequencerType assertResequencer(ProcessorType<?> route) {
        ProcessorType<?> processor = assertOneElement(route.getOutputs());
        return assertIsInstanceOf(ResequencerType.class, processor);
    }
    protected void assertExpression(ExpressionType expression, String language, String languageExpression) {
        assertNotNull(""Expression should not be null!"", expression);
        assertEquals(""Expression language"", language, expression.getLanguage());
        assertEquals(""Expression"", languageExpression, expression.getExpression());
    }
    protected void assertInterceptorRefs(ProcessorType route, String... names) {
        int idx = 0;
        List<InterceptorType> interceptors = route.getInterceptors();
        for (String name : names) {
            int nextIdx = idx + 1;
            assertTrue(""Not enough interceptors! Expected: "" + nextIdx + "" but have: "" + interceptors,
                    nextIdx <= interceptors.size());
            InterceptorRef interceptor = assertIsInstanceOf(InterceptorRef.class, interceptors.get(idx++));
            assertEquals(""Interceptor: "" + idx, name, interceptor.getRef());
        }
    }
}
"
org.apache.camel.model.XmlTestSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model;
import java.net.URL;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import org.apache.camel.TestSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 1.1 $
 */
public class XmlTestSupport extends TestSupport {
    protected final transient Log log = LogFactory.getLog(getClass());
    protected JAXBContext jaxbContext;
    protected RouteContainer assertParseAsJaxb(String uri) throws JAXBException {
        Object value = parseUri(uri);
        RouteContainer context = assertIsInstanceOf(RouteContainer.class, value);
        log.info(""Found: "" + context);
        return context;
    }
    protected Object parseUri(String uri) throws JAXBException {
        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
        URL resource = getClass().getResource(uri);
        assertNotNull(""Cannot find resource on the classpath: "" + uri, resource);
        Object value = unmarshaller.unmarshal(resource);
        return value;
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        jaxbContext = JAXBContext.newInstance(""org.apache.camel.model:org.apache.camel.model.config:org.apache.camel.model.dataformat:org.apache.camel.model.language"");
    }
}
"
org.apache.camel.model.config.BatchResequencerConfig,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.config;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.processor.Resequencer;
/**
 * Defines the configuration parameters for the batch-processing
 * {@link Resequencer}. Usage example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).batch(
 *         BatchResequencerConfig.getDefault()).to(&quot;mock:result&quot;)
 * </pre>
 * is equivalent to
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).batch().to(&quot;mock:result&quot;)
 * </pre>
 * 
 * or
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * Custom values for <code>batchSize</code> and <code>batchTimeout</code>
 * can be set like in this example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(body()).batch(
 *         new BatchResequencerConfig(300, 400L)).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * @author Martin Krasser
 * 
 * @version $Revision$
 */
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class BatchResequencerConfig {
    @XmlAttribute
    private Integer batchSize; // optional XML attribute requires wrapper object 
    @XmlAttribute
    private Long batchTimeout; // optional XML attribute requires wrapper object
    /**
     * Creates a new {@link BatchResequencerConfig} instance using default
     * values for <code>batchSize</code> (100) and <code>batchTimeout</code>
     * (1000L).
     */
    public BatchResequencerConfig() {
        this(100, 1000L);
    }
    /**
     * Creates a new {@link BatchResequencerConfig} instance using the given
     * values for <code>batchSize</code> and <code>batchTimeout</code>.
     * 
     * @param batchSize
     *            size of the batch to be re-ordered.
     * @param batchTimeout
     *            timeout for collecting elements to be re-ordered.
     */
    public BatchResequencerConfig(int batchSize, long batchTimeout) {
        this.batchSize = batchSize;
        this.batchTimeout = batchTimeout;
    }
    /**
     * Returns a new {@link BatchResequencerConfig} instance using default
     * values for <code>batchSize</code> (100) and <code>batchTimeout</code>
     * (1000L).
     * 
     * @return a default {@link BatchResequencerConfig}.
     */
    public static BatchResequencerConfig getDefault() {
        return new BatchResequencerConfig();
    }
    public int getBatchSize() {
        return batchSize;
    }
    public void setBatchSize(int batchSize) {
        this.batchSize = batchSize;
    }
    public long getBatchTimeout() {
        return batchTimeout;
    }
    public void setBatchTimeout(long batchTimeout) {
        this.batchTimeout = batchTimeout;
    }
}
"
org.apache.camel.model.config.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED) 
package org.apache.camel.model.config;
"
org.apache.camel.model.config.StreamResequencerConfig,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.config;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.Exchange;
import org.apache.camel.processor.StreamResequencer;
import org.apache.camel.processor.resequencer.DefaultExchangeComparator;
import org.apache.camel.processor.resequencer.ExpressionResultComparator;
/**
 * Defines the configuration parameters for the {@link StreamResequencer}.
 * Usage example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(header(&quot;seqnum&quot;)).stream(
 *         StreamResequencerConfig.getDefault()).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * is equivalent to
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(header(&quot;seqnum&quot;)).stream().to(&quot;mock:result&quot;)
 * </pre>
 * 
 * Custom values for <code>capacity</code> and <code>timeout</code> can be
 * set like in this example:
 * 
 * <pre>
 * from(&quot;direct:start&quot;).resequencer(header(&quot;seqnum&quot;)).stream(
 *         new StreamResequencerConfig(300, 400L)).to(&quot;mock:result&quot;)
 * </pre>
 * 
 * @author Martin Krasser
 * 
 * @version $Revision$
 */
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class StreamResequencerConfig {
    @XmlAttribute
    private Integer capacity; // optional XML attribute requires wrapper object
    @XmlAttribute
    private Long timeout; // optional XML attribute requires wrapper object
    @XmlTransient
    private ExpressionResultComparator<Exchange> comparator;
    /**
     * Creates a new {@link StreamResequencerConfig} instance using default
     * values for <code>capacity</code> (100) and <code>timeout</code>
     * (1000L). Elements of the sequence are compared using the
     * {@link DefaultExchangeComparator}.
     */
    public StreamResequencerConfig() {
        this(100, 1000L);
    }
    /**
     * Creates a new {@link BatchResequencerConfig} instance using the given
     * values for <code>capacity</code> and <code>timeout</code>. Elements
     * of the sequence are compared using the {@link DefaultExchangeComparator}.
     * 
     * @param capacity
     *            capacity of the resequencer's inbound queue.
     * @param timeout.
     *            minimum time to wait for missing elements (messages).
     */
    public StreamResequencerConfig(int capacity, long timeout) {
        this(capacity, timeout, new DefaultExchangeComparator());
    }
    /**
     * Creates a new {@link BatchResequencerConfig} instance using the given
     * values for <code>capacity</code> and <code>timeout</code>. Elements
     * of the sequence are compared with the given
     * {@link ExpressionResultComparator}.
     * 
     * @param capacity
     *            capacity of the resequencer's inbound queue.
     * @param timeout.
     *            minimum time to wait for missing elements (messages).
     */
    public StreamResequencerConfig(int capacity, long timeout, ExpressionResultComparator<Exchange> comparator) {
        this.capacity = capacity;
        this.timeout = timeout;
        this.comparator = comparator;
    }
    /**
     * Returns a new {@link StreamResequencerConfig} instance using default
     * values for <code>capacity</code> (100) and <code>timeout</code>
     * (1000L). Elements of the sequence are compared using the
     * {@link DefaultExchangeComparator}.
     * 
     * @return a default {@link StreamResequencerConfig}.
     */
    public static StreamResequencerConfig getDefault() {
        return new StreamResequencerConfig();
    }
    public int getCapacity() {
        return capacity;
    }
    public void setCapacity(int capacity) {
        this.capacity = capacity;
    }
    public long getTimeout() {
        return timeout;
    }
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }
    public ExpressionResultComparator<Exchange> getComparator() {
        return comparator;
    }
    public void setComparator(ExpressionResultComparator<Exchange> comparator) {
        this.comparator = comparator;
    }
}
"
org.apache.camel.model.dataformat.ArtixDSContentType,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlEnum;
/**
 * @version $Revision: 1.1 $
 */
@XmlEnum(String.class)
public enum ArtixDSContentType {
    Default, Auto, Binary, Text, Java, Xml, Sax, TagValuePair 
}
"
org.apache.camel.model.dataformat.ArtixDSDataFormat,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ObjectHelper;
/**
 * Represents the <a href=""http://activemq.apache.org/camel/artix-data-services.html"">Artix Data Services</a>
 * {@link DataFormat}
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""artixDS"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ArtixDSDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private String elementTypeName;
    @XmlAttribute(required = false)
    private String format;
    @XmlAttribute(required = false)
    private Class<?> elementType;
    @XmlAttribute(required = false)
    private ArtixDSContentType contentType;
    public ArtixDSDataFormat() {
        super(""org.apache.camel.artix.ds.ArtixDSFormat"");
    }
    public ArtixDSDataFormat(Class<?> elementType) {
        this();
        this.elementType = elementType;
    }
    public ArtixDSDataFormat(Class<?> elementType, ArtixDSContentType contentType) {
        this();
        this.elementType = elementType;
        this.contentType = contentType;
    }
    public ArtixDSDataFormat(ArtixDSContentType contentType) {
        this();
        this.contentType = contentType;
    }
    // Properties
    //-------------------------------------------------------------------------
    public String getElementTypeName() {
        return elementTypeName;
    }
    public void setElementTypeName(String elementTypeName) {
        this.elementTypeName = elementTypeName;
    }
    public ArtixDSContentType getContentType() {
        return contentType;
    }
    public void setContentType(ArtixDSContentType contentType) {
        this.contentType = contentType;
    }
    public Class<?> getElementType() {
        if (elementType == null) {
            if (elementTypeName != null) {
                elementType = ObjectHelper.loadClass(elementTypeName, getClass().getClassLoader());
            }
        }
        return elementType;
    }
    public void setElementType(Class<?> elementType) {
        this.elementType = elementType;
    }
    public String getFormat() {
        return format;
    }
    public void setFormat(String format) {
        this.format = format;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected void configureDataFormat(DataFormat dataFormat) {
        Class<?> type = getElementType();
        if (type != null) {
            setProperty(dataFormat, ""elementType"", type);
        }
        ArtixDSContentType content = getContentType();
        if (content != null) {
            setProperty(dataFormat, ""contentType"", content);
        }
    }
}
"
org.apache.camel.model.dataformat.DataFormatType,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.IntrospectionSupport;
/**
 * @version $Revision: 1.1 $
 */
@XmlType(name = ""dataFormatType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class DataFormatType {
    @XmlTransient
    private DataFormat dataFormat;
    @XmlTransient
    private String dataFormatTypeName;
    public DataFormatType() {
    }
    public DataFormatType(DataFormat dataFormat) {
        this.dataFormat = dataFormat;
    }
    protected DataFormatType(String dataFormatTypeName) {
        this.dataFormatTypeName = dataFormatTypeName;
    }
    public DataFormat getDataFormat(RouteContext routeContext) {
        if (dataFormat == null) {
            dataFormat = createDataFormat(routeContext);
            ObjectHelper.notNull(dataFormat, ""dataFormat"");
            configureDataFormat(dataFormat);
        }
        return dataFormat;
    }
    /**
     * Factory method to create the data format instance
     */
    protected DataFormat createDataFormat(RouteContext routeContext) {
        if (dataFormatTypeName != null) {
            Class type = ObjectHelper.loadClass(dataFormatTypeName, getClass().getClassLoader());
            if (type == null) {
                throw new IllegalArgumentException(""The class "" + dataFormatTypeName + "" is not on the classpath! Cannot use the dataFormat "" + this);
            }
            return (DataFormat) ObjectHelper.newInstance(type);
        }
        return null;
    }
    /**
     * Allows derived classes to customize the data format
     */
    protected void configureDataFormat(DataFormat dataFormat) {
    }
    /**
     * Sets a named property on the data format instance using introspection
     */
    protected void setProperty(DataFormat dataFormat, String name, Object value) {
        try {
            IntrospectionSupport.setProperty(dataFormat,name, value);
        }
        catch (Exception e) {
            throw new IllegalArgumentException(""Failed to set property "" + name + "" on "" + dataFormat + "". Reason: "" + e, e);
        }
    }
}
"
org.apache.camel.model.dataformat.JaxbDataFormat,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.spi.DataFormat;
/**
 * Represents the JAXB2 XML {@link DataFormat}
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""jaxb"")
@XmlAccessorType(XmlAccessType.FIELD)
public class JaxbDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private Boolean prettyPrint;
    public JaxbDataFormat() {
        super(""org.apache.camel.converter.jaxb.JaxbDataFormat"");
    }
    public JaxbDataFormat(boolean prettyPrint) {
        this();
        setPrettyPrint(prettyPrint);
    }
    public Boolean getPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(Boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
    @Override
    protected void configureDataFormat(DataFormat dataFormat) {
        if (ObjectConverter.toBool(getPrettyPrint())) {
            setProperty(dataFormat, ""prettyPrint"", Boolean.TRUE);
        }
    }
}
"
org.apache.camel.model.dataformat.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.model.dataformat;
"
org.apache.camel.model.dataformat.SerializationDataFormat,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.impl.RouteContext;
/**
 * Represents the Java Serialization {@link DataFormat}
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""serialization"")
public class SerializationDataFormat extends DataFormatType {
    @Override
    protected DataFormat createDataFormat(RouteContext routeContext) {
        return new org.apache.camel.impl.SerializationDataFormat();
    }
}
"
org.apache.camel.model.dataformat.XMLBeansDataFormat,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.dataformat;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.spi.DataFormat;
/**
 * Represents the XMLBeans XML {@link DataFormat}
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""xmlBeans"")
@XmlAccessorType(XmlAccessType.FIELD)
public class XMLBeansDataFormat extends DataFormatType {
    @XmlAttribute(required = false)
    private Boolean prettyPrint;
    public XMLBeansDataFormat() {
        super(""org.apache.camel.dataformat.converter.XmlBeansDataType"");
    }
    public Boolean getPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(Boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
}
"
org.apache.camel.model.language.ELExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For EL expresions and predicates
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""el"")
public class ELExpression extends ExpressionType {
    public ELExpression() {
    }
    public ELExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""el"";
    }
}
"
org.apache.camel.model.language.ExpressionType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.spi.Language;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.util.CollectionStringBuffer;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlValue;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import java.util.List;
/**
 * A useful base class for an expression
 *
 * @version $Revision: 1.1 $
 */
@XmlType(name = ""expressionType"")
@XmlAccessorType(XmlAccessType.FIELD)
public class ExpressionType {
    @XmlAttribute
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    private String id;
    @XmlValue
    private String expression;
    @XmlTransient
    private Predicate predicate;
    @XmlTransient
    private Expression expressionValue;
    public static String getLabel(List<ExpressionType> expressions) {
        CollectionStringBuffer buffer = new CollectionStringBuffer();
        for (ExpressionType expression : expressions) {
            buffer.append(expression.getLabel());
        }
        return buffer.toString();
    }
    public ExpressionType() {
    }
    public ExpressionType(String expression) {
        this.expression = expression;
    }
    public ExpressionType(Predicate predicate) {
        this.predicate = predicate;
    }
    public ExpressionType(Expression expression) {
        this.expressionValue = expression;
    }
    @Override
    public String toString() {
        return getLanguage() + ""Expression["" + getExpression() + ""]"";
    }
    public String getLanguage() {
        return """";
    }
    public Predicate<Exchange> createPredicate(RouteContext route) {
        if (predicate == null) {
            CamelContext camelContext = route.getCamelContext();
            Language language = camelContext.resolveLanguage(getLanguage());
            predicate = language.createPredicate(getExpression());
        }
        return predicate;
    }
    public Expression createExpression(RouteContext routeContext) {
        if (expressionValue == null) {
            CamelContext camelContext = routeContext.getCamelContext();
            Language language = camelContext.resolveLanguage(getLanguage());
            expressionValue = language.createExpression(getExpression());
        }
        return expressionValue;
    }
    public String getExpression() {
        return expression;
    }
    public void setExpression(String expression) {
        this.expression = expression;
    }
    /**
     * Gets the value of the id property.
     *
     * @return possible object is
     *         {@link String }
     */
    public String getId() {
        return id;
    }
    /**
     * Sets the value of the id property.
     *
     * @param value allowed object is
     *              {@link String }
     */
    public void setId(String value) {
        this.id = value;
    }
    public Predicate getPredicate() {
        return predicate;
    }
    public Expression getExpressionValue() {
        return expressionValue;
    }
    /**
     * Returns some descriptive text to describe this node
     */
    public String getLabel() {
        String language = getExpression();
        if (ObjectHelper.isNullOrBlank(language)) {
            Predicate predicate = getPredicate();
            if (predicate != null) {
                return predicate.toString();
            }
            Expression expressionValue = getExpressionValue();
            if (expressionValue != null) {
                return expressionValue.toString();
            }
        }
        else {
            return language;
        }
        return """";
    }
}
"
org.apache.camel.model.language.GroovyExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For Groovy expresions and predicates
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""groovy"")
public class GroovyExpression extends ExpressionType {
    public GroovyExpression() {
    }
    public GroovyExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""groovy"";
    }
}
"
org.apache.camel.model.language.HeaderExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * An expression which extracts the named header
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""header"")
public class HeaderExpression extends ExpressionType {
    public HeaderExpression() {
    }
    public HeaderExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""header"";
    }
}
"
org.apache.camel.model.language.JavaScriptExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For JavaScript expresions and predicates
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""javaScript"")
public class JavaScriptExpression extends ExpressionType {
    public JavaScriptExpression() {
    }
    public JavaScriptExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""js"";
    }
}
"
org.apache.camel.model.language.LanguageExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * Represents a parameterised language expression which can support any language
 * at runtime using the language attribute.
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""expression"")
@XmlAccessorType(XmlAccessType.FIELD)
public class LanguageExpression extends ExpressionType {
    @XmlAttribute
    private String language;
    public LanguageExpression() {
    }
    public LanguageExpression(String language, String expression) {
        setLanguage(language);
        setExpression(expression);
    }
    public String getLanguage() {
        return language;
    }
    public void setLanguage(String language) {
        this.language = language;
    }
}
"
org.apache.camel.model.language.OgnlExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For OGNL expresions and predicates
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""ognl"")
public class OgnlExpression extends ExpressionType {
    public OgnlExpression() {
    }
    public OgnlExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""ognl"";
    }
}
"
org.apache.camel.model.language.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED) 
package org.apache.camel.model.language;
"
org.apache.camel.model.language.PhpExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For PHP expresions and predicates
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""php"")
public class PhpExpression extends ExpressionType {
    public PhpExpression() {
    }
    public PhpExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""php"";
    }
}
"
org.apache.camel.model.language.PythonExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For Python expresions and predicates
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""python"")
public class PythonExpression extends ExpressionType {
    public PythonExpression() {
    }
    public PythonExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""python"";
    }
}
"
org.apache.camel.model.language.RubyExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For Ruby expresions and predicates
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""ruby"")
public class RubyExpression extends ExpressionType {
    public RubyExpression() {
    }
    public RubyExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""ruby"";
    }
}
"
org.apache.camel.model.language.SimpleExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For Groovy expresions and predicates
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""simple"")
public class SimpleExpression extends ExpressionType {
    public SimpleExpression() {
    }
    public SimpleExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""simple"";
    }
}
"
org.apache.camel.model.language.SqlExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For SQ: expresions and predicates
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""sql"")
public class SqlExpression extends ExpressionType {
    public SqlExpression() {
    }
    public SqlExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""sql"";
    }
}
"
org.apache.camel.model.language.XPathExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For XPath expresions and predicates
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""xpath"")
public class XPathExpression extends ExpressionType {
    public XPathExpression() {
    }
    public XPathExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""xpath"";
    }
}
"
org.apache.camel.model.language.XQueryExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.model.language;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * For XQuery expresions and predicates
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""xquery"")
public class XQueryExpression extends ExpressionType {
    public XQueryExpression() {
    }
    public XQueryExpression(String expression) {
        super(expression);
    }
    public String getLanguage() {
        return ""xquery"";
    }
}
"
org.apache.camel.processor.Aggregator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Endpoint;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.processor.aggregate.AggregationCollection;
import org.apache.camel.processor.aggregate.AggregationStrategy;
/**
 * An implementation of the <a
 * href=""http://activemq.apache.org/camel/aggregator.html"">Aggregator</a>
 * pattern where a batch of messages are processed (up to a maximum amount or
 * until some timeout is reached) and messages for the same correlation key are
 * combined together using some kind of
 * {@link AggregationStrategy ) (by default the latest message is used) to compress 
 * many message exchanges * into a smaller number of exchanges. <p/> A good
 * example of this is stock market data; you may be receiving 30,000
 * messages/second and you may want to throttle it right down so that multiple
 * messages for the same stock are combined (or just the latest message is used
 * and older prices are discarded). Another idea is to combine line item
 * messages together into a single invoice message.
 * 
 * @version $Revision: 1.1 $
 * @param correlationExpression the expression used to calculate the correlation
 *                key. For a JMS message this could be the expression
 *                <code>header(""JMSDestination"")</code> or
 *                <code>header(""JMSCorrelationID"")</code>
 */
public class Aggregator extends BatchProcessor {
    public Aggregator(Endpoint endpoint, Processor processor, Expression correlationExpression,
                      AggregationStrategy aggregationStrategy) {
        this(endpoint, processor, new AggregationCollection(correlationExpression, aggregationStrategy));
    }
    public Aggregator(Endpoint endpoint, Processor processor, AggregationCollection collection) {
        super(endpoint, processor, collection);
    }
    @Override
    public String toString() {
        return ""Aggregator[to: "" + getProcessor() + ""]"";
    }
}
"
org.apache.camel.processor.AggregatorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class AggregatorTest extends ContextTestSupport {
    protected int messageCount = 100;
    public void testSendingLotsOfMessagesGetAggregatedToTheLatestMessage() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(""message:"" + messageCount);
        // lets send a large batch of messages
        for (int i = 1; i <= messageCount; i++) {
            String body = ""message:"" + i;
            template.sendBodyAndHeader(""direct:a"", body, ""cheese"", 123);
        }
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: ex
                from(""direct:a"").aggregator(header(""cheese"")).to(""mock:result"");
                // END SNIPPET: ex
            }
        };
    }
}
"
org.apache.camel.processor.BatchProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Collection;
import java.util.Iterator;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.impl.LoggingExceptionHandler;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.ExceptionHandler;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A base class for any kind of {@link Processor} which implements some kind of
 * batch processing.
 * 
 * @version $Revision: 1.1 $
 */
public class BatchProcessor extends ServiceSupport implements Runnable {
    public static final long DEFAULT_BATCH_TIMEOUT = 1000L;
    public static final int DEFAULT_BATCH_SIZE = 100;
    private static final transient Log LOG = LogFactory.getLog(Resequencer.class);
    private Endpoint endpoint;
    private Processor processor;
    private Collection<Exchange> collection;
    private long batchTimeout = DEFAULT_BATCH_TIMEOUT;
    private int batchSize = DEFAULT_BATCH_SIZE;
    private PollingConsumer consumer;
    private ExceptionHandler exceptionHandler;
    public BatchProcessor(Endpoint endpoint, Processor processor, Collection<Exchange> collection) {
        this.endpoint = endpoint;
        this.processor = processor;
        this.collection = collection;
    }
    @Override
    public String toString() {
        return ""BatchProcessor[to: "" + processor + ""]"";
    }
    public void run() {
        LOG.debug(""Starting thread for "" + this);
        while (isRunAllowed()) {
            try {
                processBatch();
            } catch (Exception e) {
                getExceptionHandler().handleException(e);
            }
        }
        collection.clear();
    }
    // Properties
    // -------------------------------------------------------------------------
    public ExceptionHandler getExceptionHandler() {
        if (exceptionHandler == null) {
            exceptionHandler = new LoggingExceptionHandler(getClass());
        }
        return exceptionHandler;
    }
    public void setExceptionHandler(ExceptionHandler exceptionHandler) {
        this.exceptionHandler = exceptionHandler;
    }
    public int getBatchSize() {
        return batchSize;
    }
    public void setBatchSize(int batchSize) {
        this.batchSize = batchSize;
    }
    public long getBatchTimeout() {
        return batchTimeout;
    }
    public void setBatchTimeout(long batchTimeout) {
        this.batchTimeout = batchTimeout;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public Processor getProcessor() {
        return processor;
    }
    /**
     * A transactional method to process a batch of messages up to a timeout
     * period or number of messages reached.
     */
    protected synchronized void processBatch() throws Exception {
        long start = System.currentTimeMillis();
        long end = start + batchTimeout;
        for (int i = 0; i < batchSize; i++) {
            long timeout = end - System.currentTimeMillis();
            Exchange exchange = consumer.receive(timeout);
            if (exchange == null) {
                break;
            }
            collection.add(exchange);
        }
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Finsihed batch size: "" + batchSize + "" timeout: "" + batchTimeout + "" so sending set: ""
                      + collection);
        }
        // lets send the batch
        Iterator<Exchange> iter = collection.iterator();
        while (iter.hasNext()) {
            Exchange exchange = iter.next();
            iter.remove();
            processExchange(exchange);
        }
    }
    /**
     * Strategy Method to process an exchange in the batch. This method allows
     * derived classes to perform custom processing before or after an
     * individual exchange is processed
     */
    protected void processExchange(Exchange exchange) throws Exception {
        processor.process(exchange);
    }
    protected void doStart() throws Exception {
        consumer = endpoint.createPollingConsumer();
        ServiceHelper.startServices(processor, consumer);
        Thread thread = new Thread(this, this + "" Polling Thread"");
        thread.start();
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(consumer, processor);
        collection.clear();
    }
    protected Collection<Exchange> getCollection() {
        return collection;
    }
}
"
org.apache.camel.processor.BeanRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.naming.Context;
import java.util.concurrent.atomic.AtomicInteger;
/**
 * @version $Revision: 1.1 $
 */
public class BeanRouteTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendingMessageWithMethodNameHeader() throws Exception {
        String expectedBody = ""Wobble"";
        template.sendBodyAndHeader(""direct:in"", expectedBody, BeanProcessor.METHOD_NAME, ""read"");
        assertEquals(""bean received correct value for: "" + myBean, expectedBody, myBean.body);
    }
    public void testSendingMessageWithMethodNameHeaderWithMoreVerboseCoe() throws Exception {
        final String expectedBody = ""Wibble"";
        template.send(""direct:in"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(expectedBody);
                in.setHeader(BeanProcessor.METHOD_NAME, ""read"");
            }
        });
        assertEquals(""bean received correct value"", expectedBody, myBean.body);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Object lookedUpBean = context.getRegistry().lookup(""myBean"");
        assertSame(""Lookup of 'myBean' should return same object!"", myBean, lookedUpBean);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public String body;
        private static AtomicInteger counter = new AtomicInteger(0);
        private int id;
        public MyBean() {
            id = counter.incrementAndGet();
        }
        @Override
        public String toString() {
            return ""MyBean:"" + id;
        }
        public void read(String body) {
            this.body = body;
            LOG.info(""read() method on "" + this + "" with body: "" + body);
        }
        public void wrongMethod(String body) {
            fail(""wrongMethod() called with: "" + body);
        }
    }
}
"
org.apache.camel.processor.BeanWithExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Header;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.naming.Context;
/**
 * @version $Revision: 1.1 $
 */
public class BeanWithExceptionTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint invalidEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint);
    }
    public void testInvalidMessage() throws Exception {
        invalidEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        invalidEndpoint = resolveMandatoryEndpoint(""mock:invalid"", MockEndpoint.class);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", new ValidationBean());
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                exception(ValidationException.class).to(""mock:invalid"");
                from(""direct:start"").
                        beanRef(""myBean"").
                        to(""mock:valid"");            }
        };
    }
    public static class ValidationBean {
        private static final transient Log LOG = LogFactory.getLog(ValidationBean.class);
        public void someMethod(String body, @Header(name = ""foo"") String header) throws ValidationException {
            if (""bar"".equals(header)) {
                LOG.info(""someMethod() called with valid header and body: "" + body);
            }
            else {
                throw new ValidationException(null, ""Invalid header foo: "" + header);
            }
        }
    }
}
"
org.apache.camel.processor.BeanWithXPathInjectionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.language.XPath;
import org.apache.camel.util.jndi.JndiContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.naming.Context;
/**
 * @version $Revision: 1.1 $
 */
public class BeanWithXPathInjectionTest extends ContextTestSupport {
    private static final transient Log LOG = LogFactory.getLog(BeanRouteTest.class);
    protected MyBean myBean = new MyBean();
    public void testSendMessage() throws Exception {
        String expectedBody = ""<env:Envelope xmlns:env='http://www.w3.org/2003/05/soap-envelope'><env:Body>"" +
                ""<foo>bar</foo></env:Body></env:Envelope>"";
        template.sendBodyAndHeader(""direct:in"", expectedBody, ""foo"", ""bar"");
        assertEquals(""bean body: "" + myBean, expectedBody, myBean.body);
        assertEquals(""bean foo: "" + myBean, ""bar"", myBean.foo);
    }
    @Override
    protected Context createJndiContext() throws Exception {
        JndiContext answer = new JndiContext();
        answer.bind(""myBean"", myBean);
        return answer;
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:in"").beanRef(""myBean"");
            }
        };
    }
    public static class MyBean {
        public String body;
        public String foo;
        @Override
        public String toString() {
            return ""MyBean[foo: "" + foo + "" body: "" + body + ""]"";
        }
        public void read(String body, @XPath(""/soap:Envelope/soap:Body/foo/text()"") String foo) {
            this.foo = foo;
            this.body = body;
            LOG.info(""read() method called on "" + this);
        }
    }
}
"
org.apache.camel.processor.CatchProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.Processor;
/**
 * @version $Revision: $
 */
public class CatchProcessor extends DelegateProcessor {
    private List<Class> exceptions;
    public CatchProcessor(List<Class> exceptions, Processor processor) {
        super(processor);
        this.exceptions = exceptions;
    }
    @Override
    public String toString() {
        return ""Catch["" + exceptions + "" -> "" + getProcessor() + ""]"";
    }
    public boolean catches(Throwable e) {
        for (Class type : exceptions) {
            if (type.isInstance(e)) {
                return true;
            }
        }
        return false;
    }
    public List<Class> getExceptions() {
        return exceptions;
    }
}
"
org.apache.camel.processor.ChoiceProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * Implements a Choice structure where one or more predicates are used which if
 * they are true their processors are used, with a default otherwise clause used
 * if none match.
 * 
 * @version $Revision: 563607 $
 */
public class ChoiceProcessor extends ServiceSupport implements Processor {
    private List<FilterProcessor> filters = new ArrayList<FilterProcessor>();
    private Processor otherwise;
    public ChoiceProcessor(List<FilterProcessor> filters, Processor otherwise) {
        this.filters = filters;
        this.otherwise = otherwise;
    }
    public void process(Exchange exchange) throws Exception {
        for (FilterProcessor filterProcessor : filters) {
            Predicate<Exchange> predicate = filterProcessor.getPredicate();
            if (predicate != null && predicate.matches(exchange)) {
                filterProcessor.getProcessor().process(exchange);
                return;
            }
        }
        if (otherwise != null) {
            otherwise.process(exchange);
        }
    }
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""choice{"");
        boolean first = true;
        for (FilterProcessor processor : filters) {
            if (first) {
                first = false;
            } else {
                builder.append("", "");
            }
            builder.append(""when "");
            builder.append(processor.getPredicate().toString());
            builder.append("": "");
            builder.append(processor.getProcessor());
        }
        if (otherwise != null) {
            builder.append("", otherwise: "");
            builder.append(otherwise);
        }
        builder.append(""}"");
        return builder.toString();
    }
    public List<FilterProcessor> getFilters() {
        return filters;
    }
    public Processor getOtherwise() {
        return otherwise;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(filters);
        ServiceHelper.startServices(otherwise);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(otherwise);
        ServiceHelper.stopServices(filters);
    }
}
"
org.apache.camel.processor.ChoiceTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied;
import static org.apache.camel.component.mock.MockEndpoint.expectsMessageCount;
/**
 * @version $Revision: 1.1 $
 */
public class ChoiceTest extends ContextTestSupport {
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    public void testSendToFirstWhen() throws Exception {
        String body = ""<one/>"";
        x.expectedBodiesReceived(body);
        expectsMessageCount(0, y, z);
        sendMessage(""bar"", body);
        assertMockEndpointsSatisifed();
    }
    public void testSendToSecondWhen() throws Exception {
        String body = ""<two/>"";
        y.expectedBodiesReceived(body);
        expectsMessageCount(0, x, z);
        sendMessage(""cheese"", body);
        assertMockEndpointsSatisifed();
    }
    public void testSendToOtherwiseClause() throws Exception {
        String body = ""<three/>"";
        z.expectedBodiesReceived(body);
        expectsMessageCount(0, x, y);
        sendMessage(""somethingUndefined"", body);
        assertMockEndpointsSatisifed();
    }
    protected void sendMessage(final Object headerValue, final Object body) throws Exception {
        template.sendBodyAndHeader(""direct:start"", body, ""foo"", headerValue);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").choice()
                        .when(header(""foo"").isEqualTo(""bar"")).setHeader(""name"", constant(""a"")).to(""mock:x"")
                        .when(header(""foo"").isEqualTo(""cheese"")).to(""mock:y"")
                        .otherwise().to(""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.CompositeProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Collection;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * Represents a composite pattern, aggregating a collection of processors
 * together as a single processor
 * 
 * @version $Revision: 563607 $
 */
public class CompositeProcessor extends ServiceSupport implements Processor {
    private final Collection<Processor> processors;
    public CompositeProcessor(Collection<Processor> processors) {
        this.processors = processors;
    }
    public void process(Exchange exchange) throws Exception {
        for (Processor processor : processors) {
            processor.process(exchange);
        }
    }
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder(""[ "");
        boolean first = true;
        for (Processor processor : processors) {
            if (first) {
                first = false;
            } else {
                builder.append("", "");
            }
            builder.append(processor.toString());
        }
        builder.append("" ]"");
        return builder.toString();
    }
    public Collection<Processor> getProcessors() {
        return processors;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processors);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processors);
    }
}
"
org.apache.camel.processor.CreateRouteWithNonExistingEndpointTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 1.1 $
 */
public class CreateRouteWithNonExistingEndpointTest extends ContextTestSupport {
    public void testCreateRouteWithBadEndpoint() throws Exception {
    }
    @Override
    protected void setUp() throws Exception {
        try {
            super.setUp();
            fail(""Should have failed to create this route!"");
        } catch (NoSuchEndpointException e) {
            log.debug(""Caught expected exception: "" + e, e);
            assertEquals(""uri"", ""thisUriDoesNotExist"", e.getUri());
        }
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").to(""thisUriDoesNotExist"");
            }
        };
    }
}
"
org.apache.camel.processor.DataFormatTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.Serializable;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.util.ObjectHelper;
/**
 * @version $Revision: 1.1 $
 */
public class DataFormatTest extends ContextTestSupport {
    public void testMarshalThenUnmarshalBean() throws Exception {
        MyBean bean = new MyBean();
        bean.name = ""James"";
        bean.counter = 5;
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedBodiesReceived(bean);
        template.sendBody(""direct:start"", bean);
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").marshal().serialization().to(""direct:marshalled"");
                from(""direct:marshalled"").unmarshal().serialization().to(""mock:result"");
            }
        };
    }
    protected static class MyBean implements Serializable {
        public String name;
        public int counter;
        @Override
        public boolean equals(Object o) {
            if (o instanceof MyBean) {
                MyBean that = (MyBean) o;
                return ObjectHelper.equals(this.name, that.name) && ObjectHelper.equals(this.counter,  that.counter);                
            }
            return false;
        }
    }
}
"
org.apache.camel.processor.DeadLetterChannel,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.RejectedExecutionException;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.model.ExceptionType;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Implements a <a
 * href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter
 * Channel</a> after attempting to redeliver the message using the
 * {@link RedeliveryPolicy}
 * 
 * @version $Revision: 582309 $
 */
public class DeadLetterChannel extends ErrorHandlerSupport implements AsyncProcessor {
    public static final String REDELIVERY_COUNTER = ""org.apache.camel.RedeliveryCounter"";
    public static final String REDELIVERED = ""org.apache.camel.Redelivered"";
    private class RedeliveryData {
        int redeliveryCounter;
        long redeliveryDelay;
        boolean sync = true;
        // default behaviour which can be overloaded on a per exception basis
        RedeliveryPolicy currentRedeliveryPolicy = redeliveryPolicy;
        Processor failureProcessor = deadLetter;
    }
    private static final transient Log LOG = LogFactory.getLog(DeadLetterChannel.class);
    private static final String FAILURE_HANDLED_PROPERTY = DeadLetterChannel.class.getName()+"".FAILURE_HANDLED"";
    private Processor output;
    private Processor deadLetter;
    private AsyncProcessor outputAsync;
    private RedeliveryPolicy redeliveryPolicy;
    private Logger logger;
    public DeadLetterChannel(Processor output, Processor deadLetter) {
        this(output, deadLetter, new RedeliveryPolicy(), DeadLetterChannel.createDefaultLogger());
    }
    public DeadLetterChannel(Processor output, Processor deadLetter, RedeliveryPolicy redeliveryPolicy, Logger logger) {
        this.deadLetter = deadLetter;
        this.output = output;        
        this.outputAsync = AsyncProcessorTypeConverter.convert(output);
        this.redeliveryPolicy = redeliveryPolicy;
        this.logger = logger;
    }
    public static <E extends Exchange> Logger createDefaultLogger() {
        return new Logger(LOG, LoggingLevel.ERROR);
    }
    @Override
    public String toString() {
        return ""DeadLetterChannel["" + output + "", "" + deadLetter + "", "" + redeliveryPolicy + ""]"";
    }
    public boolean process(Exchange exchange, final AsyncCallback callback) {
        return process(exchange, callback, new RedeliveryData());
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data) {
        while (true) {
            // We can't keep retrying if the route is being shutdown.
            if (!isRunAllowed()) {
                if (exchange.getException() == null) {
                    exchange.setException(new RejectedExecutionException());
                }
                callback.done(data.sync);
                return data.sync;
            }
            if (exchange.getException() != null) {
                Throwable e = exchange.getException();
                exchange.setException(null); // Reset it since we are handling it.
                logger.log(""On delivery attempt: "" + data.redeliveryCounter + "" caught: "" + e, e);
                data.redeliveryCounter = incrementRedeliveryCounter(exchange, e);
                ExceptionType exceptionPolicy = getExceptionPolicy(exchange, e);
                if (exceptionPolicy != null) {
                    data.currentRedeliveryPolicy = exceptionPolicy.createRedeliveryPolicy(data.currentRedeliveryPolicy);
                    Processor processor = exceptionPolicy.getErrorHandler();
                    if (processor != null) {
                        data.failureProcessor = processor;
                    }
                }
            }
            if (!data.currentRedeliveryPolicy.shouldRedeliver(data.redeliveryCounter)) {
                setFailureHandled(exchange, true);
                AsyncProcessor afp = AsyncProcessorTypeConverter.convert(data.failureProcessor);
                return afp.process(exchange, new AsyncCallback() {
                    public void done(boolean sync) {
                        callback.done(data.sync);
                    }
                });
            }
            if (data.redeliveryCounter > 0) {
                // Figure out how long we should wait to resend this message.
                data.redeliveryDelay = data.currentRedeliveryPolicy.getRedeliveryDelay(data.redeliveryDelay);
                sleep(data.redeliveryDelay);
            }
            exchange.setException(null);
            boolean sync = outputAsync.process(exchange, new AsyncCallback() {
                public void done(boolean sync) {
                    // Only handle the async case...
                    if (sync) {
                        return;
                    }
                    data.sync = false;
                    if (exchange.getException() != null) {
                        process(exchange, callback, data);
                    } else {
                        callback.done(sync);
                    }
                }
            });
            if (!sync) {
                // It is going to be processed async..
                return false;
            }
            if (exchange.getException() == null || isFailureHandled(exchange)) {
                // If everything went well.. then we exit here..
                callback.done(true);
                return true;
            }
            // error occured so loop back around.....
        }
    }
    public static boolean isFailureHandled(Exchange exchange) {
        Boolean rc = exchange.getProperty(FAILURE_HANDLED_PROPERTY, Boolean.class);
        return rc == null ? false : rc;
    }
    public static void setFailureHandled(Exchange exchange, boolean b) {
        exchange.setProperty(FAILURE_HANDLED_PROPERTY, b ? Boolean.TRUE : Boolean.FALSE );
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    // Properties
    // -------------------------------------------------------------------------
    /**
     * Returns the output processor
     */
    public Processor getOutput() {
        return output;
    }
    /**
     * Returns the dead letter that message exchanges will be sent to if the
     * redelivery attempts fail
     */
    public Processor getDeadLetter() {
        return deadLetter;
    }
    public RedeliveryPolicy getRedeliveryPolicy() {
        return redeliveryPolicy;
    }
    /**
     * Sets the redelivery policy
     */
    public void setRedeliveryPolicy(RedeliveryPolicy redeliveryPolicy) {
        this.redeliveryPolicy = redeliveryPolicy;
    }
    public Logger getLogger() {
        return logger;
    }
    /**
     * Sets the logger strategy; which {@link Log} to use and which
     * {@link LoggingLevel} to use
     */
    public void setLogger(Logger logger) {
        this.logger = logger;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Increments the redelivery counter and adds the redelivered flag if the
     * message has been redelivered
     */
    protected int incrementRedeliveryCounter(Exchange exchange, Throwable e) {
        Message in = exchange.getIn();
        Integer counter = in.getHeader(REDELIVERY_COUNTER, Integer.class);
        int next = 1;
        if (counter != null) {
            next = counter + 1;
        }
        in.setHeader(REDELIVERY_COUNTER, next);
        in.setHeader(REDELIVERED, true);
        exchange.setException(e);
        return next;
    }
    protected void sleep(long redeliveryDelay) {
        if (redeliveryDelay > 0) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Sleeping for: "" + redeliveryDelay + "" until attempting redelivery"");
            }
            try {
                Thread.sleep(redeliveryDelay);
            } catch (InterruptedException e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Thread interupted: "" + e, e);
                }
            }
        }
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(output, deadLetter);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(deadLetter, output);
    }
}
"
org.apache.camel.processor.DeadLetterChannelTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied;
/**
 * @version $Revision: 1.1 $
 */
public class DeadLetterChannelTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint deadEndpoint; 
    protected MockEndpoint successEndpoint;
    protected int failUntilAttempt = 2;
    protected String body = ""<hello>world!</hello>"";
    public void testFirstFewAttemptsFail() throws Exception {
        successEndpoint.expectedBodiesReceived(body);
        successEndpoint.message(0).header(DeadLetterChannel.REDELIVERED).isEqualTo(true);
        // TODO convert to AND
        successEndpoint.message(0).header(DeadLetterChannel.REDELIVERY_COUNTER).isEqualTo(1);
        deadEndpoint.expectedMessageCount(0);
        sendBody(""direct:start"", body);
        assertMockEndpointsSatisifed();
    }
    public void testLotsOfAttemptsFail() throws Exception {
        failUntilAttempt = 5;
        deadEndpoint.expectedBodiesReceived(body);
        deadEndpoint.message(0).header(DeadLetterChannel.REDELIVERED).isEqualTo(true);
        // TODO convert to AND
        deadEndpoint.message(0).header(DeadLetterChannel.REDELIVERY_COUNTER).isEqualTo(2);
        successEndpoint.expectedMessageCount(0);
        sendBody(""direct:start"", body);
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        deadEndpoint = getMockEndpoint(""mock:failed"");
        successEndpoint = getMockEndpoint(""mock:success"");
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                Integer counter = exchange.getIn().getHeader(DeadLetterChannel.REDELIVERY_COUNTER,
                                                             Integer.class);
                int attempt = (counter == null) ? 1 : counter + 1;
                if (attempt < failUntilAttempt) {
                    throw new RuntimeException(""Failed to process due to attempt: "" + attempt
                                               + "" being less than: "" + failUntilAttempt);
                } else {
                    template.send(""mock:success"", exchange);
                }
            }
        };
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").errorHandler(
                                                  deadLetterChannel(""mock:failed"").maximumRedeliveries(2)
                                                      .initialRedeliveryDelay(1)
                                                      .loggingLevel(LoggingLevel.DEBUG)
                ).process(processor);
                /*
                 * TODO - currently process().to() results in two separate
                 * operations which have their own error handler
                 * 
                 * .to(""mock:success"");
                 */
            }
        };
    }
}
"
org.apache.camel.processor.Delayer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.util.ExpressionHelper;
/**
 * A <a href=""http://activemq.apache.org/camel/delayer.html"">Delayer</a> which
 * delays processing the exchange until the correct amount of time has elapsed
 * using an expression to determine the delivery time. <p/> For example if you
 * wish to delay JMS messages by 25 seconds from their publish time you could
 * create an instance of this class with the expression
 * <code>header(""JMSTimestamp"")</code> and a delay value of 25000L.
 * 
 * @version $Revision: 1.1 $
 */
public class Delayer extends DelayProcessorSupport {
    private Expression<Exchange> timeExpression;
    private long delay;
    public Delayer(Processor processor, Expression<Exchange> timeExpression, long delay) {
        super(processor);
        this.timeExpression = timeExpression;
        this.delay = delay;
    }
    @Override
    public String toString() {
        return ""Delayer[on: "" + timeExpression + "" delay: "" + delay + "" to: "" + getProcessor() + ""]"";
    }
    // Properties
    // -------------------------------------------------------------------------
    public long getDelay() {
        return delay;
    }
    /**
     * Sets the delay from the publish time; which is typically the time from
     * the expression or the current system time if none is available
     */
    public void setDelay(long delay) {
        this.delay = delay;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Waits for an optional time period before continuing to process the
     * exchange
     */
    protected void delay(Exchange exchange) throws Exception {
        long time = 0;
        if (timeExpression != null) {
            Long longValue = ExpressionHelper.evaluateAsType(timeExpression, exchange, Long.class);
            if (longValue != null) {
                time = longValue.longValue();
            }
        }
        if (time <= 0) {
            time = defaultProcessTime(exchange);
        }
        time += delay;
        waitUntil(time, exchange);
    }
    /**
     * A Strategy Method to allow derived implementations to decide the current
     * system time or some other default exchange property
     * 
     * @param exchange
     */
    protected long defaultProcessTime(Exchange exchange) {
        return currentSystemTime();
    }
}
"
org.apache.camel.processor.DelayerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class DelayerTest extends ContextTestSupport {
    public void testSendingMessageGetsDelayed() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(0);
        template.sendBodyAndHeader(""seda:a"", ""<hello>world!</hello>"", ""JMSTimestamp"", System
            .currentTimeMillis());
        resultEndpoint.assertIsSatisfied();
        // now if we wait a bit longer we should receive the message!
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: ex
                from(""seda:a"").delayer(header(""JMSTimestamp""), 3000).to(""mock:result"");
                // END SNIPPET: ex
            }
        };
    }
}
"
org.apache.camel.processor.DelayProcessorSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.AlreadyStoppedException;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A useful base class for any processor which provides some kind of throttling
 * or delayed processing
 * 
 * @version $Revision: $
 */
public abstract class DelayProcessorSupport extends DelegateProcessor {
    private static final transient Log LOG = LogFactory.getLog(Delayer.class);
    private CountDownLatch stoppedLatch = new CountDownLatch(1);
    private boolean fastStop = true;
    public DelayProcessorSupport(Processor processor) {
        super(processor);
    }
    public void process(Exchange exchange) throws Exception {
        delay(exchange);
        super.process(exchange);
    }
    public boolean isFastStop() {
        return fastStop;
    }
    /**
     * Enables & disables a fast stop; basically to avoid waiting a possibly
     * long time for delays to complete before the context shuts down; instead
     * the current processing method throws
     * {@link org.apache.camel.AlreadyStoppedException} to terminate processing.
     */
    public void setFastStop(boolean fastStop) {
        this.fastStop = fastStop;
    }
    protected void doStop() throws Exception {
        stoppedLatch.countDown();
        super.doStop();
    }
    protected abstract void delay(Exchange exchange) throws Exception;
    /**
     * Wait until the given system time before continuing
     * 
     * @param time the system time to wait for
     * @param exchange the exchange being processed
     */
    protected void waitUntil(long time, Exchange exchange) throws Exception {
        while (true) {
            long delay = time - currentSystemTime();
            if (delay < 0) {
                return;
            } else {
                if (isFastStop() && !isRunAllowed()) {
                    throw new AlreadyStoppedException();
                }
                try {
                    sleep(delay);
                } catch (InterruptedException e) {
                    handleSleepInteruptedException(e);
                }
            }
        }
    }
    protected void sleep(long delay) throws InterruptedException {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Sleeping for: "" + delay + "" millis"");
        }
        if (isFastStop()) {
            stoppedLatch.await(delay, TimeUnit.MILLISECONDS);
        } else {
            Thread.sleep(delay);
        }
    }
    /**
     * Called when a sleep is interupted; allows derived classes to handle this
     * case differently
     */
    protected void handleSleepInteruptedException(InterruptedException e) {
        LOG.debug(""Sleep interupted: "" + e, e);
    }
    protected long currentSystemTime() {
        return System.currentTimeMillis();
    }
}
"
org.apache.camel.processor.DelegateAsyncProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Service;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.Policy;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.ServiceHelper;
/**
 * A Delegate pattern which delegates processing to a nested AsyncProcessor which can
 * be useful for implementation inheritance when writing an {@link Policy}
 */
public class DelegateAsyncProcessor extends ServiceSupport implements AsyncProcessor {
    protected AsyncProcessor processor;
    public DelegateAsyncProcessor() {
    }
    public DelegateAsyncProcessor(AsyncProcessor processor) {
        this.processor = processor;
    }
    @Override
    public String toString() {
        return ""Delegate("" + processor + "")"";
    }
    public AsyncProcessor getProcessor() {
        return processor;
    }
    public void setProcessor(AsyncProcessor processor) {
        this.processor = processor;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        return processor.process(exchange, callback);
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
}
"
org.apache.camel.processor.DelegateProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.spi.Policy;
import org.apache.camel.util.ServiceHelper;
/**
 * A Delegate pattern which delegates processing to a nested processor which can
 * be useful for implementation inheritance when writing an {@link Policy}
 * 
 * @version $Revision: 519941 $
 */
public class DelegateProcessor extends ServiceSupport implements Processor {
    protected Processor processor;
    public DelegateProcessor() {
    }
    public DelegateProcessor(Processor processor) {
        this.processor = processor;
    }
    public void process(Exchange exchange) throws Exception {
        processNext(exchange);
    }
    protected void processNext(Exchange exchange) throws Exception {
        if (processor != null) {
            processor.process(exchange);
        }
    }
    @Override
    public String toString() {
        return ""Delegate("" + processor + "")"";
    }
    public Processor getProcessor() {
        return processor;
    }
    public void setProcessor(Processor processor) {
        this.processor = processor;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
    /**
     * Proceed with the underlying delegated processor
     */
    public void proceed(Exchange exchange) throws Exception {
        processNext(exchange);
    }
}
"
org.apache.camel.processor.ErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Processor;
/**
 * An interface used to represent an error handler
 *
 * @version $Revision: 563607 $
 */
public interface ErrorHandler extends Processor {
}
"
org.apache.camel.processor.ErrorHandlerSupport,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.ExceptionType;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
/**
 * @version $Revision: 1.1 $
 */
public abstract class ErrorHandlerSupport extends ServiceSupport implements ErrorHandler {
    private Map<Class, ExceptionType> exceptionPolicices = new IdentityHashMap<Class, ExceptionType>();
    public void addExceptionPolicy(ExceptionType exception) {
        Processor processor = exception.getErrorHandler();
        addChildService(processor);
        List<Class> list = exception.getExceptionClasses();
        for (Class exceptionType : list) {
            exceptionPolicices.put(exceptionType, exception);
        }
    }
    /**
     * Attempts to invoke the handler for this particular exception if one is available
     *
     * @param exchange
     * @param exception
     * @return
     */
    protected boolean customProcessorForException(Exchange exchange, Throwable exception) throws Exception {
        ExceptionType policy = getExceptionPolicy(exchange, exception);
        Processor processor = policy.getErrorHandler();
        if (processor != null) {
            processor.process(exchange);
            return true;
        }
        return false;
    }
    protected ExceptionType getExceptionPolicy(Exchange exchange, Throwable exception) {
        Set<Map.Entry<Class, ExceptionType>> entries = exceptionPolicices.entrySet();
        for (Map.Entry<Class, ExceptionType> entry : entries) {
            Class type = entry.getKey();
            if (type.isInstance(exception)) {
                return entry.getValue();
            }
        }
        return null;
    }
}
"
org.apache.camel.processor.FaultRouteTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Message;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import java.util.List;
/**
 * @version $Revision: 1.1 $
 */
public class FaultRouteTest extends ContextTestSupport {
    protected MockEndpoint a;
    protected MockEndpoint b;
    protected MockEndpoint c;
    protected boolean shouldWork = true;
    public void testWithOut() throws Exception {
        a.whenExchangeReceived(1, new Processor() {
			public void process(Exchange exchange) throws Exception {
				exchange.getOut().setBody(""out"");
			}
        });
        a.expectedMessageCount(1);
        b.expectedBodiesReceived(""out"");
        c.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""in"");
        MockEndpoint.assertIsSatisfied(a, b, c);
    }
    public void testWithFault() throws Exception {
        shouldWork = false;
        a.whenExchangeReceived(1, new Processor() {
			public void process(Exchange exchange) throws Exception {
				exchange.getFault().setBody(""fault"");
			}
        });
        a.expectedMessageCount(1);
        b.expectedMessageCount(0);
        c.expectedMessageCount(0);
        template.sendBody(""direct:start"", ""in"");
        MockEndpoint.assertIsSatisfied(a, b, c);
        // TODO wrap up as an expecation on the mock endpoint
        List<Exchange> list = a.getReceivedExchanges();
        Exchange exchange = list.get(0);
        Message fault = exchange.getFault();
        assertNotNull(""Should have a fault on A"", fault);
        assertEquals(""Fault body"", ""fault"", fault.getBody());
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = resolveMandatoryEndpoint(""mock:a"", MockEndpoint.class);
        b = resolveMandatoryEndpoint(""mock:b"", MockEndpoint.class);
        c = resolveMandatoryEndpoint(""mock:c"", MockEndpoint.class);
    }
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() {
                from(""direct:start"")
                        .to(""mock:a"")
                        .to(""mock:b"");
            }
        };
    }
}
"
org.apache.camel.processor.FilterProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
/**
 * @version $Revision: 563607 $
 */
public class FilterProcessor extends DelegateProcessor {
    private Predicate<Exchange> predicate;
    public FilterProcessor(Predicate<Exchange> predicate, Processor processor) {
        super(processor);
        this.predicate = predicate;
    }
    public void process(Exchange exchange) throws Exception {
        if (predicate.matches(exchange)) {
            super.process(exchange);
        }
    }
    @Override
    public String toString() {
        return ""Filter[if: "" + predicate + "" do: "" + getProcessor() + ""]"";
    }
    public Predicate<Exchange> getPredicate() {
        return predicate;
    }
}
"
org.apache.camel.processor.FilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class FilterTest extends ContextTestSupport {
    public void testSendMatchingMessage() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<matched/>"", ""foo"", ""bar"");
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(0);
        template.sendBodyAndHeader(""direct:start"", ""<notMatched/>"", ""foo"", ""notMatchedHeaderValue"");
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").filter(header(""foo"").isEqualTo(""bar"")).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.IdempotentConsumerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.processor.idempotent.MemoryMessageIdRepository.memoryMessageIdRepository;
/**
 * @version $Revision: 1.1 $
 */
public class IdempotentConsumerTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testDuplicateMessagesAreFilteredOut() throws Exception {
        resultEndpoint.expectedBodiesReceived(""one"", ""two"", ""three"");
        sendMessage(""1"", ""one"");
        sendMessage(""2"", ""two"");
        sendMessage(""1"", ""one"");
        sendMessage(""2"", ""two"");
        sendMessage(""1"", ""one"");
        sendMessage(""3"", ""three"");
        resultEndpoint.assertIsSatisfied();
    }
    protected void sendMessage(final Object messageId, final Object body) {
        template.send(startEndpoint, new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(""messageId"", messageId);
            }
        });
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:start"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").idempotentConsumer(
                        header(""messageId""), memoryMessageIdRepository(200)
                ).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.Interceptor,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.camel.util.ServiceHelper;
/**
 * An interceptor which provides the processing logic as a pluggable processor
 * which allows the {@link #proceed(Exchange)} method to be called at some point
 *
 * @version $Revision: 1.1 $
 */
public class Interceptor extends DelegateProcessor {
    private Processor interceptorLogic;
    public Interceptor() {
    }
    public Interceptor(Processor interceptorLogic) {
        this.interceptorLogic = interceptorLogic;
    }
    public void process(Exchange exchange) throws Exception {
        interceptorLogic.process(exchange);
    }
    public Processor getInterceptorLogic() {
        return interceptorLogic;
    }
    public void setInterceptorLogic(Processor interceptorLogic) {
        this.interceptorLogic = interceptorLogic;
    }
    @Override
    protected void doStart() throws Exception {
        ServiceHelper.startService(interceptorLogic);
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        ServiceHelper.stopService(interceptorLogic);
        super.doStop();
    }
}
"
org.apache.camel.processor.InterceptRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied;
/**
 * @version $Revision: 1.1 $
 */
public class InterceptRouteTest extends ContextTestSupport {
    private MockEndpoint a;
    private MockEndpoint b;
    public void testSendMatchingMessage() throws Exception {
        b.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<matched/>"", ""foo"", ""bar"");
        assertMockEndpointsSatisifed();
    }
    public void testSendNotMatchingMessage() throws Exception {
        a.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<notMatched/>"", ""foo"", ""notMatchedHeaderValue"");
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = getMockEndpoint(""mock:a"");
        b = getMockEndpoint(""mock:b"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept().choice().
                        when(header(""foo"").isEqualTo(""bar"")).to(""mock:b"").
                        otherwise().proceed();
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
}
"
org.apache.camel.processor.InterceptWithoutProceedRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied;
/**
 * @version $Revision: 1.1 $
 */
public class InterceptWithoutProceedRouteTest extends ContextTestSupport {
    private MockEndpoint a;
    private MockEndpoint b;
    public void testSendMatchingMessage() throws Exception {
        b.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<matched/>"", ""foo"", ""bar"");
        assertMockEndpointsSatisifed();
    }
    public void testSendNotMatchingMessage() throws Exception {
        template.sendBodyAndHeader(""direct:start"", ""<notMatched/>"", ""foo"", ""notMatchedHeaderValue"");
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = getMockEndpoint(""mock:a"");
        b = getMockEndpoint(""mock:b"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // we will disable the output to 'mock:a' since we never proceed()
                intercept().filter(header(""foo"").isEqualTo(""bar"")).to(""mock:b"");
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
}
"
org.apache.camel.processor.InterceptWithPredicateAndProceedRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied;
/**
 * @version $Revision: 1.1 $
 */
public class InterceptWithPredicateAndProceedRouteTest extends ContextTestSupport {
    private MockEndpoint a;
    private MockEndpoint b;
    public void testSendMatchingMessage() throws Exception {
        a.expectedMessageCount(1);
        b.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<matched/>"", ""foo"", ""bar"");
        assertMockEndpointsSatisifed();
    }
    public void testSendNotMatchingMessage() throws Exception {
        a.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<notMatched/>"", ""foo"", ""notMatchedHeaderValue"");
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = getMockEndpoint(""mock:a"");
        b = getMockEndpoint(""mock:b"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept(header(""foo"").isEqualTo(""bar"")).to(""mock:b"").proceed();
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
}
"
org.apache.camel.processor.InterceptWithPredicateRouteTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied;
/**
 * @version $Revision: 1.1 $
 */
public class InterceptWithPredicateRouteTest extends ContextTestSupport {
    private MockEndpoint a;
    private MockEndpoint b;
    public void testSendMatchingMessage() throws Exception {
        b.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<matched/>"", ""foo"", ""bar"");
        assertMockEndpointsSatisifed();
    }
    public void testSendNotMatchingMessage() throws Exception {
        a.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<notMatched/>"", ""foo"", ""notMatchedHeaderValue"");
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = getMockEndpoint(""mock:a"");
        b = getMockEndpoint(""mock:b"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                intercept(header(""foo"").isEqualTo(""bar"")).to(""mock:b"");
                from(""direct:start"").to(""mock:a"");
            }
        };
    }
}
"
org.apache.camel.processor.JoinRoutesTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class JoinRoutesTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testMessagesThroughDifferentRoutes() throws Exception {
        resultEndpoint.expectedBodiesReceived(""one"", ""two"", ""three"");
        sendMessage(""bar"", ""one"");
        sendMessage(""cheese"", ""two"");
        sendMessage(""somethingUndefined"", ""three"");
        resultEndpoint.assertIsSatisfied();
    }
    protected void sendMessage(final Object headerValue, final Object body) throws Exception {
        template.send(startEndpoint, new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(""foo"", headerValue);
            }
        });
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:a"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").choice()
                        .when(header(""foo"").isEqualTo(""bar"")).to(""direct:b"")
                        .when(header(""foo"").isEqualTo(""cheese"")).to(""direct:c"")
                        .otherwise().to(""direct:d"");
                from(""direct:b"").to(""mock:result"");
                from(""direct:c"").to(""mock:result"");
                from(""direct:d"").to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.Logger,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A {@link Processor} which just logs to a {@link Log} object which can be used
 * as an exception handler instead of using a dead letter queue.
 * 
 * @version $Revision: 563607 $
 */
public class Logger implements Processor {
    private Log log;
    private LoggingLevel level;
    public Logger() {
        this(LogFactory.getLog(Logger.class));
    }
    public Logger(Log log) {
        this(log, LoggingLevel.INFO);
    }
    public Logger(Log log, LoggingLevel level) {
        this.log = log;
        this.level = level;
    }
    public Logger(String logName) {
        this(LogFactory.getLog(logName));
    }
    public Logger(String logName, LoggingLevel level) {
        this(LogFactory.getLog(logName), level);
    }
    @Override
    public String toString() {
        return ""Logger["" + log + ""]"";
    }
    public void process(Exchange exchange) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(logMessage(exchange));
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(logMessage(exchange));
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(logMessage(exchange));
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.info(logMessage(exchange));
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(logMessage(exchange));
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(logMessage(exchange));
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + logMessage(exchange));
        }
    }
    public void log(String message) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(message);
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(message);
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(message);
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.debug(message);
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(message);
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(message);
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + message);
        }
    }
    public void log(String message, Throwable exception) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(message, exception);
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(message, exception);
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(message, exception);
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.debug(message, exception);
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(message, exception);
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(message, exception);
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + message, exception);
        }
    }
    protected Object logMessage(Exchange exchange) {
        return exchange;
    }
    public Log getLog() {
        return log;
    }
    public void setLog(Log log) {
        this.log = log;
    }
    public LoggingLevel getLevel() {
        return level;
    }
    public void setLevel(LoggingLevel level) {
        this.level = level;
    }
}
"
org.apache.camel.processor.LoggingErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An {@link ErrorHandler} which uses commons-logging to dump the error
 * 
 * @version $Revision: 564295 $
 */
public class LoggingErrorHandler extends ErrorHandlerSupport {
    private Processor output;
    private Log log;
    private LoggingLevel level;
    public LoggingErrorHandler(Processor output) {
        this(output, LogFactory.getLog(LoggingErrorHandler.class), LoggingLevel.INFO);
    }
    public LoggingErrorHandler(Processor output, Log log, LoggingLevel level) {
        this.output = output;
        this.log = log;
        this.level = level;
    }
    @Override
    public String toString() {
        return ""LoggingErrorHandler["" + output + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        try {
            output.process(exchange);
        } catch (Throwable e) {
            if (!customProcessorForException(exchange, e)) {
                logError(exchange, e);
            }
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    /**
     * Returns the output processor
     */
    public Processor getOutput() {
        return output;
    }
    public LoggingLevel getLevel() {
        return level;
    }
    public void setLevel(LoggingLevel level) {
        this.level = level;
    }
    public Log getLog() {
        return log;
    }
    public void setLog(Log log) {
        this.log = log;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void logError(Exchange exchange, Throwable e) {
        switch (level) {
        case DEBUG:
            if (log.isDebugEnabled()) {
                log.debug(logMessage(exchange, e), e);
            }
            break;
        case ERROR:
            if (log.isErrorEnabled()) {
                log.error(logMessage(exchange, e), e);
            }
            break;
        case FATAL:
            if (log.isFatalEnabled()) {
                log.fatal(logMessage(exchange, e), e);
            }
            break;
        case INFO:
            if (log.isInfoEnabled()) {
                log.debug(logMessage(exchange, e), e);
            }
            break;
        case TRACE:
            if (log.isTraceEnabled()) {
                log.trace(logMessage(exchange, e), e);
            }
            break;
        case WARN:
            if (log.isWarnEnabled()) {
                log.warn(logMessage(exchange, e), e);
            }
            break;
        default:
            log.error(""Unknown level: "" + level + "" when trying to log exchange: "" + logMessage(exchange, e),
                      e);
        }
    }
    protected Object logMessage(Exchange exchange, Throwable e) {
        return e + "" while processing exchange: "" + exchange;
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(output);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(output);
    }
}
"
org.apache.camel.processor.LoggingLevel,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
/**
 * Used to configure the logging levels
 *
 * @version $Revision: 563607 $
 */
public enum LoggingLevel {
    DEBUG, ERROR, FATAL, INFO, TRACE, WARN;
}
"
org.apache.camel.processor.MarshalProcessor,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.ByteArrayOutputStream;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Message;
import org.apache.camel.spi.DataFormat;
/**
 * Marshals the body of the incoming message using the given
 * <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 *
 * @version $Revision: 1.1 $
 */
public class MarshalProcessor implements Processor {
    private final DataFormat dataFormat;
    public MarshalProcessor(DataFormat dataFormat) {
        this.dataFormat = dataFormat;
    }
    public void process(Exchange exchange) throws Exception {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        Message in = exchange.getIn();
        Object body = in.getBody();
        // lets setup the out message before we invoke the dataFormat
        // so that it can mutate it if necessary
        Message out = exchange.getOut(true);
        out.copyFrom(in);
        dataFormat.marshal(exchange, body, buffer);
        byte[] data = buffer.toByteArray();
        out.setBody(data);
    }
}
"
org.apache.camel.processor.MulticastProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.ArrayList;
import java.util.Collection;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * Implements the Multicast pattern to send a message exchange to a number of
 * endpoints, each endpoint receiving a copy of the message exchange.
 * 
 * @see Pipeline
 * @version $Revision: 563607 $
 */
public class MulticastProcessor extends ServiceSupport implements Processor {
    private Collection<Processor> processors;
    public MulticastProcessor(Collection<Processor> processors) {
        this.processors = processors;
    }
    /**
     * A helper method to convert a list of endpoints into a list of processors
     */
    public static <E extends Exchange> Collection<Processor> toProducers(Collection<Endpoint> endpoints)
        throws Exception {
        Collection<Processor> answer = new ArrayList<Processor>();
        for (Endpoint endpoint : endpoints) {
            answer.add(endpoint.createProducer());
        }
        return answer;
    }
    @Override
    public String toString() {
        return ""Multicast"" + getProcessors();
    }
    public void process(Exchange exchange) throws Exception {
        for (Processor producer : processors) {
            Exchange copy = copyExchangeStrategy(producer, exchange);
            producer.process(copy);
        }
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processors);
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processors);
    }
    /**
     * Returns the producers to multicast to
     */
    public Collection<Processor> getProcessors() {
        return processors;
    }
    /**
     * Strategy method to copy the exchange before sending to another endpoint.
     * Derived classes such as the {@link Pipeline} will not clone the exchange
     * 
     * @param processor the processor that will send the exchange
     * @param exchange
     * @return the current exchange if no copying is required such as for a
     *         pipeline otherwise a new copy of the exchange is returned.
     */
    protected Exchange copyExchangeStrategy(Processor processor, Exchange exchange) {
        return exchange.copy();
    }
}
"
org.apache.camel.processor.MulticastTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied;
/**
 * @version $Revision: 1.1 $
 */
public class MulticastTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint x;
    protected MockEndpoint y;
    protected MockEndpoint z;
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        x.expectedBodiesReceived(""input+output"");
        y.expectedBodiesReceived(""input+output"");
        z.expectedBodiesReceived(""input+output"");
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""input"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        assertMockEndpointsSatisifed();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        x = getMockEndpoint(""mock:x"");
        y = getMockEndpoint(""mock:y"");
        z = getMockEndpoint(""mock:z"");
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                // lets transform the IN message
                Message in = exchange.getIn();
                String body = in.getBody(String.class);
                in.setBody(body + ""+output"");
            }
        };
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").multicast().to(""direct:x"", ""direct:y"", ""direct:z"");
                // END SNIPPET: example
                from(""direct:x"").process(processor).to(""mock:x"");
                from(""direct:y"").process(processor).to(""mock:y"");
                from(""direct:z"").process(processor).to(""mock:z"");
            }
        };
    }
}
"
org.apache.camel.processor.MyValidator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
/**
 * @version $Revision: 1.1 $
 */
public class MyValidator implements Processor {
    public void process(Exchange exchange) throws Exception {
        Object value = exchange.getIn().getHeader(""foo"");
        if (value == null || !value.equals(""bar"")) {
            throw new ValidationException(exchange, ""The foo header does not equal bar! Was: "" + value);
        }
    }
}
"
org.apache.camel.processor.Pipeline,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
/**
 * Creates a Pipeline pattern where the output of the previous step is sent as
 * input to the next step, reusing the same message exchanges
 *
 * @version $Revision: 576508 $
 */
public class Pipeline extends MulticastProcessor implements AsyncProcessor {
    private static final transient Log LOG = LogFactory.getLog(Pipeline.class);
    public Pipeline(Collection<Processor> processors) {
        super(processors);
    }
    public static Processor newInstance(List<Processor> processors) {
        if (processors.isEmpty()) {
            return null;
        } else if (processors.size() == 1) {
            return processors.get(0);
        }
        return new Pipeline(processors);
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(Exchange original, AsyncCallback callback) {
        Iterator<Processor> processors = getProcessors().iterator();
        Exchange nextExchange = original;
        boolean first = true;
        while (true) {
            if (nextExchange.isFailed()) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Mesage exchange has failed so breaking out of pipeline: "" + nextExchange + "" exception: "" + nextExchange.getException() + "" fault: "" + nextExchange.getFault(false));
                }
                break;
            }
            if (!processors.hasNext()) {
                break;
            }
            AsyncProcessor processor = AsyncProcessorTypeConverter.convert(processors.next());
            if (first) {
                first = false;
            } else {
                nextExchange = createNextExchange(processor, nextExchange);
            }
            boolean sync = process(original, nextExchange, callback, processors, processor);
            // Continue processing the pipeline synchronously ...
            if (!sync) {
                // The pipeline will be completed async...
                return false;
            }
        }
        // If we get here then the pipeline was processed entirely
        // synchronously.
        ExchangeHelper.copyResults(original, nextExchange);
        callback.done(true);
        return true;
    }
    private boolean process(final Exchange original, final Exchange exchange, final AsyncCallback callback, final Iterator<Processor> processors, AsyncProcessor processor) {
        return processor.process(exchange, new AsyncCallback() {
            public void done(boolean sync) {
                // We only have to handle async completion of
                // the pipeline..
                if (sync) {
                    return;
                }
                // Continue processing the pipeline...
                Exchange nextExchange = exchange;
                while (processors.hasNext()) {
                    AsyncProcessor processor = AsyncProcessorTypeConverter.convert(processors.next());
                    if (nextExchange.isFailed()) {
                        if (LOG.isDebugEnabled()) {
                            LOG.debug(""Mesage exchange has failed so breaking out of pipeline: "" + nextExchange + "" exception: "" + nextExchange.getException() + "" fault: ""
                                      + nextExchange.getFault(false));
                        }
                        break;
                    }
                    nextExchange = createNextExchange(processor, exchange);
                    sync = process(original, nextExchange, callback, processors, processor);
                    if (!sync) {
                        return;
                    }
                }
                ExchangeHelper.copyResults(original, nextExchange);
                callback.done(false);
            }
        });
    }
    /**
     * Strategy method to create the next exchange from the
     *
     * @param producer the producer used to send to the endpoint
     * @param previousExchange the previous exchange
     * @return a new exchange
     */
    protected Exchange createNextExchange(Processor producer, Exchange previousExchange) {
        Exchange answer = copyExchangeStrategy(previousExchange);
        // now lets set the input of the next exchange to the output of the
        // previous message if it is not null
        Message previousOut = previousExchange.getOut(false);
        Object output = previousOut != null ? previousOut.getBody() : null;
        Message in = answer.getIn();
        if (output != null) {
            in.setBody(output);
            Set<Map.Entry<String,Object>> entries = previousOut.getHeaders().entrySet();
            for (Map.Entry<String, Object> entry : entries) {
                in.setHeader(entry.getKey(), entry.getValue());
            }
        }
        else {
            Object previousInBody = previousExchange.getIn().getBody();
            if (in.getBody() == null && previousInBody != null) {
                LOG.warn(""Bad exchange implementation; the copy() method did not copy across the in body: "" + previousExchange
                        + "" of type: "" + previousExchange.getClass());
                in.setBody(previousInBody);
            }
        }
        return answer;
    }
    /**
     * Strategy method to copy the exchange before sending to another endpoint.
     * Derived classes such as the {@link Pipeline} will not clone the exchange
     *
     * @param exchange
     * @return the current exchange if no copying is required such as for a
     *         pipeline otherwise a new copy of the exchange is returned.
     */
    protected Exchange copyExchangeStrategy(Exchange exchange) {
        return exchange.copy();
    }
    @Override
    public String toString() {
        return ""Pipeline"" + getProcessors();
    }
}
"
org.apache.camel.processor.PipelineTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class PipelineTest extends ContextTestSupport {
    /**
     * Simple processor the copies the in to the out and increments a counter.
     * Used to verify that the pipeline actually takes the output of one stage of 
     * the pipe and feeds it in as input into the next stage.
     */
    private final class InToOut implements Processor {
        public void process(Exchange exchange) throws Exception {            
            exchange.getOut(true).copyFrom(exchange.getIn());
            Integer counter = exchange.getIn().getHeader(""copy-counter"", Integer.class);
            if (counter == null) {
                counter = 0;
            }
            exchange.getOut().setHeader(""copy-counter"", counter + 1);
        }
    }
    /**
     * Simple processor the copies the in to the fault and increments a counter.
     */
    private final class InToFault implements Processor {
        public void process(Exchange exchange) throws Exception {
            exchange.getFault(true).setBody(exchange.getIn().getBody());
            Integer counter = exchange.getIn().getHeader(""copy-counter"", Integer.class);
            if (counter == null) {
                counter = 0;
            }
            exchange.getFault().setHeader(""copy-counter"", counter + 1);
        }
    }
    protected MockEndpoint resultEndpoint;
    public void testSendMessageThroughAPipeline() throws Exception {
        resultEndpoint.expectedBodiesReceived(4);
        Exchange results = template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(1);
                in.setHeader(""foo"", ""bar"");
            }
        });
        resultEndpoint.assertIsSatisfied();
        assertEquals(""Result body"", 4, results.getOut().getBody());
    }
    public void testResultsReturned() throws Exception {
        Exchange exchange = template.send(""direct:b"", new Processor() {
            public void process(Exchange exchange) {
                exchange.getIn().setBody(""Hello World"");
            }
        });
        assertEquals(""Hello World"", exchange.getOut().getBody());
        assertEquals(3, exchange.getOut().getHeader(""copy-counter""));        
    }
    /**
     * Disabled for now until we figure out fault processing in the pipeline.
     * 
     * @throws Exception
     */
    public void testFaultStopsPipeline() throws Exception {
        Exchange exchange = template.send(""direct:c"", new Processor() {
            public void process(Exchange exchange) {
                exchange.getIn().setBody(""Fault Message"");
            }
        });
        // Check the fault..
        assertEquals(""Fault Message"", exchange.getFault().getBody());
        assertEquals(2, exchange.getFault().getHeader(""copy-counter""));        
        // Check the out Message.. It should have only been processed once.
        // since the fault should stop it from going to the next process.
        assertEquals(1, exchange.getOut().getHeader(""copy-counter""));                
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                Integer number = exchange.getIn().getBody(Integer.class);
                if (number == null) {
                    number = 0;
                }
                // todo set the endpoint name we were received from
                //exchange.setProperty(exchange.get);
                number = number + 1;
                exchange.getOut().setBody(number);
            }
        };
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").pipeline(""direct:x"", ""direct:y"", ""direct:z"", ""mock:result"");
                // END SNIPPET: example
                from(""direct:x"").process(processor);
                from(""direct:y"").process(processor);
                from(""direct:z"").process(processor);
                // Create a route that uses the  InToOut processor 3 times. the copy-counter header should be == 3
                from(""direct:b"").process(new InToOut()).process(new InToOut()).process(new InToOut());
                // Create a route that uses the  InToFault processor.. the last InToOut will not be called since the Fault occurs before.
                from(""direct:c"").process(new InToOut()).process(new InToFault()).process(new InToOut());
            }
        };
    }
}
"
org.apache.camel.processor.ProceedProcessor,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Processor;
import org.apache.camel.Exchange;
import org.apache.camel.processor.Interceptor;
/**
 * A {@link Processor} which proceeds on an {@link Interceptor}
 *
 * @version $Revision: 1.1 $
 */
public class ProceedProcessor implements Processor {
    private final Interceptor interceptor;
    public ProceedProcessor(Interceptor interceptor) {
        this.interceptor = interceptor;
    }
    public String toString() {
        return ""Proceed["" + interceptor + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        interceptor.proceed(exchange);
    }
}
"
org.apache.camel.processor.RecipientList,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.AsyncCallback;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ExchangeHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
import org.apache.camel.util.ProducerCache;
/**
 * Implements a dynamic <a
 * href=""http://activemq.apache.org/camel/recipient-list.html"">Recipient List</a>
 * pattern where the list of actual endpoints to send a message exchange to are
 * dependent on some dynamic expression.
 * 
 * @version $Revision: 574469 $
 */
public class RecipientList extends ServiceSupport implements Processor {
    private final Expression<Exchange> expression;
    private ProducerCache<Exchange> producerCache = new ProducerCache<Exchange>();
    public RecipientList(Expression<Exchange> expression) {
        notNull(expression, ""expression"");
        this.expression = expression;
    }
    @Override
    public String toString() {
        return ""RecipientList["" + expression + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        Object receipientList = expression.evaluate(exchange);
        Iterator iter = ObjectConverter.iterator(receipientList);
        List<Processor> processors = new ArrayList<Processor>();
        while (iter.hasNext()) {
            Object recipient = iter.next();
            Endpoint<Exchange> endpoint = resolveEndpoint(exchange, recipient);
            Producer<Exchange> producer = producerCache.getProducer(endpoint);
            processors.add(producer);
        }
        // TODO we could support a multicast option?
        Pipeline pipeline = new Pipeline(processors);
        pipeline.process(exchange);
    }
    protected Endpoint<Exchange> resolveEndpoint(Exchange exchange, Object recipient) {
        return ExchangeHelper.resolveEndpoint(exchange, recipient);
    }
    protected void doStop() throws Exception {
        producerCache.stop();
    }
    protected void doStart() throws Exception {
    }
}
"
org.apache.camel.processor.RecipientListTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class RecipientListTest extends ContextTestSupport {
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        MockEndpoint x = getMockEndpoint(""mock:x"");
        MockEndpoint y = getMockEndpoint(""mock:y"");
        MockEndpoint z = getMockEndpoint(""mock:z"");
        x.expectedBodiesReceived(""answer"");
        y.expectedBodiesReceived(""answer"");
        z.expectedBodiesReceived(""answer"");
        template.sendBodyAndHeader(""direct:a"", ""answer"", ""recipientListHeader"", ""mock:x,mock:y,mock:z"");
        assertMockEndpointsSatisifed();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").recipientList(header(""recipientListHeader"").tokenize("",""));
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.RedeliveryPolicy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.Serializable;
import java.util.Random;
// Code taken from the ActiveMQ codebase
/**
 * The policy used to decide how many times to redeliver and the time between
 * the redeliveries before being sent to a <a
 * href=""http://activemq.apache.org/camel/dead-letter-channel.html"">Dead Letter
 * Channel</a>
 * 
 * @version $Revision: 565361 $
 */
public class RedeliveryPolicy implements Cloneable, Serializable {
    protected static transient Random randomNumberGenerator;
    protected int maximumRedeliveries = 6;
    protected long initialRedeliveryDelay = 1000L;
    protected double backOffMultiplier = 2;
    protected boolean useExponentialBackOff;
    // +/-15% for a 30% spread -cgs
    protected double collisionAvoidanceFactor = 0.15d;
    protected boolean useCollisionAvoidance;
    public RedeliveryPolicy() {
    }
    @Override
    public String toString() {
        return ""RedeliveryPolicy[maximumRedeliveries="" + maximumRedeliveries + ""]"";
    }
    public RedeliveryPolicy copy() {
        try {
            return (RedeliveryPolicy)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(""Could not clone: "" + e, e);
        }
    }
    /**
     * Returns true if the policy decides that the message exchange should be
     * redelivered
     */
    public boolean shouldRedeliver(int redeliveryCounter) {
        return redeliveryCounter < getMaximumRedeliveries();
    }
    // Builder methods
    // -------------------------------------------------------------------------
    /**
     * Sets the maximum number of times a message exchange will be redelivered
     */
    public RedeliveryPolicy maximumRedeliveries(int maximumRedeliveries) {
        setMaximumRedeliveries(maximumRedeliveries);
        return this;
    }
    /**
     * Sets the initial redelivery delay in milliseconds on the first redelivery
     */
    public RedeliveryPolicy initialRedeliveryDelay(long initialRedeliveryDelay) {
        setInitialRedeliveryDelay(initialRedeliveryDelay);
        return this;
    }
    /**
     * Enables collision avoidence which adds some randomization to the backoff
     * timings to reduce contention probability
     */
    public RedeliveryPolicy useCollisionAvoidance() {
        setUseCollisionAvoidance(true);
        return this;
    }
    /**
     * Enables exponential backof using the {@link #getBackOffMultiplier()} to
     * increase the time between retries
     */
    public RedeliveryPolicy useExponentialBackOff() {
        setUseExponentialBackOff(true);
        return this;
    }
    /**
     * Enables exponential backoff and sets the multiplier used to increase the
     * delay between redeliveries
     */
    public RedeliveryPolicy backOffMultiplier(double multiplier) {
        useExponentialBackOff();
        setBackOffMultiplier(multiplier);
        return this;
    }
    /**
     * Enables collision avoidence and sets the percentage used
     */
    public RedeliveryPolicy collisionAvoidancePercent(double collisionAvoidancePercent) {
        useCollisionAvoidance();
        setCollisionAvoidancePercent(collisionAvoidancePercent);
        return this;
    }
    // Properties
    // -------------------------------------------------------------------------
    public double getBackOffMultiplier() {
        return backOffMultiplier;
    }
    /**
     * Sets the multiplier used to increase the delay between redeliveries if
     * {@link #setUseExponentialBackOff(boolean)} is enabled
     */
    public void setBackOffMultiplier(double backOffMultiplier) {
        this.backOffMultiplier = backOffMultiplier;
    }
    public short getCollisionAvoidancePercent() {
        return (short)Math.round(collisionAvoidanceFactor * 100);
    }
    /**
     * Sets the percentage used for collision avoidence if enabled via
     * {@link #setUseCollisionAvoidance(boolean)}
     */
    public void setCollisionAvoidancePercent(double collisionAvoidancePercent) {
        this.collisionAvoidanceFactor = collisionAvoidancePercent * 0.01d;
    }
    public double getCollisionAvoidanceFactor() {
        return collisionAvoidanceFactor;
    }
    /**
     * Sets the factor used for collision avoidence if enabled via
     * {@link #setUseCollisionAvoidance(boolean)}
     */
    public void setCollisionAvoidanceFactor(double collisionAvoidanceFactor) {
        this.collisionAvoidanceFactor = collisionAvoidanceFactor;
    }
    public long getInitialRedeliveryDelay() {
        return initialRedeliveryDelay;
    }
    /**
     * Sets the initial redelivery delay in milliseconds on the first redelivery
     */
    public void setInitialRedeliveryDelay(long initialRedeliveryDelay) {
        this.initialRedeliveryDelay = initialRedeliveryDelay;
    }
    public int getMaximumRedeliveries() {
        return maximumRedeliveries;
    }
    /**
     * Sets the maximum number of times a message exchange will be redelivered
     */
    public void setMaximumRedeliveries(int maximumRedeliveries) {
        this.maximumRedeliveries = maximumRedeliveries;
    }
    public long getRedeliveryDelay(long previousDelay) {
        long redeliveryDelay;
        if (previousDelay == 0) {
            redeliveryDelay = initialRedeliveryDelay;
        } else if (useExponentialBackOff && backOffMultiplier > 1) {
            redeliveryDelay = Math.round(backOffMultiplier * previousDelay);
        } else {
            redeliveryDelay = previousDelay;
        }
        if (useCollisionAvoidance) {
            /*
             * First random determines +/-, second random determines how far to
             * go in that direction. -cgs
             */
            Random random = getRandomNumberGenerator();
            double variance = (random.nextBoolean() ? collisionAvoidanceFactor : -collisionAvoidanceFactor)
                              * random.nextDouble();
            redeliveryDelay += redeliveryDelay * variance;
        }
        return redeliveryDelay;
    }
    public boolean isUseCollisionAvoidance() {
        return useCollisionAvoidance;
    }
    /**
     * Enables/disables collision avoidence which adds some randomization to the
     * backoff timings to reduce contention probability
     */
    public void setUseCollisionAvoidance(boolean useCollisionAvoidance) {
        this.useCollisionAvoidance = useCollisionAvoidance;
    }
    public boolean isUseExponentialBackOff() {
        return useExponentialBackOff;
    }
    /**
     * Enables/disables exponential backof using the
     * {@link #getBackOffMultiplier()} to increase the time between retries
     */
    public void setUseExponentialBackOff(boolean useExponentialBackOff) {
        this.useExponentialBackOff = useExponentialBackOff;
    }
    protected static synchronized Random getRandomNumberGenerator() {
        if (randomNumberGenerator == null) {
            randomNumberGenerator = new Random();
        }
        return randomNumberGenerator;
    }
}
"
org.apache.camel.processor.RedeliveryPolicyPerExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Message;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import java.util.List;
/**
 * @version $Revision: 1.1 $
 */
public class RedeliveryPolicyPerExceptionTest extends ContextTestSupport {
    protected MockEndpoint a;
    protected MockEndpoint b;
    public void testUsingCustomExceptionHandlerAndOneRedelivery() throws Exception {
        a.expectedMessageCount(1);
        sendBody(""direct:start"", ""a"");
        MockEndpoint.assertIsSatisfied(a, b);
        List<Exchange> list = a.getReceivedExchanges();
        assertTrue(""List should not be empty!"", !list.isEmpty());
        Exchange exchange = list.get(0);
        Message in = exchange.getIn();
        log.info(""Found message with headers: "" + in.getHeaders());
        assertMessageHeader(in, DeadLetterChannel.REDELIVERY_COUNTER, 2);
        assertMessageHeader(in, DeadLetterChannel.REDELIVERED, true);
    }
    public void testUsingCustomExceptionHandlerWithNoRedeliveries() throws Exception {
        b.expectedMessageCount(1);
        sendBody(""direct:start"", ""b"");
        MockEndpoint.assertIsSatisfied(a, b);
        List<Exchange> list = b.getReceivedExchanges();
        assertTrue(""List should not be empty!"", !list.isEmpty());
        Exchange exchange = list.get(0);
        Message in = exchange.getIn();
        log.info(""Found message with headers: "" + in.getHeaders());
        assertMessageHeader(in, DeadLetterChannel.REDELIVERY_COUNTER, 1);
        assertMessageHeader(in, DeadLetterChannel.REDELIVERED, true);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        a = resolveMandatoryEndpoint(""mock:a"", MockEndpoint.class);
        b = resolveMandatoryEndpoint(""mock:b"", MockEndpoint.class);
    }
    protected RouteBuilder createRouteBuilder() {
        final Processor processor = new Processor() {
            public void process(Exchange exchange) {
                if (""b"".equals(exchange.getIn().getBody())) {
                    throw new NullPointerException(""MyCustomException"");
                }
                else {
                    throw new IllegalArgumentException(""MyCustomException"");
                }
            }
        };
        return new RouteBuilder() {
            public void configure() {
                exception(IllegalArgumentException.class).maximumRedeliveries(2).to(""mock:a"");
                exception(NullPointerException.class).to(""mock:b"");
                from(""direct:start"").process(processor);
            }
        };
    }
}
"
org.apache.camel.processor.Resequencer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.util.ExpressionComparator;
import org.apache.camel.util.ExpressionListComparator;
/**
 * An implementation of the <a href=""http://activemq.apache.org/camel/resequencer.html"">Resequencer</a>
 * which can reorder messages within a batch.
 *
 * @version $Revision: 1.1 $
 */
public class Resequencer extends BatchProcessor {
    public Resequencer(Endpoint endpoint, Processor processor, Expression<Exchange> expression) {
        this(endpoint, processor, createSet(expression));
    }
    public Resequencer(Endpoint endpoint, Processor processor, List<Expression> expressions) {
        this(endpoint, processor, createSet(expressions));
    }
    public Resequencer(Endpoint endpoint, Processor processor, Set<Exchange> collection) {
        super(endpoint, processor, collection);
    }
    @Override
    public String toString() {
        return ""Resequencer[to: "" + getProcessor() + ""]"";
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected static Set<Exchange> createSet(Expression<Exchange> expression) {
        return createSet(new ExpressionComparator<Exchange>(expression));
    }
    protected static Set<Exchange> createSet(List<Expression> expressions) {
        if (expressions.size() == 1) {
            return createSet(expressions.get(0));
        }
        return createSet(new ExpressionListComparator(expressions));
    }
    protected static Set<Exchange> createSet(Comparator<? super Exchange> comparator) {
        return new TreeSet<Exchange>(comparator);
    }
}
"
org.apache.camel.processor.ResequencerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class ResequencerTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testSendMessagesInWrongOrderButReceiveThemInCorrectOrder() throws Exception {
        resultEndpoint.expectedBodiesReceived(""Guillaume"", ""Hiram"", ""James"", ""Rob"");
        sendBodies(""direct:start"", ""Rob"", ""Hiram"", ""Guillaume"", ""James"");
        resultEndpoint.assertIsSatisfied();
        List<Exchange> list = resultEndpoint.getReceivedExchanges();
        for (Exchange exchange : list) {
            log.debug(""Received: "" + exchange);
        }
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").resequencer(body()).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.SendProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Producer;
import org.apache.camel.Service;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 570471 $
 */
public class SendProcessor extends ServiceSupport implements AsyncProcessor, Service {
    private static final transient Log LOG = LogFactory.getLog(SendProcessor.class);
    private Endpoint destination;
    private Producer producer;
    private AsyncProcessor processor;
    public SendProcessor(Endpoint destination) {
        if (destination == null) {
            throw new IllegalArgumentException(""Endpoint cannot be null!"");
        }
        this.destination = destination;
    }
    @Override
    public String toString() {
        return ""sendTo("" + destination + "")"";
    }
    public void process(Exchange exchange) throws Exception {
        if (producer == null) {
            if (isStopped()) {
                LOG.warn(""Ignoring exchange sent after processor is stopped: "" + exchange);
            } else {
                throw new IllegalStateException(""No producer, this processor has not been started!"");
            }
        } else {
            producer.process(exchange);
        }
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        if (producer == null) {
            if (isStopped()) {
                LOG.warn(""Ignoring exchange sent after processor is stopped: "" + exchange);
            } else {
                exchange.setException(new IllegalStateException(""No producer, this processor has not been started!""));
            }
            callback.done(true);
            return true;
        } else {
            return processor.process(exchange, callback);
        }
    }
    public Endpoint getDestination() {
        return destination;
    }
    protected void doStart() throws Exception {
        this.producer = destination.createProducer();
        this.producer.start();
        this.processor = AsyncProcessorTypeConverter.convert(producer);
    }
    protected void doStop() throws Exception {
        if (producer != null) {
            try {
                producer.stop();
            } finally {
                producer = null;
                processor = null;
            }
        }
    }
}
"
org.apache.camel.processor.SendToNonExistingEndpointTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.NoSuchEndpointException;
/**
 * @version $Revision: 1.1 $
 */
public class SendToNonExistingEndpointTest extends ContextTestSupport {
    public void testSendToNonExistingEndpoint() throws Exception {
        try {
            template.sendBody(""thisUriDoesNotExist"", ""<hello>world!</hello>"");
            fail(""Should have failed to send this message!"");
        } catch (NoSuchEndpointException e) {
            log.debug(""Caught expected exception: "" + e, e);
            assertEquals(""uri"", ""thisUriDoesNotExist"", e.getUri());
        }
    }
}
"
org.apache.camel.processor.SimulatorTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.InvalidPayloadException;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import static org.apache.camel.language.simple.SimpleLanguage.simple;
import org.apache.camel.util.ExchangeHelper;
/**
 * @version $Revision: 1.1 $
 */
public class SimulatorTest extends ContextTestSupport {
    public void testReceivesFooResponse() throws Exception {
        assertRespondsWith(""foo"", ""<hello>foo</hello>"");
    }
    public void testReceivesBarResponse() throws Exception {
        assertRespondsWith(""bar"", ""<hello>bar</hello>"");
    }
    protected void assertRespondsWith(final String value, String containedText) throws InvalidPayloadException {
        Exchange response = template.request(""direct:a"", new Processor() {
            public void process(Exchange exchange) throws Exception {
                Message in = exchange.getIn();
                in.setBody(""answer"");
                in.setHeader(""cheese"", value);
            }
        });
        assertNotNull(""Should receive a response!"", response);
        String text = ExchangeHelper.getMandatoryOutBody(response, String.class);
        log.info(""Received: "" + text);
        assertStringContains(text, containedText);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:a"").
                    recipientList(simple(""file:src/main/data/${in.headers.cheese}.xml""));
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.Splitter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.Iterator;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.converter.ObjectConverter;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * Implements a dynamic <a
 * href=""http://activemq.apache.org/camel/splitter.html"">Splitter</a> pattern
 * where an expression is evaluated to iterate through each of the parts of a
 * message and then each part is then send to some endpoint.
 * 
 * @version $Revision: 563607 $
 */
public class Splitter extends ServiceSupport implements Processor {
    private final Processor processor;
    private final Expression expression;
    public Splitter(Expression expression, Processor destination) {
        this.processor = destination;
        this.expression = expression;
        notNull(destination, ""destination"");
        notNull(expression, ""expression"");
    }
    @Override
    public String toString() {
        return ""Splitter[on: "" + expression + "" to: "" + processor + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        Object value = expression.evaluate(exchange);
        Iterator iter = ObjectConverter.iterator(value);
        while (iter.hasNext()) {
            Object part = iter.next();
            Exchange newExchange = exchange.copy();
            newExchange.getIn().setBody(part);
            processor.process(newExchange);
        }
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(processor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(processor);
    }
}
"
org.apache.camel.processor.SplitterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class SplitterTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        resultEndpoint.expectedBodiesReceived(""James"", ""Guillaume"", ""Hiram"", ""Rob"");
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(""James,Guillaume,Hiram,Rob"");
                in.setHeader(""foo"", ""bar"");
            }
        });
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:a"").splitter(body().tokenize("","")).to(""mock:result"");
            }
        };
    }
}
"
org.apache.camel.processor.StreamResequencer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.processor.resequencer.ResequencerEngine;
import org.apache.camel.processor.resequencer.SequenceElementComparator;
import org.apache.camel.processor.resequencer.SequenceSender;
/**
 * A resequencer that re-orders a (continuous) stream of {@link Exchange}s. The
 * algorithm implemented by {@link ResequencerEngine} is based on the detection
 * of gaps in a message stream rather than on a fixed batch size. Gap detection
 * in combination with timeouts removes the constraint of having to know the
 * number of messages of a sequence (i.e. the batch size) in advance.
 * <p>
 * Messages must contain a unique sequence number for which a predecessor and a
 * successor is known. For example a message with the sequence number 3 has a
 * predecessor message with the sequence number 2 and a successor message with
 * the sequence number 4. The message sequence 2,3,5 has a gap because the
 * sucessor of 3 is missing. The resequencer therefore has to retain message 5
 * until message 4 arrives (or a timeout occurs).
 * 
 * @author Martin Krasser
 * 
 * @version $Revision$
 */
public class StreamResequencer extends DelegateProcessor implements Processor {
    private ResequencerEngine<Exchange> reseq;
    private BlockingQueue<Exchange> queue;
    private SequenceSender sender;
    /**
     * Creates a new {@link StreamResequencer} instance.
     * 
     * @param processor
     *            the next processor that processes the re-ordered exchanges.
     * @param comparator
     *            a {@link SequenceElementComparator} for comparing sequence
     *            number contained in {@link Exchange}s.
     * @param capacity
     *            the capacity of the inbound queue.
     */
    public StreamResequencer(Processor processor, SequenceElementComparator<Exchange> comparator, int capacity) {
        super(processor);
        queue = new LinkedBlockingQueue<Exchange>();
        reseq = new ResequencerEngine<Exchange>(comparator, capacity);
        reseq.setOutQueue(queue);
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        sender = new SequenceSender(getProcessor());
        sender.setQueue(queue);
        sender.start();
    }
    @Override
    protected void doStop() throws Exception {
        reseq.stop();
        sender.cancel();
        super.doStop();
    }
    @Override
    public void process(Exchange exchange) throws Exception {
        reseq.put(exchange);
    }
    public long getTimeout() {
        return reseq.getTimeout();
    }
    public void setTimeout(long timeout) {
        reseq.setTimeout(timeout);
    }
    @Override
    public String toString() {
        return ""StreamResequencer[to: "" + getProcessor() + ""]"";
    }
}
"
org.apache.camel.processor.StreamResequencerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
public class StreamResequencerTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    public void sendBodyAndHeader(String endpointUri, final Object body, 
            final String headerName, final Object headerValue) {
        template.send(endpointUri, new Processor() {
            public void process(Exchange exchange) {
                Message in = exchange.getIn();
                in.setBody(body);
                in.setHeader(headerName, headerValue);
                in.setHeader(""testCase"", getName());
            }
        });        
    }
    public void testSendMessagesInWrongOrderButReceiveThemInCorrectOrder() throws Exception {
        resultEndpoint.expectedBodiesReceived(""msg1"", ""msg2"", ""msg3"", ""msg4"");
        sendBodyAndHeader(""direct:start"", ""msg4"", ""seqnum"", 4L);
        sendBodyAndHeader(""direct:start"", ""msg1"", ""seqnum"", 1L);
        sendBodyAndHeader(""direct:start"", ""msg3"", ""seqnum"", 3L);
        sendBodyAndHeader(""direct:start"", ""msg2"", ""seqnum"", 2L);
        resultEndpoint.assertIsSatisfied();
        List<Exchange> list = resultEndpoint.getReceivedExchanges();
        for (Exchange exchange : list) {
            log.debug(""Received: "" + exchange);
        }
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").resequencer(header(""seqnum"")).stream().to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.ThreadProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.Service;
import org.apache.camel.util.AsyncProcessorHelper;
/**
 * A processor that forces async processing of the exchange using a thread pool.
 * 
 * @version $Revision: 581261 $
 */
public class ThreadProcessor implements AsyncProcessor, Service {
    private ThreadPoolExecutor executor;
    private long stackSize;
    private ThreadGroup threadGroup;
    private int priority = Thread.NORM_PRIORITY;
    private boolean daemon = true;
    private String name = ""Thread Processor"";
    private BlockingQueue<Runnable> taskQueue;
    private long keepAliveTime;
    private int maxSize = 1;
    private int coreSize = 1;
    private final AtomicBoolean shutdown = new AtomicBoolean(true);;
    class ProcessCall implements Runnable {
        private final Exchange exchange;
        private final AsyncCallback callback;
        public ProcessCall(Exchange exchange, AsyncCallback callback) {
            this.exchange = exchange;
            this.callback = callback;
        }
        public void run() {
            if( shutdown.get() ) {
                exchange.setException(new RejectedExecutionException());
                callback.done(false);
            } else {
                callback.done(false);
            }
        }
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        if( shutdown.get() ) {
            throw new IllegalStateException(""ThreadProcessor is not running."");
        }
        ProcessCall call = new ProcessCall(exchange, callback);
        executor.execute(call);
        return false;
    }
    public void start() throws Exception {
        shutdown.set(false);
        getExecutor().setRejectedExecutionHandler(new RejectedExecutionHandler() {
            public void rejectedExecution(Runnable runnable, ThreadPoolExecutor executor) {
                ProcessCall call = (ProcessCall)runnable;
                call.exchange.setException(new RejectedExecutionException());
                call.callback.done(false);
            }
        });
    }
    public void stop() throws Exception {
        shutdown.set(true);
        executor.shutdown();
        executor.awaitTermination(0, TimeUnit.SECONDS);
    }
    public long getStackSize() {
        return stackSize;
    }
    public void setStackSize(long stackSize) {
        this.stackSize = stackSize;
    }
    public ThreadGroup getThreadGroup() {
        return threadGroup;
    }
    public void setThreadGroup(ThreadGroup threadGroup) {
        this.threadGroup = threadGroup;
    }
    public int getPriority() {
        return priority;
    }
    public void setPriority(int priority) {
        this.priority = priority;
    }
    public boolean isDaemon() {
        return daemon;
    }
    public void setDaemon(boolean daemon) {
        this.daemon = daemon;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public long getKeepAliveTime() {
        return keepAliveTime;
    }
    public void setKeepAliveTime(long keepAliveTime) {
        this.keepAliveTime = keepAliveTime;
    }
    public int getMaxSize() {
        return maxSize;
    }
    public void setMaxSize(int maxSize) {
        this.maxSize = maxSize;
    }
    public int getCoreSize() {
        return coreSize;
    }
    public void setCoreSize(int coreSize) {
        this.coreSize = coreSize;
    }
    public BlockingQueue<Runnable> getTaskQueue() {
        if (taskQueue == null) {
            taskQueue = new ArrayBlockingQueue<Runnable>(1000);
        }
        return taskQueue;
    }
    public void setTaskQueue(BlockingQueue<Runnable> taskQueue) {
        this.taskQueue = taskQueue;
    }
    public ThreadPoolExecutor getExecutor() {
        if (executor == null) {
            executor = new ThreadPoolExecutor(getCoreSize(), getMaxSize(), getKeepAliveTime(), TimeUnit.MILLISECONDS, getTaskQueue(), new ThreadFactory() {
                public Thread newThread(Runnable runnable) {
                    Thread thread;
                    if (getStackSize() > 0) {
                        thread = new Thread(getThreadGroup(), runnable, getName(), getStackSize());
                    } else {
                        thread = new Thread(getThreadGroup(), runnable, getName());
                    }
                    thread.setDaemon(isDaemon());
                    thread.setPriority(getPriority());
                    return thread;
                }
            });
        }
        return executor;
    }
    public void setExecutor(ThreadPoolExecutor executor) {
        this.executor = executor;
    }
}
"
org.apache.camel.processor.ThreadTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.InterruptedIOException;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import org.apache.camel.AsyncCallback;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 576920 $
 */
public class ThreadTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    private CountDownLatch continueProcessing = new CountDownLatch(1);
    public void testSimpleAsyncThreadCase() throws Exception {
        // Send the exchange using the async completion interface.
        // This call returns before the exchange is completed.
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(1);
            }
        }, new AsyncCallback() {
            public void done(boolean doneSynchronously) {
                log.info(""Exchange completed."");
            }
        });
        // Should not received anything since processing should not be complete.
        resultEndpoint.expectedMessageCount(0);
        resultEndpoint.assertIsSatisfied();
        // Release the processing latch..
        continueProcessing.countDown();
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.assertIsSatisfied();
    }
    public void testSimpleSyncThreadCase() throws Exception {
        // Release the processing latch in an async thread.
        releaseProcessingLatchIn(1000);
        // This call will block until the continueProcessing is released.
        template.send(""direct:a"", new Processor() {
            public void process(Exchange exchange) {
                // now lets fire in a message
                Message in = exchange.getIn();
                in.setBody(1);
            }
        });
        resultEndpoint.expectedMessageCount(1);
        resultEndpoint.assertIsSatisfied();
    }
    public void testQueuedUpExchangesCompleteOnShutdown() throws Exception {
        int exchangeCount = 10;
        final CountDownLatch completedExchanges = new CountDownLatch(exchangeCount);
        final Exchange exchanges[] = new Exchange[exchangeCount]; 
        for (int i = 0; i < exchangeCount; i++) { 
            final int index = i;
            // Send the exchange using the async completion interface.
            // This call returns before the exchange is completed.
            exchanges[i] = template.send(""direct:a"", new Processor() {
                public void process(Exchange exchange) {
                    // now lets fire in a message
                    Message in = exchange.getIn();
                    in.setBody(1);
                }
            }, new AsyncCallback() {
                public void done(boolean doneSynchronously) {
                    System.out.println(""Completed: ""+index+"", exception: ""+exchanges[index].getException());
                    completedExchanges.countDown();
                }
            });
        }
        // Should not received anything since processing should not be complete.
        resultEndpoint.expectedMessageCount(0);
        resultEndpoint.assertIsSatisfied();
        // Release it in a sec
        releaseProcessingLatchIn(1000);
        // Make sure we can shut down the context while there are 
        // concurrent requests outstanding.
        stopCamelContext();
        // All exchanges should get completed..
        assertTrue(completedExchanges.await(5, TimeUnit.SECONDS));        
    }
    protected void releaseProcessingLatchIn(final long delay) {
        new Thread() {
            @Override
            public void run() {
                try {
                    Thread.sleep(delay);
                    continueProcessing.countDown();
                } catch (InterruptedException e) {
                }
            }
        }.start();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                inheritErrorHandler(false);
                // START SNIPPET: example
                from(""direct:a"").thread(1).process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        continueProcessing.await();
                    }
                }).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.Throttler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A <a href=""http://activemq.apache.org/camel/throttler.html"">Throttler</a>
 * will set a limit on the maximum number of message exchanges which can be sent
 * to a processor within a specific time period. <p/> This pattern can be
 * extremely useful if you have some external system which meters access; such
 * as only allowing 100 requests per second; or if huge load can cause a
 * particular systme to malfunction or to reduce its throughput you might want
 * to introduce some throttling.
 * 
 * @version $Revision: $
 */
public class Throttler extends DelayProcessorSupport {
    private long maximumRequestsPerPeriod;
    private long timePeriodMillis;
    private long startTimeMillis;
    private long requestCount;
    public Throttler(Processor processor, long maximumRequestsPerPeriod) {
        this(processor, maximumRequestsPerPeriod, 1000);
    }
    public Throttler(Processor processor, long maximumRequestsPerPeriod, long timePeriodMillis) {
        super(processor);
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
        this.timePeriodMillis = timePeriodMillis;
    }
    @Override
    public String toString() {
        return ""Throttler[requests: "" + maximumRequestsPerPeriod + "" per: "" + timePeriodMillis + "" (ms) to: ""
               + getProcessor() + ""]"";
    }
    // Properties
    // -----------------------------------------------------------------------
    public long getMaximumRequestsPerPeriod() {
        return maximumRequestsPerPeriod;
    }
    /**
     * Sets the maximum number of requests per time period
     */
    public void setMaximumRequestsPerPeriod(long maximumRequestsPerPeriod) {
        this.maximumRequestsPerPeriod = maximumRequestsPerPeriod;
    }
    public long getTimePeriodMillis() {
        return timePeriodMillis;
    }
    /**
     * Sets the time period during which the maximum number of requests apply
     */
    public void setTimePeriodMillis(long timePeriodMillis) {
        this.timePeriodMillis = timePeriodMillis;
    }
    /**
     * The number of requests which have taken place so far within this time
     * period
     */
    public long getRequestCount() {
        return requestCount;
    }
    /**
     * The start time when this current period began
     */
    public long getStartTimeMillis() {
        return startTimeMillis;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected void delay(Exchange exchange) throws Exception {
        long now = currentSystemTime();
        if (startTimeMillis == 0) {
            startTimeMillis = now;
        }
        if (now - startTimeMillis > timePeriodMillis) {
            // we're at the start of a new time period
            // so lets reset things
            requestCount = 1;
            startTimeMillis = now;
        } else {
            if (++requestCount > maximumRequestsPerPeriod) {
                // lets sleep until the start of the next time period
                long time = startTimeMillis + timePeriodMillis;
                waitUntil(time, exchange);
            }
        }
    }
}
"
org.apache.camel.processor.ThrottlerTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class ThrottlerTest extends ContextTestSupport {
    protected int messageCount = 6;
    public void testSendLotsOfMessagesButOnly3GetThrough() throws Exception {
        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(""mock:result"", MockEndpoint.class);
        resultEndpoint.expectedMessageCount(3);
        resultEndpoint.setDefaulResultWaitMillis(1000);
        for (int i = 0; i < messageCount; i++) {
            template.sendBody(""seda:a"", ""<message>"" + i + ""</message>"");
        }
        // lets pause to give the requests time to be processed
        // to check that the throttle really does kick in
        resultEndpoint.assertIsSatisfied();
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: ex
                from(""seda:a"").throttler(3).timePeriodMillis(30000).to(""mock:result"");
                // END SNIPPET: ex
            }
        };
    }
}
"
org.apache.camel.processor.TransformTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class TransformTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        resultEndpoint.expectedBodiesReceived(""Hello World!"");
        sendBody(""direct:start"", ""Hello"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").process(new Processor() {
                    public void process(Exchange exchange) {
                        Message in = exchange.getIn();
                        in.setBody(in.getBody(String.class) + "" World!"");
                    }
                }).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.TransformViaDSLTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class TransformViaDSLTest extends ContextTestSupport {
    protected MockEndpoint resultEndpoint;
    public void testSendingAMessageUsingMulticastReceivesItsOwnExchange() throws Exception {
        resultEndpoint.expectedBodiesReceived(""Hello World!"");
        sendBody(""direct:start"", ""Hello"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").setBody(body().append("" World!"")).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.TryProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Implements try/catch/finally type processing
 * 
 * @version $Revision: $
 */
public class TryProcessor extends ServiceSupport implements Processor {
    private static final Log LOG = LogFactory.getLog(TryProcessor.class);
    private final Processor tryProcessor;
    private final List<CatchProcessor> catchClauses;
    private final Processor finallyProcessor;
    public TryProcessor(Processor tryProcessor, List<CatchProcessor> catchClauses, Processor finallyProcessor) {
        this.tryProcessor = tryProcessor;
        this.catchClauses = catchClauses;
        this.finallyProcessor = finallyProcessor;
    }
    public String toString() {
        String finallyText = (finallyProcessor == null) ? """" : "" Finally {"" + finallyProcessor + ""}"";
        return ""Try {"" + tryProcessor + ""} "" + catchClauses + finallyText;
    }
    public void process(Exchange exchange) throws Exception {
        Throwable e = null;
        try {
            tryProcessor.process(exchange);
            e = exchange.getException();
            // Ignore it if it was handled by the dead letter channel.
            if (e != null && DeadLetterChannel.isFailureHandled(exchange)) {
                e = null;
            }
        } catch (Exception ex) {
            e = ex;
            exchange.setException(e);
        }
        if (e != null) {
            try {
                DeadLetterChannel.setFailureHandled(exchange, true);
                handleException(exchange, e);
            } catch (Exception ex) {
                throw ex;
            } catch (Throwable ex) {
                throw new RuntimeCamelException(ex);
            } finally {
                handleAll(exchange);
            }
        } else {
            handleAll(exchange);
        }
    }
    private void handleAll(Exchange exchange) {
        if (finallyProcessor != null) {
            DeadLetterChannel.setFailureHandled(exchange, true);
            try {
                finallyProcessor.process(exchange);
            } catch (Exception e2) {
                LOG.warn(""Caught exception in finally block while handling other exception: "" + e2, e2);
            }
        }
    }
    protected void doStart() throws Exception {
        ServiceHelper.startServices(tryProcessor, catchClauses, finallyProcessor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(tryProcessor, catchClauses, finallyProcessor);
    }
    protected void handleException(Exchange exchange, Throwable e) throws Throwable {
        for (CatchProcessor catchClause : catchClauses) {
            if (catchClause.catches(e)) {
                // lets attach the exception to the exchange
                exchange.setException(e);
                try {
                    catchClause.process(exchange);
                } catch (Exception e1) {
                    LOG.warn(""Caught exception inside catch clause: "" + e1, e1);
                    throw e1;
                }
                return;
            }
        }
        // unhandled exception
        if (finallyProcessor == null) {
            throw e;
        }
    }
}
"
org.apache.camel.processor.UnitOfWorkProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultUnitOfWork;
import org.apache.camel.spi.UnitOfWork;
/** 
 * Handles calling the UnitOfWork.done() method when processing of an exchange
 * is complete.
 */
public final class UnitOfWorkProcessor extends DelegateAsyncProcessor {
    public UnitOfWorkProcessor(AsyncProcessor processor) {
        super(processor);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        if (exchange.getUnitOfWork() == null) {
            // If there is no existing UoW, then we should start one and
            // terminate it once processing is completed for the exchange.
            exchange.setUnitOfWork(new DefaultUnitOfWork());
            return processor.process(exchange, new AsyncCallback() {
                public void done(boolean sync) {
                    // Order here matters. We need to complete the callbacks
                    // since they will likely update the exchange with 
                    // some final results.
                    callback.done(sync);
                    exchange.getUnitOfWork().done(exchange);
                    exchange.setUnitOfWork(null);
                }
            });
        } else {
            // There was an existing UoW, so we should just pass through..
            // so that the guy the initiated the UoW can terminate it.
            return processor.process(exchange, callback);
        }
    }
}
"
org.apache.camel.processor.UnitOfWorkTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.spi.Synchronization;
/**
 * @version $Revision: 583549 $
 */
public class UnitOfWorkTest extends ContextTestSupport {
    protected Synchronization synchronization;
    protected Exchange completed;
    protected Exchange failed;
    protected String uri = ""direct:foo"";
    protected CountDownLatch doneLatch = new CountDownLatch(1);
    public void testSuccess() throws Exception {
        sendMessage();
        assertTrue(""Exchange did not complete."", doneLatch.await(5, TimeUnit.SECONDS));
        assertNull(""Should not have failed"", failed);
        assertNotNull(""Should have received completed notification"", completed);
        log.info(""Received completed: "" + completed);
    }
    public void testFail() throws Exception {
        sendMessage();
        assertTrue(""Exchange did not complete."", doneLatch.await(5, TimeUnit.SECONDS));
        assertNull(""Should not have completed"", completed);
        assertNotNull(""Should have received failed notification"", failed);
        log.info(""Received fail: "" + failed);
    }
    public void testException() throws Exception {
        sendMessage();
        assertTrue(""Exchange did not complete."", doneLatch.await(5, TimeUnit.SECONDS));
        assertNull(""Should not have completed"", completed);
        assertNotNull(""Should have received failed notification"", failed);
        log.info(""Received fail: "" + failed);
    }
    @Override
    protected void setUp() throws Exception {
        synchronization = new Synchronization() {
            public void onComplete(Exchange exchange) {
                completed = exchange;
                doneLatch.countDown();
            }
            public void onFailure(Exchange exchange) {
                failed = exchange;
                doneLatch.countDown();
            }
        };
        super.setUp();
    }
    protected void sendMessage() throws InterruptedException {
        template.send(uri, new Processor() {
            public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody(""<hello>world!</hello>"");
            }
        });
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:async"").thread(1).to(""direct:foo"");
                from(""direct:foo"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        log.info(""Received: "" + exchange);
                        exchange.getUnitOfWork().addSynchronization(synchronization);
                        String name = getName();
                        if (name.equals(""testFail"")) {
                            log.info(""Failing test!"");
                            exchange.getFault(true).setBody(""testFail() should always fail with a fault!"");
                        } else if (name.equals(""testException"")) {
                            log.info(""Throwing exception!"");
                            throw new Exception(""Failing test!"");
                        }
                    }
                });
            }
        };
    }
}
"
org.apache.camel.processor.UnitOfWorkWithAsyncFlowTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
/**
 * @version $Revision: 581937 $
 */
public class UnitOfWorkWithAsyncFlowTest extends UnitOfWorkTest {
    @Override
    protected void setUp() throws Exception {
        uri = ""direct:async"";
        super.setUp();
    }
}
"
org.apache.camel.processor.UnmarshalProcessor,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import java.io.InputStream;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Message;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.ExchangeHelper;
/**
 * Unmarshals the body of the incoming message using the given
 * <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 *
 * @version $Revision: 1.1 $
 */
public class UnmarshalProcessor implements Processor {
    private final DataFormat dataFormat;
    public UnmarshalProcessor(DataFormat dataFormat) {
        this.dataFormat = dataFormat;
    }
    public void process(Exchange exchange) throws Exception {
        InputStream stream = ExchangeHelper.getMandatoryInBody(exchange, InputStream.class);
        // lets setup the out message before we invoke the dataFormat
        // so that it can mutate it if necessary
        Message out = exchange.getOut(true);
        out.copyFrom(exchange.getIn());
        Object result = dataFormat.unmarshal(exchange, stream);
        out.setBody(result);
    }
}
"
org.apache.camel.processor.ValidationHandleAllNoCatchTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.TryType;
/**
 * No catch blocks but handle all should work
 *
 * @author <a href=""mailto:nsandhu@raleys.com"">nsandhu</a>
 */
public class ValidationHandleAllNoCatchTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint allEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        allEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        MockEndpoint.assertIsSatisfied(validEndpoint, allEndpoint);
    }
    public void testInvalidMessage() throws Exception {
        validEndpoint.expectedMessageCount(0);
        allEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        MockEndpoint.assertIsSatisfied(validEndpoint, allEndpoint);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        allEndpoint = resolveMandatoryEndpoint(""mock:all"", MockEndpoint.class);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                TryType tryType = from(""direct:start"").tryBlock().
                        process(validator).
                        to(""mock:valid"");
                tryType.handleAll().to(""mock:all"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationHandleAllTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.model.TryType;
/**
 * Test handleAll
 *
 * @author <a href=""mailto:nsandhu@raleys.com"">nsandhu</a>
 */
public class ValidationHandleAllTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint invalidEndpoint;
    protected MockEndpoint allEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        invalidEndpoint.expectedMessageCount(0);
        allEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint, allEndpoint);
    }
    public void testInvalidMessage() throws Exception {
        invalidEndpoint.expectedMessageCount(1);
        validEndpoint.expectedMessageCount(0);
        allEndpoint.expectedMessageCount(1);
        template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint, allEndpoint);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        invalidEndpoint = resolveMandatoryEndpoint(""mock:invalid"", MockEndpoint.class);
        allEndpoint = resolveMandatoryEndpoint(""mock:all"", MockEndpoint.class);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                TryType tryType = from(""direct:start"").tryBlock().
                        process(validator).
                        to(""mock:valid"");
                tryType.handle(ValidationException.class).to(""mock:invalid"");
                tryType.handleAll().to(""mock:all"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
/**
 * @version $Revision: 1.1 $
 */
public class ValidationTest extends ContextTestSupport {
    protected Processor validator = new MyValidator();
    protected MockEndpoint validEndpoint;
    protected MockEndpoint invalidEndpoint;
    public void testValidMessage() throws Exception {
        validEndpoint.expectedMessageCount(1);
        invalidEndpoint.expectedMessageCount(0);
        template.sendBodyAndHeader(""direct:start"", ""<valid/>"", ""foo"", ""bar"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint);
    }
    public void testInvalidMessage() throws Exception {
        invalidEndpoint.expectedMessageCount(1);
        validEndpoint.expectedMessageCount(0);
        template.sendBodyAndHeader(""direct:start"", ""<invalid/>"", ""foo"", ""notMatchedHeaderValue"");
        MockEndpoint.assertIsSatisfied(validEndpoint, invalidEndpoint);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        validEndpoint = resolveMandatoryEndpoint(""mock:valid"", MockEndpoint.class);
        invalidEndpoint = resolveMandatoryEndpoint(""mock:invalid"", MockEndpoint.class);
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").
                        tryBlock().
                            process(validator).
                            to(""mock:valid"").
                        handle(ValidationException.class).to(""mock:invalid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithExceptionTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 1.1 $
 */
public class ValidationWithExceptionTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                exception(ValidationException.class).to(""mock:invalid"");
                from(""direct:start"").
                        process(validator).
                        to(""mock:valid"");
            }
        };
    }
}
"
org.apache.camel.processor.ValidationWithTryCatchTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.ValidationException;
import org.apache.camel.builder.RouteBuilder;
/**
 * @version $Revision: 1.1 $
 */
public class ValidationWithTryCatchTest extends ValidationTest {
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from(""direct:start"").process(new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        try {
                            validator.process(exchange);
                            template.send(""mock:valid"", exchange);
                        } catch (ValidationException e) {
                            template.send(""mock:invalid"", exchange);
                        }
                    }
                });
            }
        };
    }
}
"
org.apache.camel.processor.XPathFilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.builder.xml.XPathBuilder.xpath;
/**
 * @version $Revision: 1.1 $
 */
public class XPathFilterTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testSendMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(1);
        sendBody(""direct:start"", ""<person name='James' city='London'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(0);
        sendBody(""direct:start"", ""<person name='Hiram' city='Tampa'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:start"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").filter(
                        xpath(""/person[@name='James']"")
                ).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.XPathWithNamespaceBuilderFilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.NamespaceBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.builder.xml.NamespaceBuilder.namespaceContext;
/**
 * @version $Revision: 1.1 $
 */
public class XPathWithNamespaceBuilderFilterTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testSendMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(1);
        template.sendBody(""direct:start"",
                          ""<person xmlns='http://acme.com/cheese' name='James' city='London'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start"",
                          ""<person xmlns='http://acme.com/cheese'  name='Hiram' city='Tampa'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:start"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                // lets define the namespaces we'll need in our filters
                NamespaceBuilder ns = namespaceContext(""c"", ""http://acme.com/cheese"")
                    .namespace(""xsd"", ""http://www.w3.org/2001/XMLSchema"");
                from(""direct:start"").filter(ns.xpath(""/c:person[@name='James']"")).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.XPathWithNamespacesFilterTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import static org.apache.camel.builder.xml.XPathBuilder.xpath;
/**
 * @version $Revision: 1.1 $
 */
public class XPathWithNamespacesFilterTest extends ContextTestSupport {
    protected Endpoint<Exchange> startEndpoint;
    protected MockEndpoint resultEndpoint;
    public void testSendMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(1);
        template.sendBody(""direct:start"",
                          ""<person xmlns='http://acme.com/cheese' name='James' city='London'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    public void testSendNotMatchingMessage() throws Exception {
        resultEndpoint.expectedMessageCount(0);
        template.sendBody(""direct:start"",
                          ""<person xmlns='http://acme.com/cheese'  name='Hiram' city='Tampa'/>"");
        resultEndpoint.assertIsSatisfied();
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        startEndpoint = resolveMandatoryEndpoint(""direct:start"");
        resultEndpoint = getMockEndpoint(""mock:result"");
    }
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                // START SNIPPET: example
                from(""direct:start"").filter(
                                            xpath(""/c:person[@name='James']"")
                                                .namespace(""c"", ""http://acme.com/cheese"")).to(""mock:result"");
                // END SNIPPET: example
            }
        };
    }
}
"
org.apache.camel.processor.aggregate.AggregationCollection,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import java.util.AbstractCollection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * A {@link Collection} which aggregates exchanges together using a correlation
 * expression so that there is only a single message exchange sent for a single
 * correlation key.
 * 
 * @version $Revision: 1.1 $
 */
public class AggregationCollection extends AbstractCollection<Exchange> {
    private final Expression<Exchange> correlationExpression;
    private final AggregationStrategy aggregationStrategy;
    private Map<Object, Exchange> map = new LinkedHashMap<Object, Exchange>();
    public AggregationCollection(Expression<Exchange> correlationExpression,
                                 AggregationStrategy aggregationStrategy) {
        this.correlationExpression = correlationExpression;
        this.aggregationStrategy = aggregationStrategy;
    }
    @Override
    public boolean add(Exchange exchange) {
        Object correlationKey = correlationExpression.evaluate(exchange);
        Exchange oldExchange = map.get(correlationKey);
        Exchange newExchange = exchange;
        if (oldExchange != null) {
            newExchange = aggregationStrategy.aggregate(oldExchange, newExchange);
        }
        // the strategy may just update the old exchange and return it
        if (newExchange != oldExchange) {
            map.put(correlationKey, newExchange);
        }
        return true;
    }
    public Iterator<Exchange> iterator() {
        return map.values().iterator();
    }
    public int size() {
        return map.size();
    }
}
"
org.apache.camel.processor.aggregate.AggregationStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import org.apache.camel.Exchange;
/**
 * A strategy for aggregating two exchanges together into a single exchange.
 * Possible implementations include performing some kind of combining or delta
 * processing, such as adding line items together into an invoice or just using
 * the newest exchange and removing old exchanges such as for state tracking or
 * market data prices; where old values are of little use.
 * 
 * @version $Revision: 1.1 $
 */
public interface AggregationStrategy {
    /**
     * Aggregates an old and new exchange together to create a single combined
     * exchange
     *
     * @param oldExchange the oldest exchange
     * @param newExchange the newest exchange
     * @return a combined composite of the two exchanges
     */
    Exchange aggregate(Exchange oldExchange, Exchange newExchange);
}
"
org.apache.camel.processor.aggregate.UseLatestAggregationStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.aggregate;
import org.apache.camel.Exchange;
/**
 * An {@link AggregationStrategy} which just uses the latest exchange which is useful
 * for status messages where old status messages have no real value; another example is things
 * like market data prices, where old stock prices are not that relevant, only the current price is.
 *
 * @version $Revision: 1.1 $
 */
public class UseLatestAggregationStrategy implements AggregationStrategy {
    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        return newExchange;
    }
}
"
org.apache.camel.processor.idempotent.IdempotentConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ExpressionHelper;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * An implementation of the <a
 * href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent
 * Consumer</a> pattern.
 * 
 * @version $Revision: 1.1 $
 */
public class IdempotentConsumer extends ServiceSupport implements Processor {
    private static final transient Log LOG = LogFactory.getLog(IdempotentConsumer.class);
    private Expression<Exchange> messageIdExpression;
    private Processor nextProcessor;
    private MessageIdRepository messageIdRepository;
    public IdempotentConsumer(Expression<Exchange> messageIdExpression,
                              MessageIdRepository messageIdRepository, Processor nextProcessor) {
        this.messageIdExpression = messageIdExpression;
        this.messageIdRepository = messageIdRepository;
        this.nextProcessor = nextProcessor;
    }
    @Override
    public String toString() {
        return ""IdempotentConsumer[expression="" + messageIdExpression + "", repository="" + messageIdRepository
               + "", processor="" + nextProcessor + ""]"";
    }
    public void process(Exchange exchange) throws Exception {
        String messageId = ExpressionHelper.evaluateAsString(messageIdExpression, exchange);
        if (messageId == null) {
            throw new NoMessageIdException(exchange, messageIdExpression);
        }
        if (!messageIdRepository.contains(messageId)) {
            nextProcessor.process(exchange);
        } else {
            onDuplicateMessage(exchange, messageId);
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    public Expression<Exchange> getMessageIdExpression() {
        return messageIdExpression;
    }
    public MessageIdRepository getMessageIdRepository() {
        return messageIdRepository;
    }
    public Processor getNextProcessor() {
        return nextProcessor;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startServices(nextProcessor);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(nextProcessor);
    }
    /**
     * A strategy method to allow derived classes to overload the behaviour of
     * processing a duplicate message
     * 
     * @param exchange the exchange
     * @param messageId the message ID of this exchange
     */
    protected void onDuplicateMessage(Exchange exchange, String messageId) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Ignoring duplicate message with id: "" + messageId + "" for exchange: "" + exchange);
        }
    }
}
"
org.apache.camel.processor.idempotent.MemoryMessageIdRepository,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.util.LRUCache;
/**
 * A memory based implementation of {@link MessageIdRepository}. Care should be
 * taken to use a suitable underlying {@link Map} to avoid this class being a
 * memory leak
 * 
 * @version $Revision: 1.1 $
 */
public class MemoryMessageIdRepository implements MessageIdRepository {
    private Map cache;
    public MemoryMessageIdRepository(Map set) {
        this.cache = set;
    }
    /**
     * Creates a new MemoryMessageIdRepository with a memory based respository.
     * <b>Warning</b> this method should only really be used for testing as it
     * will involve keeping all message IDs in RAM.
     */
    public static MessageIdRepository memoryMessageIdRepository() {
        return memoryMessageIdRepository(new HashMap());
    }
    /**
     * Creates a new MemoryMessageIdRepository with a memory based respository.
     * <b>Warning</b> this method should only really be used for testing as it
     * will involve keeping all message IDs in RAM.
     */
    public static MessageIdRepository memoryMessageIdRepository(int cacheSize) {
        return memoryMessageIdRepository(new LRUCache(cacheSize));
    }
    /**
     * Creates a new MemoryMessageIdRepository using the given {@link Map} to
     * use to store the processed Message ID objects. Warning be cafeful of the
     * implementation of Map you use as if you are not careful it could be a
     * memory leak.
     */
    public static MessageIdRepository memoryMessageIdRepository(Map cache) {
        return new MemoryMessageIdRepository(cache);
    }
    public boolean contains(String messageId) {
        synchronized (cache) {
            if (cache.containsKey(messageId)) {
                return true;
            } else {
                cache.put(messageId, messageId);
                return false;
            }
        }
    }
}
"
org.apache.camel.processor.idempotent.MessageIdRepository,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
/**
 * Access to a repository of Message IDs to implement the
 * <a href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent Consumer</a> pattern.
 *
 * @version $Revision: 1.1 $
 */
public interface MessageIdRepository {
    /**
     * Returns true if this messageId has been processed before
     * otherwise this messageId is added to the repository and false is returned.
     *
     * @param messageId the String ID of the message
     * @return true if the message has been processed succesfully before otherwise false
     */
    boolean contains(String messageId);
}
"
org.apache.camel.processor.idempotent.NoMessageIdException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.idempotent;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.RuntimeCamelException;
/**
 * An exception thrown if no message ID could be found on a message which is to be used with the
 * <a href=""http://activemq.apache.org/camel/idempotent-consumer.html"">Idempotent Consumer</a> pattern.
 *
 * @version $Revision: 1.1 $
 */
public class NoMessageIdException extends RuntimeCamelException {
    private final Exchange exchange;
    private final Expression expression;
    public NoMessageIdException(Exchange exchange, Expression expression) {
        super(""No message ID could be found using expression: "" + expression + "" on message exchange: "" + exchange);
        this.exchange = exchange;
        this.expression = expression;
    }
    /**
     * The exchange which caused this failure
     */
    public Exchange getExchange() {
        return exchange;
    }
    /**
     * The expression which was used
     */
    public Expression getExpression() {
        return expression;
    }
}
"
org.apache.camel.processor.loadbalancer.LoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Processor;
/**
 * A strategy for load balancing across a number of {@link Processor} instances
 *
 * @version $Revision: 1.1 $
 */
public interface LoadBalancer extends Processor {
    /**
     * Adds a new processor to the load balancer
     *
     * @param processor the processor to be added to the load balancer
     */
    void addProcessor(Processor processor);
    /**
     * Removes the given processor from the load balancer
     *
     * @param processor the processor to be removed from the load balancer
     */
    void removeProcessor(Processor processor);
    /**
     * Returns the current processors available to this load balancer
     *
     * @return the processors available
     */
    List<Processor> getProcessors();
}
"
org.apache.camel.processor.loadbalancer.LoadBalancerSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import org.apache.camel.Processor;
/**
 * A default base class for a {@link LoadBalancer} implementation
 *
 * @version $Revision: 1.1 $
 */
public abstract class LoadBalancerSupport implements LoadBalancer {
    private List<Processor> processors = new CopyOnWriteArrayList<Processor>();
    public void addProcessor(Processor processor) {
        processors.add(processor);
    }
    public void removeProcessor(Processor processor) {
        processors.remove(processor);
    }
    public List<Processor> getProcessors() {
        return processors;
    }
}
"
org.apache.camel.processor.loadbalancer.QueueLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A base class for {@link LoadBalancer} implementations which choose a single
 * destination for each exchange (rather like JMS Queues)
 * 
 * @version $Revision: 1.1 $
 */
public abstract class QueueLoadBalancer extends LoadBalancerSupport {
    public void process(Exchange exchange) throws Exception {
        List<Processor> list = getProcessors();
        if (list.isEmpty()) {
            throw new IllegalStateException(""No processors available to process "" + exchange);
        }
        Processor processor = chooseProcessor(list, exchange);
        if (processor == null) {
            throw new IllegalStateException(""No processors could be chosen to process "" + exchange);
        } else {
            processor.process(exchange);
        }
    }
    protected abstract Processor chooseProcessor(List<Processor> processors, Exchange exchange);
}
"
org.apache.camel.processor.loadbalancer.RandomLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Implements the random load balancing policy
 *
 * @version $Revision: 1.1 $
 */
public class RandomLoadBalancer extends QueueLoadBalancer {
    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        int size = processors.size();
        while (true) {
            int index = (int) Math.round(Math.random() * size);
            if (index < size) {
                return processors.get(index);
            }
        }
    }
}
"
org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Implements the round robin load balancing policy
 *
 * @version $Revision: 1.1 $
 */
public class RoundRobinLoadBalancer extends QueueLoadBalancer {
    private int counter = -1;
    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        int size = processors.size();
        if (++counter >= size) {
            counter = 0;
        }
        return processors.get(counter);
    }
}
"
org.apache.camel.processor.loadbalancer.StickyLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
/**
 * Implements a sticky load balancer using an {@link Expression} to calculate
 * a correlation key to perform the sticky load balancing; rather like jsessionid in the web
 * or JMSXGroupID in JMS.
 *
 * @version $Revision: 1.1 $
 */
public class StickyLoadBalancer extends QueueLoadBalancer {
    private Expression<Exchange> correlationExpression;
    private QueueLoadBalancer loadBalancer;
    private int numberOfHashGroups = 64 * 1024;
    private Map<Object, Processor> stickyMap = new HashMap<Object, Processor>();
    public StickyLoadBalancer(Expression<Exchange> correlationExpression) {
        this(correlationExpression, new RoundRobinLoadBalancer());
    }
    public StickyLoadBalancer(Expression<Exchange> correlationExpression, QueueLoadBalancer loadBalancer) {
        this.correlationExpression = correlationExpression;
        this.loadBalancer = loadBalancer;
    }
    protected synchronized Processor chooseProcessor(List<Processor> processors, Exchange exchange) {
        Object value = correlationExpression.evaluate(exchange);
        Object key = getStickyKey(value);
        Processor processor;
        synchronized (stickyMap) {
            processor = stickyMap.get(key);
            if (processor == null) {
                processor = loadBalancer.chooseProcessor(processors, exchange);
                stickyMap.put(key, processor);
            }
        }
        return processor;
    }
    @Override
    public void removeProcessor(Processor processor) {
        synchronized (stickyMap) {
            Iterator<Map.Entry<Object, Processor>> iter = stickyMap.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<Object, Processor> entry = iter.next();
                if (processor.equals(entry.getValue())) {
                    iter.remove();
                }
            }
        }
        super.removeProcessor(processor);
    }
    // Properties
    //-------------------------------------------------------------------------
    public int getNumberOfHashGroups() {
        return numberOfHashGroups;
    }
    public void setNumberOfHashGroups(int numberOfHashGroups) {
        this.numberOfHashGroups = numberOfHashGroups;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    /**
     * A strategy to create the key for the sticky load balancing map.
     * The default implementation uses the hash code of the value
     * then modulos by the numberOfHashGroups to avoid the sticky map getting too big
     *
     * @param value the correlation value
     * @return the key to be used in the sticky map
     */
    protected Object getStickyKey(Object value) {
        int hashCode = 37;
        if (value != null) {
            hashCode = value.hashCode();
        }
        if (numberOfHashGroups > 0) {
            hashCode = hashCode % numberOfHashGroups;
        }
        return hashCode;
    }
}
"
org.apache.camel.processor.loadbalancer.TopicLoadBalancer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.loadbalancer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A {@link LoadBalancer} implementations which sends to all destinations
 * (rather like JMS Topics)
 * 
 * @version $Revision: 1.1 $
 */
public class TopicLoadBalancer extends LoadBalancerSupport {
    public void process(Exchange exchange) throws Exception {
        List<Processor> list = getProcessors();
        for (Processor processor : list) {
            Exchange copy = copyExchangeStrategy(processor, exchange);
            processor.process(copy);
        }
    }
    /**
     * Strategy method to copy the exchange before sending to another endpoint.
     * Derived classes such as the {@link Pipeline} will not clone the exchange
     * 
     * @param processor the processor that will send the exchange
     * @param exchange
     * @return the current exchange if no copying is required such as for a
     *         pipeline otherwise a new copy of the exchange is returned.
     */
    protected Exchange copyExchangeStrategy(Processor processor, Exchange exchange) {
        return exchange.copy();
    }
}
"
org.apache.camel.processor.resequencer.DefaultExchangeComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * Compares elements of an {@link Exchange} sequence by comparing
 * <code>long</code> values returned by this comaprator's
 * <code>expression</code>. The expression is set during route definition
 * e.g.
 * 
 * <pre>
 *    ...resequencer(header(&quot;seqnum&quot;)).stream()...
 * </pre>
 * 
 * @author Martin Krasser
 * 
 * @version $Revision$
 */
public class DefaultExchangeComparator implements ExpressionResultComparator<Exchange> {
    private Expression<Exchange> expression;
    public Expression<Exchange> getExpression() {
        return expression;
    }
    public void setExpression(Expression<Exchange> expression) {
        this.expression = expression;
    }
    @SuppressWarnings(""unchecked"")
    public void setExpressions(List<Expression> expressions) {
        if (expressions.isEmpty()) {
            throw new IllegalArgumentException(
                    ""Expression required to resolve sequence number"");
        } else if (expressions.size() > 1) {
            throw new IllegalArgumentException(
                    ""More than one expression currently not supported"");
        }
        expression = expressions.get(0);
    }
    public boolean predecessor(Exchange o1, Exchange o2) {
        long n1 = getSequenceNumber(o1);
        long n2 = getSequenceNumber(o2);
        return n1 == (n2 - 1L);
    }
    public boolean successor(Exchange o1, Exchange o2) {
        long n1 = getSequenceNumber(o1);
        long n2 = getSequenceNumber(o2);
        return n2 == (n1 - 1L);
    }
    public int compare(Exchange o1, Exchange o2) {
        Long n1 = getSequenceNumber(o1);
        Long n2 = getSequenceNumber(o2);
        return n1.compareTo(n2);
    }
    private long getSequenceNumber(Exchange exchange) {
        return (Long)expression.evaluate(exchange);
    }
}
"
org.apache.camel.processor.resequencer.Element,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
/**
 * A container for objects to be resequenced. This container can be scheduled
 * for timing out. Non-scheduled objects or already timed-out objects are ready
 * for being released by the {@link ResequencerEngine}.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
class Element<E> implements TimeoutHandler {
    /**
     * The contained object.
     */
    private E object;
    /**
     * Not <code>null</code> if this element is currently beeing scheduled for
     * timing out.
     */
    private Timeout timeout;
    /**
     * Creates a new container instance.
     * 
     * @param object contained object.
     */
    public Element(E object) {
        this.object = object;
    }
    /**
     * Returns the contained object.
     * 
     * @return the contained object.
     */
    public E getObject() {
        return object;
    }
    /**
     * Returns <code>true</code> if this element is currently scheduled for
     * timing out.
     * 
     * @return <code>true</code> if scheduled or <code>false</code> if not
     *         scheduled or already timed-out.
     */
    public synchronized boolean scheduled() {
        return timeout != null;
    }
    /**
     * Schedules the given timeout task. Before this methods calls the
     * {@link Timeout#schedule()} method it adds this element as timeout
     * listener.
     * 
     * @param t a timeout task.
     */
    public synchronized void schedule(Timeout t) {
        this.timeout = t;
        this.timeout.addTimeoutHandlerFirst(this);
        this.timeout.schedule();
    }
    /**
     * Cancels the scheduled timeout for this element. If this element is not
     * scheduled or has already timed-out this method has no effect.
     */
    public synchronized void cancel() {
        if (timeout != null) {
            timeout.cancel();
        }
        timeout(null);
    }
    /**
     * Marks this element as timed-out.
     * 
     * @param t timeout task that caused the notification.
     */
    public synchronized void timeout(Timeout t) {
        this.timeout = null;
    }
}
"
org.apache.camel.processor.resequencer.ElementComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
/**
 * A strategy for comparing {@link Element} instances. This strategy uses
 * another {@link SequenceElementComparator} instance for comparing elements
 * contained by {@link Element} instances.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
class ElementComparator<E> implements SequenceElementComparator<Element<E>> {
    /**
     * A sequence element comparator this comparator delegates to.
     */
    private SequenceElementComparator<E> comparator;
    /**
     * Creates a new element comparator instance.
     * 
     * @param comparator a sequence element comparator this comparator delegates
     *        to.
     */
    public ElementComparator(SequenceElementComparator<E> comparator) {
        this.comparator = comparator;
    }
    /**
     * @see SequenceElementComparator#predecessor(java.lang.Object, java.lang.Object)
     */
    public boolean predecessor(Element<E> o1, Element<E> o2) {
        return comparator.predecessor(o1.getObject(), o2.getObject());
    }
    /**
     * @see SequenceElementComparator#successor(java.lang.Object, java.lang.Object)
     */
    public boolean successor(Element<E> o1, Element<E> o2) {
        return comparator.successor(o1.getObject(), o2.getObject());
    }
    /**
     * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
     */
    public int compare(Element<E> o1, Element<E> o2) {
        return comparator.compare(o1.getObject(), o2.getObject());
    }
}
"
org.apache.camel.processor.resequencer.ExpressionResultComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * A {@link SequenceElementComparator} that compares {@link Exchange}s based on
 * the result of an expression evaluation.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision$
 */
public interface ExpressionResultComparator<E extends Exchange> extends SequenceElementComparator<E> {
    /**
     * Sets the list expressions used for comparing {@link Exchange}s.
     * 
     * @param expressions a list of {@link Expression} objects.
     */
    void setExpressions(List<Expression> expressions);
}
"
org.apache.camel.processor.resequencer.ResequencerEngine,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.Queue;
import java.util.Timer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Resequences elements based on a given {@link SequenceElementComparator}.
 * This resequencer is designed for resequencing element streams. Resequenced
 * elements are added to an output {@link Queue}. The resequencer is configured
 * via the <code>timeout</code> and <code>capacity</code> properties.
 * 
 * <ul>
 * <li><code>timeout</code>. Defines the timeout (in milliseconds) for a
 * given element managed by this resequencer. An out-of-sequence element can
 * only be marked as <i>ready-for-delivery</i> if it either times out or if it
 * has an immediate predecessor (in that case it is in-sequence). If an
 * immediate predecessor of a waiting element arrives the timeout task for the
 * waiting element will be cancelled (which marks it as <i>ready-for-delivery</i>).
 * <p>
 * If the maximum out-of-sequence time between elements within a stream is
 * known, the <code>timeout</code> value should be set to this value. In this
 * case it is guaranteed that all elements of a stream will be delivered in
 * sequence to the output queue. However, large <code>timeout</code> values
 * might require a very high resequencer <code>capacity</code> which might be
 * in conflict with available memory resources. The lower the
 * <code>timeout</code> value is compared to the out-of-sequence time between
 * elements within a stream the higher the probability is for out-of-sequence
 * elements delivered by this resequencer.</li>
 * <li><code>capacity</code>. The capacity of this resequencer.</li>
 * </ul>
 * 
 * Whenever a timeout for a certain element occurs or an element has been added
 * to this resequencer a delivery attempt is started. If a (sub)sequence of
 * elements is <i>ready-for-delivery</i> then they are added to output queue.
 * <p>
 * The resequencer remembers the last-delivered element. If an element arrives
 * which is the immediate successor of the last-delivered element it will be
 * delivered immediately and the last-delivered element is adjusted accordingly.
 * If the last-delivered element is <code>null</code> i.e. the resequencer was
 * newly created the first arriving element will wait <code>timeout</code>
 * milliseconds for being delivered to the output queue.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
public class ResequencerEngine<E> implements TimeoutHandler {
    private static final Log LOG = LogFactory.getLog(ResequencerEngine.class);
    private long timeout;
    private int capacity;
    private Queue<E> outQueue;
    private Element<E> lastDelivered;
    /**
     * A sequence of elements for sorting purposes.
     */
    private Sequence<Element<E>> sequence;
    /**
     * A timer for scheduling timeout notifications.
     */
    private Timer timer;
    /**
     * Creates a new resequencer instance with a default timeout of 2000
     * milliseconds. The capacity is set to {@link Integer#MAX_VALUE}.
     * 
     * @param comparator a sequence element comparator.
     */
    public ResequencerEngine(SequenceElementComparator<E> comparator) {
        this(comparator, Integer.MAX_VALUE);
    }
    /**
     * Creates a new resequencer instance with a default timeout of 2000
     * milliseconds.
     * 
     * @param comparator a sequence element comparator.
     * @param capacity the capacity of this resequencer.
     */
    public ResequencerEngine(SequenceElementComparator<E> comparator, int capacity) {
        this.timer = new Timer(""Resequencer Timer"");
        this.sequence = createSequence(comparator);
        this.capacity = capacity;
        this.timeout = 2000L;
        this.lastDelivered = null;
    }
    /**
     * Stops this resequencer (i.e. this resequencer's {@link Timer} instance).
     */
    public void stop() {
        this.timer.cancel();
    }
    /**
     * Returns the output queue.
     * 
     * @return the output queue.
     */
    public Queue<E> getOutQueue() {
        return outQueue;
    }
    /**
     * Sets the output queue.
     * 
     * @param outQueue output queue.
     */
    public void setOutQueue(Queue<E> outQueue) {
        this.outQueue = outQueue;
    }
    /**
     * Returns this resequencer's timeout value.
     * 
     * @return the timeout in milliseconds.
     */
    public long getTimeout() {
        return timeout;
    }
    /**
     * Sets this sequencer's timeout value.
     * 
     * @param timeout the timeout in milliseconds.
     */
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }
    /** 
     * Handles a timeout notification by starting a delivery attempt.
     * 
     * @param timout timeout task that caused the notification.
     */
    public synchronized void timeout(Timeout timout) {
        try {
            while (deliver()) {
                // work done in deliver()
            }
        } catch (RuntimeException e) {
            LOG.error(""error during delivery"", e);
        }
    }
    /**
     * Adds an element to this resequencer throwing an exception if the maximum
     * capacity is reached.
     * 
     * @param o element to be resequenced.
     * @throws IllegalStateException if the element cannot be added at this time
     *         due to capacity restrictions.
     */
    public synchronized void add(E o) {
        if (sequence.size() >= capacity) {
            throw new IllegalStateException(""maximum capacity is reached"");
        }
        insert(o);
    }
    /**
     * Adds an element to this resequencer waiting, if necessary, until capacity
     * becomes available.
     * 
     * @param o element to be resequenced.
     * @throws InterruptedException if interrupted while waiting.
     */
    public synchronized void put(E o) throws InterruptedException {
        if (sequence.size() >= capacity) {
            wait();
        }
        insert(o);
    }
    /**
     * Returns the last delivered element.
     * 
     * @return the last delivered element or <code>null</code> if no delivery
     *         has been made yet.
     */
    E getLastDelivered() {
        if (lastDelivered == null) {
            return null;
        }
        return lastDelivered.getObject();
    }
    /**
     * Sets the last delivered element. This is for testing purposes only.
     * 
     * @param o an element.
     */
    void setLastDelivered(E o) {
        lastDelivered = new Element<E>(o);
    }
    /**
     * Inserts the given element into this resequencing queue (sequence). If the
     * element is not ready for immediate delivery and has no immediate
     * presecessor then it is scheduled for timing out. After being timed out it
     * is ready for delivery.
     * 
     * @param o an element.
     */
    private void insert(E o) {
        // wrap object into internal element
        Element<E> element = new Element<E>(o);
        // add element to sequence in proper order
        sequence.add(element);
        Element<E> successor = sequence.successor(element);
        // check if there is an immediate successor and cancel
        // timer task (no need to wait any more for timeout)
        if (successor != null) {
            successor.cancel();
        }
        // start delivery if current element is successor of last delivered element
        if (successorOfLastDelivered(element)) {
            // nothing to schedule
        } else if (sequence.predecessor(element) != null) {
            // nothing to schedule
        } else {
            Timeout t = defineTimeout();
            element.schedule(t);
        }
        // start delivery
        while (deliver()) {
            // work done in deliver()
        }
    }
    /**
     * Attempts to deliver a single element from the head of the resequencer
     * queue (sequence). Only elements which have not been scheduled for timing
     * out or which already timed out can be delivered.
     * 
     * @return <code>true</code> if the element has been delivered
     *         <code>false</code> otherwise.
     */
    private boolean deliver() {
        if (sequence.size() == 0) {
            return false;
        }
        // inspect element with lowest sequence value
        Element<E> element = sequence.first();
        // if element is scheduled do not deliver and return
        if (element.scheduled()) {
            return false;
        }
        // remove deliverable element from sequence
        sequence.remove(element);
        // set the delivered element to last delivered element
        lastDelivered = element;
        // notify a waiting thread that capacity is available
        notify();
        // add element to output queue
        outQueue.add(element.getObject());
        // element has been delivered
        return true;
    }
    /**
     * Returns <code>true</code> if the given element is the immediate
     * successor of the last delivered element.
     * 
     * @param element an element.
     * @return <code>true</code> if the given element is the immediate
     *         successor of the last delivered element.
     */
    private boolean successorOfLastDelivered(Element<E> element) {
        if (lastDelivered == null) {
            return false;
        }
        if (sequence.comparator().successor(element, lastDelivered)) {
            return true;
        }
        return false;
    }
    /**
     * Creates a timeout task based on the timeout setting of this resequencer.
     * 
     * @return a new timeout task.
     */
    private Timeout defineTimeout() {
        Timeout result = new Timeout(timer, timeout);
        result.addTimeoutHandler(this);
        return result;
    }
    private static <E> Sequence<Element<E>> createSequence(SequenceElementComparator<E> comparator) {
        return new Sequence<Element<E>>(new ElementComparator<E>(comparator));
    }
}
"
org.apache.camel.processor.resequencer.Sequence,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.TreeSet;
/**
 * A sorted set of elements with additional methods for obtaining immediate
 * successors and immediate predecessors of a given element in the sequence.
 * Successors and predecessors are calculated by using a
 * {@link SequenceElementComparator}.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
public class Sequence<E> extends TreeSet<E> {
    private static final long serialVersionUID = 5647393631147741711L;
    private SequenceElementComparator<E> comparator;
    /**
     * Creates a new {@link Sequence} instance.
     * 
     * @param comparator a strategy for comparing elements of this sequence.
     */
    public Sequence(SequenceElementComparator<E> comparator) {
        super(comparator);
        this.comparator = comparator;
    }
    /**
     * Returns the immediate predecessor of the given element in this sequence
     * or <code>null</code> if no predecessor exists.
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E predecessor(E e) {
        E elem = lower(e);
        if (elem == null) {
            return null;
        }
        if (comparator.predecessor(elem, e)) {
            return elem;
        }
        return null;
    }
    /**
     * Returns the immediate successor of the given element in this sequence
     * or <code>null</code> if no successor exists.
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E successor(E e) {
        E elem = higher(e);
        if (elem == null) {
            return null;
        }
        if (comparator.successor(elem, e)) {
            return elem;
        }
        return null;
    }
    /**
     * Returns this sequence's comparator.
     * 
     * @return this sequence's comparator.
     */
    public SequenceElementComparator<E> comparator() {
        return comparator;
    }
    /**
     * Returns the next higher element in the sequence to the given element. If
     * the given element doesn't exist or if it is the last element in the
     * sequence <code>null</code> is returned. <strong>Please note that this
     * method is provided for compatibility with Java 5 SE. On a Java 6 SE
     * platform the same method implemented by the {@link TreeSet}
     * class should be used for better performance.</strong>
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E higher(E e) {
        boolean found = false;
        for (E current : this) {
            if (found) {
                return current;
            }
            if (comparator.compare(e, current) == 0) {
                found = true;
            }
        }
        return null;
    }
    /**
     * Returns the next lower element in the sequence to the given element. If
     * the given element doesn't exist or if it is the first element in the
     * sequence <code>null</code> is returned. <strong>Please note that this
     * method is provided for compatibility with Java 5 SE. On a Java 6 SE
     * platform the same method implemented by the {@link TreeSet}
     * class should be used for better performance.</strong>
     * 
     * @param e an element which is compared to elements of this sequence.
     * @return an element of this sequence or <code>null</code>.
     */
    public E lower(E e) {
        E last = null;
        for (E current : this) {
            if (comparator.compare(e, current) == 0) {
                return last;
            }
            last = current;
        }
        return last;
    }
}
"
org.apache.camel.processor.resequencer.SequenceElementComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.Comparator;
/**
 * A strategy for comparing elements of a sequence.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
public interface SequenceElementComparator<E> extends Comparator<E> {
    /**
     * Returns <code>true</code> if <code>o1</code> is an immediate predecessor
     * of <code>o2</code>.
     * 
     * @param o1 a sequence element.
     * @param o2 a sequence element.
     */
    boolean predecessor(E o1, E o2);
    /**
     * Returns <code>true</code> if <code>o1</code> is an immediate successor
     * of <code>o2</code>.
     * 
     * @param o1 a sequence element.
     * @param o2 a sequence element.
     */
    boolean successor(E o1, E o2);
}
"
org.apache.camel.processor.resequencer.SequenceSender,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.concurrent.BlockingQueue;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A thread that takes re-ordered {@link Exchange}s from a blocking queue and
 * send them to the linked processor.  
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
public class SequenceSender extends Thread {
    private static final Log LOG = LogFactory.getLog(SequenceSender.class);
    private static final Exchange STOP = createStopSignal();
    private BlockingQueue<Exchange> queue;
    private Processor processor;
    /**
     * Creates a new {@link SequenceSender} thread.
     * 
     * @param processor
     *            the processor to send re-ordered {@link Exchange}s.
     */
    public SequenceSender(Processor processor) {
        this.processor = processor;
    }
    /**
     * Sets the {@link BlockingQueue} to take messages from.
     * 
     * @param queue
     *            the {@link BlockingQueue} to take messages from.
     */
    public void setQueue(BlockingQueue<Exchange> queue) {
        this.queue = queue;
    }
    public void run() {
        while (true) {
            try {
                Exchange exchange = queue.take();
                if (exchange == STOP) {
                    LOG.info(""exit processing loop after cancellation"");
                    return;
                }
                processor.process(exchange);
            } catch (InterruptedException e) {
                LOG.info(""exit processing loop after interrupt"");
                return;
            } catch (Exception e) {
                LOG.warn(""exception during exchange processing"");
            }
        }
    }
    /**
     * Cancels this thread.
     */
    public void cancel() throws InterruptedException {
        queue.put(STOP);
    }
    private static Exchange createStopSignal() {
        return (Exchange)Proxy.newProxyInstance(SequenceSender.class.getClassLoader(), 
                new Class[] {Exchange.class}, createStopHandler());
    }
    private static InvocationHandler createStopHandler() {
        return new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                throw new RuntimeException(""illegal method invocation on stop signal"");
            }
        };
    }
}
"
org.apache.camel.processor.resequencer.Timeout,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
import java.util.LinkedList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
/**
 * A timer task that notifies handlers about scheduled timeouts.
 * 
 * @see Timer
 * @see TimerTask
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
public class Timeout extends TimerTask {
    private List<TimeoutHandler> timeoutHandlers;
    private Timer timer;
    private long timeout;
    /**
     * Creates a new timeout task using the given {@link Timer} instance a timeout value. The
     * task is not scheduled immediately. It will be scheduled by calling this
     * task's {@link #schedule()} method.
     * 
     * @param timer
     * @param timeout
     */
    public Timeout(Timer timer, long timeout) {
        this.timeoutHandlers = new LinkedList<TimeoutHandler>();
        this.timeout = timeout;
        this.timer = timer;
    }
    /**
     * Returns the list of timeout handlers that have been registered for
     * notification.
     * 
     * @return the list of timeout handlers
     */
    public List<TimeoutHandler> getTimeoutHandlers() {
        return timeoutHandlers;
    }
    /**
     * Appends a new timeout handler at the end of the timeout handler list.
     * 
     * @param handler a timeout handler.
     */
    public void addTimeoutHandler(TimeoutHandler handler) {
        timeoutHandlers.add(handler);
    }
    /**
     * inserts a new timeout handler at the beginning of the timeout handler
     * list.
     * 
     * @param handler a timeout handler.
     */
    public void addTimeoutHandlerFirst(TimeoutHandler handler) {
        timeoutHandlers.add(0, handler);
    }
    /**
     * Removes all timeout handlers from the timeout handler list. 
     */
    public void clearTimeoutHandlers() {
        this.timeoutHandlers.clear();
    }
    /**
     * Schedules this timeout task.
     */
    public void schedule() {
        timer.schedule(this, timeout);
    }
    /**
     * Notifies all timeout handlers about the scheduled timeout.
     */
    @Override
    public void run() {
        for (TimeoutHandler observer : timeoutHandlers) {
            observer.timeout(this);
        }
    }
}
"
org.apache.camel.processor.resequencer.TimeoutHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.resequencer;
/**
 * Implemented by classes that handle timeout notifications.
 * 
 * @author Martin Krasser
 * 
 * @version $Revision
 */
public interface TimeoutHandler {
    /**
     * Handles a timeout notification.
     * 
     * @param timeout the timer task that caused this timeout notification.
     */
    void timeout(Timeout timeout);
}
"
org.apache.camel.processor.validation.DefaultValidationErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import java.util.ArrayList;
import java.util.List;
import javax.xml.transform.dom.DOMResult;
import javax.xml.validation.Schema;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
/**
 * A default error handler which just stores all the errors so they can be reported or transformed.
 * 
 * @version $Revision: $
 */
public class DefaultValidationErrorHandler implements ValidatorErrorHandler {
    private static final transient Log log = LogFactory.getLog(DefaultValidationErrorHandler.class);
    private List<SAXParseException> warnings = new ArrayList<SAXParseException>();
    private List<SAXParseException> errors = new ArrayList<SAXParseException>();
    private List<SAXParseException> fatalErrors = new ArrayList<SAXParseException>();
    public void warning(SAXParseException e) throws SAXException {
        if (log.isDebugEnabled()) {
            log.debug(""warning: "" + e, e);
        }
        warnings.add(e);
    }
    public void error(SAXParseException e) throws SAXException {
        if (log.isDebugEnabled()) {
            log.debug(""error: "" + e, e);
        }
        errors.add(e);
    }
    public void fatalError(SAXParseException e) throws SAXException {
        if (log.isDebugEnabled()) {
            log.debug(""fatalError: "" + e, e);
        }
        fatalErrors.add(e);
    }
    public void reset() {
    }
    public boolean isValid() {
        return errors.isEmpty() && fatalErrors.isEmpty();
    }
    public void handleErrors(Exchange exchange, Schema schema, DOMResult result) throws ValidationException {
        if (!isValid()) {
            throw new SchemaValidationException(exchange, schema, fatalErrors, errors, warnings);
        }
    }
    public void handleErrors(Exchange exchange, Object schema) throws ValidationException {
        if (!isValid()) {
            throw new SchemaValidationException(exchange, schema, fatalErrors, errors, warnings);
        }
    }
}
"
org.apache.camel.processor.validation.NoXmlBodyValidationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
/**
 * An exception found if no XML body is available on the inbound message
 *
 * @version $Revision: $
 */
public class NoXmlBodyValidationException extends ValidationException {
    public NoXmlBodyValidationException(Exchange exchange) {
        super(exchange, ""No XML body could be found on the input message"" + exchange);
    }
}
"
org.apache.camel.processor.validation.SchemaValidationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import java.util.List;
import org.xml.sax.SAXParseException;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
/**
 * A Schema validation exception occurred
 * 
 * @version $Revision: $
 */
public class SchemaValidationException extends ValidationException {
    private final Object schema;
    private final List<SAXParseException> fatalErrors;
    private final List<SAXParseException> errors;
    private final List<SAXParseException> warnings;
    public SchemaValidationException(Exchange exchange, Object schema, List<SAXParseException> fatalErrors,
                                     List<SAXParseException> errors, List<SAXParseException> warnings) {
        super(exchange, message(schema, fatalErrors, errors, warnings));
        this.schema = schema;
        this.fatalErrors = fatalErrors;
        this.errors = errors;
        this.warnings = warnings;
    }
    /**
     * Returns the schema that failed
     * 
     * @return the schema that failed
     */
    public Object getSchema() {
        return schema;
    }
    /**
     * Returns the validation errors
     * 
     * @return the validation errors
     */
    public List<SAXParseException> getErrors() {
        return errors;
    }
    /**
     * Returns the fatal validation errors
     * 
     * @return the fatal validation errors
     */
    public List<SAXParseException> getFatalErrors() {
        return fatalErrors;
    }
    /**
     * Returns the validation warnings
     * 
     * @return the validation warnings
     */
    public List<SAXParseException> getWarnings() {
        return warnings;
    }
    protected static String message(Object schema, List<SAXParseException> fatalErrors,
                                    List<SAXParseException> errors, List<SAXParseException> warnings) {
        StringBuffer buffer = new StringBuffer(""Validation failed for: "" + schema);
        if (!fatalErrors.isEmpty()) {
            buffer.append("" fatal errors: "");
            buffer.append(fatalErrors);
        }
        if (!errors.isEmpty()) {
            buffer.append("" errors: "");
            buffer.append(errors);
        }
        return buffer.toString();
    }
}
"
org.apache.camel.processor.validation.ValidatingProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import javax.xml.XMLConstants;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import org.xml.sax.SAXException;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * A processor which validates the XML version of the inbound message body
 * against some schema either in XSD or RelaxNG
 * 
 * @version $Revision: 453155 $
 */
public class ValidatingProcessor implements Processor {
    private Schema schema;
    private ValidatorErrorHandler errorHandler = new DefaultValidationErrorHandler();
    // for lazy creation of the Schema
    private String schemaLanguage = XMLConstants.W3C_XML_SCHEMA_NS_URI;
    private Source schemaSource;
    private SchemaFactory schemaFactory;
    private URL schemaUrl;
    private File schemaFile;
    public void process(Exchange exchange) throws Exception {
        Schema schema = getSchema();
        Validator validator = schema.newValidator();
        Source source = exchange.getIn().getBody(DOMSource.class);
        if (source == null) {
            throw new NoXmlBodyValidationException(exchange);
        }
        // create a new errorHandler and set it on the validator
        errorHandler.reset();
        validator.setErrorHandler(errorHandler);
        DOMResult result = new DOMResult();
        validator.validate(source, result);
        errorHandler.handleErrors(exchange, schema, result);
        /*
         * Fault fault = exchange.createFault(); if (errorHandler.hasErrors()) { //
         * set the schema and source document as properties on the fault
         * fault.setProperty(""org.apache.servicemix.schema"", schema);
         * fault.setProperty(""org.apache.servicemix.xml"", source);
         * 
         *//*
             * check if this error handler supports the capturing of error
             * messages.
             *//*
             * if (errorHandler.capturesMessages()) {
             * 
             *//*
             * In descending order of preference select a format to use. If
             * neither DOMSource, StringSource or String are supported throw a
             * messaging exception.
             *//*
             * if (errorHandler.supportsMessageFormat(DOMSource.class)) {
             * fault.setContent( (DOMSource)
             * errorHandler.getMessagesAs(DOMSource.class)); } else if
             * (errorHandler.supportsMessageFormat(StringSource.class)) {
             * fault.setContent(sourceTransformer.toDOMSource( (StringSource)
             * errorHandler.getMessagesAs(StringSource.class))); } else if
             * (errorHandler.supportsMessageFormat(String.class)) {
             * fault.setContent( sourceTransformer.toDOMSource( new
             * StringSource( (String)
             * errorHandler.getMessagesAs(String.class)))); } else { throw new
             * MessagingException(""MessageAwareErrorHandler implementation "" +
             * errorHandler.getClass().getName() + "" does not support a
             * compatible error message format.""); } } else {
             *//*
             * we can't do much here if the ErrorHandler implementation does not
             * support capturing messages
             *//*
             * fault.setContent(new DOMSource(result.getNode(),
             * result.getSystemId())); } throw new FaultException(""Failed to
             * validate against schema: "" + schema, exchange, fault); } else { //
             * Retrieve the ouput of the validation // as it may have been
             * changed by the validator out.setContent(new
             * DOMSource(result.getNode(), result.getSystemId())); } }
             */
    }
    // Properties
    // -----------------------------------------------------------------------
    public Schema getSchema() throws IOException, SAXException {
        if (schema == null) {
            schema = createSchema();
        }
        return schema;
    }
    public void setSchema(Schema schema) {
        this.schema = schema;
    }
    public String getSchemaLanguage() {
        return schemaLanguage;
    }
    public void setSchemaLanguage(String schemaLanguage) {
        this.schemaLanguage = schemaLanguage;
    }
    public Source getSchemaSource() throws IOException {
        if (schemaSource == null) {
            schemaSource = createSchemaSource();
        }
        return schemaSource;
    }
    public void setSchemaSource(Source schemaSource) {
        this.schemaSource = schemaSource;
    }
    public URL getSchemaUrl() {
        return schemaUrl;
    }
    public void setSchemaUrl(URL schemaUrl) {
        this.schemaUrl = schemaUrl;
    }
    public File getSchemaFile() {
        return schemaFile;
    }
    public void setSchemaFile(File schemaFile) {
        this.schemaFile = schemaFile;
    }
    public SchemaFactory getSchemaFactory() {
        if (schemaFactory == null) {
            schemaFactory = createSchemaFactory();
        }
        return schemaFactory;
    }
    public void setSchemaFactory(SchemaFactory schemaFactory) {
        this.schemaFactory = schemaFactory;
    }
    public ValidatorErrorHandler getErrorHandler() {
        return errorHandler;
    }
    public void setErrorHandler(ValidatorErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected SchemaFactory createSchemaFactory() {
        return SchemaFactory.newInstance(schemaLanguage);
    }
    protected Source createSchemaSource() throws IOException {
        throw new IllegalArgumentException(""You must specify a schema, ""
                                           + ""schemaFile, schemaSource or schemaUrl property"");
    }
    protected Schema createSchema() throws SAXException, IOException {
        SchemaFactory factory = getSchemaFactory();
        URL url = getSchemaUrl();
        if (url != null) {
            return factory.newSchema(url);
        }
        File file = getSchemaFile();
        if (file != null) {
            return factory.newSchema(file);
        }
        return factory.newSchema(getSchemaSource());
    }
}
"
org.apache.camel.processor.validation.ValidatorErrorHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.processor.validation;
import javax.xml.transform.dom.DOMResult;
import javax.xml.validation.Schema;
import org.xml.sax.ErrorHandler;
import org.apache.camel.Exchange;
import org.apache.camel.ValidationException;
/**
 * @version $Revision: $
 */
public interface ValidatorErrorHandler extends ErrorHandler {
    /**
     * Resets any state within this error handler
     */
    void reset();
    /**
     * Process any errors which may have occurred during validation
     *
     * @param exchange
     * @param schema
     * @param result
     */
    void handleErrors(Exchange exchange, Schema schema, DOMResult result) throws ValidationException;
}
"
org.apache.camel.spi.ComponentResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.CamelContext;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
/**
 * Represents a resolver of components from a URI to be able to auto-load them using some
 * discovery mechanism like {@link org.apache.camel.impl.DefaultComponentResolver}
 *
 * @version $Revision: 577721 $
 */
public interface ComponentResolver<E extends Exchange> {
    /**
     * Attempts to resolve the component for the given URI
     *
     * @param name the component name to resolve
     * @param context the context to load the component if it can be resolved
     * @return the component which is added to the context or null if it can not be resolved
     */
    Component<E> resolveComponent(String name, CamelContext context) throws Exception;
}
"
org.apache.camel.spi.DataFormat,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.apache.camel.Exchange;
/**
 * Represents a
 * <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * used to marshal objects to and from streams
 * such as Java Serialization or using JAXB2 to encode/decode objects using XML
 * or using SOAP encoding.
 *
 * @version $Revision: 1.1 $
 */
public interface DataFormat {
    /**
     * Marshals the object to the given Stream.
     */
    void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception;
    /**
     * Unmarshals the given stream into an object.
     */
    Object unmarshal(Exchange exchange, InputStream stream) throws Exception;
}
"
org.apache.camel.spi.ExceptionHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * A Strategy pattern for handling exceptions; particularly in asynchronous processes such as consumers
 *
 * @version $Revision: 1.1 $
 */
public interface ExceptionHandler {
    /**
     * Handles the given exception
     *
     * @param exception the exception
     */
    void handleException(Throwable exception);
}
"
org.apache.camel.spi.ExchangeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Exchange;
/**
 * This converter is capable of converting from an exchange to another type
 *
 * @version $Revision: 563607 $
 */
public interface ExchangeConverter {
     <T> T  convertTo(Class<T> type, Exchange exchange);
}
"
org.apache.camel.spi.Injector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * A pluggable strategy for creating and possibly dependency injecting objects
 * which could be implemented using straight forward reflection or using Spring
 * or Guice to perform dependency injection.
 * 
 * @version $Revision: 563607 $
 */
public interface Injector {
    /**
     * Instantiates a new instance of the given type possibly injecting values
     * into the object in the process
     * 
     * @param type the type of object to create
     * @return a newly created instance
     */
    <T> T newInstance(Class<T> type);
}
"
org.apache.camel.spi.InstrumentationAgent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import javax.management.JMException;
import javax.management.MBeanServer;
import javax.management.ObjectName;
import org.apache.camel.Service;
import org.apache.camel.management.CamelNamingStrategy;
public interface InstrumentationAgent extends Service {
    /**
     * Registers object with management infrastructure with a specific name. Object must be annotated or 
     * implement standard MBean interface.
     * @param obj
     * @param name
     * @throws JMException
     */
    void register(Object obj, ObjectName name) throws JMException;
    /**
     * Registers object with management infrastructure with a specific name. Object must be annotated or 
     * implement standard MBean interface.
     * @param obj
     * @param name
     * @param forceRegistration if set to true, then component will be registered despite existing component.
     * @throws JMException
     */
    void register(Object obj, ObjectName name, boolean forceRegistration) throws JMException;
    /**
     * Unregisters component based upon registered name
     * @param name
     * @throws JMException
     */
    void unregister(ObjectName name) throws JMException;
    /**
     * Get the MBeanServer which hosts managed components
     * NOTE: if the configuration is not set the JMXEnabled to be true, this method
     * will return null
     * @return the MBeanServer 
     */
    MBeanServer getMBeanServer();
    CamelNamingStrategy getNamingStrategy();
}
"
org.apache.camel.spi.Language,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
/**
 * Represents a language to be used for {@link Expression} or {@link Predicate} instances
 *
 * @version $Revision: 1.1 $
 */
public interface Language {
    Predicate<Exchange> createPredicate(String expression);
    Expression<Exchange> createExpression(String expression);
}
"
org.apache.camel.spi.LanguageResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.CamelContext;
/**
 * A pluggable strategy for resolving different languages in a loosely coupled manner
 * 
 * @version $Revision: 1.1 $
 */
public interface LanguageResolver {
    Language resolveLanguage(String name, CamelContext context);
}
"
org.apache.camel.spi.LifecycleStrategy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import java.util.Collection;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Route;
import org.apache.camel.Service;
import org.apache.camel.model.RouteType;
public interface LifecycleStrategy {
	/**
     * Notification on adding a {@see CamelContext}.
     */
	void onContextCreate(CamelContext context);
	/**
     * Notification on adding an {@see Endpoint}.
     */
	void onEndpointAdd(Endpoint endpoint);
	/**
     * Notification on adding a {@see Service}.
     */
	void onServiceAdd(CamelContext context, Service service);
	/**
     * Notification on adding {@see Route}(s).
     */
	void onRoutesAdd(Collection<Route> routes);
	/**
     * Notification on adding {@see Route}(s).
	 * @param context TODO
     */
	void beforeStartRouteType(CamelContext context, RouteType routeType);
}
"
org.apache.camel.spi.Policy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Processor;
/**
 * A strategy capable of applying interceptors to a processor
 *
 * @version $Revision: 1.1 $
 */
public interface Policy<E> {
    /**
     * Wraps any applicable interceptors around the given processor
     *
     * @param processor the processor to be intercepted
     * @return either the original processor or a processor wrapped in one or more interceptors
     */
    Processor wrap(Processor processor);
}
"
org.apache.camel.spi.Provider,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * A provider of newly constructed objects
 *
 * @version $Revision: 563607 $
 */
public interface Provider<T> {
    /**
     * Returns the newly constructed instance
     */
    T get();
}
"
org.apache.camel.spi.Registry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
/**
 * Represents a service registry which may be implemented via a Spring ApplicationContext,
 * via JNDI, a simple Map or the OSGI Service Registry
 *
 * @version $Revision: 1.1 $
 */
public interface Registry {
    /**
     * Looks up a service in the registry, returning the service or null if it could not be found.
     *
     * @param name the name of the service
     * @param type the type of the required service
     * @return the service from the registry or null if it could not be found
     */
    <T> T lookup(String name, Class<T> type);
    /**
     * Looks up a service in the registry based purely on name,
     * returning the service or null if it could not be found.
     *
     * @param name the name of the service
     * @return the service from the registry or null if it could not be found
     */
    Object lookup(String name);
}
"
org.apache.camel.spi.Synchronization,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
/**
 * Provides a hook for custom {@link Processor} or {@link Component} instances to respond to
 * completed or failed processing of an {@link Exchange} rather like Spring's
 * <a href=""http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/transaction/support/TransactionSynchronization.html"">TransactionSynchronization</a>
 *
 * @version $Revision: 1.1 $
 */
public interface Synchronization {
    /**
     * Called when the processing of the message exchange is complete
     *
     * @param exchange the excahnge being processed
     */
    void onComplete(Exchange exchange);
    /**
     * Called when the processing of the message exchange has failed for some reason. 
     * The exception which caused the problem is in {@link Exchange#getException()} and
     * there could be a fault message via {@link Exchange#getFault()}
     *
     * @param exchange the excahnge being processed
     */
    void onFailure(Exchange exchange);
}
"
org.apache.camel.spi.TypeConverterAware,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.TypeConverter;
/**
 * An interface for an object which is interested in being injected with the root {@link TypeConverter}
 * such as for implementing a fallback type converter
 *
 * @see DefaultTypeConverter#addFallbackConverter(TypeConverter) 
 * @version $Revision: 1.1 $
 */
public interface TypeConverterAware {
    void setTypeConverter(TypeConverter parentTypeConverter);
}
"
org.apache.camel.spi.UnitOfWork,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spi;
import org.apache.camel.Exchange;
/**
 * An object representing the unit of work processing an {@link Exchange}
 * which allows the use of {@link Synchronization} hooks. This object might map one-to-one with
 * a transaction in JPA or Spring; or might not.
 *
 * @version $Revision: 1.1 $
 */
public interface UnitOfWork {
    /**
     * Adds a synchronization hook
     *
     * @param synchronization
     */
    void addSynchronization(Synchronization synchronization);
    /**
     * Removes a synchronization hook
     *
     * @param synchronization
     */
    void removeSynchronization(Synchronization synchronization);
    /**
     * Invoked when this unit of work has been completed, whether it has failed or completed
     */
    void done(Exchange exchange);
}
"
org.apache.camel.util.AsyncProcessorHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.concurrent.CountDownLatch;
import org.apache.camel.AsyncCallback;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Exchange;
/**
 * Helper methods for AsyncProcessor objects.
 */
public final class AsyncProcessorHelper {
    private AsyncProcessorHelper() {
    }
    /**
     * Calls the async version of the processor's process method and waits
     * for it to complete before returning.  This can be used by AsyncProcessor
     * objects to implement their sync version of the process method.
     * 
     * @param processor
     * @param exchange
     * @throws Exception
     */
    public static void process(AsyncProcessor processor, Exchange exchange) throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        boolean sync = processor.process(exchange, new AsyncCallback() {
            public void done(boolean sync) {
                if (!sync) {
                    latch.countDown();
                }
            }
        });
        if (!sync) {
            latch.await();
        }
    }
}
"
org.apache.camel.util.CamelContextHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.spi.Injector;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A number of helper methods
 * 
 * @version $Revision: $
 */
public class CamelContextHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private CamelContextHelper() {        
    }
    /**
     * Returns the mandatory endpoint for the given URI or the
     * {@link org.apache.camel.NoSuchEndpointException} is thrown
     * 
     * @param camelContext
     * @param uri
     * @return
     */
    public static Endpoint getMandatoryEndpoint(CamelContext camelContext, String uri)
        throws NoSuchEndpointException {
        Endpoint endpoint = camelContext.getEndpoint(uri);
        if (endpoint == null) {
            throw new NoSuchEndpointException(uri);
        } else {
            return endpoint;
        }
    }
    /**
     * Converts the given value to the requested type
     */
    public static <T> T convertTo(CamelContext context, Class<T> type, Object value) {
        notNull(context, ""camelContext"");
        return context.getTypeConverter().convertTo(type, value);
    }
    /**
     * Converts the given value to the specified type throwing an {@link IllegalArgumentException}
     * if the value could not be converted to a non null value
     */
    public static <T> T mandatoryConvertTo(CamelContext context, Class<T> type, Object value) {
        T answer = convertTo(context, type, value);
        if (answer == null) {
            throw new IllegalArgumentException(""Value "" + value + "" converted to "" + type.getName() + "" cannot be null"");
        }
        return answer;
    }
    /**
     * Creates a new instance of the given type using the {@link Injector} on the given
     * {@link CamelContext}
     */
    public static <T> T newInstance(CamelContext context, Class<T> beanType) {
        return context.getInjector().newInstance(beanType);
    }
}
"
org.apache.camel.util.CollectionHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
/**
 * A number of helper methods for working with collections
 * 
 * @version $Revision: 1.1 $
 */
public class CollectionHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private CollectionHelper() {        
    }
    /**
     * Sets the value of the entry in the map for the given key, though if the
     * map already contains a value for the given key then the value is appended
     * to a list of values.
     * 
     * @param map the map to add the entry to
     * @param key the key in the map
     * @param value the value to put in the map
     */
    public static void appendValue(Map map, Object key, Object value) {
        Object oldValue = map.get(key);
        if (oldValue != null) {
            List list;
            if (oldValue instanceof List) {
                list = (List)oldValue;
            } else {
                list = new ArrayList();
                list.add(oldValue);
            }
            list.add(value);
        } else {
            map.put(key, value);
        }
    }
}
"
org.apache.camel.util.CollectionStringBuffer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
/**
 * A little helper class for converting a collection of values to a (usually comma separated) string.
 *
 * @version $Revision: 1.1 $
 */
public class CollectionStringBuffer {
    private StringBuffer buffer = new StringBuffer();
    private String separator;
    private boolean first = true;
    public CollectionStringBuffer() {
        this("", "");
    }
    public CollectionStringBuffer(String separator) {
        this.separator = separator;
    }
    @Override
    public String toString() {
        return buffer.toString();
    }
    public void append(Object value) {
        if (first) {
            first = false;
        }
        else {
            buffer.append(separator);
        }
        buffer.append(value);
    }
    public String getSeparator() {
        return separator;
    }
    public void setSeparator(String separator) {
        this.separator = separator;
    }
}
"
org.apache.camel.util.ExchangeHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Map;
import java.util.HashMap;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.InvalidPayloadException;
import org.apache.camel.InvalidTypeException;
import org.apache.camel.Message;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.NoSuchPropertyException;
import org.apache.camel.CamelContext;
/**
 * Some helper methods for working with {@link Exchange} objects
 * 
 * @version $Revision: 583494 $
 */
public class ExchangeHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private ExchangeHelper() {        
    }
    /**
     * Extracts the exchange property of the given name and type; if it is not present then the
     * default value will be used
     *
     * @param exchange the message exchange
     * @param propertyName the name of the property on the exchange
     * @param type the expected type of the property
     * @param defaultValue the default value to be used if the property name does not exist or could not be
     * converted to the given type
     * @return the property value as the given type or the defaultValue if it could not be found or converted
     */
    public static <T> T getExchangeProperty(Exchange exchange, String propertyName, Class<T> type, T defaultValue) {
        T answer = exchange.getProperty(propertyName, type);
        if (answer == null) {
            return defaultValue;
        }
        return answer;
    }
    /**
     * Attempts to resolve the endpoint for the given value
     * 
     * @param exchange the message exchange being processed
     * @param value the value which can be an {@link Endpoint} or an object
     *                which provides a String representation of an endpoint via
     *                {@link #toString()}
     * 
     * @return the endpoint
     * @throws NoSuchEndpointException if the endpoint cannot be resolved
     */
    @SuppressWarnings({""unchecked"" })
    public static <E extends Exchange> Endpoint<E> resolveEndpoint(E exchange, Object value)
        throws NoSuchEndpointException {
        Endpoint<E> endpoint;
        if (value instanceof Endpoint) {
            endpoint = (Endpoint<E>)value;
        } else {
            String uri = value.toString();
            endpoint = CamelContextHelper.getMandatoryEndpoint(exchange.getContext(), uri);
        }
        return endpoint;
    }
    public static <T> T getMandatoryProperty(Exchange exchange, String propertyName, Class<T> type)
        throws NoSuchPropertyException {
        T answer = exchange.getProperty(propertyName, type);
        if (answer == null) {
            throw new NoSuchPropertyException(exchange, propertyName, type);
        }
        return answer;
    }
    /**
     * Returns the mandatory inbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static Object getMandatoryInBody(Exchange exchange) throws InvalidPayloadException {
        Object answer = exchange.getIn().getBody();
        if (answer == null) {
            throw new InvalidPayloadException(exchange, Object.class);
        }
        return answer;
    }
    /**
     * Returns the mandatory inbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static <T> T getMandatoryInBody(Exchange exchange, Class<T> type) throws InvalidPayloadException {
        T answer = exchange.getIn().getBody(type);
        if (answer == null) {
            throw new InvalidPayloadException(exchange, type);
        }
        return answer;
    }
    /**
     * Returns the mandatory outbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static Object getMandatoryOutBody(Exchange exchange) throws InvalidPayloadException {
        Object answer = exchange.getOut().getBody();
        if (answer == null) {
            throw new InvalidPayloadException(exchange, Object.class);
        }
        return answer;
    }
    /**
     * Returns the mandatory outbound message body of the correct type or throws
     * an exception if it is not present
     */
    public static <T> T getMandatoryOutBody(Exchange exchange, Class<T> type) throws InvalidPayloadException {
        T answer = exchange.getOut().getBody(type);
        if (answer == null) {
            throw new InvalidPayloadException(exchange, type);
        }
        return answer;
    }
    /**
     * Converts the value to the given expected type or throws an exception
     */
    public static <T> T convertToMandatoryType(Exchange exchange, Class<T> type, Object value)
        throws InvalidTypeException {
        T answer = convertToType(exchange, type, value);
        if (answer == null) {
            throw new InvalidTypeException(exchange, value, type);
        }
        return answer;
    }
    /**
     * Converts the value to the given expected type returning null if it could
     * not be converted
     */
    public static <T> T convertToType(Exchange exchange, Class<T> type, Object value) {
        return exchange.getContext().getTypeConverter().convertTo(type, value);
    }
    /**
     * Copies the results of a message exchange from the source exchange to the result exchange
     * which will copy the out and fault message contents and the exception
     *
     * @param result the result exchange which will have the output and error state added
     * @param source the source exchange which is not modified
     */
    public static void copyResults(Exchange result, Exchange source) {
        if (result != source) {
            result.setException(source.getException());
            Message fault = source.getFault(false);
            if (fault != null) {
                result.getFault(true).copyFrom(fault);
            }
            Message out = source.getOut(false);
            if (out != null) {
                result.getOut(true).copyFrom(out);
            }
        }
    }
    /**
     * Returns true if the given exchange pattern (if defined) can support IN messagea
     *
     * @param exchange the exchange to interrogate
     * @return true if the exchange is defined as an {@link ExchangePattern} which supports
     * IN messages
     */
    public static boolean isInCapable(Exchange exchange) {
        ExchangePattern pattern = exchange.getPattern();
        return pattern != null && pattern.isInCapable();
    }
    /**
     * Returns true if the given exchange pattern (if defined) can support OUT messagea
     *
     * @param exchange the exchange to interrogate
     * @return true if the exchange is defined as an {@link ExchangePattern} which supports
     * OUT messages
     */
    public static boolean isOutCapable(Exchange exchange) {
        ExchangePattern pattern = exchange.getPattern();
        return pattern != null && pattern.isOutCapable();
    }
    /**
     * Creates a new instance of the given type from the injector
     */
    public static <T> T newInstance(Exchange exchange, Class<T> type) {
        return exchange.getContext().getInjector().newInstance(type);
    }
    /**
     * Creates a Map of the variables which are made available to a script or template
     *
     * @param exchange the exchange to make available
     * @return a Map populated with the require dvariables
     */
    public static Map createVariableMap(Exchange exchange) {
        Map answer = new HashMap();
        populateVariableMap(exchange, answer);
        return answer;
    }
    /**
     * Populates the Map with the variables which are made available to a script or template
     *
     * @param exchange the exchange to make available
     * @param map      the map to populate
     * @return a Map populated with the require dvariables
     */
    public static void populateVariableMap(Exchange exchange, Map map) {
        map.put(""exchange"", exchange);
        Message in = exchange.getIn();
        map.put(""in"", in);
        map.put(""request"", in);
        map.put(""headers"", in.getHeaders());
        map.put(""body"", in.getBody())
                ;
        if (isOutCapable(exchange)) {
            Message out = exchange.getOut(true);
            map.put(""out"", out);
            map.put(""response"", out);
        }
        map.put(""camelContext"", exchange.getContext());
    }
    /**
     * Returns the MIME content type on the input message or null if one is not defined
     */
    public static String getContentType(Exchange exchange) {
       return exchange.getIn().getHeader(""Content-Type"", String.class);
    }
}
"
org.apache.camel.util.ExchangeHelperTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.List;
import junit.framework.TestCase;
import org.apache.camel.Exchange;
import org.apache.camel.NoSuchPropertyException;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 1.1 $
 */
public class ExchangeHelperTest extends TestCase {
    private static final transient Log LOG = LogFactory.getLog(ExchangeHelperTest.class);
    protected Exchange exchange;
    public void testValidProperty() throws Exception {
        String value = ExchangeHelper.getMandatoryProperty(exchange, ""foo"", String.class);
        assertEquals(""foo property"", ""123"", value);
    }
    public void testMissingProperty() throws Exception {
        try {
            String value = ExchangeHelper.getMandatoryProperty(exchange, ""bar"", String.class);
            fail(""Should have failed but got: "" + value);
        } catch (NoSuchPropertyException e) {
            LOG.debug(""Caught expected: "" + e, e);
        }
    }
    public void testPropertyOfIncompatibleType() throws Exception {
        try {
            List value = ExchangeHelper.getMandatoryProperty(exchange, ""foo"", List.class);
            fail(""Should have failed but got: "" + value);
        } catch (NoSuchPropertyException e) {
            LOG.debug(""Caught expected: "" + e, e);
        }
    }
    @Override
    protected void setUp() throws Exception {
        exchange = new DefaultExchange(new DefaultCamelContext());
        exchange.setProperty(""foo"", 123);
    }
}
"
org.apache.camel.util.ExpressionComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Comparator;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * An implementation of {@link Comparator} which takes an {@link Expression} which is evaluated
 * on each exchange to compare
 *  
 * @version $Revision: 1.1 $
 */
public class ExpressionComparator<E extends Exchange> implements Comparator<E> {
    private final Expression<E> expression;
    public ExpressionComparator(Expression<E> expression) {
        this.expression = expression;
    }
    public int compare(E e1, E e2) {
        Object o1 = expression.evaluate(e1);
        Object o2 = expression.evaluate(e2);
        return ObjectHelper.compare(o1, o2);
    }
}
"
org.apache.camel.util.ExpressionHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * A collection of helper methods for working with expressions.
 * 
 * @version $Revision: 1.1 $
 */
public class ExpressionHelper {
    /**
     * Utility classes should not have a public constructor.
     */
    private ExpressionHelper() {        
    }
    /**
     * Evaluates the given expression on the exchange as a String value
     * 
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @return the result of the evaluation as a string.
     */
    public static <E extends Exchange> String evaluateAsString(Expression<E> expression, E exchange) {
        return evaluateAsType(expression, exchange, String.class);
    }
    /**
     * Evaluates the given expression on the exchange, converting the result to
     * the given type
     * 
     * @param expression the expression to evaluate
     * @param exchange the exchange to use to evaluate the expression
     * @param resultType the type of the result that is required
     * @return the result of the evaluation as the specified type.
     */
    public static <T, E extends Exchange> T evaluateAsType(Expression<E> expression, E exchange,
                                                           Class<T> resultType) {
        Object value = expression.evaluate(exchange);
        return exchange.getContext().getTypeConverter().convertTo(resultType, value);
    }
}
"
org.apache.camel.util.ExpressionListComparator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Comparator;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
/**
 * An implementation of {@link java.util.Comparator} which takes a list of
 * {@link org.apache.camel.Expression} objects which is evaluated
 * on each exchange to compare them
 *
 * @version $Revision: 1.1 $
 */
public class ExpressionListComparator implements Comparator<Exchange> {
    private final List<Expression> expressions;
    public ExpressionListComparator(List<Expression> expressions) {
        this.expressions = expressions;
    }
    public int compare(Exchange e1, Exchange e2) {
        for (Expression expression : expressions) {
            Object o1 = expression.evaluate(e1);
            Object o2 = expression.evaluate(e2);
            int answer = ObjectHelper.compare(o1, o2);
            if (answer != 0) {
                return answer;
            }
        }
        return 0;
    }
}
"
org.apache.camel.util.FactoryFinder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.camel.spi.Injector;
public class FactoryFinder {
    private final String path;
    private final ConcurrentHashMap classMap = new ConcurrentHashMap();
    public FactoryFinder() {
        this(""META-INF/services/org/apache/camel/"");
    }
    public FactoryFinder(String path) {
        this.path = path;
    }
    /**
     * Creates a new instance of the given key
     * 
     * @param key is the key to add to the path to find a text file containing
     *                the factory name
     * @return a newly created instance
     */
    public Object newInstance(String key) throws IllegalAccessException, InstantiationException, IOException,
        ClassNotFoundException {
        return newInstance(key, (String)null);
    }
    public Object newInstance(String key, String propertyPrefix) throws IllegalAccessException,
        InstantiationException, IOException, ClassNotFoundException {
        Class clazz = findClass(key, propertyPrefix);
        return clazz.newInstance();
    }
    public Object newInstance(String key, Injector injector) throws IOException, ClassNotFoundException {
        return newInstance(key, injector, (String)null);
    }
    public Object newInstance(String key, Injector injector, String propertyPrefix) throws IOException,
        ClassNotFoundException {
        Class type = findClass(key, propertyPrefix);
        return injector.newInstance(type);
    }
    public <T> T newInstance(String key, Injector injector, Class<T> expectedType) throws IOException,
        ClassNotFoundException {
        return newInstance(key, injector, null, expectedType);
    }
    public <T> T newInstance(String key, Injector injector, String propertyPrefix, Class<T> expectedType)
        throws IOException, ClassNotFoundException {
        Class type = findClass(key, propertyPrefix);
        Object value = injector.newInstance(type);
        if (expectedType.isInstance(value)) {
            return expectedType.cast(value);
        } else {
            throw new ClassCastException(""Not instanceof "" + expectedType.getName() + "" value: "" + value);
        }
    }
    public <T> List<T> newInstances(String key, Injector injector, Class<T> type) throws IOException,
        ClassNotFoundException {
        List<Class> list = findClasses(key);
        List<T> answer = new ArrayList<T>(list.size());
        answer.add(newInstance(key, injector, type));
        return answer;
    }
    public Class findClass(String key) throws ClassNotFoundException, IOException {
        return findClass(key, null);
    }
    public Class findClass(String key, String propertyPrefix) throws ClassNotFoundException, IOException {
        if (propertyPrefix == null) {
            propertyPrefix = """";
        }
        Class clazz = (Class)classMap.get(propertyPrefix + key);
        if (clazz == null) {
            clazz = newInstance(doFindFactoryProperies(key), propertyPrefix);
            classMap.put(propertyPrefix + key, clazz);
        }
        return clazz;
    }
    public List<Class> findClasses(String key) throws ClassNotFoundException, IOException {
        return findClasses(key, null);
    }
    public List<Class> findClasses(String key, String propertyPrefix) throws ClassNotFoundException,
        IOException {
        // TODO change to support finding multiple classes on the classpath!
        Class type = findClass(key, propertyPrefix);
        return Collections.singletonList(type);
    }
    public String getPath() {
        return path;
    }
    private Class newInstance(Properties properties, String propertyPrefix) throws ClassNotFoundException,
        IOException {
        String className = properties.getProperty(propertyPrefix + ""class"");
        if (className == null) {
            throw new IOException(""Expected property is missing: "" + propertyPrefix + ""class"");
        }
        Class clazz = null;
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        if (loader != null) {
            try {
                clazz = loader.loadClass(className);
            } catch (ClassNotFoundException e) {
                // ignore
            }
        }
        if (clazz == null) {
            clazz = FactoryFinder.class.getClassLoader().loadClass(className);
        }
        return clazz;
    }
    private Properties doFindFactoryProperies(String key) throws IOException {
        String uri = path + key;
        // lets try the thread context class loader first
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        if (classLoader == null) {
            classLoader = getClass().getClassLoader();
        }
        InputStream in = classLoader.getResourceAsStream(uri);
        if (in == null) {
            in = FactoryFinder.class.getClassLoader().getResourceAsStream(uri);
            if (in == null) {
                throw new NoFactoryAvailableException(uri);
            }
        }
        // lets load the file
        BufferedInputStream reader = null;
        try {
            reader = new BufferedInputStream(in);
            Properties properties = new Properties();
            properties.load(reader);
            return properties;
        } finally {
            try {
                reader.close();
            } catch (Exception ignore) {
            }
        }
    }
}
"
org.apache.camel.util.IntrospectionSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.TypeConverter;
import java.beans.PropertyEditor;
import java.beans.PropertyEditorManager;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
public class IntrospectionSupport {
    /**
     * Utility classes should not have a public constructor.
     */
    private IntrospectionSupport() {        
    }
    public static boolean getProperties(Object target, Map props, String optionPrefix) {
        boolean rc = false;
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        if (optionPrefix == null) {
            optionPrefix = """";
        }
        Class clazz = target.getClass();
        Method[] methods = clazz.getMethods();
        for (int i = 0; i < methods.length; i++) {
            Method method = methods[i];
            String name = method.getName();
            Class type = method.getReturnType();
            Class params[] = method.getParameterTypes();
            if (name.startsWith(""get"") && params.length == 0 && type != null && isSettableType(type)) {
                try {
                    Object value = method.invoke(target, new Object[] {});
                    if (value == null) {
                        continue;
                    }
                    String strValue = convertToString(value, type);
                    if (strValue == null) {
                        continue;
                    }
                    name = name.substring(3, 4).toLowerCase() + name.substring(4);
                    props.put(optionPrefix + name, strValue);
                    rc = true;
                } catch (Throwable ignore) {
                }
            }
        }
        return rc;
    }
    public static Object getProperty(Object target, String prop) throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (prop == null) {
            throw new IllegalArgumentException(""prop was null."");
        }
        prop = prop.substring(0, 1).toUpperCase() + prop.substring(1);
        Class clazz = target.getClass();
        Method method = getPropertyGetter(clazz, prop);
        return method.invoke(target, new Object[] {});
    }
    public static Method getPropertyGetter(Class type, String propertyName) throws NoSuchMethodException {
        Method method = type.getMethod(""get"" + ObjectHelper.capitalize(propertyName), new Class[] {});
        return method;
    }
    public static boolean setProperties(Object target, Map props, String optionPrefix) throws Exception {
        boolean rc = false;
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        for (Iterator iter = props.keySet().iterator(); iter.hasNext();) {
            String name = (String)iter.next();
            if (name.startsWith(optionPrefix)) {
                Object value = props.get(name);
                name = name.substring(optionPrefix.length());
                if (setProperty(target, name, value)) {
                    iter.remove();
                    rc = true;
                }
            }
        }
        return rc;
    }
    public static Map extractProperties(Map props, String optionPrefix) {
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        HashMap rc = new HashMap(props.size());
        for (Iterator iter = props.keySet().iterator(); iter.hasNext();) {
            String name = (String)iter.next();
            if (name.startsWith(optionPrefix)) {
                Object value = props.get(name);
                name = name.substring(optionPrefix.length());
                rc.put(name, value);
                iter.remove();
            }
        }
        return rc;
    }
    public static boolean setProperties(TypeConverter typeConverter, Object target, Map props) throws Exception {
        boolean rc = false;
        if (target == null) {
            throw new IllegalArgumentException(""target was null."");
        }
        if (props == null) {
            throw new IllegalArgumentException(""props was null."");
        }
        for (Iterator iter = props.entrySet().iterator(); iter.hasNext();) {
            Map.Entry entry = (Entry)iter.next();
            if (setProperty(typeConverter, target, (String)entry.getKey(), entry.getValue())) {
                iter.remove();
                rc = true;
            }
        }
        return rc;
    }
    public static boolean setProperties(Object target, Map props) throws Exception {
        return setProperties(null, target, props);
    }
    public static boolean setProperty(TypeConverter typeConverter, Object target, String name, Object value) throws Exception {
        try {
            Class clazz = target.getClass();
            Method setter = findSetterMethod(typeConverter, clazz, name, value);
            if (setter == null) {
                return false;
            }
            // If the type is null or it matches the needed type, just use the
            // value directly
            if (value == null || value.getClass() == setter.getParameterTypes()[0]) {
                setter.invoke(target, new Object[] {value});
            } else {
                // We need to convert it
                Object convertedValue = convert(typeConverter, setter.getParameterTypes()[0], value);
                setter.invoke(target, new Object[] {convertedValue});
            }
            return true;
        }
        catch (InvocationTargetException e) {
            Throwable throwable = e.getTargetException();
            if (throwable instanceof Exception) {
                Exception exception = (Exception) throwable;
                throw exception;
            }
            else {
                Error error = (Error) throwable;
                throw error;
            }
        }
    }
    public static boolean setProperty(Object target, String name, Object value) throws Exception {
        return setProperty(null, target, name, value);
    }
    private static Object convert(TypeConverter typeConverter, Class type, Object value) throws URISyntaxException {
        if (typeConverter != null) {
            Object answer = typeConverter.convertTo(type, value);
            if (answer == null) {
                throw new IllegalArgumentException(""Could not convert \"""" + value + ""\"" to "" + type.getName());
            }
            return answer;
        }
        PropertyEditor editor = PropertyEditorManager.findEditor(type);
        if (editor != null) {
            editor.setAsText(value.toString());
            return editor.getValue();
        }
        if (type == URI.class) {
            return new URI(value.toString());
        }
        return null;
    }
    private static String convertToString(Object value, Class type) throws URISyntaxException {
        PropertyEditor editor = PropertyEditorManager.findEditor(type);
        if (editor != null) {
            editor.setValue(value);
            return editor.getAsText();
        }
        if (type == URI.class) {
            return ((URI)value).toString();
        }
        return null;
    }
    private static Method findSetterMethod(TypeConverter typeConverter, Class clazz, String name, Object value) {
        // Build the method name.
        name = ""set"" + ObjectHelper.capitalize(name);
        while (clazz != Object.class) {
            Method[] methods = clazz.getMethods();
            for (int i = 0; i < methods.length; i++) {
                Method method = methods[i];
                Class params[] = method.getParameterTypes();
                if (method.getName().equals(name) && params.length == 1) {
                    Class paramType = params[0];
                    if (typeConverter != null || isSettableType(paramType) || paramType.isInstance(value)) {
                        return method;
                    }
                }
            }
            clazz = clazz.getSuperclass();
        }
        return null;
    }
    private static boolean isSettableType(Class clazz) {
        if (PropertyEditorManager.findEditor(clazz) != null) {
            return true;
        }
        if (clazz == URI.class) {
            return true;
        }
        if (clazz == Boolean.class) {
            return true;
        }
        return false;
    }
    public static String toString(Object target) {
        return toString(target, Object.class);
    }
    public static String toString(Object target, Class stopClass) {
        LinkedHashMap map = new LinkedHashMap();
        addFields(target, target.getClass(), stopClass, map);
        StringBuffer buffer = new StringBuffer(simpleName(target.getClass()));
        buffer.append("" {"");
        Set entrySet = map.entrySet();
        boolean first = true;
        for (Iterator iter = entrySet.iterator(); iter.hasNext();) {
            Map.Entry entry = (Map.Entry)iter.next();
            if (first) {
                first = false;
            } else {
                buffer.append("", "");
            }
            buffer.append(entry.getKey());
            buffer.append("" = "");
            appendToString(buffer, entry.getValue());
        }
        buffer.append(""}"");
        return buffer.toString();
    }
    protected static void appendToString(StringBuffer buffer, Object value) {
        // if (value instanceof ActiveMQDestination) {
        // ActiveMQDestination destination = (ActiveMQDestination) value;
        // buffer.append(destination.getQualifiedName());
        // }
        // else {
        buffer.append(value);
        // }
    }
    public static String simpleName(Class clazz) {
        String name = clazz.getName();
        int p = name.lastIndexOf(""."");
        if (p >= 0) {
            name = name.substring(p + 1);
        }
        return name;
    }
    private static void addFields(Object target, Class startClass, Class stopClass, LinkedHashMap map) {
        if (startClass != stopClass) {
            addFields(target, startClass.getSuperclass(), stopClass, map);
        }
        Field[] fields = startClass.getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            if (Modifier.isStatic(field.getModifiers()) || Modifier.isTransient(field.getModifiers()) || Modifier.isPrivate(field.getModifiers())) {
                continue;
            }
            try {
                field.setAccessible(true);
                Object o = field.get(target);
                if (o != null && o.getClass().isArray()) {
                    try {
                        o = Arrays.asList((Object[])o);
                    } catch (Throwable e) {
                    }
                }
                map.put(field.getName(), o);
            } catch (Throwable e) {
                e.printStackTrace();
            }
        }
    }
}
"
org.apache.camel.util.IOHelper,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.IOException;
/**
 * @version $Revision: 1.1 $
 */
public class IOHelper {
    /**
     * A factory method which creates an {@link IOException} from the given
     * exception and message
     */
    public static IOException createIOException(Throwable cause) {
        return createIOException(cause.getMessage(), cause);
    }
    /**
     * A factory method which creates an {@link IOException} from the given
     * exception and message
     */
    public static IOException createIOException(String message, Throwable cause) {
        IOException answer = new IOException(message);
        answer.initCause(cause);
        return answer;
    }
}
"
org.apache.camel.util.LRUCache,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.LinkedHashMap;
import java.util.Map;
/**
 * A Least Recently Used Cache
 *
 * @version $Revision: 1.1 $
 */
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final long serialVersionUID = -342098639681884413L;
    private int maxCacheSize = 10000;
    public LRUCache(int maximumCacheSize) {
        this(maximumCacheSize, maximumCacheSize, 0.75f, true);
    }
    /**
     * Constructs an empty <tt>LRUCache</tt> instance with the
     * specified initial capacity, maximumCacheSize,load factor and ordering mode.
     *
     * @param initialCapacity  the initial capacity.
     * @param maximumCacheSize
     * @param loadFactor       the load factor.
     * @param accessOrder      the ordering mode - <tt>true</tt> for
     *                         access-order, <tt>false</tt> for insertion-order.
     * @throws IllegalArgumentException if the initial capacity is negative
     *                                  or the load factor is nonpositive.
     */
    public LRUCache(int initialCapacity, int maximumCacheSize, float loadFactor, boolean accessOrder) {
        super(initialCapacity, loadFactor, accessOrder);
        this.maxCacheSize = maximumCacheSize;
    }
    /**
     * @return Returns the maxCacheSize.
     */
    public int getMaxCacheSize() {
        return maxCacheSize;
    }
    protected boolean removeEldestEntry(Map.Entry entry) {
        return size() > maxCacheSize;
    }
}
"
org.apache.camel.util.NoFactoryAvailableException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.IOException;
/**
 * Thrown if no factory resource is available for the given URI
 *
 * @version $Revision: 563607 $
 */
public class NoFactoryAvailableException extends IOException {
    private final String uri;
    public NoFactoryAvailableException(String uri) {
        super(""Could not find factory class for resource: "" + uri);
        this.uri = uri;
    }
    public String getUri() {
        return uri;
    }
}
"
org.apache.camel.util.ObjectHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.Body;
import org.apache.camel.converter.ObjectConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.io.OutputStream;
import java.io.Closeable;
import java.io.IOException;
/**
 * A number of useful helper methods for working with Objects
 * 
 * @version $Revision: 583494 $
 */
public class ObjectHelper {
    private static final transient Log LOG = LogFactory.getLog(ObjectHelper.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private ObjectHelper() {        
    }
    /**
     * A helper method for comparing objects for equality while handling nulls
     */
    public static boolean equals(Object a, Object b) {
        if (a == b) {
            return true;
        }
        return a != null && b != null && a.equals(b);
    }
    /**
     * Returns true if the given object is equal to any of the expected value
     * 
     * @param object
     * @param values
     * @return
     */
    public static boolean isEqualToAny(Object object, Object... values) {
        for (Object value : values) {
            if (equals(object, value)) {
                return true;
            }
        }
        return false;
    }
    /**
     * A helper method for performing an ordered comparsion on the objects
     * handling nulls and objects which do not handle sorting gracefully
     */
    public static int compare(Object a, Object b) {
        if (a == b) {
            return 0;
        }
        if (a == null) {
            return -1;
        }
        if (b == null) {
            return 1;
        }
        if (a instanceof Comparable) {
            Comparable comparable = (Comparable)a;
            return comparable.compareTo(b);
        } else {
            int answer = a.getClass().getName().compareTo(b.getClass().getName());
            if (answer == 0) {
                answer = a.hashCode() - b.hashCode();
            }
            return answer;
        }
    }
    public static void notNull(Object value, String name) {
        if (value == null) {
            throw new IllegalArgumentException(name + "" must be specified"");
        }
    }
    public static String[] splitOnCharacter(String value, String needle, int count) {
        String rc[] = new String[count];
        rc[0] = value;
        for (int i = 1; i < count; i++) {
            String v = rc[i - 1];
            int p = v.indexOf(needle);
            if (p < 0) {
                return rc;
            }
            rc[i - 1] = v.substring(0, p);
            rc[i] = v.substring(p + 1);
        }
        return rc;
    }
    /**
     * Removes any starting characters on the given text which match the given
     * character
     * 
     * @param text the string
     * @param ch the initial characters to remove
     * @return either the original string or the new substring
     */
    public static String removeStartingCharacters(String text, char ch) {
        int idx = 0;
        while (text.charAt(idx) == ch) {
            idx++;
        }
        if (idx > 0) {
            return text.substring(idx);
        }
        return text;
    }
    public static String capitalize(String text) {
        int length = text.length();
        if (text == null || length == 0) {
            return text;
        }
        String answer = text.substring(0, 1).toUpperCase();
        if (length > 1) {
            answer += text.substring(1, length);
        }
        return answer;
    }
    /**
     * Returns true if the collection contains the specified value
     */
    public static boolean contains(Object collectionOrArray, Object value) {
        if (collectionOrArray instanceof Collection) {
            Collection collection = (Collection)collectionOrArray;
            return collection.contains(value);
        } else {
            Iterator iter = ObjectConverter.iterator(value);
            while (iter.hasNext()) {
                if (equals(value, iter.next())) {
                    return true;
                }
            }
            return false;
        }
    }
    /**
     * Returns the predicate matching boolean on a {@link List} result set where
     * if the first element is a boolean its value is used otherwise this method
     * returns true if the collection is not empty
     * 
     * @returns true if the first element is a boolean and its value is true or
     *          if the list is non empty
     */
    public static boolean matches(List list) {
        if (!list.isEmpty()) {
            Object value = list.get(0);
            if (value instanceof Boolean) {
                Boolean flag = (Boolean)value;
                return flag.booleanValue();
            } else {
                // lets assume non-empty results are true
                return true;
            }
        }
        return false;
    }
    public static boolean isNotNullAndNonEmpty(String text) {
        return text != null && text.trim().length() > 0;
    }
    public static boolean isNullOrBlank(String text) {
        return text == null || text.trim().length() <= 0;
    }
    /**
     * A helper method to access a system property, catching any security
     * exceptions
     * 
     * @param name the name of the system property required
     * @param defaultValue the default value to use if the property is not
     *                available or a security exception prevents access
     * @return the system property value or the default value if the property is
     *         not available or security does not allow its access
     */
    public static String getSystemProperty(String name, String defaultValue) {
        try {
            return System.getProperty(name, defaultValue);
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Caught security exception accessing system property: "" + name + "". Reason: "" + e,
                          e);
            }
            return defaultValue;
        }
    }
    /**
     * Returns the type name of the given type or null if the type variable is
     * null
     */
    public static String name(Class type) {
        return type != null ? type.getName() : null;
    }
    /**
     * Returns the type name of the given value
     */
    public static String className(Object value) {
        return name(value != null ? value.getClass() : null);
    }
    /**
     * Attempts to load the given class name using the thread context class
     * loader or the class loader used to load this class
     * 
     * @param name the name of the class to load
     * @return the class or null if it could not be loaded
     */
    public static Class<?> loadClass(String name) {
        return loadClass(name, ObjectHelper.class.getClassLoader());
    }
    /**
     * Attempts to load the given class name using the thread context class
     * loader or the given class loader
     * 
     * @param name the name of the class to load
     * @param loader the class loader to use after the thread context class
     *                loader
     * @return the class or null if it could not be loaded
     */
    public static Class<?> loadClass(String name, ClassLoader loader) {
        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        if (contextClassLoader != null) {
            try {
                return contextClassLoader.loadClass(name);
            } catch (ClassNotFoundException e) {
                try {
                    return loader.loadClass(name);
                } catch (ClassNotFoundException e1) {
                    LOG.debug(""Could not find class: "" + name + "". Reason: "" + e);
                }
            }
        }
        return null;
    }
    /**
     * A helper method to invoke a method via reflection and wrap any exceptions
     * as {@link RuntimeCamelException} instances
     * 
     * @param method the method to invoke
     * @param instance the object instance (or null for static methods)
     * @param parameters the parameters to the method
     * @return the result of the method invocation
     */
    public static Object invokeMethod(Method method, Object instance, Object... parameters) {
        try {
            return method.invoke(instance, parameters);
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeCamelException(e.getCause());
        }
    }
    /**
     * Returns a list of methods which are annotated with the given annotation
     * 
     * @param type the type to reflect on
     * @param annotationType the annotation type
     * @return a list of the methods found
     */
    public static List<Method> findMethodsWithAnnotation(Class<?> type,
                                                         Class<? extends Annotation> annotationType) {
        List<Method> answer = new ArrayList<Method>();
        do {
            Method[] methods = type.getDeclaredMethods();
            for (Method method : methods) {
                if (method.getAnnotation(annotationType) != null) {
                    answer.add(method);
                }
            }
            type = type.getSuperclass();
        } while (type != null);
        return answer;
    }
    /**
     * Turns the given object arrays into a meaningful string
     * 
     * @param objects an array of objects or null
     * @return a meaningful string
     */
    public static String asString(Object[] objects) {
        if (objects == null) {
            return ""null"";
        } else {
            StringBuffer buffer = new StringBuffer(""{"");
            int counter = 0;
            for (Object object : objects) {
                if (counter++ > 0) {
                    buffer.append("", "");
                }
                String text = (object == null) ? ""null"" : object.toString();
                buffer.append(text);
            }
            buffer.append(""}"");
            return buffer.toString();
        }
    }
    /**
     * Returns true if a class is assignable from another class like the
     * {@link Class#isAssignableFrom(Class)} method but which also includes
     * coercion between primitive types to deal with Java 5 primitive type
     * wrapping
     */
    public static boolean isAssignableFrom(Class a, Class b) {
        a = convertPrimitiveTypeToWrapperType(a);
        b = convertPrimitiveTypeToWrapperType(b);
        return a.isAssignableFrom(b);
    }
    /**
     * Converts primitive types such as int to its wrapper type like
     * {@link Integer}
     */
    public static Class convertPrimitiveTypeToWrapperType(Class type) {
        Class rc = type;
        if (type.isPrimitive()) {
            if (type == int.class) {
                rc = Integer.class;
            } else if (type == long.class) {
                rc = Long.class;
            } else if (type == double.class) {
                rc = Double.class;
            } else if (type == float.class) {
                rc = Float.class;
            } else if (type == short.class) {
                rc = Short.class;
            } else if (type == byte.class) {
                rc = Byte.class;
/*
            } else if (type == boolean.class) {
                rc = Boolean.class;
*/
            }
        }
        return rc;
    }
    /**
     * Helper method to return the default character set name
     */
    public static String getDefaultCharacterSet() {
        return Charset.defaultCharset().name();
    }
    /**
     * Returns the Java Bean property name of the given method, if it is a setter
     */
    public static String getPropertyName(Method method) {
        String propertyName = method.getName();
        if (propertyName.startsWith(""set"") && method.getParameterTypes().length == 1) {
            propertyName = propertyName.substring(3, 4).toLowerCase() + propertyName.substring(4);
        }
        return propertyName;
    }
    /**
     * Returns true if the given collection of annotations matches the given type
     */
    public static boolean hasAnnotation(Annotation[] annotations, Class<?> type) {
        for (Annotation annotation : annotations) {
            if (type.isInstance(annotation)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Closes the given resource if it is available, logging any closing exceptions to the given log
     *
     * @param closeable the object to close
     * @param name the name of the resource
     * @param log the log to use when reporting closure warnings
     */
    public static void close(Closeable closeable, String name, Log log) {
        if (closeable != null) {
            try {
                closeable.close();
            }
            catch (IOException e) {
                log.warn(""Could not close "" + name + "". Reason: ""+ e, e);
            }
        }
    }
    /**
     * Converts the given value to the required type or throw a meaningful exception
     */
    public static <T> T cast(Class<T> toType, Object value) {
        if (toType == boolean.class) {
            return (T) cast(Boolean.class, value);
        }
        else if (toType.isPrimitive()) {
            Class newType = convertPrimitiveTypeToWrapperType(toType);
            if (newType != toType) {
                return (T) cast(newType, value);
            }
        }
        try {
            return toType.cast(value);
        }
        catch (ClassCastException e) {
            throw new IllegalArgumentException(""Failed to convert: "" + value + "" to type: "" + toType.getName() + "" due to: "" + e, e);
        }
    }
    /**
     * A helper method to create a new instance of a type using the default constructor arguments.
     */
    public static <T> T newInstance(Class<T> type) {
        try {
            return type.newInstance();
        } catch (InstantiationException e) {
            throw new RuntimeCamelException(e.getCause());
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * A helper method to create a new instance of a type using the default constructor arguments.
     */
    public static <T> T newInstance(Class<?> actualType, Class<T> expectedType) {
        try {
            Object value = actualType.newInstance();
            return cast(expectedType, value);
        } catch (InstantiationException e) {
            throw new RuntimeCamelException(e.getCause());
        } catch (IllegalAccessException e) {
            throw new RuntimeCamelException(e);
        }
    }
}
"
org.apache.camel.util.ObjectHelperTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import junit.framework.TestCase;
import java.lang.reflect.Method;
/**
 * @version $Revision: 566604 $
 */
public class ObjectHelperTest extends TestCase {
    public void testRemoveInitialCharacters() throws Exception {
        assertEquals(ObjectHelper.removeStartingCharacters(""foo"", '/'), ""foo"");
        assertEquals(ObjectHelper.removeStartingCharacters(""/foo"", '/'), ""foo"");
        assertEquals(ObjectHelper.removeStartingCharacters(""//foo"", '/'), ""foo"");
    }
    public void testGetPropertyName() throws Exception {
        Method method = getClass().getMethod(""setCheese"", String.class);
        assertNotNull(""should have found a method!"", method);
        String name = ObjectHelper.getPropertyName(method);
        assertEquals(""Property name"", ""cheese"", name);
    }
    public void setCheese(String cheese) {
    }
}
"
org.apache.camel.util.ProducerCache,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.HashMap;
import java.util.Map;
import org.apache.camel.AsyncCallback;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.FailedToCreateProducerException;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 576920 $
 */
public class ProducerCache<E extends Exchange> extends ServiceSupport {
    private static final Log LOG = LogFactory.getLog(ProducerCache.class);
    private Map<String, Producer<E>> producers = new HashMap<String, Producer<E>>();
    public synchronized Producer<E> getProducer(Endpoint<E> endpoint) {
        String key = endpoint.getEndpointUri();
        Producer<E> answer = producers.get(key);
        if (answer == null) {
            try {
                answer = endpoint.createProducer();
                answer.start();
            } catch (Exception e) {
                throw new FailedToCreateProducerException(endpoint, e);
            }
            producers.put(key, answer);
        }
        return answer;
    }
    /**
     * Sends the exchange to the given endpoint
     * 
     * @param endpoint the endpoint to send the exchange to
     * @param exchange the exchange to send
     */
    public void send(Endpoint<E> endpoint, E exchange) {
        try {
            Producer<E> producer = getProducer(endpoint);
            producer.process(exchange);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * @{link Processor} to populate the exchange
     * 
     * @param endpoint the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, Processor processor) {
        try {
            Producer<E> producer = getProducer(endpoint);
            E exchange = producer.createExchange();
            return sendExchange(endpoint, producer, processor, exchange);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * @{link Processor} to populate the exchange.  The callback 
     * will be called when the exchange is completed.
     * 
     * @param endpoint the endpoint to send the exchange to
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, Processor processor, AsyncCallback callback) {
        try {
            Producer<E> producer = getProducer(endpoint);
            E exchange = producer.createExchange();
            boolean sync = sendExchange(endpoint, producer, processor, exchange, callback);
            setProcessedSync(exchange, sync);
            return exchange;
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    public static boolean isProcessedSync(Exchange exchange) {
        Boolean rc = exchange.getProperty(ProducerCache.class.getName() + "".SYNC"", Boolean.class);
        return rc == null ? false : rc;
    }
    public static void setProcessedSync(Exchange exchange, boolean b) {
        exchange.setProperty(ProducerCache.class.getName() + "".SYNC"", b ? Boolean.TRUE : Boolean.FALSE );
    }
    /**
     * Sends an exchange to an endpoint using a supplied
     * @{link Processor} to populate the exchange
     *
     * @param endpoint the endpoint to send the exchange to
     * @param pattern the message {@link ExchangePattern} such as
     *   {@link ExchangePattern#InOnly} or {@link ExchangePattern#InOut}
     * @param processor the transformer used to populate the new exchange
     */
    public E send(Endpoint<E> endpoint, ExchangePattern pattern, Processor processor) {
         try {
            Producer<E> producer = getProducer(endpoint);
            E exchange = producer.createExchange(pattern);
            return sendExchange(endpoint, producer, processor, exchange);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    protected E sendExchange(Endpoint<E> endpoint, Producer<E> producer, Processor processor, E exchange) throws Exception {
        // lets populate using the processor callback
        processor.process(exchange);
        // now lets dispatch
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> "" + endpoint + "" "" + exchange);
        }
        producer.process(exchange);
        return exchange;
    }
    protected boolean sendExchange(Endpoint<E> endpoint, Producer<E> producer, Processor processor, E exchange, AsyncCallback callback) throws Exception {
        // lets populate using the processor callback
        processor.process(exchange);
        // now lets dispatch
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> "" + endpoint + "" "" + exchange);
        }
        return AsyncProcessorTypeConverter.convert(producer).process(exchange, callback);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(producers.values());
    }
    protected void doStart() throws Exception {
    }
}
"
org.apache.camel.util.ReportingTypeConverterLoader,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.converter.AnnotationTypeConverterLoader;
import org.apache.camel.impl.converter.TypeConverterRegistry;
public class ReportingTypeConverterLoader extends AnnotationTypeConverterLoader {
    private List<TypeMapping> typeMappings = new ArrayList<TypeMapping>();
	private static final Comparator<TypeMapping> COMPARE_LAST_LOADED_FIRST =
        new Comparator<TypeMapping>() {
			public int compare(TypeMapping t1, TypeMapping t2) {
				if (ObjectHelper.equals(t1.fromType, t2.fromType)) {
					return ObjectHelper.equals(t1.toType, t2.toType) ? t1.index - t2.index :
						ObjectHelper.compare(getTypeName(t1.toType), getTypeName(t2.toType));
				}
				return ObjectHelper.compare(getTypeName(t1.fromType), getTypeName(t2.fromType));
			}
		};
    public TypeMapping[] getTypeConversions() {
    	Collections.sort(typeMappings, COMPARE_LAST_LOADED_FIRST);
    	return typeMappings.toArray(new TypeMapping[typeMappings.size()]);
    }
    protected void registerTypeConverter(TypeConverterRegistry registry, Method method, 
    		Class toType, Class fromType, TypeConverter typeConverter) {
        TypeMapping mapping = new TypeMapping(toType, fromType, typeConverter.getClass(), method);
        typeMappings.add(mapping);
    }
	static private String getTypeName(Class type) {
		return type != null ? type.getName() : null;
	}
    /**
     * Represents a mapping from one type (which can be null) to another
     */
    public static class TypeMapping {
    	private static int counter = 0;
        Class toType;
        Class fromType;
        Class converterType;
        Method method;
        int index = 0;
        public TypeMapping(Class toType, Class fromType, Class converterType, Method method) {
            this.toType = toType;
            this.fromType = fromType;
            this.converterType = converterType;
            this.method = method;
            this.index = counter++;
        }
        public Class getFromType() {
            return fromType;
        }
        public Class getToType() {
            return toType;
        }
        public Class getConverterType() {
            return converterType;
        }
        public Method getMethod() {
        	return method;
        }
        public int getIndex() {
        	return index;
        }
        @Override
        public boolean equals(Object object) {
            if (object instanceof TypeMapping) {
                TypeMapping that = (TypeMapping)object;
                return this.index == that.index;
            }
            return false;
        }
        @Override
        public int hashCode() {
            int answer = toType.hashCode();
            if (fromType != null) {
                answer *= 37 + fromType.hashCode();
            }
            return answer;
        }
        @Override
        public String toString() {
            return ""["" + fromType.getSimpleName() + ""=>"" + toType.getSimpleName() + ""]"";
        }
    }    
}
"
org.apache.camel.util.ReportingTypeConverterRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.TypeConverter;
import org.apache.camel.impl.converter.TypeConverterRegistry;
import org.apache.camel.spi.Injector;
public class ReportingTypeConverterRegistry implements TypeConverterRegistry {
    private List<String> errors = new ArrayList<String>();
	public String[] getErrors() {
		return errors.toArray(new String[errors.size()]);
	}
    public void addTypeConverter(Class toType, Class fromType,
			TypeConverter typeConverter) {
    	if (errors.size() == 0) {
    		errors.add(""Method should not be invoked."");
    	}
	}
	public Injector getInjector() {
		return null;
	}
}
"
org.apache.camel.util.ResolverUtil,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.annotation.Annotation;
import java.net.URL;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Set;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;
/**
 * <p>
 * ResolverUtil is used to locate classes that are available in the/a class path
 * and meet arbitrary conditions. The two most common conditions are that a
 * class implements/extends another class, or that is it annotated with a
 * specific annotation. However, through the use of the {@link Test} class it is
 * possible to search using arbitrary conditions.
 * </p>
 * 
 * <p>
 * A ClassLoader is used to locate all locations (directories and jar files) in
 * the class path that contain classes within certain packages, and then to load
 * those classes and check them. By default the ClassLoader returned by
 * {@code Thread.currentThread().getContextClassLoader()} is used, but this can
 * be overridden by calling {@link #setClassLoaders(Set)} prior to
 * invoking any of the {@code find()} methods.
 * </p>
 * 
 * <p>
 * General searches are initiated by calling the
 * {@link #find(ResolverUtil.Test, String)} ()} method and supplying a package
 * name and a Test instance. This will cause the named package <b>and all
 * sub-packages</b> to be scanned for classes that meet the test. There are
 * also utility methods for the common use cases of scanning multiple packages
 * for extensions of particular classes, or classes annotated with a specific
 * annotation.
 * </p>
 * 
 * <p>
 * The standard usage pattern for the ResolverUtil class is as follows:
 * </p>
 * 
 * <pre>
 * esolverUtil&lt;ActionBean&gt; resolver = new ResolverUtil&lt;ActionBean&gt;();
 * esolver.findImplementation(ActionBean.class, pkg1, pkg2);
 * esolver.find(new CustomTest(), pkg1);
 * esolver.find(new CustomTest(), pkg2);
 * ollection&lt;ActionBean&gt; beans = resolver.getClasses();
 * </pre>
 * 
 * @author Tim Fennell
 */
public class ResolverUtil<T> {
    private static final transient Log LOG = LogFactory.getLog(ResolverUtil.class);
    /**
     * A simple interface that specifies how to test classes to determine if
     * they are to be included in the results produced by the ResolverUtil.
     */
    public static interface Test {
        /**
         * Will be called repeatedly with candidate classes. Must return True if
         * a class is to be included in the results, false otherwise.
         */
        boolean matches(Class type);
    }
    /**
     * A Test that checks to see if each class is assignable to the provided
     * class. Note that this test will match the parent type itself if it is
     * presented for matching.
     */
    public static class IsA implements Test {
        private Class parent;
        /**
         * Constructs an IsA test using the supplied Class as the parent
         * class/interface.
         */
        public IsA(Class parentType) {
            this.parent = parentType;
        }
        /**
         * Returns true if type is assignable to the parent type supplied in the
         * constructor.
         */
        public boolean matches(Class type) {
            return type != null && parent.isAssignableFrom(type);
        }
        @Override
        public String toString() {
            return ""is assignable to "" + parent.getSimpleName();
        }
    }
    /**
     * A Test that checks to see if each class is annotated with a specific
     * annotation. If it is, then the test returns true, otherwise false.
     */
    public static class AnnotatedWith implements Test {
        private Class<? extends Annotation> annotation;
        /** Construts an AnnotatedWith test for the specified annotation type. */
        public AnnotatedWith(Class<? extends Annotation> annotation) {
            this.annotation = annotation;
        }
        /**
         * Returns true if the type is annotated with the class provided to the
         * constructor.
         */
        public boolean matches(Class type) {
            return type != null && type.isAnnotationPresent(annotation);
        }
        @Override
        public String toString() {
            return ""annotated with @"" + annotation.getSimpleName();
        }
    }
    /** The set of matches being accumulated. */
    private Set<Class<? extends T>> matches = new HashSet<Class<? extends T>>();
    /**
     * The ClassLoader to use when looking for classes. If null then the
     * ClassLoader returned by Thread.currentThread().getContextClassLoader()
     * will be used.
     */
    private Set<ClassLoader> classLoaders;
    /**
     * Provides access to the classes discovered so far. If no calls have been
     * made to any of the {@code find()} methods, this set will be empty.
     * 
     * @return the set of classes that have been discovered.
     */
    public Set<Class<? extends T>> getClasses() {
        return matches;
    }
    /**
     * Returns the classloaders that will be used for scanning for classes. If no
     * explicit ClassLoader has been set by the calling, the context class
     * loader will be used.
     *
     * @return the ClassLoader instances that will be used to scan for classes
     */
    public Set<ClassLoader> getClassLoaders() {
        if (classLoaders == null) {
            classLoaders = new HashSet<ClassLoader>();
            classLoaders.add(Thread.currentThread().getContextClassLoader());
        }
        return classLoaders;
    }
    /**
     * Sets the ClassLoader instances that should be used when scanning for
     * classes. If none is set then the context classloader will be used.
     *
     * @param classLoaders a ClassLoader to use when scanning for classes
     */
    public void setClassLoaders(Set<ClassLoader> classLoaders) {
        this.classLoaders = classLoaders;
    }
    /**
     * Attempts to discover classes that are assignable to the type provided. In
     * the case that an interface is provided this method will collect
     * implementations. In the case of a non-interface class, subclasses will be
     * collected. Accumulated classes can be accessed by calling
     * {@link #getClasses()}.
     * 
     * @param parent the class of interface to find subclasses or
     *                implementations of
     * @param packageNames one or more package names to scan (including
     *                subpackages) for classes
     */
    public void findImplementations(Class parent, String... packageNames) {
        if (packageNames == null) {
            return;
        }
        LOG.debug(""Searching for implementations of "" + parent.getName() + "" in packages: "" + Arrays.asList(packageNames));
        Test test = new IsA(parent);
        for (String pkg : packageNames) {
            find(test, pkg);
        }
        LOG.debug(""Found: "" + getClasses());
    }
    /**
     * Attempts to discover classes that are annotated with to the annotation.
     * Accumulated classes can be accessed by calling {@link #getClasses()}.
     * 
     * @param annotation the annotation that should be present on matching
     *                classes
     * @param packageNames one or more package names to scan (including
     *                subpackages) for classes
     */
    public void findAnnotated(Class<? extends Annotation> annotation, String... packageNames) {
        if (packageNames == null) {
            return;
        }
        Test test = new AnnotatedWith(annotation);
        for (String pkg : packageNames) {
            find(test, pkg);
        }
    }
    /**
     * Scans for classes starting at the package provided and descending into
     * subpackages. Each class is offered up to the Test as it is discovered,
     * and if the Test returns true the class is retained. Accumulated classes
     * can be fetched by calling {@link #getClasses()}.
     * 
     * @param test an instance of {@link Test} that will be used to filter
     *                classes
     * @param packageName the name of the package from which to start scanning
     *                for classes, e.g. {@code net.sourceforge.stripes}
     */
    public void find(Test test, String packageName) {
        packageName = packageName.replace('.', '/');
        Set<ClassLoader> set = getClassLoaders();
        for (ClassLoader classLoader : set) {
            LOG.trace(""Searching: "" + classLoader);
            find(test, packageName, classLoader);
        }
    }
    protected void find(Test test, String packageName, ClassLoader loader) {
        Enumeration<URL> urls;
        try {
            urls = loader.getResources(packageName);
        } catch (IOException ioe) {
            LOG.warn(""Could not read package: "" + packageName, ioe);
            return;
        }
        while (urls.hasMoreElements()) {
            try {
                URL url = urls.nextElement();
                String urlPath = url.getFile();
                urlPath = URLDecoder.decode(urlPath, ""UTF-8"");
                // If it's a file in a directory, trim the stupid file: spec
                if (urlPath.startsWith(""file:"")) {
                    urlPath = urlPath.substring(5);
                }
                // Else it's in a JAR, grab the path to the jar
                if (urlPath.indexOf('!') > 0) {
                    urlPath = urlPath.substring(0, urlPath.indexOf('!'));
                }
                LOG.debug(""Scanning for classes in ["" + urlPath + ""] matching criteria: "" + test);
                File file = new File(urlPath);
                if (file.isDirectory()) {
                    loadImplementationsInDirectory(test, packageName, file);
                } else {
                    loadImplementationsInJar(test, packageName, file);
                }
            } catch (IOException ioe) {
                LOG.warn(""could not read entries"", ioe);
            }
        }
    }
    /**
     * Finds matches in a physical directory on a filesystem. Examines all files
     * within a directory - if the File object is not a directory, and ends with
     * <i>.class</i> the file is loaded and tested to see if it is acceptable
     * according to the Test. Operates recursively to find classes within a
     * folder structure matching the package structure.
     * 
     * @param test a Test used to filter the classes that are discovered
     * @param parent the package name up to this directory in the package
     *                hierarchy. E.g. if /classes is in the classpath and we
     *                wish to examine files in /classes/org/apache then the
     *                values of <i>parent</i> would be <i>org/apache</i>
     * @param location a File object representing a directory
     */
    private void loadImplementationsInDirectory(Test test, String parent, File location) {
        File[] files = location.listFiles();
        StringBuilder builder = null;
        for (File file : files) {
            builder = new StringBuilder(100);
            String name = file.getName();
            if (name != null) {
                name = name.trim();
            }
            builder.append(parent).append(""/"").append(name);
            String packageOrClass = parent == null ? name : builder.toString();
            if (file.isDirectory()) {
                loadImplementationsInDirectory(test, packageOrClass, file);
            } else if (name.endsWith("".class"")) {
                addIfMatching(test, packageOrClass);
            }
        }
    }
    /**
     * Finds matching classes within a jar files that contains a folder
     * structure matching the package structure. If the File is not a JarFile or
     * does not exist a warning will be logged, but no error will be raised.
     * 
     * @param test a Test used to filter the classes that are discovered
     * @param parent the parent package under which classes must be in order to
     *                be considered
     * @param jarfile the jar file to be examined for classes
     */
    private void loadImplementationsInJar(Test test, String parent, File jarfile) {
        try {
            JarEntry entry;
            JarInputStream jarStream = new JarInputStream(new FileInputStream(jarfile));
            while ((entry = jarStream.getNextJarEntry()) != null) {
                String name = entry.getName();
                if (name != null) {
                    name = name.trim();
                }
                if (!entry.isDirectory() && name.startsWith(parent) && name.endsWith("".class"")) {
                    addIfMatching(test, name);
                }
            }
        } catch (IOException ioe) {
            LOG.error(""Could not search jar file '"" + jarfile + ""' for classes matching criteria: "" + test
                      + ""due to an IOException: "" + ioe.getMessage());
        }
    }
    /**
     * Add the class designated by the fully qualified class name provided to
     * the set of resolved classes if and only if it is approved by the Test
     * supplied.
     * 
     * @param test the test used to determine if the class matches
     * @param fqn the fully qualified name of a class
     */
    protected void addIfMatching(Test test, String fqn) {
        try {
            String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');
            Set<ClassLoader> set = getClassLoaders();
            boolean found = false;
            for (ClassLoader classLoader : set) {
                LOG.trace(""Checking to see if class "" + externalName + "" matches criteria ["" + test + ""]"");
                try {
                    Class type = classLoader.loadClass(externalName);
                    if (test.matches(type)) {
                        matches.add((Class<T>)type);
                    }
                    found = true;
                    break;
                }
                catch (ClassNotFoundException e) {
                    LOG.debug(""Could not find class '"" + fqn + ""' in class loader: "" + classLoader + "". Reason: "" + e, e);
                }
            }
            if (!found) {
                LOG.warn(""Could not find class '"" + fqn + ""' in any class loaders: "" + set);
            }
        } catch (Throwable t) {
            LOG.warn(""Could not examine class '"" + fqn + ""' due to a "" + t.getClass().getName()
                     + "" with message: "" + t.getMessage());
        }
    }
}
"
org.apache.camel.util.ServiceHelper,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Collection;
import org.apache.camel.Service;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A collection of helper methods for working with {@link Service} objects
 * 
 * @version $Revision: 563607 $
 */
public class ServiceHelper {
    private static final transient Log LOG = LogFactory.getLog(ServiceHelper.class);
    /**
     * Utility classes should not have a public constructor.
     */
    private ServiceHelper() {        
    }
    public static void startService(Object value) throws Exception {
        if (value instanceof Service) {
            Service service = (Service)value;
            service.start();
        } else if (value instanceof Collection) {
            startServices((Collection)value);
        }
    }
    /**
     * Starts all of the given services
     */
    public static void startServices(Object... services) throws Exception {
        for (Object value : services) {
            startService(value);
        }
    }
    /**
     * Starts all of the given services
     */
    public static void startServices(Collection services) throws Exception {
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service)value;
                service.start();
            }
        }
    }
    /**
     * Stops all of the given services, throwing the first exception caught
     */
    public static void stopServices(Object... services) throws Exception {
        Exception firstException = null;
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service)value;
                try {
                    service.stop();
                } catch (Exception e) {
                    LOG.debug(""Caught exception shutting down: "" + e, e);
                    if (firstException == null) {
                        firstException = e;
                    }
                }
            }
        }
        if (firstException != null) {
            throw firstException;
        }
    }
    public static void stopService(Object value) throws Exception {
        if (value instanceof Service) {
            Service service = (Service)value;
            service.stop();
        } else if (value instanceof Collection) {
            stopServices((Collection)value);
        }
    }
    /**
     * Stops all of the given services, throwing the first exception caught
     */
    public static void stopServices(Collection services) throws Exception {
        Exception firstException = null;
        for (Object value : services) {
            if (value instanceof Service) {
                Service service = (Service)value;
                try {
                    service.stop();
                } catch (Exception e) {
                    LOG.debug(""Caught exception shutting down: "" + e, e);
                    if (firstException == null) {
                        firstException = e;
                    }
                }
            }
        }
        if (firstException != null) {
            throw firstException;
        }
    }
}
"
org.apache.camel.util.Time,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.util.Date;
import java.util.concurrent.TimeUnit;
/**
 * A helper class for working with times in various units
 * 
 * @version $Revision: $
 */
public class Time {
    private long number;
    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;
    public Time(long number, TimeUnit timeUnit) {
        this.number = number;
        this.timeUnit = timeUnit;
    }
    public static Time millis(long value) {
        return new Time(value, TimeUnit.MILLISECONDS);
    }
    public static Time micros(long value) {
        return new Time(value, TimeUnit.MICROSECONDS);
    }
    public static Time nanos(long value) {
        return new Time(value, TimeUnit.NANOSECONDS);
    }
    public static Time seconds(long value) {
        return new Time(value, TimeUnit.SECONDS);
    }
    public static Time minutes(long value) {
        return new Time(minutesAsSeconds(value), TimeUnit.MILLISECONDS);
    }
    public static Time hours(long value) {
        return new Time(hoursAsSeconds(value), TimeUnit.MILLISECONDS);
    }
    public static Time days(long value) {
        return new Time(daysAsSeconds(value), TimeUnit.MILLISECONDS);
    }
    public long toMillis() {
        return timeUnit.toMillis(number);
    }
    public Date toDate() {
        return new Date(toMillis());
    }
    public long getNumber() {
        return number;
    }
    public TimeUnit getTimeUnit() {
        return timeUnit;
    }
    protected static long minutesAsSeconds(long value) {
        return value * 60;
    }
    protected static long hoursAsSeconds(long value) {
        return minutesAsSeconds(value) * 60;
    }
    protected static long daysAsSeconds(long value) {
        return hoursAsSeconds(value) * 24;
    }
}
"
org.apache.camel.util.UnsafeCharactersEncoderTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import junit.framework.TestCase;
public class UnsafeCharactersEncoderTest extends TestCase {
     public void testQnameEncoder() {
         String afterEncoding = ""%7Bhttp://www.example.com/test%7DServiceName"";
         String beforeEncoding = ""{http://www.example.com/test}ServiceName"";
         String result = UnsafeUriCharactersEncoder.encode(beforeEncoding);         
         assertEquals(""Get the wrong encoding result"", result, afterEncoding);
     }
     public void testNoEncoding() {
         String noEncoding= ""http://www.example.com"";
         String result = UnsafeUriCharactersEncoder.encode(noEncoding);         
         assertEquals(""Get the wrong encoding result"", result, noEncoding);
     }
}
"
org.apache.camel.util.UnsafeUriCharactersEncoder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.util.BitSet;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
public class UnsafeUriCharactersEncoder {
    private static final transient Log LOG = LogFactory.getLog(UnsafeUriCharactersEncoder.class);
    static BitSet unsafeCharacters;
    static {
        unsafeCharacters = new BitSet(256);
        unsafeCharacters.set(' ');
        unsafeCharacters.set('""');
        unsafeCharacters.set('<');
        unsafeCharacters.set('>');
        unsafeCharacters.set('#');
        unsafeCharacters.set('%');
        unsafeCharacters.set('{');
        unsafeCharacters.set('}');
        unsafeCharacters.set('|');
        unsafeCharacters.set('\\');
        unsafeCharacters.set('^');
        unsafeCharacters.set('~'); 
        unsafeCharacters.set('[');
        unsafeCharacters.set(']');
        unsafeCharacters.set('`');        
    }
    private UnsafeUriCharactersEncoder() {
        // util class 
    }
    public static String encode(String s) {
        int n = s.length();
        if (n == 0)
            return s;
        // First check whether we actually need to encode
        try {
            byte[] bytes = s.getBytes(""UTF8"");        
            for (int i = 0;;) {
                if (unsafeCharacters.get(bytes[i]))
                    break;
                if (++i >= bytes.length)
                    return s;
            }
            StringBuffer sb = new StringBuffer();
            for (byte b : bytes) {            
                if (unsafeCharacters.get(b)) {
                    appendEscape(sb, (byte)b);
                }    
                else
                    sb.append((char)b);
            }
            return sb.toString();
        } catch (UnsupportedEncodingException e) {
            LOG.error(""Can't encoding the uri: "", e);            
            return null;
        }    
    }
    private static void appendEscape(StringBuffer sb, byte b) {
        sb.append('%');
        sb.append(hexDigits[(b >> 4) & 0x0f]);
        sb.append(hexDigits[(b >> 0) & 0x0f]);
    }
    private final static char[] hexDigits = {
                                        '0', '1', '2', '3', '4', '5', '6', '7',
                                        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
                                         };
}
"
org.apache.camel.util.URISupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
/**
 * @version $Revision$
 */
public class URISupport {
    public static class CompositeData {
        public String host;
        String scheme;
        String path;
        URI components[];
        Map parameters;
        String fragment;
        public URI[] getComponents() {
            return components;
        }
        public String getFragment() {
            return fragment;
        }
        public Map getParameters() {
            return parameters;
        }
        public String getScheme() {
            return scheme;
        }
        public String getPath() {
            return path;
        }
        public String getHost() {
            return host;
        }
        public URI toURI() throws URISyntaxException {
            StringBuffer sb = new StringBuffer();
            if (scheme != null) {
                sb.append(scheme);
                sb.append(':');
            }
            if (host != null && host.length() != 0) {
                sb.append(host);
            } else {
                sb.append('(');
                for (int i = 0; i < components.length; i++) {
                    if (i != 0) {
                        sb.append(',');
                    }
                    sb.append(components[i].toString());
                }
                sb.append(')');
            }
            if (path != null) {
                sb.append('/');
                sb.append(path);
            }
            if (!parameters.isEmpty()) {
                sb.append(""?"");
                sb.append(createQueryString(parameters));
            }
            if (fragment != null) {
                sb.append(""#"");
                sb.append(fragment);
            }
            return new URI(sb.toString());
        }
    }
    public static Map parseQuery(String uri) throws URISyntaxException {
        try {
            Map rc = new HashMap();
            if (uri != null) {
                String[] parameters = uri.split(""&"");
                for (int i = 0; i < parameters.length; i++) {
                    int p = parameters[i].indexOf(""="");
                    if (p >= 0) {
                        String name = URLDecoder.decode(parameters[i].substring(0, p), ""UTF-8"");
                        String value = URLDecoder.decode(parameters[i].substring(p + 1), ""UTF-8"");
                        rc.put(name, value);
                    } else {
                        rc.put(parameters[i], null);
                    }
                }
            }
            return rc;
        } catch (UnsupportedEncodingException e) {
            throw (URISyntaxException)new URISyntaxException(e.toString(), ""Invalid encoding"").initCause(e);
        }
    }
    public static Map parseParamters(URI uri) throws URISyntaxException {
        String query = uri.getQuery();
        if (query == null) {
            String schemeSpecificPart = uri.getSchemeSpecificPart();
            int idx = schemeSpecificPart.lastIndexOf('?');
            if (idx < 0) {
                return Collections.EMPTY_MAP;
            } else {
                query = schemeSpecificPart.substring(idx + 1);
            }
        } else {
            query = stripPrefix(query, ""?"");
        }
        return parseQuery(query);
    }
    /**
     * Removes any URI query from the given uri
     */
    public static URI removeQuery(URI uri) throws URISyntaxException {
        return createURIWithQuery(uri, null);
    }
    /**
     * Creates a URI with the given query
     */
    public static URI createURIWithQuery(URI uri, String query) throws URISyntaxException {
        return new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(), uri.getPath(),
                       query, uri.getFragment());
    }
    public static CompositeData parseComposite(URI uri) throws URISyntaxException {
        CompositeData rc = new CompositeData();
        rc.scheme = uri.getScheme();
        String ssp = stripPrefix(uri.getSchemeSpecificPart().trim(), ""//"").trim();
        parseComposite(uri, rc, ssp);
        rc.fragment = uri.getFragment();
        return rc;
    }
    /**
     * @param uri
     * @param rc
     * @param ssp
     * @throws URISyntaxException
     */
    private static void parseComposite(URI uri, CompositeData rc, String ssp) throws URISyntaxException {
        String componentString;
        String params;
        if (!checkParenthesis(ssp)) {
            throw new URISyntaxException(uri.toString(), ""Not a matching number of '(' and ')' parenthesis"");
        }
        int p;
        int intialParen = ssp.indexOf(""("");
        if (intialParen == 0) {
            rc.host = ssp.substring(0, intialParen);
            p = rc.host.indexOf(""/"");
            if (p >= 0) {
                rc.path = rc.host.substring(p);
                rc.host = rc.host.substring(0, p);
            }
            p = ssp.lastIndexOf("")"");
            componentString = ssp.substring(intialParen + 1, p);
            params = ssp.substring(p + 1).trim();
        } else {
            componentString = ssp;
            params = """";
        }
        String components[] = splitComponents(componentString);
        rc.components = new URI[components.length];
        for (int i = 0; i < components.length; i++) {
            rc.components[i] = new URI(components[i].trim());
        }
        p = params.indexOf(""?"");
        if (p >= 0) {
            if (p > 0) {
                rc.path = stripPrefix(params.substring(0, p), ""/"");
            }
            rc.parameters = parseQuery(params.substring(p + 1));
        } else {
            if (params.length() > 0) {
                rc.path = stripPrefix(params, ""/"");
            }
            rc.parameters = Collections.EMPTY_MAP;
        }
    }
    /**
     * @param str
     * @return
     */
    private static String[] splitComponents(String str) {
        ArrayList l = new ArrayList();
        int last = 0;
        int depth = 0;
        char chars[] = str.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            switch (chars[i]) {
            case '(':
                depth++;
                break;
            case ')':
                depth--;
                break;
            case ',':
                if (depth == 0) {
                    String s = str.substring(last, i);
                    l.add(s);
                    last = i + 1;
                }
                break;
            default:
            }
        }
        String s = str.substring(last);
        if (s.length() != 0) {
            l.add(s);
        }
        String rc[] = new String[l.size()];
        l.toArray(rc);
        return rc;
    }
    public static String stripPrefix(String value, String prefix) {
        if (value.startsWith(prefix)) {
            return value.substring(prefix.length());
        }
        return value;
    }
    public static URI stripScheme(URI uri) throws URISyntaxException {
        return new URI(stripPrefix(uri.getSchemeSpecificPart().trim(), ""//""));
    }
    public static String createQueryString(Map options) throws URISyntaxException {
        try {
            if (options.size() > 0) {
                StringBuffer rc = new StringBuffer();
                boolean first = true;
                for (Iterator iter = options.keySet().iterator(); iter.hasNext();) {
                    if (first) {
                        first = false;
                    } else {
                        rc.append(""&"");
                    }
                    String key = (String)iter.next();
                    String value = (String)options.get(key);
                    rc.append(URLEncoder.encode(key, ""UTF-8""));
                    rc.append(""="");
                    rc.append(URLEncoder.encode(value, ""UTF-8""));
                }
                return rc.toString();
            } else {
                return """";
            }
        } catch (UnsupportedEncodingException e) {
            throw (URISyntaxException)new URISyntaxException(e.toString(), ""Invalid encoding"").initCause(e);
        }
    }
    /**
     * Creates a URI from the original URI and the remaining paramaters
     * 
     * @throws URISyntaxException
     */
    public static URI createRemainingURI(URI originalURI, Map params) throws URISyntaxException {
        String s = createQueryString(params);
        if (s.length() == 0) {
            s = null;
        }
        return createURIWithQuery(originalURI, s);
    }
    public static URI changeScheme(URI bindAddr, String scheme) throws URISyntaxException {
        return new URI(scheme, bindAddr.getUserInfo(), bindAddr.getHost(), bindAddr.getPort(), bindAddr
            .getPath(), bindAddr.getQuery(), bindAddr.getFragment());
    }
    public static boolean checkParenthesis(String str) {
        boolean result = true;
        if (str != null) {
            int open = 0;
            int closed = 0;
            int i = 0;
            while ((i = str.indexOf('(', i)) >= 0) {
                i++;
                open++;
            }
            i = 0;
            while ((i = str.indexOf(')', i)) >= 0) {
                i++;
                closed++;
            }
            result = open == closed;
        }
        return result;
    }
    public int indexOfParenthesisMatch(String str) {
        int result = -1;
        return result;
    }
}
"
org.apache.camel.util.UuidGenerator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.util.logging.Level;
import java.util.logging.Logger;
/**
 * Generator for Globally unique Strings.
 */
public class UuidGenerator {
    private static final Logger LOG = Logger.getLogger(UuidGenerator.class.getName());
    private static final String UNIQUE_STUB;
    private static int instanceCount;
    private static String hostName;
    private String seed;
    private long sequence;
    static {
        String stub = """";
        boolean canAccessSystemProps = true;
        try {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPropertiesAccess();
            }
        } catch (SecurityException se) {
            canAccessSystemProps = false;
        }
        if (canAccessSystemProps) {
            try {
                hostName = InetAddress.getLocalHost().getHostName();
                ServerSocket ss = new ServerSocket(0);
                stub = ""/"" + ss.getLocalPort() + ""-"" + System.currentTimeMillis() + ""/"";
                Thread.sleep(100);
                ss.close();
            } catch (Exception ioe) {
                LOG.log(Level.WARNING, ""could not generate unique stub"", ioe);
            }
        } else {
            hostName = ""localhost"";
            stub = ""-1-"" + System.currentTimeMillis() + ""-"";
        }
        UNIQUE_STUB = stub;
    }
    /**
     * Construct an IdGenerator
     * 
     */
    public UuidGenerator(String prefix) {
        synchronized (UNIQUE_STUB) {
            this.seed = prefix + UNIQUE_STUB + (instanceCount++) + ""-"";
        }
    }
    public UuidGenerator() {
        this(""ID-"" + hostName);
    }
    /**
     * As we have to find the hostname as a side-affect of generating a unique
     * stub, we allow it's easy retrevial here
     * 
     * @return the local host name
     */
    public static String getHostName() {
        return hostName;
    }
    /**
     * Generate a unqiue id
     * 
     * @return a unique id
     */
    public synchronized String generateId() {
        return this.seed + (this.sequence++);
    }
    /**
     * Generate a unique ID - that is friendly for a URL or file system
     * 
     * @return a unique id
     */
    public String generateSanitizedId() {
        String result = generateId();
        result = result.replace(':', '-');
        result = result.replace('_', '-');
        result = result.replace('.', '-');
        return result;
    }
}
"
org.apache.camel.util.jndi.CamelInitialContextFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
import java.util.Hashtable;
import javax.naming.Context;
import javax.naming.NamingException;
import javax.naming.spi.InitialContextFactory;
/**
 * A factory of the Cameel InitialContext which allows a Map to be used to create a
 * JNDI context.
 *
 * @version $Revision: 1.2 $
 */
public class CamelInitialContextFactory implements InitialContextFactory {
    public Context getInitialContext(Hashtable environment) throws NamingException {
        try {
            return new JndiContext(environment);
        }
        catch (NamingException e) {
            throw e;
        }
        catch (Exception e) {
            NamingException exception = new NamingException(e.getMessage());
            exception.initCause(e);
            throw exception;
        }
    }
}
"
org.apache.camel.util.jndi.ExampleBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
/**
 * @version $Revision: 1.1 $
 */
public class ExampleBean {
    private String name;
    private double price;
    public String toString() {
        return ""ExampleBean[name: "" + name + "" price: "" + price + ""]"";
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public double getPrice() {
        return price;
    }
    public void setPrice(double price) {
        this.price = price;
    }
}
"
org.apache.camel.util.jndi.JndiContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import javax.naming.Binding;
import javax.naming.CompositeName;
import javax.naming.Context;
import javax.naming.LinkRef;
import javax.naming.Name;
import javax.naming.NameClassPair;
import javax.naming.NameNotFoundException;
import javax.naming.NameParser;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.NotContextException;
import javax.naming.OperationNotSupportedException;
import javax.naming.Reference;
import javax.naming.spi.NamingManager;
import org.apache.camel.impl.ReflectionInjector;
import org.apache.camel.spi.Injector;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.ObjectHelper;
/**
 * A default JNDI context
 * 
 * @version $Revision: 1.2 $ $Date: 2005/08/27 03:52:39 $
 */
public class JndiContext implements Context, Serializable {
    public static final String SEPARATOR = ""/"";
    protected static final NameParser NAME_PARSER = new NameParser() {
        public Name parse(String name) throws NamingException {
            return new CompositeName(name);
        }
    };
    protected static final Injector INJETOR = new ReflectionInjector();
    private static final long serialVersionUID = -5754338187296859149L;
    private final Hashtable environment; // environment for this context
    private final Map bindings; // bindings at my level
    private final Map treeBindings; // all bindings under me
    private boolean frozen;
    private String nameInNamespace = """";
    public JndiContext() throws Exception {
        this(new Hashtable());
    }
    public JndiContext(Hashtable env) throws Exception {
        this(env, createBindingsMapFromEnvironment(env));
    }
    public JndiContext(Hashtable environment, Map bindings) {
        if (environment == null) {
            this.environment = new Hashtable();
        } else {
            this.environment = new Hashtable(environment);
        }
        this.bindings = bindings;
        treeBindings = new HashMap();
    }
    public JndiContext(Hashtable environment, Map bindings, String nameInNamespace) {
        this(environment, bindings);
        this.nameInNamespace = nameInNamespace;
    }
    protected JndiContext(JndiContext clone, Hashtable env) {
        this.bindings = clone.bindings;
        this.treeBindings = clone.treeBindings;
        this.environment = new Hashtable(env);
    }
    protected JndiContext(JndiContext clone, Hashtable env, String nameInNamespace) {
        this(clone, env);
        this.nameInNamespace = nameInNamespace;
    }
    /**
     * A helper method to create the JNDI bindings from the input environment
     * properties using $foo.class to point to a class name with $foo.* being
     * properties set on the injected bean
     */
    public static Map createBindingsMapFromEnvironment(Hashtable env) throws Exception {
        Map answer = new HashMap(env);
        for (Object object : env.entrySet()) {
            Map.Entry entry = (Map.Entry)object;
            Object key = entry.getKey();
            Object value = entry.getValue();
            if (key instanceof String && value instanceof String) {
                String keyText = (String)key;
                String valueText = (String)value;
                if (keyText.endsWith("".class"")) {
                    Class<?> type = ObjectHelper.loadClass(valueText);
                    if (type != null) {
                        String newEntry = keyText.substring(0, keyText.length() - "".class"".length());
                        Object bean = createBean(type, answer, newEntry + ""."");
                        if (bean != null) {
                            answer.put(newEntry, bean);
                        }
                    }
                }
            }
        }
        return answer;
    }
    public void freeze() {
        frozen = true;
    }
    boolean isFrozen() {
        return frozen;
    }
    /**
     * internalBind is intended for use only during setup or possibly by
     * suitably synchronized superclasses. It binds every possible lookup into a
     * map in each context. To do this, each context strips off one name segment
     * and if necessary creates a new context for it. Then it asks that context
     * to bind the remaining name. It returns a map containing all the bindings
     * from the next context, plus the context it just created (if it in fact
     * created it). (the names are suitably extended by the segment originally
     * lopped off).
     * 
     * @param name
     * @param value
     * @return
     * @throws javax.naming.NamingException
     */
    protected Map internalBind(String name, Object value) throws NamingException {
        assert name != null && name.length() > 0;
        assert !frozen;
        Map newBindings = new HashMap();
        int pos = name.indexOf('/');
        if (pos == -1) {
            if (treeBindings.put(name, value) != null) {
                throw new NamingException(""Something already bound at "" + name);
            }
            bindings.put(name, value);
            newBindings.put(name, value);
        } else {
            String segment = name.substring(0, pos);
            assert segment != null;
            assert !segment.equals("""");
            Object o = treeBindings.get(segment);
            if (o == null) {
                o = newContext();
                treeBindings.put(segment, o);
                bindings.put(segment, o);
                newBindings.put(segment, o);
            } else if (!(o instanceof JndiContext)) {
                throw new NamingException(""Something already bound where a subcontext should go"");
            }
            JndiContext defaultContext = (JndiContext)o;
            String remainder = name.substring(pos + 1);
            Map subBindings = defaultContext.internalBind(remainder, value);
            for (Iterator iterator = subBindings.entrySet().iterator(); iterator.hasNext();) {
                Map.Entry entry = (Map.Entry)iterator.next();
                String subName = segment + ""/"" + (String)entry.getKey();
                Object bound = entry.getValue();
                treeBindings.put(subName, bound);
                newBindings.put(subName, bound);
            }
        }
        return newBindings;
    }
    protected JndiContext newContext() {
        try {
            return new JndiContext();
        }
        catch (Exception e) {
            throw new IllegalArgumentException(e);
        }
    }
    public Object addToEnvironment(String propName, Object propVal) throws NamingException {
        return environment.put(propName, propVal);
    }
    public Hashtable getEnvironment() throws NamingException {
        return (Hashtable)environment.clone();
    }
    public Object removeFromEnvironment(String propName) throws NamingException {
        return environment.remove(propName);
    }
    public Object lookup(String name) throws NamingException {
        if (name.length() == 0) {
            return this;
        }
        Object result = treeBindings.get(name);
        if (result == null) {
            result = bindings.get(name);
        }
        if (result == null) {
            int pos = name.indexOf(':');
            if (pos > 0) {
                String scheme = name.substring(0, pos);
                Context ctx = NamingManager.getURLContext(scheme, environment);
                if (ctx == null) {
                    throw new NamingException(""scheme "" + scheme + "" not recognized"");
                }
                return ctx.lookup(name);
            } else {
                // Split out the first name of the path
                // and look for it in the bindings map.
                CompositeName path = new CompositeName(name);
                if (path.size() == 0) {
                    return this;
                } else {
                    String first = path.get(0);
                    Object value = bindings.get(first);
                    if (value == null) {
                        throw new NameNotFoundException(name);
                    } else if (value instanceof Context && path.size() > 1) {
                        Context subContext = (Context)value;
                        value = subContext.lookup(path.getSuffix(1));
                    }
                    return value;
                }
            }
        }
        if (result instanceof LinkRef) {
            LinkRef ref = (LinkRef)result;
            result = lookup(ref.getLinkName());
        }
        if (result instanceof Reference) {
            try {
                result = NamingManager.getObjectInstance(result, null, null, this.environment);
            } catch (NamingException e) {
                throw e;
            } catch (Exception e) {
                throw (NamingException)new NamingException(""could not look up : "" + name).initCause(e);
            }
        }
        if (result instanceof JndiContext) {
            String prefix = getNameInNamespace();
            if (prefix.length() > 0) {
                prefix = prefix + SEPARATOR;
            }
            result = new JndiContext((JndiContext)result, environment, prefix + name);
        }
        return result;
    }
    public Object lookup(Name name) throws NamingException {
        return lookup(name.toString());
    }
    public Object lookupLink(String name) throws NamingException {
        return lookup(name);
    }
    public Name composeName(Name name, Name prefix) throws NamingException {
        Name result = (Name)prefix.clone();
        result.addAll(name);
        return result;
    }
    public String composeName(String name, String prefix) throws NamingException {
        CompositeName result = new CompositeName(prefix);
        result.addAll(new CompositeName(name));
        return result.toString();
    }
    public NamingEnumeration list(String name) throws NamingException {
        Object o = lookup(name);
        if (o == this) {
            return new ListEnumeration();
        } else if (o instanceof Context) {
            return ((Context)o).list("""");
        } else {
            throw new NotContextException();
        }
    }
    public NamingEnumeration listBindings(String name) throws NamingException {
        Object o = lookup(name);
        if (o == this) {
            return new ListBindingEnumeration();
        } else if (o instanceof Context) {
            return ((Context)o).listBindings("""");
        } else {
            throw new NotContextException();
        }
    }
    public Object lookupLink(Name name) throws NamingException {
        return lookupLink(name.toString());
    }
    public NamingEnumeration list(Name name) throws NamingException {
        return list(name.toString());
    }
    public NamingEnumeration listBindings(Name name) throws NamingException {
        return listBindings(name.toString());
    }
    public void bind(Name name, Object value) throws NamingException {
        bind(name.toString(), value);
    }
    public void bind(String name, Object value) throws NamingException {
        if (isFrozen()) {
            throw new OperationNotSupportedException();
        } else {
            internalBind(name, value);
        }
    }
    public void close() throws NamingException {
        // ignore
    }
    public Context createSubcontext(Name name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public Context createSubcontext(String name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void destroySubcontext(Name name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void destroySubcontext(String name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public String getNameInNamespace() throws NamingException {
        return nameInNamespace;
    }
    public NameParser getNameParser(Name name) throws NamingException {
        return NAME_PARSER;
    }
    public NameParser getNameParser(String name) throws NamingException {
        return NAME_PARSER;
    }
    public void rebind(Name name, Object value) throws NamingException {
        bind(name, value);
    }
    public void rebind(String name, Object value) throws NamingException {
        bind(name, value);
    }
    public void rename(Name oldName, Name newName) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void rename(String oldName, String newName) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void unbind(Name name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    public void unbind(String name) throws NamingException {
        throw new OperationNotSupportedException();
    }
    private abstract class LocalNamingEnumeration implements NamingEnumeration {
        private Iterator i = bindings.entrySet().iterator();
        public boolean hasMore() throws NamingException {
            return i.hasNext();
        }
        public boolean hasMoreElements() {
            return i.hasNext();
        }
        protected Map.Entry getNext() {
            return (Map.Entry)i.next();
        }
        public void close() throws NamingException {
        }
    }
    private class ListEnumeration extends LocalNamingEnumeration {
        ListEnumeration() {
        }
        public Object next() throws NamingException {
            return nextElement();
        }
        public Object nextElement() {
            Map.Entry entry = getNext();
            return new NameClassPair((String)entry.getKey(), entry.getValue().getClass().getName());
        }
    }
    private class ListBindingEnumeration extends LocalNamingEnumeration {
        ListBindingEnumeration() {
        }
        public Object next() throws NamingException {
            return nextElement();
        }
        public Object nextElement() {
            Map.Entry entry = getNext();
            return new Binding((String)entry.getKey(), entry.getValue());
        }
    }
    protected static Object createBean(Class<?> type, Map properties, String prefix) throws Exception {
        Object value = INJETOR.newInstance(type);
        IntrospectionSupport.setProperties(value, properties, prefix);
        return value;
    }
}
"
org.apache.camel.util.jndi.JndiTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.util.jndi;
import java.io.InputStream;
import java.util.Hashtable;
import java.util.Properties;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import org.apache.camel.TestSupport;
/**
 * @version $Revision: 1.1 $
 */
public class JndiTest extends TestSupport {
    protected Context context;
    public static Context createInitialContext() throws Exception {
        InputStream in = JndiTest.class.getClassLoader().getResourceAsStream(""jndi-example.properties"");
        assertNotNull(""Cannot find jndi-example.properties on the classpath!"", in);
        Properties properties = new Properties();
        properties.load(in);
        return new InitialContext(new Hashtable(properties));
    }
    public void testLookupOfSimpleName() throws Exception {
        Object value = assertLookup(""foo"");
        assertEquals(""foo"", ""bar"", value);
    }
    public void testLookupOfTypedObject() throws Exception {
        Object value = assertLookup(""example"");
        ExampleBean bean = assertIsInstanceOf(ExampleBean.class, value);
        assertEquals(""Bean.name"", ""James"", bean.getName());
        assertEquals(""Bean.price"", 2.34, bean.getPrice());
        log.info(""Found bean: "" + bean);
    }
    protected Object assertLookup(String name) throws NamingException {
        Object value = context.lookup(name);
        assertNotNull(""Should have found JNDI entry: "" + name + "" in context: "" + context, value);
        return value;
    }
    protected void setUp() throws Exception {
        super.setUp();
        context = createInitialContext();
    }
}
"
org.apache.camel.view.DotViewTest,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.io.File;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.builder.xml.XPathBuilder;
import static org.apache.camel.builder.xml.XPathBuilder.xpath;
/**
 * @version $Revision: 1.1 $
 */
public class DotViewTest extends ContextTestSupport {
    protected String outputDirectory = ""target/site/cameldoc"";
    public void testGenerateFiles() throws Exception {
        RouteDotGenerator generator = new RouteDotGenerator(outputDirectory);
        generator.drawRoutes(context);
    }
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        context.addRoutes(new MulticastRoute());
        context.addRoutes(new PipelineRoute());
        context.addRoutes(new ChoiceRoute());
        context.addRoutes(new FilterRoute());
        context.addRoutes(new ComplexRoute());
    }
    static class MulticastRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""seda:multicast.in"").
                    multicast().to(""seda:multicast.out1"", ""seda:multicast.out2"", ""seda:multicast.out3"");
        }
    }
    static class PipelineRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""seda:pipeline.in"").
                    to(""seda:pipeline.out1"", ""seda:pipeline.out2"", ""seda:pipeline.out3"");
        }
    }
    static class ChoiceRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""file:foo/xyz?noop=true"").
                choice().
                  when(xpath(""/person/city = 'London'"")).to(""file:target/messages/uk"").
                  otherwise().to(""file:target/messages/others"");
        }
    }
    static class FilterRoute extends RouteBuilder {
        public void configure() throws Exception {
                from(""file:foo/bar?noop=true"").
                        filter(header(""foo"").isEqualTo(""bar"")).
                        to(""file:xyz?noop=true"");
        }
    }
    static class ComplexRoute extends RouteBuilder {
        public void configure() throws Exception {
            from(""file:xyz?noop=true"").
                    filter(header(""foo"").isEqualTo(""bar"")).
                    recipientList(header(""bar"")).
                    splitter(XPathBuilder.xpath(""/invoice/lineItems"")).
                    throttler(3).
                    to(""mock:result"");
        }
    }
}
"
org.apache.camel.view.GraphGeneratorSupport,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.io.IOException;
import java.io.File;
import java.io.PrintWriter;
import java.io.FileWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.HashMap;
import java.util.ArrayList;
import org.apache.camel.CamelContext;
import org.apache.camel.util.CollectionStringBuffer;
import org.apache.camel.model.RouteType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.MulticastType;
import org.apache.camel.model.ChoiceType;
import org.apache.camel.model.FromType;
import org.apache.camel.model.ToType;
import org.apache.camel.model.language.ExpressionType;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * @version $Revision: 1.1 $
 */
public abstract class GraphGeneratorSupport {
    private static final transient Log LOG = LogFactory.getLog(RouteDotGenerator.class);
    protected String dir;
    private String imagePrefix = ""http://www.enterpriseintegrationpatterns.com/img/"";
    private Map<Object, NodeData> nodeMap = new HashMap<Object, NodeData>();
    private boolean makeParentDirs = true;
    protected int clusterCounter;
    private Map<String, List<RouteType>> routeGroupMap;
    protected String extension;
    protected GraphGeneratorSupport(String dir, String extension) {
        this.dir = dir;
        this.extension = extension;
    }
    public String getDir() {
        return dir;
    }
    /**
     * Sets the destination directory in which to create the diagrams
     */
    public void setDir(String dir) {
        this.dir = dir;
    }
    public void drawRoutes(CamelContext context) throws IOException {
        File parent = new File(dir);
        if (makeParentDirs) {
            parent.mkdirs();
        }
        List<RouteType> routes = context.getRouteDefinitions();
        routeGroupMap = createRouteGroupMap(routes);
        // generate the global file
        generateFile(parent, ""routes"" + extension, routeGroupMap);
        if (routeGroupMap.size() >= 1) {
            Set<Map.Entry<String, List<RouteType>>> entries = routeGroupMap.entrySet();
            for (Map.Entry<String, List<RouteType>> entry : entries) {
                Map<String, List<RouteType>> map = new HashMap<String, List<RouteType>>();
                String group = entry.getKey();
                map.put(group, entry.getValue());
                // generate the file containing just the routes in this group
                generateFile(parent, group + extension, map);
            }
        }
    }
    private void generateFile(File parent, String fileName, Map<String, List<RouteType>> map) throws IOException {
        nodeMap.clear();
        clusterCounter = 0;
        PrintWriter writer = new PrintWriter(new FileWriter(new File(parent, fileName)));
        try {
            generateFile(writer, map);
        }
        finally {
            writer.close();
        }
    }
    protected abstract void generateFile(PrintWriter writer, Map<String, List<RouteType>> map);
    protected boolean isMulticastNode(ProcessorType node) {
        return node instanceof MulticastType || node instanceof ChoiceType;
    }
    protected String getLabel(List<ExpressionType> expressions) {
        CollectionStringBuffer buffer = new CollectionStringBuffer();
        for (ExpressionType expression : expressions) {
            buffer.append(getLabel(expression));
        }
        return buffer.toString();
    }
    protected String getLabel(ExpressionType expression) {
        if (expression != null) {
            return expression.getLabel();
        }
        return """";
    }
    protected NodeData getNodeData(Object node) {
        Object key = node;
        if (node instanceof FromType) {
            FromType fromType = (FromType) node;
            key = fromType.getUriOrRef();
        }
        else if (node instanceof ToType) {
            ToType toType = (ToType) node;
            key = toType.getUriOrRef();
        }
        NodeData answer = nodeMap.get(key);
        if (answer == null) {
            String id = ""node"" + (nodeMap.size() + 1);
            answer = new NodeData(id, node, imagePrefix);
            nodeMap.put(key, answer);
        }
        return answer;
    }
    protected Map<String, List<RouteType>> createRouteGroupMap(List<RouteType> routes) {
        Map<String, List<RouteType>> map = new HashMap<String, List<RouteType>>();
        for (RouteType route : routes) {
            String group = route.getGroup();
            if (group == null) {
                group = ""Camel Routes"";
            }
            List<RouteType> list = map.get(group);
            if (list == null) {
                list = new ArrayList<RouteType>();
                map.put(group, list);
            }
            list.add(route);
        }
        return map;
    }
}
"
org.apache.camel.view.NodeData,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.model.*;
import static org.apache.camel.util.ObjectHelper.isNotNullAndNonEmpty;
import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
/**
 * Represents a node in the EIP diagram tree
 *
 * @version $Revision: 1.1 $
 */
public class NodeData {
    public String id;
    private final String imagePrefix;
    public String image;
    public String label;
    public String shape;
    public String edgeLabel;
    public String tooltop;
    public String nodeType;
    public boolean nodeWritten;
    public String url;
    public List<ProcessorType> outputs;
    public String association = ""property"";
    public NodeData(String id, Object node, String imagePrefix) {
        this.id = id;
        this.imagePrefix = imagePrefix;
        if (node instanceof ProcessorType) {
            ProcessorType processorType = (ProcessorType) node;
            this.edgeLabel = processorType.getLabel();
        }
        if (node instanceof FromType) {
            FromType fromType = (FromType) node;
            this.tooltop = fromType.getLabel();
            this.label = removeQueryString(this.tooltop);
            this.url = ""http://activemq.apache.org/camel/message-endpoint.html"";
        }
        else if (node instanceof ToType) {
            ToType toType = (ToType) node;
            this.tooltop = toType.getLabel();
            this.label = removeQueryString(this.tooltop);
            this.edgeLabel = """";
            this.url = ""http://activemq.apache.org/camel/message-endpoint.html"";
        }
        else if (node instanceof FilterType) {
            this.image = imagePrefix + ""MessageFilterIcon.gif"";
            this.nodeType = ""Message Filter"";
        }
        else if (node instanceof WhenType) {
            this.image = imagePrefix + ""MessageFilterIcon.gif"";
            this.nodeType = ""When Filter"";
            this.url = ""http://activemq.apache.org/camel/content-based-router.html"";
        }
        else if (node instanceof OtherwiseType) {
            this.nodeType = ""Otherwise"";
            this.edgeLabel = """";
            this.url = ""http://activemq.apache.org/camel/content-based-router.html"";
            this.tooltop = ""Otherwise"";
        }
        else if (node instanceof ChoiceType) {
            this.image = imagePrefix + ""ContentBasedRouterIcon.gif"";
            this.nodeType = ""Content Based Router"";
            this.label = """";
            this.edgeLabel = """";
            ChoiceType choice = (ChoiceType) node;
            List<ProcessorType> outputs = new ArrayList<ProcessorType>(choice.getWhenClauses());
            outputs.add(choice.getOtherwise());
            this.outputs = outputs;
        }
        else if (node instanceof RecipientListType) {
            this.image = imagePrefix + ""RecipientListIcon.gif"";
            this.nodeType = ""Recipient List"";
        }
        else if (node instanceof SplitterType) {
            this.image = imagePrefix + ""SplitterIcon.gif"";
            this.nodeType = ""Splitter"";
        }
        else if (node instanceof AggregatorType) {
            this.image = imagePrefix + ""AggregatorIcon.gif"";
            this.nodeType = ""Aggregator"";
        }
        else if (node instanceof ResequencerType) {
            this.image = imagePrefix + ""ResequencerIcon.gif"";
            this.nodeType = ""Resequencer"";
        }
        // lets auto-default as many values as we can
        if (isNullOrBlank(this.nodeType)) {
            // TODO we could add this to the model?
            String name = node.getClass().getName();
            int idx = name.lastIndexOf('.');
            if (idx > 0) {
                name = name.substring(idx + 1);
            }
            if (name.endsWith(""Type"")) {
                name = name.substring(0, name.length() - 4);
            }
            this.nodeType = insertSpacesBetweenCamelCase(name);
        }
        if (this.label == null) {
            if (isNullOrBlank(this.image)) {
                this.label = this.nodeType;
                this.shape = ""box"";
            }
            else if (isNotNullAndNonEmpty(this.edgeLabel)) {
                this.label = """";
            }
            else {
                this.label = node.toString();
            }
        }
        if (isNullOrBlank(this.tooltop)) {
            if (isNotNullAndNonEmpty(this.nodeType)) {
                String description = isNotNullAndNonEmpty(this.edgeLabel) ? this.edgeLabel : this.label;
                this.tooltop = this.nodeType + "": "" + description;
            }
            else {
                this.tooltop = this.label;
            }
        }
        if (isNullOrBlank(this.url) && isNotNullAndNonEmpty(this.nodeType)) {
            this.url = ""http://activemq.apache.org/camel/"" + this.nodeType.toLowerCase().replace(' ', '-') + "".html"";
        }
        if (node instanceof ProcessorType && this.outputs == null) {
            ProcessorType processorType = (ProcessorType) node;
            this.outputs = processorType.getOutputs();
        }
    }
    protected String removeQueryString(String text) {
        int idx = text.indexOf(""?"");
        if (idx <= 0) {
            return text;
        }
        else {
            return text.substring(0, idx);
        }
    }
    /**
     * lets insert a space before each upper case letter after a lowercase
     *
     * @param name
     * @return
     */
    public static String insertSpacesBetweenCamelCase(String name) {
        boolean lastCharacterLowerCase = false;
        StringBuffer buffer = new StringBuffer();
        for (int i = 0, size = name.length(); i < size; i++) {
            char ch = name.charAt(i);
            if (Character.isUpperCase(ch)) {
                if (lastCharacterLowerCase) {
                    buffer.append(' ');
                }
                lastCharacterLowerCase = false;
            }
            else {
                lastCharacterLowerCase = true;
            }
            buffer.append(ch);
        }
        return buffer.toString();
    }
}
"
org.apache.camel.view.RouteDotGenerator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.model.FromType;
import org.apache.camel.model.MulticastType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import static org.apache.camel.util.ObjectHelper.isNotNullAndNonEmpty;
/**
 * A <a href=""http://www.graphviz.org/"">DOT</a> file creator plugin which
 * creates a DOT file showing the current routes
 *
 * @version $Revision: 523881 $
 */
public class RouteDotGenerator extends GraphGeneratorSupport {
    public RouteDotGenerator(String dir) {
        super(dir, "".dot"");
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void printRoutes(PrintWriter writer, Map<String, List<RouteType>> map) {
        Set<Map.Entry<String, List<RouteType>>> entries = map.entrySet();
        for (Map.Entry<String, List<RouteType>> entry : entries) {
            String group = entry.getKey();
            printRoutes(writer, group, entry.getValue());
        }
    }
    protected void printRoutes(PrintWriter writer, String group, List<RouteType> routes) {
        if (group != null) {
            writer.println(""subgraph cluster_"" + (clusterCounter++) + "" {"");
            writer.println(""label = \"""" + group + ""\"";"");
            writer.println(""color = grey;"");
            writer.println(""style = \""dashed\"";"");
            writer.println(""URL = \"""" + group + "".html\"";"");
            writer.println();
        }
        for (RouteType route : routes) {
            List<FromType> inputs = route.getInputs();
            for (FromType input : inputs) {
                printRoute(writer, route, input);
            }
            writer.println();
        }
        if (group != null) {
            writer.println(""}"");
            writer.println();
        }
    }
    protected String escapeNodeId(String text) {
        return text.replace('.', '_').replace(""$"", ""_"");
    }
    protected void printRoute(PrintWriter writer, final RouteType route, FromType input) {
        NodeData nodeData = getNodeData(input);
        printNode(writer, nodeData);
        // TODO we should add a transactional client / event driven consumer / polling client
        List<ProcessorType> outputs = route.getOutputs();
        NodeData from = nodeData;
        for (ProcessorType output : outputs) {
            NodeData newData = printNode(writer, from, output);
            from = newData;
        }
    }
    protected NodeData printNode(PrintWriter writer, NodeData fromData, ProcessorType node) {
        if (node instanceof MulticastType) {
            // no need for a multicast node
            List<ProcessorType> outputs = node.getOutputs();
            for (ProcessorType output : outputs) {
                printNode(writer, fromData, output);
            }
            return fromData;
        }
        NodeData toData = getNodeData(node);
        printNode(writer, toData);
        if (fromData != null) {
            writer.print(fromData.id);
            writer.print("" -> "");
            writer.print(toData.id);
            writer.println("" ["");
            String label = fromData.edgeLabel;
            if (isNotNullAndNonEmpty(label)) {
                writer.println(""label = \"""" + label + ""\"""");
            }
            writer.println(""];"");
        }
        // now lets write any children
        //List<ProcessorType> outputs = node.getOutputs();
        List<ProcessorType> outputs = toData.outputs;
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                NodeData newData = printNode(writer, toData, output);
                if (!isMulticastNode(node)) {
                    toData = newData;
                }
            }
        }
        return toData;
    }
    protected void printNode(PrintWriter writer, NodeData data) {
        if (!data.nodeWritten) {
            data.nodeWritten = true;
            writer.println();
            writer.print(data.id);
            writer.println("" ["");
            writer.println(""label = \"""" + data.label + ""\"""");
            writer.println(""tooltip = \"""" + data.tooltop + ""\"""");
            if (data.url != null) {
                writer.println(""URL = \"""" + data.url + ""\"""");
            }
            String image = data.image;
            if (image != null) {
                writer.println(""shapefile = \"""" + image + ""\"""");
                writer.println(""peripheries=0"");
            }
            String shape = data.shape;
            if (shape == null && image != null) {
                shape = ""custom"";
            }
            if (shape != null) {
                writer.println(""shape = \"""" + shape + ""\"""");
            }
            writer.println(""];"");
            writer.println();
        }
    }
    protected void generateFile(PrintWriter writer, Map<String, List<RouteType>> map) {
        writer.println(""digraph CamelRoutes {"");
        writer.println();
        writer.println(""node [style = \""rounded,filled\"", fillcolor = yellow, ""
                + ""fontname=\""Helvetica-Oblique\""];"");
        writer.println();
        printRoutes(writer, map);
        writer.println(""}"");
    }
}
"
org.apache.camel.view.RouteDotGeneratorTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import junit.framework.TestCase;
/**
 * @version $Revision: 1.1 $
 */
public class RouteDotGeneratorTest extends TestCase {
    public void testInsertSpacesBetweenCamelCase() throws Exception {
        String value = NodeData.insertSpacesBetweenCamelCase(""FooBarType"");
        assertEquals(""Converted value"", ""Foo Bar Type"", value);
    }
}
"
org.apache.camel.view.XmlGraphGenerator,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.model.FromType;
import org.apache.camel.model.MulticastType;
import org.apache.camel.model.ProcessorType;
import org.apache.camel.model.RouteType;
import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
/**
 * @version $Revision: 1.1 $
 */
public class XmlGraphGenerator extends GraphGeneratorSupport {
    private boolean addUrl = true;
    public XmlGraphGenerator(String dir) {
        super(dir, "".xml"");
    }
    protected void generateFile(PrintWriter writer, Map<String, List<RouteType>> map) {
        writer.println(""<?xml version='1.0' encoding='UTF-8'?>"");
        writer.println(""<Graph>"");
        writer.println();
        if (map.size() > 0) {
            writer.println(""<Node id='root' name='Camel Routes' description='Collection of Camel Routes' nodeType='root'/>"");
        }
        printRoutes(writer, map);
        writer.println();
        writer.println(""</Graph>"");
    }
    protected void printRoutes(PrintWriter writer, Map<String, List<RouteType>> map) {
        Set<Map.Entry<String, List<RouteType>>> entries = map.entrySet();
        for (Map.Entry<String, List<RouteType>> entry : entries) {
            String group = entry.getKey();
            printRoutes(writer, group, entry.getValue());
        }
    }
    protected void printRoutes(PrintWriter writer, String group, List<RouteType> routes) {
        group = encode(group);
        if (group != null) {
            int idx = group.lastIndexOf('.');
            String name =group;
            if (idx > 0 && idx < group.length() -1 ) {
                name = group.substring(idx + 1);
            }
            writer.println(""<Node id='"" + group + ""' name='"" + name + ""' description='"" + group + ""' nodeType='group'/>"");
            writer.println(""<Edge fromID='root' toID='"" + group + ""'/>"");
        }
        for (RouteType route : routes) {
            List<FromType> inputs = route.getInputs();
            boolean first = true;
            for (FromType input : inputs) {
                NodeData nodeData = getNodeData(input);
                if (first) {
                    first = false;
                    if (group != null) {
                        writer.println(""<Edge fromID='"" + group + ""' toID='"" + encode(nodeData.id) + ""'/>"");
                    }
                }
                printRoute(writer, route, nodeData);
            }
            writer.println();
        }
    }
    protected void printRoute(PrintWriter writer, final RouteType route, NodeData nodeData) {
        printNode(writer, nodeData);
        // TODO we should add a transactional client / event driven consumer / polling client
        List<ProcessorType> outputs = route.getOutputs();
        NodeData from = nodeData;
        for (ProcessorType output : outputs) {
            NodeData newData = printNode(writer, from, output);
            from = newData;
        }
    }
    protected NodeData printNode(PrintWriter writer, NodeData fromData, ProcessorType node) {
        if (node instanceof MulticastType) {
            // no need for a multicast node
            List<ProcessorType> outputs = node.getOutputs();
            for (ProcessorType output : outputs) {
                printNode(writer, fromData, output);
            }
            return fromData;
        }
        NodeData toData = getNodeData(node);
        printNode(writer, toData);
        if (fromData != null) {
            writer.print(""<Edge fromID=\"""");
            writer.print(encode(fromData.id));
            writer.print(""\"" toID=\"""");
            writer.print(encode(toData.id));
            String association = toData.edgeLabel;
            if (isNullOrBlank(association)) {
                writer.print(""\"" association=\"""");
                writer.print(encode(association));
            }
            writer.println(""\""/>"");
        }
        // now lets write any children
        List<ProcessorType> outputs = toData.outputs;
        if (outputs != null) {
            for (ProcessorType output : outputs) {
                NodeData newData = printNode(writer, toData, output);
                if (!isMulticastNode(node)) {
                    toData = newData;
                }
            }
        }
        return toData;
    }
    protected void printNode(PrintWriter writer, NodeData data) {
        if (!data.nodeWritten) {
            data.nodeWritten = true;
            writer.println();
            writer.print(""<Node id=\"""");
            writer.print(encode(data.id));
            writer.print(""\"" name=\"""");
            String name = data.label;
            if (isNullOrBlank(name)) {
                name = data.tooltop;
            }
            writer.print(encode(name));
            writer.print(""\"" nodeType=\"""");
            String nodeType = data.image;
            if (isNullOrBlank(nodeType)) {
                nodeType = data.shape;
                if (isNullOrBlank(nodeType)) {
                    nodeType = ""node"";
                }
            }
            writer.print(encode(nodeType));
            writer.print(""\"" description=\"""");
            writer.print(encode(data.tooltop));
            if (addUrl) {
                writer.print(""\"" url=\"""");
                writer.print(encode(data.url));
            }
            writer.println(""\""/>"");
        }
    }
    protected String encode(String text) {
        if (text == null) {
            return """";
        }
        return text.replaceAll(""\"""", ""&quot;"").replaceAll(""<"", ""&lt;"").
                replaceAll("">"", ""&gt;"").replaceAll(""&"", ""&amp;"");
    }
}
"
org.apache.camel.view.XmlGraphTest,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.view;
/**
 * @version $Revision: 1.1 $
 */
public class XmlGraphTest extends DotViewTest {
    @Override
    public void testGenerateFiles() throws Exception {
        XmlGraphGenerator generator = new XmlGraphGenerator(outputDirectory);
        generator.drawRoutes(context);
    }
}
"
org.apache.camel.component.irc.IrcErrorLogger,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.commons.logging.Log;
import org.schwering.irc.lib.IRCEventAdapter;
import org.schwering.irc.lib.IRCModeParser;
import org.schwering.irc.lib.IRCUser;
/**
 * A helper class which logs errors
 *
 * @version $Revision: 1.1 $
 */
public class IrcErrorLogger extends IRCEventAdapter {
    private Log log;
    public IrcErrorLogger(Log log) {
        this.log = log;
    }
    @Override
    public void onRegistered() {
        super.onRegistered();
        log.info(""onRegistered"");
    }
    @Override
    public void onDisconnected() {
        super.onDisconnected();
        log.info(""onDisconnected"");
    }
    @Override
    public void onMode(String string, IRCUser ircUser, IRCModeParser ircModeParser) {
        super.onMode(string, ircUser, ircModeParser);
        log.info(""onMode.string = "" + string);
        log.info(""onMode.ircUser = "" + ircUser);
        log.info(""onMode.ircModeParser = "" + ircModeParser);
    }
    @Override
    public void onMode(IRCUser ircUser, String string, String string1) {
        super.onMode(ircUser, string, string1);
        log.info(""onMode.ircUser = "" + ircUser);
        log.info(""onMode.string = "" + string);
        log.info(""onMode.string1 = "" + string1);
    }
    @Override
    public void onPing(String string) {
        super.onPing(string);
        log.info(""onPing.string = "" + string);
    }
    @Override
    public void onError(String string) {
        log.info(""onError.string = "" + string);
    }
    @Override
    public void onError(int i, String string) {
        super.onError(i, string);
        log.error(""onError.i = "" + i);
        log.error(""onError.string = "" + string);
    }
    @Override
    public void unknown(String string, String string1, String string2, String string3) {
        super.unknown(string, string1, string2, string3);
        log.error(""unknown.string = "" + string);
        log.error(""unknown.string1 = "" + string1);
        log.error(""unknown.string2 = "" + string2);
        log.error(""unknown.string3 = "" + string3);
    }
}
"
org.apache.camel.component.cxf.CxfSoapConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Exchange;
import org.apache.cxf.endpoint.EndpointImpl;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.endpoint.ServerImpl;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.transport.ChainInitiationObserver;
import org.apache.cxf.wsdl11.WSDLServiceFactory;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.Bus;
import org.apache.cxf.interceptor.AttachmentInInterceptor;
import org.apache.cxf.interceptor.StaxInInterceptor;
import org.apache.cxf.binding.AbstractBindingFactory;
import org.apache.cxf.binding.soap.interceptor.ReadHeadersInterceptor;
import org.apache.cxf.binding.soap.interceptor.MustUnderstandInterceptor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A CXF based soap consumer.
 * The consumer will delegate to another endpoint for the transport layer
 * and will provide SOAP support on top of it.
 */
public class CxfSoapConsumer implements Consumer {
    private static final Log LOG = LogFactory.getLog(CxfSoapConsumer.class);
    private final CxfSoapEndpoint endpoint;
    private final Consumer consumer;
    private EndpointImpl ep;
    private MessageObserver chain;
    private Server server;
    public CxfSoapConsumer(CxfSoapEndpoint endpoint, Processor processor) throws Exception {
        this.endpoint = endpoint;
        Processor soapProcessor = new AsyncProcessorDecorator(processor,
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapConsumerIn(exchange);
                    }
                },
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapConsumerOut(exchange);
                    }
                });
        this.consumer = endpoint.getInnerEndpoint().createConsumer(soapProcessor);
        WSDLServiceFactory factory = new WSDLServiceFactory(getBus(), endpoint.getDefinition(), endpoint.getService());
        Service cxfService = factory.create();
        // need to find with the endpoint and service Qname
        EndpointInfo ei = cxfService.getServiceInfos().iterator().next().getEndpoints().iterator().next();
        ei.setAddress(""local://"" + ei.getService().getName().toString() + ""/"" + ei.getName().getLocalPart());
        ei.getBinding().setProperty(AbstractBindingFactory.DATABINDING_DISABLED, Boolean.TRUE);
        cxfService.getInInterceptors().add(new ReadHeadersInterceptor(getBus()));
        cxfService.getInInterceptors().add(new MustUnderstandInterceptor());
        cxfService.getInInterceptors().add(new AttachmentInInterceptor());
        cxfService.getInInterceptors().add(new StaxInInterceptor());
        cxfService.getInInterceptors().add(new ReadHeadersInterceptor(getBus()));
        ep = new EndpointImpl(getBus(), cxfService, ei);
        chain = new ChainInitiationObserver(ep, getBus());
        server = new ServerImpl(getBus(), ep, null, chain);
    }
    public void start() throws Exception {
        server.start();
        consumer.start();
    }
    public void stop() throws Exception {
        server.stop();
        consumer.stop();
    }
    protected Bus getBus() {
        return endpoint.getBus();
    }
    protected void processSoapConsumerIn(Exchange exchange) throws Exception {
        LOG.info(""processSoapConsumerIn: "" + exchange);
        // TODO: chain.onMessage();
    }
    protected void processSoapConsumerOut(Exchange exchange) throws Exception {
        LOG.info(""processSoapConsumerOut: "" + exchange);
        // TODO
    }
}
"
org.apache.camel.component.cxf.AsyncProcessorDecorator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.AsyncProcessor;
import org.apache.camel.Processor;
import org.apache.camel.Exchange;
import org.apache.camel.AsyncCallback;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.camel.impl.converter.AsyncProcessorTypeConverter;
/**
 * A simple class to wrap an existing processor (synchronous or asynchronous)
 * with two synchronous processor that will be executed before and after the
 * main processor.
 */
public class AsyncProcessorDecorator implements AsyncProcessor {
    private final AsyncProcessor processor;
    private final Processor before;
    private final Processor after;
    public AsyncProcessorDecorator(Processor processor, Processor before, Processor after) {
        this.processor = AsyncProcessorTypeConverter.convert(processor);
        this.before = before;
        this.after = after;
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(final Exchange exchange, final AsyncCallback callback) {
        try {
            before.process(exchange);
        } catch (Throwable t) {
            exchange.setException(t);
            callback.done(true);
            return true;
        }
        return processor.process(exchange, new AsyncCallback() {
            public void done(boolean doneSynchronously) {
                try {
                    after.process(exchange);
                    callback.done(doneSynchronously);
                } catch (Throwable t) {
                    exchange.setException(t);
                }
            }
        });
    }
}
"
org.apache.camel.component.cxf.interceptors.DOMOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ResourceBundle;
import java.util.logging.Logger;
//import java.util.logging.Level;
//import java.util.logging.Logger;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.interceptor.MessageSenderInterceptor;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
public class DOMOutInterceptor extends AbstractPhaseInterceptor<Message> {
    private static final Logger LOG = LogUtils.getL7dLogger(DOMOutInterceptor.class);
    private final XMLMessageOutInterceptor xmlInterceptor = new XMLMessageOutInterceptor();
    private final SoapMessageOutInterceptor soapInterceptor = new SoapMessageOutInterceptor();
    public DOMOutInterceptor() {
        super(Phase.PREPARE_SEND);
        this.addBefore(MessageSenderInterceptor.class.getName());
    }
    public boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(Message message) throws Fault {
        if (message instanceof XMLMessage) {
            xmlInterceptor.handleMessage((XMLMessage)message);
        } else if (message instanceof SoapMessage) {
            soapInterceptor.handleMessage((SoapMessage)message);
        } else {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""NOT_SUPPORTED_MESSAGE"", 
                                                                   LOG, message.getClass().getName()));
        }        
    }
}
"
org.apache.camel.component.file.remote.FtpProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.IOException;
import java.io.InputStream;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.commons.net.ftp.FTPClient;
public class FtpProducer extends RemoteFileProducer<RemoteFileExchange> {
    FtpEndpoint endpoint;
    private final FTPClient client;
    public FtpProducer(FtpEndpoint endpoint, FTPClient client) {
        super(endpoint);
        this.endpoint = endpoint;
        this.client = client;
    }
    public void process(Exchange exchange) throws Exception {
        process(endpoint.createExchange(exchange));
    }
    public void process(RemoteFileExchange exchange) throws Exception {
        InputStream payload = exchange.getIn().getBody(InputStream.class);
        final String endpointFile = endpoint.getConfiguration().getFile();
        client.changeWorkingDirectory(endpointFile); // TODO this line might
                                                     // not be needed...
                                                     // check after finish
                                                     // writing unit tests
        String fileName = createFileName(exchange.getIn(), endpoint.getConfiguration());
        buildDirectory(client, fileName.substring(0, fileName.lastIndexOf('/')));
        final boolean success = client.storeFile(fileName, payload);
        if (!success) {
            throw new RuntimeCamelException(""error sending file"");
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        // client.connect(endpoint.getConfiguration().getHost());
        // client.login(endpoint.getConfiguration().getUsername(),
        // endpoint.getConfiguration().getPassword());
        // client.setFileType(endpoint.getConfiguration().isBinary() ?
        // FTPClient.BINARY_FILE_TYPE : FTPClient.ASCII_FILE_TYPE);
    }
    @Override
    protected void doStop() throws Exception {
        client.disconnect();
        super.doStop();
    }
    protected static boolean buildDirectory(FTPClient ftpClient, String dirName) throws IOException {
        boolean atLeastOneSuccess = false;
        final StringBuilder sb = new StringBuilder(dirName.length());
        final String[] dirs = dirName.split(""\\/"");
        for (String dir : dirs) {
            sb.append('/').append(dir);
            final boolean success = ftpClient.makeDirectory(sb.toString());
            System.out.println(sb.toString() + "" = "" + success);
            if (!atLeastOneSuccess && success) {
                atLeastOneSuccess = true;
            }
        }
        return atLeastOneSuccess;
    }
}
"
org.apache.camel.component.mail.MessageHeaderAccessException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.MessagingException;
/**
 * @version $Revision:520964 $
 */
public class MessageHeaderAccessException extends RuntimeMailException {
    private static final long serialVersionUID = -3996286386119163309L;
    private final String propertyName;
    public MessageHeaderAccessException(String propertyName, MessagingException e) {
        super(""Error accessing header: "" + propertyName, e);
        this.propertyName = propertyName;
    }
    public String getPropertyName() {
        return propertyName;
    }
}
"
org.apache.camel.component.jms.JmsEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Processor;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultEndpoint;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Endpoint</a>
 * 
 * @version $Revision:520964 $
 */
public class JmsEndpoint extends DefaultEndpoint<JmsExchange> {
    private JmsBinding binding;
    private String destination;
    private final boolean pubSubDomain;
    private String selector;
    private JmsConfiguration configuration;
    public JmsEndpoint(String uri, JmsComponent component, String destination, boolean pubSubDomain, JmsConfiguration configuration) {
        super(uri, component);
        this.configuration = configuration;
        this.destination = destination;
        this.pubSubDomain = pubSubDomain;
    }
    public JmsProducer createProducer() throws Exception {
        JmsOperations template = createJmsOperations();
        return createProducer(template);
    }
    /**
     * Creates a producer using the given template
     */
    public JmsProducer createProducer(JmsOperations template) throws Exception {
        if (template instanceof JmsTemplate) {
            JmsTemplate jmsTemplate = (JmsTemplate)template;
            jmsTemplate.setPubSubDomain(pubSubDomain);
            jmsTemplate.setDefaultDestinationName(destination);
        }
        return new JmsProducer(this, template);
    }
    public JmsConsumer createConsumer(Processor processor) throws Exception {
        AbstractMessageListenerContainer listenerContainer = configuration.createMessageListenerContainer();
        return createConsumer(processor, listenerContainer);
    }
    /**
     * Creates a consumer using the given processor and listener container
     * 
     * @param processor the processor to use to process the messages
     * @param listenerContainer the listener container
     * @return a newly created consumer
     * @throws Exception if the consumer cannot be created
     */
    public JmsConsumer createConsumer(Processor processor, AbstractMessageListenerContainer listenerContainer) throws Exception {
        listenerContainer.setDestinationName(destination);
        listenerContainer.setPubSubDomain(pubSubDomain);
        if (selector != null) {
            listenerContainer.setMessageSelector(selector);
        }
        return new JmsConsumer(this, processor, listenerContainer);
    }
    @Override
    public PollingConsumer<JmsExchange> createPollingConsumer() throws Exception {
        JmsOperations template = createJmsOperations();
        return new JmsPollingConsumer(this, template);
    }
    @Override
    public JmsExchange createExchange(ExchangePattern pattern) {
        return new JmsExchange(getContext(), pattern, getBinding());
    }
    public JmsExchange createExchange(Message message) {
        return new JmsExchange(getContext(), getExchangePattern(), getBinding(), message);
    }
    // Properties
    // -------------------------------------------------------------------------
    public JmsBinding getBinding() {
        if (binding == null) {
            binding = new JmsBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a JMS
     * message
     * 
     * @param binding the binding to use
     */
    public void setBinding(JmsBinding binding) {
        this.binding = binding;
    }
    public String getDestination() {
        return destination;
    }
    public JmsConfiguration getConfiguration() {
        return configuration;
    }
    public String getSelector() {
        return selector;
    }
    /**
     * Sets the JMS selector to use
     */
    public void setSelector(String selector) {
        this.selector = selector;
    }
    public boolean isSingleton() {
        return false;
    }
    protected JmsOperations createJmsOperations() {
        return configuration.createJmsOperations(pubSubDomain, destination);
    }
}
"
org.apache.camel.component.cxf.phase.AbstractPhaseManagerImpl,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.phase;
import java.util.List;
import java.util.SortedSet;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.phase.PhaseManager;
public abstract class AbstractPhaseManagerImpl implements PhaseManager {
    private SortedSet<Phase> inPhases;
    private SortedSet<Phase> outPhases;
    public AbstractPhaseManagerImpl() {
        inPhases = createInPhases();
        outPhases = createOutPhases();
    }
    public SortedSet<Phase> getInPhases() {
        return inPhases;
    }
    public SortedSet<Phase> getOutPhases() {
        return outPhases;
    }
    protected abstract SortedSet<Phase> createInPhases();
    protected abstract SortedSet<Phase> createOutPhases();
}
"
org.apache.camel.component.irc.IrcBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
public class IrcBinding {
    public Object extractBodyFromIrc(IrcExchange exchange, IrcMessage message) {
        String type = message.getMessageType();
        String text = message.getMessage();
        if (text != null) {
            return text;
        } else {
            return type;
        }
    }
}
"
org.apache.camel.bam.processor.ProcessContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.bam.rules.ProcessRules;
/**
 * @version $Revision: 1.1 $
 */
public class ProcessContext {
    private Exchange exchange;
    private ProcessRules processRules;
    private ActivityRules activityRules;
    private ProcessInstance processInstance;
    private ActivityState activityState;
    public ProcessContext(Exchange exchange, ActivityRules activityRules, ActivityState activityState) {
        this.exchange = exchange;
        this.activityRules = activityRules;
        this.activityState = activityState;
        this.processRules = activityRules.getProcessRules();
        this.processInstance = activityState.getProcessInstance();
    }
    public ActivityRules getActivity() {
        return activityRules;
    }
    public void setActivity(ActivityRules activityRules) {
        this.activityRules = activityRules;
    }
    public ActivityState getActivityState() {
        return activityState;
    }
    public void setActivityState(ActivityState activityState) {
        this.activityState = activityState;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public void setExchange(Exchange exchange) {
        this.exchange = exchange;
    }
    public ProcessRules getProcessDefinition() {
        return processRules;
    }
    public void setProcessDefinition(ProcessRules processRules) {
        this.processRules = processRules;
    }
    public ProcessInstance getProcessInstance() {
        return processInstance;
    }
    public void setProcessInstance(ProcessInstance processInstance) {
        this.processInstance = processInstance;
    }
    public ActivityState getActivityState(ActivityRules activityRules) {
        return getProcessInstance().getActivityState(activityRules);
    }
    /**
     * Called when the activity is started which may end up creating some timers
     * for dependent actions
     */
    public void onStarted(ActivityState activityState) {
        /** TODO */
    }
    /**
     * Called when the activity is completed which may end up creating some timers
     * for dependent actions
     */
    public void onCompleted(ActivityState activityState) {
        /** TODO */
    }
}
"
org.apache.camel.spring.spi.SpringTransactionPolicy,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.Processor;
import org.apache.camel.spi.Policy;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * Wraps the processor in a Spring transaction
 *
 * @version $Revision: 1.1 $
 */
public class SpringTransactionPolicy<E> implements Policy<E> {
    private static final transient Log LOG = LogFactory.getLog(SpringTransactionPolicy.class);
    private TransactionTemplate template;
    public SpringTransactionPolicy(TransactionTemplate template) {
        this.template = template;
    }
    public Processor wrap(Processor processor) {
        final TransactionTemplate transactionTemplate = getTemplate();
        if (transactionTemplate == null) {
            LOG.warn(""No TransactionTemplate available so transactions will not be enabled!"");
            return processor;
        }
        TransactionInterceptor answer = new TransactionInterceptor(transactionTemplate);
        answer.setProcessor(processor);
        return answer;
    }
    public TransactionTemplate getTemplate() {
        return template;
    }
    public void setTemplate(TransactionTemplate template) {
        this.template = template;
    }
}
"
org.apache.camel.spring.remoting.CamelProxyFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.remoting;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.component.bean.ProxyHelper;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.remoting.support.UrlBasedRemoteAccessor;
/**
 * A {@link FactoryBean} to create a Proxy to a a Camel Pojo Endpoint.
 * 
 * @author chirino
 */
public class CamelProxyFactoryBean extends UrlBasedRemoteAccessor implements FactoryBean, CamelContextAware {
    private CamelContext camelContext;
    private Endpoint endpoint;
    private Object serviceProxy;
    @Override
    public void afterPropertiesSet() {
        super.afterPropertiesSet();
        try {
            if (endpoint == null) {
                if (getServiceUrl() == null || camelContext == null) {
                    throw new IllegalArgumentException(""If endpoint is not specified, the serviceUrl and camelContext must be specified."");
                }
                endpoint = camelContext.getEndpoint(getServiceUrl());
                if (endpoint == null) {
                    throw new IllegalArgumentException(""Could not resolve endpoint: "" + getServiceUrl());
                }
            }
            this.serviceProxy = ProxyHelper.createProxy(endpoint, getServiceInterface());
        } catch (Exception e) {
            throw new IllegalArgumentException(e);
        }
    }
    public Class getServiceInterface() {
        return super.getServiceInterface();
    }
    public String getServiceUrl() {
        return super.getServiceUrl();
    }
    public Object getObject() throws Exception {
        return serviceProxy;
    }
    public Class getObjectType() {
        return getServiceInterface();
    }
    public boolean isSingleton() {
        return true;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
}
"
org.apache.camel.spring.EndpointFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.NoSuchEndpointException;
import org.apache.camel.model.IdentifiedType;
import static org.apache.camel.util.ObjectHelper.notNull;
import org.springframework.beans.factory.FactoryBean;
import javax.xml.bind.annotation.*;
/**
 * A {@link FactoryBean} which instantiates {@link Endpoint} objects
 *
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""endpoint"")
@XmlAccessorType(XmlAccessType.FIELD)
public class EndpointFactoryBean extends IdentifiedType implements FactoryBean, CamelContextAware {
    @XmlAttribute
    private String uri;
    @XmlTransient
    private CamelContext context;
    @XmlTransient
    private Endpoint endpoint;
    @XmlTransient
    private boolean singleton;
    public Object getObject() throws Exception {
        if (endpoint == null) {
            endpoint = createEndpoint();
        }
        return endpoint;
    }
    public Class getObjectType() {
        return Endpoint.class;
    }
    public boolean isSingleton() {
        return singleton;
    }
    public CamelContext getCamelContext() {
        return context;
    }
    /**
     * Sets the context to use to resolve endpoints
     *
     * @param context the context used to resolve endpoints
     */
    public void setCamelContext(CamelContext context) {
        this.context = context;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public void setEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    public void setSingleton(boolean singleton) {
        this.singleton = singleton;
    }
    public String getUri() {
        return uri;
    }
    /**
     * Sets the URI to use to resolve the endpoint
     *
     * @param uri the URI used to set the endpoint
     */
    public void setUri(String uri) {
        this.uri = uri;
    }
    protected Endpoint createEndpoint() {
        notNull(context, ""context"");
        notNull(uri, ""uri"");
        Endpoint endpoint = context.getEndpoint(uri);
        if (endpoint == null) {
            throw new NoSuchEndpointException(uri);
        }
        return endpoint;
    }
}
"
org.apache.camel.component.cxf.spring.CxfEndpointBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.spring;
import org.apache.cxf.frontend.AbstractEndpointFactory;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
/**
 *
 */
public class CxfEndpointBean extends AbstractEndpointFactory {    
    public CxfEndpointBean() {
        setServiceFactory(new ReflectionServiceFactoryBean());
    }    
}
"
org.apache.camel.component.cxf.transport.CamelConstants,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
/**
 * @version $Revision$
 */
public class CamelConstants {
    public static final String TEXT_MESSAGE_TYPE = ""text"";
    public static final String BINARY_MESSAGE_TYPE = ""binary"";
    public static final String CAMEL_SERVER_REQUEST_HEADERS = ""org.apache.cxf.camel.server.request.headers"";
    public static final String CAMEL_SERVER_RESPONSE_HEADERS = ""org.apache.cxf.camel.server.response.headers"";
    public static final String CAMEL_REQUEST_MESSAGE = ""org.apache.cxf.camel.request.message"";
    public static final String CAMEL_RESPONSE_MESSAGE = ""org.apache.cxf.camel.reponse.message"";
    public static final String CAMEL_CLIENT_REQUEST_HEADERS = ""org.apache.cxf.camel.template.request.headers"";
    public static final String CAMEL_CLIENT_RESPONSE_HEADERS =
            ""org.apache.cxf.camel.template.response.headers"";
    public static final String CAMEL_CLIENT_RECEIVE_TIMEOUT = ""org.apache.cxf.camel.template.timeout"";
    public static final String CAMEL_SERVER_CONFIGURATION_URI =
            ""http://cxf.apache.org/configuration/transport/camel-server"";
    public static final String CAMEL_CLIENT_CONFIGURATION_URI =
            ""http://cxf.apache.org/configuration/transport/camel-template"";
    public static final String ENDPOINT_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/endpoint-config"";
    public static final String SERVICE_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/service-config"";
    public static final String PORT_CONFIGURATION_URI =
            ""http://cxf.apache.org/jaxws/port-config"";
    public static final String CAMEL_CLIENT_CONFIG_ID = ""camel-template"";
    public static final String CAMEL_SERVER_CONFIG_ID = ""camel-server"";
    public static final String CAMEL_REBASED_REPLY_TO = ""org.apache.cxf.camel.server.replyto"";
    public static final String CAMEL_CORRELATION_ID = ""org.apache.cxf.camel.correlationId"";
}
"
org.apache.camel.component.cxf.util.UriUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import org.apache.camel.component.cxf.CxfConstants;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
public final class UriUtils {
    private UriUtils() {
        // not constructred
    }
    static URL getWsdlUrl(final URI uri) throws MalformedURLException {
        URL wsdlUrl = null;
        if (uri.getScheme().equals(CxfConstants.PROTOCOL_NAME_RES)) {       
            if (uri.getPath() != null) {
                String path = uri.isAbsolute() ? getRelativePath(uri) : uri.getPath();
                wsdlUrl = ClassLoaderUtils.getResource(path, UriUtils.class);
            }
        } else {
            wsdlUrl = new URL(uri.getScheme(), uri.getHost(), uri.getPort(), uri.getPath());
        }
        return wsdlUrl;
    }
    private static String getRelativePath(URI uri) {
        URI base = null;
        try {
            base = new URI(CxfConstants.PROTOCOL_NAME_RES, """", ""/"", """");
        } catch (URISyntaxException e) {
            // this shouldn't fail
            e.printStackTrace();
        }
        return base.relativize(uri).getPath();
    }
}
"
org.apache.camel.language.juel.JuelLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.juel;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * The <a href=""http://activemq.apache.org/camel/el.html"">EL Language from JSP and JSF</a>
 * using the <a href=""http://activemq.apache.org/camel/juel.html"">JUEL library</a>
 *
 * @version $Revision: $
 */
public class JuelLanguage implements Language {
    public Predicate<Exchange> createPredicate(String expression) {
        return new JuelExpression(expression, Boolean.class);
    }
    public Expression<Exchange> createExpression(String expression) {
        return new JuelExpression(expression, Object.class);
    }
}
"
org.apache.camel.spring.SpringRouteBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.spring.spi.TransactionInterceptor;
import org.springframework.context.ApplicationContext;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * An extension of the {@link RouteBuilder} to provide some additional helper
 * methods
 * 
 * @version $Revision: 1.1 $
 */
public abstract class SpringRouteBuilder extends RouteBuilder {
    private ApplicationContext applicationContext;
    public TransactionInterceptor transactionInterceptor() {
        return new TransactionInterceptor(bean(TransactionTemplate.class));
    }
    /**
     * Looks up the bean with the given name in the application context and
     * returns it, or throws an exception if the bean is not present or is not
     * of the given type
     * 
     * @param type the type of the bean
     * @param beanName the name of the bean in the application context
     * @return the bean
     */
    public <T> T bean(Class<T> type, String beanName) {
        ApplicationContext context = getApplicationContext();
        return (T)context.getBean(beanName, type);
    }
    /**
     * Looks up the bean with the given type in the application context and
     * returns it, or throws an exception if the bean is not present or there
     * are multiple possible beans to choose from for the given type
     * 
     * @param type the type of the bean
     * @return the bean
     */
    public <T> T bean(Class<T> type) {
        ApplicationContext context = getApplicationContext();
        String[] names = context.getBeanNamesForType(type, true, true);
        if (names != null) {
            int count = names.length;
            if (count == 1) {
                // lets instantiate the single bean
                return (T)context.getBean(names[0]);
            } else if (count > 1) {
                throw new IllegalArgumentException(""Too many beans in the application context of type: "" + type + "". Found: "" + count);
            }
        }
        throw new IllegalArgumentException(""No bean available in the application context of type: "" + type);
    }
    /**
     * Returns the application context which has been configured via the
     * {@link #setApplicationContext(ApplicationContext)} method or from the
     * underlying {@link SpringCamelContext}
     * 
     * @return
     */
    public ApplicationContext getApplicationContext() {
        if (applicationContext == null) {
            CamelContext camelContext = getContext();
            if (camelContext instanceof SpringCamelContext) {
                SpringCamelContext springCamelContext = (SpringCamelContext)camelContext;
                return springCamelContext.getApplicationContext();
            } else {
                throw new IllegalArgumentException(""This SpringBuilder is not being used with a SpringCamelContext and there is no applicationContext property configured"");
            }
        }
        return applicationContext;
    }
    /**
     * Sets the application context to use to lookup beans
     */
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
}
"
org.apache.camel.language.juel.JuelExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.juel;
import javax.el.ELContext;
import javax.el.ExpressionFactory;
import javax.el.ValueExpression;
import de.odysseus.el.util.SimpleContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.impl.ExpressionSupport;
/**
 * The <a href=""http://activemq.apache.org/camel/el.html"">EL Language from JSP and JSF</a>
 * using the <a href=""http://activemq.apache.org/camel/juel.html"">JUEL library</a>
 * 
 * @version $Revision: $
 */
public class JuelExpression extends ExpressionSupport<Exchange> {
    private final String expression;
    private final Class<?> type;
    private ExpressionFactory expressionFactory;
    public JuelExpression(String expression, Class<?> type) {
        this.expression = expression;
        this.type = type;
    }
    public static JuelExpression el(String expression) {
        return new JuelExpression(expression, Object.class);
    }
    public Object evaluate(Exchange exchange) {
        // TODO we could use caching here but then we'd have possible concurrency issues
        // so lets assume that the provider caches
        ELContext context = populateContext(createContext(), exchange);
        ValueExpression valueExpression = getExpressionFactory().createValueExpression(context, expression, type);
        return valueExpression.getValue(context);
    }
    public ExpressionFactory getExpressionFactory() {
        if (expressionFactory == null) {
            expressionFactory = ExpressionFactory.newInstance();
        }
        return expressionFactory;
    }
    public void setExpressionFactory(ExpressionFactory expressionFactory) {
        this.expressionFactory = expressionFactory;
    }
    protected ELContext populateContext(ELContext context, Exchange exchange) {
        setVariable(context, ""exchange"", exchange, Exchange.class);
        setVariable(context, ""in"", exchange.getIn(), Message.class);
        setVariable(context, ""out"", exchange.getOut(), Message.class);
        return context;
    }
    protected void setVariable(ELContext context, String name, Object value, Class<?> type) {
        ValueExpression valueExpression = getExpressionFactory().createValueExpression(value, type);
        SimpleContext simpleContext = (SimpleContext) context;
        simpleContext.setVariable(name, valueExpression);
    }
    /**
     * Factory method to create the EL context
     */
    protected ELContext createContext() {
        return new SimpleContext();
    }
    protected String assertionFailureMessage(Exchange exchange) {
        return expression;
    }
}
"
org.apache.camel.component.cxf.invoker.CxfClient,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.cxf.Bus;
import org.apache.cxf.binding.Binding;
import org.apache.cxf.endpoint.ClientImpl;
import org.apache.cxf.endpoint.ConduitSelector;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.endpoint.EndpointImpl;
import org.apache.cxf.endpoint.PreexistingConduitSelector;
import org.apache.cxf.helpers.IOUtils;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.PhaseInterceptorChain;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.transport.MessageObserver;
/**
 * Just deal with the PayLoadMessage and RawMessage
 *
 */
public class CxfClient extends ClientImpl {
    private static final Logger LOG = Logger.getLogger(CxfClient.class.getName());
    private Endpoint endpoint;
    public CxfClient(Bus b, Endpoint e) {
        super(b, e);
        endpoint = e; 
    }
    public Object dispatch(Object params, 
                           Map<String, Object> context,
                           Exchange exchange) throws Exception {
        Object retval = null;
        InvokingContext invokingContext = exchange.get(InvokingContext.class);
        assert invokingContext != null;
        // get InBound binding operation info from the exchange object
        BindingOperationInfo inBoundOp = exchange.get(BindingOperationInfo.class);
        BindingOperationInfo outBoundOp = null;
        if (inBoundOp != null) {
            //Get the BindingOperationInfo for the outbound binding.
            BindingInfo bi = getEndpoint().getEndpointInfo().getBinding();
            outBoundOp = bi.getOperation(inBoundOp.getOperationInfo().getName());
            if (outBoundOp != null 
                && inBoundOp.isUnwrapped()) {
                outBoundOp = outBoundOp.getUnwrappedOperation();
            }
        }
        retval = invokeWithMessageStream(outBoundOp, params, context, invokingContext);
        return retval;
    }
    @SuppressWarnings(""unchecked"")
    public Object invokeWithMessageStream(BindingOperationInfo bi, 
                                          Object param, 
                                          Map<String, Object> context,
                                          InvokingContext invokingContext) throws Exception {
        Object retval = null;
        Map<String, Object> requestContext = null;
        Map<String, Object> responseContext = null;
        if (null != context) {
            requestContext = (Map<String, Object>) context.get(REQUEST_CONTEXT);
            responseContext = (Map<String, Object>) context.get(RESPONSE_CONTEXT);
        }
        Exchange exchange = new ExchangeImpl();
        // put the message Observer to call the CxfClient onMessage()
        exchange.put(MessageObserver.class, this);
        exchange.put(InvokingContext.class, invokingContext);
        exchange.put(Bus.class, bus);
        exchange.put(Endpoint.class, getEndpoint());
        exchange.put(BindingInfo.class, getEndpoint().getEndpointInfo().getBinding());
        if (bi != null) {
            //Set The InputMessage
            exchange.put(BindingOperationInfo.class, bi);
            exchange.put(BindingMessageInfo.class, bi.getInput());            
            exchange.setOneWay(bi.getOperationInfo().isOneWay());
        }
        Message message = prepareMessage(exchange, requestContext, param, invokingContext);
        PhaseInterceptorChain chain = setupOutChain(requestContext, message, invokingContext);
        // setup conduit selector
        prepareConduitSelector(message);
        // execute chain
        chain.doIntercept(message);
        //it will close all the stream in the message, so we do not call it  
        //getConduitSelector().complete(exchange);
        // Check to see if there is a Fault from the outgoing chain
        Exception ex = message.getContent(Exception.class);
        if (ex != null) {
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Exception in outgoing chain: "" + ex.toString());
            }
            throw ex;
        }
        if (!exchange.isOneWay()) {
            ex = getException(exchange);
            if (ex != null) {
                if (LOG.isLoggable(Level.FINE)) {
                    LOG.fine(""Exception in incoming chain: "" + ex.toString());
                }
                throw ex;
            }
            retval = invokingContext.getResponseObject(exchange, responseContext);  
        }
        return retval;
    }
    public void onMessage(Message message) {
        Exchange exchange = message.getExchange();
        if (LOG.isLoggable(Level.FINE)) {
            LOG.fine(""call the cxf client on message , exchange is "" + exchange);
        }    
        if (exchange.get(InvokingContext.class) == null) {
            super.onMessage(message);
        } else {
            message = getEndpoint().getBinding().createMessage(message);
            message.put(Message.REQUESTOR_ROLE, Boolean.TRUE);
            message.put(Message.INBOUND_MESSAGE, Boolean.TRUE);
            exchange.put(Binding.class, getEndpoint().getBinding());
            BindingOperationInfo bi = exchange.get(BindingOperationInfo.class);        
            if (bi != null) {
                //Set The OutputMessage
                exchange.put(BindingMessageInfo.class, bi.getOutput());
            }
            InvokingContext invokingContext = exchange.get(InvokingContext.class);
            assert invokingContext != null;
            // setup interceptor chain
            PhaseInterceptorChain chain = invokingContext.getResponseInInterceptorChain(exchange);
            message.setInterceptorChain(chain);
            // execute chain
            chain.doIntercept(message);
            // set inMessage in the exchange
            exchange.setInMessage(message);
        }
    }
    private Message prepareMessage(Exchange exchange, Map<String, Object> requestContext,
            Object param, InvokingContext InvokingContext) {
        Message message = getEndpoint().getBinding().createMessage();
        message.put(Message.REQUESTOR_ROLE, Boolean.TRUE);
        message.put(Message.INBOUND_MESSAGE, Boolean.FALSE);
        // setup the message context
        if (requestContext != null) {
            message.putAll(requestContext);
        }
        if (param != null) {
            InvokingContext.setRequestOutMessageContent(message, param);
        }
        if (null != requestContext) {
            exchange.putAll(requestContext);
        }
        exchange.setOutMessage(message);
        return message;
    }
    private PhaseInterceptorChain setupOutChain(Map<String, Object> requestContext,
            Message message, InvokingContext invokingContext) {
        if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""Build an out interceptor chain to send request to server"");
        }
        Exchange exchange = message.getExchange();
        PhaseInterceptorChain chain = invokingContext.getRequestOutInterceptorChain(exchange);
        message.setInterceptorChain(chain);
        modifyChain(chain, requestContext);
        chain.setFaultObserver(outFaultObserver);
        return chain;
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public Bus getBus() {
        return bus;
    }
}
"
org.apache.camel.bam.processor.BamProcessorSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.orm.jpa.JpaSystemException;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionTemplate;
import javax.persistence.EntityExistsException;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
/**
 * A base {@link Processor} for working on <a
 * href=""http://activemq.apache.org/camel/bam.html"">BAM</a> which a derived
 * class would do the actual persistence such as the {@link JpaBamProcessor}
 *
 * @version $Revision: $
 */
public abstract class BamProcessorSupport<T> implements Processor {
    private static final transient Log LOG = LogFactory.getLog(BamProcessorSupport.class);
    private Class<T> entityType;
    private Class primaryKeyType = String.class;
    private Expression<Exchange> correlationKeyExpression;
    private TransactionTemplate transactionTemplate;
    private int maximumRetries = 30;
    public int getMaximumRetries() {
        return maximumRetries;
    }
    public void setMaximumRetries(int maximumRetries) {
        this.maximumRetries = maximumRetries;
    }
    protected BamProcessorSupport(TransactionTemplate transactionTemplate, Expression<Exchange> correlationKeyExpression) {
        this.transactionTemplate = transactionTemplate;
        this.correlationKeyExpression = correlationKeyExpression;
        Type type = getClass().getGenericSuperclass();
        if (type instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            Type[] arguments = parameterizedType.getActualTypeArguments();
            if (arguments.length > 0) {
                Type argumentType = arguments[0];
                if (argumentType instanceof Class) {
                    this.entityType = (Class<T>) argumentType;
                }
            }
        }
        if (entityType == null) {
            throw new IllegalArgumentException(""Could not infer the entity type!"");
        }
    }
    protected BamProcessorSupport(TransactionTemplate transactionTemplate, Expression<Exchange> correlationKeyExpression, Class<T> entitytype) {
        this.transactionTemplate = transactionTemplate;
        this.entityType = entitytype;
        this.correlationKeyExpression = correlationKeyExpression;
    }
    public void process(final Exchange exchange) {
        Object entity = null;
        for (int i = 0; entity == null && i < maximumRetries; i++) {
            if (i > 0) {
                LOG.info(""Retry attempt due to duplicate row: "" + i);
            }
            entity = transactionTemplate.execute(new TransactionCallback() {
                public Object doInTransaction(TransactionStatus status) {
                    try {
                        Object key = getCorrelationKey(exchange);
                        T entity = loadEntity(exchange, key);
                        if (LOG.isDebugEnabled()) {
                            LOG.debug(""Correlation key: "" + key + "" with entity: "" + entity);
                        }
                        processEntity(exchange, entity);
                        return entity;
                    }
                    catch (JpaSystemException e) {
                        if (LOG.isDebugEnabled()) {
                            LOG.debug(""Likely exception is due to duplicate row in concurrent setting: "" + e, e);
                        }
                        LOG.info(""Attempt to insert duplicate row due to concurrency issue, so retrying: "" + e);
                        return retryDueToDuplicate(status);
                    }
                    catch (DataIntegrityViolationException e) {
                        Throwable throwable = e.getCause();
                        if (throwable instanceof EntityExistsException) {
                            LOG.info(""Attempt to insert duplicate row due to concurrency issue, so retrying: "" + throwable);
                            return retryDueToDuplicate(status);
                        }
                        return onError(status, throwable);
                    }
                    catch (Throwable e) {
                        return onError(status, e);
                    }
                }
            });
        }
    }
    // Properties
    // -----------------------------------------------------------------------
    public Expression<Exchange> getCorrelationKeyExpression() {
        return correlationKeyExpression;
    }
    public Class<T> getEntityType() {
        return entityType;
    }
    // Implemenation methods
    // -----------------------------------------------------------------------
    protected abstract void processEntity(Exchange exchange, T entity) throws Exception;
    protected abstract T loadEntity(Exchange exchange, Object key) throws Exception;
    protected abstract Class getKeyType();
    protected Object getCorrelationKey(Exchange exchange) throws NoCorrelationKeyException {
        Object value = correlationKeyExpression.evaluate(exchange);
        Class keyType = getKeyType();
        if (keyType != null) {
            value = ExchangeHelper.convertToType(exchange, keyType, value);
        }
        if (value == null) {
            throw new NoCorrelationKeyException(this, exchange);
        }
        return value;
    }
    protected Object retryDueToDuplicate(TransactionStatus status) {
        status.setRollbackOnly();
        return null;
    }
    protected Object onError(TransactionStatus status, Throwable e) {
        status.setRollbackOnly();
        LOG.error(""Caught: "" + e, e);
        throw new RuntimeCamelException(e);
    }
}
"
org.apache.camel.spring.CamelProxyFactoryType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.IdentifiedType;
/**
 * @version $Revision: $
*/ // to fudge the XSD generation
@XmlRootElement(name = ""proxy"")
public class CamelProxyFactoryType extends IdentifiedType {
    @XmlAttribute
    private String serviceUrl;
    @XmlAttribute
    private Class serviceInterface;
}
"
org.apache.camel.component.jdbc.JdbcComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing pejdbcssions and
 * limitations under the License.
 */
package org.apache.camel.component.jdbc;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.DefaultExchange;
/**
 * @version $Revision:520964 $
 */
public class JdbcComponent extends DefaultComponent<DefaultExchange> {
    public JdbcComponent() {
    }
    public JdbcComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<DefaultExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new JdbcEndpoint(uri, remaining, this);
    }
    @Override
    protected void doStart() throws Exception {
        // TODO Auto-generated method stub
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        // TODO Auto-generated method stub
        super.doStop();
    }
}
"
org.apache.camel.component.validator.jing.JingValidator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator.jing;
import java.io.IOException;
import java.io.InputStream;
import javax.xml.XMLConstants;
import javax.xml.transform.Source;
import javax.xml.transform.sax.SAXSource;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import com.thaiopensource.relaxng.SchemaFactory;
import com.thaiopensource.util.PropertyMap;
import com.thaiopensource.util.PropertyMapBuilder;
import com.thaiopensource.validate.IncorrectSchemaException;
import com.thaiopensource.validate.Schema;
import com.thaiopensource.validate.ValidateProperty;
import com.thaiopensource.validate.Validator;
import com.thaiopensource.xml.sax.Jaxp11XMLReaderCreator;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.Processor;
import org.apache.camel.processor.validation.DefaultValidationErrorHandler;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.Resource;
/**
 * A validator which uses the <a
 * href=""http://www.thaiopensource.com/relaxng/jing.html"">Jing</a> library to
 * validate XML against RelaxNG
 * 
 * @version $Revision: 1.1 $
 */
public class JingValidator implements Processor {
    private static final transient Log LOG = LogFactory.getLog(JingValidator.class);
    private Schema schema;
    private SchemaFactory schemaFactory;
    private String schemaNamespace = XMLConstants.RELAXNG_NS_URI;
    private Resource schemaResource;
    private InputSource inputSource;
    private boolean compactSyntax;
    public void process(Exchange exchange) throws Exception {
        Jaxp11XMLReaderCreator xmlCreator = new Jaxp11XMLReaderCreator();
        DefaultValidationErrorHandler errorHandler = new DefaultValidationErrorHandler();
        PropertyMapBuilder mapBuilder = new PropertyMapBuilder();
        mapBuilder.put(ValidateProperty.XML_READER_CREATOR, xmlCreator);
        mapBuilder.put(ValidateProperty.ERROR_HANDLER, errorHandler);
        PropertyMap propertyMap = mapBuilder.toPropertyMap();
        Validator validator = getSchema().createValidator(propertyMap);
        Message in = exchange.getIn();
        SAXSource saxSource = in.getBody(SAXSource.class);
        if (saxSource == null) {
            Source source = ExchangeHelper.getMandatoryInBody(exchange, Source.class);
            saxSource = ExchangeHelper.convertToMandatoryType(exchange, SAXSource.class, source);
        }
        InputSource bodyInput = saxSource.getInputSource();
        // now lets parse the body using the validator
        XMLReader reader = xmlCreator.createXMLReader();
        reader.setContentHandler(validator.getContentHandler());
        reader.setDTDHandler(validator.getDTDHandler());
        reader.setErrorHandler(errorHandler);
        reader.parse(bodyInput);
        errorHandler.handleErrors(exchange, schema);
    }
    // Properties
    // -------------------------------------------------------------------------
    public Schema getSchema() throws IOException, IncorrectSchemaException, SAXException {
        if (schema == null) {
            SchemaFactory factory = getSchemaFactory();
            schema = factory.createSchema(getInputSource());
        }
        return schema;
    }
    public void setSchema(Schema schema) {
        this.schema = schema;
    }
    public InputSource getInputSource() throws IOException {
        if (inputSource == null) {
            Resource resource = getSchemaResource();
            if (resource == null) {
                throw new IllegalArgumentException(""No schemaResource or inputSource specified"");
            } else {
                InputStream inputStream = resource.getInputStream();
                if (inputStream == null) {
                    throw new IllegalArgumentException(""No inputStream available for: "" + resource);
                }
                inputSource = new InputSource(inputStream);
            }
        }
        return inputSource;
    }
    public void setInputSource(InputSource inputSource) {
        this.inputSource = inputSource;
    }
    public SchemaFactory getSchemaFactory() {
        if (schemaFactory == null) {
            schemaFactory = new SchemaFactory();
            schemaFactory.setCompactSyntax(compactSyntax);
            schemaFactory.setXMLReaderCreator(new Jaxp11XMLReaderCreator());
        }
        return schemaFactory;
    }
    public void setSchemaFactory(SchemaFactory schemaFactory) {
        this.schemaFactory = schemaFactory;
    }
    public Resource getSchemaResource() {
        return schemaResource;
    }
    public void setSchemaResource(Resource schemaResource) {
        this.schemaResource = schemaResource;
    }
    public String getSchemaNamespace() {
        return schemaNamespace;
    }
    public void setSchemaNamespace(String schemaNamespace) {
        this.schemaNamespace = schemaNamespace;
    }
    public boolean isCompactSyntax() {
        return compactSyntax;
    }
    public void setCompactSyntax(boolean compactSyntax) {
        this.compactSyntax = compactSyntax;
    }
}
"
org.apache.camel.language.ognl.RootObject,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
/**
 * @version $Revision: $
 */
public class RootObject {
    private final Exchange exchange;
    public RootObject(Exchange exchange) {
        this.exchange = exchange;
    }
    public Exchange getExchange() {
        return exchange;
    }
    public CamelContext getContext() {
        return exchange.getContext();
    }
    public Throwable getException() {
        return exchange.getException();
    }
    public String getExchangeId() {
        return exchange.getExchangeId();
    }
    public Message getFault() {
        return exchange.getFault();
    }
    public Message getRequest() {
        return exchange.getIn();
    }
    public Message getIn() {
        return exchange.getIn();
    }
    public Message getOut() {
        return exchange.getOut();
    }
    public Message getResponse() {
        return exchange.getOut();
    }
    public Map<String, Object> getProperties() {
        return exchange.getProperties();
    }
    public Object getProperty(String name) {
        return exchange.getProperty(name);
    }
    public <T> T getProperty(String name, Class<T> type) {
        return exchange.getProperty(name, type);
    }
}
"
org.apache.camel.component.mail.MailBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import javax.mail.Address;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import org.apache.camel.Exchange;
import org.apache.camel.converter.ObjectConverter;
/**
 * A Strategy used to convert between a Camel {@Exchange} and {@Message} to and
 * from a Mail {@link MimeMessage}
 * 
 * @version $Revision: 521240 $
 */
public class MailBinding {
    public void populateMailMessage(MailEndpoint endpoint, MimeMessage mimeMessage, Exchange exchange) {
        try {
            appendHeadersFromCamel(mimeMessage, exchange, exchange.getIn());
            String destination = endpoint.getConfiguration().getDestination();
            if (destination != null) {
                mimeMessage.setRecipients(Message.RecipientType.TO, destination);
            }
            if (empty(mimeMessage.getFrom())) {
                // lets default the address to the endpoint destination
                String from = endpoint.getConfiguration().getFrom();
                mimeMessage.setFrom(new InternetAddress(from));
            }
            mimeMessage.setText(exchange.getIn().getBody(String.class));
        } catch (Exception e) {
            throw new RuntimeMailException(""Failed to populate body due to: "" + e + "". Exchange: "" + exchange, e);
        }
    }
    protected boolean empty(Address[] addresses) {
        return addresses == null || addresses.length == 0;
    }
    /**
     * Extracts the body from the Mail message
     * 
     * @param exchange
     * @param message
     */
    public Object extractBodyFromMail(MailExchange exchange, Message message) {
        try {
            return message.getContent();
        } catch (Exception e) {
            throw new RuntimeMailException(""Failed to extract body due to: "" + e + "". Message: "" + message, e);
        }
    }
    /**
     * Appends the Mail headers from the Camel {@link MailMessage}
     */
    protected void appendHeadersFromCamel(MimeMessage mimeMessage, Exchange exchange, org.apache.camel.Message camelMessage) throws MessagingException {
        Set<Map.Entry<String, Object>> entries = camelMessage.getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            String headerName = entry.getKey();
            Object headerValue = entry.getValue();
            if (headerValue != null) {
                if (shouldOutputHeader(camelMessage, headerName, headerValue)) {
                    // Mail messages can repeat the same header...
                    if (ObjectConverter.isCollection(headerValue)) {
                        Iterator iter = ObjectConverter.iterator(headerValue);
                        while (iter.hasNext()) {
                            Object value = iter.next();
                            mimeMessage.addHeader(headerName, asString(exchange, value));
                        }
                    } else {
                        mimeMessage.setHeader(headerName, asString(exchange, headerValue));
                    }
                }
            }
        }
    }
    /**
     * Converts the given object value to a String
     */
    protected String asString(Exchange exchange, Object value) {
        return exchange.getContext().getTypeConverter().convertTo(String.class, value);
    }
    /**
     * Strategy to allow filtering of headers which are put on the Mail message
     */
    protected boolean shouldOutputHeader(org.apache.camel.Message camelMessage, String headerName, Object headerValue) {
        return true;
    }
}
"
org.apache.camel.language.ognl.OgnlExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import ognl.Ognl;
import ognl.OgnlContext;
import ognl.OgnlException;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.impl.ExpressionSupport;
import org.apache.camel.language.ExpressionEvaluationException;
import org.apache.camel.language.IllegalSyntaxException;
import java.util.HashMap;
import java.util.Map;
/**
 * An <a href=""http://www.ognl.org/"">OGNL</a> {@link Expression}
 *
 * @version $Revision: $
 */
public class OgnlExpression extends ExpressionSupport<Exchange> {
    private final String expressionString;
    private final Class<?> type;
    private Object expression;
    public OgnlExpression(OgnlLanguage language, String expressionString, Class<?> type) {
        this.expressionString = expressionString;
        this.type = type;
        try {
            this.expression = Ognl.parseExpression(expressionString);
        } catch (OgnlException e) {
            throw new IllegalSyntaxException(language, expressionString);
        }
    }
    public static OgnlExpression ognl(String expression) {
        return new OgnlExpression(new OgnlLanguage(), expression, Object.class);
    }
    public Object evaluate(Exchange exchange) {
        // TODO we could use caching here but then we'd have possible
        // concurrency issues
        // so lets assume that the provider caches
        Map values = new HashMap();
        populateContext(values, exchange);
        OgnlContext oglContext = new OgnlContext();
        try {
            return Ognl.getValue(expression, oglContext, new RootObject(exchange));
        } catch (OgnlException e) {
            throw new ExpressionEvaluationException(this, exchange, e);
        }
    }
    protected void populateContext(Map map, Exchange exchange) {
        map.put(""exchange"", exchange);
        map.put(""in"", exchange.getIn());
        map.put(""out"", exchange.getOut());
    }
    protected String assertionFailureMessage(Exchange exchange) {
        return expressionString;
    }
}
"
org.apache.camel.component.cxf.interceptors.DOMInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ResourceBundle;
import java.util.logging.Logger;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.interceptor.SoapActionInInterceptor;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
public class DOMInInterceptor extends AbstractPhaseInterceptor<Message> {
    private static final Logger LOG = LogUtils.getL7dLogger(DOMOutInterceptor.class);
    private final XMLMessageInInterceptor xmlInterceptor = new XMLMessageInInterceptor();
    private final SoapMessageInInterceptor soapInterceptor = new SoapMessageInInterceptor();
    public DOMInInterceptor() {
        super(Phase.READ);
        this.addAfter(SoapActionInInterceptor.class.getName());
        this.addBefore(PayloadInInterceptor.class.getName());
    }
    public boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    public void handleMessage(Message message) throws Fault {
        if (message instanceof XMLMessage) {
            xmlInterceptor.handleMessage((XMLMessage)message);
        } else if (message instanceof SoapMessage) {
            soapInterceptor.handleMessage((SoapMessage)message);
        } else {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""NOT_SUPPORTED_MESSAGE"", 
                                                                   LOG, message.getClass().getName()));
        }
    }
}
"
org.apache.camel.component.mina.MinaExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * A {@link Exchange} for MINA
 * 
 * @version $Revision$
 */
public class MinaExchange extends DefaultExchange {
    public MinaExchange(CamelContext camelContext, ExchangePattern pattern) {
        super(camelContext, pattern);
    }
}
"
org.apache.camel.builder.script.JavaScript,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.language.LanguageAnnotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation for injection of JavaScript expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""js"")
public @interface JavaScript {
    public abstract String value();
}"
org.apache.camel.component.event.EventEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.processor.loadbalancer.TopicLoadBalancer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationEvent;
/**
 * An <a href=""http://activemq.apache.org/camel/event.html"">Event Endpoint</a>
 * for working with Spring ApplicationEvents
 * 
 * @version $Revision: 1.1 $
 */
public class EventEndpoint extends DefaultEndpoint<Exchange> {
    private final EventComponent component;
    private LoadBalancer loadBalancer;
    public EventEndpoint(String endpointUri, EventComponent component) {
        super(endpointUri, component);
        this.component = component;
    }
    @Override
    public EventComponent getComponent() {
        return component;
    }
    public ApplicationContext getApplicationContext() {
        return getComponent().getApplicationContext();
    }
    public boolean isSingleton() {
        return true;
    }
    public Producer<Exchange> createProducer() throws Exception {
        return new DefaultProducer<Exchange>(this) {
            public void process(Exchange exchange) throws Exception {
                ApplicationEvent event = toApplicationEvent(exchange);
                getApplicationContext().publishEvent(event);
            }
        };
    }
    public EventConsumer createConsumer(Processor processor) throws Exception {
        return new EventConsumer(this, processor);
    }
    public void onApplicationEvent(ApplicationEvent event) {
        Exchange exchange = createExchange();
        exchange.getIn().setBody(event);
        try {
            getLoadBalancer().process(exchange);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    public LoadBalancer getLoadBalancer() {
        if (loadBalancer == null) {
            loadBalancer = createLoadBalancer();
        }
        return loadBalancer;
    }
    public void setLoadBalancer(LoadBalancer loadBalancer) {
        this.loadBalancer = loadBalancer;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    public synchronized void consumerStarted(EventConsumer consumer) {
        getLoadBalancer().addProcessor(consumer.getProcessor());
    }
    public synchronized void consumerStopped(EventConsumer consumer) {
        getLoadBalancer().removeProcessor(consumer.getProcessor());
    }
    protected LoadBalancer createLoadBalancer() {
        return new TopicLoadBalancer();
    }
    protected ApplicationEvent toApplicationEvent(Exchange exchange) {
        ApplicationEvent event = exchange.getIn().getBody(ApplicationEvent.class);
        if (event == null) {
            event = new CamelEvent(this, exchange);
        }
        return event;
    }
}
"
org.apache.camel.converter.jaxb.LongHeader,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""longHeader"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class LongHeader extends HeaderType {
    @XmlAttribute(name = ""value"")
    private Long number;
    public LongHeader() {
    }
    public LongHeader(String name, Long number) {
        super(name);
        this.number = number;
    }
    public Long getNumber() {
        return number;
    }
    public void setNumber(Long number) {
        this.number = number;
    }
    public Object getValue() {
        return getNumber();
    }
    public void setValue(Object value) {
        if (value instanceof Number) {
            Number n = (Number) value;
            setNumber(n.longValue());
        }
        else {
            throw new IllegalArgumentException(""Value must be a Long"");
        }
    }
}"
org.apache.camel.converter.jaxb.JaxbDataFormat,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import org.apache.camel.Exchange;
import org.apache.camel.spi.DataFormat;
import org.apache.camel.util.IOHelper;
/**
 * A <a href=""http://activemq.apache.org/camel/data-format.html"">data format</a>
 * ({@link DataFormat}) using JAXB2 to marshal to and from XML
 *
 * @version $Revision: 1.1 $
 */
public class JaxbDataFormat implements DataFormat {
    private JAXBContext context;
    private String contextPath;
    private boolean prettyPrint = true;
    private Marshaller marshaller;
    private Unmarshaller unmarshaller;
    public JaxbDataFormat() {
    }
    public JaxbDataFormat(JAXBContext context) {
        this.context = context;
    }
    public JaxbDataFormat(String contextPath) {
        this.contextPath = contextPath;
    }
    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws IOException {
        try {
            getMarshaller().marshal(graph, stream);
        }
        catch (JAXBException e) {
            throw IOHelper.createIOException(e);
        }
    }
    public Object unmarshal(Exchange exchange, InputStream stream) throws IOException, ClassNotFoundException {
        try {
            return getUnmarshaller().unmarshal(stream);
        }
        catch (JAXBException e) {
            throw IOHelper.createIOException(e);
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public JAXBContext getContext() throws JAXBException {
        if (context == null) {
            context = createContext();
        }
        return context;
    }
    public void setContext(JAXBContext context) {
        this.context = context;
    }
    public Marshaller getMarshaller() throws JAXBException {
        if (marshaller == null) {
            marshaller = getContext().createMarshaller();
        }
        return marshaller;
    }
    public void setMarshaller(Marshaller marshaller) {
        this.marshaller = marshaller;
    }
    public boolean isPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
    public Unmarshaller getUnmarshaller() throws JAXBException {
        if (unmarshaller == null) {
            unmarshaller = getContext().createUnmarshaller();
        }
        return unmarshaller;
    }
    public void setUnmarshaller(Unmarshaller unmarshaller) {
        this.unmarshaller = unmarshaller;
    }
    protected JAXBContext createContext() throws JAXBException {
        if (contextPath != null) {
            return JAXBContext.newInstance(contextPath);
        }
        else {
            return JAXBContext.newInstance();
        }
    }
}
"
org.apache.camel.builder.script.BeanShell,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.language.LanguageAnnotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation for injection of BeanShell expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""beanshell"")
public @interface BeanShell {
    public abstract String value();
}"
org.apache.camel.component.cxf.CxfSoapProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.*;
import org.apache.camel.util.AsyncProcessorHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A CXF based soap provider.
 * The consumer will delegate to another endpoint for the transport layer
 * and will provide SOAP support on top of it.
 */
public class CxfSoapProducer implements Producer, AsyncProcessor {
    private static final Log LOG = LogFactory.getLog(CxfSoapProducer.class);
    private final CxfSoapEndpoint endpoint;
    private final Producer producer;
    private final AsyncProcessor processor;
    public CxfSoapProducer(CxfSoapEndpoint endpoint) throws Exception {
        this.endpoint = endpoint;
        this.producer = endpoint.getInnerEndpoint().createProducer();
        this.processor = new AsyncProcessorDecorator(producer,
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapProviderIn(exchange);
                    }
                },
                new Processor() {
                    public void process(Exchange exchange) throws Exception {
                        processSoapProviderOut(exchange);
                    }
                });
    }
    public Endpoint getEndpoint() {
        return producer.getEndpoint();
    }
    public Exchange createExchange() {
        return producer.createExchange();
    }
    public Exchange createExchange(ExchangePattern pattern) {
        return producer.createExchange(pattern);
    }
    public Exchange createExchange(Exchange exchange) {
        return producer.createExchange(exchange);
    }
    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }
    public boolean process(Exchange exchange, AsyncCallback callback) {
        return processor.process(exchange, callback);
    }
    public void start() throws Exception {
        producer.start();
    }
    public void stop() throws Exception {
        producer.stop();
    }
    protected void processSoapProviderIn(Exchange exchange) throws Exception {
        LOG.info(""processSoapProviderIn: "" + exchange);
        // TODO
    }
    protected void processSoapProviderOut(Exchange exchange) throws Exception {
        LOG.info(""processSoapProviderOut: "" + exchange);
        // TODO
    }
}
"
org.apache.camel.converter.jaxb.StringHeader,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""header"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class StringHeader extends HeaderType {
    @XmlAttribute(name = ""value"", required = true)
    private String text;
    public StringHeader() {
    }
    public StringHeader(String name, String text) {
        super(name);
        this.text = text;
    }
    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
    public Object getValue() {
        return getText();
    }
    public void setValue(Object value) {
        if (value instanceof String) {
            setText((String) value);
        }
        else {
            throw new IllegalArgumentException(""Value must be a String"");
        }
    }
}
"
org.apache.camel.bam.TimeExpression,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import java.util.Date;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.bam.rules.TemporalRule;
import org.apache.camel.util.ObjectHelper;
/**
 * @version $Revision: $
 */
public abstract class TimeExpression {
    private ActivityRules activityRules;
    private ActivityBuilder builder;
    private ActivityLifecycle lifecycle;
    public TimeExpression(ActivityBuilder builder, ActivityLifecycle lifecycle) {
        this.lifecycle = lifecycle;
        this.builder = builder;
        this.activityRules = builder.getActivityRules();
    }
    public boolean isActivityLifecycle(ActivityRules activityRules, ActivityLifecycle lifecycle) {
        return ObjectHelper.equals(activityRules, this.activityRules) && ObjectHelper.equals(lifecycle, this.lifecycle);
    }
    /**
     * Creates a new temporal rule on this expression and the other expression
     */
    public TemporalRule after(TimeExpression expression) {
        TemporalRule rule = new TemporalRule(expression, this);
        rule.getSecond().getActivityRules().addRule(rule);
        return rule;
    }
    public Date evaluate(ProcessInstance processInstance) {
        ActivityState state = processInstance.getActivityState(activityRules);
        if (state != null) {
            return evaluate(processInstance, state);
        }
        return null;
    }
    public abstract Date evaluate(ProcessInstance instance, ActivityState state);
    // Properties
    //-------------------------------------------------------------------------
    public ActivityBuilder getBuilder() {
        return builder;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public ActivityLifecycle getLifecycle() {
        return lifecycle;
    }
    public ActivityState getActivityState(ProcessInstance instance) {
        return instance.getActivityState(activityRules);
    }
    public ActivityState getOrCreateActivityState(ProcessInstance instance) {
        return instance.getOrCreateActivityState(activityRules);
    }
}
"
org.apache.camel.component.irc.IrcConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.schwering.irc.lib.IRCConnection;
import org.schwering.irc.lib.IRCEventAdapter;
import org.schwering.irc.lib.IRCModeParser;
import org.schwering.irc.lib.IRCUser;
public class IrcConsumer extends DefaultConsumer<IrcExchange> {
    private static final transient Log LOG = LogFactory.getLog(IrcConsumer.class);
    private final IrcConfiguration configuration;
    private final IrcEndpoint endpoint;
    private final IRCConnection connection;
    private FilteredIRCEventAdapter listener;
    public IrcConsumer(IrcEndpoint endpoint, Processor processor, IRCConnection connection) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.connection = connection;
        configuration = endpoint.getConfiguration();
    }
    @Override
    protected void doStop() throws Exception {
        String target = endpoint.getConfiguration().getTarget();
        connection.doPart(target);
        connection.removeIRCEventListener(listener);
        super.doStop();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        String target = endpoint.getConfiguration().getTarget();
        connection.addIRCEventListener(new FilteredIRCEventAdapter(target));
        LOG.debug(""joining: "" + target);
        connection.doJoin(target);
    }
    public IRCConnection getConnection() {
        return connection;
    }
    class FilteredIRCEventAdapter extends IRCEventAdapter {
        final String target;
        public FilteredIRCEventAdapter(String target) {
            this.target = target;
        }
        @Override
        public void onNick(IRCUser user, String newNick) {
            if (configuration.isOnNick()) {
                IrcExchange exchange = endpoint.createOnNickExchange(user, newNick);
                try {
                    getProcessor().process(exchange);
                } catch (Exception e) {
                    // TODO: what should we do when a processing failure
                    // occurs??
                    e.printStackTrace();
                }
            }
        }
        @Override
        public void onQuit(IRCUser user, String msg) {
            if (configuration.isOnQuit()) {
                IrcExchange exchange = endpoint.createOnQuitExchange(user, msg);
                try {
                    getProcessor().process(exchange);
                } catch (Exception e) {
                    // TODO: what should we do when a processing failure
                    // occurs??
                    e.printStackTrace();
                }
            }
        }
        @Override
        public void onJoin(String channel, IRCUser user) {
            if (configuration.isOnJoin()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnJoinExchange(channel, user);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onKick(String channel, IRCUser user, String passiveNick, String msg) {
            if (configuration.isOnKick()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnKickExchange(channel, user, passiveNick, msg);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onMode(String channel, IRCUser user, IRCModeParser modeParser) {
            if (configuration.isOnMode()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnModeExchange(channel, user, modeParser);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onPart(String channel, IRCUser user, String msg) {
            if (configuration.isOnPart()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnPartExchange(channel, user, msg);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onTopic(String channel, IRCUser user, String topic) {
            if (configuration.isOnTopic()) {
                if (channel.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnTopicExchange(channel, user, topic);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
        @Override
        public void onPrivmsg(String target, IRCUser user, String msg) {
            if (configuration.isOnPrivmsg()) {
                if (target.equals(configuration.getTarget())) {
                    IrcExchange exchange = endpoint.createOnPrivmsgExchange(target, user, msg);
                    try {
                        getProcessor().process(exchange);
                    } catch (Exception e) {
                        // TODO: what should we do when a processing failure
                        // occurs??
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
"
org.apache.camel.spring.CamelContextFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.model.IdentifiedType;
import org.apache.camel.model.RouteContainer;
import org.apache.camel.model.RouteType;
import org.apache.camel.spi.InstrumentationAgent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import javax.management.MBeanServer;
import javax.xml.bind.annotation.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
/**
 * A Spring {@link FactoryBean} to create and initialize a
 * {@link SpringCamelContext} and install routes either explicitly configured in
 * Spring XML or found by searching the classpath for Java classes which extend
 * {@link RouteBuilder} using the nested {@link #setPackages(String[])}.
 *
 * @version $Revision$
 */
@XmlRootElement(name = ""camelContext"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelContextFactoryBean extends IdentifiedType implements RouteContainer, FactoryBean, InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener {
    private static final Log LOG = LogFactory.getLog(CamelContextFactoryBean.class);
    @XmlElement(name = ""package"", required = false)
    private String[] packages = {};
    @XmlElements({@XmlElement(name = ""beanPostProcessor"", type = CamelBeanPostProcessor.class, required = false), @XmlElement(name = ""proxy"", type = CamelProxyFactoryType.class, required = false),
    @XmlElement(name = ""export"", type = CamelServiceExporterType.class, required = false), @XmlElement(name = ""jmxAgent"", required = false)})
    private List beans;
    @XmlElement(name = ""endpoint"", required = false)
    private List<EndpointFactoryBean> endpoints;
    @XmlElement(name = ""route"", required = false)
    private List<RouteType> routes = new ArrayList<RouteType>();
    @XmlAttribute(required = false)
    private Boolean useJmx;
    @XmlAttribute(required = false)
    private String mbeanServer;
    @XmlTransient
    private SpringCamelContext context;
    @XmlTransient
    private RouteBuilder routeBuilder;
    @XmlTransient
    private List<RouteBuilder> additionalBuilders = new ArrayList<RouteBuilder>();
    @XmlTransient
    private ApplicationContext applicationContext;
    @XmlTransient
    private ClassLoader contextClassLoaderOnStart;
    @XmlTransient
    private InstrumentationAgent instrumentationAgent;
    public CamelContextFactoryBean() {
        // Lets keep track of the class loader for when we actually do start things up
        contextClassLoaderOnStart = Thread.currentThread().getContextClassLoader();
    }
    public Object getObject() throws Exception {
        return getContext();
    }
    public Class getObjectType() {
        return SpringCamelContext.class;
    }
    public boolean isSingleton() {
        return true;
    }
    public void afterPropertiesSet() throws Exception {
        // lets force any lazy creation
        getContext().addRouteDefinitions(routes);
        if (instrumentationAgent == null && isJmxEnabled()) {
            SpringInstrumentationAgent agent = new SpringInstrumentationAgent();
            agent.setCamelContext(getContext());
            String name = getMbeanServer();
            if (name != null) {
                MBeanServer mbeanServer = (MBeanServer) getApplicationContext().getBean(name, MBeanServer.class);
                agent.setMBeanServer(mbeanServer);
            }
            instrumentationAgent = agent;
            instrumentationAgent.start();
        }
        LOG.debug(""Found JAXB created routes: "" + getRoutes());
        findRouteBuiders();
        installRoutes();
    }
    public void destroy() throws Exception {
        getContext().stop();
    }
    public void onApplicationEvent(ApplicationEvent event) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Publishing event: "" + event);
        }
        if (event instanceof ContextRefreshedEvent) {
            // now lets start the CamelContext so that all its possible
            // dependencies are initailized
            try {
                LOG.debug(""Starting the context now!"");
                getContext().start();
            }
            catch (Exception e) {
                throw new RuntimeCamelException(e);
            }
        }
        /*
         * if (context != null) { context.onApplicationEvent(event); }
         */
    }
    // Properties
    // -------------------------------------------------------------------------
    public SpringCamelContext getContext() throws Exception {
        if (context == null) {
            context = createContext();
        }
        return context;
    }
    public void setContext(SpringCamelContext context) {
        this.context = context;
    }
    public List<RouteType> getRoutes() {
        return routes;
    }
    public void setRoutes(List<RouteType> routes) {
        this.routes = routes;
    }
    public RouteBuilder getRouteBuilder() {
        return routeBuilder;
    }
    /**
     * Set a single {@link RouteBuilder} to be used to create the default routes
     * on startup
     */
    public void setRouteBuilder(RouteBuilder routeBuilder) {
        this.routeBuilder = routeBuilder;
    }
    /**
     * Set a collection of {@link RouteBuilder} instances to be used to create
     * the default routes on startup
     */
    public void setRouteBuilders(RouteBuilder[] builders) {
        for (RouteBuilder builder : builders) {
            additionalBuilders.add(builder);
        }
    }
    public ApplicationContext getApplicationContext() {
        if (applicationContext == null) {
            throw new IllegalArgumentException(""No applicationContext has been injected!"");
        }
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public String[] getPackages() {
        return packages;
    }
    /**
     * Sets the package names to be recursively searched for Java classes which
     * extend {@link RouteBuilder} to be auto-wired up to the
     * {@link SpringCamelContext} as a route. Note that classes are excluded if
     * they are specifically configured in the spring.xml
     *
     * @param packages the package names which are recursively searched
     */
    public void setPackages(String[] packages) {
        this.packages = packages;
    }
    public String getMbeanServer() {
        return mbeanServer;
    }
    public void setMbeanServer(String mbeanServer) {
        this.mbeanServer = mbeanServer;
    }
    public boolean isJmxEnabled() {
        return useJmx != null && useJmx.booleanValue();
    }
    public Boolean getUseJmx() {
        return useJmx;
    }
    public void setUseJmx(Boolean useJmx) {
        this.useJmx = useJmx;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * Create the context
     */
    protected SpringCamelContext createContext() {
    	SpringCamelContext ctx = new SpringCamelContext(getApplicationContext());
    	ctx.setName(getId());
    	return ctx;
    }
    /**
     * Strategy to install all available routes into the context
     */
    protected void installRoutes() throws Exception {
        Map builders = getApplicationContext().getBeansOfType(RouteBuilder.class, true, true);
        if (builders != null) {
            for (Object builder : builders.values()) {
                getContext().addRoutes((RouteBuilder) builder);
            }
        }
        for (RouteBuilder routeBuilder : additionalBuilders) {
            getContext().addRoutes(routeBuilder);
        }
        if (routeBuilder != null) {
            getContext().addRoutes(routeBuilder);
        }
    }
    /**
     * Strategy method to try find {@link RouteBuilder} instances on the
     * classpath
     */
    protected void findRouteBuiders() throws Exception, InstantiationException {
        if (packages != null && packages.length > 0) {
            RouteBuilderFinder finder = new RouteBuilderFinder(getContext(), packages, contextClassLoaderOnStart);
            finder.appendBuilders(additionalBuilders);
        }
    }
}
"
org.apache.camel.converter.jaxb.MessageType,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import org.apache.camel.Message;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlMixed;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
/**
 * Represents a JAXB2 representation of a Camel {@link Message}
 *
 * @version $Revision: $
 */
@XmlRootElement(name = ""message"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class MessageType {
    @XmlElementRef(type = HeaderType.class)
    List<HeaderType> headers = new ArrayList<HeaderType>();
    @XmlAnyElement(lax = true)
    @XmlMixed
    private List content = new ArrayList();
    @XmlTransient
    private Object body;
    public Object getBody() {
        if (body == null) {
            if (content != null) {
                if (content.size() == 1) {
                    return content.get(0);
                }
                else {
                    return content;
                }
            }
        }
        return body;
    }
    public void setBody(Object body) {
        this.body = body;
        if (body instanceof List) {
            content = (List) body;
        }
        else {
            content = new ArrayList();
            content.add(body);
        }
    }
    public List<HeaderType> getHeaders() {
        return headers;
    }
    public void setHeaders(List<HeaderType> headers) {
        this.headers = headers;
    }
    public Map<String, Object> getHeaderMap() {
        Map<String, Object> answer = new HashMap<String, Object>();
        for (HeaderType header : headers) {
            answer.put(header.getName(), header.getValue());
        }
        return answer;
    }
    /**
     * Copies the headers and body of this object from the given Camel message
     *
     * @param message the Camel message to read the headers and body from
     */
    public void copyFrom(Message message) {
        headers.clear();
        Set<Map.Entry<String, Object>> entries = message.getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            Object value = entry.getValue();
            if (value != null) {
                headers.add(createHeader(entry.getKey(), value));
            }
        }
        setBody(message.getBody());
    }
    /**
     * Copies the headers and body of this object to the given Camel message
     *
     * @param message the camel message to overwrite its headers and body
     */
    public void copyTo(Message message) {
        message.setHeaders(getHeaderMap());
        message.setBody(getBody());
    }
    protected HeaderType createHeader(String key, Object value) {
        if (value instanceof String) {
            return new StringHeader(key, (String) value);
        }
        else if (value instanceof Integer) {
            return new IntegerHeader(key, (Integer) value);
        }
        else if (value instanceof Long) {
            return new LongHeader(key, (Long) value);
        }
        else {
            // lets convert to a String
            return new StringHeader(key, value.toString());
            //return new ObjectHeader(key, value);
        }
    }
}
"
org.apache.camel.component.file.remote.RemoteFileEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.apache.camel.ExchangePattern;
public abstract class RemoteFileEndpoint<T extends RemoteFileExchange> extends ScheduledPollEndpoint<T> {
    private RemoteFileBinding binding;
    private RemoteFileConfiguration configuration;
    public RemoteFileEndpoint(String uri, RemoteFileComponent component, RemoteFileConfiguration configuration) {
        super(uri, component);
        this.configuration = configuration;
    }
    protected RemoteFileBinding createRemoteFileBinding() {
        return new RemoteFileBinding();
    }
    public T createExchange() {
        return (T) new RemoteFileExchange(getContext(), getExchangePattern(), getBinding());
    }
    public T createExchange(ExchangePattern pattern) {
        return (T) new RemoteFileExchange(getContext(), pattern, getBinding());
    }
    public T createExchange(String fullFileName, ByteArrayOutputStream outputStream) {
        return (T) new RemoteFileExchange(getContext(), getExchangePattern(), getBinding(), getConfiguration().getHost(), fullFileName, outputStream);
    }
    public RemoteFileBinding getBinding() {
        if (binding == null) {
            binding = createRemoteFileBinding();
        }
        return binding;
    }
    public void setBinding(RemoteFileBinding binding) {
        this.binding = binding;
    }
    public boolean isSingleton() {
        return true;
    }
    public RemoteFileConfiguration getConfiguration() {
        return configuration;
    }
}
"
org.apache.camel.component.cxf.CxfConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.net.URI;
import org.apache.camel.Processor;
import org.apache.camel.component.cxf.spring.CxfEndpointBean;
import org.apache.camel.component.cxf.util.CxfEndpointUtils;
import org.apache.camel.component.cxf.util.UriUtils;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.camel.spring.SpringCamelContext;
import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
import org.apache.cxf.endpoint.Server;
import org.apache.cxf.endpoint.ServerImpl;
import org.apache.cxf.frontend.ServerFactoryBean;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.MessageObserver;
/**
 * A consumer of exchanges for a service in CXF
 * 
 * @version $Revision$
 */
public class CxfConsumer extends DefaultConsumer<CxfExchange> {
    private CxfEndpoint endpoint;    
    private Server server;
    public CxfConsumer(CxfEndpoint endpoint, Processor processor) throws Exception {
        super(endpoint, processor);        
        this.endpoint = endpoint;        
        try {
            // now we just use the default bus here   
            Bus bus = BusFactory.getDefaultBus();
            ServerFactoryBean svrBean = null;
            if (endpoint.isSpringContextEndpoint()) {
                CxfEndpointBean endpointBean = endpoint.getCxfEndpointBean();
                svrBean = CxfEndpointUtils.getServerFactoryBean(endpointBean.getServiceClass());
                endpoint.configure(svrBean);
                //Need to set the service name and endpoint name to the ClientFactoryBean's service factory
                // to walk around the issue of setting EndpointName and ServiceName
                CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();
                if (cxfEndpointBean.getServiceName() != null) {
                    svrBean.getServiceFactory().setServiceName(cxfEndpointBean.getServiceName());
                } 
                if (cxfEndpointBean.getEndpointName() != null) {
                    svrBean.getServiceFactory().setEndpointName(cxfEndpointBean.getEndpointName());
                } 
            } else { // setup the serverFactoryBean with the URI paraments           
                Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass()); 
                svrBean = CxfEndpointUtils.getServerFactoryBean(serviceClass);                           
                svrBean.setAddress(endpoint.getAddress());
                svrBean.setServiceClass(serviceClass);
                if (endpoint.getServiceName() != null) {
                    svrBean.getServiceFactory().setServiceName(CxfEndpointUtils.getServiceName(endpoint));                
                }
                if (endpoint.getPortName() != null) {
                    svrBean.getServiceFactory().setEndpointName(CxfEndpointUtils.getPortName(endpoint));
                }    
                if (endpoint.getWsdlURL() != null) {                
                    svrBean.setWsdlURL(endpoint.getWsdlURL());
                }
            }
            DataFormat dataFormat = CxfEndpointUtils.getDataFormat(endpoint);
            if (dataFormat.equals(DataFormat.POJO)) {
                svrBean.setInvoker(new CamelInvoker(this));
            }
            svrBean.setBus(bus);
            svrBean.setStart(false);
            server = svrBean.create();            
            if (!dataFormat.equals(DataFormat.POJO)) {
                CxfMessageObserver observer = new CxfMessageObserver(this, server.getEndpoint(), bus , dataFormat);
                //set the message observer for the Message and PayLoad mode message 
                ServerImpl serverImpl = (ServerImpl)server;
                serverImpl.setMessageObserver(observer);
            } 
        } catch (Exception ex) {
            // create Consumer endpoint failed
            ex.printStackTrace();
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();        
        server.start();
    }
    @Override
    protected void doStop() throws Exception {
        server.stop();
        super.doStop();
    }
    public CxfEndpoint getEndpoint() {
        return endpoint;
    }
}
"
org.apache.camel.component.mail.MailProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.internet.MimeMessage;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessagePreparator;
/**
 * @version $Revision: 525547 $
 */
public class MailProducer extends DefaultProducer<MailExchange> {
    private static final transient Log LOG = LogFactory.getLog(MailProducer.class);
    private final MailEndpoint endpoint;
    private final JavaMailSender sender;
    public MailProducer(MailEndpoint endpoint, JavaMailSender sender) {
        super(endpoint);
        this.endpoint = endpoint;
        this.sender = sender;
    }
    public void process(final Exchange exchange) {
        sender.send(new MimeMessagePreparator() {
            public void prepare(MimeMessage mimeMessage) throws Exception {
                endpoint.getBinding().populateMailMessage(endpoint, mimeMessage, exchange);
            }
        });
    }
}
"
org.apache.camel.component.cxf.CxfSoapComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.CamelContextHelper;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.camel.util.URISupport;
import java.util.Map;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/cxf.html"">SOAP Component</a>
 *
 * @version $Revision: 576522 $
 */
public class CxfSoapComponent extends DefaultComponent {
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        Map soapProps = IntrospectionSupport.extractProperties(parameters, ""soap."");
        if (parameters.size() > 0) {
            remaining += ""?"" + URISupport.createQueryString(parameters);
        }
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(getCamelContext(), remaining);
        CxfSoapEndpoint soapEndpoint = new CxfSoapEndpoint(endpoint);
        setProperties(soapEndpoint, soapProps);
        soapEndpoint.init();
        return soapEndpoint;
    }
}
"
org.apache.camel.component.cxf.invoker.CxfClientFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import javax.xml.ws.soap.SOAPBinding;
import org.apache.cxf.BusException;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.endpoint.ClientImpl;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.endpoint.EndpointException;
import org.apache.cxf.frontend.ClientFactoryBean;
import org.apache.cxf.jaxws.binding.soap.JaxWsSoapBindingConfiguration;
import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
import org.apache.cxf.service.factory.ServiceConstructionException;
public class CxfClientFactoryBean extends ClientFactoryBean {
    private boolean isJSR181Enabled;
    public CxfClientFactoryBean() {
        super();        
    }
    public void setJSR181Enabled(boolean enabled) {
        if (enabled) {
            setServiceFactory(new JaxWsServiceFactoryBean());            
        } else {
            setServiceFactory(new ReflectionServiceFactoryBean());
        }
        isJSR181Enabled = enabled;
    }
    @Override
    public void setBindingId(String bind) {
        super.setBindingId(bind);
        if (isJSR181Enabled) {
            if (SOAPBinding.SOAP11HTTP_BINDING.equals(bind)
                || SOAPBinding.SOAP12HTTP_BINDING.equals(bind)) {
                setBindingConfig(new JaxWsSoapBindingConfiguration((JaxWsServiceFactoryBean)getServiceFactory()));
            } else if (SOAPBinding.SOAP11HTTP_MTOM_BINDING.equals(bind)
                || SOAPBinding.SOAP12HTTP_MTOM_BINDING.equals(bind)) {
                setBindingConfig(new JaxWsSoapBindingConfiguration((JaxWsServiceFactoryBean)getServiceFactory()));
                ((JaxWsSoapBindingConfiguration)getBindingConfig()).setMtomEnabled(true);
            }
        }    
    }
    protected void createClient(Endpoint ep) {
        CxfClient client = new CxfClient(getBus(), ep);
        setClient(client);
    }
}
"
org.apache.camel.component.file.remote.RemoteFileExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
public class RemoteFileExchange<T extends RemoteFileBinding> extends DefaultExchange {
    private T binding;
    public RemoteFileExchange(CamelContext context, ExchangePattern pattern, T binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public RemoteFileExchange(CamelContext context, ExchangePattern pattern, T binding, String host, String fullFileName, ByteArrayOutputStream outputStream) {
        this(context, pattern, binding);
        setIn(new RemoteFileMessage(host, fullFileName, outputStream));
    }
    public T getBinding() {
        return binding;
    }
    public void setBinding(T binding) {
        this.binding = binding;
    }
}
"
org.apache.camel.component.event.CamelEvent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import org.apache.camel.Exchange;
import org.springframework.context.ApplicationEvent;
/**
 * Represents a Spring {@link ApplicationEvent} which contains a Camel {@link Exchange}
 *
 * @version $Revision: 1.1 $
 */
public class CamelEvent extends ApplicationEvent {
    private final Exchange exchange;
    public CamelEvent(EventEndpoint source, Exchange exchange) {
        super(source);
        this.exchange = exchange;
    }
    @Override
    public EventEndpoint getSource() {
        return (EventEndpoint) super.getSource();
    }
    /**
     * Returns the message exchange
     *
     * @return the camel message exchange
     */
    public Exchange getExchange() {
        return exchange;
    }
}
"
org.apache.camel.component.jms.JmsComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import static org.apache.camel.util.ObjectHelper.removeStartingCharacters;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.listener.serversession.ServerSessionFactory;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.jms.connection.JmsTransactionManager;
import org.springframework.jms.core.JmsOperations;
import org.springframework.transaction.PlatformTransactionManager;
import javax.jms.ConnectionFactory;
import javax.jms.ExceptionListener;
import javax.jms.Session;
import java.util.Map;
/**
 * A <a href=""http://activemq.apache.org/jms.html"">JMS Component</a>
 * 
 * @version $Revision:520964 $
 */
public class JmsComponent extends DefaultComponent<JmsExchange> implements ApplicationContextAware {
    public static final String QUEUE_PREFIX = ""queue:"";
    public static final String TOPIC_PREFIX = ""topic:"";
    private JmsConfiguration configuration;
	private ApplicationContext applicationContext;
    public JmsComponent() {
    }
    public JmsComponent(JmsConfiguration configuration) {
        this.configuration = configuration;
    }
    public JmsComponent(CamelContext context) {
        super(context);
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent() {
        return new JmsComponent();
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent(JmsConfiguration configuration) {
        return new JmsComponent(configuration);
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponent(ConnectionFactory connectionFactory) {
        return jmsComponent(new JmsConfiguration(connectionFactory));
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponentClientAcknowledge(ConnectionFactory connectionFactory) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setAcknowledgementMode(Session.CLIENT_ACKNOWLEDGE);
        return jmsComponent(template);
    }
    /**
     * Static builder method
     */
    public static JmsComponent jmsComponentAutoAcknowledge(ConnectionFactory connectionFactory) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setAcknowledgementMode(Session.AUTO_ACKNOWLEDGE);
        return jmsComponent(template);
    }
    public static JmsComponent jmsComponentTransacted(ConnectionFactory connectionFactory) {
        JmsTransactionManager transactionManager = new JmsTransactionManager();
        transactionManager.setConnectionFactory(connectionFactory);
        return jmsComponentTransacted(connectionFactory, transactionManager);
    }
    public static JmsComponent jmsComponentTransacted(ConnectionFactory connectionFactory, PlatformTransactionManager transactionManager) {
        JmsConfiguration template = new JmsConfiguration(connectionFactory);
        template.setTransactionManager(transactionManager);
        template.setTransacted(true);
        return jmsComponent(template);
    }
    @Override
    protected Endpoint<JmsExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        boolean pubSubDomain = false;
        if (remaining.startsWith(QUEUE_PREFIX)) {
            pubSubDomain = false;
            remaining = removeStartingCharacters(remaining.substring(QUEUE_PREFIX.length()), '/');
        } else if (remaining.startsWith(TOPIC_PREFIX)) {
            pubSubDomain = true;
            remaining = removeStartingCharacters(remaining.substring(TOPIC_PREFIX.length()), '/');
        }
        final String subject = convertPathToActualDestination(remaining);
        // lets make sure we copy the configuration as each endpoint can
        // customize its own version
        JmsEndpoint endpoint = new JmsEndpoint(uri, this, subject, pubSubDomain, getConfiguration().copy());
        String selector = (String)parameters.remove(""selector"");
        if (selector != null) {
            endpoint.setSelector(selector);
        }
        setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    public JmsConfiguration getConfiguration() {
        if (configuration == null) {
            configuration = createConfiguration();
            // If we are being configured with spring... 
            if( applicationContext !=null ) {
            	Map beansOfType = applicationContext.getBeansOfType(ConnectionFactory.class);
            	if( !beansOfType.isEmpty() ) { 
            		ConnectionFactory cf = (ConnectionFactory) beansOfType.values().iterator().next();
            		configuration.setConnectionFactory(cf);
            	}
                beansOfType = applicationContext.getBeansOfType(DestinationResolver.class);
                if( !beansOfType.isEmpty() ) { 
                    DestinationResolver destinationResolver = (DestinationResolver) beansOfType.values().iterator().next();
                        configuration.setDestinationResolver(destinationResolver);
                }
            }
        }
        return configuration;
    }
    /**
     * Sets the JMS configuration
     * 
     * @param configuration the configuration to use by default for endpoints
     */
    public void setConfiguration(JmsConfiguration configuration) {
        this.configuration = configuration;
    }
    public void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping) {
        getConfiguration().setAcceptMessagesWhileStopping(acceptMessagesWhileStopping);
    }
    public void setAcknowledgementMode(int consumerAcknowledgementMode) {
        getConfiguration().setAcknowledgementMode(consumerAcknowledgementMode);
    }
    public void setAcknowledgementModeName(String consumerAcknowledgementMode) {
        getConfiguration().setAcknowledgementModeName(consumerAcknowledgementMode);
    }
    public void setAutoStartup(boolean autoStartup) {
        getConfiguration().setAutoStartup(autoStartup);
    }
    public void setCacheLevel(int cacheLevel) {
        getConfiguration().setCacheLevel(cacheLevel);
    }
    public void setCacheLevelName(String cacheName) {
        getConfiguration().setCacheLevelName(cacheName);
    }
    public void setClientId(String consumerClientId) {
        getConfiguration().setClientId(consumerClientId);
    }
    public void setConcurrentConsumers(int concurrentConsumers) {
        getConfiguration().setConcurrentConsumers(concurrentConsumers);
    }
    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        getConfiguration().setConnectionFactory(connectionFactory);
    }
    public void setConsumerType(ConsumerType consumerType) {
        getConfiguration().setConsumerType(consumerType);
    }
    public void setDeliveryPersistent(boolean deliveryPersistent) {
        getConfiguration().setDeliveryPersistent(deliveryPersistent);
    }
    public void setDurableSubscriptionName(String durableSubscriptionName) {
        getConfiguration().setDurableSubscriptionName(durableSubscriptionName);
    }
    public void setExceptionListener(ExceptionListener exceptionListener) {
        getConfiguration().setExceptionListener(exceptionListener);
    }
    public void setExplicitQosEnabled(boolean explicitQosEnabled) {
        getConfiguration().setExplicitQosEnabled(explicitQosEnabled);
    }
    public void setExposeListenerSession(boolean exposeListenerSession) {
        getConfiguration().setExposeListenerSession(exposeListenerSession);
    }
    public void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {
        getConfiguration().setIdleTaskExecutionLimit(idleTaskExecutionLimit);
    }
    public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
        getConfiguration().setMaxConcurrentConsumers(maxConcurrentConsumers);
    }
    public void setMaxMessagesPerTask(int maxMessagesPerTask) {
        getConfiguration().setMaxMessagesPerTask(maxMessagesPerTask);
    }
    public void setMessageConverter(MessageConverter messageConverter) {
        getConfiguration().setMessageConverter(messageConverter);
    }
    public void setMessageIdEnabled(boolean messageIdEnabled) {
        getConfiguration().setMessageIdEnabled(messageIdEnabled);
    }
    public void setMessageTimestampEnabled(boolean messageTimestampEnabled) {
        getConfiguration().setMessageTimestampEnabled(messageTimestampEnabled);
    }
    public void setPriority(int priority) {
        getConfiguration().setPriority(priority);
    }
    public void setPubSubNoLocal(boolean pubSubNoLocal) {
        getConfiguration().setPubSubNoLocal(pubSubNoLocal);
    }
    public void setReceiveTimeout(long receiveTimeout) {
        getConfiguration().setReceiveTimeout(receiveTimeout);
    }
    public void setRecoveryInterval(long recoveryInterval) {
        getConfiguration().setRecoveryInterval(recoveryInterval);
    }
    public void setServerSessionFactory(ServerSessionFactory serverSessionFactory) {
        getConfiguration().setServerSessionFactory(serverSessionFactory);
    }
    public void setSubscriptionDurable(boolean subscriptionDurable) {
        getConfiguration().setSubscriptionDurable(subscriptionDurable);
    }
    public void setTaskExecutor(TaskExecutor taskExecutor) {
        getConfiguration().setTaskExecutor(taskExecutor);
    }
    public void setTimeToLive(long timeToLive) {
        getConfiguration().setTimeToLive(timeToLive);
    }
    public void setTransacted(boolean consumerTransacted) {
        getConfiguration().setTransacted(consumerTransacted);
    }
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        getConfiguration().setTransactionManager(transactionManager);
    }
    public void setTransactionName(String transactionName) {
        getConfiguration().setTransactionName(transactionName);
    }
    public void setTransactionTimeout(int transactionTimeout) {
        getConfiguration().setTransactionTimeout(transactionTimeout);
    }
    public void setUseVersion102(boolean useVersion102) {
        getConfiguration().setUseVersion102(useVersion102);
    }
    public void setJmsOperations(JmsOperations jmsOperations) {
        getConfiguration().setJmsOperations(jmsOperations);
    }
    public void setDestinationResolver(DestinationResolver destinationResolver) {
        getConfiguration().setDestinationResolver(destinationResolver);
    }
    /**
     * A strategy method allowing the URI destination to be translated into the
     * actual JMS destination name (say by looking up in JNDI or something)
     */
    protected String convertPathToActualDestination(String path) {
        return path;
    }
    /**
     * Factory method to create the default configuration instance
     * 
     * @return a newly created configuration object which can then be further
     *         customized
     */
    protected JmsConfiguration createConfiguration() {
        return new JmsConfiguration();
    }
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		this.applicationContext = applicationContext;
	}
}
"
org.apache.camel.component.cxf.spring.NamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.camel.component.cxf.spring;
import org.apache.cxf.configuration.spring.StringBeanDefinitionParser;
import org.apache.cxf.frontend.spring.ServerFactoryBeanDefinitionParser;
import org.apache.cxf.jaxws.JaxWsServerFactoryBean;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
public class NamespaceHandler extends NamespaceHandlerSupport {
    public void init() {
        registerBeanDefinitionParser(""cxfEndpoint"", new CxfEndpointBeanDefinitionParser());      
    }
}
"
org.apache.camel.component.xmpp.XmppComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.net.URI;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
/**
 * @version $Revision:520964 $
 */
public class XmppComponent extends DefaultComponent<XmppExchange> {
    public XmppComponent() {
    }
    public XmppComponent(CamelContext context) {
        super(context);
    }
    /**
     * Static builder method
     */
    public static XmppComponent xmppComponent() {
        return new XmppComponent();
    }
    @Override
    protected Endpoint<XmppExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        XmppEndpoint endpoint = new XmppEndpoint(uri, this);
        URI u = new URI(uri);
        endpoint.setHost(u.getHost());
        endpoint.setPort(u.getPort());
        if (u.getUserInfo() != null) {
            endpoint.setUser(u.getUserInfo());
        }
        String remainingPath = u.getPath();
        if (remainingPath != null) {
            if (remainingPath.startsWith(""/"")) {
                remainingPath = remainingPath.substring(1);
            }
            // assume its a participant
            if (remainingPath.length() > 0) {
                endpoint.setParticipant(remainingPath);
            }
        }
        return endpoint;
    }
}
"
org.apache.camel.component.irc.IrcExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
public class IrcExchange extends DefaultExchange {
    private IrcBinding binding;
    public IrcExchange(CamelContext context, ExchangePattern pattern, IrcBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public IrcExchange(CamelContext context, ExchangePattern pattern, IrcBinding binding, IrcMessage inMessage) {
        this(context, pattern, binding);
        setIn(inMessage);
    }
    public IrcBinding getBinding() {
        return binding;
    }
    public void setBinding(IrcBinding binding) {
        this.binding = binding;
    }
    @Override
    public IrcMessage getIn() {
        return (IrcMessage) super.getIn();
    }
    @Override
    public IrcMessage getOut() {
        return (IrcMessage) super.getOut();
    }
    @Override
    public IrcMessage getOut(boolean lazyCreate) {
        return (IrcMessage) super.getOut(lazyCreate);
    }
    @Override
    public IrcMessage getFault() {
        return (IrcMessage) super.getFault();
    }
    @Override
    public IrcExchange newInstance() {
        return new IrcExchange(getContext(), getPattern(), getBinding());
    }
    @Override
    protected IrcMessage createInMessage() {
        return new IrcMessage();
    }
    @Override
    protected IrcMessage createOutMessage() {
        return new IrcMessage();
    }
}
"
org.apache.camel.spring.spi.TransactionInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.processor.DelegateProcessor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * @version $Revision: 1.1 $
 */
public class TransactionInterceptor extends DelegateProcessor {
    private static final transient Log LOG = LogFactory.getLog(TransactionInterceptor.class);
    private final TransactionTemplate transactionTemplate;
    public TransactionInterceptor(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }
    public void process(final Exchange exchange) {
        LOG.info(""transaction begin"");
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                try {
                    processNext(exchange);
                } catch (Exception e) {
                    throw new RuntimeCamelException(e);
                }
            }
        });
        LOG.info(""transaction commit"");
    }
    @Override
    public String toString() {
        return ""TransactionInterceptor:"" + propagationBehaviorToString(transactionTemplate.getPropagationBehavior()) + ""["" + getProcessor() + ""]"";
    }
    private String propagationBehaviorToString(int propagationBehavior) {
        String rc;
        switch (propagationBehavior) {
        case TransactionDefinition.PROPAGATION_MANDATORY:
            rc = ""PROPAGATION_MANDATORY"";
            break;
        case TransactionDefinition.PROPAGATION_NESTED:
            rc = ""PROPAGATION_NESTED"";
            break;
        case TransactionDefinition.PROPAGATION_NEVER:
            rc = ""PROPAGATION_NEVER"";
            break;
        case TransactionDefinition.PROPAGATION_NOT_SUPPORTED:
            rc = ""PROPAGATION_NOT_SUPPORTED"";
            break;
        case TransactionDefinition.PROPAGATION_REQUIRED:
            rc = ""PROPAGATION_REQUIRED"";
            break;
        case TransactionDefinition.PROPAGATION_REQUIRES_NEW:
            rc = ""PROPAGATION_REQUIRES_NEW"";
            break;
        case TransactionDefinition.PROPAGATION_SUPPORTS:
            rc = ""PROPAGATION_SUPPORTS"";
            break;
        default:
            rc = ""UNKOWN""; 
        }
        return rc;
    }
}
"
org.apache.camel.spring.util.ReflectionUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
public class ReflectionUtils extends org.springframework.util.ReflectionUtils {
    public static <T extends Annotation> void callLifecycleMethod(final Object bean, final Class<T> annotation) {
        ReflectionUtils.doWithMethods(bean.getClass(), new ReflectionUtils.MethodCallback() {
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                if (method.getAnnotation(annotation) != null) {
                    try {
                        method.invoke(bean, (Object[])null);
                    } catch (IllegalArgumentException ex) {
                        throw new IllegalStateException(""Failure to invoke "" + method + "" on "" + bean.getClass() + "": args=[]"", ex);
                    } catch (IllegalAccessException ex) {
                        throw new UnsupportedOperationException(ex.toString());
                    } catch (InvocationTargetException ex) {
                        throw new UnsupportedOperationException(""PostConstruct method on bean threw exception"", ex.getTargetException());
                    }
                }
            }
        });
    }
    public static void setField(Field f, Object instance, Object value) {
        try {
            boolean oldAccessible = f.isAccessible();
            boolean shouldSetAccessible = !Modifier.isPublic(f.getModifiers()) && !oldAccessible;
            if (shouldSetAccessible) {
                f.setAccessible(true);
            }
            f.set(instance, value);
            if (shouldSetAccessible) {
                f.setAccessible(oldAccessible);
            }
        } catch (IllegalArgumentException ex) {
            throw new UnsupportedOperationException(""Cannot inject value of class '"" + value.getClass() + ""' into "" + f);
        } catch (IllegalAccessException ex) {
            ReflectionUtils.handleReflectionException(ex);
        }
    }
}
"
org.apache.camel.component.cxf.interceptors.RawMessageContentRedirectInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.io.InputStream;
import java.io.OutputStream;
import org.apache.commons.io.IOUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
public class RawMessageContentRedirectInterceptor extends AbstractPhaseInterceptor<Message> {
    public RawMessageContentRedirectInterceptor() {
        super(Phase.WRITE);        
    }
    public void handleMessage(Message message) throws Fault {
        InputStream is = message.getContent(InputStream.class);
        OutputStream os = message.getContent(OutputStream.class);
        try {            
            IOUtils.copy(is, os);
            is.close();
            os.flush();
        } catch (Exception e) {
            throw new Fault(e);
        }
    }
}
"
org.apache.camel.component.cxf.interceptors.XMLMessageInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.apache.cxf.binding.xml.XMLConstants;
import org.apache.cxf.binding.xml.XMLFault;
import org.apache.cxf.bindings.xformat.XMLBindingMessageFormat;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.MessagePartInfo;
import org.apache.cxf.staxutils.StaxUtils;
public class XMLMessageInInterceptor extends AbstractMessageInInterceptor<XMLMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(XMLMessageInInterceptor.class);
    public XMLMessageInInterceptor() {
        super(Phase.READ);        
    }
    protected Logger getLogger() {
        return LOG;
    }
    protected boolean isFaultMessage(XMLMessage message) {
        XMLStreamReader xsr = message.getContent(XMLStreamReader.class);
        boolean isFault = false;
        try {
            if (StaxUtils.skipToStartOfElement(xsr)) {
                QName startQName = xsr.getName();
                isFault = XMLConstants.NS_XML_FORMAT.equals(startQName.getNamespaceURI())
                          && XMLFault.XML_FAULT_ROOT.equals(startQName.getLocalPart());
            }
        } catch (XMLStreamException xse) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""STAX_READ_EXC"", LOG));
        }
        return isFault;
    }
    protected BindingOperationInfo getBindingOperation(XMLMessage message, Document doc) {
        Exchange ex = message.getExchange();
        BindingInfo binding = ex.get(BindingInfo.class);
        if (binding == null) {
            Endpoint ep = ex.get(Endpoint.class);
            binding = ep.getEndpointInfo().getBinding();
        }
        //TODO if binding is null throw exception.
        Element payloadEl = (Element)doc.getChildNodes().item(0);
        QName startQName = new QName(payloadEl.getNamespaceURI(), payloadEl.getLocalName());
        // handling xml normal inbound message
        boolean client = isRequestor(message);
        List<BindingOperationInfo> boiList = new ArrayList<BindingOperationInfo>();
        for (BindingOperationInfo boi : binding.getOperations()) {
            BindingMessageInfo bmi = client ?  boi.getOutput() : boi.getInput();
            QName rootName = null;
            if (bmi != null) {
                XMLBindingMessageFormat msgFormat =
                    bmi.getExtensor(XMLBindingMessageFormat.class);
                if (msgFormat != null) {
                    rootName = msgFormat.getRootNode();
                } else {
                    Collection<MessagePartInfo> bodyParts = bmi.getMessageParts();
                    if (bodyParts.size() == 1) {
                        MessagePartInfo p = bodyParts.iterator().next();
                        rootName = p.getConcreteName();
                    }
                }
            }
            if (startQName.equals(rootName)) {
                boiList.add(boi);
            }
        }
        BindingOperationInfo match = null;
        if (boiList.size() > 1) {
            if (LOG.isLoggable(Level.INFO)) {
                LOG.info(""Mulitple matching BindingOperationIno found in Binding."");
            }
        } else if (!boiList.isEmpty()) {
            match = boiList.get(0);
        }
        return match; 
    }
    protected List<Element> getPartList(XMLMessage inMessage, Element rootNode, BindingMessageInfo bmi) {
        List<Element> partList = new ArrayList<Element>();
        XMLBindingMessageFormat msgFormat =
            bmi.getExtensor(XMLBindingMessageFormat.class);
        if (msgFormat != null) {
            NodeList nodeList = rootNode.getChildNodes();
            for (int idx = 0; idx < nodeList.getLength(); idx++) {
                partList.add((Element)nodeList.item(idx));
            }
        } else {
            partList.add(rootNode);
        }
        return partList;
    }
    protected Element getHeader(XMLMessage inMessage) {
        return null;
    }
}
"
org.apache.camel.component.irc.IrcConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import java.net.URI;
import org.apache.camel.RuntimeCamelException;
public class IrcConfiguration implements Cloneable {
    String target;
    String hostname;
    String password;
    String nickname;
    String realname;
    String username;
    boolean persistent = true;
    boolean colors = true;
    boolean onNick = true;
    boolean onQuit = true;
    boolean onJoin = true;
    boolean onKick = true;
    boolean onMode = true;
    boolean onPart = true;
    boolean onTopic = true;
    boolean onPrivmsg = true;
    int[] ports = {6667, 6668, 6669};
    public IrcConfiguration() {
    }
    public IrcConfiguration(String hostname, String nickname, String displayname, String target) {
        this.target = target;
        this.hostname = hostname;
        this.nickname = nickname;
        this.username = nickname;
        this.realname = displayname;
    }
    public IrcConfiguration(String hostname, String username, String password, String nickname, String displayname, String target) {
        this.target = target;
        this.hostname = hostname;
        this.username = username;
        this.password = password;
        this.nickname = nickname;
        this.realname = displayname;
    }
    public IrcConfiguration copy() {
        try {
            return (IrcConfiguration)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public String getCacheKey() {
        return hostname + "":"" + nickname;
    }
    public void configure(URI uri) {
        setNickname(uri.getUserInfo());
        setUsername(uri.getUserInfo());
        setRealname(uri.getUserInfo());
        setHostname(uri.getHost());
        setTarget(uri.getPath().substring(1));
    }
    public String getHostname() {
        return hostname;
    }
    public void setHostname(String hostname) {
        this.hostname = hostname;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getNickname() {
        return nickname;
    }
    public void setNickname(String nickname) {
        this.nickname = nickname;
    }
    public String getRealname() {
        return realname;
    }
    public void setRealname(String realname) {
        this.realname = realname;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public int[] getPorts() {
        return ports;
    }
    public void setPorts(int[] ports) {
        this.ports = ports;
    }
    public String getTarget() {
        return target;
    }
    public void setTarget(String target) {
        this.target = target;
    }
    public boolean isPersistent() {
        return persistent;
    }
    public void setPersistent(boolean persistent) {
        this.persistent = persistent;
    }
    public boolean isColors() {
        return colors;
    }
    public void setColors(boolean colors) {
        this.colors = colors;
    }
    public boolean isOnNick() {
        return onNick;
    }
    public void setOnNick(boolean onNick) {
        this.onNick = onNick;
    }
    public boolean isOnQuit() {
        return onQuit;
    }
    public void setOnQuit(boolean onQuit) {
        this.onQuit = onQuit;
    }
    public boolean isOnJoin() {
        return onJoin;
    }
    public void setOnJoin(boolean onJoin) {
        this.onJoin = onJoin;
    }
    public boolean isOnKick() {
        return onKick;
    }
    public void setOnKick(boolean onKick) {
        this.onKick = onKick;
    }
    public boolean isOnMode() {
        return onMode;
    }
    public void setOnMode(boolean onMode) {
        this.onMode = onMode;
    }
    public boolean isOnPart() {
        return onPart;
    }
    public void setOnPart(boolean onPart) {
        this.onPart = onPart;
    }
    public boolean isOnTopic() {
        return onTopic;
    }
    public void setOnTopic(boolean onTopic) {
        this.onTopic = onTopic;
    }
    public boolean isOnPrivmsg() {
        return onPrivmsg;
    }
    public void setOnPrivmsg(boolean onPrivmsg) {
        this.onPrivmsg = onPrivmsg;
    }
    public String toString() {
        return ""IrcConfiguration{"" + ""target='"" + target + '\'' + "", hostname='"" + hostname + '\'' + "", password='"" + password + '\'' + "", nickname='"" + nickname + '\'' + "", realname='"" + realname
               + '\'' + "", username='"" + username + '\'' + "", persistent="" + persistent + "", colors="" + colors + "", onNick="" + onNick + "", onQuit="" + onQuit + "", onJoin="" + onJoin + "", onKick=""
               + onKick + "", onMode="" + onMode + "", onPart="" + onPart + "", onTopic="" + onTopic + "", onPrivmsg="" + onPrivmsg + "", ports="" + ports + '}';
    }
}
"
org.apache.camel.language.ognl.OGNL,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import org.apache.camel.language.LanguageAnnotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation for injection of <a href=""http://www.ognl.org/"">OGNL</a> expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""ognl"")
public @interface OGNL {
    public abstract String value();
}"
org.apache.camel.component.mail.MailEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.Folder;
import javax.mail.Message;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.ScheduledPollEndpoint;
import org.springframework.mail.javamail.JavaMailSender;
/**
 * @version $Revision:520964 $
 */
public class MailEndpoint extends ScheduledPollEndpoint<MailExchange> {
    private MailBinding binding;
    private MailConfiguration configuration;
    public MailEndpoint(String uri, MailComponent component, MailConfiguration configuration) {
        super(uri, component);
        this.configuration = configuration;
    }
    public Producer<MailExchange> createProducer() throws Exception {
        JavaMailSender sender = configuration.createJavaMailConnection(this);
        return createProducer(sender);
    }
    /**
     * Creates a producer using the given sender
     */
    public Producer<MailExchange> createProducer(JavaMailSender sender) throws Exception {
        return new MailProducer(this, sender);
    }
    public Consumer<MailExchange> createConsumer(Processor processor) throws Exception {
        JavaMailConnection connection = configuration.createJavaMailConnection(this);
        String protocol = getConfiguration().getProtocol();
        if (protocol.equals(""smtp"")) {
            protocol = ""pop3"";
        }
        String folderName = getConfiguration().getFolderName();
        Folder folder = connection.getFolder(protocol, folderName);
        if (folder == null) {
            throw new IllegalArgumentException(""No folder for protocol: "" + protocol + "" and name: "" + folderName);
        }
        return createConsumer(processor, folder);
    }
    /**
     * Creates a consumer using the given processor and transport
     * 
     * @param processor the processor to use to process the messages
     * @param folder the JavaMail Folder to use for inbound messages
     * @return a newly created consumer
     * @throws Exception if the consumer cannot be created
     */
    public Consumer<MailExchange> createConsumer(Processor processor, Folder folder) throws Exception {
        MailConsumer answer = new MailConsumer(this, processor, folder);
        configureConsumer(answer);
        return answer;
    }
    @Override
    public MailExchange createExchange(ExchangePattern pattern) {
        return new MailExchange(getContext(), pattern, getBinding());
    }
    public MailExchange createExchange(Message message) {
        return new MailExchange(getContext(), getExchangePattern(), getBinding(), message);
    }
    // Properties
    // -------------------------------------------------------------------------
    public MailBinding getBinding() {
        if (binding == null) {
            binding = new MailBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a Mail
     * message
     * 
     * @param binding the binding to use
     */
    public void setBinding(MailBinding binding) {
        this.binding = binding;
    }
    public boolean isSingleton() {
        return false;
    }
    public MailConfiguration getConfiguration() {
        return configuration;
    }
}
"
org.apache.camel.spring.handler.BeanDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import org.w3c.dom.Element;
import org.springframework.beans.factory.xml.AbstractSimpleBeanDefinitionParser;
/**
 * A base class for a parser for a bean.
 *
 * @version $Revision: 1.1 $
 */
public class BeanDefinitionParser extends AbstractSimpleBeanDefinitionParser {
    private Class type;
    protected BeanDefinitionParser() {
    }
    public BeanDefinitionParser(Class type) {
        this.type = type;
    }
    protected Class getBeanClass(Element element) {
        if (type == null) {
            type = loadType();
        }
        return type;
    }
    protected Class loadType() {
        throw new IllegalArgumentException(""No type specified!"");
    }
    @Override
    protected boolean isEligibleAttribute(String attributeName) {
        return attributeName != null && super.isEligibleAttribute(attributeName) && !attributeName.equals(""xmlns"");
    }
}"
org.apache.camel.component.cxf.CxfMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
/**
 * An Apache CXF {@link Message} which provides access to the underlying CXF
 * features
 * 
 * @version $Revision$
 */
public class CxfMessage extends DefaultMessage {
    private Message cxfMessage;
    public CxfMessage() {
        this(new MessageImpl());
    }
    public CxfMessage(Message cxfMessage) {
        if (cxfMessage == null) {
            this.cxfMessage = new MessageImpl();
        }
        this.cxfMessage = cxfMessage;
    }
    @Override
    public String toString() {
        if (cxfMessage != null) {
            return ""CxfMessage: "" + cxfMessage;
        } else {
            return ""CxfMessage: "" + getBody();
        }
    }
    @Override
    public CxfExchange getExchange() {
        return (CxfExchange)super.getExchange();
    }
    /**
     * Returns the underlying CXF message
     * 
     * @return the CXF message
     */
    public Message getMessage() {
        return cxfMessage;
    }
    public void setMessage(Message cxfMessage) {
        this.cxfMessage = cxfMessage;
    }
    public Object getHeader(String name) {
        return cxfMessage.get(name);
    }
    @Override
    public void setHeader(String name, Object value) {
        cxfMessage.put(name, value);
    }
    @Override
    public Map<String, Object> getHeaders() {
        return cxfMessage;
    }
    @Override
    public CxfMessage newInstance() {
        return new CxfMessage();
    }
    @Override
    protected Object createBody() {
        return getExchange().getBinding().extractBodyFromCxf(getExchange(), cxfMessage);
    }
}
"
org.apache.camel.converter.jaxb.HeaderType,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import org.apache.camel.Message;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;
/**
 * Represents a JAXB2 representation of a Camel {@link Message} header
 *
 * @version $Revision: 1.1 $
 */
@XmlType(name = ""headerType"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public abstract class HeaderType {
    @XmlAttribute
    private String name;
    public HeaderType() {
    }
    protected HeaderType(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public abstract Object getValue();
    public abstract void setValue(Object value);
}"
org.apache.camel.component.jms.MessagePropertyNamesAccessException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class MessagePropertyNamesAccessException extends RuntimeJmsException {
    private static final long serialVersionUID = -6744171518099741324L;
    public MessagePropertyNamesAccessException(JMSException e) {
        super(""Failed to access the JMS message property names: "" + e, e);
    }
}
"
org.apache.camel.bam.processor.NoCorrelationKeyException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.CamelExchangeException;
import org.apache.camel.Exchange;
/**
 * An exception thrown if no correlation key could be found for a message
 * exchange preventing any particular orchestration or
 * <a href=""http://activemq.apache.org/camel/bam.html"">BAM</a>
 *
 * @version $Revision: $
 */
public class NoCorrelationKeyException extends CamelExchangeException {
    private final BamProcessorSupport processor;
    public NoCorrelationKeyException(BamProcessorSupport processor, Exchange exchange) {
        super(""No correlation key could be found for "" + processor.getCorrelationKeyExpression(), exchange);
        this.processor = processor;
    }
    public BamProcessorSupport getProcessor() {
        return processor;
    }
}
"
org.apache.camel.component.cxf.interceptors.XMLMessageOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.apache.cxf.bindings.xformat.XMLBindingMessageFormat;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingMessageInfo;
//import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.MessagePartInfo;
public class XMLMessageOutInterceptor extends AbstractMessageOutInterceptor<XMLMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(XMLMessageOutInterceptor.class);
    public XMLMessageOutInterceptor() {
        super(Phase.PREPARE_SEND);        
        addAfter(DOMOutInterceptor.class.getName());
    }
    protected Logger getLogger() {
        return LOG;
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(XMLMessage message) throws Fault {
        Exchange exchange = message.getExchange();        
        //BindingOperationInfo boi = exchange.get(BindingOperationInfo.class);
        BindingMessageInfo bmi = exchange.get(BindingMessageInfo.class);
        List<Element> payload = message.get(List.class);
        if (bmi == null && payload.size() > 1) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(
                            ""NO_XML_ROOT_NODE"", LOG));            
        }
        if (bmi != null) {
            Element header = message.get(Element.class);
            if (header != null) {
                //Headers -represent as -Element,
                //Body -represent as StaxStream in CXF Runtime.
                //Copy inbound Header parts to outbound payload
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""DOMOutInterceptor Copy Message Part related Headers to Payload."");
                }
                moveHeaderPartToPayload(bmi, header, payload);
            }
            XMLBindingMessageFormat msgFormat = 
                bmi.getExtensor(XMLBindingMessageFormat.class);
            QName rootName = msgFormat != null ? msgFormat.getRootNode() : null;
            if (rootName == null) {
                if (payload.size() > 1) {
                    throw new Fault(new org.apache.cxf.common.i18n.Message(
                                    ""NO_XML_ROOT_NODE"", LOG));
                }
            } else {
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""DOMOutInterceptor Create xmlformat RootNode element"");
                }                
                Element el = createElement(rootName, payload);
                payload = new ArrayList<Element>();
                payload.add(el);
            }
            message.put(List.class, payload);
            message.remove(Element.class);
        }
    }
    private void moveHeaderPartToPayload(BindingMessageInfo bmi,
                                         Element header,
                                         List<Element> payload) {
        Collection<MessagePartInfo> bodyParts = bmi.getMessageParts();
        NodeList nodes = header.getChildNodes();
        for (int idx = 0; idx < nodes.getLength(); idx++) {
            Node node = nodes.item(idx);
            int index = 0;
            for (MessagePartInfo mpi : bodyParts) {
                QName name = mpi.getConcreteName();
                if (name.getLocalPart().equals(node.getLocalName())
                    && name.getNamespaceURI().equals(node.getNamespaceURI())) {
                    payload.add(index, (Element)node);
                    break;
                } 
                ++index;
            }
        }
    }
}
"
org.apache.camel.component.cxf.interceptors.FaultOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.cxf.binding.soap.SoapFault;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.xml.XMLFault;
import org.apache.cxf.common.logging.LogUtils;
//import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.XMLMessage;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
public class FaultOutInterceptor extends AbstractPhaseInterceptor<Message> {
    private static final Logger LOG = LogUtils.getL7dLogger(FaultOutInterceptor.class);
    public FaultOutInterceptor() {
        super(Phase.PREPARE_SEND);        
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(Message message) throws Fault {
        Exception ex = message.getContent(Exception.class); 
        if (ex != null) {
            if (!(ex instanceof Fault)) {
                ex = new Fault(ex);
            }
            if (message instanceof XMLMessage) {
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""FaultOutInterceptor Creating XMLFault"");
                }                
                ex = XMLFault.createFault((Fault)ex);
            } else if (message instanceof SoapMessage) {
                if (LOG.isLoggable(Level.INFO)) {
                    LOG.info(""FaultOutInterceptor Creating SoapFault"");
                }                
                SoapMessage sm = (SoapMessage)message;
                ex = SoapFault.createFault((Fault)ex, sm.getVersion());
            } 
            message.setContent(Exception.class, ex);
        }
    }
}
"
org.apache.camel.spring.remoting.SendBeforeInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.remoting;
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Endpoint;
import org.apache.camel.Producer;
import org.apache.camel.component.bean.CamelInvocationHandler;
import org.apache.camel.util.CamelContextHelper;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A Spring interceptor which sends a message exchange to an endpoint before the method is invoked
 * 
 * @version $Revision: $
 */
public class SendBeforeInterceptor implements MethodInterceptor, CamelContextAware, InitializingBean, DisposableBean {
    private String uri;
    private CamelContext camelContext;
    private CamelInvocationHandler invocationHandler;
    private Producer producer;
    public Object invoke(MethodInvocation invocation) throws Throwable {
        invocationHandler.invoke(invocation.getThis(), invocation.getMethod(), invocation.getArguments());
        return invocation.proceed();
    }
    public void afterPropertiesSet() throws Exception {
        notNull(uri, ""uri"");
        notNull(camelContext, ""camelContext"");
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(camelContext, uri);
        producer = endpoint.createProducer();
        producer.start();
        invocationHandler = new CamelInvocationHandler(endpoint, producer);
    }
    public void destroy() throws Exception {
        if (producer != null) {
            producer.stop();
        }
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    // Properties
    //-----------------------------------------------------------------------
    public String getUri() {
        return uri;
    }
    public void setUri(String uri) {
        this.uri = uri;
    }
}
"
org.apache.camel.component.cxf.DataFormat,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
/**
 * The data format the user expoects to see at the camel cxf components.  It can be
 * configured as a property (DataFormat) in the Camel cxf endpoint.
 */
public enum DataFormat {
    /**
     * PAYLOAD is the message payload of the message after message configured in
     * the CXF endpoint is applied.  Streaming and non-streaming are both
     * supported.
     */
    PAYLOAD,
    /**
     * MESSAGE is the raw message that is received from the transport layer.
     * Streaming and non-streaming are both supported.
     */
    MESSAGE,
    /**
     * POJOs (Plain old Java objects) are the Java parameters to the method
     * it is invoking on the target server.  The ""serviceClass"" property
     * must be included in the endpoint.  Streaming is not available for this
     * data format.
     */
    POJO
}
"
org.apache.camel.bam.processor.JpaBamProcessorSupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.support.TransactionTemplate;
import java.util.List;
import java.lang.reflect.Method;
/**
 * A base class for JPA based BAM which can use any entity to store the process
 * instance information which allows derived classes to specialise the process
 * instance entity.
 *
 * @version $Revision: $
 */
public class JpaBamProcessorSupport<T> extends BamProcessorSupport<T> {
    private static final transient Log LOG = LogFactory.getLog(JpaBamProcessorSupport.class);
    private ActivityRules activityRules;
    private JpaTemplate template;
    private String findByKeyQuery;
    private String keyPropertyName = ""correlationKey"";
    private boolean correlationKeyIsPrimary = true;
    public JpaBamProcessorSupport(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, ActivityRules activityRules, Class<T> entitytype) {
        super(transactionTemplate, correlationKeyExpression, entitytype);
        this.activityRules = activityRules;
        this.template = template;
    }
    public JpaBamProcessorSupport(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, ActivityRules activityRules) {
        super(transactionTemplate, correlationKeyExpression);
        this.activityRules = activityRules;
        this.template = template;
    }
    public String getFindByKeyQuery() {
        if (findByKeyQuery == null) {
            findByKeyQuery = createFindByKeyQuery();
        }
        return findByKeyQuery;
    }
    public void setFindByKeyQuery(String findByKeyQuery) {
        this.findByKeyQuery = findByKeyQuery;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public void setActivityRules(ActivityRules activityRules) {
        this.activityRules = activityRules;
    }
    public String getKeyPropertyName() {
        return keyPropertyName;
    }
    public void setKeyPropertyName(String keyPropertyName) {
        this.keyPropertyName = keyPropertyName;
    }
    public JpaTemplate getTemplate() {
        return template;
    }
    public void setTemplate(JpaTemplate template) {
        this.template = template;
    }
    public boolean isCorrelationKeyIsPrimary() {
        return correlationKeyIsPrimary;
    }
    public void setCorrelationKeyIsPrimary(boolean correlationKeyIsPrimary) {
        this.correlationKeyIsPrimary = correlationKeyIsPrimary;
    }
    // Implementatiom methods
    // -----------------------------------------------------------------------
    protected T loadEntity(Exchange exchange, Object key) throws Exception {
        T entity = findEntityByCorrelationKey(key);
        if (entity == null) {
            entity = createEntity(exchange, key);
            setKeyProperty(entity, key);
            ProcessDefinition definition = ProcessDefinition.getRefreshedProcessDefinition(template, getActivityRules().getProcessRules().getProcessDefinition());
            setProcessDefinitionProperty(entity, definition);
            template.persist(entity);
            // Now we must flush to avoid concurrent updates clashing trying to insert the
            // same row
            LOG.debug(""About to flush on entity: "" + entity + "" with key: "" + key);
            template.flush();
        }
        return entity;
    }
    protected T findEntityByCorrelationKey(Object key) {
        if (isCorrelationKeyIsPrimary()) {
            return template.find(getEntityType(), key);
        }
        else {
            List<T> list = template.find(getFindByKeyQuery(), key);
            if (list.isEmpty()) {
                return null;
            }
            else {
                return list.get(0);
            }
        }
    }
    protected Class getKeyType() {
        try {
            Method getter = IntrospectionSupport.getPropertyGetter(getEntityType(), getKeyPropertyName());
            return getter.getReturnType();
        }
        catch (NoSuchMethodException e) {
            LOG.warn(""no such getter for: "" + getKeyPropertyName() + "" on "" + getEntityType() + "". Reason: "" + e, e);
            return null;
        }
    }
    /**
     * Sets the key property on the new entity
     */
    protected void setKeyProperty(T entity, Object key) throws Exception {
        IntrospectionSupport.setProperty(entity, getKeyPropertyName(), key);
    }
    protected void setProcessDefinitionProperty(T entity, ProcessDefinition processDefinition) throws Exception {
        IntrospectionSupport.setProperty(entity, ""processDefinition"", processDefinition);
    }
    /**
     * Create a new instance of the entity for the given key
     */
    protected T createEntity(Exchange exchange, Object key) {
        return (T) exchange.getContext().getInjector().newInstance(getEntityType());
    }
    protected void processEntity(Exchange exchange, T entity) throws Exception {
        if (entity instanceof Processor) {
            Processor processor = (Processor) entity;
            processor.process(exchange);
        }
        else {
            // TODO add other extension points - eg. passing in Activity
            throw new IllegalArgumentException(""No processor defined for this route"");
        }
    }
    protected String createFindByKeyQuery() {
        return ""select x from "" + getEntityType().getName() + "" x where x."" + getKeyPropertyName() + "" = ?1"";
    }
}
"
org.apache.camel.component.quartz.QuartzMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.quartz.JobExecutionContext;
import org.quartz.Trigger;
/**
 * @version $Revision: 1.1 $
 */
public class QuartzMessage extends DefaultMessage {
    private final JobExecutionContext jobExecutionContext;
    public QuartzMessage(QuartzExchange exchange, JobExecutionContext jobExecutionContext) {
        this.jobExecutionContext = jobExecutionContext;
        setExchange(exchange);
        setBody(jobExecutionContext.getJobDetail());
    }
    public JobExecutionContext getJobExecutionContext() {
        return jobExecutionContext;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        super.populateInitialHeaders(map);
        if (jobExecutionContext != null) {
            map.put(""calendar"", jobExecutionContext.getCalendar());
            map.put(""fireTime"", jobExecutionContext.getFireTime());
            map.put(""jobDetail"", jobExecutionContext.getJobDetail());
            map.put(""jobInstance"", jobExecutionContext.getJobInstance());
            map.put(""jobRunTime"", jobExecutionContext.getJobRunTime());
            map.put(""mergedJobDataMap"", jobExecutionContext.getMergedJobDataMap());
            map.put(""nextFireTime"", jobExecutionContext.getNextFireTime());
            map.put(""previousFireTime"", jobExecutionContext.getPreviousFireTime());
            map.put(""refireCount"", jobExecutionContext.getRefireCount());
            map.put(""result"", jobExecutionContext.getResult());
            map.put(""scheduledFireTime"", jobExecutionContext.getScheduledFireTime());
            map.put(""scheduler"", jobExecutionContext.getScheduler());
            Trigger trigger = jobExecutionContext.getTrigger();
            map.put(""trigger"", trigger);
            map.put(""triggerName"", trigger.getName());
            map.put(""triggerGroup"", trigger.getGroup());
        }
    }
}
"
org.apache.camel.component.velocity.VelocityEndpoint,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.velocity;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Message;
import org.apache.camel.component.ResourceBasedEndpoint;
import org.apache.camel.util.ExchangeHelper;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.context.Context;
/**
 * @version $Revision: 1.1 $
 */
public class VelocityEndpoint extends ResourceBasedEndpoint {
    private final VelocityComponent component;
    private VelocityEngine velocityEngine;
    public VelocityEndpoint(String uri, VelocityComponent component, String resourceUri, Map parameters) {
        super(uri, component, resourceUri, null);
        this.component = component;
    }
    public boolean isSingleton() {
        return true;
    }
    @Override
    public ExchangePattern getExchangePattern() {
        return ExchangePattern.InOut;
    }
    public VelocityEngine getVelocityEngine() throws Exception {
        if (velocityEngine == null) {
            velocityEngine = component.getVelocityEngine();
            velocityEngine.init();
        }
        return velocityEngine;
    }
    public void setVelocityEngine(VelocityEngine velocityEngine) {
        this.velocityEngine = velocityEngine;
    }
    @Override
    protected void onExchange(Exchange exchange) throws Exception {
        // TODO we might wanna add some kinda resource caching of the template
        Reader reader = new InputStreamReader(getResource().getInputStream());
        StringWriter buffer = new StringWriter();
        String logTag = getClass().getName();
        Map variableMap = ExchangeHelper.createVariableMap(exchange);
        Context velocityContext = new VelocityContext(variableMap);
        VelocityEngine engine = getVelocityEngine();
        engine.evaluate(velocityContext, buffer, logTag, reader);
        // now lets output the results to the exchange
        Message out = exchange.getOut(true);
        out.setBody(buffer.toString());
        out.setHeader(""org.apache.camel.velocity.resource"", getResource());
    }
}
"
org.apache.camel.component.xmpp.XmppPrivateChatProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.Chat;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Message;
/**
 * @version $Revision$
 */
public class XmppPrivateChatProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(XmppPrivateChatProducer.class);
    private final XmppEndpoint endpoint;
    private final String participant;
    private Chat chat;
    public XmppPrivateChatProducer(XmppEndpoint endpoint, String participant) {
        super(endpoint);
        this.endpoint = endpoint;
        this.participant = participant;
        if (participant == null) {
            throw new IllegalArgumentException(""No participant property specified"");
        }
    }
    public void process(Exchange exchange) {
        // TODO it would be nice if we could reuse the message from the exchange
        Message message = chat.createMessage();
        message.setTo(participant);
        message.setFrom(endpoint.getUser());
        message.setThread(exchange.getExchangeId());
        message.setType(Message.Type.NORMAL);
        endpoint.getBinding().populateXmppMessage(message, exchange);
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> message: "" + message.getBody());
        }
        try {
            chat.sendMessage(message);
        } catch (XMPPException e) {
            throw new RuntimeXmppException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (chat == null) {
            chat = endpoint.getConnection().createChat(getParticipant());
        }
    }
    @Override
    protected void doStop() throws Exception {
        chat = null;
        super.doStop();
    }
    // Properties
    // -------------------------------------------------------------------------
    public Chat getChat() {
        return chat;
    }
    public void setChat(Chat chat) {
        this.chat = chat;
    }
    public String getParticipant() {
        return participant;
    }
}
"
org.apache.camel.spring.package-info,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@javax.xml.bind.annotation.XmlSchema(namespace = ""http://activemq.apache.org/camel/schema/spring"", elementFormDefault = javax.xml.bind.annotation.XmlNsForm.QUALIFIED)
package org.apache.camel.spring;
"
org.apache.camel.component.cxf.CxfBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import java.io.InputStream;
import java.util.List;
import java.util.Set;
/**
 * The binding of how Camel messages get mapped to Apache CXF and back again
 *
 * @version $Revision$
 */
public class CxfBinding {
    public Object extractBodyFromCxf(CxfExchange exchange, Message message) {
        //  TODO how do we choose a format?
        return getBody(message);
    }
    protected Object getBody(Message message) {
        Set<Class<?>> contentFormats = message.getContentFormats();
        if (contentFormats != null) {
            for (Class<?> contentFormat : contentFormats) {            
                Object answer = message.getContent(contentFormat);
                if (answer != null) {
                    return answer;
                }
            }
        }    
        return null;
    }
    public Message createCxfMessage(CxfExchange exchange) {
        Message answer = exchange.getInMessage();
        // CXF uses the stax which is based on the stream API to parser the XML, so
        // the CXF transport is also based on the stream API.
        // And the interceptors are also based on the stream API,
        // so lets use an InputStream to host the CXF on wire message.
        CxfMessage in = exchange.getIn();
        Object body = in.getBody(InputStream.class);
        if (body == null) {
            body = in.getBody();
        }
        if (body instanceof InputStream) {
        	answer.setContent(InputStream.class, body);
                // we need copy context 
        } else if (body instanceof List) {
        	//just set the operation's parament
        	answer.setContent(List.class, body);
                //just set the method name
                answer.setContent(String.class, in.getHeader(CxfConstants.OPERATION_NAME));
        }
        return answer;
    }
    public void storeCxfResponse(CxfExchange exchange, Message response) {
        // no need to process headers as we use the CXF message
        CxfMessage out = exchange.getOut();
        if (response != null) {
            out.setMessage(response);
            out.setBody(getBody(response));
        }
    }
    public void storeCxfResponse(CxfExchange exchange, Object response) {
        CxfMessage out = exchange.getOut();
        if (response != null) {
            out.setBody(response);
        }
    }
    public void storeCxfFault(CxfExchange exchange, Message message) {
        CxfMessage fault = exchange.getFault();
        if (fault != null) {
            fault.setBody(getBody(message));
        }
    }
}
"
org.apache.camel.component.jms.JmsProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.MessageCreator;
/**
 * @version $Revision$
 */
public class JmsProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(JmsProducer.class);
    private final JmsEndpoint endpoint;
    private final JmsOperations template;
    public JmsProducer(JmsEndpoint endpoint, JmsOperations template) {
        super(endpoint);
        this.endpoint = endpoint;
        this.template = template;
    }
    public void process(final Exchange exchange) {
        template.send(endpoint.getDestination(), new MessageCreator() {
            public Message createMessage(Session session) throws JMSException {
                Message message = endpoint.getBinding().makeJmsMessage(exchange, session);
                if (LOG.isDebugEnabled()) {
                    LOG.debug(endpoint + "" sending JMS message: "" + message);
                }
                return message;
            }
        });
    }
    public JmsOperations getTemplate() {
        return template;
    }
}
"
org.apache.camel.component.cxf.interceptors.PayloadContentRedirectInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.List;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;
import org.w3c.dom.Element;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.staxutils.StaxUtils;
public class PayloadContentRedirectInterceptor extends AbstractPhaseInterceptor<Message> {
    public PayloadContentRedirectInterceptor() {
        super(Phase.POST_STREAM);        
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(Message message) throws Fault {
        XMLStreamWriter out = message.getContent(XMLStreamWriter.class);
        List<Element> in = message.get(List.class);
        try {
            for (Element el : in) {
                StaxUtils.writeElement(el, out, false, true);
            }
        } catch (XMLStreamException e) {
            throw new Fault(e);
        }
    }
}
"
org.apache.camel.component.cxf.CxfExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultMessage;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
/**
 * An {@link Exchange} for working with Apache CXF which expoes the underlying
 * CXF messages via {@link #getInMessage()} and {@link #getOutMessage()} along with the
 * {@link #getExchange()} 
 *
 * @version $Revision$
 */
public class CxfExchange extends DefaultExchange {
    private final CxfBinding binding;
    private Exchange exchange;
    public CxfExchange(CamelContext context, CxfBinding binding, Exchange exchange) {
        super(context);
        this.binding = binding;
        this.exchange = exchange;
        setIn(new CxfMessage(exchange.getInMessage()));
        setOut(new CxfMessage(exchange.getOutMessage()));
        if (exchange.getInFaultMessage() != null) {
            setFault(new CxfMessage(exchange.getInFaultMessage()));
        }    
    }
    public CxfExchange(CamelContext context, ExchangePattern pattern, CxfBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public CxfExchange(CamelContext context, ExchangePattern pattern, CxfBinding binding, Message inMessage) {
        this(context, pattern, binding);
        this.exchange = inMessage.getExchange();
        setIn(new CxfMessage(inMessage));
        if (exchange != null) {
            setOut(new CxfMessage(exchange.getOutMessage()));
            if (exchange.getInFaultMessage() != null) {
                setFault(new CxfMessage(exchange.getInFaultMessage()));
            }    
        }
    }
    @Override
    public CxfMessage getIn() {
        return (CxfMessage) super.getIn();
    }
    @Override
    public CxfMessage getOut() {
        return (CxfMessage) super.getOut();
    }
    @Override
    public CxfMessage getOut(boolean lazyCreate) {
        return (CxfMessage) super.getOut(lazyCreate);
    }
    @Override
    public CxfMessage getFault() {
        return (CxfMessage) super.getFault();
    }
    @Override
    protected org.apache.camel.Message createFaultMessage() {
        return new CxfMessage();
    }
    /**
     * @return the Camel <-> JBI binding
     */
    public CxfBinding getBinding() {
        return binding;
    }
    // Expose CXF APIs directly on the exchange
    //-------------------------------------------------------------------------
    /**
     * Returns the underlying CXF message exchange for an inbound exchange
     * or null for outbound messages
     *
     * @return the inbound message exchange
     */
    public Exchange getExchange() {
        return exchange;
    }
    public Message getInMessage() {
        return getIn().getMessage();
    }
    public Message getOutMessage() {
        return getOut().getMessage();
    }
    public Message getOutFaultMessage() {
        return getExchange().getOutFaultMessage();
    }
    public Message getInFaultMessage() {
        return getExchange().getInFaultMessage();
    }
    public Destination getDestination() {
        return getExchange().getDestination();
    }
    public Conduit getConduit(Message message) {
        return getExchange().getConduit(message);
    }
    @Override
    protected CxfMessage createInMessage() {
        return new CxfMessage();
    }
    @Override
    protected CxfMessage createOutMessage() {
        return new CxfMessage();
    }
}
"
org.apache.camel.component.xmpp.XmppMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.jivesoftware.smack.packet.Message;
/**
 * Represents a {@link org.apache.camel.Message} for working with XMPP
 * 
 * @version $Revision:520964 $
 */
public class XmppMessage extends DefaultMessage {
    private Message xmppMessage;
    public XmppMessage() {
        this(new Message());
    }
    public XmppMessage(Message jmsMessage) {
        this.xmppMessage = jmsMessage;
    }
    @Override
    public String toString() {
        if (xmppMessage != null) {
            return ""XmppMessage: "" + xmppMessage;
        } else {
            return ""XmppMessage: "" + getBody();
        }
    }
    @Override
    public XmppExchange getExchange() {
        return (XmppExchange)super.getExchange();
    }
    /**
     * Returns the underlying XMPP message
     * 
     * @return the underlying XMPP message
     */
    public Message getXmppMessage() {
        return xmppMessage;
    }
    public void setXmppMessage(Message xmppMessage) {
        this.xmppMessage = xmppMessage;
    }
    public Object getHeader(String name) {
        return xmppMessage.getProperty(name);
    }
    @Override
    public void setHeader(String name, Object value) {
        if (value == null) {
            xmppMessage.deleteProperty(name);
        } else {
            xmppMessage.setProperty(name, value);
        }
    }
    @Override
    public Map<String, Object> getHeaders() {
        Map<String, Object> answer = new HashMap<String, Object>();
        Iterator iter = xmppMessage.getPropertyNames();
        while (iter.hasNext()) {
            String name = (String)iter.next();
            answer.put(name, xmppMessage.getProperty(name));
        }
        return answer;
    }
    @Override
    public XmppMessage newInstance() {
        return new XmppMessage();
    }
    @Override
    protected Object createBody() {
        if (xmppMessage != null) {
            return getExchange().getBinding().extractBodyFromXmpp(getExchange(), xmppMessage);
        }
        return null;
    }
}
"
org.apache.camel.component.file.remote.SftpProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.IOException;
import java.io.InputStream;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.SftpException;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
public class SftpProducer extends RemoteFileProducer<RemoteFileExchange> {
    SftpEndpoint endpoint;
    private final ChannelSftp channel;
    public SftpProducer(SftpEndpoint endpoint, ChannelSftp channelSftp) {
        super(endpoint);
        this.endpoint = endpoint;
        this.channel = channelSftp;
    }
    public void process(Exchange exchange) throws Exception {
        process(endpoint.createExchange(exchange));
    }
    public void process(RemoteFileExchange exchange) throws Exception {
        InputStream payload = exchange.getIn().getBody(InputStream.class);
        final String endpointFile = endpoint.getConfiguration().getFile();
        channel.cd(endpointFile);
        String fileName = createFileName(exchange.getIn(), endpoint.getConfiguration());
        buildDirectory(channel, fileName.substring(0, fileName.lastIndexOf('/')));
        try {
            channel.put(payload, fileName);
        } catch (SftpException e) {
            throw new RuntimeCamelException(""error sending file"", e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        // channel.connect(endpoint.getConfiguration().getHost());
        // channel.login(endpoint.getConfiguration().getUsername(),
        // endpoint.getConfiguration().getPassword());
        // channel.setFileType(endpoint.getConfiguration().isBinary() ?
        // SftpClient.BINARY_FILE_TYPE : SftpClient.ASCII_FILE_TYPE);
    }
    @Override
    protected void doStop() throws Exception {
        channel.disconnect();
        super.doStop();
    }
    protected static boolean buildDirectory(ChannelSftp sftpClient, String dirName) throws IOException {
        boolean atLeastOneSuccess = false;
        final StringBuilder sb = new StringBuilder(dirName.length());
        final String[] dirs = dirName.split(""\\/"");
        for (String dir : dirs) {
            sb.append('/').append(dir);
            try {
                sftpClient.mkdir(sb.toString());
                if (!atLeastOneSuccess) {
                    atLeastOneSuccess = true;
                }
            } catch (SftpException e) {
                // ignore
            }
        }
        return atLeastOneSuccess;
    }
}
"
org.apache.camel.component.jdbc.JdbcProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing pejdbcssions and
 * limitations under the License.
 */
package org.apache.camel.component.jdbc;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import javax.sql.DataSource;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.IntrospectionSupport;
/**
 * @version $Revision: 533076 $
 */
public class JdbcProducer extends DefaultProducer<DefaultExchange> {
    private DataSource source;
    /** The maximum size for reading a result set <code>readSize</code> */
    private int readSize = 2000;
    public JdbcProducer(JdbcEndpoint endpoint, String remaining, int readSize) throws Exception {
        super(endpoint);
        this.readSize = readSize;
        source = (DataSource) getEndpoint().getContext().getRegistry().lookup(remaining);
    }
    /**
     * Execute sql of exchange and set results on output
     * 
     * @see org.apache.camel.Processor#process(org.apache.camel.Exchange)
     */
    public void process(Exchange exchange) throws Exception {
        String sql = exchange.getIn().getBody(String.class);
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = source.getConnection();
            stmt = conn.createStatement();
            if (stmt.execute(sql)) {
                ResultSet rs = stmt.getResultSet();
                setResultSet(exchange, rs);
                rs.close();
            } else {
                int updateCount = stmt.getUpdateCount();
                exchange.getOut().setHeader(""jdbc.updateCount"", updateCount);
            }
        } finally {
            if (stmt != null) {
                stmt.close();
            }
            if (conn != null) {
                conn.close();
            }
        }
    }
    public int getReadSize() {
        return this.readSize;
    }
    public void setReadSize(int readSize) {
        this.readSize = readSize;
    }
    public void setResultSet(Exchange exchange, ResultSet rs) throws SQLException {
        ResultSetMetaData meta = rs.getMetaData();
        HashMap<String, Object> props = new HashMap<String, Object>();
        IntrospectionSupport.getProperties(meta, props, ""jdbc."");
        exchange.getOut().setHeaders(props);
        //
        int count = meta.getColumnCount();
        ArrayList<HashMap<String, Object>> data = new ArrayList<HashMap<String, Object>>();
        int rowNumber = 0;
        while (rs.next() && rowNumber < readSize) {
            HashMap<String, Object> row = new HashMap<String, Object>();
            for (int i = 0; i < count; i++) {
                int columnNumber = i + 1;
                String columnName = meta.getColumnName(columnNumber);
                row.put(columnName, rs.getObject(columnName));
            }
            data.add(row);
            rowNumber++;
        }
        exchange.getOut().setBody(data);
    }
}
"
org.apache.camel.bam.model.ProcessInstance,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import javax.persistence.*;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a single business process
 *
 * @version $Revision: $
 */
@Entity
public class ProcessInstance  {
    private static final transient Log LOG = LogFactory.getLog(ProcessInstance.class);
    private ProcessDefinition processDefinition;
    private Collection<ActivityState> activityStates = new HashSet<ActivityState>();
    private String correlationKey;
    private Date timeStarted;
    private Date timeCompleted;
    public ProcessInstance() {
        setTimeStarted(new Date());
    }
    public String toString() {
        return ""ProcessInstance["" + getCorrelationKey() + ""]"";
    }
    @Id
    public String getCorrelationKey() {
        return correlationKey;
    }
    public void setCorrelationKey(String correlationKey) {
        this.correlationKey = correlationKey;
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST })
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    @OneToMany(mappedBy = ""processInstance"", fetch = FetchType.LAZY, cascade = {CascadeType.ALL })
    public Collection<ActivityState> getActivityStates() {
        return activityStates;
    }
    public void setActivityStates(Collection<ActivityState> activityStates) {
        this.activityStates = activityStates;
    }
    @Transient
    public boolean isStarted() {
        return timeStarted != null;
    }
    @Transient
    public boolean isCompleted() {
        return timeCompleted != null;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeStarted() {
        return timeStarted;
    }
    public void setTimeStarted(Date timeStarted) {
        this.timeStarted = timeStarted;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeCompleted() {
        return timeCompleted;
    }
    public void setTimeCompleted(Date timeCompleted) {
        this.timeCompleted = timeCompleted;
    }    // Helper methods
    //-------------------------------------------------------------------------
    /**
     * Returns the activity state for the given activity
     *
     * @param activityRules the activity to find the state for
     * @return the activity state or null if no state could be found for the
     *         given activity
     */
    public ActivityState getActivityState(ActivityRules activityRules) {
        for (ActivityState activityState : getActivityStates()) {
            if (activityState.isActivity(activityRules)) {
                return activityState;
            }
        }
        return null;
    }
    public ActivityState getOrCreateActivityState(ActivityRules activityRules) {
        ActivityState state = getActivityState(activityRules);
        if (state == null) {
            state = createActivityState();
            state.setProcessInstance(this);
            state.setActivityDefinition(activityRules.getActivityDefinition());
            // we don't need to do: getTemplate().persist(state);
        }
        return state;
    }
    protected ActivityState createActivityState() {
        return new ActivityState();
    }
}
"
org.apache.camel.component.mail.MailMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.util.Enumeration;
import java.util.Map;
import javax.mail.Header;
import javax.mail.Message;
import javax.mail.MessagingException;
import org.apache.camel.impl.DefaultMessage;
import org.apache.camel.util.CollectionHelper;
/**
 * Represents a {@link org.apache.camel.Message} for working with Mail
 * 
 * @version $Revision:520964 $
 */
public class MailMessage extends DefaultMessage {
    private Message mailMessage;
    public MailMessage() {
    }
    public MailMessage(Message message) {
        this.mailMessage = message;
    }
    @Override
    public String toString() {
        if (mailMessage != null) {
            return ""MailMessage: "" + mailMessage;
        } else {
            return ""MailMessage: "" + getBody();
        }
    }
    @Override
    public MailExchange getExchange() {
        return (MailExchange)super.getExchange();
    }
    public MailMessage copy() {
        MailMessage answer = (MailMessage)super.copy();
        answer.mailMessage = mailMessage;
        return answer;
    }
    /**
     * Returns the underlying Mail message
     * 
     * @return the underlying Mail message
     */
    public Message getMessage() {
        return mailMessage;
    }
    public void setMessage(Message mailMessage) {
        this.mailMessage = mailMessage;
    }
    public Object getHeader(String name) {
        String[] answer = null;
        if (mailMessage != null) {
            try {
                answer = mailMessage.getHeader(name);
            } catch (MessagingException e) {
                throw new MessageHeaderAccessException(name, e);
            }
        }
        if (answer == null) {
            return super.getHeader(name);
        }
        if (answer.length == 1) {
            return answer[0];
        }
        return answer;
    }
    @Override
    public MailMessage newInstance() {
        return new MailMessage();
    }
    @Override
    protected Object createBody() {
        if (mailMessage != null) {
            return getExchange().getBinding().extractBodyFromMail(getExchange(), mailMessage);
        }
        return null;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        if (mailMessage != null) {
            Enumeration names;
            try {
                names = mailMessage.getAllHeaders();
            } catch (MessagingException e) {
                throw new MessageHeaderNamesAccessException(e);
            }
            try {
                while (names.hasMoreElements()) {
                    Header header = (Header)names.nextElement();
                    String value = header.getValue();
                    String name = header.getName();
                    CollectionHelper.appendValue(map, name, value);
                }
            } catch (Throwable e) {
                throw new MessageHeaderNamesAccessException(e);
            }
        }
    }
    public void copyFrom(org.apache.camel.Message that) {
        super.copyFrom(that);
        if (that instanceof MailMessage) {
            MailMessage mailMessage = (MailMessage) that;
            this.mailMessage = mailMessage.mailMessage;
        }
    }
}
"
org.apache.camel.component.cxf.spring.CxfEndpointBeanDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.camel.component.cxf.spring;
import com.sun.xml.bind.v2.schemagen.xmlschema.List;
import java.util.Map;
import javax.xml.namespace.QName;
import org.w3c.dom.Element;
import org.apache.cxf.common.util.StringUtils;
import org.apache.cxf.configuration.spring.AbstractBeanDefinitionParser;
import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.BeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
public class CxfEndpointBeanDefinitionParser extends AbstractBeanDefinitionParser {
    @Override
    protected Class getBeanClass(Element arg0) {
        return CxfEndpointBean.class;
    }
    @Override
    protected void mapAttribute(BeanDefinitionBuilder bean, Element e, String name, String val) {
        if (""endpointName"".equals(name) || ""serviceName"".equals(name)) {
            QName q = parseQName(e, val);
            bean.addPropertyValue(name, q);
        } else {
            mapToProperty(bean, name, val);
        }
    }
    @Override
    protected void mapElement(ParserContext ctx, BeanDefinitionBuilder bean, Element el, String name) {
        if (""properties"".equals(name)) {
            Map map = ctx.getDelegate().parseMapElement(el, bean.getBeanDefinition());
            bean.addPropertyValue(""properties"", map);
        } else if (""binding"".equals(name)) {
            setFirstChildAsProperty(el, ctx, bean, ""bindingConfig"");
        } else if (""inInterceptors"".equals(name) || ""inFaultInterceptors"".equals(name)
            || ""outInterceptors"".equals(name) || ""outFaultInterceptors"".equals(name)
            || ""features"".equals(name) || ""schemaLocations"".equals(name)) {
            List list = (List)ctx.getDelegate().parseListElement(el, bean.getBeanDefinition());
            bean.addPropertyValue(name, list);
        } else {
            setFirstChildAsProperty(el, ctx, bean, name);            
        }        
    }
    @Override
    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {
        super.doParse(element, ctx, bean);
        bean.setLazyInit(false);
    }
    @Override
    protected String resolveId(Element elem, 
                               AbstractBeanDefinition definition, 
                               ParserContext ctx) 
        throws BeanDefinitionStoreException {
        String id = super.resolveId(elem, definition, ctx);
        if (StringUtils.isEmpty(id)) {
            throw new BeanDefinitionStoreException(""The bean id is needed."");
        }
        return id;
    }
    @Override
    protected boolean hasBusProperty() {
        return true;
    }
}
"
org.apache.camel.component.irc.IrcProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.schwering.irc.lib.IRCConnection;
import org.schwering.irc.lib.IRCEventListener;
public class IrcProducer extends DefaultProducer<IrcExchange> {
    public static final String[] COMMANDS = new String[] {""AWAY"", ""INVITE"", ""ISON"", ""JOIN"", ""KICK"", ""LIST"", ""NAMES"", ""PRIVMSG"", ""MODE"", ""NICK"", ""NOTICE"", ""PART"", ""PONG"", ""QUIT"", ""TOPIC"", ""WHO"",
                                                          ""WHOIS"", ""WHOWAS"", ""USERHOST""};
    private static final transient Log LOG = LogFactory.getLog(IrcProducer.class);
    private IRCConnection connection;
    private IrcEndpoint endpoint;
    private IRCEventListener ircErrorLogger;
    public IrcProducer(IrcEndpoint endpoint, IRCConnection connection) {
        super(endpoint);
        this.endpoint = endpoint;
        this.connection = connection;
    }
    public void process(Exchange exchange) throws Exception {
        try {
            final String msg = exchange.getIn().getBody(String.class);
            if (isMessageACommand(msg)) {
                connection.send(msg);
            } else {
                final String target = endpoint.getConfiguration().getTarget();
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""sending to: "" + target + "" message: "" + msg);
                }
                connection.doPrivmsg(target, msg);
            }
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        ircErrorLogger = createIrcErrorLogger();
        connection.addIRCEventListener(ircErrorLogger);
        final String target = endpoint.getConfiguration().getTarget();
        LOG.debug(""joining: "" + target);
        connection.doJoin(target);
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        if (connection != null) {
            connection.removeIRCEventListener(ircErrorLogger);
        }
    }
    protected boolean isMessageACommand(String msg) {
        for (String command : COMMANDS) {
            if (msg.startsWith(command)) {
                return true;
            }
        }
        return false;
    }
    protected IRCEventListener createIrcErrorLogger() {
        return new IrcErrorLogger(LOG);
    }
}
"
org.apache.camel.component.file.remote.RemoteFileMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.OutputStream;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
public class RemoteFileMessage extends DefaultMessage {
    private OutputStream outputStream;
    private String fullFileName;
    private String hostname;
    public RemoteFileMessage() {
    }
    public RemoteFileMessage(String hostname, String fullFileName, OutputStream outputStream) {
        this.hostname = hostname;
        this.fullFileName = fullFileName;
        this.outputStream = outputStream;
        setMessageId(hostname + "":"" + fullFileName);
    }
    public String getHostname() {
        return hostname;
    }
    public void setHostname(String hostname) {
        this.hostname = hostname;
    }
    public String getFullFileName() {
        return fullFileName;
    }
    public void setFullFileName(String fullFileName) {
        this.fullFileName = fullFileName;
    }
    public OutputStream getOutputStream() {
        return outputStream;
    }
    public void setOutputStream(OutputStream outputStream) {
        this.outputStream = outputStream;
    }
    @Override
    public RemoteFileExchange getExchange() {
        return (RemoteFileExchange) super.getExchange();
    }
    @Override
    protected Object createBody() {
        if (outputStream != null) {
            return getExchange().getBinding().extractBodyFromOutputStream(getExchange(), outputStream);
        }
        return null;
    }
    @Override
    public RemoteFileMessage newInstance() {
        return new RemoteFileMessage();
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        super.populateInitialHeaders(map);
        map.put(""file.remote.host"", hostname);
        map.put(""file.remote.name"", fullFileName);
    }
}
"
org.apache.camel.component.jms.JmsMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.io.File;
import java.util.Enumeration;
import java.util.Map;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Topic;
import org.apache.camel.impl.DefaultMessage;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a {@link org.apache.camel.Message} for working with JMS
 * 
 * @version $Revision:520964 $
 */
public class JmsMessage extends DefaultMessage {
    private static final transient Log LOG = LogFactory.getLog(JmsMessage.class);
    private Message jmsMessage;
    public JmsMessage() {
    }
    public JmsMessage(Message jmsMessage) {
        setJmsMessage(jmsMessage);
    }
    @Override
    public String toString() {
        if (jmsMessage != null) {
            return ""JmsMessage: "" + jmsMessage;
        } else {
            return ""JmsMessage: "" + getBody();
        }
    }
    /**
     * Returns the underlying JMS message
     * 
     * @return the underlying JMS message
     */
    public Message getJmsMessage() {
        return jmsMessage;
    }
    public void setJmsMessage(Message jmsMessage) {
        this.jmsMessage = jmsMessage;
        try {
            String id = getDestinationAsString(jmsMessage.getJMSDestination());
            id += getSanitizedString(jmsMessage.getJMSMessageID());
            setMessageId(id);
        } catch (JMSException e) {
            LOG.error(""Failed to get message id from message "" + jmsMessage, e);
        }
    }
    public Object getHeader(String name) {
        Object answer = null;
        // we will exclude using JMS-prefixed headers here to avoid strangeness with some JMS providers
        // e.g. ActiveMQ returns the String not the Destination type for ""JMSReplyTo""!
        if (jmsMessage != null && !name.startsWith(""JMS"")) {
            try {
                answer = jmsMessage.getObjectProperty(name);
            } catch (JMSException e) {
                throw new MessagePropertyAccessException(name, e);
            }
        }
        if (answer == null) {
            answer = super.getHeader(name);
        }
        return answer;
    }
    @Override
    public JmsMessage newInstance() {
        return new JmsMessage();
    }
    @Override
    protected Object createBody() {
        if (jmsMessage != null && getExchange() instanceof JmsExchange) {
            JmsExchange exchange = (JmsExchange)getExchange();
            return exchange.getBinding().extractBodyFromJms(exchange, jmsMessage);
        }
        return null;
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        if (jmsMessage != null) {
            // lets populate the standard JMS message headers
            try {
                map.put(""JMSCorrelationID"", jmsMessage.getJMSCorrelationID());
                map.put(""JMSDeliveryMode"", jmsMessage.getJMSDeliveryMode());
                map.put(""JMSDestination"", jmsMessage.getJMSDestination());
                map.put(""JMSExpiration"", jmsMessage.getJMSExpiration());
                map.put(""JMSMessageID"", jmsMessage.getJMSMessageID());
                map.put(""JMSPriority"", jmsMessage.getJMSPriority());
                map.put(""JMSRedelivered"", jmsMessage.getJMSRedelivered());
                map.put(""JMSReplyTo"", jmsMessage.getJMSReplyTo());
                map.put(""JMSTimestamp"", jmsMessage.getJMSTimestamp());
                map.put(""JMSType"", jmsMessage.getJMSType());
                // TODO this works around a bug in the ActiveMQ property handling
                map.put(""JMSXGroupID"", jmsMessage.getStringProperty(""JMSXGroupID""));
            }
            catch (JMSException e) {
                throw new MessageJMSPropertyAccessException(e);
            }
            Enumeration names;
            try {
                names = jmsMessage.getPropertyNames();
            } catch (JMSException e) {
                throw new MessagePropertyNamesAccessException(e);
            }
            while (names.hasMoreElements()) {
                String name = names.nextElement().toString();
                try {
                    Object value = jmsMessage.getObjectProperty(name);
                    map.put(name, value);
                } catch (JMSException e) {
                    throw new MessagePropertyAccessException(name, e);
                }
            }
        }
    }
    private String getDestinationAsString(Destination destination) throws JMSException {
        String result = """";
        if (destination == null) {
            result = ""null destination!"";
        } else if (destination instanceof Topic) {
            result += ""topic"" + File.separator + getSanitizedString(((Topic)destination).getTopicName());
        } else {
            result += ""queue"" + File.separator + getSanitizedString(((Queue)destination).getQueueName());
        }
        result += File.separator;
        return result;
    }
    private String getSanitizedString(Object value) {
        return value != null ? value.toString().replaceAll(""[^a-zA-Z0-9\\.\\_\\-]"", ""_"") : """";
    }
}
"
org.apache.camel.component.cxf.phase.PayloadPhaseManagerImpl,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.phase;
import java.util.SortedSet;
import org.apache.cxf.common.util.SortedArraySet;
import org.apache.cxf.phase.Phase;
public class PayloadPhaseManagerImpl extends AbstractPhaseManagerImpl {
    protected SortedSet<Phase> createInPhases() {
        SortedSet<Phase> inPhases = new SortedArraySet<Phase>();
        int i = 0;        
        inPhases.add(new Phase(Phase.RECEIVE, ++i * 1000));   
        inPhases.add(new Phase(Phase.PRE_STREAM, ++i * 1000));
        inPhases.add(new Phase(Phase.USER_STREAM, ++i * 1000));
        inPhases.add(new Phase(Phase.POST_STREAM, ++i * 1000));
        inPhases.add(new Phase(Phase.PRE_PROTOCOL, ++i * 1000));
        inPhases.add(new Phase(Phase.USER_PROTOCOL, ++i * 1000));
        inPhases.add(new Phase(Phase.POST_PROTOCOL, ++i * 1000));
        inPhases.add(new Phase(Phase.READ, ++i * 1000));
        return inPhases;
    }
    protected SortedSet<Phase> createOutPhases() {
        SortedSet<Phase> outPhases = new SortedArraySet<Phase>();
        int i = 0;
        outPhases.add(new Phase(Phase.PREPARE_SEND, ++i * 1000));
        outPhases.add(new Phase(Phase.PRE_STREAM, ++i * 1000));
        outPhases.add(new Phase(Phase.PRE_PROTOCOL, ++i * 1000));        
        outPhases.add(new Phase(Phase.USER_PROTOCOL, ++i * 1000));
        outPhases.add(new Phase(Phase.POST_PROTOCOL, ++i * 1000));
        outPhases.add(new Phase(Phase.WRITE, ++i * 1000));
        outPhases.add(new Phase(Phase.USER_STREAM, ++i * 1000));
        outPhases.add(new Phase(Phase.POST_STREAM, ++i * 1000));
        outPhases.add(new Phase(Phase.SEND, ++i * 1000));
        outPhases.add(new Phase(Phase.SEND_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.POST_STREAM_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.USER_STREAM_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.POST_PROTOCOL_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.USER_PROTOCOL_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.WRITE_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.PRE_PROTOCOL_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.PRE_STREAM_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.PREPARE_SEND_ENDING, ++i * 1000));
        return outPhases;
    }
}
"
org.apache.camel.spring.CamelTemplateFactoryBean,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.CamelTemplate;
import org.apache.camel.Endpoint;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
/**
 * A Spring {@link FactoryBean} for creating a new {@link CamelTemplate}
 * instance with a minimum of XML
 * 
 * @version $Revision: $
 */
@XmlRootElement(name = ""camelTemplate"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelTemplateFactoryBean implements FactoryBean, InitializingBean, CamelContextAware {
    @XmlAttribute(required = false)
    private String defaultEndpoint;
    @XmlTransient
    private CamelContext camelContext;
    public void afterPropertiesSet() throws Exception {
        if (camelContext == null) {
            throw new IllegalArgumentException(""A CamelContext must be injected!"");
        }
    }
    public Object getObject() throws Exception {
        CamelContext context = getCamelContext();
        if (defaultEndpoint != null) {
            Endpoint endpoint = context.getEndpoint(defaultEndpoint);
            if (endpoint == null) {
                throw new IllegalArgumentException(""No endpoint found for URI: "" + defaultEndpoint);
            } else {
                return new CamelTemplate(context, endpoint);
            }
        }
        return new CamelTemplate(context);
    }
    public Class getObjectType() {
        return CamelTemplate.class;
    }
    public boolean isSingleton() {
        return true;
    }
    // Properties
    // -------------------------------------------------------------------------
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public String getDefaultEndpoint() {
        return defaultEndpoint;
    }
    /**
     * Sets the default endpoint URI used by default for sending message
     * exchanges
     */
    public void setDefaultEndpoint(String defaultEndpoint) {
        this.defaultEndpoint = defaultEndpoint;
    }
}
"
org.apache.camel.component.jms.RuntimeJmsException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class RuntimeJmsException extends RuntimeException {
    private static final long serialVersionUID = -2141493732308871761L;
    public RuntimeJmsException(String message, JMSException cause) {
        super(message, cause);
    }
}
"
org.apache.camel.component.cxf.invoker.InvokingContextFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import org.apache.camel.component.cxf.DataFormat;
public final class InvokingContextFactory {
    private InvokingContextFactory() {
        // not constructed
    }
    /**
     * Static method that creates a routing context object from a given data format
     * @param dataFormat
     * @return routing context
     */
    public static InvokingContext createContext(DataFormat dataFormat) {
        if (dataFormat == DataFormat.MESSAGE) {
            return new RawMessageInvokingContext();
        }
        if (dataFormat == DataFormat.PAYLOAD) {
            return new PayloadInvokingContext();
        }
        //Default is DataFormat.MESSAGE, we do not set the POJO context
        return new RawMessageInvokingContext();
    }
}
"
org.apache.camel.component.ibatis.IBatisPollingConsumer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import java.sql.SQLException;
import java.util.List;
import com.ibatis.sqlmap.client.SqlMapClient;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.PollingConsumerSupport;
/**
 * @version $Revision: 1.1 $
 */
public class IBatisPollingConsumer extends PollingConsumerSupport {
    private final IBatisEndpoint endpoint;
    private SqlMapClient sqlClient;
    private String queryName;
    public IBatisPollingConsumer(IBatisEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
        queryName = endpoint.getEntityName();
    }
    public Exchange receive(long timeout) {
        return receiveNoWait();
    }
    public Exchange receive() {
        return receiveNoWait();
    }
    public Exchange receiveNoWait() {
        try {
            if (sqlClient == null) {
                sqlClient = endpoint.getSqlClient();
            }
            List list = sqlClient.queryForList(queryName);
            Exchange exchange = endpoint.createExchange();
            Message in = exchange.getIn();
            in.setBody(list);
            in.setHeader(""org.apache.camel.ibatis.queryName"", queryName);
            return exchange;
        }
        catch (Exception e) {
            throw new RuntimeCamelException(""Failed to poll: "" + endpoint + "". Reason: "" + e, e);
        }
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
}
"
org.apache.camel.component.cxf.phase.RawMessagePhaseManagerImpl,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.phase;
import java.util.SortedSet;
import org.apache.cxf.common.util.SortedArraySet;
import org.apache.cxf.phase.Phase;
public class RawMessagePhaseManagerImpl extends AbstractPhaseManagerImpl {
    protected SortedSet<Phase> createInPhases() {
        SortedSet<Phase> inPhases = new SortedArraySet<Phase>();
        int i = 0;
        inPhases.add(new Phase(Phase.RECEIVE, ++i * 1000));
        return inPhases;
    }
    protected SortedSet<Phase> createOutPhases() {
        SortedSet<Phase> outPhases = new SortedArraySet<Phase>();
        int i = 0;
        outPhases.add(new Phase(Phase.PREPARE_SEND, ++i * 1000));
        outPhases.add(new Phase(Phase.WRITE, ++i * 1000));
        outPhases.add(new Phase(Phase.SEND, ++i * 1000));
        outPhases.add(new Phase(Phase.PREPARE_SEND_ENDING, ++i * 1000));
        return outPhases;
    }
}
"
org.apache.camel.bam.ProcessBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.bam.model.ActivityDefinition;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.processor.ActivityMonitorEngine;
import org.apache.camel.bam.processor.JpaBamProcessor;
import org.apache.camel.bam.rules.ProcessRules;
import org.apache.camel.builder.RouteBuilder;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A builder of a process definition
 * 
 * @version $Revision: $
 */
public abstract class ProcessBuilder extends RouteBuilder {
    private static int processCounter;
    private JpaTemplate jpaTemplate;
    private final TransactionTemplate transactionTemplate;
    private final String processName;
    private List<ActivityBuilder> activityBuilders = new ArrayList<ActivityBuilder>();
    private Class entityType = ProcessInstance.class;
    private ProcessRules processRules = new ProcessRules();
    private ProcessDefinition processDefinition;
    protected ProcessBuilder(JpaTemplate jpaTemplate, TransactionTemplate transactionTemplate) {
        this(jpaTemplate, transactionTemplate, createProcessName());
    }
    protected ProcessBuilder(JpaTemplate jpaTemplate, TransactionTemplate transactionTemplate, String processName) {
        this.jpaTemplate = jpaTemplate;
        this.transactionTemplate = transactionTemplate;
        this.processName = processName;
    }
    protected static synchronized String createProcessName() {
        return ""Process-"" + (++processCounter);
    }
    public ActivityBuilder activity(String endpointUri) {
        return activity(endpoint(endpointUri));
    }
    public ActivityBuilder activity(Endpoint endpoint) {
        ActivityBuilder answer = new ActivityBuilder(this, endpoint);
        activityBuilders.add(answer);
        return answer;
    }
    /**
     * Sets the process entity type used to perform state management
     */
    public ProcessBuilder entityType(Class entityType) {
        this.entityType = entityType;
        return this;
    }
    public Processor createActivityProcessor(ActivityBuilder activityBuilder) {
        notNull(jpaTemplate, ""jpaTemplate"");
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                processRules.setProcessDefinition(getProcessDefinition());
            }
        });
        return new JpaBamProcessor(getTransactionTemplate(), getJpaTemplate(), activityBuilder.getCorrelationExpression(), activityBuilder.getActivityRules(), getEntityType());
    }
    // Properties
    // -----------------------------------------------------------------------
    public List<ActivityBuilder> getActivityBuilders() {
        return activityBuilders;
    }
    public Class getEntityType() {
        return entityType;
    }
    public JpaTemplate getJpaTemplate() {
        return jpaTemplate;
    }
    public void setJpaTemplate(JpaTemplate jpaTemplate) {
        this.jpaTemplate = jpaTemplate;
    }
    public TransactionTemplate getTransactionTemplate() {
        return transactionTemplate;
    }
    public ProcessRules getProcessRules() {
        return processRules;
    }
    public String getProcessName() {
        return processName;
    }
    public ProcessDefinition getProcessDefinition() {
        if (processDefinition == null) {
            processDefinition = findOrCreateProcessDefinition();
        }
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void populateRoutes(List<Route> routes) throws Exception {
        boolean first = true;
        for (ActivityBuilder builder : activityBuilders) {
            Route route = builder.createRoute();
            if (first) {
                route.getServices().add(new ActivityMonitorEngine(getJpaTemplate(), getTransactionTemplate(), getProcessRules()));
                first = false;
            }
            routes.add(route);
        }
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    public ActivityDefinition findOrCreateActivityDefinition(String activityName) {
        ProcessDefinition definition = getProcessDefinition();
        List<ActivityDefinition> list = jpaTemplate.find(""select x from "" + ActivityDefinition.class.getName() + "" x where x.processDefinition = ?1 and x.name = ?2"", definition, activityName);
        if (!list.isEmpty()) {
            return list.get(0);
        } else {
            ActivityDefinition answer = new ActivityDefinition();
            answer.setName(activityName);
            answer.setProcessDefinition(ProcessDefinition.getRefreshedProcessDefinition(jpaTemplate, definition));
            jpaTemplate.persist(answer);
            return answer;
        }
    }
    protected ProcessDefinition findOrCreateProcessDefinition() {
        List<ProcessDefinition> list = jpaTemplate.find(""select x from "" + ProcessDefinition.class.getName() + "" x where x.name = ?1"", processName);
        if (!list.isEmpty()) {
            return list.get(0);
        } else {
            ProcessDefinition answer = new ProcessDefinition();
            answer.setName(processName);
            jpaTemplate.persist(answer);
            return answer;
        }
    }
}
"
org.apache.camel.component.cxf.interceptors.AbstractMessageOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.List;
//import java.util.ResourceBundle;
//import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
//import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.helpers.DOMUtils;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
/**
 * This is the base class for message interceptors that intercepts
 * binding specific headers and message parts as DOM Element.
 * Then moves dom elements between header and message part list based on the
 * binding operation info provided in the exchange.
 */
public abstract class AbstractMessageOutInterceptor<T extends Message>
       extends AbstractPhaseInterceptor<T> {
    public AbstractMessageOutInterceptor(String phase) {
        super(phase);
    }
    protected boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    protected abstract Logger getLogger();
    protected Element createElement(QName elName, List<Element> childEl) {
        Document doc = DOMUtils.createDocument();
        String prefix = elName.getPrefix();
        StringBuilder tagName = new StringBuilder();
        if (!"""".equals(prefix)) {
            tagName.append(prefix);
            tagName.append("":"");
        }
        tagName.append(elName.getLocalPart());
        Element el = doc.createElementNS(elName.getNamespaceURI(),
                                         tagName.toString());
        if (!"""".equals(elName.getPrefix())) {
            StringBuilder attrName = new StringBuilder(""xmlns"");        
            attrName.append(':');
            attrName.append(elName.getPrefix());
            el.setAttribute(attrName.toString(), elName.getNamespaceURI());
        }
        for (Element part : childEl) {
            Node adoptedNode = doc.adoptNode(part);
            el.appendChild(adoptedNode);
        }
        return el;
    }    
}
"
org.apache.camel.component.cxf.transport.CamelTransportBase,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelTemplate;
import org.apache.camel.Exchange;
import org.apache.cxf.Bus;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.EndpointInfo;
/**
 * @version $Revision$
 */
public class CamelTransportBase {
    CamelTemplate<Exchange> template;
    Bus bus;
    EndpointInfo endpointInfo;
    private String replyDestination;
    private final CamelContext camelContext;
    public CamelTransportBase(CamelContext camelContext, Bus bus, EndpointInfo endpointInfo, boolean b, String baseBeanNameSuffix) {
        this.camelContext = camelContext;
        this.bus = bus;
        this.endpointInfo = endpointInfo;
        this.template = new CamelTemplate<Exchange>(camelContext);
    }
    public void populateIncomingContext(Exchange exchange, MessageImpl inMessage, String camelServerRequestHeaders) {
    }
    public String getReplyDestination() {
        return replyDestination;
    }
    public void setMessageProperties(Message inMessage, Exchange reply) {
    }
    public void close() {
        if (template != null) {
            try {
                template.stop();
            } catch (Exception e) {
                // do nothing?
                // TODO
            }
        }
    }
    /**
     * Populates a Camel exchange with a payload
     * 
     * @param payload the message payload, expected to be either of type String
     *                or byte[] depending on payload type
     * @param replyTo the ReplyTo destination if any
     * @param exchange the underlying exchange to marshal to
     */
    protected void marshal(Object payload, String replyTo, Exchange exchange) {
        org.apache.camel.Message message = exchange.getIn();
        message.setBody(payload);
        if (replyTo != null) {
            message.setHeader(CamelConstants.CAMEL_CORRELATION_ID, replyTo);
        }
    }
    /**
     * Unmarshal the payload of an incoming message.
     */
    public byte[] unmarshal(Exchange exchange) {
        return exchange.getIn().getBody(byte[].class);
    }
    /*
     * protected CamelMessageHeadersType
     * populateIncomingContext(javax.camel.Message message,
     * org.apache.cxf.message.Message inMessage, String headerType) throws
     * CamelException { CamelMessageHeadersType headers = null; headers =
     * (CamelMessageHeadersType)inMessage.get(headerType); if (headers == null) {
     * headers = new CamelMessageHeadersType(); inMessage.put(headerType,
     * headers); }
     * headers.setCamelCorrelationID(message.getCamelCorrelationID());
     * headers.setCamelDeliveryMode(new
     * Integer(message.getCamelDeliveryMode())); headers.setCamelExpiration(new
     * Long(message.getCamelExpiration()));
     * headers.setCamelMessageID(message.getCamelMessageID());
     * headers.setCamelPriority(new Integer(message.getCamelPriority()));
     * headers.setCamelRedelivered(Boolean.valueOf(message.getCamelRedelivered()));
     * headers.setCamelTimeStamp(new Long(message.getCamelTimestamp()));
     * headers.setCamelType(message.getCamelType()); List<CamelPropertyType>
     * props = headers.getProperty(); Enumeration enm =
     * message.getPropertyNames(); while (enm.hasMoreElements()) { String name =
     * (String)enm.nextElement(); String val = message.getStringProperty(name);
     * CamelPropertyType prop = new CamelPropertyType(); prop.setName(name);
     * prop.setValue(val); props.add(prop); } return headers; } protected int
     * getCamelDeliveryMode(CamelMessageHeadersType headers) { int deliveryMode =
     * Message.DEFAULT_DELIVERY_MODE; if (headers != null &&
     * headers.isSetCamelDeliveryMode()) { deliveryMode =
     * headers.getCamelDeliveryMode(); } return deliveryMode; } protected int
     * getCamelPriority(CamelMessageHeadersType headers) { int priority =
     * Message.DEFAULT_PRIORITY; if (headers != null &&
     * headers.isSetCamelPriority()) { priority = headers.getCamelPriority(); }
     * return priority; } protected long getTimeToLive(CamelMessageHeadersType
     * headers) { long ttl = -1; if (headers != null &&
     * headers.isSetTimeToLive()) { ttl = headers.getTimeToLive(); } return ttl; }
     * protected String getCorrelationId(CamelMessageHeadersType headers) {
     * String correlationId = null; if (headers != null &&
     * headers.isSetCamelCorrelationID()) { correlationId =
     * headers.getCamelCorrelationID(); } return correlationId; } protected
     * String getAddrUriFromCamelAddrPolicy() { AddressType camelAddressPolicy =
     * transport.getCamelAddress(); return ""camel:"" +
     * camelAddressPolicy.getJndiConnectionFactoryName() + ""#"" +
     * camelAddressPolicy.getJndiDestinationName(); } protected String
     * getReplyTotAddrUriFromCamelAddrPolicy() { AddressType camelAddressPolicy =
     * transport.getCamelAddress(); return ""camel:"" +
     * camelAddressPolicy.getJndiConnectionFactoryName() + ""#"" +
     * camelAddressPolicy.getJndiReplyDestinationName(); } protected boolean
     * isDestinationStyleQueue() { return CamelConstants.CAMEL_QUEUE.equals(
     * transport.getCamelAddress().getDestinationStyle().value()); }
     */
}
"
org.apache.camel.component.xmpp.XmppConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.util.Iterator;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.PacketListener;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Packet;
import org.jivesoftware.smack.packet.RosterPacket;
/**
 * A {@link Consumer} which listens to XMPP packets
 * 
 * @version $Revision$
 */
public class XmppConsumer extends DefaultConsumer<XmppExchange> implements PacketListener {
    private static final transient Log LOG = LogFactory.getLog(XmppConsumer.class);
    private final XmppEndpoint endpoint;
    public XmppConsumer(XmppEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        endpoint.getConnection().addPacketListener(this, endpoint.getFilter());
    }
    @Override
    protected void doStop() throws Exception {
        endpoint.getConnection().removePacketListener(this);
        super.doStop();
    }
    public void processPacket(Packet packet) {
        if (packet instanceof Message) {
            Message message = (Message)packet;
            if (LOG.isDebugEnabled()) {
                LOG.debug(""<<<< message: "" + message.getBody());
            }
            XmppExchange exchange = endpoint.createExchange(message);
            try {
                getProcessor().process(exchange);
            } catch (Exception e) {
                // TODO: what should we do when a processing failure occurs??
                e.printStackTrace();
            }
        } else if (packet instanceof RosterPacket) {
            RosterPacket rosterPacket = (RosterPacket)packet;
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Roster packet with : "" + rosterPacket.getRosterItemCount() + "" item(s)"");
                Iterator rosterItems = rosterPacket.getRosterItems();
                while (rosterItems.hasNext()) {
                    Object item = rosterItems.next();
                    LOG.debug(""Roster item: "" + item);
                }
            }
        } else {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""<<<< ignored packet: "" + packet);
            }
        }
    }
}
"
org.apache.camel.component.validator.jing.RelaxNGCompactSyntaxComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator.jing;
import java.util.Map;
/**
 * A component for validating the XML payload using
 * <a href=""http://www.oasis-open.org/committees/relax-ng/compact-20021121.html"">RelaxNG Compact Syntax</a> using the
 * <a href=""http://www.thaiopensource.com/relaxng/jing.html"">Jing library</a>
 *
 * @version $Revision: 1.1 $
 */
public class RelaxNGCompactSyntaxComponent extends JingComponent {
    protected void configureValidator(JingValidator validator, String uri, String remaining, Map parameters) throws Exception {
        validator.setCompactSyntax(true);
        super.configureValidator(validator, uri, remaining, parameters);
    }
}
"
org.apache.camel.builder.script.ScriptEvaluationException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.RuntimeCamelException;
/**
 * An exception thrown if the script evaluation fails
 * 
 * @version $Revision$
 */
public class ScriptEvaluationException extends RuntimeCamelException {
    public ScriptEvaluationException(String message) {
        super(message);
    }
    public ScriptEvaluationException(String message, Throwable cause) {
        super(message, cause);
    }
    public ScriptEvaluationException(Throwable cause) {
        super(cause);
    }
}
"
org.apache.camel.language.juel.EL,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.juel;
import org.apache.camel.language.LanguageAnnotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation for injection of EL (JSP & JSF) expressions into method parameters, fields or properties
 *
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""el"")
public @interface EL {
    public String value();
}"
org.apache.camel.component.jms.MessageListenerProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import javax.jms.MessageListener;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
/**
 * Represents a JMS {@link MessageListener} which can be used directly with any
 * JMS template or derived from to create an MDB for processing messages using a
 * {@link Processor}
 * 
 * @version $Revision:520964 $
 */
public class MessageListenerProcessor implements MessageListener {
    private final JmsEndpoint endpoint;
    private final Processor processor;
    public MessageListenerProcessor(JmsEndpoint endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
    }
    public void onMessage(Message message) {
        try {
            Exchange exchange = endpoint.createExchange(message);
            processor.process(exchange);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
}
"
org.apache.camel.component.jms.JmsConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.ConnectionFactory;
import javax.jms.ExceptionListener;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageProducer;
import javax.jms.QueueSender;
import javax.jms.Session;
import javax.jms.TopicPublisher;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.util.ObjectHelper;
import org.springframework.core.task.TaskExecutor;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer;
import org.springframework.jms.listener.DefaultMessageListenerContainer102;
import org.springframework.jms.listener.SimpleMessageListenerContainer;
import org.springframework.jms.listener.SimpleMessageListenerContainer102;
import org.springframework.jms.listener.serversession.ServerSessionFactory;
import org.springframework.jms.listener.serversession.ServerSessionMessageListenerContainer;
import org.springframework.jms.listener.serversession.ServerSessionMessageListenerContainer102;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.destination.DestinationResolver;
import org.springframework.transaction.PlatformTransactionManager;
/**
 * @version $Revision$
 */
public class JmsConfiguration implements Cloneable {
    protected static final String TRANSACTED = ""TRANSACTED"";
    protected static final String CLIENT_ACKNOWLEDGE = ""CLIENT_ACKNOWLEDGE"";
    protected static final String AUTO_ACKNOWLEDGE = ""AUTO_ACKNOWLEDGE"";
    protected static final String DUPS_OK_ACKNOWLEDGE = ""DUPS_OK_ACKNOWLEDGE"";
    private JmsOperations jmsOperations;
    private DestinationResolver destinationResolver;
    private ConnectionFactory connectionFactory;
    private ConnectionFactory templateConnectionFactory;
    private ConnectionFactory listenerConnectionFactory;
    private int acknowledgementMode = -1;
    private String acknowledgementModeName = null;
    // Used to configure the spring Container
    private ExceptionListener exceptionListener;
    private ConsumerType consumerType = ConsumerType.Default;
    private boolean autoStartup = true;
    private boolean acceptMessagesWhileStopping;
    private String clientId;
    private String durableSubscriptionName;
    private boolean subscriptionDurable;
    private boolean exposeListenerSession = true;
    private TaskExecutor taskExecutor;
    private boolean pubSubNoLocal;
    private int concurrentConsumers = 1;
    private int maxMessagesPerTask = 1;
    private ServerSessionFactory serverSessionFactory;
    private int cacheLevel = -1;
    private String cacheLevelName = ""CACHE_CONNECTION"";
    private long recoveryInterval = -1;
    private long receiveTimeout = -1;
    private int idleTaskExecutionLimit = 1;
    private int maxConcurrentConsumers = 1;
    // JmsTemplate only
    private boolean useVersion102;
    private boolean explicitQosEnabled;
    private boolean deliveryPersistent = true;
    private long timeToLive = -1;
    private MessageConverter messageConverter;
    private boolean messageIdEnabled = true;
    private boolean messageTimestampEnabled = true;
    private int priority = -1;
    // Transaction related configuration
    private boolean transacted;
    private PlatformTransactionManager transactionManager;
    private String transactionName;
    private int transactionTimeout = -1;
    private boolean preserveMessageQos;
    public JmsConfiguration() {
    }
    public JmsConfiguration(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }
    /**
     * Returns a copy of this configuration
     */
    public JmsConfiguration copy() {
        try {
            return (JmsConfiguration)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public JmsOperations createJmsOperations(boolean pubSubDomain, String destination) {
        if ( jmsOperations !=null ) {
            return jmsOperations;
        }
        ConnectionFactory factory = getTemplateConnectionFactory();
        // I whish the spring templates had built in support for preserving the message
        // qos when doing a send. :(  
        JmsTemplate template = useVersion102 ? new JmsTemplate102(factory, pubSubDomain) {
            /**
             * Override so we can support preserving the Qos settings that have
             * been set on the message.
             */
            @Override
            protected void doSend(MessageProducer producer, Message message) throws JMSException {
                if (preserveMessageQos) {
                    long ttl = message.getJMSExpiration();
                    if (ttl != 0) {
                        ttl = ttl - System.currentTimeMillis();
                        // Message had expired.. so set the ttl as small as
                        // possible
                        if (ttl <= 0) {
                            ttl = 1;
                        }
                    }
                    if (isPubSubDomain()) {
                        ((TopicPublisher)producer).publish(message, message.getJMSDeliveryMode(), message.getJMSPriority(), ttl);
                    } else {
                        ((QueueSender)producer).send(message, message.getJMSDeliveryMode(), message.getJMSPriority(), ttl);
                    }
                } else {
                    super.doSend(producer, message);
                }
            }
        } : new JmsTemplate(factory) {
            /**
             * Override so we can support preserving the Qos settings that have
             * been set on the message.
             */
            @Override
            protected void doSend(MessageProducer producer, Message message) throws JMSException {
                if (preserveMessageQos) {
                    long ttl = message.getJMSExpiration();
                    if (ttl != 0) {
                        ttl = ttl - System.currentTimeMillis();
                        // Message had expired.. so set the ttl as small as
                        // possible
                        if (ttl <= 0) {
                            ttl = 1;
                        }
                    }
                    producer.send(message, message.getJMSDeliveryMode(), message.getJMSPriority(), ttl);
                } else {
                    super.doSend(producer, message);
                }
            }
        };
        template.setPubSubDomain(pubSubDomain);
        if( destinationResolver!=null ) {
            template.setDestinationResolver(destinationResolver);
        }
        template.setDefaultDestinationName(destination);
        template.setExplicitQosEnabled(explicitQosEnabled);
        template.setDeliveryPersistent(deliveryPersistent);
        if (messageConverter != null) {
            template.setMessageConverter(messageConverter);
        }
        template.setMessageIdEnabled(messageIdEnabled);
        template.setMessageTimestampEnabled(messageTimestampEnabled);
        if (priority >= 0) {
            template.setPriority(priority);
        }
        template.setPubSubNoLocal(pubSubNoLocal);
        if (receiveTimeout >= 0) {
            template.setReceiveTimeout(receiveTimeout);
        }
        if (timeToLive >= 0) {
            template.setTimeToLive(timeToLive);
        }
        template.setSessionTransacted(transacted);
        if (transacted) {
            template.setSessionAcknowledgeMode(Session.SESSION_TRANSACTED);
        }
        else {
            // This is here for completeness, but the template should not get used
            // for receiving messages.
            if (acknowledgementMode >= 0) {
                template.setSessionAcknowledgeMode(acknowledgementMode);
            } else if (acknowledgementModeName != null) {
                template.setSessionAcknowledgeModeName(acknowledgementModeName);
            }
        }
        return template;
    }
    public AbstractMessageListenerContainer createMessageListenerContainer() {
        AbstractMessageListenerContainer container = chooseMessageListenerContainerImplementation();
        configureMessageListenerContainer(container);
        return container;
    }
    protected void configureMessageListenerContainer(AbstractMessageListenerContainer container) {
        container.setConnectionFactory(getListenerConnectionFactory());
        if( destinationResolver!=null ) {
            container.setDestinationResolver(destinationResolver);
        }
        if (autoStartup) {
            container.setAutoStartup(true);
        }
        if (clientId != null) {
            container.setClientId(clientId);
        }
        container.setSubscriptionDurable(subscriptionDurable);
        if (durableSubscriptionName != null) {
            container.setDurableSubscriptionName(durableSubscriptionName);
        }
        // lets default to durable subscription if the subscriber name and
        // client ID are specified (as there's
        // no reason to specify them if not! :)
        if (durableSubscriptionName != null && clientId != null) {
            container.setSubscriptionDurable(true);
        }
        if (exceptionListener != null) {
            container.setExceptionListener(exceptionListener);
        }
        container.setAcceptMessagesWhileStopping(acceptMessagesWhileStopping);
        container.setExposeListenerSession(exposeListenerSession);
        container.setSessionTransacted(transacted);
        if (transacted) {
            container.setSessionAcknowledgeMode(Session.SESSION_TRANSACTED);
        }
        else {
            if (acknowledgementMode >= 0) {
                container.setSessionAcknowledgeMode(acknowledgementMode);
            } else if (acknowledgementModeName != null) {
                container.setSessionAcknowledgeModeName(acknowledgementModeName);
            }
        }
        if (container instanceof DefaultMessageListenerContainer) {
            // this includes DefaultMessageListenerContainer102
            DefaultMessageListenerContainer listenerContainer = (DefaultMessageListenerContainer)container;
            if (concurrentConsumers >= 0) {
                listenerContainer.setConcurrentConsumers(concurrentConsumers);
            }
            if (cacheLevel >= 0) {
                listenerContainer.setCacheLevel(cacheLevel);
            } else if (cacheLevelName != null) {
                listenerContainer.setCacheLevelName(cacheLevelName);
            } else {
                // Default to CACHE_CONSUMER unless specified. This works best
                // with most JMS providers.
                listenerContainer.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);
            }
            if (idleTaskExecutionLimit >= 0) {
                listenerContainer.setIdleTaskExecutionLimit(idleTaskExecutionLimit);
            }
            if (maxConcurrentConsumers >= 0) {
                listenerContainer.setMaxConcurrentConsumers(maxConcurrentConsumers);
            }
            if (maxMessagesPerTask >= 0) {
                listenerContainer.setMaxMessagesPerTask(maxMessagesPerTask);
            }
            listenerContainer.setPubSubNoLocal(pubSubNoLocal);
            if (receiveTimeout >= 0) {
                listenerContainer.setReceiveTimeout(receiveTimeout);
            }
            if (recoveryInterval >= 0) {
                listenerContainer.setRecoveryInterval(recoveryInterval);
            }
            if (taskExecutor != null) {
                listenerContainer.setTaskExecutor(taskExecutor);
            }
            if (transactionManager != null) {
                listenerContainer.setTransactionManager(transactionManager);
            }
            else if (transacted) {
                throw new IllegalArgumentException(""Property transacted is enabled but a transactionManager was not injected!"");
            }
            if (transactionName != null) {
                listenerContainer.setTransactionName(transactionName);
            }
            if (transactionTimeout >= 0) {
                listenerContainer.setTransactionTimeout(transactionTimeout);
            }
        } else if (container instanceof ServerSessionMessageListenerContainer) {
            // this includes ServerSessionMessageListenerContainer102
            ServerSessionMessageListenerContainer listenerContainer = (ServerSessionMessageListenerContainer)container;
            if (maxMessagesPerTask >= 0) {
                listenerContainer.setMaxMessagesPerTask(maxMessagesPerTask);
            }
            if (serverSessionFactory != null) {
                listenerContainer.setServerSessionFactory(serverSessionFactory);
            }
        } else if (container instanceof SimpleMessageListenerContainer) {
            // this includes SimpleMessageListenerContainer102
            SimpleMessageListenerContainer listenerContainer = (SimpleMessageListenerContainer)container;
            if (concurrentConsumers >= 0) {
                listenerContainer.setConcurrentConsumers(concurrentConsumers);
            }
            listenerContainer.setPubSubNoLocal(pubSubNoLocal);
            if (taskExecutor != null) {
                listenerContainer.setTaskExecutor(taskExecutor);
            }
        }
    }
    // Properties
    // -------------------------------------------------------------------------
    public ConnectionFactory getConnectionFactory() {
        if (connectionFactory == null) {
            connectionFactory = createConnectionFactory();
        }
        return connectionFactory;
    }
    /**
     * Sets the default connection factory to be used if a connection factory is
     * not specified for either
     * {@link #setTemplateConnectionFactory(ConnectionFactory)} or
     * {@link #setListenerConnectionFactory(ConnectionFactory)}
     * 
     * @param connectionFactory the default connection factory to use
     */
    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }
    public ConnectionFactory getListenerConnectionFactory() {
        if (listenerConnectionFactory == null) {
            listenerConnectionFactory = createListenerConnectionFactory();
        }
        return listenerConnectionFactory;
    }
    /**
     * Sets the connection factory to be used for consuming messages via the
     * {@link #createMessageListenerContainer()}
     * 
     * @param listenerConnectionFactory the connection factory to use for
     *                consuming messages
     */
    public void setListenerConnectionFactory(ConnectionFactory listenerConnectionFactory) {
        this.listenerConnectionFactory = listenerConnectionFactory;
    }
    public ConnectionFactory getTemplateConnectionFactory() {
        if (templateConnectionFactory == null) {
            templateConnectionFactory = createTemplateConnectionFactory();
        }
        return templateConnectionFactory;
    }
    /**
     * Sets the connection factory to be used for sending messages via the
     * {@link JmsTemplate} via {@link #createJmsOperations(boolean, String)}
     * 
     * @param templateConnectionFactory the connection factory for sending
     *                messages
     */
    public void setTemplateConnectionFactory(ConnectionFactory templateConnectionFactory) {
        this.templateConnectionFactory = templateConnectionFactory;
    }
    public boolean isUseVersion102() {
        return useVersion102;
    }
    public void setUseVersion102(boolean useVersion102) {
        this.useVersion102 = useVersion102;
    }
    public boolean isAutoStartup() {
        return autoStartup;
    }
    public void setAutoStartup(boolean autoStartup) {
        this.autoStartup = autoStartup;
    }
    public boolean isAcceptMessagesWhileStopping() {
        return acceptMessagesWhileStopping;
    }
    public void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping) {
        this.acceptMessagesWhileStopping = acceptMessagesWhileStopping;
    }
    public String getClientId() {
        return clientId;
    }
    public void setClientId(String consumerClientId) {
        this.clientId = consumerClientId;
    }
    public String getDurableSubscriptionName() {
        return durableSubscriptionName;
    }
    public void setDurableSubscriptionName(String durableSubscriptionName) {
        this.durableSubscriptionName = durableSubscriptionName;
    }
    public ExceptionListener getExceptionListener() {
        return exceptionListener;
    }
    public void setExceptionListener(ExceptionListener exceptionListener) {
        this.exceptionListener = exceptionListener;
    }
    public boolean isSubscriptionDurable() {
        return subscriptionDurable;
    }
    public void setSubscriptionDurable(boolean subscriptionDurable) {
        this.subscriptionDurable = subscriptionDurable;
    }
    public String getAcknowledgementModeName() {
        return acknowledgementModeName;
    }
    public void setAcknowledgementModeName(String consumerAcknowledgementMode) {
        this.acknowledgementModeName = consumerAcknowledgementMode;
        this.acknowledgementMode = -1;
    }
    public boolean isExposeListenerSession() {
        return exposeListenerSession;
    }
    public void setExposeListenerSession(boolean exposeListenerSession) {
        this.exposeListenerSession = exposeListenerSession;
    }
    public TaskExecutor getTaskExecutor() {
        return taskExecutor;
    }
    public void setTaskExecutor(TaskExecutor taskExecutor) {
        this.taskExecutor = taskExecutor;
    }
    public boolean isPubSubNoLocal() {
        return pubSubNoLocal;
    }
    public void setPubSubNoLocal(boolean pubSubNoLocal) {
        this.pubSubNoLocal = pubSubNoLocal;
    }
    public int getConcurrentConsumers() {
        return concurrentConsumers;
    }
    public void setConcurrentConsumers(int concurrentConsumers) {
        this.concurrentConsumers = concurrentConsumers;
    }
    public int getMaxMessagesPerTask() {
        return maxMessagesPerTask;
    }
    public void setMaxMessagesPerTask(int maxMessagesPerTask) {
        this.maxMessagesPerTask = maxMessagesPerTask;
    }
    public ServerSessionFactory getServerSessionFactory() {
        return serverSessionFactory;
    }
    public void setServerSessionFactory(ServerSessionFactory serverSessionFactory) {
        this.serverSessionFactory = serverSessionFactory;
    }
    public int getCacheLevel() {
        return cacheLevel;
    }
    public void setCacheLevel(int cacheLevel) {
        this.cacheLevel = cacheLevel;
    }
    public String getCacheLevelName() {
        return cacheLevelName;
    }
    public void setCacheLevelName(String cacheName) {
        this.cacheLevelName = cacheName;
    }
    public long getRecoveryInterval() {
        return recoveryInterval;
    }
    public void setRecoveryInterval(long recoveryInterval) {
        this.recoveryInterval = recoveryInterval;
    }
    public long getReceiveTimeout() {
        return receiveTimeout;
    }
    public void setReceiveTimeout(long receiveTimeout) {
        this.receiveTimeout = receiveTimeout;
    }
    public PlatformTransactionManager getTransactionManager() {
        return transactionManager;
    }
    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }
    public String getTransactionName() {
        return transactionName;
    }
    public void setTransactionName(String transactionName) {
        this.transactionName = transactionName;
    }
    public int getTransactionTimeout() {
        return transactionTimeout;
    }
    public void setTransactionTimeout(int transactionTimeout) {
        this.transactionTimeout = transactionTimeout;
    }
    public int getIdleTaskExecutionLimit() {
        return idleTaskExecutionLimit;
    }
    public void setIdleTaskExecutionLimit(int idleTaskExecutionLimit) {
        this.idleTaskExecutionLimit = idleTaskExecutionLimit;
    }
    public int getMaxConcurrentConsumers() {
        return maxConcurrentConsumers;
    }
    public void setMaxConcurrentConsumers(int maxConcurrentConsumers) {
        this.maxConcurrentConsumers = maxConcurrentConsumers;
    }
    public boolean isExplicitQosEnabled() {
        return explicitQosEnabled;
    }
    public void setExplicitQosEnabled(boolean explicitQosEnabled) {
        this.explicitQosEnabled = explicitQosEnabled;
    }
    public boolean isDeliveryPersistent() {
        return deliveryPersistent;
    }
    public void setDeliveryPersistent(boolean deliveryPersistent) {
        this.deliveryPersistent = deliveryPersistent;
    }
    public long getTimeToLive() {
        return timeToLive;
    }
    public void setTimeToLive(long timeToLive) {
        this.timeToLive = timeToLive;
    }
    public MessageConverter getMessageConverter() {
        return messageConverter;
    }
    public void setMessageConverter(MessageConverter messageConverter) {
        this.messageConverter = messageConverter;
    }
    public boolean isMessageIdEnabled() {
        return messageIdEnabled;
    }
    public void setMessageIdEnabled(boolean messageIdEnabled) {
        this.messageIdEnabled = messageIdEnabled;
    }
    public boolean isMessageTimestampEnabled() {
        return messageTimestampEnabled;
    }
    public void setMessageTimestampEnabled(boolean messageTimestampEnabled) {
        this.messageTimestampEnabled = messageTimestampEnabled;
    }
    public int getPriority() {
        return priority;
    }
    public void setPriority(int priority) {
        this.priority = priority;
    }
    public ConsumerType getConsumerType() {
        return consumerType;
    }
    public void setConsumerType(ConsumerType consumerType) {
        this.consumerType = consumerType;
    }
    public int getAcknowledgementMode() {
        return acknowledgementMode;
    }
    public void setAcknowledgementMode(int consumerAcknowledgementMode) {
        this.acknowledgementMode = consumerAcknowledgementMode;
        this.acknowledgementModeName = null;
    }
    public boolean isTransacted() {
        return transacted;
    }
    public void setTransacted(boolean consumerTransacted) {
        this.transacted = consumerTransacted;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected AbstractMessageListenerContainer chooseMessageListenerContainerImplementation() {
        // TODO we could allow a spring container to auto-inject these objects?
        switch (consumerType) {
        case Simple:
            return isUseVersion102() ? new SimpleMessageListenerContainer102() : new SimpleMessageListenerContainer();
        case ServerSessionPool:
            return isUseVersion102() ? new ServerSessionMessageListenerContainer102() : new ServerSessionMessageListenerContainer();
        case Default:
            return isUseVersion102() ? new DefaultMessageListenerContainer102() : new DefaultMessageListenerContainer();
        default:
            throw new IllegalArgumentException(""Unknown consumer type: "" + consumerType);
        }
    }
    /**
     * Factory method which allows derived classes to customize the lazy
     * creation
     */
    protected ConnectionFactory createConnectionFactory() {
        ObjectHelper.notNull(connectionFactory, ""connectionFactory"");
        return null;
    }
    /**
     * Factory method which allows derived classes to customize the lazy
     * creation
     */
    protected ConnectionFactory createListenerConnectionFactory() {
        return getConnectionFactory();
    }
    /**
     * Factory method which allows derived classes to customize the lazy
     * creation
     */
    protected ConnectionFactory createTemplateConnectionFactory() {
        return getConnectionFactory();
    }
    public boolean isPreserveMessageQos() {
        return preserveMessageQos;
    }
    /**
     * Set to true if you want to send message using the QoS settings specified 
     * on the message.  Normally the QoS settings used are the one configured
     * on this Object.
     * 
     * @param preserveMessageQos
     */
    public void setPreserveMessageQos(boolean preserveMessageQos) {
        this.preserveMessageQos = preserveMessageQos;
    }
    public JmsOperations getJmsOperations() {
        return jmsOperations;
    }
    public void setJmsOperations(JmsOperations jmsOperations) {
        this.jmsOperations = jmsOperations;
    }
    public DestinationResolver getDestinationResolver() {
        return destinationResolver;
    }
    public void setDestinationResolver(DestinationResolver destinationResolver) {
        this.destinationResolver = destinationResolver;
    }
}
"
org.apache.camel.component.jms.MessagePropertyAccessException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision:520964 $
 */
public class MessagePropertyAccessException extends RuntimeJmsException {
    private static final long serialVersionUID = -3996286386119163309L;
    private final String propertyName;
    public MessagePropertyAccessException(String propertyName, JMSException e) {
        super(""Error accessing header: "" + propertyName, e);
        this.propertyName = propertyName;
    }
    public String getPropertyName() {
        return propertyName;
    }
}
"
org.apache.camel.component.cxf.interceptors.RawMessageInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.logging.Logger;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.phase.Phase;
public class RawMessageInInterceptor extends AbstractInvokerInterceptor {
    private static final Logger LOG = LogUtils.getL7dLogger(RawMessageInInterceptor.class); 
    public RawMessageInInterceptor() {
        super(Phase.RECEIVE);
    }
    @Override
    protected Logger getLogger() {
        return LOG;
    }
}
"
org.apache.camel.converter.jaxb.PropertyType,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""property"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class PropertyType {
    @XmlAttribute
    private String key;
    @XmlAnyElement(lax = true)
    private Object value;
    public String getKey() {
        return key;
    }
    public void setKey(String key) {
        this.key = key;
    }
    public Object getValue() {
        return value;
    }
    public void setValue(Object value) {
        this.value = value;
    }
}"
org.apache.camel.spring.CamelServiceExporterType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import org.apache.camel.model.IdentifiedType;
/**
 * @version $Revision: $
*/
@XmlRootElement(name = ""export"")
public class CamelServiceExporterType extends IdentifiedType {
    @XmlAttribute
    private String uri;
    @XmlAttribute
    private String serviceRef;
    @XmlAttribute
    private Class serviceInterface;
}
"
org.apache.camel.component.xmpp.XmppExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.jivesoftware.smack.packet.Message;
/**
 * Represents an {@ilnk Exchange} for working with XMPP
 *
 * @version $Revision:520964 $
 */
public class XmppExchange extends DefaultExchange {
    private XmppBinding binding;
    public XmppExchange(CamelContext context, ExchangePattern pattern, XmppBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public XmppExchange(CamelContext context, ExchangePattern pattern, XmppBinding binding, Message message) {
        this(context, pattern, binding);
        setIn(new XmppMessage(message));
    }
    @Override
    public XmppMessage getIn() {
        return (XmppMessage) super.getIn();
    }
    @Override
    public XmppMessage getOut() {
        return (XmppMessage) super.getOut();
    }
    @Override
    public XmppMessage getOut(boolean lazyCreate) {
        return (XmppMessage) super.getOut(lazyCreate);
    }
    @Override
    public XmppMessage getFault() {
        return (XmppMessage) super.getFault();
    }
    public XmppBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new XmppExchange(getContext(), getPattern(), binding);
    }
    // Expose the underlying XMPP APIs
    //-------------------------------------------------------------------------
    /**
     * Return the underlying XMPP In message
     *
     * @return the XMPP In message
     */
    public Message getInMessage() {
        return getIn().getXmppMessage();
    }
    /**
     * Return the underlying XMPP Out message
     *
     * @return the XMPP out message
     */
    public Message getOutMessage() {
        return getOut().getXmppMessage();
    }
    /**
     * Return the underlying XMPP Fault message
     *
     * @return the XMPP fault message
     */
    public Message getFaultMessage() {
        return getOut().getXmppMessage();
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected XmppMessage createInMessage() {
        return new XmppMessage();
    }
    @Override
    protected XmppMessage createOutMessage() {
        return new XmppMessage();
    }
}
"
org.apache.camel.component.mail.RuntimeMailException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
/**
 * @version $Revision:520964 $
 */
public class RuntimeMailException extends RuntimeException {
    private static final long serialVersionUID = -2141493732308871761L;
    public RuntimeMailException(String message, Throwable cause) {
        super(message, cause);
    }
}
"
org.apache.camel.component.cxf.interceptors.PayloadInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.logging.Logger;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.phase.Phase;
public class PayloadInInterceptor extends AbstractInvokerInterceptor {
    private static final Logger LOG = LogUtils.getL7dLogger(PayloadInInterceptor.class); 
    public PayloadInInterceptor() {
        super(Phase.READ);       
    }
    @Override
    protected Logger getLogger() {
        return LOG;
    }
}"
org.apache.camel.component.cxf.invoker.InvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.Map;
import org.apache.cxf.Bus;
import org.apache.cxf.endpoint.EndpointImpl;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.PhaseInterceptorChain;
public interface InvokingContext {
    /**
     * This method is called when an request from a (routing) client is observed
     * at the router's transport (inbound to the router from a client).  It will 
     * return an ""in"" interceptor chain that will allow the appropriate routing 
     * interceptor to receive and handle the message.
     * @param exchange
     * @return in interceptor chain
     */
    PhaseInterceptorChain getRequestInInterceptorChain(Exchange exchange);
    /**
     * This method is called when the router is preparing an outbound message 
     * (orignated from the router's client) to be sent to the target CXF server.
     * It sets the content in the given (out) message object.
     * @param content
     */
    void setRequestOutMessageContent(Message message, Object content);
    /**
     * This method is called when a response from a CXF server is observed at the
     * router's transport (inbound to the router from a server).  It will return an
     * ""in"" interceptor chain that will allow the response to be returned to the 
     * involved routing interceptor (with the appropriate interceptors in between).
     * @param exchange
     * @return in interceptor chain
     */
    PhaseInterceptorChain getResponseInInterceptorChain(Exchange exchange);
    /**
     * This method is called when the router is ready to forward a request from a client
     * to the target CXF server.  It returns an ""out"" intercetptor chain that will deliver 
     * the request message to the CXF server.
     * @param exchange
     * @return out interceptor chain
     */
    PhaseInterceptorChain getRequestOutInterceptorChain(Exchange exchange);
    /**
     * This method is called when the router is ready to forward a response from a CXF
     * to the client who has made the request. It returns an ""out"" interceptor chain that 
     * will deliver the response message to the client.
     * @param exchange
     * @return out interceptor chain
     */
    PhaseInterceptorChain getResponseOutInterceptorChain(Exchange exchange);
    /**
     * This method is call when the CxfClient receives a response from a CXF server and needs
     * to extract the response object from the message.
     * @param exchange
     * @param responseContext
     * @return response object
     */
    Object getResponseObject(Exchange exchange, Map<String, Object> responseContext);
    /**
     * This method is called to set the fault observers on the endpoint that are specified
     * to the phases meaningful to the routing context.
     * @param endpointImpl
     * @param bus
     */
    void setEndpointFaultObservers(EndpointImpl endpointImpl, Bus bus);
    /**
     * This method is called when the routing interceptor has received a response message
     * from the target CXF server and needs to set the response in the outgoing message
     * that is to be sent to the client.
     * @param outMessage
     * @param resultPayload
     */
    void setResponseContent(Message outMessage, Object resultPayload);
    /**
     * This method is called when the routing interceptor has intercepted a message from
     * the client and needs to extract the request content from the message.  It retreives
     * and receives the request content from the incoming message. 
     * @param inMessage
     * @return the request from client
     */
    Object getRequestContent(Message inMessage);
}
"
org.apache.camel.spring.CamelBeanPostProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.*;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.spring.util.ReflectionUtils;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.isNotNullAndNonEmpty;
import static org.apache.camel.util.ObjectHelper.isNullOrBlank;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlTransient;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
/**
 * A post processor to perform injection of {@link Endpoint} and
 * {@link Producer} instances together with binding methods annotated with
 * {@link @MessageDriven} to a Camel consumer.
 * 
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""beanPostProcessor"")
@XmlAccessorType(XmlAccessType.FIELD)
public class CamelBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware {
    private static final transient Log LOG = LogFactory.getLog(CamelBeanPostProcessor.class);
    @XmlTransient
    private SpringCamelContext camelContext;
    @XmlTransient
    private ApplicationContext applicationContext;
    // private List<Consumer> consumers = new ArrayList<Consumer>();
    public CamelBeanPostProcessor() {
    }
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        injectFields(bean);
        injectMethods(bean);
        if (bean instanceof CamelContextAware) {
            CamelContextAware contextAware = (CamelContextAware)bean;
            if (camelContext == null) {
                LOG.warn(""No CamelContext defined yet so cannot inject into: "" + bean);
            } else {
                contextAware.setCamelContext(camelContext);
            }
        }
        return bean;
    }
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
    // Properties
    // -------------------------------------------------------------------------
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public SpringCamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(SpringCamelContext camelContext) {
        this.camelContext = camelContext;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    /**
     * A strategy method to allow implementations to perform some custom JBI
     * based injection of the POJO
     * 
     * @param bean the bean to be injected
     */
    protected void injectFields(final Object bean) {
        ReflectionUtils.doWithFields(bean.getClass(), new ReflectionUtils.FieldCallback() {
            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {
                EndpointInject annotation = field.getAnnotation(EndpointInject.class);
                if (annotation != null) {
                    ReflectionUtils.setField(field, bean, getEndpointInjectionValue(annotation, field.getType(), field.getName()));
                }
            }
        });
    }
    protected void injectMethods(final Object bean) {
        ReflectionUtils.doWithMethods(bean.getClass(), new ReflectionUtils.MethodCallback() {
            @SuppressWarnings(""unchecked"")
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                setterInjection(method, bean);
                consumerInjection(method, bean);
            }
        });
    }
    protected void setterInjection(Method method, Object bean) {
        EndpointInject annoation = method.getAnnotation(EndpointInject.class);
        if (annoation != null) {
            Class<?>[] parameterTypes = method.getParameterTypes();
            if (parameterTypes != null) {
                if (parameterTypes.length != 1) {
                    LOG.warn(""Ignoring badly annotated method for injection due to incorrect number of parameters: "" + method);
                } else {
                    String propertyName = ObjectHelper.getPropertyName(method);
                    Object value = getEndpointInjectionValue(annoation, parameterTypes[0], propertyName);
                    ObjectHelper.invokeMethod(method, bean, value);
                }
            }
        }
    }
    protected void consumerInjection(final Object bean) {
        ReflectionUtils.doWithMethods(bean.getClass(), new ReflectionUtils.MethodCallback() {
            @SuppressWarnings(""unchecked"")
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                /*
                 * TODO support callbacks? if
                 * (method.getAnnotation(Callback.class) != null) { try {
                 * Expression e = ExpressionFactory.createExpression(
                 * method.getAnnotation(Callback.class).condition());
                 * JexlContext jc = JexlHelper.createContext();
                 * jc.getVars().put(""this"", obj); Object r = e.evaluate(jc); if
                 * (!(r instanceof Boolean)) { throw new
                 * RuntimeException(""Expression did not returned a boolean value
                 * but: "" + r); } Boolean oldVal =
                 * req.getCallbacks().get(method); Boolean newVal = (Boolean) r;
                 * if ((oldVal == null || !oldVal) && newVal) {
                 * req.getCallbacks().put(method, newVal); method.invoke(obj,
                 * new Object[0]); // TODO: handle return value and sent it as
                 * the answer } } catch (Exception e) { throw new
                 * RuntimeException(""Unable to invoke callback"", e); } }
                 */
            }
        });
    }
    protected void consumerInjection(Method method, Object bean) {
        MessageDriven annotation = method.getAnnotation(MessageDriven.class);
        if (annotation != null) {
            LOG.info(""Creating a consumer for: "" + annotation);
            // lets bind this method to a listener
            String injectionPointName = method.getName();
            Endpoint endpoint = getEndpointInjection(annotation.uri(), annotation.name(), injectionPointName);
            if (endpoint != null) {
                try {
                    Processor processor = createConsumerProcessor(bean, method, endpoint);
                    LOG.info(""Created processor: "" + processor);
                    Consumer consumer = endpoint.createConsumer(processor);
                    consumer.start();
                    onConsumerAdded(consumer);
                } catch (Exception e) {
                    LOG.warn(e);
                    throw new RuntimeCamelException(e);
                }
            }
        }
    }
    /**
     * Create a processor which invokes the given method when an incoming
     * message exchange is received
     */
    protected Processor createConsumerProcessor(final Object pojo, final Method method, final Endpoint endpoint) {
        BeanProcessor answer = new BeanProcessor(pojo, getCamelContext());
        answer.setMethod(method);
        return answer;
    }
    protected void onConsumerAdded(Consumer consumer) {
        LOG.debug(""Adding consumer: "" + consumer);
    }
    /**
     * Creates the value for the injection point for the given annotation
     */
    protected Object getEndpointInjectionValue(EndpointInject annotation, Class<?> type, String injectionPointName) {
        Endpoint endpoint = getEndpointInjection(annotation.uri(), annotation.name(), injectionPointName);
        if (endpoint != null) {
            if (type.isInstance(endpoint)) {
                return endpoint;
            } else if (type.isAssignableFrom(Producer.class)) {
                return createInjectionProducer(endpoint);
            } else if (type.isAssignableFrom(CamelTemplate.class)) {
                return new CamelTemplate(getCamelContext(), endpoint);
            } else if (type.isAssignableFrom(PollingConsumer.class)) {
                return createInjectionPollingConsumer(endpoint);
            } else {
                throw new IllegalArgumentException(""Invalid type: "" + type.getName() + "" which cannot be injected via @EndpointInject for "" + endpoint);
            }
        }
        return null;
    }
    /**
     * Factory method to create a started {@link PollingConsumer} to be injected
     * into a POJO
     */
    protected PollingConsumer createInjectionPollingConsumer(Endpoint endpoint) {
        try {
            PollingConsumer pollingConsumer = endpoint.createPollingConsumer();
            pollingConsumer.start();
            return pollingConsumer;
        }
        catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    /**
     * A Factory method to create a started {@link Producer} to be injected into a POJO
     */
    protected Producer createInjectionProducer(Endpoint endpoint) {
        try {
            Producer producer = endpoint.createProducer();
            producer.start();
            return producer;
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    protected Endpoint getEndpointInjection(String uri, String name, String injectionPointName) {
        Endpoint endpoint = null;
        if (isNotNullAndNonEmpty(uri)) {
            endpoint = camelContext.getEndpoint(uri);
        } else {
            if (isNullOrBlank(name)) {
                name = injectionPointName;
            }
            endpoint = (Endpoint) applicationContext.getBean(name);
            if (endpoint == null) {
                throw new NoSuchBeanDefinitionException(name);
            }
        }
        return endpoint;
    }
}
"
org.apache.camel.builder.script.Ruby,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.language.LanguageAnnotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation for injection of <a href=""http://ruby-lang.org/"">Ruby</a> expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""jruby"")
public @interface Ruby {
    public abstract String value();
}"
org.apache.camel.converter.jaxb.ObjectHeader,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlRootElement;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""objectHeader"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class ObjectHeader extends HeaderType {
    @XmlAnyElement(lax = true)
    private Object value;
    public ObjectHeader() {
    }
    public ObjectHeader(String name, Object value) {
        super(name);
        this.value = value;
    }
    public Object getValue() {
        return value;
    }
    public void setValue(Object value) {
        this.value = value;
    }
}
"
org.apache.camel.builder.sql.SqlBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.sql;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Message;
import org.apache.camel.Predicate;
import org.apache.camel.RuntimeExpressionException;
import org.apache.camel.util.ObjectHelper;
import org.josql.Query;
import org.josql.QueryExecutionException;
import org.josql.QueryParseException;
/**
 * A builder of SQL {@link org.apache.camel.Expression} and
 * {@link org.apache.camel.Predicate} implementations
 * 
 * @version $Revision: $
 */
public class SqlBuilder<E extends Exchange> implements Expression<E>, Predicate<E> {
    private Query query;
    private Map<String, Object> variables = new HashMap<String, Object>();
    public SqlBuilder(Query query) {
        this.query = query;
    }
    public Object evaluate(E exchange) {
        return evaluateQuery(exchange);
    }
    public boolean matches(E exchange) {
        List list = evaluateQuery(exchange);
        return matches(exchange, list);
    }
    public void assertMatches(String text, E exchange) throws AssertionError {
        List list = evaluateQuery(exchange);
        if (!matches(exchange, list)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as found "" + list);
        }
    }
    // Builder API
    // -----------------------------------------------------------------------
    /**
     * Creates a new builder for the given SQL query string
     * 
     * @param sql the SQL query to perform
     * @return a new builder
     * @throws QueryParseException if there is an issue with the SQL
     */
    public static <E extends Exchange> SqlBuilder<E> sql(String sql) throws QueryParseException {
        Query q = new Query();
        q.parse(sql);
        return new SqlBuilder(q);
    }
    /**
     * Adds the variable value to be used by the SQL query
     */
    public SqlBuilder<E> variable(String name, Object value) {
        getVariables().put(name, value);
        return this;
    }
    // Properties
    // -----------------------------------------------------------------------
    public Map<String, Object> getVariables() {
        return variables;
    }
    public void setVariables(Map<String, Object> properties) {
        this.variables = properties;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    protected boolean matches(E exchange, List list) {
        return ObjectHelper.matches(list);
    }
    protected List evaluateQuery(E exchange) {
        configureQuery(exchange);
        Message in = exchange.getIn();
        List list = in.getBody(List.class);
        if (list == null) {
            list = Collections.singletonList(in.getBody());
        }
        try {
            return query.execute(list).getResults();
        } catch (QueryExecutionException e) {
            throw new RuntimeExpressionException(e);
        }
    }
    protected void configureQuery(E exchange) {
        // lets pass in the headers as variables that the SQL can use
        addVariables(exchange.getProperties());
        addVariables(exchange.getIn().getHeaders());
        addVariables(getVariables());
        query.setVariable(""exchange"", exchange);
        query.setVariable(""in"", exchange.getIn());
        query.setVariable(""out"", exchange.getOut());
    }
    protected void addVariables(Map<String, Object> map) {
        Set<Map.Entry<String, Object>> propertyEntries = map.entrySet();
        for (Map.Entry<String, Object> entry : propertyEntries) {
            query.setVariable(entry.getKey(), entry.getValue());
        }
    }
}
"
org.apache.camel.component.jms.JmsBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.Exchange;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.jms.BytesMessage;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.MapMessage;
import javax.jms.Message;
import javax.jms.ObjectMessage;
import javax.jms.Session;
import javax.jms.StreamMessage;
import javax.jms.TextMessage;
import java.io.Serializable;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
/**
 * A Strategy used to convert between a Camel {@JmsExchange} and {@JmsMessage}
 * to and from a JMS {@link Message}
 * 
 * @version $Revision$
 */
public class JmsBinding {
    private static final transient Log LOG = LogFactory.getLog(JmsBinding.class);
    /**
     * Extracts the body from the JMS message
     * 
     * @param exchange
     * @param message
     */
    public Object extractBodyFromJms(JmsExchange exchange, Message message) {
        try {
            if (message instanceof ObjectMessage) {
                ObjectMessage objectMessage = (ObjectMessage)message;
                return objectMessage.getObject();
            } else if (message instanceof TextMessage) {
                TextMessage textMessage = (TextMessage)message;
                return textMessage.getText();
            } else if (message instanceof MapMessage) {
                return createMapFromMapMessage((MapMessage)message);
            } else if (message instanceof BytesMessage || message instanceof StreamMessage) {
                // TODO we need a decoder to be able to process the message
                return message;
            } else {
                return null;
            }
        } catch (JMSException e) {
            throw new RuntimeJmsException(""Failed to extract body due to: "" + e + "". Message: "" + message, e);
        }
    }
    /**
     * Creates a JMS message from the Camel exchange and message
     * 
     * @param session the JMS session used to create the message
     * @return a newly created JMS Message instance containing the
     * @throws JMSException if the message could not be created
     */
    public Message makeJmsMessage(Exchange exchange, Session session) throws JMSException {
        Message answer = null;
        if( exchange instanceof JmsExchange  ) {
            JmsExchange jmsExchange = (JmsExchange)exchange;
            answer = jmsExchange.getIn().getJmsMessage();
        }
        if( answer == null ) {
            answer = createJmsMessage(exchange.getIn().getBody(), session);
            appendJmsProperties(answer, exchange);
        }
        return answer;
    }
    /**
     * Appends the JMS headers from the Camel {@link JmsMessage}
     */
    public void appendJmsProperties(Message jmsMessage, Exchange exchange) throws JMSException {
        org.apache.camel.Message in = exchange.getIn();
        Set<Map.Entry<String, Object>> entries = in.getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            String headerName = entry.getKey();
            Object headerValue = entry.getValue();
            if (headerName.startsWith(""JMS"") && !headerName.startsWith(""JMSX"")) {
                if (headerName.equals(""JMSCorrelationID"")) {
                    jmsMessage.setJMSCorrelationID(ExchangeHelper.convertToType(exchange, String.class, headerValue));
                }
                else if (headerName.equals(""JMSCorrelationID"")) {
                    jmsMessage.setJMSCorrelationID(ExchangeHelper.convertToType(exchange, String.class, headerValue));
                }
                else if (headerName.equals(""JMSReplyTo"")) {
                    jmsMessage.setJMSReplyTo(ExchangeHelper.convertToType(exchange, Destination.class, headerValue));
                }
                else if (headerName.equals(""JMSType"")) {
                    jmsMessage.setJMSType(ExchangeHelper.convertToType(exchange, String.class, headerValue));
                }
                else if (LOG.isDebugEnabled()) {
                    // The following properties are set by the MessageProducer
                    //   JMSDeliveryMode, JMSDestination, JMSExpiration, JMSPriority,
                    // The following are set on the underlying JMS provider
                    //   JMSMessageID, JMSTimestamp, JMSRedelivered
                    LOG.debug(""Ignoring JMS header: "" + headerName + "" with value: "" + headerValue);
                }
            }
            else if (shouldOutputHeader(in, headerName, headerValue)) {
                jmsMessage.setObjectProperty(headerName, headerValue);
            }
        }
    }
    protected Message createJmsMessage(Object body, Session session) throws JMSException {
        if (body instanceof String) {
            return session.createTextMessage((String)body);
        } else if (body instanceof Serializable) {
            return session.createObjectMessage((Serializable)body);
        } else {
            return session.createMessage();
        }
    }
    /**
     * Extracts a {@link Map} from a {@link MapMessage}
     */
    public Map<String, Object> createMapFromMapMessage(MapMessage message) throws JMSException {
        Map<String, Object> answer = new HashMap<String, Object>();
        Enumeration names = message.getPropertyNames();
        while (names.hasMoreElements()) {
            String name = names.nextElement().toString();
            Object value = message.getObject(name);
            answer.put(name, value);
        }
        return answer;
    }
    /**
     * Strategy to allow filtering of headers which are put on the JMS message
     */
    protected boolean shouldOutputHeader(org.apache.camel.Message camelMessage, String headerName, Object headerValue) {
        return headerValue != null;
    }
}
"
org.apache.camel.component.quartz.QuartzExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.CamelContext;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import org.quartz.JobExecutionContext;
/**
 * @version $Revision: 1.1 $
 */
public class QuartzExchange extends DefaultExchange {
    public QuartzExchange(CamelContext context, ExchangePattern pattern, JobExecutionContext jobExecutionContext) {
        super(context, pattern);
        setIn(new QuartzMessage(this, jobExecutionContext));
    }
    @Override
    public QuartzMessage getIn() {
        return (QuartzMessage) super.getIn();
    }
    public JobExecutionContext getJobExecutionContext() {
        return getIn().getJobExecutionContext();
    }
}
"
org.apache.camel.component.validator.SpringValidator,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator;
import java.io.IOException;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import org.apache.camel.processor.validation.ValidatingProcessor;
import org.springframework.core.io.Resource;
/**
 * @version $Revision: $
 */
public class SpringValidator extends ValidatingProcessor {
    private Resource schemaResource;
    public Resource getSchemaResource() {
        return schemaResource;
    }
    public void setSchemaResource(Resource schemaResource) {
        this.schemaResource = schemaResource;
    }
    @Override
    protected Source createSchemaSource() throws IOException {
        if (schemaResource != null) {
            if (schemaResource.getURL() == null) {
                return new StreamSource(schemaResource.getInputStream());
            } else {
                return new StreamSource(schemaResource.getInputStream(), schemaResource.getURL().toExternalForm());
            }
        } else {
            throw new IllegalArgumentException(""You must specify a schema, schemaFile, schemaResource, schemaSource or schemaUrl property"");
        }
    }
}
"
org.apache.camel.component.cxf.transport.CamelConduit,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.CamelContext;
import org.apache.camel.Processor;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.configuration.Configurable;
import org.apache.cxf.configuration.Configurer;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractConduit;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.AttributedURIType;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
/**
 * @version $Revision$
 */
public class CamelConduit extends AbstractConduit implements Configurable {
    protected static final String BASE_BEAN_NAME_SUFFIX = "".camel-conduit-base"";
    private static final Logger LOG = LogUtils.getL7dLogger(CamelConduit.class);
    private final CamelTransportBase base;
    private String targetCamelEndpointUri;
    /*
     * protected ClientConfig clientConfig; protected ClientBehaviorPolicyType
     * runtimePolicy; protected AddressType address; protected SessionPoolType
     * sessionPool;
     */
    public CamelConduit(CamelContext camelContext, Bus bus, EndpointInfo endpointInfo, EndpointReferenceType targetReference) {
        super(targetReference);
        AttributedURIType address = targetReference.getAddress();
        if (address != null) {
            this.targetCamelEndpointUri = address.getValue();
        }
        base = new CamelTransportBase(camelContext, bus, endpointInfo, false, BASE_BEAN_NAME_SUFFIX);
        initConfig();
    }
    // prepare the message for send out , not actually send out the message
    public void prepare(Message message) throws IOException {
        getLogger().log(Level.FINE, ""CamelConduit send message"");
        message.setContent(OutputStream.class, new CamelOutputStream(message));
    }
    public void close() {
        getLogger().log(Level.FINE, ""CamelConduit closed "");
        // ensure resources held by session factory are released
        //
        base.close();
    }
    protected Logger getLogger() {
        return LOG;
    }
    public String getBeanName() {
        EndpointInfo info = base.endpointInfo;
        if (info == null) {
            return ""default.camel-conduit"";
        }
        return info.getName() + "".camel-conduit"";
    }
    private void initConfig() {
        /*
         * this.address = base.endpointInfo.getTraversedExtensor(new
         * AddressType(), AddressType.class); this.sessionPool =
         * base.endpointInfo.getTraversedExtensor(new SessionPoolType(),
         * SessionPoolType.class); this.clientConfig =
         * base.endpointInfo.getTraversedExtensor(new ClientConfig(),
         * ClientConfig.class); this.runtimePolicy =
         * base.endpointInfo.getTraversedExtensor(new
         * ClientBehaviorPolicyType(), ClientBehaviorPolicyType.class);
         */
        Configurer configurer = base.bus.getExtension(Configurer.class);
        if (null != configurer) {
            configurer.configureBean(this);
        }
    }
    private class CamelOutputStream extends CachedOutputStream {
        private Message outMessage;
        private boolean isOneWay;
        public CamelOutputStream(Message m) {
            outMessage = m;
        }
        protected void doFlush() throws IOException {
            // do nothing here
        }
        protected void doClose() throws IOException {
            isOneWay = outMessage.getExchange().isOneWay();
            commitOutputMessage();
            if (!isOneWay) {
                handleResponse();
            }
        }
        protected void onWrite() throws IOException {
        }
        private void commitOutputMessage() {
            base.template.send(targetCamelEndpointUri, new Processor() {
                public void process(org.apache.camel.Exchange reply) {
                    Object request = null;
                    if (isTextPayload()) {
                        request = currentStream.toString();
                    } else {
                        request = ((ByteArrayOutputStream)currentStream).toByteArray();
                    }
                    getLogger().log(Level.FINE, ""Conduit Request is :["" + request + ""]"");
                    String replyTo = base.getReplyDestination();
                    // TODO setting up the responseExpected
                    base.marshal(request, replyTo, reply);
                    base.setMessageProperties(outMessage, reply);
                    String correlationID = null;
                    if (!isOneWay) {
                        // TODO create a correlationID
                        String id = null;
                        if (id != null) {
                            if (correlationID != null) {
                                String error = ""User cannot set CamelCorrelationID when "" + ""making a request/reply invocation using "" + ""a static replyTo Queue."";
                            }
                            correlationID = id;
                        }
                    }
                    if (correlationID != null) {
                        reply.getIn().setHeader(CamelConstants.CAMEL_CORRELATION_ID, correlationID);
                    } else {
                        // No message correlation id is set. Whatever comeback
                        // will be accepted as responses.
                        // We assume that it will only happen in case of the
                        // temp. reply queue.
                    }
                    getLogger().log(Level.FINE, ""template sending request: "", reply.getIn());
                }
            });
        }
        private void handleResponse() throws IOException {
            // REVISIT distinguish decoupled case or oneway call
            Object response = null;
            // TODO if outMessage need to get the response
            Message inMessage = new MessageImpl();
            outMessage.getExchange().setInMessage(inMessage);
            // set the message header back to the incomeMessage
            // inMessage.put(CamelConstants.CAMEL_CLIENT_RESPONSE_HEADERS,
            // outMessage.get(CamelConstants.CAMEL_CLIENT_RESPONSE_HEADERS));
            /*
             * Object result1; Object result = null; javax.camel.Message
             * camelMessage1 = pooledSession.consumer().receive(timeout);
             * getLogger().log(Level.FINE, ""template received reply: "" ,
             * camelMessage1); if (camelMessage1 != null) {
             * base.populateIncomingContext(camelMessage1, outMessage,
             * CamelConstants.CAMEL_CLIENT_RESPONSE_HEADERS); String messageType =
             * camelMessage1 instanceof TextMessage ?
             * CamelConstants.TEXT_MESSAGE_TYPE :
             * CamelConstants.BINARY_MESSAGE_TYPE; result =
             * base.unmarshal((org.apache.camel.Exchange) outMessage); result1 =
             * result; } else { String error = ""CamelClientTransport.receive()
             * timed out. No message available.""; getLogger().log(Level.SEVERE,
             * error); //TODO: Review what exception should we throw. throw new
             * CamelException(error); } response = result1; //set the message
             * header back to the incomeMessage
             * inMessage.put(CamelConstants.CAMEL_CLIENT_RESPONSE_HEADERS,
             * outMessage.get(CamelConstants.CAMEL_CLIENT_RESPONSE_HEADERS));
             */
            getLogger().log(Level.FINE, ""The Response Message is : ["" + response + ""]"");
            // setup the inMessage response stream
            byte[] bytes = null;
            if (response instanceof String) {
                String requestString = (String)response;
                bytes = requestString.getBytes();
            } else {
                bytes = (byte[])response;
            }
            inMessage.setContent(InputStream.class, new ByteArrayInputStream(bytes));
            getLogger().log(Level.FINE, ""incoming observer is "" + incomingObserver);
            incomingObserver.onMessage(inMessage);
        }
    }
    private boolean isTextPayload() {
        // TODO use runtime policy
        return true;
    }
    /**
     * Represented decoupled response endpoint.
     */
    protected class DecoupledDestination implements Destination {
        protected MessageObserver decoupledMessageObserver;
        private EndpointReferenceType address;
        DecoupledDestination(EndpointReferenceType ref, MessageObserver incomingObserver) {
            address = ref;
            decoupledMessageObserver = incomingObserver;
        }
        public EndpointReferenceType getAddress() {
            return address;
        }
        public Conduit getBackChannel(Message inMessage, Message partialResponse, EndpointReferenceType addr) throws IOException {
            // shouldn't be called on decoupled endpoint
            return null;
        }
        public void shutdown() {
            // TODO Auto-generated method stub
        }
        public synchronized void setMessageObserver(MessageObserver observer) {
            decoupledMessageObserver = observer;
        }
        public synchronized MessageObserver getMessageObserver() {
            return decoupledMessageObserver;
        }
    }
}
"
org.apache.camel.component.xmpp.RuntimeXmppException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.jivesoftware.smack.XMPPException;
/**
 * A runtime exception thrown if sending or receiving from XMPP fails
 *
 * @version $Revision:520964 $
 */
public class RuntimeXmppException extends RuntimeException {
    private static final long serialVersionUID = -2141493732308871761L;
    public RuntimeXmppException(XMPPException cause) {
        super(cause);
    }
    public RuntimeXmppException(String message, XMPPException cause) {
        super(message, cause);
    }
}
"
org.apache.camel.spring.remoting.CamelServiceExporter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.remoting;
import org.apache.camel.CamelContext;
import org.apache.camel.CamelContextAware;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.util.CamelContextHelper;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.remoting.support.RemoteExporter;
import static org.apache.camel.util.ObjectHelper.notNull;
/**
 * A {@link FactoryBean} to create a proxy to a service exposing a given {@link #getServiceInterface()}
 *
 * @author chirino
 */
public class CamelServiceExporter extends RemoteExporter implements InitializingBean, DisposableBean, ApplicationContextAware, CamelContextAware {
    private String uri;
    private CamelContext camelContext;
    private Consumer consumer;
    private String serviceRef;
    private ApplicationContext applicationContext;
    public String getUri() {
        return uri;
    }
    public void setUri(String uri) {
        this.uri = uri;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public String getServiceRef() {
        return serviceRef;
    }
    public void setServiceRef(String serviceRef) {
        this.serviceRef = serviceRef;
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public void afterPropertiesSet() throws Exception {
        // lets bind the URI to a pojo
        notNull(uri, ""uri"");
        notNull(camelContext, ""camelContext"");
        if (serviceRef != null && getService() == null && applicationContext != null) {
            setService(applicationContext.getBean(serviceRef));
        }
        Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(camelContext, uri);
        Object proxy = getProxyForService();
        consumer = endpoint.createConsumer(new BeanProcessor(proxy, camelContext));
        consumer.start();
    }
    public void destroy() throws Exception {
        if (consumer != null) {
            consumer.stop();
        }
    }
}
"
org.apache.camel.component.jms.JmsIOConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.ObjectOutputStream;
import java.nio.ByteBuffer;
import java.util.Enumeration;
import javax.jms.BytesMessage;
import javax.jms.MapMessage;
import javax.jms.Message;
import javax.jms.MessageEOFException;
import javax.jms.ObjectMessage;
import javax.jms.StreamMessage;
import javax.jms.TextMessage;
import org.apache.camel.Converter;
import org.apache.camel.converter.NIOConverter;
/**
 * Some simple payload conversions to I/O <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 * 
 * @version $Revision: 533630 $
 */
@Converter
public final class JmsIOConverter {
    private JmsIOConverter() {        
    }
    /**
     * @param message
     * @return a ByteBuffer
     * @throws Exception
     */
    @Converter
    public static ByteBuffer toByteBuffer(final Message message) throws Exception {
        if (message instanceof TextMessage) {
            final String text = ((TextMessage)message).getText();
            return NIOConverter.toByteBuffer(text);
        }
        if (message instanceof BytesMessage) {
            final BytesMessage bmsg = (BytesMessage)message;
            final int len = (int)bmsg.getBodyLength();
            final byte[] data = new byte[len];
            bmsg.readBytes(data, len);
            return NIOConverter.toByteBuffer(data);
        }
        if (message instanceof StreamMessage) {
            final StreamMessage msg = (StreamMessage)message;
            final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
            final DataOutputStream dataOut = new DataOutputStream(bytesOut);
            try {
                while (true) {
                    final Object obj = msg.readObject();
                    writeData(dataOut, obj);
                }
            } catch (MessageEOFException e) {
                // we have no other way of knowing the end of the message
            }
            dataOut.close();
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        if (message instanceof MapMessage) {
            final MapMessage msg = (MapMessage)message;
            final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
            final DataOutputStream dataOut = new DataOutputStream(bytesOut);
            for (final Enumeration en = msg.getMapNames(); en.hasMoreElements();) {
                final Object obj = msg.getObject(en.nextElement().toString());
                writeData(dataOut, obj);
            }
            dataOut.close();
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        if (message instanceof ObjectMessage) {
            ObjectMessage objMessage = (ObjectMessage)message;
            Object object = objMessage.getObject();
            ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
            ObjectOutputStream objectOut = new ObjectOutputStream(bytesOut);
            objectOut.writeObject(object);
            objectOut.close();
            return NIOConverter.toByteBuffer(bytesOut.toByteArray());
        }
        return null;
    }
    private static void writeData(DataOutputStream dataOut, Object data) throws Exception {
        if (data instanceof byte[]) {
            dataOut.write((byte[])data);
        } else if (data instanceof String) {
            dataOut.writeUTF(data.toString());
        } else if (data instanceof Double) {
            dataOut.writeDouble(((Double)data).doubleValue());
        } else if (data instanceof Float) {
            dataOut.writeFloat(((Float)data).floatValue());
        } else if (data instanceof Long) {
            dataOut.writeLong(((Long)data).longValue());
        } else if (data instanceof Integer) {
            dataOut.writeInt(((Integer)data).intValue());
        } else if (data instanceof Short) {
            dataOut.writeShort(((Short)data).shortValue());
        } else if (data instanceof Character) {
            dataOut.writeChar(((Character)data).charValue());
        } else if (data instanceof Byte) {
            dataOut.writeByte(((Byte)data).byteValue());
        } else if (data instanceof Boolean) {
            dataOut.writeBoolean(((Boolean)data).booleanValue());
        }
    }
}
"
org.apache.camel.component.cxf.invoker.RawMessageInvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.component.cxf.interceptors.RawMessageContentRedirectInterceptor;
import org.apache.camel.component.cxf.interceptors.RawMessageInInterceptor;
import org.apache.camel.component.cxf.phase.RawMessagePhaseManagerImpl;
import org.apache.cxf.Bus;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.helpers.IOUtils;
import org.apache.cxf.interceptor.Interceptor;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.phase.PhaseInterceptorChain;
import org.apache.cxf.phase.PhaseManager;
public class RawMessageInvokingContext extends AbstractInvokingContext {
    private static final Logger LOG = Logger.getLogger(RawMessageInvokingContext.class.getName());
    private PhaseManager phaseManager; 
    public RawMessageInvokingContext() {
        phaseManager = new RawMessagePhaseManagerImpl();
    }
    public PhaseInterceptorChain getRequestOutInterceptorChain(Exchange exchange) {
        return getOutInterceptorChain(exchange);
    }
    public PhaseInterceptorChain getResponseOutInterceptorChain(Exchange exchange) {
        return getOutInterceptorChain(exchange);
    }
    private PhaseInterceptorChain getOutInterceptorChain(Exchange exchange) {
        PhaseInterceptorChain chain = new PhaseInterceptorChain(
                new RawMessagePhaseManagerImpl().getOutPhases());
        Bus bus = exchange.get(Bus.class);
        assert bus != null;
        // bus
        List<Interceptor> list = bus.getOutInterceptors();
        if (LOG.isLoggable(Level.FINE)) {
            LOG.fine(""Interceptors contributed by bus: "" + list);
        }
        chain.add(list);
        // endpoint
        Endpoint endpoint = exchange.get(Endpoint.class);
        if (endpoint != null) {
            list = endpoint.getOutInterceptors();
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Interceptors contributed by endpoint: "" + list);
            }
            chain.add(list);
        }
        if (LOG.isLoggable(Level.FINE)) {
            LOG.fine(""inject "" + RawMessageContentRedirectInterceptor.class);
        }
        chain.add(new RawMessageContentRedirectInterceptor());
        return chain;
    }
    public void setRequestOutMessageContent(Message message, Object content) {
        message.setContent(InputStream.class, content);        
    }
    @Override
    protected SortedSet<Phase> getInPhases() {
        return phaseManager.getInPhases();
    }
    @Override
    protected List<Interceptor> getRoutingInterceptors() {
        List<Interceptor> list = new ArrayList<Interceptor>();
        list.add(new RawMessageInInterceptor());
        return list;
    }
    public Object getResponseObject(Exchange exchange, Map<String, Object> responseContext) {
        return getResponseObject(exchange.getInMessage(), responseContext, InputStream.class);
    }
    //@Override
    protected PhaseInterceptorChain getInInterceptorChain(Exchange exchange, boolean isResponse) {
        Bus bus = exchange.get(Bus.class);
        assert bus != null;
        PhaseInterceptorChain chain = new PhaseInterceptorChain(getInPhases());
        if (!isResponse) {
            List<Interceptor> routingInterceptors = getRoutingInterceptors();
            chain.add(routingInterceptors);    
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Injected "" + routingInterceptors);
            }
        }
        // bus
        List<Interceptor> list = bus.getInInterceptors();
        LOG.fine(""Interceptors contributed by bus: "" + list);
        chain.add(list);
        // endpoint
        Endpoint ep = exchange.get(Endpoint.class);
        if (ep != null) {
            list = ep.getInInterceptors();
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Interceptors contributed by endpoint: "" + list);
            }
            chain.add(list);
        }
        return chain;
    }
    public void setResponseContent(Message outMessage, Object resultPayload) {
        LOG.info(""Set content: "" + resultPayload);
        outMessage.setContent(InputStream.class, resultPayload);
        //loggerTheMessage(outMessage, ""Out Message"");
    }
    public Object getRequestContent(Message inMessage) {        
        //loggerTheMessage(inMessage, ""In Message"");
        return inMessage.getContent(InputStream.class);
    }
    private void loggerTheMessage(Message message, String messageTile) {
        StringBuffer buffer = new StringBuffer( messageTile + ""\n"" 
                                               + ""--------------------------------------"");
        InputStream is = message.getContent(InputStream.class);        
        if (is != null) {
            CachedOutputStream bos = new CachedOutputStream();
            try {
                IOUtils.copy(is, bos);
                is.close();
                bos.close();
                buffer.append(""\nMessage:\n"");
                buffer.append(bos.getOut().toString());
                message.setContent(InputStream.class, bos.getInputStream());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        buffer.append(""\n--------------------------------------"");
        LOG.info(buffer.toString());
    }
}
"
org.apache.camel.component.cxf.CxfComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import java.util.Map;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/cxf.html"">CXF Component</a>
 * @version $Revision$
 */
public class CxfComponent extends DefaultComponent<CxfExchange> {
    public CxfComponent() {
    }
    public CxfComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<CxfExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        // now we need to add the address, endpoint name, wsdl url or the SEI to build up a endpoint
        CxfEndpoint result = new CxfEndpoint(uri, remaining, this);        
        setProperties(result, parameters);
        // we can check the endpoint integration here
        return result;
    }
}
"
org.apache.camel.component.validator.ValidatorComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.component.ResourceBasedComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.springframework.core.io.Resource;
import java.util.Map;
/**
 * The <a href=""http://activemq.apache.org/camel/validator.html"">Validator Component</a>
 * for validating XML against some schema
 *
 * @version $Revision: 1.1 $
 */
public class ValidatorComponent extends ResourceBasedComponent {
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        SpringValidator validator = new SpringValidator();
        Resource resource = resolveMandatoryResource(remaining);
        validator.setSchemaResource(resource);
        if (LOG.isDebugEnabled()) {
            LOG.debug(this + "" using schema resource: "" + resource);
        }
        configureValidator(validator, uri, remaining, parameters);
        return new ProcessorEndpoint(uri, this, validator);
    }
    protected void configureValidator(SpringValidator validator, String uri, String remaining, Map parameters) throws Exception {
        setProperties(validator, parameters);
    }
}
"
org.apache.camel.component.cxf.invoker.AbstractInvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.cxf.Bus;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.endpoint.EndpointImpl;
import org.apache.cxf.interceptor.Interceptor;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.phase.PhaseInterceptorChain;
/**
 * A RoutingContext encapulates specific knowledge about how to route messages of
 * a particular data format.
 *
 */
public abstract class AbstractInvokingContext implements InvokingContext {
    private static final Logger LOG = Logger.getLogger(AbstractInvokingContext.class.getName());
    /**
     * This method is called when an request from a (routing) client is observed
     * at the router's transport (inbound to the router from a client).  It will 
     * return an ""in"" interceptor chain that will allow the appropriate routing 
     * interceptor to receive and handle the message.
     * @param exchange
     * @return in interceptor chain
     */
    public PhaseInterceptorChain getRequestInInterceptorChain(Exchange exchange) {
        return getInInterceptorChain(exchange, false);
    }
    protected PhaseInterceptorChain getInInterceptorChain(Exchange exchange, boolean isResponse) {
        Bus bus = exchange.get(Bus.class);
        assert bus != null;
        PhaseInterceptorChain chain = new PhaseInterceptorChain(getInPhases());
        if (!isResponse) {
            List<Interceptor> routingInterceptors = getRoutingInterceptors();
            chain.add(routingInterceptors);    
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Injected "" + routingInterceptors);
            }
        }
        // bus
        List<Interceptor> list = bus.getInInterceptors();
        if (LOG.isLoggable(Level.FINE)) {
            LOG.fine(""Interceptors contributed by bus: "" + list);
        }  
        chain.add(list);
        // endpoint
        Endpoint ep = exchange.get(Endpoint.class);
        if (ep != null) {
            list = ep.getInInterceptors();
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Interceptors contributed by endpoint: "" + list);
            }
            chain.add(list);
            // binding
            list = ep.getBinding().getInInterceptors();
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Interceptors contributed by binding: "" + list);
            }
            chain.add(list);
            // service
            list = ep.getService().getInInterceptors();
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Interceptors contributed by service: "" + list);
            }
            chain.add(list);
        }
        return chain;
    }
    /**
     * @return routing interceptor(s) specific to the routing context.
     */
    protected abstract List<Interceptor> getRoutingInterceptors();
    /**
     * @return ""in"" phrases from the phase manager specific to the routing context.
     */
    protected abstract SortedSet<Phase> getInPhases(); 
    /**
     * This method is called when a response from a CXF server is observed at the
     * router's transport (inbound to the router from a server).  It will return an
     * ""in"" interceptor chain that will allow the response to be returned to the 
     * involved routing interceptor (with the appropriate interceptors in between).
     * @param exchange
     * @return in interceptor chain
     */
    public PhaseInterceptorChain getResponseInInterceptorChain(Exchange exchange) {
        return getInInterceptorChain(exchange, true);
    }
    protected <T> T getResponseObject(Message inMessage, Map<String, Object> responseContext,
            Class <T> clazz) {        
        T retval = null;
        if (inMessage != null) {
            if (null != responseContext) {
                responseContext.putAll(inMessage);
                LOG.info(""set responseContext to be"" + responseContext);
            }
            retval = inMessage.getContent(clazz);
        }
        return retval;
    }
    /**
     * This method is called to set the fault observers on the endpoint that are specified
     * to the phases meaningful to the routing context.
     * @param endpointImpl
     * @param bus
     */
    public void setEndpointFaultObservers(EndpointImpl endpointImpl, Bus bus) {
        // default is no op
    }
}
"
org.apache.camel.language.ognl.OgnlLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.language.ognl;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * An <a href=""http://www.ognl.org/"">OGNL</a> {@link Language} plugin
 *
 * @version $Revision: $
 */
public class OgnlLanguage implements Language {
    public Predicate<Exchange> createPredicate(String expression) {
        return new OgnlExpression(this, expression, Boolean.class);
    }
    public Expression<Exchange> createExpression(String expression) {
        return new OgnlExpression(this, expression, Object.class);
    }
}
"
org.apache.camel.component.mina.MinaEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.net.SocketAddress;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoConnector;
import org.apache.mina.common.IoServiceConfig;
import org.apache.mina.common.IoSession;
/**
 * @version $Revision$
 */
public class MinaEndpoint extends DefaultEndpoint<MinaExchange> {
    private final IoAcceptor acceptor;
    private final SocketAddress address;
    private final IoConnector connector;
    private final IoServiceConfig config;
    public MinaEndpoint(String endpointUri, MinaComponent component, SocketAddress address, IoAcceptor acceptor, IoConnector connector, IoServiceConfig config) {
        super(endpointUri, component);
        this.config = config;
        this.address = address;
        this.acceptor = acceptor;
        this.connector = connector;
    }
    public Producer<MinaExchange> createProducer() throws Exception {
        return new MinaProducer(this);
    }
    public Consumer<MinaExchange> createConsumer(Processor processor) throws Exception {
        return new MinaConsumer(this, processor);
    }
    @Override
    public MinaExchange createExchange(ExchangePattern pattern) {
        return new MinaExchange(getContext(), pattern);
    }
    public MinaExchange createExchange(IoSession session, Object object) {
        MinaExchange exchange = new MinaExchange(getContext(), getExchangePattern());
        exchange.getIn().setBody(object);
        // TODO store session in exchange?
        return exchange;
    }
    // Properties
    // -------------------------------------------------------------------------
    public IoAcceptor getAcceptor() {
        return acceptor;
    }
    public SocketAddress getAddress() {
        return address;
    }
    public IoConnector getConnector() {
        return connector;
    }
    public IoServiceConfig getConfig() {
        return config;
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.bam.rules.ProcessRules,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessDefinition;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
/**
 * @version $Revision: $
 */
public class ProcessRules extends ServiceSupport {
    private ProcessDefinition processDefinition;
    private List<ActivityRules> activities = new ArrayList<ActivityRules>();
    public void processExpired(ActivityState activityState) throws Exception {
        for (ActivityRules activityRules : activities) {
            activityRules.processExpired(activityState);
        }
    }
    public void processExchange(Exchange exchange, ProcessInstance process) {
        for (ActivityRules activityRules : activities) {
            activityRules.processExchange(exchange, process);
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public List<ActivityRules> getActivities() {
        return activities;
    }
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startServices(activities);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(activities);
    }
}
"
org.apache.camel.component.rmi.RmiEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.net.URI;
import java.net.URISyntaxException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.Arrays;
import java.util.List;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.ExchangePattern;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.impl.DefaultEndpoint;
/**
 * @version $Revision:520964 $
 */
public class RmiEndpoint extends DefaultEndpoint<BeanExchange> {
    private List<Class> remoteInterfaces;
    private ClassLoader classLoader;
    private URI uri;
    private int port;
    protected RmiEndpoint(String endpointUri, RmiComponent component) throws URISyntaxException {
        super(endpointUri, component);
        this.uri = new URI(endpointUri);
    }
    public boolean isSingleton() {
        return false;
    }
    @Override
    public BeanExchange createExchange(ExchangePattern pattern) {
        return new BeanExchange(getContext(), pattern);
    }
    public Consumer<BeanExchange> createConsumer(Processor processor) throws Exception {
        if (remoteInterfaces == null || remoteInterfaces.size() == 0) {
            throw new RuntimeCamelException(""To create an RMI consumer, the RMI endpoint's remoteInterfaces property must be be configured."");
        }
        return new RmiConsumer(this, processor);
    }
    public Producer<BeanExchange> createProducer() throws Exception {
        return new RmiProducer(this);
    }
    public String getName() {
        String path = uri.getPath();
        if (path == null) {
            path = uri.getSchemeSpecificPart();
        }
        return path;
    }
    public Registry getRegistry() throws RemoteException {
        if (uri.getHost() != null) {
            if (uri.getPort() == -1) {
                return LocateRegistry.getRegistry(uri.getHost());
            } else {
                return LocateRegistry.getRegistry(uri.getHost(), uri.getPort());
            }
        } else {
            return LocateRegistry.getRegistry();
        }
    }
    public List<Class> getRemoteInterfaces() {
        return remoteInterfaces;
    }
    public void setRemoteInterfaces(List<Class> remoteInterfaces) {
        this.remoteInterfaces = remoteInterfaces;
        if (classLoader == null && !remoteInterfaces.isEmpty()) {
            classLoader = remoteInterfaces.get(0).getClassLoader();
        }
    }
    public void setRemoteInterfaces(Class... remoteInterfaces) {
        setRemoteInterfaces(Arrays.asList(remoteInterfaces));
    }
    public ClassLoader getClassLoader() {
        return classLoader;
    }
    public void setClassLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        this.port = port;
    }
}
"
org.apache.camel.bam.model.TemporalEntity,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import java.util.Date;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
/**
 * @version $Revision: $
 */
public abstract class TemporalEntity extends EntitySupport {
    private Date timeStarted;
    private Date timeCompleted;
    @Transient
    public boolean isStarted() {
        return timeStarted != null;
    }
    @Transient
    public boolean isCompleted() {
        return timeCompleted != null;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeStarted() {
        return timeStarted;
    }
    public void setTimeStarted(Date timeStarted) {
        this.timeStarted = timeStarted;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeCompleted() {
        return timeCompleted;
    }
    public void setTimeCompleted(Date timeCompleted) {
        this.timeCompleted = timeCompleted;
    }
}
"
org.apache.camel.spring.handler.ScriptDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import org.w3c.dom.Element;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
/**
 * A parser of the various scripting language expressions
 *
 * @version $Revision: 1.1 $
 */
public class ScriptDefinitionParser extends LazyLoadingBeanDefinitionParser {
    private final String scriptEngineName;
    public ScriptDefinitionParser(String scriptEngineName) {
        super(""org.apache.camel.builder.script.ScriptBuilder"", ""camel-script"");
        this.scriptEngineName = scriptEngineName;
    }
    @Override
    protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
        // lets create a child context
        String engine = scriptEngineName;
        if (engine == null) {
            engine = element.getAttribute(""language"");
        }
        builder.addConstructorArg(engine);
        super.doParse(element, parserContext, builder);
        String scriptText = DomUtils.getTextValue(element).trim();
        if (scriptText.length() > 0) {
            builder.addPropertyValue(""scriptText"", scriptText);
        }
    }
}
"
org.apache.camel.component.cxf.invoker.FaultChainInitiatorObserver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.SortedSet;
import org.apache.camel.component.cxf.interceptors.FaultOutInterceptor;
import org.apache.cxf.Bus;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.interceptor.AbstractFaultChainInitiatorObserver;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.phase.PhaseInterceptorChain;
public class FaultChainInitiatorObserver extends AbstractFaultChainInitiatorObserver {
    private SortedSet<Phase> phases;
    private boolean isOutbound;
    public FaultChainInitiatorObserver(Bus bus, SortedSet<Phase> phases, boolean isOutbound) {
        super(bus);
        this.phases = phases;
        this.isOutbound = isOutbound;
    }
    protected void initializeInterceptors(Exchange ex, PhaseInterceptorChain chain) {
        Endpoint e = ex.get(Endpoint.class);
        if (isOutboundObserver()) {
            chain.add(e.getOutFaultInterceptors());
            chain.add(e.getBinding().getOutFaultInterceptors());
            chain.add(e.getService().getOutFaultInterceptors());
            chain.add(getBus().getOutFaultInterceptors());
            chain.add(new FaultOutInterceptor());
        } else {
            chain.add(e.getBinding().getInFaultInterceptors());
            chain.add(e.getService().getInFaultInterceptors());
            chain.add(getBus().getInFaultInterceptors());
        }
    }
    @Override
    protected SortedSet<Phase> getPhases() {
        return phases;
    }
    @Override
    protected boolean isOutboundObserver() {
        return isOutbound;
    }
}
"
org.apache.camel.component.rmi.RmiConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.rmi.Remote;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import org.apache.camel.Processor;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.component.bean.BeanInvocation;
import org.apache.camel.impl.DefaultConsumer;
/**
 * A {@link Consumer} which uses RMI's {@see UnicastRemoteObject} to consume
 * method invocations.
 * 
 * @version $Revision: 533758 $
 */
public class RmiConsumer extends DefaultConsumer<BeanExchange> implements InvocationHandler {
    private final RmiEndpoint endpoint;
    private Remote stub;
    private Remote proxy;
    public RmiConsumer(RmiEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        Class[] interfaces = new Class[endpoint.getRemoteInterfaces().size()];
        endpoint.getRemoteInterfaces().toArray(interfaces);
        proxy = (Remote)Proxy.newProxyInstance(endpoint.getClassLoader(), interfaces, this);
        stub = UnicastRemoteObject.exportObject(proxy, endpoint.getPort());
        try {
            Registry registry = endpoint.getRegistry();
            String name = endpoint.getName();
            registry.bind(name, stub);
        } catch (Exception e) { // Registration might fail.. clean up..
            try {
                UnicastRemoteObject.unexportObject(stub, true);
            } catch (Throwable ignore) {
            }
            stub = null;
            throw e;
        }
        super.doStart();
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();
        try {
            Registry registry = endpoint.getRegistry();
            registry.unbind(endpoint.getName());
        } catch (Throwable e) { // do our best to unregister
        }
        UnicastRemoteObject.unexportObject(proxy, true);
    }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (!isStarted()) {
            throw new IllegalStateException(""The endpoint is not active: "" + getEndpoint().getEndpointUri());
        }
        BeanInvocation invocation = new BeanInvocation(proxy, method, args);
        BeanExchange exchange = getEndpoint().createExchange();
        exchange.setInvocation(invocation);
        getProcessor().process(exchange);
        Throwable fault = exchange.getException();
        if (fault != null) {
            throw new InvocationTargetException(fault);
        }
        return exchange.getOut().getBody();
    }
    public Remote getProxy() {
        return proxy;
    }
    public Remote getStub() {
        return stub;
    }
}
"
org.apache.camel.builder.sql.SQL,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.sql;
import org.apache.camel.language.LanguageAnnotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation for injection of SQL expressions into method parameters, fields or properties
 *
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""sql"")
public @interface SQL {
    public abstract String value();
}"
org.apache.camel.spring.SpringCamelContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.Endpoint;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.component.event.EventComponent;
import org.apache.camel.component.event.EventEndpoint;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.camel.spi.Injector;
import org.apache.camel.spi.Registry;
import org.apache.camel.spring.spi.ApplicationContextRegistry;
import org.apache.camel.spring.spi.SpringInjector;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.*;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.context.support.ClassPathXmlApplicationContext;
/**
 * A Spring aware implementation of {@link org.apache.camel.CamelContext} which will
 * automatically register itself with Springs lifecycle methods plus allows
 * spring to be used to customize a any <a
 * href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 * as well as supporting accessing components and beans via the Spring
 * {@link ApplicationContext}
 * 
 * @version $Revision$
 */
public class SpringCamelContext extends DefaultCamelContext implements InitializingBean, DisposableBean, ApplicationContextAware, ApplicationListener {
    private static final transient Log LOG = LogFactory.getLog(SpringCamelContext.class);
    private ApplicationContext applicationContext;
    private EventEndpoint eventEndpoint;
    public SpringCamelContext() {
    }
    public SpringCamelContext(ApplicationContext applicationContext) {
        setApplicationContext(applicationContext);
    }
    public static SpringCamelContext springCamelContext(ApplicationContext applicationContext) throws Exception {
        // lets try and look up a configured camel context in the context
        String[] names = applicationContext.getBeanNamesForType(SpringCamelContext.class);
        if (names.length == 1) {
            return (SpringCamelContext)applicationContext.getBean(names[0], SpringCamelContext.class);
        }
        SpringCamelContext answer = new SpringCamelContext();
        answer.setApplicationContext(applicationContext);
        answer.afterPropertiesSet();
        return answer;
    }
    public static SpringCamelContext springCamelContext(String configLocations) throws Exception {
        return springCamelContext(new ClassPathXmlApplicationContext(configLocations));
    }
    public void afterPropertiesSet() throws Exception {
        start();
    }
    public void destroy() throws Exception {
        stop();
    }
    public void onApplicationEvent(ApplicationEvent event) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Publishing event: "" + event);
        }
        if (event instanceof ContextRefreshedEvent) {
            // now lets start the CamelContext so that all its possible
            // dependencies are initailized
            try {
                LOG.debug(""Starting the CamelContext now that the ApplicationContext has started"");
                start();
            } catch (Exception e) {
                throw new RuntimeCamelException(e);
            }
            if (eventEndpoint != null) {
                eventEndpoint.onApplicationEvent(event);
            }
        } else {
            if (eventEndpoint != null) {
                eventEndpoint.onApplicationEvent(event);
            } else {
                LOG.warn(""No eventEndpoint enabled for event: "" + event);
            }
        }
    }
    // Properties
    // -----------------------------------------------------------------------
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        if (applicationContext instanceof ConfigurableApplicationContext) {
            addComponent(""event"", new EventComponent(applicationContext));
        }
    }
    public EventEndpoint getEventEndpoint() {
        return eventEndpoint;
    }
    public void setEventEndpoint(EventEndpoint eventEndpoint) {
        this.eventEndpoint = eventEndpoint;
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (eventEndpoint == null) {
            eventEndpoint = createEventEndpoint();
        }
    }
    @Override
    protected Injector createInjector() {
        if (applicationContext instanceof ConfigurableApplicationContext) {
            return new SpringInjector((ConfigurableApplicationContext)applicationContext);
        }
        else {
            LOG.warn(""Cannot use SpringInjector as applicationContext is not a ConfigurableApplicationContext as its: "" + applicationContext);
            return super.createInjector();
        }
    }
    protected EventEndpoint createEventEndpoint() {
        EventEndpoint endpoint = getEndpoint(""event:default"", EventEndpoint.class);
        return endpoint;
    }
    protected Endpoint convertBeanToEndpoint(String uri, Object bean) {
        Processor processor = new BeanProcessor(bean, this);
        return new ProcessorEndpoint(uri, this, processor);
    }
    @Override
    protected Registry createRegistry() {
        return new ApplicationContextRegistry(getApplicationContext());
    }
}
"
org.apache.camel.component.mail.MessageHeaderNamesAccessException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
/**
 * @version $Revision:520964 $
 */
public class MessageHeaderNamesAccessException extends RuntimeMailException {
    private static final long serialVersionUID = -6744171518099741324L;
    public MessageHeaderNamesAccessException(Throwable e) {
        super(""Failed to acess the Mail message property names"", e);
    }
}
"
org.apache.camel.spring.RouteBuilderFinder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.util.ResolverUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.context.ApplicationContext;
/**
 * A helper class which will find all {@link RouteBuilder} instances on the classpath
 *
 * @version $Revision$
 */
public class RouteBuilderFinder {
    private static final transient Log LOG = LogFactory.getLog(RouteBuilderFinder.class);
    private final SpringCamelContext camelContext;
    private final String[] packages;
    private ApplicationContext applicationContext;
    private ResolverUtil resolver = new ResolverUtil();
    public RouteBuilderFinder(SpringCamelContext camelContext, String[] packages, ClassLoader classLoader) {
        this.camelContext = camelContext;
        this.applicationContext = camelContext.getApplicationContext();
        this.packages = packages;
        // lets add all the available class loaders just in case of wierdness
        // we could make this more strict once we've worked out all the gremlins
        // in servicemix-camel
        Set set = resolver.getClassLoaders();
        set.clear();
        set.add(classLoader);
/*
        set.add(classLoader);
        set.add(applicationContext.getClassLoader());
        set.add(getClass().getClassLoader());
*/
    }
    public String[] getPackages() {
        return packages;
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    /**
     * Appends all the {@link RouteBuilder} instances that can be found on the classpath
     */
    public void appendBuilders(List<RouteBuilder> list) throws IllegalAccessException, InstantiationException {
        resolver.findImplementations(RouteBuilder.class, packages);
        Set<Class> classes = resolver.getClasses();
        for (Class aClass : classes) {
            if (shouldIgnoreBean(aClass)) {
                continue;
            }
            if (isValidClass(aClass)) {
                RouteBuilder builder = instantiateBuilder(aClass);
                list.add(builder);
            }
        }
    }
    public void destroy() throws Exception {
    }
    /**
     * Lets ignore beans that are not explicitly configured in the spring.xml
     */
    protected boolean shouldIgnoreBean(Class type) {
        Map beans = applicationContext.getBeansOfType(type, true, true);
        if (beans == null || beans.isEmpty()) {
            return false;
        }
        // TODO apply some filter?
        return true;
    }
    /**
     * Returns true if the object is non-abstract and supports a zero argument constructor
     */
    protected boolean isValidClass(Class type) {
        if (!Modifier.isAbstract(type.getModifiers()) && !type.isInterface()) {
            return true;
        }
        return false;
    }
    protected RouteBuilder instantiateBuilder(Class type) throws IllegalAccessException, InstantiationException {
        return (RouteBuilder) camelContext.getInjector().newInstance(type);
    }
}"
org.apache.camel.bam.model.EntitySupport,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
/**
 * A base class for persistent entities
 *
 * @version $Revision: $
 */
public class EntitySupport {
    private Long id;
    @Id
    @GeneratedValue
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public String toString() {
        return getClass().getName() + ""["" + id + ""]"";
    }
}
"
org.apache.camel.component.ResourceBasedComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component;
import org.apache.camel.Exchange;
import org.apache.camel.component.validator.ValidatorComponent;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
/**
 * @version $Revision: 1.1 $
 */
public abstract class ResourceBasedComponent extends DefaultComponent<Exchange> {
    protected static final transient Log LOG = LogFactory.getLog(ValidatorComponent.class);
    private ResourceLoader resourceLoader = new DefaultResourceLoader();
    public ResourceLoader getResourceLoader() {
        return resourceLoader;
    }
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }
    protected Resource resolveMandatoryResource(String uri) {
        Resource resource = getResourceLoader().getResource(uri);
        if (resource == null) {
            throw new IllegalArgumentException(""Could not find resource for URI: "" + uri + "" using: "" + getResourceLoader());
        } else {
            return resource;
        }
    }
}
"
org.apache.camel.component.irc.IrcComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.CamelContext;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.schwering.irc.lib.IRCConnection;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/irc.html"">IRC Component</a>
 * 
 * @version $Revision:$
 */
public class IrcComponent extends DefaultComponent<IrcExchange> {
    private static final transient Log LOG = LogFactory.getLog(IrcComponent.class);
    private IrcConfiguration configuration;
    private final Map<String, IRCConnection> connectionCache = new HashMap<String, IRCConnection>();
    public IrcComponent() {
        configuration = new IrcConfiguration();
    }
    public IrcComponent(IrcConfiguration configuration) {
        this.configuration = configuration;
    }
    public IrcComponent(CamelContext context) {
        super(context);
        configuration = new IrcConfiguration();
    }
    public static IrcComponent ircComponent() {
        return new IrcComponent();
    }
    protected IrcEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        IrcConfiguration config = getConfiguration().copy();
        config.configure(new URI(uri));
        // lets make sure we copy the configuration as each endpoint can
        // customize its own version
        final IrcEndpoint endpoint = new IrcEndpoint(uri, this, config);
        setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    public IrcConfiguration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(IrcConfiguration configuration) {
        this.configuration = configuration;
    }
    public synchronized IRCConnection getIRCConnection(IrcConfiguration configuration) {
        final IRCConnection connection;
        if (connectionCache.containsKey(configuration.getCacheKey())) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Returning Cached Connection to "" + configuration.getHostname() + "" "" + configuration.getTarget());
            }
            connection = connectionCache.get(configuration.getCacheKey());
        } else {
            connection = createConnection(configuration);
            connectionCache.put(configuration.getCacheKey(), connection);
        }
        return connection;
    }
    protected IRCConnection createConnection(IrcConfiguration configuration) {
        LOG.debug(""Creating Connection to "" + configuration.getHostname() + "" destination: "" + configuration.getTarget() + "" nick: "" + configuration.getNickname() + "" user: ""
                  + configuration.getUsername());
        final IRCConnection conn = new IRCConnection(configuration.getHostname(), configuration.getPorts(), configuration.getPassword(), configuration.getNickname(), configuration.getUsername(),
                                                     configuration.getRealname());
        conn.setEncoding(""UTF-8"");
        // conn.setDaemon(true);
        conn.setColors(configuration.isColors());
        conn.setPong(true);
        try {
            conn.connect();
        } catch (Exception e) {
            LOG.error(""Failed to connect: "" + e, e);
            // TODO use checked exceptions?
            throw new RuntimeCamelException(e);
        }
        return conn;
    }
    public void closeConnection(String key, IRCConnection connection) {
        try {
            connection.doQuit();
            connection.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @Override
    protected synchronized void doStop() throws Exception {
        // lets use a copy so we can clear the connections eagerly in case of
        // exceptions
        Map<String, IRCConnection> map = new HashMap<String, IRCConnection>(connectionCache);
        connectionCache.clear();
        for (Map.Entry<String, IRCConnection> entry : map.entrySet()) {
            closeConnection(entry.getKey(), entry.getValue());
        }
        super.doStop();
    }
}
"
org.apache.camel.builder.script.PHP,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.language.LanguageAnnotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation for injection of PHP expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""php"")
public @interface PHP {
    public abstract String value();
}"
org.apache.camel.component.xmpp.XmppEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.AccountManager;
import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.filter.PacketFilter;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Presence;
/**
 * An XMPP Endpoint
 * 
 * @version $Revision:520964 $
 */
public class XmppEndpoint extends DefaultEndpoint<XmppExchange> {
    private static final transient Log LOG = LogFactory.getLog(XmppEndpoint.class);
    private XmppBinding binding;
    private XMPPConnection connection;
    private String host;
    private int port;
    private String user;
    private String password;
    private String resource = ""Camel"";
    private boolean login = true;
    private PacketFilter filter;
    private boolean createAccount;
    private String room;
    private String participant;
    public XmppEndpoint(String uri, XmppComponent component) {
        super(uri, component);
    }
    public Producer<XmppExchange> createProducer() throws Exception {
        if (room != null) {
            return createGroupChatProducer(room);
        } else {
            if (participant == null) {
                throw new IllegalArgumentException(""No room or participant configured on this endpoint: "" + this);
            }
            return createPrivateChatProducer(participant);
        }
    }
    public Producer<XmppExchange> createGroupChatProducer(String room) throws Exception {
        return new XmppGroupChatProducer(this, room);
    }
    public Producer<XmppExchange> createPrivateChatProducer(String participant) throws Exception {
        return new XmppPrivateChatProducer(this, participant);
    }
    public Consumer<XmppExchange> createConsumer(Processor processor) throws Exception {
        return new XmppConsumer(this, processor);
    }
    @Override
    public XmppExchange createExchange(ExchangePattern pattern) {
        return new XmppExchange(getContext(), pattern, getBinding());
    }
    public XmppExchange createExchange(Message message) {
        return new XmppExchange(getContext(), getExchangePattern(), getBinding(), message);
    }
    // Properties
    // -------------------------------------------------------------------------
    public XmppBinding getBinding() {
        if (binding == null) {
            binding = new XmppBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from an XMPP
     * message
     * 
     * @param binding the binding to use
     */
    public void setBinding(XmppBinding binding) {
        this.binding = binding;
    }
    public String getHost() {
        return host;
    }
    public void setHost(String host) {
        this.host = host;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        this.port = port;
    }
    public String getUser() {
        return user;
    }
    public void setUser(String user) {
        this.user = user;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getResource() {
        return resource;
    }
    public void setResource(String resource) {
        this.resource = resource;
    }
    public boolean isLogin() {
        return login;
    }
    public void setLogin(boolean login) {
        this.login = login;
    }
    public PacketFilter getFilter() {
        return filter;
    }
    public void setFilter(PacketFilter filter) {
        this.filter = filter;
    }
    public boolean isCreateAccount() {
        return createAccount;
    }
    public void setCreateAccount(boolean createAccount) {
        this.createAccount = createAccount;
    }
    public String getRoom() {
        return room;
    }
    public void setRoom(String room) {
        this.room = room;
    }
    public String getParticipant() {
        return participant;
    }
    public void setParticipant(String participant) {
        this.participant = participant;
    }
    public XMPPConnection getConnection() throws XMPPException {
        if (connection == null) {
            connection = createConnection();
        }
        return connection;
    }
    public void setConnection(XMPPConnection connection) {
        this.connection = connection;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected XMPPConnection createConnection() throws XMPPException {
        XMPPConnection connection;
        if (port > 0) {
            connection = new XMPPConnection(host, port);
        } else {
            connection = new XMPPConnection(host);
        }
        if (login && !connection.isAuthenticated()) {
            if (user != null) {
                LOG.info(""Logging in to XMPP as user: "" + user + "" on connection: "" + connection);
                if (password == null) {
                    LOG.warn(""No password configured for user: "" + user);
                }
                if (createAccount) {
                    AccountManager accountManager = new AccountManager(connection);
                    accountManager.createAccount(user, password);
                }
                if (resource != null) {
                    connection.login(user, password, resource);
                } else {
                    connection.login(user, password);
                }
            } else {
                LOG.info(""Logging in anonymously to XMPP on connection: "" + connection);
                connection.loginAnonymously();
            }
            // now lets send a presence
            connection.sendPacket(new Presence(Presence.Type.AVAILABLE));
        }
        return connection;
    }
    public boolean isSingleton() {
        return true;
    }
}
"
org.apache.camel.component.file.remote.RemoteFileComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import org.apache.camel.CamelContext;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.impl.DefaultComponent;
import java.net.URI;
import java.util.Map;
public class RemoteFileComponent extends DefaultComponent<RemoteFileExchange> {
    private RemoteFileConfiguration configuration;
    public RemoteFileComponent() {
        this.configuration = new RemoteFileConfiguration();
    }
    public RemoteFileComponent(RemoteFileConfiguration configuration) {
        this.configuration = configuration;
    }
    public RemoteFileComponent(CamelContext context) {
        super(context);
        this.configuration = new RemoteFileConfiguration();
    }
    public String toString() {
        return ""RemoteFileComponent"";
    }
    public static RemoteFileComponent remoteFileComponent() {
        return new RemoteFileComponent();
    }
    protected RemoteFileEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        RemoteFileConfiguration config = getConfiguration().copy();
        config.configure(new URI(uri));
        // lets make sure we copy the configuration as each endpoint can
        // customize its own version
        final RemoteFileEndpoint endpoint;
        if (""ftp"".equals(config.getProtocol())) {
            endpoint = new FtpEndpoint(uri, this, config);
        } else if (""sftp"".equals(config.getProtocol())) {
            endpoint = new SftpEndpoint(uri, this, config);
        } else {
            throw new RuntimeCamelException(""Unsupported protocol: "" + config.getProtocol());
        }
        setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    public RemoteFileConfiguration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(RemoteFileConfiguration configuration) {
        this.configuration = configuration;
    }
}
"
org.apache.camel.component.file.remote.SftpEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.UserInfo;
import org.apache.camel.Processor;
public class SftpEndpoint extends RemoteFileEndpoint<RemoteFileExchange> {
    public SftpEndpoint(String uri, RemoteFileComponent remoteFileComponent, RemoteFileConfiguration configuration) {
        super(uri, remoteFileComponent, configuration);
    }
    public SftpProducer createProducer() throws Exception {
        return new SftpProducer(this, createChannelSftp());
    }
    public SftpConsumer createConsumer(Processor processor) throws Exception {
        final SftpConsumer consumer = new SftpConsumer(this, processor, createChannelSftp());
        configureConsumer(consumer);
        return consumer;
    }
    protected ChannelSftp createChannelSftp() throws JSchException {
        final JSch jsch = new JSch();
        final Session session = jsch.getSession(getConfiguration().getUsername(), getConfiguration().getHost());
        // TODO there's got to be a better way to deal with accepting new hosts...
        session.setUserInfo(new UserInfo() {
            public String getPassphrase() {
                return null;
            }
            public String getPassword() {
                return SftpEndpoint.this.getConfiguration().getPassword();
            }
            public boolean promptPassword(String string) {
                return true;
            }
            public boolean promptPassphrase(String string) {
                return true;
            }
            public boolean promptYesNo(String string) {
                return true;
            }
            public void showMessage(String string) {
            }
        });
        session.connect();
        final ChannelSftp channel = (ChannelSftp) session.openChannel(""sftp"");
        channel.connect();
        return channel;
    }
}
"
org.apache.camel.component.quartz.QuartzComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.CamelContext;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.util.IntrospectionSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.CronTrigger;
import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SchedulerFactory;
import org.quartz.Trigger;
import org.quartz.impl.StdSchedulerFactory;
import java.net.URI;
import java.util.Map;
/**
 * A <a href=""http://activemq.apache.org/camel/quartz.html"">Quartz Component</a>
 * 
 * @version $Revision:520964 $
 */
public class QuartzComponent extends DefaultComponent<QuartzExchange> {
    private static final transient Log LOG = LogFactory.getLog(QuartzComponent.class);
    private SchedulerFactory factory;
    private Scheduler scheduler;
    private Map<Trigger, JobDetail> triggers;
    public QuartzComponent() {
    }
    public QuartzComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected QuartzEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        QuartzEndpoint answer = new QuartzEndpoint(uri, this, getScheduler());
        // lets split the remaining into a group/name
        URI u = new URI(uri);
        String name;
        String group = ""Camel"";
        String path = u.getPath();
        CronTrigger cronTrigger = null;
        if (path != null && path.length() > 1) {
            if (path.startsWith(""/"")) {
                path = path.substring(1);
            }
            int idx = path.indexOf('/');
            if (idx > 0) {
                cronTrigger = new CronTrigger();
                name = path.substring(0, idx);
                String cronExpression = path.substring(idx + 1);
                // lets allow / instead of spaces and allow $ instead of ?
                cronExpression = cronExpression.replace('/', ' ');
                cronExpression = cronExpression.replace('$', '?');
                LOG.debug(""Creating cron trigger: "" + cronExpression);
                cronTrigger.setCronExpression(cronExpression);
                answer.setTrigger(cronTrigger);
            } else {
                name = path;
            }
            group = u.getHost();
        } else {
            name = u.getHost();
        }
        /*
         * String[] names = ObjectHelper.splitOnCharacter(remaining, ""/"", 2); if
         * (names[1] != null) { group = names[0]; name = names[1]; } else { name =
         * names[0]; }
         */
        Trigger trigger = cronTrigger;
        if (trigger == null) {
            trigger = answer.getTrigger();
        }
        trigger.setName(name);
        trigger.setGroup(group);
        Map triggerParameters = IntrospectionSupport.extractProperties(parameters, ""trigger."");
        Map jobParameters = IntrospectionSupport.extractProperties(parameters, ""job."");
        setProperties(trigger, triggerParameters);
        setProperties(answer.getJobDetail(), jobParameters);
        return answer;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        getScheduler().start();
    }
    @Override
    protected void doStop() throws Exception {
        if (scheduler != null) {
            scheduler.shutdown();
        }
        super.doStop();
    }
    // Properties
    // -------------------------------------------------------------------------
    public SchedulerFactory getFactory() {
        if (factory == null) {
            factory = createSchedulerFactory();
        }
        return factory;
    }
    public void setFactory(SchedulerFactory factory) {
        this.factory = factory;
    }
    public Scheduler getScheduler() throws SchedulerException {
        if (scheduler == null) {
            scheduler = createScheduler();
        }
        return scheduler;
    }
    public void setScheduler(Scheduler scheduler) {
        this.scheduler = scheduler;
    }
    public Map getTriggers() {
        return triggers;
    }
    public void setTriggers(Map triggers) {
        this.triggers = triggers;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected SchedulerFactory createSchedulerFactory() {
        return new StdSchedulerFactory();
    }
    protected Scheduler createScheduler() throws SchedulerException {
        return getFactory().getScheduler();
    }
}
"
org.apache.camel.builder.script.ScriptBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.Processor;
import org.apache.camel.converter.ObjectConverter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
/**
 * A builder class for creating {@link Processor}, {@link Expression} and
 * {@link Predicate} objects using the JSR 223 scripting engine.
 * 
 * @version $Revision$
 */
public class ScriptBuilder<E extends Exchange> implements Expression<E>, Predicate<E>, Processor {
    private static final transient Log LOG = LogFactory.getLog(ScriptBuilder.class);
    private String scriptEngineName;
    private Resource scriptResource;
    private String scriptText;
    private ScriptEngine engine;
    private CompiledScript compiledScript;
    public ScriptBuilder(String scriptEngineName) {
        this.scriptEngineName = scriptEngineName;
    }
    public ScriptBuilder(String scriptEngineName, String scriptText) {
        this(scriptEngineName);
        this.scriptText = scriptText;
    }
    public ScriptBuilder(String scriptEngineName, Resource scriptResource) {
        this(scriptEngineName);
        this.scriptResource = scriptResource;
    }
    @Override
    public String toString() {
        return getScriptDescription();
    }
    public Object evaluate(E exchange) {
        return evaluateScript(exchange);
    }
    public boolean matches(E exchange) {
        Object scriptValue = evaluateScript(exchange);
        return matches(exchange, scriptValue);
    }
    public void assertMatches(String text, E exchange) throws AssertionError {
        Object scriptValue = evaluateScript(exchange);
        if (!matches(exchange, scriptValue)) {
            throw new AssertionError(this + "" failed on "" + exchange + "" as script returned <"" + scriptValue + "">"");
        }
    }
    public void process(Exchange exchange) {
        evaluateScript(exchange);
    }
    // Builder API
    // -------------------------------------------------------------------------
    /**
     * Sets the attribute on the context so that it is available to the script
     * as a variable in the {@link ScriptContext#ENGINE_SCOPE}
     * 
     * @param name the name of the attribute
     * @param value the attribute value
     * @return this builder
     */
    public ScriptBuilder attribute(String name, Object value) {
        getScriptContext().setAttribute(name, value, ScriptContext.ENGINE_SCOPE);
        return this;
    }
    // Create any scripting language builder recognised by JSR 223
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the named language and script contents
     * 
     * @param language the language to use for the script
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder script(String language, String scriptText) {
        return new ScriptBuilder(language, scriptText);
    }
    /**
     * Creates a script builder for the named language and script
     * 
     * @{link Resource}
     * @param language the language to use for the script
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, Resource scriptResource) {
        return new ScriptBuilder(language, scriptResource);
    }
    /**
     * Creates a script builder for the named language and script
     * 
     * @{link File}
     * @param language the language to use for the script
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, File scriptFile) {
        return new ScriptBuilder(language, new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the named language and script
     * 
     * @{link URL}
     * @param language the language to use for the script
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder script(String language, URL scriptURL) {
        return new ScriptBuilder(language, new UrlResource(scriptURL));
    }
    // Groovy
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the groovy script contents
     * 
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder groovy(String scriptText) {
        return new ScriptBuilder(""groovy"", scriptText);
    }
    /**
     * Creates a script builder for the groovy script
     * 
     * @{link Resource}
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(Resource scriptResource) {
        return new ScriptBuilder(""groovy"", scriptResource);
    }
    /**
     * Creates a script builder for the groovy script
     * 
     * @{link File}
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(File scriptFile) {
        return new ScriptBuilder(""groovy"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the groovy script
     * 
     * @{link URL}
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder groovy(URL scriptURL) {
        return new ScriptBuilder(""groovy"", new UrlResource(scriptURL));
    }
    // JavaScript
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the JavaScript/ECMAScript script contents
     * 
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder javaScript(String scriptText) {
        return new ScriptBuilder(""js"", scriptText);
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script
     * 
     * @{link Resource}
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(Resource scriptResource) {
        return new ScriptBuilder(""js"", scriptResource);
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script
     * 
     * @{link File}
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(File scriptFile) {
        return new ScriptBuilder(""js"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the JavaScript/ECMAScript script
     * 
     * @{link URL}
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder javaScript(URL scriptURL) {
        return new ScriptBuilder(""js"", new UrlResource(scriptURL));
    }
    // PHP
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the PHP script contents
     * 
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder php(String scriptText) {
        return new ScriptBuilder(""php"", scriptText);
    }
    /**
     * Creates a script builder for the PHP script
     * 
     * @{link Resource}
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(Resource scriptResource) {
        return new ScriptBuilder(""php"", scriptResource);
    }
    /**
     * Creates a script builder for the PHP script
     * 
     * @{link File}
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(File scriptFile) {
        return new ScriptBuilder(""php"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the PHP script
     * 
     * @{link URL}
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder php(URL scriptURL) {
        return new ScriptBuilder(""php"", new UrlResource(scriptURL));
    }
    // Python
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the Python script contents
     * 
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder python(String scriptText) {
        return new ScriptBuilder(""python"", scriptText);
    }
    /**
     * Creates a script builder for the Python script
     * 
     * @{link Resource}
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(Resource scriptResource) {
        return new ScriptBuilder(""python"", scriptResource);
    }
    /**
     * Creates a script builder for the Python script
     * 
     * @{link File}
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(File scriptFile) {
        return new ScriptBuilder(""python"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the Python script
     * 
     * @{link URL}
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder python(URL scriptURL) {
        return new ScriptBuilder(""python"", new UrlResource(scriptURL));
    }
    // Ruby/JRuby
    // -------------------------------------------------------------------------
    /**
     * Creates a script builder for the Ruby/JRuby script contents
     * 
     * @param scriptText the script text to be evaluted
     * @return the builder
     */
    public static ScriptBuilder ruby(String scriptText) {
        return new ScriptBuilder(""jruby"", scriptText);
    }
    /**
     * Creates a script builder for the Ruby/JRuby script
     * 
     * @{link Resource}
     * @param scriptResource the resource used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(Resource scriptResource) {
        return new ScriptBuilder(""jruby"", scriptResource);
    }
    /**
     * Creates a script builder for the Ruby/JRuby script
     * 
     * @{link File}
     * @param scriptFile the file used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(File scriptFile) {
        return new ScriptBuilder(""jruby"", new FileSystemResource(scriptFile));
    }
    /**
     * Creates a script builder for the Ruby/JRuby script
     * 
     * @{link URL}
     * @param scriptURL the URL used to load the script
     * @return the builder
     */
    public static ScriptBuilder ruby(URL scriptURL) {
        return new ScriptBuilder(""jruby"", new UrlResource(scriptURL));
    }
    // Properties
    // -------------------------------------------------------------------------
    public ScriptEngine getEngine() {
        checkInitialised();
        if (engine == null) {
            throw new IllegalArgumentException(""No script engine could be created for: "" + getScriptEngineName());
        }
        return engine;
    }
    public CompiledScript getCompiledScript() {
        return compiledScript;
    }
    public String getScriptText() {
        return scriptText;
    }
    public void setScriptText(String scriptText) {
        this.scriptText = scriptText;
    }
    public String getScriptEngineName() {
        return scriptEngineName;
    }
    /**
     * Returns a description of the script
     * 
     * @return the script description
     */
    public String getScriptDescription() {
        if (scriptText != null) {
            return scriptEngineName + "": "" + scriptText;
        } else if (scriptResource != null) {
            return scriptEngineName + "": "" + scriptResource.getDescription();
        } else {
            return scriptEngineName + "": null script"";
        }
    }
    /**
     * Access the script context so that it can be configured such as adding
     * attributes
     */
    public ScriptContext getScriptContext() {
        return getEngine().getContext();
    }
    /**
     * Sets the context to use by the script
     */
    public void setScriptContext(ScriptContext scriptContext) {
        getEngine().setContext(scriptContext);
    }
    public Resource getScriptResource() {
        return scriptResource;
    }
    public void setScriptResource(Resource scriptResource) {
        this.scriptResource = scriptResource;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void checkInitialised() {
        if (scriptText == null && scriptResource == null) {
            throw new IllegalArgumentException(""Neither scriptText or scriptResource are specified"");
        }
        if (engine == null) {
            engine = createScriptEngine();
        }
        if (compiledScript == null) {
            if (engine instanceof Compilable) {
                compileScript((Compilable)engine);
            }
        }
    }
    protected boolean matches(E exchange, Object scriptValue) {
        return ObjectConverter.toBoolean(scriptValue);
    }
    protected ScriptEngine createScriptEngine() {
        ScriptEngineManager manager = new ScriptEngineManager();
        return manager.getEngineByName(scriptEngineName);
    }
    protected void compileScript(Compilable compilable) {
        try {
            if (scriptText != null) {
                compiledScript = compilable.compile(scriptText);
            } else if (scriptResource != null) {
                compiledScript = compilable.compile(createScriptReader());
            }
        } catch (ScriptException e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Script compile failed: "" + e, e);
            }
            throw createScriptCompileException(e);
        } catch (IOException e) {
            throw createScriptCompileException(e);
        }
    }
    protected synchronized Object evaluateScript(Exchange exchange) {
        try {
            getScriptContext();
            populateBindings(getEngine(), exchange);
            return runScript();
        } catch (ScriptException e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Script evaluation failed: "" + e, e);
            }
            throw createScriptEvaluationException(e.getCause());
        } catch (IOException e) {
            throw createScriptEvaluationException(e);
        }
    }
    protected Object runScript() throws ScriptException, IOException {
        checkInitialised();
        if (compiledScript != null) {
            return compiledScript.eval();
        } else {
            if (scriptText != null) {
                return getEngine().eval(scriptText);
            } else {
                return getEngine().eval(createScriptReader());
            }
        }
    }
    protected void populateBindings(ScriptEngine engine, Exchange exchange) {
        ScriptContext context = engine.getContext();
        int scope = ScriptContext.ENGINE_SCOPE;
        context.setAttribute(""context"", exchange.getContext(), scope);
        context.setAttribute(""exchange"", exchange, scope);
        context.setAttribute(""request"", exchange.getIn(), scope);
        context.setAttribute(""response"", exchange.getOut(), scope);
    }
    protected InputStreamReader createScriptReader() throws IOException {
        // TODO consider character sets?
        return new InputStreamReader(scriptResource.getInputStream());
    }
    protected ScriptEvaluationException createScriptCompileException(Exception e) {
        return new ScriptEvaluationException(""Failed to compile: "" + getScriptDescription() + "". Cause: "" + e, e);
    }
    protected ScriptEvaluationException createScriptEvaluationException(Throwable e) {
        return new ScriptEvaluationException(""Failed to evaluate: "" + getScriptDescription() + "". Cause: "" + e, e);
    }
}
"
org.apache.camel.component.cxf.interceptors.SoapMessageInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
//import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.model.SoapBindingInfo;
import org.apache.cxf.common.logging.LogUtils;
//import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.helpers.DOMUtils;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.MessagePartInfo;
public class SoapMessageInInterceptor extends AbstractMessageInInterceptor<SoapMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(SoapMessageInInterceptor.class);
    public SoapMessageInInterceptor() {       
        super(Phase.READ);
    }
    protected Logger getLogger() {
        return LOG;
    }
    protected boolean isFaultMessage(SoapMessage message) {
        //Fault Processing is Handled in SOAP Binding in the ReadHeadersInterceptor.
        return false;
    }
    protected BindingOperationInfo getBindingOperation(SoapMessage message, Document doc) {
        Exchange ex = message.getExchange();
        SoapBindingInfo soapBinding = (SoapBindingInfo)ex.get(BindingInfo.class);
        Element payloadEl = (Element)doc.getChildNodes().item(0);
        QName startQName = new QName(payloadEl.getNamespaceURI(), payloadEl.getLocalName());
        // handling xml normal inbound message
        boolean client = isRequestor(message);
        List<BindingOperationInfo> boiList = new ArrayList<BindingOperationInfo>();
        for (BindingOperationInfo boi : soapBinding.getOperations()) {
            String style = soapBinding.getStyle(boi.getOperationInfo());
            QName rootName = null;
            if (""rpc"".equals(style)) {
                rootName = boi.getOperationInfo().getName();
            } else {
                BindingMessageInfo bmi = client ?  boi.getOutput() : boi.getInput();
                if (bmi != null) {
                    Collection<MessagePartInfo> bodyParts = bmi.getMessageParts();
                    if (bodyParts.size() == 1) {
                        MessagePartInfo p = bodyParts.iterator().next();
                        rootName = p.getConcreteName();
                    }
                }
            }
            if (startQName.equals(rootName)) {
                boiList.add(boi);
            }
        }
        if (boiList.size() > 1
            && LOG.isLoggable(Level.INFO)) {
            LOG.info(""Mulitple matching BindingOperationIno found in Binding."");
        }
        return boiList.size() != 1 ? null : boiList.get(0);
    }
    protected List<Element> getPartList(SoapMessage inMessage, Element rootNode, BindingMessageInfo bmi) {
        List<Element> partList = new ArrayList<Element>();
        Exchange ex = inMessage.getExchange();
        SoapBindingInfo soapBinding = (SoapBindingInfo)ex.get(BindingInfo.class);
        String style = soapBinding.getStyle(bmi.getBindingOperation().getOperationInfo());
        if (""rpc"".equals(style)) {
            //Remove the operation element.
            rootNode = (Element)DOMUtils.getChild(rootNode, Node.ELEMENT_NODE);
        }
        partList.add(rootNode);
        return partList;
    }
    protected Element getHeader(SoapMessage inMessage) {
        // need to revisited 
        Element element = null;
        return element;
	// return inMessage.getHeaders(Element.class);
    }    
}
"
org.apache.camel.component.irc.IrcEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import org.apache.camel.Processor;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultEndpoint;
import org.schwering.irc.lib.IRCModeParser;
import org.schwering.irc.lib.IRCUser;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/irc.html"">IRC Endpoint</a>
 *
 * @version $Revision:$
 */
public class IrcEndpoint extends DefaultEndpoint<IrcExchange> {
    private IrcBinding binding;
    private IrcConfiguration configuration;
    private IrcComponent component;
    public IrcEndpoint(String endpointUri, IrcComponent component, IrcConfiguration configuration) {
        super(endpointUri, component);
        this.component = component;
        this.configuration = configuration;
    }
    public boolean isSingleton() {
        return true;
    }
    public IrcExchange createExchange(ExchangePattern pattern) {
        return new IrcExchange(getContext(), pattern, getBinding());
    }
    public IrcExchange createOnPrivmsgExchange(String target, IRCUser user, String msg) {
        return new IrcExchange(getContext(), getExchangePattern(), getBinding(), new IrcMessage(""PRIVMSG"", target, user, msg));
    }
    public IrcExchange createOnNickExchange(IRCUser user, String newNick) {
        return new IrcExchange(getContext(), getExchangePattern(), getBinding(), new IrcMessage(""NICK"", user, newNick));
    }
    public IrcExchange createOnQuitExchange(IRCUser user, String msg) {
        return new IrcExchange(getContext(), getExchangePattern(), getBinding(), new IrcMessage(""QUIT"", user, msg));
    }
    public IrcExchange createOnJoinExchange(String channel, IRCUser user) {
        return new IrcExchange(getContext(), getExchangePattern(), getBinding(), new IrcMessage(""JOIN"", channel, user));
    }
    public IrcExchange createOnKickExchange(String channel, IRCUser user, String whoWasKickedNick, String msg) {
        return new IrcExchange(getContext(), getExchangePattern(), getBinding(), new IrcMessage(""KICK"", channel, user, whoWasKickedNick, msg));
    }
    public IrcExchange createOnModeExchange(String channel, IRCUser user, IRCModeParser modeParser) {
        return new IrcExchange(getContext(), getExchangePattern(), getBinding(), new IrcMessage(""MODE"", channel, user, modeParser.getLine()));
    }
    public IrcExchange createOnPartExchange(String channel, IRCUser user, String msg) {
        return new IrcExchange(getContext(), getExchangePattern(), getBinding(), new IrcMessage(""PART"", channel, user, msg));
    }
    public IrcExchange createOnTopicExchange(String channel, IRCUser user, String topic) {
        return new IrcExchange(getContext(), getExchangePattern(), getBinding(), new IrcMessage(""TOPIC"", channel, user, topic));
    }
    public IrcProducer createProducer() throws Exception {
        return new IrcProducer(this, component.getIRCConnection(configuration));
    }
    public IrcConsumer createConsumer(Processor processor) throws Exception {
        return new IrcConsumer(this, processor, component.getIRCConnection(configuration));
    }
    public IrcComponent getComponent() {
        return component;
    }
    public void setComponent(IrcComponent component) {
        this.component = component;
    }
    public IrcBinding getBinding() {
        if (binding == null) {
            binding = new IrcBinding();
        }
        return binding;
    }
    public void setBinding(IrcBinding binding) {
        this.binding = binding;
    }
    public IrcConfiguration getConfiguration() {
        return configuration;
    }
    public void setConfiguration(IrcConfiguration configuration) {
        this.configuration = configuration;
    }
}
"
org.apache.camel.component.quartz.CamelJob,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.quartz.Job;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
/**
 * @version $Revision: 1.1 $
 */
public class CamelJob implements Job {
    public void execute(JobExecutionContext context) throws JobExecutionException {
        QuartzEndpoint component = (QuartzEndpoint) context.getJobDetail().getJobDataMap().get(QuartzEndpoint.ENDPOINT_KEY);
        if (component == null) {
            throw new JobExecutionException(""No quartz endpoint available for key: "" + QuartzEndpoint.ENDPOINT_KEY + "". Bad job data map"");
        }
        component.onJobExecute(context);
    }
}"
org.apache.camel.spring.Main,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import org.apache.camel.CamelContext;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ObjectHelper;
import org.apache.camel.view.RouteDotGenerator;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
/**
 * A command line tool for booting up a CamelContext using an optional Spring
 * ApplicationContext
 *
 * @version $Revision: $
 */
public class Main extends ServiceSupport {
    private static final Log LOG = LogFactory.getLog(Main.class);
    private String applicationContextUri = ""META-INF/spring/*.xml"";
    private AbstractApplicationContext applicationContext;
    private List<Option> options = new ArrayList<Option>();
    private CountDownLatch latch = new CountDownLatch(1);
    private AtomicBoolean completed = new AtomicBoolean(false);
    private long duration = -1;
    private TimeUnit timeUnit = TimeUnit.MILLISECONDS;
    private String dotOutputDir;
    public Main() {
        addOption(new Option(""h"", ""help"", ""Displays the help screen"") {
            protected void doProcess(String arg, LinkedList<String> remainingArgs) {
                showOptions();
                completed();
            }
        });
        addOption(new ParameterOption(""a"", ""applicationContext"", ""Sets the classpath based pring ApplicationContext"", ""applicationContext"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                setApplicationContextUri(parameter);
            }
        });
        addOption(new ParameterOption(""o"", ""outdir"", ""Sets the DOT output directory where the visual representations of the routes are generated"", ""dot"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                setDotOutputDir(parameter);
            }
        });
        addOption(new ParameterOption(""d"", ""duration"", ""Sets the time duration that the applicaiton will run for, by default in milliseconds. You can use '10s' for 10 seconds etc"", ""duration"") {
            protected void doProcess(String arg, String parameter, LinkedList<String> remainingArgs) {
                String value = parameter.toUpperCase();
                if (value.endsWith(""S"")) {
                    value = value.substring(0, value.length() - 1);
                    setTimeUnit(TimeUnit.SECONDS);
                }
                setDuration(Integer.parseInt(value));
            }
        });
    }
    public static void main(String... args) {
        new Main().run(args);
    }
    /**
     * Parses the command line arguments then runs the program
     */
    public void run(String[] args) {
        parseArguments(args);
        run();
    }
    /**
     * Runs this process with the given arguments
     */
    public void run() {
        if (!completed.get()) {
            try {
                start();
                postProcessContext();
                waitUntilCompleted();
                stop();
            }
            catch (Exception e) {
                LOG.error(""Failed: "" + e, e);
            }
        }
    }
    /**
     * Marks this process as being completed
     */
    public void completed() {
        completed.set(true);
        latch.countDown();
    }
    /**
     * Displays the command line options
     */
    public void showOptions() {
        System.out.println(""Apache Camel Runner takes the following options"");
        System.out.println();
        for (Option option : options) {
            System.out.println(""  "" + option.getAbbreviation() + "" or "" + option.getFullName() + "" = "" + option.getDescription());
        }
    }
    /**
     * Parses the commandl ine arguments
     */
    public void parseArguments(String[] arguments) {
        LinkedList<String> args = new LinkedList<String>(Arrays.asList(arguments));
        boolean valid = true;
        while (!args.isEmpty()) {
            String arg = args.removeFirst();
            boolean handled = false;
            for (Option option : options) {
                if (option.processOption(arg, args)) {
                    handled = true;
                    break;
                }
            }
            if (!handled) {
                System.out.println(""Unknown option: "" + arg);
                System.out.println();
                valid = false;
                break;
            }
        }
        if (!valid) {
            showOptions();
            completed();
        }
    }
    public void addOption(Option option) {
        options.add(option);
    }
    public abstract class Option {
        private String abbreviation;
        private String fullName;
        private String description;
        protected Option(String abbreviation, String fullName, String description) {
            this.abbreviation = ""-"" + abbreviation;
            this.fullName = ""-"" + fullName;
            this.description = description;
        }
        public boolean processOption(String arg, LinkedList<String> remainingArgs) {
            if (arg.equalsIgnoreCase(abbreviation) || fullName.startsWith(arg)) {
                doProcess(arg, remainingArgs);
                return true;
            }
            return false;
        }
        public String getAbbreviation() {
            return abbreviation;
        }
        public String getDescription() {
            return description;
        }
        public String getFullName() {
            return fullName;
        }
        protected abstract void doProcess(String arg, LinkedList<String> remainingArgs);
    }
    public abstract class ParameterOption extends Option {
        private String parameterName;
        protected ParameterOption(String abbreviation, String fullName, String description, String parameterName) {
            super(abbreviation, fullName, description);
            this.parameterName = parameterName;
        }
        protected void doProcess(String arg, LinkedList<String> remainingArgs) {
            if (remainingArgs.isEmpty()) {
                System.err.println(""Expected fileName for "");
                showOptions();
                completed();
            }
            else {
                String parameter = remainingArgs.removeFirst();
                doProcess(arg, parameter, remainingArgs);
            }
        }
        protected abstract void doProcess(String arg, String parameter, LinkedList<String> remainingArgs);
    }
    // Properties
    // -------------------------------------------------------------------------
    public AbstractApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(AbstractApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public String getApplicationContextUri() {
        return applicationContextUri;
    }
    public void setApplicationContextUri(String applicationContextUri) {
        this.applicationContextUri = applicationContextUri;
    }
    public long getDuration() {
        return duration;
    }
    /**
     * Sets the duration to run the application for in milliseconds until it should be terminated.
     * Defaults to -1. Any value <= 0 will run forever.
     *
     * @param duration
     */
    public void setDuration(long duration) {
        this.duration = duration;
    }
    public TimeUnit getTimeUnit() {
        return timeUnit;
    }
    /**
     * Sets the time unit duration
     */
    public void setTimeUnit(TimeUnit timeUnit) {
        this.timeUnit = timeUnit;
    }
    public String getDotOutputDir() {
        return dotOutputDir;
    }
    /**
     * Sets the output directory of the generated DOT Files
     * to show the visual representation of the routes.
     * A null value disables the dot file generation
     */
    public void setDotOutputDir(String dotOutputDir) {
        this.dotOutputDir = dotOutputDir;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    protected void doStart() throws Exception {
        LOG.info(""Apache Camel "" + getVersion() + "" starting"");
        if (applicationContext == null) {
            applicationContext = createDefaultApplicationContext();
        }
        applicationContext.start();
    }
    protected AbstractApplicationContext createDefaultApplicationContext() {
        String[] args = getApplicationContextUri().split("";"");
        return new ClassPathXmlApplicationContext(args);
    }
    protected void doStop() throws Exception {
        LOG.info(""Apache Camel terminating"");
        if (applicationContext != null) {
            applicationContext.close();
        }
    }
    protected void waitUntilCompleted() {
        while (!completed.get()) {
            try {
                if (duration > 0) {
                    TimeUnit unit = getTimeUnit();
                    LOG.info(""Waiting for: "" + duration + "" "" + unit);
                    latch.await(duration, unit);
                    completed.set(true);
                }
                else {
                    latch.await();
                }
            }
            catch (InterruptedException e) {
                LOG.debug(""Caught: "" + e);
            }
        }
    }
    protected void postProcessContext() throws Exception {
        if (ObjectHelper.isNotNullAndNonEmpty(dotOutputDir)) {
            RouteDotGenerator generator = new RouteDotGenerator(dotOutputDir);
            CamelContext camelContext = SpringCamelContext.springCamelContext(applicationContext);
            LOG.info(""Generating DOT file for routes: "" + dotOutputDir + "" for: "" + camelContext);
            generator.drawRoutes(camelContext);
        }
    }
    protected String getVersion() {
        Package aPackage = Package.getPackage(""org.apache.camel"");
        if (aPackage != null) {
            String version = aPackage.getImplementationVersion();
            if (version == null) {
                version = aPackage.getSpecificationVersion();
                if (version == null) {
                    version = """";
                }
            }
            return version;
        }
        return """";
    }
}
"
org.apache.camel.component.ibatis.IBatisProducer,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import com.ibatis.sqlmap.client.SqlMapClient;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ExchangeHelper;
/**
 * @version $Revision: 1.1 $
 */
public class IBatisProducer extends DefaultProducer {
    private SqlMapClient sqlClient;
    private final IBatisEndpoint endpoint;
    public IBatisProducer(IBatisEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    @Override
    public IBatisEndpoint getEndpoint() {
        return (IBatisEndpoint) super.getEndpoint();
    }
    public void process(Exchange exchange) throws Exception {
        if (sqlClient == null) {
            sqlClient = endpoint.getSqlClient();
        }
        Object body = ExchangeHelper.getMandatoryInBody(exchange);
        String operation = getOperationName(exchange);
        sqlClient.insert(operation, body);
    }
    /**
     * Returns the iBatis insert operation name
     */
    protected String getOperationName(Exchange exchange) {
        return endpoint.getEntityName();
    }
}
"
org.apache.camel.component.ResourceBasedEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component;
import org.apache.camel.Component;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.component.validator.ValidatorComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
/**
 * A useful base class for endpoints which depend on a resource
 * such as things like Velocity or XQuery based components
 *
 * @version $Revision: 1.1 $
 */
public abstract class ResourceBasedEndpoint extends ProcessorEndpoint {
    protected static final transient Log LOG = LogFactory.getLog(ValidatorComponent.class);
    private ResourceLoader resourceLoader = new DefaultResourceLoader();
    private final String resourceUri;
    private Resource resource;
    public ResourceBasedEndpoint(String endpointUri, Component component, String resourceUri, Processor processor) {
        super(endpointUri, component, processor);
        this.resourceUri = resourceUri;
    }
    public Resource getResource() {
        if (resource == null) {
            resource = getResourceLoader().getResource(resourceUri);
            if (resource == null) {
                throw new IllegalArgumentException(""Could not find resource for URI: "" + resourceUri + "" using: "" + getResourceLoader());
            }
        }
        return resource;
    }
    public ResourceLoader getResourceLoader() {
        return resourceLoader;
    }
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }
}"
org.apache.camel.component.mail.JavaMailConnection,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.Folder;
import javax.mail.MessagingException;
import javax.mail.Store;
import org.springframework.mail.MailSendException;
import org.springframework.mail.javamail.JavaMailSenderImpl;
/**
 * An extension of Spring's {@link JavaMailSenderImpl} to provide helper methods
 * for listening for new mail
 * 
 * @version $Revision: 1.1 $
 */
public class JavaMailConnection extends JavaMailSenderImpl {
    public Folder getFolder(String protocol, String folderName) {
        try {
            Store store = getSession().getStore(protocol);
            store.connect(getHost(), getPort(), getUsername(), getPassword());
            return store.getFolder(folderName);
        } catch (MessagingException e) {
            throw new MailSendException(""Mail server connection failed"", e);
        }
    }
}
"
org.apache.camel.component.event.EventComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import java.util.Map;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultComponent;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ConfigurableApplicationContext;
/**
 * An <a href=""http://activemq.apache.org/camel/event.html"">Event Component</a>
 * for working with Spring ApplicationEvents
 * 
 * @version $Revision: 1.1 $
 */
public class EventComponent extends DefaultComponent<Exchange> implements ApplicationContextAware {
    private ApplicationContext applicationContext;
    public EventComponent() {
    }
    public EventComponent(ApplicationContext applicationContext) {
        setApplicationContext(applicationContext);
    }
    public ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
    public ConfigurableApplicationContext getConfigurableApplicationContext() {
        ApplicationContext applicationContext = getApplicationContext();
        if (applicationContext instanceof ConfigurableApplicationContext) {
            return (ConfigurableApplicationContext)applicationContext;
        } else {
            throw new IllegalArgumentException(""Not created with a ConfigurableApplicationContext! Was: "" + applicationContext);
        }
    }
    protected EventEndpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        EventEndpoint answer = new EventEndpoint(uri, this);
        // getConfigurableApplicationContext().addApplicationListener(answer);
        return answer;
    }
}
"
org.apache.camel.component.jms.JmsConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.MessageListener;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.springframework.jms.listener.AbstractMessageListenerContainer;
/**
 * A {@link Consumer} which uses Spring's {@link AbstractMessageListenerContainer} implementations to consume JMS messages
 *
 * @version $Revision$
 */
public class JmsConsumer extends DefaultConsumer<JmsExchange> {
    private final AbstractMessageListenerContainer listenerContainer;
    public JmsConsumer(JmsEndpoint endpoint, Processor processor, AbstractMessageListenerContainer listenerContainer) {
        super(endpoint, processor);
        this.listenerContainer = listenerContainer;
        MessageListener messageListener = createMessageListener(endpoint, processor);
        this.listenerContainer.setMessageListener(messageListener);
    }
    public AbstractMessageListenerContainer getListenerContainer() {
        return listenerContainer;
    }
    protected MessageListener createMessageListener(JmsEndpoint endpoint, Processor processor) {
        EndpointMessageListener<JmsExchange> messageListener = new EndpointMessageListener<JmsExchange>(endpoint, processor);
        messageListener.setBinding(endpoint.getBinding());
        return messageListener;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        listenerContainer.afterPropertiesSet();
        listenerContainer.start();
    }
    @Override
    protected void doStop() throws Exception {
        listenerContainer.stop();
        listenerContainer.destroy();
        super.doStop();
    }
}
"
org.apache.camel.component.rmi.RmiComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.component.bean.BeanExchange;
import org.apache.camel.impl.DefaultComponent;
/**
 * @version $Revision:520964 $
 */
public class RmiComponent extends DefaultComponent<BeanExchange> {
    public RmiComponent() {
    }
    public RmiComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<BeanExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new RmiEndpoint(uri, this);
    }
}
"
org.apache.camel.component.cxf.transport.CamelDestination,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.cxf.Bus;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.configuration.Configurable;
import org.apache.cxf.io.CachedOutputStream;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractConduit;
import org.apache.cxf.transport.AbstractDestination;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.ConduitInitiator;
import org.apache.cxf.transport.MessageObserver;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
import org.apache.cxf.wsdl.EndpointReferenceUtils;
/**
 * @version $Revision$
 */
public class CamelDestination extends AbstractDestination implements Configurable {
    protected static final String BASE_BEAN_NAME_SUFFIX = "".camel-destination-base"";
    private static final Logger LOG = LogUtils.getL7dLogger(CamelDestination.class);
    CamelContext camelContext;
    String camelUri;
    final ConduitInitiator conduitInitiator;
    private CamelTransportBase base;
    private Endpoint endpoint;
    public CamelDestination(CamelContext camelContext, Bus bus, ConduitInitiator ci, EndpointInfo info) throws IOException {
        super(getTargetReference(info, bus), info);
        this.camelContext = camelContext;
        base = new CamelTransportBase(camelContext, bus, endpointInfo, true, BASE_BEAN_NAME_SUFFIX);
        conduitInitiator = ci;
        initConfig();
    }
    protected Logger getLogger() {
        return LOG;
    }
    /**
     * @param inMessage the incoming message
     * @return the inbuilt backchannel
     */
    protected Conduit getInbuiltBackChannel(Message inMessage) {
        return new BackChannelConduit(EndpointReferenceUtils.getAnonymousEndpointReference(), inMessage);
    }
    public void activate() {
        getLogger().log(Level.INFO, ""CamelDestination activate().... "");
        try {
            getLogger().log(Level.FINE, ""establishing Camel connection"");
            endpoint = camelContext.getEndpoint(camelUri);
        } catch (Exception ex) {
            getLogger().log(Level.SEVERE, ""Camel connect failed with EException : "", ex);
        }
    }
    public void deactivate() {
        base.close();
    }
    public void shutdown() {
        getLogger().log(Level.FINE, ""CamelDestination shutdown()"");
        this.deactivate();
    }
    protected void incoming(Exchange exchange) {
        getLogger().log(Level.FINE, ""server received request: "", exchange);
        byte[] bytes = base.unmarshal(exchange);
        // get the message to be interceptor
        MessageImpl inMessage = new MessageImpl();
        inMessage.setContent(InputStream.class, new ByteArrayInputStream(bytes));
        base.populateIncomingContext(exchange, inMessage, CamelConstants.CAMEL_SERVER_REQUEST_HEADERS);
        // inMessage.put(CamelConstants.CAMEL_SERVER_RESPONSE_HEADERS, new
        // CamelMessageHeadersType());
        inMessage.put(CamelConstants.CAMEL_REQUEST_MESSAGE, exchange);
        inMessage.setDestination(this);
        // handle the incoming message
        incomingObserver.onMessage(inMessage);
    }
    public String getBeanName() {
        return endpointInfo.getName().toString() + "".camel-destination"";
    }
    private void initConfig() {
        /*
         * this.runtimePolicy = endpointInfo.getTraversedExtensor(new
         * ServerBehaviorPolicyType(), ServerBehaviorPolicyType.class);
         * this.serverConfig = endpointInfo.getTraversedExtensor(new
         * ServerConfig(), ServerConfig.class); this.address =
         * endpointInfo.getTraversedExtensor(new AddressType(),
         * AddressType.class); this.sessionPool =
         * endpointInfo.getTraversedExtensor(new SessionPoolType(),
         * SessionPoolType.class);
         */
    }
    protected class ConsumerProcessor implements Processor {
        public void process(Exchange exchange) {
            try {
                incoming(exchange);
            } catch (Throwable ex) {
                getLogger().log(Level.WARNING, ""Failed to process incoming message : "", ex);
            }
        }
    }
    // this should deal with the cxf message
    protected class BackChannelConduit extends AbstractConduit {
        protected Message inMessage;
        BackChannelConduit(EndpointReferenceType ref, Message message) {
            super(ref);
            inMessage = message;
        }
        /**
         * Register a message observer for incoming messages.
         * 
         * @param observer the observer to notify on receipt of incoming
         */
        public void setMessageObserver(MessageObserver observer) {
            // shouldn't be called for a back channel conduit
        }
        /**
         * Send an outbound message, assumed to contain all the name-value
         * mappings of the corresponding input message (if any).
         * 
         * @param message the message to be sent.
         */
        public void prepare(Message message) throws IOException {
            // setup the message to be send back
            message.put(CamelConstants.CAMEL_REQUEST_MESSAGE, inMessage.get(CamelConstants.CAMEL_REQUEST_MESSAGE));
            message.setContent(OutputStream.class, new CamelOutputStream(inMessage));
        }
        protected Logger getLogger() {
            return LOG;
        }
    }
    private class CamelOutputStream extends CachedOutputStream {
        private Message inMessage;
        private Producer<Exchange> replyTo;
        private Producer<Exchange> sender;
        // setup the ByteArrayStream
        public CamelOutputStream(Message m) {
            super();
            inMessage = m;
        }
        // prepair the message and get the send out message
        private void commitOutputMessage() throws IOException {
            // setup the reply message
            final String replyToUri = getReplyToDestination(inMessage);
            base.template.send(replyToUri, new Processor() {
                public void process(Exchange reply) {
                    base.marshal(currentStream.toString(), replyToUri, reply);
                    setReplyCorrelationID(inMessage, reply);
                    base.setMessageProperties(inMessage, reply);
                    getLogger().log(Level.FINE, ""just server sending reply: "", reply);
                }
            });
        }
        @Override
        protected void doFlush() throws IOException {
            // Do nothing here
        }
        @Override
        protected void doClose() throws IOException {
            commitOutputMessage();
        }
        @Override
        protected void onWrite() throws IOException {
            // Do nothing here
        }
    }
    protected String getReplyToDestination(Message inMessage) {
        if (inMessage.get(CamelConstants.CAMEL_REBASED_REPLY_TO) != null) {
            return (String)inMessage.get(CamelConstants.CAMEL_REBASED_REPLY_TO);
        } else {
            return base.getReplyDestination();
        }
    }
    protected void setReplyCorrelationID(Message inMessage, Exchange reply) {
        Object value = inMessage.get(CamelConstants.CAMEL_CORRELATION_ID);
        if (value != null) {
            reply.getIn().setHeader(CamelConstants.CAMEL_CORRELATION_ID, value);
        }
    }
}
"
org.apache.camel.spring.spi.SpringConverters,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import org.aopalliance.intercept.MethodInvocation;
import org.apache.camel.Converter;
import org.apache.camel.component.bean.BeanInvocation;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
/**
 * Some Spring based
 * <a href=""http://activemq.apache.org/camel/type-converter.html"">Type Converters</a>
 *
 * @version $Revision$
 */
@Converter
public final class SpringConverters {
    private SpringConverters() {        
    }
    @Converter
    public static InputStream toInputStream(Resource resource) throws IOException {
        return resource.getInputStream();
    }
    @Converter
    public static File toFile(Resource resource) throws IOException {
        return resource.getFile();
    }
    @Converter
    public static URL toUrl(Resource resource) throws IOException {
        return resource.getURL();
    }
    @Converter
    public static UrlResource toResource(String uri) throws IOException {
        return new UrlResource(uri);
    }
    @Converter
    public static UrlResource toResource(URL uri) throws IOException {
        return new UrlResource(uri);
    }
    @Converter
    public static FileSystemResource toResource(File file) throws IOException {
        return new FileSystemResource(file);
    }
    @Converter
    public static ByteArrayResource toResource(byte[] data) throws IOException {
        return new ByteArrayResource(data);
    }
    @Converter
    public static BeanInvocation toBeanInvocation(MethodInvocation invocation) {
        return new BeanInvocation(invocation.getThis(), invocation.getMethod(), invocation.getArguments());
    }
}
"
org.apache.camel.component.file.remote.FtpConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.concurrent.ScheduledExecutorService;
import org.apache.camel.Processor;
import org.apache.camel.component.file.FileComponent;
import org.apache.commons.net.ftp.FTPClient;
import org.apache.commons.net.ftp.FTPFile;
public class FtpConsumer extends RemoteFileConsumer<RemoteFileExchange> {
    private boolean recursive = true;
    private String regexPattern = """";
    private long lastPollTime;
    private final FtpEndpoint endpoint;
    private FTPClient client;
    private boolean setNames = false;
    public FtpConsumer(FtpEndpoint endpoint, Processor processor, FTPClient client) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.client = client;
    }
    public FtpConsumer(FtpEndpoint endpoint, Processor processor, FTPClient client, ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
        this.endpoint = endpoint;
        this.client = client;
    }
    protected void poll() throws Exception {
        final String fileName = endpoint.getConfiguration().getFile();
        if (endpoint.getConfiguration().isDirectory()) {
            pollDirectory(fileName);
        } else {
            client.changeWorkingDirectory(fileName.substring(0, fileName.lastIndexOf('/')));
            final FTPFile[] files = client.listFiles(fileName.substring(fileName.lastIndexOf('/') + 1));
            pollFile(files[0]);
        }
        lastPollTime = System.currentTimeMillis();
    }
    protected void pollDirectory(String dir) throws Exception {
        client.changeWorkingDirectory(dir);
        for (FTPFile ftpFile : client.listFiles()) {
            if (ftpFile.isFile()) {
                pollFile(ftpFile);
            } else if (ftpFile.isDirectory()) {
                if (isRecursive()) {
                    pollDirectory(getFullFileName(ftpFile));
                }
            } else {
                throw new RuntimeException("""");
            }
        }
    }
    protected String getFullFileName(FTPFile ftpFile) throws IOException {
        return client.printWorkingDirectory() + ""/"" + ftpFile.getName();
    }
    private void pollFile(FTPFile ftpFile) throws Exception {
        if (ftpFile.getTimestamp().getTimeInMillis() > lastPollTime) { // TODO
                                                                       // do we
                                                                       // need
                                                                       // to
                                                                       // adjust
                                                                       // the
                                                                       // TZ?
                                                                       // can
                                                                       // we?
            if (isMatched(ftpFile)) {
                final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
                client.retrieveFile(ftpFile.getName(), byteArrayOutputStream);
                RemoteFileExchange exchange = endpoint.createExchange(getFullFileName(ftpFile), byteArrayOutputStream);
                if (isSetNames()) {
                    String relativePath = getFullFileName(ftpFile).substring(endpoint.getConfiguration().getFile().length());
                    if (relativePath.startsWith(""/"")) {
                        relativePath = relativePath.substring(1);
                    }
                    exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);
                }
                getProcessor().process(exchange);
            }
        }
    }
    protected boolean isMatched(FTPFile file) {
        boolean result = true;
        if (regexPattern != null && regexPattern.length() > 0) {
            result = file.getName().matches(getRegexPattern());
        }
        return result;
    }
    public boolean isRecursive() {
        return recursive;
    }
    public void setRecursive(boolean recursive) {
        this.recursive = recursive;
    }
    public long getLastPollTime() {
        return lastPollTime;
    }
    public void setLastPollTime(long lastPollTime) {
        this.lastPollTime = lastPollTime;
    }
    public String getRegexPattern() {
        return regexPattern;
    }
    public void setRegexPattern(String regexPattern) {
        this.regexPattern = regexPattern;
    }
    public boolean isSetNames() {
        return setNames;
    }
    public void setSetNames(boolean setNames) {
        this.setNames = setNames;
    }
}
"
org.apache.camel.component.velocity.VelocityComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.velocity;
import java.util.Map;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.velocity.app.VelocityEngine;
/**
 * @version $Revision: 1.1 $
 */
public class VelocityComponent extends DefaultComponent {
    private VelocityEngine velocityEngine = new VelocityEngine();
    public VelocityEngine getVelocityEngine() {
        return velocityEngine;
    }
    public void setVelocityEngine(VelocityEngine velocityEngine) {
        this.velocityEngine = velocityEngine;
    }
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new VelocityEndpoint(uri, this, remaining, parameters);
    }
}
"
org.apache.camel.builder.script.Python,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.language.LanguageAnnotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation for injection of Python expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""python"")
public @interface Python {
    public abstract String value();
}"
org.apache.camel.component.quartz.QuartzEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import java.util.Date;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.processor.loadbalancer.LoadBalancer;
import org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.quartz.JobDetail;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.SimpleTrigger;
import org.quartz.Trigger;
/**
 * A <a href=""http://activemq.apache.org/quartz.html"">Quartz Endpoint</a>
 * 
 * @version $Revision:520964 $
 */
public class QuartzEndpoint extends DefaultEndpoint<QuartzExchange> {
    public static final String ENDPOINT_KEY = ""org.apache.camel.quartz"";
    private static final transient Log LOG = LogFactory.getLog(QuartzEndpoint.class);
    private Scheduler scheduler;
    private LoadBalancer loadBalancer;
    private Trigger trigger;
    private JobDetail jobDetail;
    private boolean started;
    public QuartzEndpoint(String endpointUri, QuartzComponent component, Scheduler scheduler) {
        super(endpointUri, component);
        this.scheduler = scheduler;
    }
    public void addTriggers(Map<Trigger, JobDetail> triggerMap) throws SchedulerException {
        if (triggerMap != null) {
            Set<Map.Entry<Trigger, JobDetail>> entries = triggerMap.entrySet();
            for (Map.Entry<Trigger, JobDetail> entry : entries) {
                Trigger key = entry.getKey();
                JobDetail value = entry.getValue();
                ObjectHelper.notNull(key, ""key"");
                ObjectHelper.notNull(value, ""value"");
                addTrigger(key, value);
            }
        }
    }
    public void addTrigger(Trigger trigger, JobDetail detail) throws SchedulerException {
        // lets default the trigger name to the job name
        if (trigger.getName() == null) {
            trigger.setName(detail.getName());
        }
        // lets default the trigger group to the job group
        if (trigger.getGroup() == null) {
            trigger.setGroup(detail.getGroup());
        }
        // default start time to now if not specified
        if (trigger.getStartTime() == null) {
            trigger.setStartTime(new Date());
        }
        detail.getJobDataMap().put(ENDPOINT_KEY, this);
        Class jobClass = detail.getJobClass();
        if (jobClass == null) {
            detail.setJobClass(CamelJob.class);
        }
        if (detail.getName() == null) {
            detail.setName(getEndpointUri());
        }
        getScheduler().scheduleJob(detail, trigger);
    }
    public void removeTrigger(Trigger trigger, JobDetail jobDetail) throws SchedulerException {
        getScheduler().unscheduleJob(trigger.getName(), trigger.getGroup());
    }
    /**
     * This method is invoked when a Quartz job is fired.
     * 
     * @param jobExecutionContext the Quartz Job context
     */
    public void onJobExecute(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Firing Quartz Job with context: "" + jobExecutionContext);
        }
        QuartzExchange exchange = createExchange(jobExecutionContext);
        try {
            getLoadBalancer().process(exchange);
        } catch (JobExecutionException e) {
            throw e;
        } catch (Exception e) {
            throw new JobExecutionException(e);
        }
    }
    @Override
    public QuartzExchange createExchange(ExchangePattern pattern) {
        return new QuartzExchange(getContext(), pattern, null);
    }
    public QuartzExchange createExchange(JobExecutionContext jobExecutionContext) {
        return new QuartzExchange(getContext(), getExchangePattern(), jobExecutionContext);
    }
    public Producer<QuartzExchange> createProducer() throws Exception {
        throw new UnsupportedOperationException(""You cannot send messages to this endpoint"");
    }
    public QuartzConsumer createConsumer(Processor processor) throws Exception {
        return new QuartzConsumer(this, processor);
    }
    // Properties
    // -------------------------------------------------------------------------
    @Override
    public QuartzComponent getComponent() {
        return (QuartzComponent)super.getComponent();
    }
    public boolean isSingleton() {
        return true;
    }
    public Scheduler getScheduler() {
        return scheduler;
    }
    public LoadBalancer getLoadBalancer() {
        if (loadBalancer == null) {
            loadBalancer = createLoadBalancer();
        }
        return loadBalancer;
    }
    public void setLoadBalancer(LoadBalancer loadBalancer) {
        this.loadBalancer = loadBalancer;
    }
    public JobDetail getJobDetail() {
        if (jobDetail == null) {
            jobDetail = createJobDetail();
        }
        return jobDetail;
    }
    public void setJobDetail(JobDetail jobDetail) {
        this.jobDetail = jobDetail;
    }
    public Trigger getTrigger() {
        if (trigger == null) {
            trigger = createTrigger();
        }
        return trigger;
    }
    public void setTrigger(Trigger trigger) {
        this.trigger = trigger;
    }
    // Implementation methods
    // -------------------------------------------------------------------------
    public synchronized void consumerStarted(QuartzConsumer consumer) throws SchedulerException {
        getLoadBalancer().addProcessor(consumer.getProcessor());
        // if we have not yet added our default trigger, then lets do it
        if (!started) {
            addTrigger(getTrigger(), getJobDetail());
            started = true;
        }
    }
    public synchronized void consumerStopped(QuartzConsumer consumer) throws SchedulerException {
        getLoadBalancer().removeProcessor(consumer.getProcessor());
        if (getLoadBalancer().getProcessors().isEmpty() && started) {
            removeTrigger(getTrigger(), getJobDetail());
            started = false;
        }
    }
    protected LoadBalancer createLoadBalancer() {
        return new RoundRobinLoadBalancer();
    }
    protected JobDetail createJobDetail() {
        return new JobDetail();
    }
    protected Trigger createTrigger() {
        return new SimpleTrigger();
    }
}
"
org.apache.camel.component.xmpp.XmppBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import java.util.Map;
import java.util.Set;
import org.apache.camel.Exchange;
import org.jivesoftware.smack.packet.Message;
/**
 * A Strategy used to convert between a Camel {@XmppExchange} and {@XmppMessage} to and from a
 * XMPP {@link Message}
 *
 * @version $Revision$
 */
public class XmppBinding {
    /**
     * Populates the given XMPP message from the inbound exchange
     */
    public void populateXmppMessage(Message message, Exchange exchange) {
        message.setBody(exchange.getIn().getBody(String.class));
        Set<Map.Entry<String, Object>> entries = exchange.getIn().getHeaders().entrySet();
        for (Map.Entry<String, Object> entry : entries) {
            String name = entry.getKey();
            Object value = entry.getValue();
            if (shouldOutputHeader(exchange, name, value)) {
                message.setProperty(name, value);
            }
        }
        String id = exchange.getExchangeId();
        if (id != null) {
            message.setProperty(""exchangeId"", id);
        }
    }
    /**
     * Extracts the body from the XMPP message
     *
     * @param exchange
     * @param message
     */
    public Object extractBodyFromXmpp(XmppExchange exchange, Message message) {
        return message.getBody();
    }
    /**
     * Strategy to allow filtering of headers which are put on the XMPP message
     */
    protected boolean shouldOutputHeader(Exchange exchange, String headerName, Object headerValue) {
        return true;
    }
}
"
org.apache.camel.component.jms.EndpointMessageListener,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import javax.jms.MessageListener;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.RuntimeCamelException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A JMS {@link MessageListener} which can be used to delegate processing to a
 * Camel endpoint.
 * 
 * @version $Revision$
 */
public class EndpointMessageListener<E extends Exchange> implements MessageListener {
    private static final transient Log LOG = LogFactory.getLog(EndpointMessageListener.class);
    private JmsEndpoint endpoint;
    private Processor processor;
    private JmsBinding binding;
    private boolean eagerLoadingOfProperties;
    public EndpointMessageListener(JmsEndpoint endpoint, Processor processor) {
        this.endpoint = endpoint;
        this.processor = processor;
    }
    public void onMessage(Message message) {
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug(endpoint + "" receiving JMS message: "" + message);
            }
            JmsExchange exchange = createExchange(message);
            if (eagerLoadingOfProperties) {
                exchange.getIn().getHeaders();
            }
            processor.process(exchange);
        } catch (Exception e) {
            throw new RuntimeCamelException(e);
        }
    }
    public JmsExchange createExchange(Message message) {
        return new JmsExchange(endpoint.getContext(), endpoint.getExchangePattern(), getBinding(), message);
    }
    // Properties
    // -------------------------------------------------------------------------
    public JmsBinding getBinding() {
        if (binding == null) {
            binding = new JmsBinding();
        }
        return binding;
    }
    /**
     * Sets the binding used to convert from a Camel message to and from a JMS
     * message
     * 
     * @param binding the binding to use
     */
    public void setBinding(JmsBinding binding) {
        this.binding = binding;
    }
    public boolean isEagerLoadingOfProperties() {
        return eagerLoadingOfProperties;
    }
    public void setEagerLoadingOfProperties(boolean eagerLoadingOfProperties) {
        this.eagerLoadingOfProperties = eagerLoadingOfProperties;
    }
}
"
org.apache.camel.component.mina.MinaComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.URI;
import java.util.Map;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoConnector;
import org.apache.mina.common.support.BaseIoConnectorConfig;
import org.apache.mina.filter.codec.ProtocolCodecFilter;
import org.apache.mina.filter.codec.serialization.ObjectSerializationCodecFactory;
import org.apache.mina.filter.codec.textline.TextLineCodecFactory;
import org.apache.mina.transport.socket.nio.DatagramAcceptor;
import org.apache.mina.transport.socket.nio.DatagramConnector;
import org.apache.mina.transport.socket.nio.DatagramConnectorConfig;
import org.apache.mina.transport.socket.nio.SocketAcceptor;
import org.apache.mina.transport.socket.nio.SocketConnector;
import org.apache.mina.transport.socket.nio.SocketConnectorConfig;
import org.apache.mina.transport.vmpipe.VmPipeAcceptor;
import org.apache.mina.transport.vmpipe.VmPipeAddress;
import org.apache.mina.transport.vmpipe.VmPipeConnector;
/**
 * @version $Revision$
 */
public class MinaComponent extends DefaultComponent<MinaExchange> {
    public MinaComponent() {
    }
    public MinaComponent(CamelContext context) {
        super(context);
    }
    @Override
    protected Endpoint<MinaExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        URI u = new URI(remaining);
        String protocol = u.getScheme();
        if (protocol.equals(""tcp"")) {
            return createSocketEndpoint(uri, u, parameters);
        } else if (protocol.equals(""udp"") || protocol.equals(""mcast"") || protocol.equals(""multicast"")) {
            return createDatagramEndpoint(uri, u, parameters);
        } else if (protocol.equals(""vm"")) {
            return createVmEndpoint(uri, u);
        } else {
            throw new IOException(""Unrecognised MINA protocol: "" + protocol + "" for uri: "" + uri);
        }
    }
    protected MinaEndpoint createVmEndpoint(String uri, URI connectUri) {
        IoAcceptor acceptor = new VmPipeAcceptor();
        SocketAddress address = new VmPipeAddress(connectUri.getPort());
        IoConnector connector = new VmPipeConnector();
        return new MinaEndpoint(uri, this, address, acceptor, connector, null);
    }
    protected MinaEndpoint createSocketEndpoint(String uri, URI connectUri, Map parameters) {
        IoAcceptor acceptor = new SocketAcceptor();
        SocketAddress address = new InetSocketAddress(connectUri.getHost(), connectUri.getPort());
        IoConnector connector = new SocketConnector();
        // TODO customize the config via URI
        SocketConnectorConfig config = new SocketConnectorConfig();
        configureCodecFactory(config, parameters);
        return new MinaEndpoint(uri, this, address, acceptor, connector, config);
    }
    protected MinaEndpoint createDatagramEndpoint(String uri, URI connectUri, Map parameters) {
        IoAcceptor acceptor = new DatagramAcceptor();
        SocketAddress address = new InetSocketAddress(connectUri.getHost(), connectUri.getPort());
        IoConnector connector = new DatagramConnector();
        // TODO customize the config via URI
        DatagramConnectorConfig config = new DatagramConnectorConfig();
        configureCodecFactory(config, parameters);
        return new MinaEndpoint(uri, this, address, acceptor, connector, config);
    }
    protected void configureCodecFactory(BaseIoConnectorConfig config, Map parameters){
        boolean textline = false;
        if (parameters != null) {
            if (parameters.containsKey(""codec"")) {
                String value = (String) parameters.get(""codec"");
                if (value.equals(""textline"")) {
                    textline = true;
                }
            } else {
                textline = false;
            }
        }
        if (textline) {
            config.getFilterChain().addLast(""codec"", new ProtocolCodecFilter(new TextLineCodecFactory()));
        } else {
            config.getFilterChain().addLast(""codec"", new ProtocolCodecFilter(new ObjectSerializationCodecFactory()));
        }
    }
}
"
org.apache.camel.component.xmpp.XmppGroupChatProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.xmpp;
import org.apache.camel.Exchange;
import org.apache.camel.impl.DefaultProducer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jivesoftware.smack.GroupChat;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.Message;
/**
 * @version $Revision$
 */
public class XmppGroupChatProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(XmppGroupChatProducer.class);
    private final XmppEndpoint endpoint;
    private final String room;
    private GroupChat chat;
    public XmppGroupChatProducer(XmppEndpoint endpoint, String room) {
        super(endpoint);
        this.endpoint = endpoint;
        this.room = room;
        if (room == null) {
            throw new IllegalArgumentException(""No room property specified"");
        }
    }
    public void process(Exchange exchange) {
        // TODO it would be nice if we could reuse the message from the exchange
        Message message = chat.createMessage();
        message.setTo(room);
        message.setFrom(endpoint.getUser());
        endpoint.getBinding().populateXmppMessage(message, exchange);
        if (LOG.isDebugEnabled()) {
            LOG.debug("">>>> message: "" + message.getBody());
        }
        try {
            chat.sendMessage(message);
        } catch (XMPPException e) {
            throw new RuntimeXmppException(e);
        }
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        if (chat == null) {
            chat = endpoint.getConnection().createGroupChat(room);
        }
    }
    @Override
    protected void doStop() throws Exception {
        if (chat != null) {
            chat.leave();
            chat = null;
        }
        super.doStop();
    }
    // Properties
    // -------------------------------------------------------------------------
    public GroupChat getChat() {
        return chat;
    }
    public void setChat(GroupChat chat) {
        this.chat = chat;
    }
    public String getRoom() {
        return room;
    }
}
"
org.apache.camel.spring.spi.ApplicationContextRegistry,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.spi.Registry;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.context.ApplicationContext;
/**
 * A {@link Registry} implementation which looks up the objects in the Spring
 * {@link ApplicationContext}
 * 
 * @version $Revision: 1.1 $
 */
public class ApplicationContextRegistry implements Registry {
    private ApplicationContext applicationContext;
    public ApplicationContextRegistry(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public <T> T lookup(String name, Class<T> type) {
        try {
            Object value = applicationContext.getBean(name, type);
            return type.cast(value);
        } catch (NoSuchBeanDefinitionException e) {
            return null;
        }
    }
    public Object lookup(String name) {
        try {
            return applicationContext.getBean(name);
        } catch (NoSuchBeanDefinitionException e) {
            return null;
        }
    }
}
"
org.apache.camel.component.file.remote.RemoteFileProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.component.file.FileComponent;
import org.apache.camel.impl.DefaultProducer;
public abstract class RemoteFileProducer<T extends RemoteFileExchange> extends DefaultProducer<T> {
    protected RemoteFileProducer(RemoteFileEndpoint<T> endpoint) {
        super(endpoint);
    }
    protected String createFileName(Message message, RemoteFileConfiguration fileConfig) {
        String answer;
        String endpointFileName = fileConfig.getFile();
        String headerFileName = message.getHeader(FileComponent.HEADER_FILE_NAME, String.class);
        if (fileConfig.isDirectory()) {
            if (headerFileName != null) {
                answer = endpointFileName + ""/"" + headerFileName;
            } else {
                answer = endpointFileName + ""/"" + message.getMessageId();
            }
        } else {
            answer = endpointFileName;
        }
        return answer;
    }
}
"
org.apache.camel.bam.ActivityBuilder,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
import java.util.Date;
import org.apache.camel.Endpoint;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.builder.ProcessorFactory;
import org.apache.camel.impl.EventDrivenConsumerRoute;
/**
 * @version $Revision: $
 */
public class ActivityBuilder implements ProcessorFactory {
    private ProcessBuilder processBuilder;
    private Endpoint endpoint;
    private ActivityRules activityRules;
    private Expression correlationExpression;
    public ActivityBuilder(ProcessBuilder processBuilder, Endpoint endpoint) {
        this.processBuilder = processBuilder;
        this.endpoint = endpoint;
        this.activityRules = new ActivityRules(processBuilder);
        this.activityRules.setActivityName(endpoint.getEndpointUri());
    }
    public Endpoint getEndpoint() {
        return endpoint;
    }
    public Processor createProcessor() throws Exception {
        return processBuilder.createActivityProcessor(this);
    }
    public Route createRoute() throws Exception {
        Processor processor = createProcessor();
        if (processor == null) {
            throw new IllegalArgumentException(""No processor created for ActivityBuilder: "" + this);
        }
        return new EventDrivenConsumerRoute(getEndpoint(), processor);
    }
    // Builder methods
    //-----------------------------------------------------------------------
    public ActivityBuilder correlate(Expression correlationExpression) {
        this.correlationExpression = correlationExpression;
        return this;
    }
    public ActivityBuilder name(String name) {
        activityRules.setActivityName(name);
        return this;
    }
    /**
     * Create a temporal rule for when this step starts
     */
    public TimeExpression starts() {
        return new TimeExpression(this, ActivityLifecycle.Started) {
            public Date evaluate(ProcessInstance instance, ActivityState state) {
                return state.getTimeStarted();
            }
        };
    }
    /**
     * Create a temporal rule for when this step completes
     */
    public TimeExpression completes() {
        return new TimeExpression(this, ActivityLifecycle.Completed) {
            public Date evaluate(ProcessInstance instance, ActivityState state) {
                return state.getTimeCompleted();
            }
        };
    }
    // Properties
    //-----------------------------------------------------------------------
    public Expression getCorrelationExpression() {
        return correlationExpression;
    }
    public ActivityRules getActivityRules() {
        return activityRules;
    }
    public ProcessBuilder getProcessBuilder() {
        return processBuilder;
    }
}
"
org.apache.camel.component.cxf.CxfConstants,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
/**
 * Constants used in this module
 *
 * @version $Revision$
 */
public interface CxfConstants {
    String METHOD = ""method"";
    String SEI = ""sei"";
    String IMPL = ""impl"";
    String WSDL_URL = ""wsdlURL"";
    String ADDRESS = ""address"";
    String SERVICE_NAME = ""serviceName"";
    String PORT_NAME = ""portName"";
    String PROTOCOL_NAME_RES = ""res"";
    String OPERATION_NAME = ""operationName"";
    String SPRING_CONTEXT_ENDPOINT = ""bean:"";
    // service name -- come from the wsdl   
}
"
org.apache.camel.component.cxf.phase.FaultPayloadPhaseManagerImpl,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.phase;
import java.util.SortedSet;
import org.apache.cxf.common.util.SortedArraySet;
import org.apache.cxf.phase.Phase;
public class FaultPayloadPhaseManagerImpl extends AbstractPhaseManagerImpl {
    protected SortedSet<Phase> createInPhases() {
        SortedSet<Phase> inPhases = new SortedArraySet<Phase>();
        int i = 0;
        inPhases.add(new Phase(Phase.RECEIVE, ++i * 1000));
        inPhases.add(new Phase(Phase.PRE_STREAM, ++i * 1000));
        inPhases.add(new Phase(Phase.USER_STREAM, ++i * 1000));
        inPhases.add(new Phase(Phase.POST_STREAM, ++i * 1000));
        inPhases.add(new Phase(Phase.READ, ++i * 1000));
        inPhases.add(new Phase(Phase.PRE_PROTOCOL, ++i * 1000));
        inPhases.add(new Phase(Phase.USER_PROTOCOL, ++i * 1000));
        inPhases.add(new Phase(Phase.POST_PROTOCOL, ++i * 1000));
        inPhases.add(new Phase(Phase.UNMARSHAL, ++i * 1000));
        return inPhases;
    }
    protected SortedSet<Phase> createOutPhases() {
        SortedSet<Phase> outPhases = new SortedArraySet<Phase>();
        int i = 0;
        outPhases.add(new Phase(Phase.PREPARE_SEND, ++i * 1000));
        outPhases.add(new Phase(Phase.PRE_STREAM, ++i * 1000));
        outPhases.add(new Phase(Phase.PRE_PROTOCOL, ++i * 1000));
        outPhases.add(new Phase(Phase.USER_PROTOCOL, ++i * 1000));
        outPhases.add(new Phase(Phase.POST_PROTOCOL, ++i * 1000));
        outPhases.add(new Phase(Phase.WRITE, ++i * 1000));
        outPhases.add(new Phase(Phase.MARSHAL, ++i * 1000));
        outPhases.add(new Phase(Phase.USER_STREAM, ++i * 1000));
        outPhases.add(new Phase(Phase.POST_STREAM, ++i * 1000));
        outPhases.add(new Phase(Phase.SEND, ++i * 1000));
        outPhases.add(new Phase(Phase.SEND_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.POST_STREAM_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.USER_STREAM_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.POST_PROTOCOL_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.USER_PROTOCOL_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.WRITE_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.PRE_PROTOCOL_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.PRE_STREAM_ENDING, ++i * 1000));
        outPhases.add(new Phase(Phase.PREPARE_SEND_ENDING, ++i * 1000));
        return outPhases;
    }
}
"
org.apache.camel.component.ibatis.IBatisEndpoint,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import java.io.IOException;
import org.apache.camel.PollingConsumer;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultPollingEndpoint;
import com.ibatis.sqlmap.client.SqlMapClient;
/**
 * An <a href=""http://activemq.apache.org/camel/ibatis.html>iBatis Endpoint</a>
 * for performing SQL operations using an XML mapping file to abstract away the SQL
 *
 * @version $Revision: 1.1 $
 */
public class IBatisEndpoint extends DefaultPollingEndpoint {
    private final String entityName;
    public IBatisEndpoint(String endpointUri, IBatisComponent component, String entityName) {
        super(endpointUri, component);
        this.entityName = entityName;
    }
    @Override
    public IBatisComponent getComponent() {
        return (IBatisComponent) super.getComponent();
    }
    public boolean isSingleton() {
        return true;
    }
    public Producer createProducer() throws Exception {
        return new IBatisProducer(this); 
    }
    @Override
    public PollingConsumer createPollingConsumer() throws Exception {
        return new IBatisPollingConsumer(this);
    }
    /**
     * Returns the iBatis SQL client
     */
    public SqlMapClient getSqlClient() throws IOException {
        return getComponent().getSqlMapClient();
    }
    public String getEntityName() {
        return entityName;
    }
}
"
org.apache.camel.bam.model.ProcessDefinition,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import java.util.List;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.UniqueConstraint;
import org.apache.camel.util.ObjectHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaTemplate;
/**
 * @version $Revision: 1.1 $
 */
@Entity
@UniqueConstraint(columnNames = {""name"" })
public class ProcessDefinition extends EntitySupport {
    private static final transient Log LOG = LogFactory.getLog(ProcessDefinition.class);
    private String name;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public static ProcessDefinition getRefreshedProcessDefinition(JpaTemplate template, ProcessDefinition definition) {
        // TODO refresh doesn't tend to work - maybe its a spring thing?
        // template.refresh(definition);
        ObjectHelper.notNull(definition, ""definition"");
        Long id = definition.getId();
        if (id == null) {
            LOG.warn(""No primary key is available!"");
            return findOrCreateProcessDefinition(template, definition.getName());
        }
        definition = template.find(ProcessDefinition.class, id);
        return definition;
    }
    public static ProcessDefinition findOrCreateProcessDefinition(JpaTemplate template, String processName) {
        List<ProcessDefinition> list = template.find(""select x from "" + ProcessDefinition.class.getName() + "" x where x.name = ?1"", processName);
        if (!list.isEmpty()) {
            return list.get(0);
        } else {
            ProcessDefinition answer = new ProcessDefinition();
            answer.setName(processName);
            template.persist(answer);
            return answer;
        }
    }
}
"
org.apache.camel.spring.util.MainRunner,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.util;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.InitializingBean;
import static org.apache.camel.util.ObjectHelper.name;
/**
 * A simple helper bean for running main classes from within the spring.xml
 * usually asynchronous in a background thread; which is useful for demos such
 * as running Swing programs in the same JVM.
 * 
 * @version $Revision: $
 */
public class MainRunner implements InitializingBean, Runnable {
    private static final Log LOG = LogFactory.getLog(MainRunner.class);
    private Class main;
    private String[] args = {};
    private boolean asyncRun = true;
    private long delay;
    public String toString() {
        return ""MainRunner("" + name(main) + "" "" + Arrays.asList(getArgs()) + "")"";
    }
    public void run() {
        try {
            runMethodWithoutCatchingExceptions();
        } catch (NoSuchMethodException e) {
            LOG.error(""Class: "" + name(main) + "" does not have a main method: "" + e, e);
        } catch (IllegalAccessException e) {
            LOG.error(""Failed to run: "" + this + "". Reason: "" + e, e);
        } catch (InvocationTargetException e) {
            Throwable throwable = e.getTargetException();
            LOG.error(""Failed to run: "" + this + "". Reason: "" + throwable, throwable);
        }
    }
    public void runMethodWithoutCatchingExceptions() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
        if (delay > 0) {
            try {
                Thread.sleep(delay);
            } catch (InterruptedException e) {
                LOG.info(""Caught: "" + e, e);
            }
        }
        Method method = main.getMethod(""main"", String[].class);
        if (!Modifier.isStatic(method.getModifiers())) {
            throw new IllegalArgumentException(""The main method is not static!: "" + method);
        }
        Object[] arguments = {getArgs()};
        method.invoke(null, arguments);
    }
    public String[] getArgs() {
        return args;
    }
    public void setArgs(String[] args) {
        this.args = args;
    }
    public boolean isAsyncRun() {
        return asyncRun;
    }
    public void setAsyncRun(boolean asyncRun) {
        this.asyncRun = asyncRun;
    }
    public Class getMain() {
        return main;
    }
    public void setMain(Class main) {
        this.main = main;
    }
    public long getDelay() {
        return delay;
    }
    public void setDelay(long delay) {
        this.delay = delay;
    }
    public void afterPropertiesSet() throws Exception {
        if (main == null) {
            throw new IllegalArgumentException(""You must specify a main class!"");
        }
        if (isAsyncRun()) {
            Thread thread = new Thread(this, ""Thread for: "" + this);
            thread.start();
        } else {
            runMethodWithoutCatchingExceptions();
        }
    }
}
"
org.apache.camel.component.jms.JmsPollingConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.Message;
import org.apache.camel.impl.PollingConsumerSupport;
import org.springframework.jms.core.JmsOperations;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;
/**
 * @version $Revision: 1.1 $
 */
public class JmsPollingConsumer extends PollingConsumerSupport<JmsExchange> {
    private JmsOperations template;
    public JmsPollingConsumer(JmsEndpoint endpoint, JmsOperations template) {
        super(endpoint);
        this.template = template;
    }
    @Override
    public JmsEndpoint getEndpoint() {
        return (JmsEndpoint)super.getEndpoint();
    }
    public JmsExchange receiveNoWait() {
        return receive(0);
    }
    public JmsExchange receive() {
        return receive(-1);
    }
    public JmsExchange receive(long timeout) {
        setReceiveTimeout(timeout);
        Message message = template.receive();
        if (message != null) {
            return getEndpoint().createExchange(message);
        }
        return null;
    }
    protected void doStart() throws Exception {
    }
    protected void doStop() throws Exception {
    }
    protected void setReceiveTimeout(long timeout) {
        if (template instanceof JmsTemplate) {
            JmsTemplate jmsTemplate = (JmsTemplate)template;
            jmsTemplate.setReceiveTimeout(timeout);
        } else if (template instanceof JmsTemplate102) {
            JmsTemplate102 jmsTemplate102 = (JmsTemplate102)template;
            jmsTemplate102.setReceiveTimeout(timeout);
        } else {
            throw new IllegalArgumentException(""Cannot set the receiveTimeout property on unknown JmsOperations type: "" + template);
        }
    }
}
"
org.apache.camel.component.irc.IrcMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.irc;
import java.util.Map;
import org.apache.camel.impl.DefaultMessage;
import org.schwering.irc.lib.IRCUser;
public class IrcMessage extends DefaultMessage {
    private String messageType;
    private String target;
    private IRCUser user;
    private String whoWasKickedNick;
    private String message;
    public IrcMessage() {
    }
    public IrcMessage(String messageType, IRCUser user, String message) {
        this.messageType = messageType;
        this.user = user;
        this.message = message;
    }
    public IrcMessage(String messageType, String target, IRCUser user, String message) {
        this.messageType = messageType;
        this.target = target;
        this.user = user;
        this.message = message;
    }
    public IrcMessage(String messageType, String target, IRCUser user, String whoWasKickedNick, String message) {
        this.messageType = messageType;
        this.target = target;
        this.user = user;
        this.whoWasKickedNick = whoWasKickedNick;
        this.message = message;
    }
    public IrcMessage(String messageType, String target, IRCUser user) {
        this.messageType = messageType;
        this.target = target;
        this.user = user;
    }
    public String getMessageType() {
        return messageType;
    }
    public void setMessageType(String messageType) {
        this.messageType = messageType;
    }
    public String getTarget() {
        return target;
    }
    public void setTarget(String target) {
        this.target = target;
    }
    public IRCUser getUser() {
        return user;
    }
    public void setUser(IRCUser user) {
        this.user = user;
    }
    public String getWhoWasKickedNick() {
        return whoWasKickedNick;
    }
    public void setWhoWasKickedNick(String whoWasKickedNick) {
        this.whoWasKickedNick = whoWasKickedNick;
    }
    public String getMessage() {
        return message;
    }
    public void setMessage(String message) {
        this.message = message;
    }
    @Override
    public IrcExchange getExchange() {
        return (IrcExchange)super.getExchange();
    }
    @Override
    protected Object createBody() {
        IrcExchange ircExchange = getExchange();
        IrcBinding binding = ircExchange.getBinding();
        return binding.extractBodyFromIrc(ircExchange, this);
    }
    @Override
    public IrcMessage newInstance() {
        return new IrcMessage();
    }
    @Override
    protected void populateInitialHeaders(Map<String, Object> map) {
        map.put(""irc.messageType"", messageType);
        if (target != null) {
            map.put(""irc.target"", target);
        }
        if (whoWasKickedNick != null) {
            map.put(""irc.user.kicked"", whoWasKickedNick);
        }
        if (user != null) {
            map.put(""irc.user.host"", user.getHost());
            map.put(""irc.user.nick"", user.getNick());
            map.put(""irc.user.servername"", user.getServername());
            map.put(""irc.user.username"", user.getUsername());
        }
    }
    @Override
    public String toString() {
        if (message != null) {
            return ""IrcMessage: "" + message;
        } else {
            return ""IrcMessage: "" + getBody();
        }
    }
}
"
org.apache.camel.converter.jaxb.ExchangeType,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import java.util.ArrayList;
import java.util.List;
/**
 * @version $Revision: $
 */
@XmlRootElement(name = ""exchange"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class ExchangeType {
    @XmlElement(name = ""property"", required = false)
    List<PropertyType> properties = new ArrayList<PropertyType>();
    @XmlAnyElement(lax = true)
    private Object body;
    public Object getBody() {
        return body;
    }
    public void setBody(Object body) {
        this.body = body;
    }
    public List<PropertyType> getProperties() {
        return properties;
    }
    public void setProperties(List<PropertyType> properties) {
        this.properties = properties;
    }
}"
org.apache.camel.component.mail.MailConverters,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.io.IOException;
import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.internet.MimeMultipart;
import org.apache.camel.Converter;
/**
 * @version $Revision: 1.1 $
 */
@Converter
public class MailConverters {
    /**
     * Converts the given JavaMail message to a String body
     *
     * @param message the message
     * @return the String content
     * @throws MessagingException
     * @throws IOException
     */
    @Converter
    public String toString(Message message) throws MessagingException, IOException {
        Object content = message.getContent();
        if (content instanceof MimeMultipart) {
            MimeMultipart multipart = (MimeMultipart) content;
            if (multipart.getCount() > 0) {
                BodyPart part = multipart.getBodyPart(0);
                content = part.getContent();
            }
        }
        if (content != null) {
            return content.toString();
        }
        return null;
    }
    @Converter
    public static String toString(Multipart multipart) throws MessagingException, IOException {
        int size = multipart.getCount();
        for (int i = 0; i < size; i++) {
            BodyPart part = multipart.getBodyPart(i);
            if (part.getContentType().startsWith(""text"")) {
                return part.getContent().toString();
            }
        }
        return null;
    }
}
"
org.apache.camel.component.cxf.interceptors.AbstractMessageInInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.xml.namespace.QName;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.service.model.OperationInfo;
import org.apache.cxf.staxutils.StaxUtils;
/**
 * This is the base class for message interceptors that intercepts message as DOM content
 * infers the BindingOperationInfo and then set the
 *
 */
public abstract class AbstractMessageInInterceptor<T extends Message> 
       extends AbstractPhaseInterceptor<T> {
    private static final Logger LOG = LogUtils.getL7dLogger(AbstractMessageInInterceptor.class);
    public AbstractMessageInInterceptor(String phase) {
        super(phase);
    }
    protected boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    /**
     * Infer the OperationInfo from the XML Document and get the list of 
     * parts as DOM Element
     */
    public void handleMessage(T message) throws Fault {
        Logger logger = getLogger();
        if (isFaultMessage(message)) {
            message.getInterceptorChain().abort();
            Endpoint ep = message.getExchange().get(Endpoint.class);
            if (ep.getInFaultObserver() != null) {
                ep.getInFaultObserver().onMessage(message);
                return;
            }
            //Fault f = createFault(message, payloadEl);
            //message.setContent(Exception.class, f);
            //return;
        }
        Document document = createDOMMessage(message);
        //Document document = message.getContent(Document.class);
        Element payloadEl = (Element)document.getChildNodes().item(0);
        Exchange ex = message.getExchange();
        BindingOperationInfo boi = ex.get(BindingOperationInfo.class);
        if (boi == null) {
            BindingInfo bi = ex.get(BindingInfo.class);
            if (bi == null) {
                Endpoint ep = ex.get(Endpoint.class);
                bi = ep.getEndpointInfo().getBinding();
                ex.put(BindingInfo.class, bi);
            }
            // handling inbound message
            if (logger.isLoggable(Level.INFO)) {
                logger.info(""AbstractRoutingMessageInInterceptor Infer BindingOperationInfo."");
            }
            boi = getBindingOperation(message, document);
            if (boi == null) {
                QName startQName = new QName(payloadEl.getNamespaceURI(), payloadEl.getLocalName());
                throw new Fault(new org.apache.cxf.common.i18n.Message(
                                ""REQ_NOT_UNDERSTOOD"", LOG, startQName));
            }
            if (boi != null) {
                ex.put(BindingOperationInfo.class, boi);
                ex.put(OperationInfo.class, boi.getOperationInfo());
                ex.setOneWay(boi.getOperationInfo().isOneWay());
                if (logger.isLoggable(Level.INFO)) {
                    logger.info(""DOMInInterceptor- BindingOperation is:"" + boi.getName());
                }                
            }
        }
        BindingMessageInfo bmi = isRequestor(message) ?  boi.getOutput() : boi.getInput();
        List<Element> partList = getPartList(message, payloadEl, bmi);        
        message.put(List.class, partList);
        Element header = getHeader(message);
        message.put(Element.class, header);
    }
    /**
     * This method is called to convert a incoming message format e.g Stax Stream
     * to a DOM Tree. Default Implementation converts Stax Stream to a DOM
     * @param inMessage
     * @param Document
     */
    protected Document createDOMMessage(T message) {
        Document doc = null;
        try {
            if (getLogger().isLoggable(Level.INFO)) {
                getLogger().info(""AbstractMessageInInterceptor Converting Stax Stream to DOM"");
            }
            XMLStreamReader xsr = message.getContent(XMLStreamReader.class);            
            doc = StaxUtils.read(xsr);
        } catch (XMLStreamException xe) {
            throw new Fault(new org.apache.cxf.common.i18n.Message(""STAX_READ_EXC"", LOG), xe);
        }
        return doc;
    }
    protected abstract Logger getLogger();
    /**
     * This method is called on incoming to check if it is a fault.
     * @param inMessage
     * @param boolean
     */
    protected abstract boolean isFaultMessage(T message);
    /**
     * This method is called when the routing message interceptor has received a inbound message
     * It infers the binding operation by matching the root Element with a binding operation
     * from the service model.
     * @param inMessage
     * @param resultPayload
     */
    protected abstract BindingOperationInfo getBindingOperation(T inMessage, Document document);
    /**
     * This method is called when the routing message interceptor has intercepted a inbound
     * message as a DOM Content.  It retreives the message parts as DOM Element
     * and returns a List<Element>
     * @param inMessage
     * @param rootElement
     * @param bindingMessageInfo
     * @return List<Element>
     */
    protected abstract List<Element> getPartList(T inMessage, Element rootElement, BindingMessageInfo boi);
    /**
     * This method is called when the routing message interceptor has intercepted a inbound
     * message as a DOM Content.  It retreives the header parts as DOM Element
     * and returns a Element.
     * @param inMessage
     * @return Element
     */
    protected abstract Element getHeader(T inMessage);
}
"
org.apache.camel.spring.handler.LazyLoadingBeanDefinitionParser,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import org.apache.camel.util.ObjectHelper;
/**
 * A {@link BeanDefinitionParser} which lazy loads the type on which it creates to allow the schema to be loosly coupled
 * with the camel jars.
 *
 * @version $Revision: 1.1 $
 */
public class LazyLoadingBeanDefinitionParser extends BeanDefinitionParser {
    private String className;
    private String moduleName;
    public LazyLoadingBeanDefinitionParser(String className, String moduleName) {
        this.className = className;
        this.moduleName = moduleName;
    }
    @Override
    protected Class loadType() {
        Class<?> answer = ObjectHelper.loadClass(className, getClass().getClassLoader());
        if (answer == null) {
            throw new IllegalArgumentException(""Class: "" + className + "" could not be found. You need to add Camel module: "" + moduleName + "" to your classpath"");
        }
        return answer;
    }
}
"
org.apache.camel.component.cxf.CxfEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.net.URI;
import java.net.URISyntaxException;
import javax.xml.namespace.QName;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.ExchangePattern;
import org.apache.camel.component.cxf.spring.CxfEndpointBean;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.spring.SpringCamelContext;
import org.apache.cxf.configuration.spring.ConfigurerImpl;
import org.apache.cxf.message.Message;
/**
 * Defines the <a href=""http://activemq.apache.org/camel/cxf.html"">CXF Endpoint</a>
 * 
 * @version $Revision$
 */
public class CxfEndpoint extends DefaultEndpoint<CxfExchange> {    
    private final CxfComponent component;
    private final String address;
    private String wsdlURL;
    private String serviceClass;
    private CxfBinding binding;
    private String portName;
    private String serviceName;
    private String dataFormat;
    private String beanId;
    private boolean isSpringContextEndpoint;
    private boolean inOut = true;
    private ConfigurerImpl configurer;
    private CxfEndpointBean cxfEndpointBean;
    public CxfEndpoint(String uri, String address, CxfComponent component) {
        super(uri, component);
        this.component = component;        
        this.address = address;
        if (address.startsWith(CxfConstants.SPRING_CONTEXT_ENDPOINT)) {
            isSpringContextEndpoint = true;
            //get the bean from spring context
            beanId = address.substring(CxfConstants.SPRING_CONTEXT_ENDPOINT.length());
            if (beanId.startsWith(""//"")) {
               beanId = beanId.substring(2);     
            }
            SpringCamelContext context = (SpringCamelContext) this.getContext();
            configurer = new ConfigurerImpl(context.getApplicationContext()); 
            cxfEndpointBean = (CxfEndpointBean) context.getApplicationContext().getBean(beanId);
            assert(cxfEndpointBean != null);
        }
    }
    public Producer<CxfExchange> createProducer() throws Exception {
        return new CxfProducer(this);
    }
    public Consumer<CxfExchange> createConsumer(Processor processor) throws Exception {
        return new CxfConsumer(this, processor);
    }
    public CxfExchange createExchange() {
        return new CxfExchange(getContext(), getExchangePattern(), getBinding());
    }
    public CxfExchange createExchange(ExchangePattern pattern) {
        return new CxfExchange(getContext(), pattern, getBinding());
    }
    public CxfExchange createExchange(Message inMessage) {
        return new CxfExchange(getContext(), getExchangePattern(), getBinding(), inMessage);
    }
    public String getDataFormat() {
        return dataFormat;
    }
    public void setDataFormat(String format) {
        dataFormat = format;
    }
    public boolean isSpringContextEndpoint() {
        return isSpringContextEndpoint;
    }
    public String getAddress() {
    	return address;
    }
    public String getWsdlURL() {
    	return wsdlURL;
    }
    public void setWsdlURL(String url) {
        wsdlURL = url;
    }
    public String getServiceClass() {
        return serviceClass;
    }
    public void setServiceClass(String className) {        
        serviceClass = className;
    }
    public void setPortName(String port) {
        portName = port;
    }
    public void setServiceName(String service) {
        serviceName = service;
    }
    public String getPortName(){
        return portName;
    }
    public String getServiceName() {
        return serviceName;
    }
    public CxfBinding getBinding() {
        if (binding == null) {
            binding = new CxfBinding();
        }
        return binding;
    }
    public void setBinding(CxfBinding binding) {
        this.binding = binding;
    }
    public boolean isInOut() {
        return inOut;
    }
    public void setInOut(boolean inOut) {
        this.inOut = inOut;
    }
    public CxfComponent getComponent() {
        return component;
    }
    public boolean isSingleton() {
        return true;
    }
    public String getBeanId() {
        return beanId;
    }
    public CxfEndpointBean getCxfEndpointBean() {
        return cxfEndpointBean;
    }
    public void configure(Object beanInstance) {
        configurer.configureBean(beanId, beanInstance);
    }
}
"
org.apache.camel.component.mail.MailConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import java.net.URI;
import java.util.Properties;
import javax.mail.Session;
import org.apache.camel.RuntimeCamelException;
/**
 * Represents the configuration data for communicating over email
 * 
 * @version $Revision: 532790 $
 */
public class MailConfiguration implements Cloneable {
    private String defaultEncoding;
    private String host;
    private Properties javaMailProperties;
    private String password;
    private String protocol;
    private Session session;
    private String username;
    private int port = -1;
    private String destination;
    private String from = ""camel@localhost"";
    private boolean deleteProcessedMessages = true;
    private String folderName = ""INBOX"";
    public MailConfiguration() {
    }
    /**
     * Returns a copy of this configuration
     */
    public MailConfiguration copy() {
        try {
            return (MailConfiguration)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public void configure(URI uri) {
        String value = uri.getHost();
        if (value != null) {
            setHost(value);
        }
        String scheme = uri.getScheme();
        if (scheme != null) {
            setProtocol(scheme);
        }
        String userInfo = uri.getUserInfo();
        if (userInfo != null) {
            setUsername(userInfo);
        }
        int port = uri.getPort();
        if (port >= 0) {
            setPort(port);
        }
        // we can either be invoked with
        // mailto:address
        // or
        // smtp:user@host:port/name@address
        String fragment = uri.getFragment();
        if (fragment == null || fragment.length() == 0) {
            fragment = userInfo + ""@"" + host;
        } else {
            setFolderName(fragment);
        }
        setDestination(fragment);
    }
    public JavaMailConnection createJavaMailConnection(MailEndpoint mailEndpoint) {
        JavaMailConnection answer = new JavaMailConnection();
        if (defaultEncoding != null) {
            answer.setDefaultEncoding(defaultEncoding);
        }
        // answer.setDefaultFileTypeMap(fileTypeMap);
        if (host != null) {
            answer.setHost(host);
        }
        if (javaMailProperties != null) {
            answer.setJavaMailProperties(javaMailProperties);
        }
        if (port >= 0) {
            answer.setPort(port);
        }
        if (password != null) {
            answer.setPassword(password);
        }
        if (protocol != null) {
            answer.setProtocol(protocol);
        }
        if (session != null) {
            answer.setSession(session);
        }
        if (username != null) {
            answer.setUsername(username);
        }
        return answer;
    }
    // Properties
    // -------------------------------------------------------------------------
    public String getDefaultEncoding() {
        return defaultEncoding;
    }
    public void setDefaultEncoding(String defaultEncoding) {
        this.defaultEncoding = defaultEncoding;
    }
    public String getHost() {
        return host;
    }
    public void setHost(String host) {
        this.host = host;
    }
    public Properties getJavaMailProperties() {
        return javaMailProperties;
    }
    public void setJavaMailProperties(Properties javaMailProperties) {
        this.javaMailProperties = javaMailProperties;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        this.port = port;
    }
    public String getProtocol() {
        return protocol;
    }
    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }
    public Session getSession() {
        return session;
    }
    public void setSession(Session session) {
        this.session = session;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public String getDestination() {
        return destination;
    }
    public void setDestination(String destination) {
        this.destination = destination;
    }
    public String getFrom() {
        return from;
    }
    public void setFrom(String from) {
        this.from = from;
    }
    public boolean isDeleteProcessedMessages() {
        return deleteProcessedMessages;
    }
    public void setDeleteProcessedMessages(boolean deleteProcessedMessages) {
        this.deleteProcessedMessages = deleteProcessedMessages;
    }
    public String getFolderName() {
        return folderName;
    }
    public void setFolderName(String folderName) {
        this.folderName = folderName;
    }
}
"
org.apache.camel.component.cxf.CamelInvoker,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.cxf.invoker.InvokingContext;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.frontend.MethodDispatcher;
import org.apache.cxf.helpers.CastUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageContentsList;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.invoker.AbstractInvoker;
import org.apache.cxf.service.invoker.Invoker;
import org.apache.cxf.service.model.BindingOperationInfo;
public class CamelInvoker implements Invoker  {
    private static final Logger LOG = Logger.getLogger(CamelInvoker.class.getName());
    private CxfConsumer cxfConsumer;
    public CamelInvoker(CxfConsumer consumer) {
        cxfConsumer = consumer;
    }
    /**
    * This method is called when the incoming message is to
    * be passed into the camel processor. The return value is the response
    * from the processor
    * @param inMessage
    * @return outMessage
    */
    public Message invoke(Message inMessage) {
        System.out.println(""invoke the message "" + inMessage);
        Exchange exchange = inMessage.getExchange();
        //InvokingContext invokingContext = exchange.get(InvokingContext.class);
        //Set Request Context into CXF Message
        Map<String, Object> ctxContainer = new HashMap<String, Object>();
        Map<String, Object> requestCtx = new HashMap<String, Object>();
        ctxContainer.put(Client.REQUEST_CONTEXT, requestCtx);
        updateContext(inMessage, requestCtx);
        CxfEndpoint endpoint = (CxfEndpoint) cxfConsumer.getEndpoint();
        CxfExchange cxfExchange = endpoint.createExchange(inMessage);
        try {
            cxfConsumer.getProcessor().process(cxfExchange);
        } catch (Exception e) {
            // catch the exception and send back to cxf client
            e.printStackTrace();
        }
        // make sure the client has retrun back the message
        Message outMessage = getCxfMessage(cxfExchange, exchange);
        //Set Response Context into CXF Message
        /*ctxContainer = (Map<String, Object>)outMessage.getProperty(CxfMessageAdapter.REQ_RESP_CONTEXT);
        Map<String, Object> respCtx = (Map<String, Object>)ctxContainer.get(Client.RESPONSE_CONTEXT);
        updateContext(respCtx, outMessage);*/
        return outMessage;
    }
    public Message getCxfMessage(CxfExchange result, Exchange exchange) {        
        Message outMessage = null;
        if (result.isFailed()) {
            CxfMessage fault = result.getFault();
            outMessage = exchange.getInFaultMessage();
            //REVISIT ?
            if (outMessage == null) {
                outMessage = new MessageImpl();
                //outMessage.setExchange(exchange);
                exchange.setInFaultMessage(outMessage);
            }
            Exception ex = (Exception) fault.getBody();
            outMessage.setContent(Exception.class, ex);
        } else {
            if (LOG.isLoggable(Level.FINEST)) {
                LOG.finest(""Payload is a response."");
            }
            // get the payload message
            outMessage = result.getOutMessage();
            if (outMessage == null) {
                Endpoint ep = exchange.get(Endpoint.class);                    
                outMessage = ep.getBinding().createMessage();
                exchange.setOutMessage(outMessage);
            }
        }
        return outMessage;
    }
    @SuppressWarnings(""unchecked"")
    public void updateContext(Map<String, Object> from, Map<String, Object> to) {
        if (to != null && from != null) {
            for (Iterator iter = from.entrySet().iterator(); iter.hasNext();) {
                Map.Entry entry = (Map.Entry) iter.next();
                String key = (String)entry.getKey();
                //Requires deep copy.
                if (!(Message.INBOUND_MESSAGE.equals(key)
                      || Message.REQUESTOR_ROLE.equals(key)
                      || Message.PROTOCOL_HEADERS.equals(key))) {
                    to.put(key, entry.getValue());
                }
            }
        }
    }
    /**
     * This method is called when the incoming pojo invocation is called
     * from the service invocation interceptor. The return value is the response
     * from the processor
     * @param inMessage
     * @return outMessage
     */
    public Object invoke(Exchange exchange, Object o) {
        BindingOperationInfo bop = exchange.get(BindingOperationInfo.class);
        MethodDispatcher md = (MethodDispatcher) 
            exchange.get(Service.class).get(MethodDispatcher.class.getName());
        Method m = md.getMethod(bop);
        List<Object> params = null;
        if (o instanceof List) {
            params = CastUtils.cast((List<?>)o);
        } else if (o != null) {
            params = new MessageContentsList(o);
        }
        CxfEndpoint endpoint = (CxfEndpoint) cxfConsumer.getEndpoint();
        CxfExchange cxfExchange = endpoint.createExchange(exchange.getInMessage());
        cxfExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, m.getName());
        cxfExchange.getIn().setBody(params);
        try {
            cxfConsumer.getProcessor().process(cxfExchange);
        } catch (Exception e) {
            // catch the exception and send back to cxf client
            e.printStackTrace();
        }
        //System.out.println(cxfExchange.getOut().getBody());
        //TODO deal with the fault message
        Object[] result;
        if (cxfExchange.isFailed()) {
            Exception ex= (Exception)cxfExchange.getFault().getBody();
            throw new Fault(ex);
        } else {
            result = (Object[])cxfExchange.getOut().getBody();
        }
        return result;
    }
}
"
org.apache.camel.bam.rules.ActivityRules,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import java.util.ArrayList;
import java.util.List;
import org.apache.camel.Exchange;
import org.apache.camel.bam.ProcessBuilder;
import org.apache.camel.bam.model.ActivityDefinition;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.util.ServiceHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * Represents a activity which is typically a system or could be an endpoint
 *
 * @version $Revision: $
 */
public class ActivityRules extends ServiceSupport {
    private static final transient Log LOG = LogFactory.getLog(ActivityRules.class);
    private int expectedMessages = 1;
    private ProcessRules processRules;
    private List<TemporalRule> rules = new ArrayList<TemporalRule>();
    private ActivityDefinition activityDefinition;
    private String activityName;
    private final org.apache.camel.bam.ProcessBuilder builder;
    public ActivityRules(ProcessBuilder builder) {
        this.builder = builder;
        this.processRules = builder.getProcessRules();
        processRules.getActivities().add(this);
    }
    public void addRule(TemporalRule rule) {
        rules.add(rule);
    }
    /**
     * Handles overdue activities
     */
    public void processExpired(ActivityState activityState) throws Exception {
        for (TemporalRule rule : rules) {
            rule.processExpired(activityState);
        }
    }
    public void processExchange(Exchange exchange, ProcessInstance process) {
        for (TemporalRule rule : rules) {
            rule.processExchange(exchange, process);
        }
    }
    // Properties
    //-------------------------------------------------------------------------
    public ActivityDefinition getActivityDefinition() {
        // lets always query for it, to avoid issues with refreshing before a commit etc
        return builder.findOrCreateActivityDefinition(activityName);
    }
    public void setActivityDefinition(ActivityDefinition activityDefinition) {
        this.activityDefinition = activityDefinition;
    }
    public int getExpectedMessages() {
        return expectedMessages;
    }
    public void setExpectedMessages(int expectedMessages) {
        this.expectedMessages = expectedMessages;
    }
    public ProcessRules getProcessRules() {
        return processRules;
    }
    public void setActivityName(String activityName) {
        this.activityName = activityName;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected void doStart() throws Exception {
        ServiceHelper.startServices(rules);
    }
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(rules);
    }
}
"
org.apache.camel.component.cxf.transport.CamelTransportFactory,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.transport;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import javax.annotation.Resource;
import org.apache.camel.CamelContext;
import org.apache.cxf.Bus;
import org.apache.cxf.configuration.Configurer;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.transport.AbstractTransportFactory;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.transport.ConduitInitiator;
import org.apache.cxf.transport.Destination;
import org.apache.cxf.transport.DestinationFactory;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
/**
 * @version $Revision$
 */
public class CamelTransportFactory extends AbstractTransportFactory implements ConduitInitiator, DestinationFactory {
    private static final Set<String> URI_PREFIXES = new HashSet<String>();
    static {
        URI_PREFIXES.add(""camel://"");
    }
    private Bus bus;
    private CamelContext camelContext;
    @Resource
    public void setBus(Bus b) {
        bus = b;
    }
    public Bus getBus() {
        return bus;
    }
    public CamelContext getCamelContext() {
        return camelContext;
    }
    @Resource
    public void setCamelContext(CamelContext camelContext) {
        this.camelContext = camelContext;
    }
    public Conduit getConduit(EndpointInfo targetInfo) throws IOException {
        return getConduit(targetInfo, null);
    }
    public Conduit getConduit(EndpointInfo endpointInfo, EndpointReferenceType target) throws IOException {
        return new CamelConduit(camelContext, bus, endpointInfo, target);
    }
    public Destination getDestination(EndpointInfo endpointInfo) throws IOException {
        CamelDestination destination = new CamelDestination(camelContext, bus, this, endpointInfo);
        Configurer configurer = bus.getExtension(Configurer.class);
        if (null != configurer) {
            configurer.configureBean(destination);
        }
        return destination;
    }
    public Set<String> getUriPrefixes() {
        return URI_PREFIXES;
    }
}
"
org.apache.camel.builder.script.ScriptLanguageResolver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.CamelContext;
import org.apache.camel.spi.Language;
import org.apache.camel.spi.LanguageResolver;
/**
 * @version $Revision: $
 */
public class ScriptLanguageResolver implements LanguageResolver {
    public Language resolveLanguage(String name, CamelContext context) {
        return new ScriptLanguage(name);
    }
}
"
org.apache.camel.component.cxf.util.CxfEndpointUtils,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.util;
import java.net.URI;
import java.net.URL;
import java.util.logging.Logger;
import javax.jws.WebService;
import javax.xml.namespace.QName;
import org.apache.camel.CamelException;
import org.apache.camel.component.cxf.CxfEndpoint;
import org.apache.camel.component.cxf.CxfMessage;
import org.apache.camel.component.cxf.DataFormat;
import org.apache.cxf.Bus;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
import org.apache.cxf.common.i18n.Message;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.frontend.ClientFactoryBean;
import org.apache.cxf.frontend.ServerFactoryBean;
import org.apache.cxf.jaxws.JaxWsClientFactoryBean;
import org.apache.cxf.jaxws.JaxWsServerFactoryBean;
import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;
import org.apache.cxf.service.Service;
import org.apache.cxf.service.factory.AbstractServiceFactoryBean;
import org.apache.cxf.service.factory.ReflectionServiceFactoryBean;
import org.apache.cxf.service.model.EndpointInfo;
import org.apache.cxf.wsdl11.WSDLServiceFactory;
public final class CxfEndpointUtils {    
    public static final String PROP_NAME_PORT = ""port"";
    public static final String PROP_NAME_SERVICE = ""service"";
    public static final String PROP_NAME_SERVICECLASS = ""serviceClass"";
    public static final String PROP_NAME_DATAFORMAT = ""dataFormat"";
    public static final String DATAFORMAT_POJO = ""pojo"";
    public static final String DATAFORMAT_MESSAGE = ""message"";
    public static final String DATAFORMAT_PAYLOAD = ""payload"";
    private static final Logger LOG = LogUtils.getL7dLogger(CxfEndpointUtils.class);
    private CxfEndpointUtils() {
        // not constructed
    }
    static QName getQName(final String name) {      
        QName qName = null;
        if (name != null) {
            try {
                qName =  QName.valueOf(name);
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        } 
        return qName;
    }
    public static QName getPortName(final CxfEndpoint endpoint) {
        return getQName(endpoint.getPortName());
    }
    public static QName getServiceName(final CxfEndpoint endpoint) {
        return getQName(endpoint.getServiceName());
    }
    public static EndpointInfo getEndpointInfo(final Service service, final CxfEndpoint endpoint) {
        EndpointInfo endpointInfo = null;
        final java.util.Collection<EndpointInfo> endpoints = service.getServiceInfos().get(0).getEndpoints();
        if (endpoints.size() == 1) {
            endpointInfo = endpoints.iterator().next();
        } else {
            final String port = endpoint.getPortName();
            if (port != null) {
                final QName endpointName = QName.valueOf(port);
                endpointInfo = service.getServiceInfos().get(0).getEndpoint(endpointName);
            }
            //TBD may be delegate to the EndpointUri params.  
        }
        return endpointInfo;
    }
    public static boolean hasWebServiceAnnotation(Class<?> cls) {
        if (cls == null) {
            return false;
        }
        if (null != cls.getAnnotation(WebService.class)) {
            return true;
        }
        for (Class<?> inf : cls.getInterfaces()) {
            if (null != inf.getAnnotation(WebService.class)) {
                return true;
            }
        }
        return hasWebServiceAnnotation(cls.getSuperclass());
    }
    public static ServerFactoryBean getServerFactoryBean(Class<?> cls) throws CamelException {
        try {            
            boolean isJSR181SEnabled = CxfEndpointUtils.hasWebServiceAnnotation(cls);
            ServerFactoryBean serverFactory = isJSR181SEnabled ? new JaxWsServerFactoryBean() 
                        : new ServerFactoryBean();            
            return serverFactory;
        } catch (Exception e) {
            throw new CamelException(e);
        }
    }
    public static ClientFactoryBean getClientFactoryBean(Class<?> cls) throws CamelException {
        try {            
            boolean isJSR181SEnabled = CxfEndpointUtils.hasWebServiceAnnotation(cls);
            ClientFactoryBean clientFactory = isJSR181SEnabled ? new JaxWsClientFactoryBean() 
                        : new ClientFactoryBean();            
            return clientFactory;
        } catch (Exception e) {
            throw new CamelException(e);
        }
    }
    //TODO check the CxfEndpoint information integration
    public static void checkEndpiontIntegration(CxfEndpoint endpoint, Bus bus) throws CamelException {
        String wsdlLocation = endpoint.getWsdlURL();
        QName serviceQName = CxfEndpointUtils.getQName(endpoint.getServiceName());
        String serviceClassName = endpoint.getServiceClass();
        DataFormat dataFormat = CxfEndpointUtils.getDataFormat(endpoint);
        URL wsdlUrl = null;
        if (wsdlLocation != null) {
            try {
                wsdlUrl = UriUtils.getWsdlUrl(new URI(wsdlLocation));
            } catch (Exception e) {
                throw new CamelException(e);
            }
        }
        if (serviceQName == null) {
            throw new CamelException(new Message(""SVC_QNAME_NOT_FOUND_X"", LOG, endpoint.getServiceName()).toString());
        }
        if (serviceClassName == null && dataFormat == DataFormat.POJO) {
            throw new CamelException(new Message(""SVC_CLASS_PROP_IS_REQUIRED_X"", LOG).toString());
        }
        AbstractServiceFactoryBean serviceFactory = null;
        try {
            if (serviceClassName != null) {
                Class<?> cls = ClassLoaderUtils.loadClass(serviceClassName, CxfEndpointUtils.class);
                boolean isJSR181SEnabled = CxfEndpointUtils.hasWebServiceAnnotation(cls);
                serviceFactory = isJSR181SEnabled
                    ? new JaxWsServiceFactoryBean() : new ReflectionServiceFactoryBean();
                serviceFactory.setBus(bus);
                if (wsdlUrl != null) {
                    ((ReflectionServiceFactoryBean)serviceFactory).setWsdlURL(wsdlUrl);
                }
                if (serviceQName != null) {
                    ((ReflectionServiceFactoryBean)serviceFactory).setServiceName(serviceQName);
                }    
                ((ReflectionServiceFactoryBean)serviceFactory).setServiceClass(cls);
            } else {
                if (wsdlUrl == null) {
                    throw new CamelException(new Message(""SVC_WSDL_URL_IS_NULL_X"", LOG, wsdlLocation).toString());
                }
                serviceFactory = new WSDLServiceFactory(bus, wsdlUrl, serviceQName);
            }
        } catch (ClassNotFoundException cnfe) {
            throw new CamelException(new Message(""CLASS_X_NOT_FOUND "", LOG, serviceClassName).toString(), cnfe);
        } catch (Exception e) {
            throw new CamelException(e);
        }       
    }
    public static DataFormat getDataFormat(CxfEndpoint endpoint) throws CamelException {
        String dataFormatString = endpoint.getDataFormat();
        DataFormat retval = DataFormat.POJO; 
        if (dataFormatString != null) {
            try {
                retval = DataFormat.valueOf(dataFormatString.toUpperCase());
            } catch (IllegalArgumentException iae) {
                throw new CamelException(new Message(""INVALID_MESSAGE_FORMAT_XXXX"", LOG, dataFormatString).toString()
                                         , iae);
            }
        }
        return retval;
    }
}
"
org.apache.camel.component.event.EventConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.event;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * @version $Revision: 1.1 $
 */
public class EventConsumer extends DefaultConsumer<Exchange> {
    private EventEndpoint endpoint;
    public EventConsumer(EventEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        endpoint.consumerStarted(this);
    }
    @Override
    protected void doStop() throws Exception {
        endpoint.consumerStopped(this);
        super.doStop();
    }
}
"
org.apache.camel.spring.spi.BeanInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.springframework.beans.factory.wiring.BeanConfigurerSupport;
import org.springframework.context.ApplicationContext;
/**
 * @version $Revision: 1.1 $
 */
public class BeanInjector extends BeanConfigurerSupport {
    public BeanInjector(ApplicationContext applicationContext) throws Exception {
        setBeanFactory(applicationContext);
        afterPropertiesSet();
    }
    public void inject(Object bean) {
        configureBean(bean);
    }
}
"
org.apache.camel.component.validator.jing.JingComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.validator.jing;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.component.ResourceBasedComponent;
import org.apache.camel.impl.ProcessorEndpoint;
import org.springframework.core.io.Resource;
import java.util.Map;
/**
 * A component for validating XML payloads using the
 * <a href=""http://www.thaiopensource.com/relaxng/jing.html"">Jing library</a>
 *
 * @version $Revision: 1.1 $
 */
public class JingComponent extends ResourceBasedComponent {
    protected Endpoint<Exchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        JingValidator validator = new JingValidator();
        Resource resource = resolveMandatoryResource(remaining);
        validator.setSchemaResource(resource);
        if (LOG.isDebugEnabled()) {
            LOG.debug(this + "" using schema resource: "" + resource);
        }
        configureValidator(validator, uri, remaining, parameters);
        return new ProcessorEndpoint(uri, this, validator);
    }
    protected void configureValidator(JingValidator validator, String uri, String remaining, Map parameters) throws Exception {
        setProperties(validator, parameters);
    }
}
"
org.apache.camel.bam.rules.TemporalRule,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.rules;
import java.util.ArrayList;
import java.util.Date;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Route;
import org.apache.camel.bam.TimeExpression;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.RouteContext;
import org.apache.camel.impl.ServiceSupport;
import org.apache.camel.model.OutputType;
import org.apache.camel.model.RouteType;
import org.apache.camel.util.Time;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import static org.apache.camel.util.ServiceHelper.startServices;
import static org.apache.camel.util.ServiceHelper.stopServices;
/**
 * A temporal rule for use within BAM
 *
 * @version $Revision: $
 */
public class TemporalRule extends ServiceSupport {
    private static final transient Log LOG = LogFactory.getLog(TemporalRule.class);
    private TimeExpression first;
    private TimeExpression second;
    private long expectedMillis;
    private long overdueMillis;
    private Processor overdueAction;
    private OutputType overdueProcessors = new OutputType();
    public TemporalRule(TimeExpression first, TimeExpression second) {
        this.first = first;
        this.second = second;
    }
    public TemporalRule expectWithin(Time builder) {
        return expectWithin(builder.toMillis());
    }
    public TemporalRule expectWithin(long millis) {
        expectedMillis = millis;
        return this;
    }
    public OutputType errorIfOver(Time builder) {
        return errorIfOver(builder.toMillis());
    }
    public OutputType errorIfOver(long millis) {
        overdueMillis = millis;
        if (overdueProcessors == null) {
            overdueProcessors = new OutputType();
        }
        return overdueProcessors;
    }
    public TimeExpression getFirst() {
        return first;
    }
    public TimeExpression getSecond() {
        return second;
    }
    public Processor getOverdueAction() throws Exception {
        if (overdueAction == null && overdueProcessors != null) {
            // TOOD refactor to avoid this messyness...
            ArrayList<Route> list = new ArrayList<Route>();
            RouteType route = new RouteType();
            route.setCamelContext(first.getBuilder().getProcessBuilder().getContext());
            RouteContext routeContext = new RouteContext(route, null, list);
            overdueAction = overdueProcessors.createOutputsProcessor(routeContext);
        }
        return overdueAction;
    }
    public void processExchange(Exchange exchange, ProcessInstance instance) {
        Date firstTime = first.evaluate(instance);
        if (firstTime == null) {
            // ignore as first event has not accurred yet
            return;
        }
        // TODO now we might need to set the second activity state
        // to 'grey' to indicate it now could happen?
        // lets force the lazy creation of the second state
        ActivityState secondState = second.getOrCreateActivityState(instance);
        if (expectedMillis > 0L) {
            Date expected = secondState.getTimeExpected();
            if (expected == null) {
                expected = add(firstTime, expectedMillis);
                secondState.setTimeExpected(expected);
            }
        }
        if (overdueMillis > 0L) {
            Date overdue = secondState.getTimeOverdue();
            if (overdue == null) {
                overdue = add(firstTime, overdueMillis);
                secondState.setTimeOverdue(overdue);
            }
        }
    }
    public void processExpired(ActivityState activityState) throws Exception {
        Processor processor = getOverdueAction();
        if (processor != null) {
            Date now = new Date();
/*
            TODO this doesn't work and returns null for some strange reason
            ProcessInstance instance = activityState.getProcessInstance();
            ActivityState secondState = second.getActivityState(instance);
            if (secondState == null) {
                log.error(""Could not find the second state! Process is: "" 
                + instance + "" with first state: "" + first.getActivityState(instance) 
                + "" and the state I was called with was: "" + activityState);
            }
*/
            ActivityState secondState = activityState;
            Date overdue = secondState.getTimeOverdue();
            if (now.compareTo(overdue) >= 0) {
                Exchange exchange = createExchange();
                exchange.getIn().setBody(activityState);
                processor.process(exchange);
            } else {
                LOG.warn(""Process has not actually expired; the time is: "" + now + "" but the overdue time is: "" + overdue);
            }
        }
    }
    protected Exchange createExchange() {
        return new DefaultExchange(second.getBuilder().getProcessBuilder().getContext());
    }
    /**
     * Returns the date in the future adding the given number of millis
     *
     * @param date
     * @param millis
     * @return the date in the future
     */
    protected Date add(Date date, long millis) {
        return new Date(date.getTime() + millis);
    }
    protected void doStart() throws Exception {
        startServices(getOverdueAction());
    }
    protected void doStop() throws Exception {
        stopServices(getOverdueAction());
    }
}
"
org.apache.camel.bam.model.ActivityState,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import org.apache.camel.bam.processor.ProcessContext;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.camel.util.ObjectHelper;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
import java.util.Date;
/**
 * The default state for a specific activity within a process
 * 
 * @version $Revision: $
 */
@Entity
public class ActivityState extends TemporalEntity {
    private ProcessInstance processInstance;
    private Integer receivedMessageCount = 0;
    private ActivityDefinition activityDefinition;
    private Date timeExpected;
    @Temporal(TemporalType.TIME)
    private Date timeOverdue;
    private Integer escalationLevel = 0;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    @Override
    public String toString() {
        return ""ActivityState["" + getId() + "" on "" + getProcessInstance() + "" "" + getActivityDefinition() + ""]"";
    }
    public synchronized void processExchange(ActivityRules activityRules, ProcessContext context) throws Exception {
        int messageCount = 0;
        Integer count = getReceivedMessageCount();
        if (count != null) {
            messageCount = count.intValue();
        }
        setReceivedMessageCount(++messageCount);
        if (messageCount == 1) {
            onFirstMessage(context);
        }
        int expectedMessages = activityRules.getExpectedMessages();
        if (messageCount == expectedMessages) {
            onExpectedMessage(context);
        } else if (messageCount > expectedMessages) {
            onExcessMessage(context);
        }
    }
    /**
     * Returns true if this state is for the given activity
     */
    public boolean isActivity(ActivityRules activityRules) {
        return ObjectHelper.equals(getActivityDefinition(), activityRules.getActivityDefinition());
    }
    // Properties
    // -----------------------------------------------------------------------
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST })
    public ProcessInstance getProcessInstance() {
        return processInstance;
    }
    public void setProcessInstance(ProcessInstance processInstance) {
        this.processInstance = processInstance;
        processInstance.getActivityStates().add(this);
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST })
    public ActivityDefinition getActivityDefinition() {
        return activityDefinition;
    }
    public void setActivityDefinition(ActivityDefinition activityDefinition) {
        this.activityDefinition = activityDefinition;
    }
    public Integer getEscalationLevel() {
        return escalationLevel;
    }
    public void setEscalationLevel(Integer escalationLevel) {
        this.escalationLevel = escalationLevel;
    }
    public Integer getReceivedMessageCount() {
        return receivedMessageCount;
    }
    public void setReceivedMessageCount(Integer receivedMessageCount) {
        this.receivedMessageCount = receivedMessageCount;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeExpected() {
        return timeExpected;
    }
    public void setTimeExpected(Date timeExpected) {
        this.timeExpected = timeExpected;
    }
    @Temporal(TemporalType.TIME)
    public Date getTimeOverdue() {
        return timeOverdue;
    }
    public void setTimeOverdue(Date timeOverdue) {
        this.timeOverdue = timeOverdue;
    }
    public void setTimeCompleted(Date timeCompleted) {
        super.setTimeCompleted(timeCompleted);
        if (timeCompleted != null) {
            setEscalationLevel(-1);
        }
    }
    @Transient
    public String getCorrelationKey() {
        ProcessInstance pi = getProcessInstance();
        if (pi == null) {
            return null;
        }
        return pi.getCorrelationKey();
    }
    // Implementation methods
    // -----------------------------------------------------------------------
    /**
     * Called when the first message is reached
     */
    protected void onFirstMessage(ProcessContext context) {
        if (!isStarted()) {
            setTimeStarted(currentTime());
            context.onStarted(this);
        }
    }
    /**
     * Called when the expected number of messages are is reached
     */
    protected void onExpectedMessage(ProcessContext context) {
        if (!isCompleted()) {
            setTimeCompleted(currentTime());
            context.onCompleted(this);
        }
    }
    /**
     * Called when an excess message (after the expected number of messages) are
     * received
     */
    protected void onExcessMessage(ProcessContext context) {
        // TODO
    }
    protected Date currentTime() {
        return new Date();
    }
}
"
org.apache.camel.component.cxf.interceptors.SoapMessageOutInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.util.ArrayList;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.wsdl.Definition;
import javax.xml.namespace.QName;
import org.w3c.dom.Element;
import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.binding.soap.SoapVersion;
import org.apache.cxf.binding.soap.model.SoapBindingInfo;
import org.apache.cxf.binding.soap.model.SoapHeaderInfo;
import org.apache.cxf.common.i18n.BundleUtils;
import org.apache.cxf.common.logging.LogUtils;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.service.model.BindingInfo;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.MessagePartInfo;
import org.apache.cxf.service.model.OperationInfo;
import org.apache.cxf.wsdl11.WSDLServiceBuilder;
public class SoapMessageOutInterceptor extends AbstractMessageOutInterceptor<SoapMessage> {
    private static final Logger LOG = LogUtils.getL7dLogger(SoapMessageInInterceptor.class);
    public SoapMessageOutInterceptor() {
        super(Phase.PREPARE_SEND);        
        addAfter(DOMOutInterceptor.class.getName());
    }
    protected Logger getLogger() {
        return LOG;
    }
    @SuppressWarnings(""unchecked"")
    public void handleMessage(SoapMessage message) throws Fault {
        Element header = message.get(Element.class);
        List<Element> payload = message.get(List.class);        
        Exchange exchange = message.getExchange();        
        BindingMessageInfo bmi = exchange.get(BindingMessageInfo.class);
        //Headers -represent as -Element,Body -represent as StaxStream.
        //Check if BindingOperationInfo contains header
        List<SoapHeaderInfo> bindingHdr = bmi.getExtensors(SoapHeaderInfo.class);
        if (bindingHdr != null && !bindingHdr.isEmpty()) {
            if (LOG.isLoggable(Level.INFO)) {
                LOG.info(""SoapMessageOutInterceptor BindingOperation header processing."");
            }
            List<Element> headerList = new ArrayList<Element>();
            List<Element> newPayload = new ArrayList<Element>(payload);
            //Look for headers in Payload.
            for (SoapHeaderInfo shi : bindingHdr) {
                List<Element> tmpList = new ArrayList<Element>();
                MessagePartInfo mpi = shi.getPart();
                QName hdrName = mpi.getConcreteName();
                for (Element el : payload) {
                    QName elName = new QName(el.getNamespaceURI(), el.getLocalName());
                    if (elName.equals(hdrName)) {
                        newPayload.remove(el);
                        tmpList.add(el);
                    }
                }
                if (tmpList.size() > 1) {
                    throw new Fault(new org.apache.cxf.common.i18n.Message(
                                    ""MULTIPLE_HDR_PARTS"", LOG, hdrName));
                }
                headerList.addAll(tmpList);
            }
            if (LOG.isLoggable(Level.INFO)) {
                LOG.info(""DOMOutInterceptor Copy Payload parts to SOAPHeaders"");
            }
            if (headerList.size() != 0) {
                SoapVersion version = ((SoapMessage)message).getVersion();
                header = createElement(version.getHeader(), headerList);
            }
            payload = newPayload;
        }
        //Set SOAP Header Element.
        //Child Elements Could be binding specified parts or user specified headers.
        //REVISTED the soap headers
        //message.setHeaders(Element.class, header);
        //TODO Moving Parts from Header to Payload.
        //For e.g Payload ROuting from SOAP11 <-> SOAP12 
        //So write payload and header to outbound message
        if (LOG.isLoggable(Level.INFO)) {
            LOG.info(""SoapMessageOutInterceptor binding operation style processing."");
        }
        SoapBindingInfo soapBinding = (SoapBindingInfo)exchange.get(BindingInfo.class);
        String style = soapBinding.getStyle(bmi.getBindingOperation().getOperationInfo());
        if (""rpc"".equals(style)) {
            //Add the Operation Node or Operation+""Response"" node
            //Remove the operation element.
            OperationInfo oi = bmi.getBindingOperation().getOperationInfo();
            Endpoint ep = exchange.get(Endpoint.class);
            Definition def = 
                ep.getService().getServiceInfos().get(0).getProperty(WSDLServiceBuilder.WSDL_DEFINITION, 
                                                             Definition.class);
            String prefix = def.getPrefix(oi.getName().getNamespaceURI());
            if ("""".equals(prefix)) {
                prefix = ""tns"";
            }
            QName opName = null;
            boolean isClient = isRequestor(message);
            if (isClient) {
                opName = new QName(oi.getName().getNamespaceURI(),
                                   oi.getName().getLocalPart(),
                                   prefix); 
            } else {
                opName = new QName(oi.getName().getNamespaceURI(),
                                   oi.getName().getLocalPart() + ""Response"",
                                   prefix);
            }
            Element opEl = createElement(opName, payload);
            payload = new ArrayList<Element>();
            payload.add(opEl);
        }
        message.put(List.class, payload);
    }
}
"
org.apache.camel.component.quartz.QuartzConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.quartz;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
/**
 * @version $Revision: 1.1 $
 */
public class QuartzConsumer extends DefaultConsumer<QuartzExchange> {
    public QuartzConsumer(QuartzEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
    }
    @Override
    public QuartzEndpoint getEndpoint() {
        return (QuartzEndpoint) super.getEndpoint();
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        getEndpoint().consumerStarted(this);
    }
    @Override
    protected void doStop() throws Exception {
        getEndpoint().consumerStopped(this);
        super.doStop();
    }
}
"
org.apache.camel.spring.handler.CamelNamespaceHandler,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.handler;
import java.util.HashSet;
import java.util.Set;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import org.apache.camel.builder.xml.XPathBuilder;
import org.apache.camel.spring.CamelBeanPostProcessor;
import org.apache.camel.spring.CamelContextFactoryBean;
import org.apache.camel.spring.EndpointFactoryBean;
import org.apache.camel.spring.remoting.CamelProxyFactoryBean;
import org.apache.camel.spring.remoting.CamelServiceExporter;
import org.apache.camel.util.ObjectHelper;
import static org.apache.camel.util.ObjectHelper.isNotNullAndNonEmpty;
import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.RuntimeBeanReference;
import org.springframework.beans.factory.parsing.BeanComponentDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.NamespaceHandlerSupport;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
public class CamelNamespaceHandler extends NamespaceHandlerSupport {
    public static final String JAXB_PACKAGES = ""org.apache.camel.spring:org.apache.camel.model:org.apache.camel.model.config:org.apache.camel.model.dataformat:org.apache.camel.model.language"";
    protected BeanDefinitionParser endpointParser = new BeanDefinitionParser(EndpointFactoryBean.class);
    protected BeanDefinitionParser proxyParser = new BeanDefinitionParser(CamelProxyFactoryBean.class);
    protected BeanDefinitionParser exportParser = new BeanDefinitionParser(CamelServiceExporter.class);
    protected BeanDefinitionParser beanPostProcessorParser = new BeanDefinitionParser(CamelBeanPostProcessor.class);
    protected Set<String> parserElementNames = new HashSet<String>();
    private JAXBContext jaxbContext;
    public void init() {
        registerParser(""endpoint"", endpointParser);
        registerParser(""proxy"", proxyParser);
        registerParser(""export"", exportParser);
        registerParser(""camelContext"", new CamelContextBeanDefinitionParser(CamelContextFactoryBean.class));
        registerParser(""xpath"", new BeanDefinitionParser(XPathBuilder.class) {
            @Override
            protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
                // lets create a child context
                String xpath = DomUtils.getTextValue(element);
                builder.addConstructorArg(xpath);
                super.doParse(element, parserContext, builder);
                builder.addPropertyValue(""namespacesFromDom"", element);
            }
        });
    }
    protected void createBeanPostProcessor(ParserContext parserContext, String contextId, Element childElement) {
        String beanPostProcessorId = contextId + "":beanPostProcessor"";
        childElement.setAttribute(""id"", beanPostProcessorId);
        BeanDefinition definition = beanPostProcessorParser.parse(childElement, parserContext);
        definition.getPropertyValues().addPropertyValue(""camelContext"", new RuntimeBeanReference(contextId));
    }
    protected void registerScriptParser(String elementName, String engineName) {
        registerParser(elementName, new ScriptDefinitionParser(engineName));
    }
    protected void registerParser(String name, org.springframework.beans.factory.xml.BeanDefinitionParser parser) {
        parserElementNames.add(name);
        registerBeanDefinitionParser(name, parser);
    }
    public Set<String> getParserElementNames() {
        return parserElementNames;
    }
    protected Object parseUsingJaxb(Element element, ParserContext parserContext) {
        try {
            Unmarshaller unmarshaller = getJaxbContext().createUnmarshaller();
            return unmarshaller.unmarshal(element);
        } catch (JAXBException e) {
            throw new BeanDefinitionStoreException(""Failed to parse JAXB element: "" + e, e);
        }
    }
    protected JAXBContext getJaxbContext() throws JAXBException {
        if (jaxbContext == null) {
            jaxbContext = createJaxbContext();
        }
        return jaxbContext;
    }
    protected JAXBContext createJaxbContext() throws JAXBException {
        return JAXBContext.newInstance(JAXB_PACKAGES);
    }
    protected class CamelContextBeanDefinitionParser extends BeanDefinitionParser {
        public CamelContextBeanDefinitionParser(Class type) {
            super(type);
        }
        @Override
            protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
            super.doParse(element, parserContext, builder);
            String contextId = element.getAttribute(""id"");
            // lets avoid folks having to explicitly give an ID to a camel
            // context
            if (ObjectHelper.isNullOrBlank(contextId)) {
                contextId = ""camelContext"";
                element.setAttribute(""id"", contextId);
            }
            // now lets parse the routes
            Object value = parseUsingJaxb(element, parserContext);
            if (value instanceof CamelContextFactoryBean) {
                CamelContextFactoryBean factoryBean = (CamelContextFactoryBean)value;
                builder.addPropertyValue(""id"", contextId);
                builder.addPropertyValue(""routes"", factoryBean.getRoutes());
                if (factoryBean.getPackages().length > 0) {
                    builder.addPropertyValue(""packages"", factoryBean.getPackages());
                }
            }
            boolean createdBeanPostProcessor = false;
            NodeList list = element.getChildNodes();
            int size = list.getLength();
            for (int i = 0; i < size; i++) {
                Node child = list.item(i);
                if (child instanceof Element) {
                    Element childElement = (Element)child;
                    String localName = child.getLocalName();
                    if (localName.equals(""beanPostProcessor"")) {
                        createBeanPostProcessor(parserContext, contextId, childElement);
                        createdBeanPostProcessor = true;
                    } else if (localName.equals(""endpoint"")) {
                        BeanDefinition definition = endpointParser.parse(childElement, parserContext);
                        String id = childElement.getAttribute(""id"");
                        if (ObjectHelper.isNotNullAndNonEmpty(id)) {
                            // TODO we can zap this?
                            definition.getPropertyValues().addPropertyValue(""camelContext"", new RuntimeBeanReference(contextId));
                            // definition.getPropertyValues().addPropertyValue(""context"",
                            // builder.getBeanDefinition());
                            parserContext.registerComponent(new BeanComponentDefinition(definition, id));
                        }
                    } else if (localName.equals(""proxy"")) {
                        BeanDefinition definition = proxyParser.parse(childElement, parserContext);
                        String id = childElement.getAttribute(""id"");
                        if (ObjectHelper.isNotNullAndNonEmpty(id)) {
                            parserContext.registerComponent(new BeanComponentDefinition(definition, id));
                        }
                    } else if (localName.equals(""export"")) {
                        BeanDefinition definition = exportParser.parse(childElement, parserContext);
                        String id = childElement.getAttribute(""id"");
                        if (ObjectHelper.isNotNullAndNonEmpty(id)) {
                            parserContext.registerComponent(new BeanComponentDefinition(definition, id));
                        }
                    }
                }
            }
            if (!createdBeanPostProcessor) {
                // no bean processor element so lets add a fake one
                Element childElement = element.getOwnerDocument().createElement(""beanPostProcessor"");
                element.appendChild(childElement);
                createBeanPostProcessor(parserContext, contextId, childElement);
            }
        }
    }
}
"
org.apache.camel.component.cxf.CxfProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.List;
import org.apache.camel.CamelException;
import org.apache.camel.Exchange;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.cxf.invoker.CxfClient;
import org.apache.camel.component.cxf.invoker.CxfClientFactoryBean;
import org.apache.camel.component.cxf.invoker.InvokingContext;
import org.apache.camel.component.cxf.spring.CxfEndpointBean;
import org.apache.camel.component.cxf.util.CxfEndpointUtils;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ObjectHelper;
import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.binding.Binding;
import org.apache.cxf.binding.BindingFactory;
import org.apache.cxf.binding.BindingFactoryManager;
import org.apache.cxf.common.classloader.ClassLoaderUtils;
import org.apache.cxf.endpoint.Client;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.frontend.ClientFactoryBean;
import org.apache.cxf.message.Message;
import org.apache.cxf.message.MessageImpl;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.transport.Conduit;
import java.io.InputStream;
import java.net.MalformedURLException;
/**
 * Sends messages from Camel into the CXF endpoint
 * 
 * @version $Revision$
 */
public class CxfProducer extends DefaultProducer <CxfExchange> {
    private CxfEndpoint endpoint;
    private Client client;
    private DataFormat dataFormat;
    public CxfProducer(CxfEndpoint endpoint) throws CamelException {
        super(endpoint);
        this.endpoint = endpoint;
        dataFormat = CxfEndpointUtils.getDataFormat(endpoint);
        if (dataFormat.equals(DataFormat.POJO)) {
            client = createClientFormClientFactoryBean(null);
        } else {
            // create CxfClient for message
            client = createClientForStreamMessge();           
        }
    }
    private Client createClientForStreamMessge() throws CamelException {
        CxfClientFactoryBean cfb = new CxfClientFactoryBean();
        if (null != endpoint.getServiceClass()) {
            try {
                Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());
                boolean jsr181Enabled = CxfEndpointUtils.hasWebServiceAnnotation(serviceClass);
                cfb.setJSR181Enabled(jsr181Enabled);
            } catch (ClassNotFoundException e) {
                throw new CamelException(e);
            }
        }
        return createClientFormClientFactoryBean(cfb);
    }
    //If cfb is null ,we will try to find a right cfb to use.    
    private Client createClientFormClientFactoryBean(ClientFactoryBean cfb) throws CamelException {              
        Bus bus = BusFactory.getDefaultBus();
        if (endpoint.isSpringContextEndpoint()) {
            CxfEndpointBean endpointBean = endpoint.getCxfEndpointBean();
            if (cfb == null) {
                cfb = CxfEndpointUtils.getClientFactoryBean(endpointBean.getServiceClass());
            }    
            endpoint.configure(cfb);
            // Need to set the service name and endpoint name to the ClientFactoryBean's service factory
            // to walk around the issue of setting EndpointName and ServiceName
            CxfEndpointBean cxfEndpointBean = endpoint.getCxfEndpointBean();
            if (cxfEndpointBean.getServiceName() != null) {
                cfb.getServiceFactory().setServiceName(cxfEndpointBean.getServiceName());
            } 
            if (cxfEndpointBean.getEndpointName() != null) {
                cfb.getServiceFactory().setEndpointName(cxfEndpointBean.getEndpointName());
            } 
        } else { // set up the clientFactoryBean by using URI information
            if (null != endpoint.getServiceClass()) {
                try {
                    //we need to choice the right front end to create the clientFactoryBean
                    Class serviceClass = ClassLoaderUtils.loadClass(endpoint.getServiceClass(), this.getClass());
                    if (cfb == null) {
                        cfb = CxfEndpointUtils.getClientFactoryBean(serviceClass);
                    } 
                    cfb.setAddress(endpoint.getAddress());
                    if (null != endpoint.getServiceClass()) {            
                        cfb.setServiceClass(ObjectHelper.loadClass(endpoint.getServiceClass()));
                    } 
                    if (null != endpoint.getWsdlURL()) {
                        cfb.setWsdlURL(endpoint.getWsdlURL());
                    }                
                } catch (ClassNotFoundException e) {
                    throw new CamelException(e);
                }
            } else { // we can't see any service class from the endpoint
                if (cfb == null) {
                    cfb = new ClientFactoryBean();
                }    
                if (null != endpoint.getWsdlURL()) {
                    cfb.setWsdlURL(endpoint.getWsdlURL());
                } else {
                    // throw the exception for insufficiency of the endpoint info
                    throw new CamelException(""Insufficiency of the endpoint info"");
                }
            }
            if (endpoint.getServiceName() != null) {
                cfb.getServiceFactory().setServiceName(CxfEndpointUtils.getServiceName(endpoint));
            }
            if (endpoint.getPortName() != null) {
                cfb.getServiceFactory().setEndpointName(CxfEndpointUtils.getPortName(endpoint));
            }    
            if (endpoint.getWsdlURL() != null) {                
                cfb.setWsdlURL(endpoint.getWsdlURL());
            }
        }    
        cfb.setBus(bus);        
        return cfb.create();
    }
    public void process(Exchange exchange) {
        CxfExchange cxfExchange = endpoint.createExchange(exchange);
        process(cxfExchange);
    }
    public void process(CxfExchange exchange) {
        CxfBinding cxfBinding = endpoint.getBinding();
        Message inMessage = cxfBinding.createCxfMessage(exchange);
        try {
            if (dataFormat.equals(DataFormat.POJO)) {
                //InputStream is = m.getContent(InputStream.class);
                // now we just deal with the POJO invocations 
                List paraments = inMessage.getContent(List.class);
                String operation = inMessage.getContent(String.class);
                Message response = new MessageImpl();            
                if (operation != null && paraments != null) {                
                    // now we just deal with the invoking the paraments
                    try {
                        Object[] result = client.invoke(operation, paraments.toArray());                
                        response.setContent(Object[].class, result);
                        cxfBinding.storeCxfResponse(exchange, response);
                    } catch (Exception ex) {
                        response.setContent(Exception.class, ex);
                        cxfBinding.storeCxfFault(exchange, response);                        
                    }
                }  
            } else {
                // get the invocation context
                org.apache.cxf.message.Exchange ex = exchange.getExchange();
                InvokingContext invokingContext = ex.get(InvokingContext.class);
                Object params = invokingContext.getRequestContent(inMessage);
                // invoke the stream message with the exchange context
                CxfClient cxfClient = (CxfClient) client;
                // invoke the message
                //TODO need setup the call context here
                //TODO need to handle the one way message
                Object result = cxfClient.dispatch(params, null, ex);
                // need to get the binding object to create the message
                BindingOperationInfo boi = ex.get(BindingOperationInfo.class);
                Message response = null;                
                if (boi == null) {
                    // it should be the raw message                    
                    response = new MessageImpl(); 
                } else {
                    // create the message here
                    Endpoint ep = ex.get(Endpoint.class);                    
                    response = ep.getBinding().createMessage();
                }                
                response.setExchange(ex);
                ex.setOutMessage(response);                
                invokingContext.setResponseContent(response, result);
                cxfBinding.storeCxfResponse(exchange, response);
            }
        } catch (Exception e) {
            //TODO add the falut message handling work
            throw new RuntimeCamelException(e);
        }     
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart(); 
    }
    @Override
    protected void doStop() throws Exception {
        super.doStop();        
    }
}
"
org.apache.camel.component.mail.MailExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.Message;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
/**
 * Represents an {@ilnk Exchange} for working with Mail
 *
 * @version $Revision:520964 $
 */
public class MailExchange extends DefaultExchange {
    private MailBinding binding;
    public MailExchange(CamelContext context, ExchangePattern pattern, MailBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public MailExchange(CamelContext context, ExchangePattern pattern, MailBinding binding, Message message) {
        this(context, pattern, binding);
        setIn(new MailMessage(message));
    }
    @Override
    public MailMessage getIn() {
        return (MailMessage) super.getIn();
    }
    @Override
    public MailMessage getOut() {
        return (MailMessage) super.getOut();
    }
    @Override
    public MailMessage getOut(boolean lazyCreate) {
        return (MailMessage) super.getOut(lazyCreate);
    }
    @Override
    public MailMessage getFault() {
        return (MailMessage) super.getFault();
    }
    public MailBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new MailExchange(getContext(), getPattern(), binding);
    }
    // Expose Email APIs
    //-------------------------------------------------------------------------
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected MailMessage createInMessage() {
        return new MailMessage();
    }
    @Override
    protected MailMessage createOutMessage() {
        return new MailMessage();
    }
}
"
org.apache.camel.component.cxf.invoker.PayloadInvokingContext,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.w3c.dom.Element;
import org.apache.camel.component.cxf.interceptors.DOMInInterceptor;
import org.apache.camel.component.cxf.interceptors.DOMOutInterceptor;
import org.apache.camel.component.cxf.interceptors.PayloadContentRedirectInterceptor;
import org.apache.camel.component.cxf.interceptors.PayloadInInterceptor;
import org.apache.camel.component.cxf.phase.FaultPayloadPhaseManagerImpl;
import org.apache.camel.component.cxf.phase.PayloadPhaseManagerImpl;
import org.apache.cxf.Bus;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.endpoint.EndpointImpl;
import org.apache.cxf.interceptor.Interceptor;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.Phase;
import org.apache.cxf.phase.PhaseInterceptorChain;
import org.apache.cxf.phase.PhaseManager;
import org.apache.cxf.transport.MessageObserver;
public class PayloadInvokingContext extends AbstractInvokingContext {
    private static final Logger LOG = Logger.getLogger(PayloadInvokingContext.class.getName());
    private PhaseManager phaseManager;
    private PhaseManager faultPhaseManager;
    private MessageObserver inFaultObserver;
    private MessageObserver outFaultObserver;
    public PayloadInvokingContext() {
        phaseManager = new PayloadPhaseManagerImpl();
        faultPhaseManager = new FaultPayloadPhaseManagerImpl();
    }
    public PhaseInterceptorChain getRequestOutInterceptorChain(Exchange exchange) {
        return getOutIntercepterChain(exchange);
    }
    public PhaseInterceptorChain getResponseOutInterceptorChain(Exchange exchange) {
        return getOutIntercepterChain(exchange);
    }
    private PhaseInterceptorChain getOutIntercepterChain(Exchange exchange) {
        PhaseInterceptorChain chain = new PhaseInterceptorChain(
                new PayloadPhaseManagerImpl().getOutPhases());
        Bus bus = exchange.get(Bus.class);
        assert bus != null;
        // bus
        List<Interceptor> list = bus.getOutInterceptors();
        if (LOG.isLoggable(Level.FINE)) {
            LOG.fine(""Interceptors contributed by bus: "" + list);
        }
        chain.add(list);
        // endpoint
        Endpoint endpoint = exchange.get(Endpoint.class);
        if (endpoint != null) {
            list = endpoint.getOutInterceptors();
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Interceptors contributed by endpoint: "" + list);
            }
            chain.add(list);
            list = endpoint.getBinding().getOutInterceptors();
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Interceptors contributed by binding: "" + list);
            }
            chain.add(list);
        }
        chain.add(new DOMOutInterceptor());
        chain.add(new PayloadContentRedirectInterceptor());
        return chain;
    }
    public void setRequestOutMessageContent(Message message, Object content) {
        PayloadMessage request = (PayloadMessage) content;
        Element header = request.getHeader();
        List<Element> payload = request.getPayload();
        if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""header = "" + header + "", paylaod = "" + payload);
        }
        message.put(Element.class, header);
        message.put(List.class, payload);    
    }
    @Override
    protected SortedSet<Phase> getInPhases() {
        return phaseManager.getInPhases();
    }
    protected SortedSet<Phase> getOutPhases() {
        return phaseManager.getOutPhases();
    }
    @Override
    protected List<Interceptor> getRoutingInterceptors() {
        List<Interceptor> list = new ArrayList<Interceptor>();
        list.add(new DOMInInterceptor());
        list.add(new PayloadInInterceptor());
        return list;
    }
    @SuppressWarnings(""unchecked"")
    public Object getResponseObject(Exchange exchange, Map<String, Object> responseContext) {
        PayloadMessage payloadMsg = null;
        Message msg = exchange.getInMessage();
        List<Element> payload = getResponseObject(msg , responseContext, List.class);
        Element header = exchange.getInMessage().get(Element.class);
        payloadMsg = new PayloadMessage(payload, header);            
        if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(payloadMsg.toString());
        }
        return payloadMsg;
    }
    @Override
    protected <T> T getResponseObject(Message inMessage, Map<String, Object> responseContext,
                                      Class <T> clazz) {
        T retval = null;
        if (inMessage != null) {
            if (null != responseContext) {
                responseContext.putAll(inMessage);
                LOG.info(""set responseContext to be"" + responseContext);
            }
            retval = inMessage.get(clazz);
        }
        return retval;
    }
    protected PhaseInterceptorChain getInInterceptorChain(Exchange exchange, boolean isResponse) {
        Bus bus = exchange.get(Bus.class);
        assert bus != null;
        PhaseInterceptorChain chain = new PhaseInterceptorChain(getInPhases());
        List<Interceptor> routingInterceptors = getRoutingInterceptors();
        chain.add(routingInterceptors);    
        if (LOG.isLoggable(Level.FINE)) {
            LOG.fine(""Injected "" + routingInterceptors);
        }
        // bus
        List<Interceptor> list = bus.getInInterceptors();
        if (LOG.isLoggable(Level.FINE)) {
            LOG.fine(""Interceptors contributed by bus: "" + list);
        }
        chain.add(list);
        // endpoint
        Endpoint ep = exchange.get(Endpoint.class);
        if (ep != null) {
            list = ep.getInInterceptors();
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Interceptors contributed by endpoint: "" + list);
            }
            chain.add(list);
            // binding
            list = ep.getBinding().getInInterceptors();
            if (LOG.isLoggable(Level.FINE)) {
                LOG.fine(""Interceptors contributed by binding: "" + list);
            }
            chain.add(list);
        }
        return chain;
    }
    /**
     * This method is called to set the fault observers on the endpoint that are specified
     * to the phases meaningful to the routing context.
     * @param endpointImpl
     */
    @Override
    public void setEndpointFaultObservers(EndpointImpl endpointImpl, Bus bus) {
        if (inFaultObserver == null) {
            inFaultObserver = new FaultChainInitiatorObserver(bus, faultPhaseManager.getInPhases(), false);
        }
        endpointImpl.setInFaultObserver(inFaultObserver);
        if (outFaultObserver == null) {
            outFaultObserver = new FaultChainInitiatorObserver(bus, faultPhaseManager.getOutPhases(), true);
        }
        endpointImpl.setOutFaultObserver(outFaultObserver);
    }
    public void setResponseContent(Message outMessage, Object resultPayload) {
        if (resultPayload != null) {
            PayloadMessage payloadMessage = (PayloadMessage) resultPayload;
            if (LOG.isLoggable(Level.FINEST)) {
                LOG.finest(payloadMessage.toString());
            }
            outMessage.put(List.class, payloadMessage.getPayload());
            outMessage.put(Element.class, payloadMessage.getHeader());
        }
    }
    @SuppressWarnings(""unchecked"")
    public Object getRequestContent(Message inMessage) {
        List<Element> payload = inMessage.get(List.class);
        Element header = inMessage.get(Element.class);
        if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""Header = "" + header + "", Payload = "" + payload);
        }
        return new PayloadMessage(payload, header);
    }
}
"
org.apache.camel.bam.ActivityLifecycle,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam;
/**
 * @version $Revision: 1.1 $
 */
public enum ActivityLifecycle {
    Started, Completed
}
"
org.apache.camel.bam.processor.JpaBamProcessor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Processor;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.model.ProcessInstance;
import org.apache.camel.bam.rules.ActivityRules;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * A concrete {@link Processor} for working on <a
 * href=""http://activemq.apache.org/camel/bam.html"">BAM</a> which uses JPA as
 * the persistence and uses the {@link ProcessInstance} entity to store the
 * process information.
 * 
 * @version $Revision: $
 */
public class JpaBamProcessor extends JpaBamProcessorSupport<ProcessInstance> {
    private static final transient Log LOG = LogFactory.getLog(JpaBamProcessor.class);
    public JpaBamProcessor(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, ActivityRules activityRules) {
        super(transactionTemplate, template, correlationKeyExpression, activityRules);
    }
    public JpaBamProcessor(TransactionTemplate transactionTemplate, JpaTemplate template, Expression<Exchange> correlationKeyExpression, 
                           ActivityRules activityRules, Class<ProcessInstance> entitytype) {
        super(transactionTemplate, template, correlationKeyExpression, activityRules, entitytype);
    }
    protected void processEntity(Exchange exchange, ProcessInstance process) throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Processing process instance: "" + process);
        }
        // lets force the lazy creation of this activity
        ActivityRules rules = getActivityRules();
        ActivityState state = process.getOrCreateActivityState(rules);
        state.processExchange(rules, new ProcessContext(exchange, rules, state));
        rules.getProcessRules().processExchange(exchange, process);
    }
}
"
org.apache.camel.builder.script.ScriptLanguage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.Exchange;
import org.apache.camel.Expression;
import org.apache.camel.Predicate;
import org.apache.camel.spi.Language;
/**
 * @version $Revision: $
 */
public class ScriptLanguage implements Language {
    private final String language;
    public ScriptLanguage(String language) {
        this.language = language;
    }
    public Predicate<Exchange> createPredicate(String expression) {
        return new ScriptBuilder(language, expression);
    }
    public Expression<Exchange> createExpression(String expression) {
        return new ScriptBuilder(language, expression);
    }
}
"
org.apache.camel.component.mail.MailComponent,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import org.apache.camel.CamelContext;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import java.net.URI;
import java.util.Map;
/**
 * @version $Revision:520964 $
 */
public class MailComponent extends DefaultComponent<MailExchange> {
    private MailConfiguration configuration;
    public MailComponent() {
        this.configuration = new MailConfiguration();
    }
    public MailComponent(MailConfiguration configuration) {
        this.configuration = configuration;
    }
    public MailComponent(CamelContext context) {
        super(context);
        this.configuration = new MailConfiguration();
    }
    /**
     * Static builder method
     */
    public static MailComponent mailComponent() {
        return new MailComponent();
    }
    /**
     * Static builder method
     */
    public static MailComponent mailComponent(MailConfiguration configuration) {
        return new MailComponent(configuration);
    }
    @Override
    protected Endpoint<MailExchange> createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        MailConfiguration config = getConfiguration().copy();
        config.configure(new URI(uri));
        // lets make sure we copy the configuration as each endpoint can customize its own version
        MailEndpoint endpoint = new MailEndpoint(uri, this, config);
        setProperties(endpoint.getConfiguration(), parameters);
        return endpoint;
    }
    public MailConfiguration getConfiguration() {
        return configuration;
    }
    /**
     * Sets the Mail configuration
     *
     * @param configuration the configuration to use by default for endpoints
     */
    public void setConfiguration(MailConfiguration configuration) {
        this.configuration = configuration;
    }
    /**
     * A strategy method allowing the URI destination to be translated into the actual Mail destination name
     * (say by looking up in JNDI or something)
     */
    protected String convertPathToActualDestination(String path) {
        return path;
    }
}
"
org.apache.camel.component.cxf.CxfMessageObserver,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.camel.component.cxf.invoker.InvokingContext;
import org.apache.camel.component.cxf.invoker.InvokingContextFactory;
import org.apache.cxf.Bus;
import org.apache.cxf.endpoint.Endpoint;
import org.apache.cxf.endpoint.EndpointImpl;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.ExchangeImpl;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.PhaseInterceptorChain;
import org.apache.cxf.transport.ChainInitiationObserver;
public class CxfMessageObserver extends ChainInitiationObserver {
    private static final Logger LOG = Logger.getLogger(ChainInitiationObserver.class.getName());
    private CxfConsumer cxfConsumer;
    private DataFormat dataFormat;
    private CamelInvoker invoker;
    public CxfMessageObserver(CxfConsumer consumer, Endpoint endpoint, Bus bus,
            DataFormat dataFormat) {
        super(endpoint, bus);
        cxfConsumer = consumer;
        this.dataFormat = dataFormat;
        invoker = new CamelInvoker(consumer);
    }
    protected void setExchangeProperties(Exchange exchange, Message m) {
        super.setExchangeProperties(exchange, m);        
        exchange.put(CxfConsumer.class, cxfConsumer);
        exchange.put(Bus.class, bus);
        exchange.put(Endpoint.class, endpoint);
        exchange.put(InvokingContext.class, InvokingContextFactory.createContext(dataFormat));
        exchange.put(CamelInvoker.class, invoker);
    }
    public void onMessage(Message m) {
        if (LOG.isLoggable(Level.FINER)) {
            LOG.fine(""Observed Client request at router's endpoint.  Request message: "" + m);
        }
        Message message = endpoint.getBinding().createMessage(m);
        message.put(Message.INBOUND_MESSAGE, Boolean.TRUE);
        Exchange exchange = message.getExchange();
        if (exchange == null) {
            exchange = new ExchangeImpl();
            exchange.setInMessage(message);
        }
        setExchangeProperties(exchange, message);
        InvokingContext invokingContext = exchange.get(InvokingContext.class);
        assert invokingContext != null;
        invokingContext.setEndpointFaultObservers((EndpointImpl)endpoint, bus);
        if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""Build inbound interceptor chain and inject routing interceptor"");
        }
        // now we just support the raw message and the payload message
        PhaseInterceptorChain chain = invokingContext.getRequestInInterceptorChain(exchange);
        message.setInterceptorChain(chain);
        chain.setFaultObserver(endpoint.getOutFaultObserver());
        chain.doIntercept(message);        
    }
}
"
org.apache.camel.component.file.remote.SftpConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.concurrent.ScheduledExecutorService;
import com.jcraft.jsch.ChannelSftp;
import org.apache.camel.Processor;
import org.apache.camel.component.file.FileComponent;
public class SftpConsumer extends RemoteFileConsumer<RemoteFileExchange> {
    private boolean recursive = true;
    private String regexPattern = """";
    private long lastPollTime;
    private final SftpEndpoint endpoint;
    private ChannelSftp channel;
    private boolean setNames = false;
    public SftpConsumer(SftpEndpoint endpoint, Processor processor, ChannelSftp channel) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.channel = channel;
    }
    public SftpConsumer(SftpEndpoint endpoint, Processor processor, ChannelSftp channel, ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
        this.endpoint = endpoint;
        this.channel = channel;
    }
    protected void poll() throws Exception {
        final String fileName = endpoint.getConfiguration().getFile();
        if (endpoint.getConfiguration().isDirectory()) {
            pollDirectory(fileName);
        } else {
            channel.cd(fileName.substring(0, fileName.lastIndexOf('/')));
            final ChannelSftp.LsEntry file = (ChannelSftp.LsEntry)channel.ls(fileName.substring(fileName.lastIndexOf('/') + 1)).get(0);
            pollFile(file);
        }
        lastPollTime = System.currentTimeMillis();
    }
    protected void pollDirectory(String dir) throws Exception {
        channel.cd(dir);
        for (ChannelSftp.LsEntry sftpFile : (ChannelSftp.LsEntry[])channel.ls(""."").toArray(new ChannelSftp.LsEntry[] {})) {
            if (sftpFile.getFilename().startsWith(""."")) {
                // skip
            } else if (sftpFile.getAttrs().isDir()) {
                if (isRecursive()) {
                    pollDirectory(getFullFileName(sftpFile));
                }
            } else {
                pollFile(sftpFile);
            }
        }
    }
    protected String getFullFileName(ChannelSftp.LsEntry sftpFile) throws IOException {
        return channel.pwd() + ""/"" + sftpFile.getFilename();
    }
    private void pollFile(ChannelSftp.LsEntry sftpFile) throws Exception {
        if (sftpFile.getAttrs().getMTime() * 1000 > lastPollTime) { // TODO do
                                                                    // we need
                                                                    // to adjust
                                                                    // the TZ?
            if (isMatched(sftpFile)) {
                final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
                channel.get(sftpFile.getFilename(), byteArrayOutputStream);
                RemoteFileExchange exchange = endpoint.createExchange(getFullFileName(sftpFile), byteArrayOutputStream);
                if (isSetNames()) {
                    String relativePath = getFullFileName(sftpFile).substring(endpoint.getConfiguration().getFile().length());
                    if (relativePath.startsWith(""/"")) {
                        relativePath = relativePath.substring(1);
                    }
                    exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);
                }
                getProcessor().process(exchange);
            }
        }
    }
    protected boolean isMatched(ChannelSftp.LsEntry sftpFile) {
        boolean result = true;
        if (regexPattern != null && regexPattern.length() > 0) {
            result = sftpFile.getFilename().matches(getRegexPattern());
        }
        return result;
    }
    public boolean isRecursive() {
        return recursive;
    }
    public void setRecursive(boolean recursive) {
        this.recursive = recursive;
    }
    public long getLastPollTime() {
        return lastPollTime;
    }
    public void setLastPollTime(long lastPollTime) {
        this.lastPollTime = lastPollTime;
    }
    public String getRegexPattern() {
        return regexPattern;
    }
    public void setRegexPattern(String regexPattern) {
        this.regexPattern = regexPattern;
    }
    public boolean isSetNames() {
        return setNames;
    }
    public void setSetNames(boolean setNames) {
        this.setNames = setNames;
    }
}
"
org.apache.camel.component.jms.MessageJMSPropertyAccessException,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import javax.jms.JMSException;
/**
 * @version $Revision: 1.1 $
 */
public class MessageJMSPropertyAccessException extends RuntimeJmsException {
    private static final long serialVersionUID = -6744171518099741324L;
    public MessageJMSPropertyAccessException(JMSException e) {
        super(""Failed to access a JMS property: "" + e, e);
    }
}
"
org.apache.camel.component.file.remote.RemoteFileBinding,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.OutputStream;
public class RemoteFileBinding {
    public Object extractBodyFromOutputStream(RemoteFileExchange exchange, OutputStream outputStream) {
        return outputStream;
    }
}
"
org.apache.camel.component.file.remote.FtpOperationFailedException,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import org.apache.camel.RuntimeCamelException;
/**
 * @version $Revision: 1.1 $
 */
public class FtpOperationFailedException extends RuntimeCamelException {
    private final int code;
    private final String reason;
    public FtpOperationFailedException(int code, String reason) {
        super(""Ftp Operation failed: "" + reason.trim() + "" Code: "" + code);
        this.code = code;
        this.reason = reason;
    }
    /**
     * Return the failure code
     */
    public int getCode() {
        return code;
    }
    /**
     * Return the failure reason
     */
    public String getReason() {
        return reason;
    }
}
"
org.apache.camel.component.ibatis.IBatisComponent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.ibatis;
import java.io.IOException;
import java.io.InputStream;
import java.util.Map;
import com.ibatis.sqlmap.client.SqlMapClient;
import com.ibatis.sqlmap.client.SqlMapClientBuilder;
import org.apache.camel.Endpoint;
import org.apache.camel.impl.DefaultComponent;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
/**
 * An <a href=""http://activemq.apache.org/camel/ibatis.html>iBatis Component</a>
 * for performing SQL operations using an XML mapping file to abstract away the SQL
 *
 * @version $Revision: 1.1 $
 */
public class IBatisComponent extends DefaultComponent {
    private static final transient Log LOG = LogFactory.getLog(IBatisComponent.class);
    public static final String DEFAULT_CONFIG_URI = ""SqlMapConfig.xml"";
    private SqlMapClient sqlMapClient;
    private Resource sqlMapResource;
    public IBatisComponent() {
    }
    public IBatisComponent(SqlMapClient sqlMapClient) {
        this.sqlMapClient = sqlMapClient;
    }
    // Properties
    //-------------------------------------------------------------------------
    public SqlMapClient getSqlMapClient() throws IOException {
        if (sqlMapClient == null) {
            sqlMapClient = createSqlMapClient();
        }
        return sqlMapClient;
    }
    public void setSqlMapClient(SqlMapClient sqlMapClient) {
        this.sqlMapClient = sqlMapClient;
    }
    public Resource getSqlMapResource() {
        if (sqlMapResource == null) {
            sqlMapResource = new ClassPathResource(DEFAULT_CONFIG_URI);
            LOG.debug(""Defaulting to use the iBatis configuration from: "" + sqlMapResource);
        }
        return sqlMapResource;
    }
    public void setSqlMapResource(Resource sqlMapResource) {
        this.sqlMapResource = sqlMapResource;
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        return new IBatisEndpoint(uri, this, remaining);
    }
    protected SqlMapClient createSqlMapClient() throws IOException {
        InputStream in = getSqlMapResource().getInputStream();
        return SqlMapClientBuilder.buildSqlMapClient(in);
    }
}
"
org.apache.camel.component.jms.JmsExchange,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultExchange;
import javax.jms.Message;
/**
 * Represents an {@ilnk Exchange} for working with JMS messages while exposing the inbound and outbound JMS {@link Message}
 * objects via {@link #getInMessage()} and {@link #getOutMessage()}
 *
 * @version $Revision:520964 $
 */
public class JmsExchange extends DefaultExchange {
    private JmsBinding binding;
    public JmsExchange(CamelContext context, ExchangePattern pattern, JmsBinding binding) {
        super(context, pattern);
        this.binding = binding;
    }
    public JmsExchange(CamelContext context, ExchangePattern pattern, JmsBinding binding, Message message) {
        this(context, pattern, binding);
        setIn(new JmsMessage(message));
    }
    @Override
    public JmsMessage getIn() {
        return (JmsMessage) super.getIn();
    }
    @Override
    public JmsMessage getOut() {
        return (JmsMessage) super.getOut();
    }
    @Override
    public JmsMessage getOut(boolean lazyCreate) {
        return (JmsMessage) super.getOut(lazyCreate);
    }
    @Override
    public JmsMessage getFault() {
        return (JmsMessage) super.getFault();
    }
    public JmsBinding getBinding() {
        return binding;
    }
    @Override
    public Exchange newInstance() {
        return new JmsExchange(getContext(), getPattern(), binding);
    }
    // Expose JMS APIs
    //-------------------------------------------------------------------------
    /**
     * Return the underlying JMS In message
     *
     * @return the JMS In message
     */
    public Message getInMessage() {
        return getIn().getJmsMessage();
    }
    /**
     * Return the underlying JMS Out message
     *
     * @return the JMS out message
     */
    public Message getOutMessage() {
        return getOut().getJmsMessage();
    }
    /**
     * Return the underlying JMS Fault message
     *
     * @return the JMS fault message
     */
    public Message getFaultMessage() {
        return getOut().getJmsMessage();
    }
    // Implementation methods
    //-------------------------------------------------------------------------
    @Override
    protected JmsMessage createInMessage() {
        return new JmsMessage();
    }
    @Override
    protected JmsMessage createOutMessage() {
        return new JmsMessage();
    }
    @Override
    protected org.apache.camel.Message createFaultMessage() {
        return new JmsMessage();
    }
}
"
org.apache.camel.converter.jaxb.IntegerHeader,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
/**
 * @version $Revision: 1.1 $
 */
@XmlRootElement(name = ""intHeader"")
@XmlAccessorType(value = XmlAccessType.FIELD)
public class IntegerHeader extends HeaderType {
    @XmlAttribute(name = ""value"")
    private Integer number;
    public IntegerHeader() {
    }
    public IntegerHeader(String name, Integer number) {
        super(name);
        this.number = number;
    }
    public Integer getNumber() {
        return number;
    }
    public void setNumber(Integer number) {
        this.number = number;
    }
    public Object getValue() {
        return getNumber();
    }
    public void setValue(Object value) {
        if (value instanceof Number) {
            Number n = (Number) value;
            setNumber(n.intValue());
        }
        else {
            throw new IllegalArgumentException(""Value must be an Integer"");
        }
    }
}"
org.apache.camel.component.file.remote.RemoteFileConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.util.concurrent.ScheduledExecutorService;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
public abstract class RemoteFileConsumer<T extends RemoteFileExchange> extends ScheduledPollConsumer<T> {
    RemoteFileEndpoint<T> endpoint;
    public RemoteFileConsumer(RemoteFileEndpoint<T> endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
    }
    public RemoteFileConsumer(RemoteFileEndpoint<T> endpoint, Processor processor, ScheduledExecutorService executor) {
        super(endpoint, processor, executor);
    }
}
"
org.apache.camel.component.file.remote.RemoteFileConfiguration,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.net.URI;
import org.apache.camel.RuntimeCamelException;
public class RemoteFileConfiguration implements Cloneable {
    private String protocol;
    private String username;
    private String host;
    private int port;
    private String password;
    private String file;
    private boolean binary;
    private boolean directory = true;
    public RemoteFileConfiguration() {
    }
    public RemoteFileConfiguration(URI uri) {
        configure(uri);
    }
    public RemoteFileConfiguration copy() {
        try {
            return (RemoteFileConfiguration)clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeCamelException(e);
        }
    }
    public String toString() {
        return protocol + "":\\"" + username + ""@"" + host + "":"" + port + ""/"" + directory;
    }
    public void configure(URI uri) {
        setProtocol(uri.getScheme());
        setDefaultPort();
        setUsername(uri.getUserInfo());
        setHost(uri.getHost());
        setPort(uri.getPort());
        setFile(uri.getPath());
    }
    protected void setDefaultPort() {
        if (""ftp"".equalsIgnoreCase(protocol)) {
            setPort(21);
        } else if (""sftp"".equalsIgnoreCase(protocol)) {
            setPort(22);
        }
    }
    public String getFile() {
        return file;
    }
    public void setFile(String file) {
        this.file = file;
    }
    public String getHost() {
        return host;
    }
    public void setHost(String host) {
        this.host = host;
    }
    public int getPort() {
        return port;
    }
    public void setPort(int port) {
        if (port != -1) { // use default
            this.port = port;
        }
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public String getProtocol() {
        return protocol;
    }
    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public boolean isBinary() {
        return binary;
    }
    public void setBinary(boolean binary) {
        this.binary = binary;
    }
    public boolean isDirectory() {
        return directory;
    }
    public void setDirectory(boolean directory) {
        this.directory = directory;
    }
    public String dump() {
        return ""RemoteFileConfiguration{"" + ""protocol='"" + protocol + '\'' + "", username='"" + username + '\'' + "", host='"" + host + '\'' + "", port="" + port + "", password='"" + password + '\''
               + "", file='"" + file + '\'' + "", binary="" + binary + "", directory="" + directory + '}';
    }
}
"
org.apache.camel.component.mail.MailConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mail;
import javax.mail.Flags;
import javax.mail.Folder;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.event.MessageCountEvent;
import javax.mail.event.MessageCountListener;
import org.apache.camel.Processor;
import org.apache.camel.impl.ScheduledPollConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
/**
 * A {@link Consumer} which consumes messages from JavaMail using a
 * {@link Transport} and dispatches them to the {@link Processor}
 * 
 * @version $Revision: 523430 $
 */
public class MailConsumer extends ScheduledPollConsumer<MailExchange> implements MessageCountListener {
    private static final transient Log LOG = LogFactory.getLog(MailConsumer.class);
    private final MailEndpoint endpoint;
    private final Folder folder;
    public MailConsumer(MailEndpoint endpoint, Processor processor, Folder folder) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        this.folder = folder;
    }
    @Override
    protected void doStart() throws Exception {
        super.doStart();
        ensureFolderIsOpen();
        folder.addMessageCountListener(this);
    }
    @Override
    protected void doStop() throws Exception {
        folder.removeMessageCountListener(this);
        folder.close(true);
        super.doStop();
    }
    public void messagesAdded(MessageCountEvent event) {
        Message[] messages = event.getMessages();
        for (Message message : messages) {
            try {
                if (!message.getFlags().contains(Flags.Flag.DELETED)) {
                    processMessage(message);
                    flagMessageDeleted(message);
                }
            } catch (MessagingException e) {
                handleException(e);
            }
        }
    }
    public void messagesRemoved(MessageCountEvent event) {
        Message[] messages = event.getMessages();
        for (Message message : messages) {
            if (LOG.isDebugEnabled()) {
                try {
                    LOG.debug(""Removing message: "" + message.getSubject());
                } catch (MessagingException e) {
                    LOG.debug(""Ignored: "" + e);
                }
            }
        }
    }
    protected void poll() throws Exception {
        ensureFolderIsOpen();
        int count = folder.getMessageCount();
        if (count > 0) {
            Message[] messages = folder.getMessages();
            MessageCountEvent event = new MessageCountEvent(folder, MessageCountEvent.ADDED, true, messages);
            messagesAdded(event);
        } else if (count == -1) {
            throw new MessagingException(""Folder: "" + folder.getFullName() + "" is closed"");
        }
        folder.close(true);
    }
    protected void processMessage(Message message) {
        try {
            MailExchange exchange = endpoint.createExchange(message);
            getProcessor().process(exchange);
        } catch (Throwable e) {
            handleException(e);
        }
    }
    protected void ensureFolderIsOpen() throws MessagingException {
        if (!folder.isOpen()) {
            folder.open(Folder.READ_WRITE);
        }
    }
    protected void flagMessageDeleted(Message message) throws MessagingException {
        if (endpoint.getConfiguration().isDeleteProcessedMessages()) {
            message.setFlag(Flags.Flag.DELETED, true);
        } else {
            message.setFlag(Flags.Flag.SEEN, true);
        }
    }
}
"
org.apache.camel.builder.script.Groovy,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.builder.script;
import org.apache.camel.language.LanguageAnnotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
/**
 * An annotation for injection of <a href=""http://groovy.codehaus.org/"">Groovy</a> expressions
 *  into method parameters, fields or properties
 *
 * @version $Revision: 1.1 $
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
@LanguageAnnotation(language = ""groovy"")
public @interface Groovy {
    public abstract String value();
}"
org.apache.camel.spring.spi.SpringInjector,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring.spi;
import org.apache.camel.spi.Injector;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
/**
 * A Spring implementation of {@link Injector} allowing Spring to be used to dependency inject newly created POJOs
 *
 * @version $Revision$
 */
public class SpringInjector implements Injector {
    private final ConfigurableApplicationContext applicationContext;
    private int autowireMode = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;
    private boolean dependencyCheck;
    public SpringInjector(ConfigurableApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    public <T> T newInstance(Class<T> type) {
        // TODO support annotations for mandatory injection points?
        Object value = applicationContext.getBeanFactory().createBean(type, autowireMode, dependencyCheck);
        return type.cast(value);
    }
    public int getAutowireMode() {
        return autowireMode;
    }
    public void setAutowireMode(int autowireMode) {
        this.autowireMode = autowireMode;
    }
    public boolean isDependencyCheck() {
        return dependencyCheck;
    }
    public void setDependencyCheck(boolean dependencyCheck) {
        this.dependencyCheck = dependencyCheck;
    }
}
"
org.apache.camel.converter.jaxb.FallbackTypeConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.TypeConverter;
import org.apache.camel.spi.TypeConverterAware;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.util.JAXBSource;
import javax.xml.transform.Source;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
/**
 * @version $Revision: 1.1 $
 */
public class FallbackTypeConverter implements TypeConverter, TypeConverterAware {
    private static final transient Log LOG = LogFactory.getLog(FallbackTypeConverter.class);
    private TypeConverter parentTypeConverter;
    private boolean prettyPrint = true;
    public boolean isPrettyPrint() {
        return prettyPrint;
    }
    public void setPrettyPrint(boolean prettyPrint) {
        this.prettyPrint = prettyPrint;
    }
    public void setTypeConverter(TypeConverter parentTypeConverter) {
        this.parentTypeConverter = parentTypeConverter;
    }
    public <T> T convertTo(Class<T> type, Object value) {
        try {
            if (isJaxbType(type)) {
                return unmarshall(type, value);
            }
            if (value != null) {
                if (isJaxbType(value.getClass())) {
                    return marshall(type, value);
                }
            }
            return null;
        }
        catch (JAXBException e) {
            throw new RuntimeCamelException(e);
        }
    }
    protected <T> boolean isJaxbType(Class<T> type) {
        XmlRootElement element = type.getAnnotation(XmlRootElement.class);
        boolean jaxbType = element != null;
        return jaxbType;
    }
    /**
     * Lets try parse via JAXB
     */
    protected <T> T unmarshall(Class<T> type, Object value) throws JAXBException {
        JAXBContext context = createContext(type);
        Unmarshaller unmarshaller = context.createUnmarshaller();
        if (parentTypeConverter != null) {
            InputStream inputStream = parentTypeConverter.convertTo(InputStream.class, value);
            if (inputStream != null) {
                Object unmarshalled = unmarshaller.unmarshal(inputStream);
                return type.cast(unmarshalled);
            }
            Reader reader = parentTypeConverter.convertTo(Reader.class, value);
            if (reader != null) {
                Object unmarshalled = unmarshaller.unmarshal(reader);
                return type.cast(unmarshalled);
            }
            Source source = parentTypeConverter.convertTo(Source.class, value);
            if (source != null) {
                Object unmarshalled = unmarshaller.unmarshal(source);
                return type.cast(unmarshalled);
            }
        }
        if (value instanceof String) {
            value = new StringReader((String) value);
        }
        if (value instanceof InputStream) {
            Object unmarshalled = unmarshaller.unmarshal((InputStream) value);
            return type.cast(unmarshalled);
        }
        if (value instanceof Reader) {
            Object unmarshalled = unmarshaller.unmarshal((Reader) value);
            return type.cast(unmarshalled);
        }
        return null;
    }
    protected <T> T marshall(Class<T> type, Object value) throws JAXBException {
        if (parentTypeConverter != null) {
            // lets convert the object to a JAXB source and try convert that to
            // the required source
            JAXBContext context = createContext(value.getClass());
            JAXBSource source = new JAXBSource(context, value);
            T answer = parentTypeConverter.convertTo(type, source);
            if (answer == null) {
                // lets try a stream
                StringWriter buffer = new StringWriter();
                Marshaller marshaller = context.createMarshaller();
                marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, isPrettyPrint() ? Boolean.TRUE : Boolean.FALSE);
                marshaller.marshal(value, buffer);
                return parentTypeConverter.convertTo(type, buffer.toString());
            }
            return answer;
        }
        // lets try convert to the type from JAXB
        return null;
    }
    protected <T> JAXBContext createContext(Class<T> type) throws JAXBException {
        JAXBContext context = JAXBContext.newInstance(type);
        return context;
    }
}
"
org.apache.camel.component.mina.MinaConsumer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import java.net.SocketAddress;
import org.apache.camel.Processor;
import org.apache.camel.impl.DefaultConsumer;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.common.IoAcceptor;
import org.apache.mina.common.IoHandler;
import org.apache.mina.common.IoHandlerAdapter;
import org.apache.mina.common.IoSession;
/**
 * A
 * 
 * @{link Consumer} for MINA
 * @version $Revision$
 */
public class MinaConsumer extends DefaultConsumer<MinaExchange> {
    private static final transient Log LOG = LogFactory.getLog(MinaConsumer.class);
    private final MinaEndpoint endpoint;
    private final SocketAddress address;
    private final IoAcceptor acceptor;
    public MinaConsumer(final MinaEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        this.endpoint = endpoint;
        address = endpoint.getAddress();
        acceptor = endpoint.getAcceptor();
    }
    @Override
    protected void doStart() throws Exception {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Binding to server address: "" + address + "" using acceptor: "" + acceptor);
        }
        IoHandler handler = new IoHandlerAdapter() {
            @Override
            public void messageReceived(IoSession session, Object object) throws Exception {
                getProcessor().process(endpoint.createExchange(session, object));
            }
        };
        acceptor.bind(address, handler, endpoint.getConfig());
    }
    @Override
    protected void doStop() throws Exception {
        acceptor.unbind(address);
        super.doStop();
    }
}
"
org.apache.camel.converter.jaxb.JaxbConverter,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.converter.jaxb;
import org.apache.camel.Converter;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.converter.HasAnnotation;
import org.apache.camel.converter.jaxp.XmlConverter;
import org.w3c.dom.Document;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.util.JAXBSource;
import javax.xml.parsers.ParserConfigurationException;
/**
 * @version $Revision$
 */
public class JaxbConverter {
    private XmlConverter jaxbConverter;
    public XmlConverter getJaxbConverter() {
        if (jaxbConverter == null) {
            jaxbConverter = new XmlConverter();
        }
        return jaxbConverter;
    }
    public void setJaxbConverter(XmlConverter jaxbConverter) {
        this.jaxbConverter = jaxbConverter;
    }
    @Converter
    public static JAXBSource toSource(@HasAnnotation(XmlRootElement.class)Object value) throws JAXBException {
        JAXBContext context = createJaxbContext(value);
        return new JAXBSource(context, value);
    }
    @Converter
    public Document toDocument(
            @HasAnnotation(XmlRootElement.class)Object value) throws JAXBException, ParserConfigurationException {
        JAXBContext context = createJaxbContext(value);
        Marshaller marshaller = context.createMarshaller();
        Document doc = getJaxbConverter().createDocument();
        marshaller.marshal(value, doc);
        return doc;
    }
    @Converter
    public static MessageType toMessageType(Exchange exchange) {
        return toMessageType(exchange.getIn());
    }
    @Converter
    public static MessageType toMessageType(Message in) {
        MessageType answer = new MessageType();
        answer.copyFrom(in);
        return answer;
    }
    protected static JAXBContext createJaxbContext(Object value) throws JAXBException {
        if (value == null) {
            throw new IllegalArgumentException(""Cannot convert from null value to JAXBSource"");
        }
        JAXBContext context = JAXBContext.newInstance(value.getClass());
        return context;
    }
//    public void write(OutputStream out, Object value) throws JAXBException {
//        JAXBContext context = JAXBContext.newInstance(value.getClass());
//        Marshaller marshaller = context.createMarshaller();
//        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
//        marshaller.marshal(value, out);
//    }
}
"
org.apache.camel.component.mina.MinaProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.mina;
import org.apache.camel.Exchange;
import org.apache.camel.Producer;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.util.ExchangeHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.common.ConnectFuture;
import org.apache.mina.common.IoConnector;
import org.apache.mina.common.IoHandler;
import org.apache.mina.common.IoHandlerAdapter;
import org.apache.mina.common.IoSession;
import org.apache.mina.common.WriteFuture;
import java.net.SocketAddress;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
/**
 * A {@link Producer} implementation for MINA
 * 
 * @version $Revision$
 */
public class MinaProducer extends DefaultProducer {
    private static final transient Log LOG = LogFactory.getLog(MinaProducer.class);
    private static final long MAX_WAIT_RESPONSE = 10000;
    private IoSession session;
    private MinaEndpoint endpoint;
    private CountDownLatch latch;
    public MinaProducer(MinaEndpoint endpoint) {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public void process(Exchange exchange) throws Exception{
        if (session == null) {
            throw new IllegalStateException(""Not started yet!"");
        }
        if (!session.isConnected()){
            doStart();
        }
        Object body = exchange.getIn().getBody();
        if (body == null) {
            LOG.warn(""No payload for exchange: "" + exchange);
        } else {
            if (ExchangeHelper.isOutCapable(exchange)){
                if (LOG.isDebugEnabled()){
                    LOG.debug(""Writing body : ""+body);
                }
                latch = new CountDownLatch(1);
                WriteFuture future = session.write(body);
                future.join();
                if (!future.isWritten()){
                    throw new RuntimeException(""Timed out waiting for response: ""+exchange);
                }
                latch.await(MAX_WAIT_RESPONSE, TimeUnit.MILLISECONDS);
                if (latch.getCount()==1){
                    throw new RuntimeException(""No response from server within ""+MAX_WAIT_RESPONSE+"" millisecs"");
                }
                ResponseHandler handler = (ResponseHandler) session.getHandler();
                if (handler.getCause() != null){
                    throw new Exception(""Response Handler had an exception"", handler.getCause());
                }else{
                    if (LOG.isDebugEnabled()){
                        LOG.debug(""Handler message: ""+handler.getMessage());
                    }
                    exchange.getOut().setBody(handler.getMessage());
                }
            }else{
                session.write(body);
            }
        }
    }
    @Override
    protected void doStart() throws Exception {
        SocketAddress address = endpoint.getAddress();
        IoConnector connector = endpoint.getConnector();
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Creating connector to address: "" + address + "" using connector: "" + connector);
        }
        IoHandler ioHandler = new ResponseHandler(endpoint);
        ConnectFuture future = connector.connect(address, ioHandler, endpoint.getConfig());
        future.join();
        session = future.getSession();
    }
    @Override
    protected void doStop() throws Exception {
        if (session != null) {
            session.close().join(2000);
        }
    }
    /**
     * Handles response from session writes
     * 
     * @author <a href=""mailto:karajdaar@gmail.com"">nsandhu</a>
     *
     */
    private final class ResponseHandler extends IoHandlerAdapter {
        private MinaEndpoint endpoint;
        private Object message;
        private Throwable cause;
        /**
         * @param endpoint
         */
        private ResponseHandler(MinaEndpoint endpoint) {
            this.endpoint = endpoint;
        }
        @Override
        public void messageReceived(IoSession ioSession, Object message) throws Exception {
            if (LOG.isDebugEnabled()) {
                LOG.debug(""Message received: ""+message);
            }
            cause = null;
            this.message = message;
            latch.countDown();
        }
        @Override
        public void exceptionCaught(IoSession ioSession, Throwable cause) {
            LOG.error(""Exception on receiving message from address: ""+this.endpoint.getAddress()
                        + "" using connector: ""+this.endpoint.getConnector(), cause);
            this.message = null;
            this.cause = cause;
            ioSession.close();
            latch.countDown();
        }
        public Throwable getCause() {
            return this.cause;
        }
        public Object getMessage() {
            return this.message;
        }
    }
}
"
org.apache.camel.component.cxf.CxfSoapEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf;
import org.apache.camel.*;
import org.apache.cxf.Bus;
import org.apache.cxf.BusFactory;
import org.apache.cxf.helpers.DOMUtils;
import org.springframework.core.io.Resource;
import org.springframework.util.Assert;
import javax.wsdl.Definition;
import javax.wsdl.xml.WSDLReader;
import javax.wsdl.factory.WSDLFactory;
import javax.xml.namespace.QName;
/**
 * A CXF based SOAP endpoint which wraps an existing
 * endpoint with SOAP processing.
 */
public class CxfSoapEndpoint implements Endpoint {
    private final Endpoint endpoint;
    private Resource wsdl;
    private org.w3c.dom.Document description;
    private Definition definition;
    private QName service;
    private Bus bus;
    public CxfSoapEndpoint(Endpoint endpoint) {
        this.endpoint = endpoint;
    }
    protected Endpoint getInnerEndpoint() {
        return endpoint;
    }
    public boolean isSingleton() {
        return endpoint.isSingleton();
    }
    public String getEndpointUri() {
        return endpoint.getEndpointUri();
    }
    public Exchange createExchange() {
        return endpoint.createExchange();
    }
    public Exchange createExchange(ExchangePattern pattern) {
        return endpoint.createExchange(pattern);
    }
    public Exchange createExchange(Exchange exchange) {
        return endpoint.createExchange(exchange);
    }
    public CamelContext getContext() {
        return endpoint.getContext();
    }
    public Producer createProducer() throws Exception {
        return new CxfSoapProducer(this);
    }
    public Consumer createConsumer(Processor processor) throws Exception {
        return new CxfSoapConsumer(this, processor);
    }
    public PollingConsumer createPollingConsumer() throws Exception {
        throw new UnsupportedOperationException();
    }
    public void setWsdl(Resource wsdl) {
        this.wsdl = wsdl;
    }
    public void init() throws Exception {
        Assert.notNull(wsdl, ""soap.wsdl parameter must be set on the uri"");
        description = DOMUtils.readXml(wsdl.getInputStream());
        WSDLFactory wsdlFactory = WSDLFactory.newInstance();
        WSDLReader reader = wsdlFactory.newWSDLReader();
        reader.setFeature(""javax.wsdl.verbose"", false);
        definition = reader.readWSDL(wsdl.getURL().toString(), description);
        service = (QName) definition.getServices().keySet().iterator().next();
    }
    protected Bus getBus() {
        if (bus == null) {
            bus = BusFactory.newInstance().createBus();
        }
        return bus;
    }
    public Definition getDefinition() {
        return definition;
    }
    public QName getService() {
        return service;
    }
}
"
org.apache.camel.component.rmi.RmiProducer,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.rmi;
import java.rmi.NotBoundException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.registry.Registry;
import org.apache.camel.Exchange;
import org.apache.camel.component.bean.BeanProcessor;
import org.apache.camel.impl.DefaultProducer;
/**
 * @version $Revision: 533076 $
 */
public class RmiProducer extends DefaultProducer {
    private final RmiEndpoint endpoint;
    private Remote remote;
    private BeanProcessor beanProcessor;
    public RmiProducer(RmiEndpoint endpoint) throws RemoteException, NotBoundException {
        super(endpoint);
        this.endpoint = endpoint;
    }
    public void process(Exchange exchange) throws Exception {
        if (beanProcessor == null) {
            beanProcessor = new BeanProcessor(getRemote(), getEndpoint().getContext());
        }
        beanProcessor.process(exchange);
    }
    public Remote getRemote() throws RemoteException, NotBoundException {
        if (remote == null) {
            Registry registry = endpoint.getRegistry();
            remote = registry.lookup(endpoint.getName());
        }
        return remote;
    }
}
"
org.apache.camel.bam.processor.ActivityMonitorEngine,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.processor;
import java.util.Date;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.LockModeType;
import javax.persistence.PersistenceException;
import org.apache.camel.bam.model.ActivityState;
import org.apache.camel.bam.rules.ProcessRules;
import org.apache.camel.impl.ServiceSupport;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.orm.jpa.JpaCallback;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;
/**
 * A timer engine to monitor for expired activities and perform whatever actions
 * are required.
 * 
 * @version $Revision: $
 */
public class ActivityMonitorEngine extends ServiceSupport implements Runnable {
    private static final Log LOG = LogFactory.getLog(ActivityMonitorEngine.class);
    private JpaTemplate template;
    private TransactionTemplate transactionTemplate;
    private ProcessRules rules;
    private int escalateLevel;
    private long windowMillis = 1000L;
    private Thread thread;
    private boolean useLocking;
    public ActivityMonitorEngine(JpaTemplate template, TransactionTemplate transactionTemplate, ProcessRules rules) {
        this.template = template;
        this.transactionTemplate = transactionTemplate;
        this.rules = rules;
    }
    public boolean isUseLocking() {
        return useLocking;
    }
    public void setUseLocking(boolean useLocking) {
        this.useLocking = useLocking;
    }
    public void run() {
        LOG.debug(""Starting to poll for timeout events"");
        while (!isStopped()) {
            try {
                long now = System.currentTimeMillis();
                long nextPoll = now + windowMillis;
                final Date timeNow = new Date(now);
                transactionTemplate.execute(new TransactionCallbackWithoutResult() {
                    protected void doInTransactionWithoutResult(TransactionStatus status) {
                        List<ActivityState> list = template.find(""select x from "" + ActivityState.class.getName() + "" x where x.escalationLevel = ?1 and x.timeOverdue < ?2"", escalateLevel, timeNow);
                        for (ActivityState activityState : list) {
                            fireExpiredEvent(activityState);
                        }
                    }
                });
                long timeToSleep = nextPoll - System.currentTimeMillis();
                if (timeToSleep > 0) {
                    if (LOG.isDebugEnabled()) {
                        LOG.debug(""Sleeping for "" + timeToSleep + "" millis"");
                    }
                    try {
                        Thread.sleep(timeToSleep);
                    } catch (InterruptedException e) {
                        LOG.debug(""Caught: "" + e, e);
                    }
                }
            } catch (Exception e) {
                LOG.error(""Caught: "" + e, e);
            }
        }
    }
    protected void fireExpiredEvent(final ActivityState activityState) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Trying to fire expiration of: "" + activityState);
        }
        template.execute(new JpaCallback() {
            public Object doInJpa(EntityManager entityManager) throws PersistenceException {
                // lets try lock the object first
                if (isUseLocking()) {
                    LOG.info(""Attempting to lock: "" + activityState);
                    entityManager.lock(activityState, LockModeType.WRITE);
                    LOG.info(""Grabbed lock: "" + activityState);
                }
                try {
                    rules.processExpired(activityState);
                } catch (Exception e) {
                    LOG.error(""Failed to process expiration of: "" + activityState + "". Reason: "" + e, e);
                }
                activityState.setEscalationLevel(escalateLevel + 1);
                return null;
            }
        });
    }
    protected void doStart() throws Exception {
        rules.start();
        thread = new Thread(this, ""ActivityMonitorEngine"");
        thread.start();
    }
    protected void doStop() throws Exception {
        if (thread != null) {
            thread = null;
        }
        rules.stop();
    }
}
"
org.apache.camel.component.cxf.interceptors.AbstractInvokerInterceptor,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.interceptors;
import java.io.IOException;
import java.util.logging.Logger;
import org.apache.camel.component.cxf.CamelInvoker;
import org.apache.camel.component.cxf.invoker.InvokingContext;
import org.apache.cxf.endpoint.ConduitSelector;
import org.apache.cxf.endpoint.PreexistingConduitSelector;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.interceptor.InterceptorChain;
import org.apache.cxf.message.Exchange;
import org.apache.cxf.message.Message;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.service.model.BindingMessageInfo;
import org.apache.cxf.service.model.BindingOperationInfo;
import org.apache.cxf.transport.Conduit;
import org.apache.cxf.ws.addressing.EndpointReferenceType;
/**
 * This is the base class for routing interceptors that can intercept and forward
 * message to router as different phases.
 *
 */
public abstract class AbstractInvokerInterceptor extends AbstractPhaseInterceptor<Message> {
    public static final String ROUTING_INERCEPTOR_PHASE = ""Routing-Phase"";
    public static final String BUNDLE = ""wsdl-cxf""; 
    public AbstractInvokerInterceptor(String phase) {
        super(phase);
    }
    private boolean isRequestor(Message message) {
        return Boolean.TRUE.equals(message.get(Message.REQUESTOR_ROLE));
    }
    /**
     * Send the intercepted message to router
     */
    @SuppressWarnings(""unchecked"")
    public void handleMessage(Message inMessage) throws Fault {
        if (isRequestor(inMessage)) {
            return;
        }
        Exchange exchange = inMessage.getExchange();
        Message outMessage = null;
        try {
            CamelInvoker invoker = exchange.get(CamelInvoker.class);
            outMessage = invoker.invoke(inMessage);
        } catch (Exception e) {
            throw new Fault(e);
        }
        // set back channel conduit in the exchange if it is not present
        setBackChannelConduit(exchange, outMessage);
        Exception ex = outMessage.getContent(Exception.class);
        if (ex != null) {
            if (!(ex instanceof Fault)) {
                ex = new Fault(ex); 
            }
            throw (Fault)ex;
        }
        outMessage.put(Message.INBOUND_MESSAGE, Boolean.FALSE);
        BindingOperationInfo boi = exchange.get(BindingOperationInfo.class);
        if (boi != null) {
            exchange.put(BindingMessageInfo.class, boi.getOutput());
        }
        InvokingContext invokingContext = exchange.get(InvokingContext.class);
        assert invokingContext != null;
        InterceptorChain chain = invokingContext.getResponseOutInterceptorChain(exchange);
        if (chain != null) {
            outMessage.setInterceptorChain(chain);
            //Initiate the OutBound Chain.
            chain.doIntercept(outMessage);
        }                
    }
    /**
     * Creates a conduit if not present on the exchange. outMessage or faultMessage
     * It will create a back channel in PAYLOAD and MESSAGE case.
     * POJO case will have a coduit due to OutgoingChainInterceptor in PRE_INVOKE Phase
     */
    protected void setBackChannelConduit(Exchange ex, Message message) throws Fault {
        Conduit conduit = ex.getConduit(message);
        if (conduit == null) {
            try {
                EndpointReferenceType target =
                    ex.get(EndpointReferenceType.class);
                conduit = ex.getDestination().getBackChannel(ex.getInMessage(), null, target);
                ex.put(ConduitSelector.class,
                       new PreexistingConduitSelector(conduit));
            } catch (IOException e) {
                throw new Fault(e);
            }
        }
        assert conduit != null;
    }
    protected abstract Logger getLogger();
}
"
org.apache.camel.component.jms.ConsumerType,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.jms;
/**
 * @version $Revision$
 */
public enum ConsumerType {
    Simple, Default, ServerSessionPool
}
"
org.apache.camel.component.jdbc.JdbcEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing pejdbcssions and
 * limitations under the License.
 */
package org.apache.camel.component.jdbc;
import java.net.URI;
import java.net.URISyntaxException;
import org.apache.camel.Consumer;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.ExchangePattern;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultExchange;
/**
 * @version $Revision:520964 $
 */
public class JdbcEndpoint extends DefaultEndpoint<DefaultExchange> {
    private URI uri;
    private String remaining;
    /** The maximum size for reading a result set <code>readSize</code> */
    private int readSize = 20000;
    protected JdbcEndpoint(String endpointUri, String remaining, JdbcComponent component) throws URISyntaxException {
        super(endpointUri, component);
        this.uri = new URI(endpointUri);
        this.remaining = remaining;
    }
    public boolean isSingleton() {
        return false;
    }
    public Consumer<DefaultExchange> createConsumer(Processor processor) throws Exception {
        throw new RuntimeCamelException(""A JDBC Consumer would be the server side of database! No such support here"");
    }
    public Producer<DefaultExchange> createProducer() throws Exception {
        return new JdbcProducer(this, remaining, readSize);
    }
    public String getName() {
        String path = uri.getPath();
        if (path == null) {
            path = uri.getSchemeSpecificPart();
        }
        return path;
    }
    public int getReadSize() {
        return this.readSize;
    }
    public void setReadSize(int readSize) {
        this.readSize = readSize;
    }
}
"
org.apache.camel.bam.model.ActivityDefinition,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.bam.model;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.UniqueConstraint;
/**
 * @version $Revision: 1.1 $
 */
@Entity
@UniqueConstraint(columnNames = {""name"" })
public class ActivityDefinition extends EntitySupport {
    private String name;
    private ProcessDefinition processDefinition;
    // This crap is required to work around a bug in hibernate
    @Override
    @Id
    @GeneratedValue
    public Long getId() {
        return super.getId();
    }
    @Override
    public String toString() {
        return ""Activity["" + getId() + "" name: "" + getName() + ""]"";
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST })
    public ProcessDefinition getProcessDefinition() {
        return processDefinition;
    }
    public void setProcessDefinition(ProcessDefinition processDefinition) {
        this.processDefinition = processDefinition;
    }
}
"
org.apache.camel.component.file.remote.FtpEndpoint,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.file.remote;
import java.io.IOException;
import org.apache.camel.Processor;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.commons.net.ftp.FTPClient;
public class FtpEndpoint extends RemoteFileEndpoint<RemoteFileExchange> {
    private static final transient Log LOG = LogFactory.getLog(FtpEndpoint.class);
    public FtpEndpoint(String uri, RemoteFileComponent remoteFileComponent, RemoteFileConfiguration configuration) {
        super(uri, remoteFileComponent, configuration);
    }
    public FtpProducer createProducer() throws Exception {
        return new FtpProducer(this, createFtpClient());
    }
    public FtpConsumer createConsumer(Processor processor) throws Exception {
        final FtpConsumer consumer = new FtpConsumer(this, processor, createFtpClient());
        configureConsumer(consumer);
        return consumer;
    }
    protected FTPClient createFtpClient() throws IOException {
        final FTPClient client = new FTPClient();
        RemoteFileConfiguration config = getConfiguration();
        String host = config.getHost();
        int port = config.getPort();
        LOG.debug(""Connecting to host: "" + host + "" port: "" + port);
        client.connect(host, port);
        client.login(config.getUsername(), config.getPassword());
        client.setFileType(config.isBinary() ? FTPClient.BINARY_FILE_TYPE : FTPClient.ASCII_FILE_TYPE);
        return client;
    }
}
"
org.apache.camel.component.cxf.invoker.PayloadMessage,"/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.component.cxf.invoker;
import java.util.List;
import org.w3c.dom.Element;
public class PayloadMessage {
    private List<Element> payload;
    private Element header;
    public PayloadMessage(List<Element> payload, Element header) {
        this.payload = payload;
        this.header = header;
    }
    public List<Element> getPayload() {
        return payload;
    }
    public Element getHeader() {
        return header;
    }
    public String toString() {
        StringBuffer buf = new StringBuffer();
        buf.append(""payload: "" + payload);
        buf.append("" header: "" + header);
        return buf.toString();
    }
}
"
org.apache.camel.spring.SpringInstrumentationAgent,"/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.camel.spring;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlTransient;
import javax.management.MBeanServer;
import org.apache.camel.management.InstrumentationAgentImpl;
import org.apache.camel.CamelContext;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
public class SpringInstrumentationAgent extends InstrumentationAgentImpl
        implements InitializingBean, DisposableBean {
    private static final transient Log LOG = LogFactory.getLog(SpringInstrumentationAgent.class);
    public void afterPropertiesSet() throws Exception {
		LOG.debug(""Starting JMX agent on server: "" + getMBeanServer());
        start();
	}
	public void destroy() throws Exception {
	}
}
"
