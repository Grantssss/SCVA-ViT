metric_name,file
bsh.ASCII_UCodeESC_CharStream,"/* Generated By:JavaCC: Do not edit this line. ASCII_UCodeESC_CharStream.java Version 0.7pre6 */
package bsh;
/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (with java-like unicode escape processing).
 */
final class ASCII_UCodeESC_CharStream
{
  public static final boolean staticFlag = false;
  static final int hexval(char c) throws java.io.IOException {
    switch(c)
    {
       case '0' :
          return 0;
       case '1' :
          return 1;
       case '2' :
          return 2;
       case '3' :
          return 3;
       case '4' :
          return 4;
       case '5' :
          return 5;
       case '6' :
          return 6;
       case '7' :
          return 7;
       case '8' :
          return 8;
       case '9' :
          return 9;
       case 'a' :
       case 'A' :
          return 10;
       case 'b' :
       case 'B' :
          return 11;
       case 'c' :
       case 'C' :
          return 12;
       case 'd' :
       case 'D' :
          return 13;
       case 'e' :
       case 'E' :
          return 14;
       case 'f' :
       case 'F' :
          return 15;
    }
    throw new java.io.IOException(); // Should never come here
  }
  public int bufpos = -1;
  int bufsize;
  int available;
  int tokenBegin;
  private int bufline[];
  private int bufcolumn[];
  private int column = 0;
  private int line = 1;
  private java.io.Reader inputStream;
  private boolean prevCharIsCR = false;
  private boolean prevCharIsLF = false;
  private char[] nextCharBuf;
  private char[] buffer;
  private int maxNextCharInd = 0;
  private int nextCharInd = -1;
  private int inBuf = 0;
  private final void ExpandBuff(boolean wrapAround)
  {
     char[] newbuffer = new char[bufsize + 2048];
     int newbufline[] = new int[bufsize + 2048];
     int newbufcolumn[] = new int[bufsize + 2048];
     try
     {
        if (wrapAround)
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           System.arraycopy(buffer, 0, newbuffer,
                                             bufsize - tokenBegin, bufpos);
           buffer = newbuffer;
           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
           bufline = newbufline;
           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
           bufcolumn = newbufcolumn;
           bufpos += (bufsize - tokenBegin);
        }
        else
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           buffer = newbuffer;
           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           bufline = newbufline;
           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           bufcolumn = newbufcolumn;
           bufpos -= tokenBegin;
        }
     }
     catch (Throwable t)
     {
        throw new Error(t.getMessage());
     }
     available = (bufsize += 2048);
     tokenBegin = 0;
  }
  private final void FillBuff() throws java.io.IOException
  {
     int i;
     if (maxNextCharInd == 4096)
        maxNextCharInd = nextCharInd = 0;
     try {
        if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
                                            4096 - maxNextCharInd)) == -1)
        {
           inputStream.close();
           throw new java.io.IOException();
        }
        else
           maxNextCharInd += i;
        return;
     }
     catch(java.io.IOException e) {
        if (bufpos != 0)
        {
           --bufpos;
           backup(0);
        }
        else
        {
           bufline[bufpos] = line;
           bufcolumn[bufpos] = column;
        }
        throw e;
     }
  }
  private final char ReadByte() throws java.io.IOException
  {
     if (++nextCharInd >= maxNextCharInd)
        FillBuff();
     return nextCharBuf[nextCharInd];
  }
  public final char BeginToken() throws java.io.IOException
  {     
     if (inBuf > 0)
     {
        --inBuf;
        return buffer[tokenBegin = (bufpos == bufsize - 1) ? (bufpos = 0)
                                                           : ++bufpos];
     }
     tokenBegin = 0;
     bufpos = -1;
     return readChar();
  }     
  private final void AdjustBuffSize()
  {
     if (available == bufsize)
     {
        if (tokenBegin > 2048)
        {
           bufpos = 0;
           available = tokenBegin;
        }
        else
           ExpandBuff(false);
     }
     else if (available > tokenBegin)
        available = bufsize;
     else if ((tokenBegin - available) < 2048)
        ExpandBuff(true);
     else
        available = tokenBegin;
  }
  private final void UpdateLineColumn(char c)
  {
     column++;
     if (prevCharIsLF)
     {
        prevCharIsLF = false;
        line += (column = 1);
     }
     else if (prevCharIsCR)
     {
        prevCharIsCR = false;
        if (c == '\n')
        {
           prevCharIsLF = true;
        }
        else
           line += (column = 1);
     }
     switch (c)
     {
        case '\r' :
           prevCharIsCR = true;
           break;
        case '\n' :
           prevCharIsLF = true;
           break;
        case '\t' :
           column--;
           column += (8 - (column & 07));
           break;
        default :
           break;
     }
     bufline[bufpos] = line;
     bufcolumn[bufpos] = column;
  }
  public final char readChar() throws java.io.IOException
  {
     if (inBuf > 0)
     {
        --inBuf;
        return buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos];
     }
     char c;
     if (++bufpos == available)
        AdjustBuffSize();
     if (((buffer[bufpos] = c = (char)((char)0xff & ReadByte())) == '\\'))
     {
        UpdateLineColumn(c);
        int backSlashCnt = 1;
        for (;;) // Read all the backslashes
        {
           if (++bufpos == available)
              AdjustBuffSize();
           try
           {
              if ((buffer[bufpos] = c = (char)((char)0xff & ReadByte())) != '\\')
              {
                 UpdateLineColumn(c);
                 // found a non-backslash char.
                 if ((c == 'u') && ((backSlashCnt & 1) == 1))
                 {
                    if (--bufpos < 0)
                       bufpos = bufsize - 1;
                    break;
                 }
                 backup(backSlashCnt);
                 return '\\';
              }
           }
           catch(java.io.IOException e)
           {
              if (backSlashCnt > 1)
                 backup(backSlashCnt);
              return '\\';
           }
           UpdateLineColumn(c);
           backSlashCnt++;
        }
        // Here, we have seen an odd number of backslash's followed by a 'u'
        try
        {
           while ((c = (char)((char)0xff & ReadByte())) == 'u')
              ++column;
           buffer[bufpos] = c = (char)(hexval(c) << 12 |
                                       hexval((char)((char)0xff & ReadByte())) << 8 |
                                       hexval((char)((char)0xff & ReadByte())) << 4 |
                                       hexval((char)((char)0xff & ReadByte())));
           column += 4;
        }
        catch(java.io.IOException e)
        {
           throw new Error(""Invalid escape character at line "" + line +
                                         "" column "" + column + ""."");
        }
        if (backSlashCnt == 1)
           return c;
        else
        {
           backup(backSlashCnt - 1);
           return '\\';
        }
     }
     else
     {
        UpdateLineColumn(c);
        return (c);
     }
  }
  /**
   * @deprecated 
   * @see #getEndColumn
   */
  public final int getColumn() {
     return bufcolumn[bufpos];
  }
  /**
   * @deprecated 
   * @see #getEndLine
   */
  public final int getLine() {
     return bufline[bufpos];
  }
  public final int getEndColumn() {
     return bufcolumn[bufpos];
  }
  public final int getEndLine() {
     return bufline[bufpos];
  }
  public final int getBeginColumn() {
     return bufcolumn[tokenBegin];
  }
  public final int getBeginLine() {
     return bufline[tokenBegin];
  }
  public final void backup(int amount) {
    inBuf += amount;
    if ((bufpos -= amount) < 0)
       bufpos += bufsize;
  }
  public ASCII_UCodeESC_CharStream(java.io.Reader dstream,
                 int startline, int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;
    available = bufsize = buffersize;
    buffer = new char[buffersize];
    bufline = new int[buffersize];
    bufcolumn = new int[buffersize];
    nextCharBuf = new char[4096];
  }
  public ASCII_UCodeESC_CharStream(java.io.Reader dstream,
                                        int startline, int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }
  public void ReInit(java.io.Reader dstream,
                 int startline, int startcolumn, int buffersize)
  {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;
    if (buffer == null || buffersize != buffer.length)
    {
      available = bufsize = buffersize;
      buffer = new char[buffersize];
      bufline = new int[buffersize];
      bufcolumn = new int[buffersize];
      nextCharBuf = new char[4096];
    }
    prevCharIsLF = prevCharIsCR = false;
    tokenBegin = inBuf = maxNextCharInd = 0;
    nextCharInd = bufpos = -1;
  }
  public void ReInit(java.io.Reader dstream,
                                        int startline, int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }
  public ASCII_UCodeESC_CharStream(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
     this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
  }
  public ASCII_UCodeESC_CharStream(java.io.InputStream dstream, int startline,
                                                           int startcolumn)
  {
     this(dstream, startline, startcolumn, 4096);
  }
  public void ReInit(java.io.InputStream dstream, int startline,
  int startcolumn, int buffersize)
  {
     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
  }
  public void ReInit(java.io.InputStream dstream, int startline,
                                                           int startcolumn)
  {
     ReInit(dstream, startline, startcolumn, 4096);
  }
  public final String GetImage()
  {
     if (bufpos >= tokenBegin)
        return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
     else
        return new String(buffer, tokenBegin, bufsize - tokenBegin) +
                              new String(buffer, 0, bufpos + 1);
  }
  public final char[] GetSuffix(int len)
  {
     char[] ret = new char[len];
     if ((bufpos + 1) >= len)
        System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
     else
     {
        System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
                                                          len - bufpos - 1);
        System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
     }
     return ret;
  }
  public void Done()
  {
     nextCharBuf = null;
     buffer = null;
     bufline = null;
     bufcolumn = null;
  }
  /**
   * Method to adjust line and column numbers for the start of a token.<BR>
   */
  public void adjustBeginLineColumn(int newLine, int newCol)
  {
     int start = tokenBegin;
     int len;
     if (bufpos >= tokenBegin)
     {
        len = bufpos - tokenBegin + inBuf + 1;
     }
     else
     {
        len = bufsize - tokenBegin + bufpos + 1 + inBuf;
     }
     int i = 0, j = 0, k = 0;
     int nextColDiff = 0, columnDiff = 0;
     while (i < len &&
            bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
     {
        bufline[j] = newLine;
        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
        bufcolumn[j] = newCol + columnDiff;
        columnDiff = nextColDiff;
        i++;
     } 
     if (i < len)
     {
        bufline[j] = newLine++;
        bufcolumn[j] = newCol + columnDiff;
        while (i++ < len)
        {
           if (bufline[j = start % bufsize] != bufline[++start % bufsize])
              bufline[j] = newLine++;
           else
              bufline[j] = newLine;
        }
     }
     line = bufline[j];
     column = bufcolumn[j];
  }
}
"
bsh.BlockNameSpace,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package	bsh;
/**
    A specialized namespace	for Blocks, e.g. the body of a ""for"" statement.
	The Block acts like a child namespace but only for typed variables 
	declared within it.  Elsewhere variable assignment (including untyped
	variable usage) acts like it is part of the containing block.  
	<p>
	Note: It *must* remain possible for a BlockNameSpace to be a child of
	another BlockNameSpace and have variable propogation pass all the way
	through.  (This happens naturally and simply here). This is used in 
	BSHForStatement (see notes there).
*/
class BlockNameSpace extends NameSpace 
{
    public BlockNameSpace( NameSpace parent ) 
		throws EvalError
	{
		super( parent, parent.name + ""/BlockNameSpace"" );
    }
	/**
		Override the standard namespace behavior.
		If the variables exists in our namespace assign it there,
		otherwise in the parent space.
		i.e. only allow typed var declaration to happen in this namespace.
		Typed vars are handled in the ordinary way... local scope.
	*/
    public void	setVariable(String name, Object	o) throws EvalError {
		if ( weHaveVar( name ) ) 
			super.setVariable( name, o );
		else
			getParent().setVariable( name, o );
    }
	boolean weHaveVar( String name ) {
		return super.getVariableImpl( name, false ) != null;
	}
}
"
bsh.BSHAllocationExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
class BSHAllocationExpression extends SimpleNode
{
    BSHAllocationExpression(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        // type is either a class name or a primitive type
        SimpleNode type = (SimpleNode)jjtGetChild(0);
        // args is either constructor arguments or array dimensions
        SimpleNode args = (SimpleNode)jjtGetChild(1);
        if ( type instanceof BSHAmbiguousName )
        {
            BSHAmbiguousName name = (BSHAmbiguousName)type;
            if(args instanceof BSHArguments)
                return objectAllocation(name, (BSHArguments)args, 
					callstack, interpreter );
            else
                return objectArrayAllocation(name, (BSHArrayDimensions)args, 
					callstack, interpreter );
        }
        else
            return primitiveArrayAllocation((BSHPrimitiveType)type,
                (BSHArrayDimensions)args, callstack, interpreter );
    }
    private Object objectAllocation(
		BSHAmbiguousName nameNode, BSHArguments argumentsNode, 
		CallStack callstack, Interpreter interpreter 
	) 
		throws EvalError
    {
		NameSpace namespace = callstack.top();
        Class type = nameNode.toClass(namespace);
		/* toClass throws this
        if (type == null)
            throw new EvalError(
				""Class "" + nameNode.getName(namespace) + "" not found."", this);
		*/
        Object[] args = argumentsNode.getArguments(callstack, interpreter);
        if(args == null)
            throw new EvalError(""Trying to new a class...?"", this);
		// Is an inner class style object allocation
		boolean hasBody = jjtGetNumChildren() > 2;
		if ( hasBody ) {
        	BSHBlock body = (BSHBlock)jjtGetChild(2);
			return constructWithBody( 
				type, args, body, callstack, interpreter );
		} else
			return constructObject( type, args );
    }
	private Object constructObject( Class type, Object[] args ) 
		throws EvalError
	{
        try {
            return Reflect.constructObject(type, args);
        } catch(ReflectError e) {
            throw new EvalError(""Constructor error: "" + e.getMessage(), this);
        } catch(InvocationTargetException e) {
            Interpreter.debug(""The constructor threw an exception:\n\t"" +
                e.getTargetException());
            throw new TargetError(e.getTargetException(), this);
        }
	}
	private Object constructWithBody( 
		Class type, Object[] args, BSHBlock body,
		CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		if ( ! type.isInterface() )
			throw new EvalError(
				""BeanShell cannot extend class types: ""+ type );
		NameSpace namespace = callstack.top();
// Maybe we should swap in local namespace for the top?
// who is the caller?
		NameSpace local = new NameSpace(namespace, ""anonymous block object"");
		callstack.push(local);
		body.eval( callstack, interpreter, true );
		callstack.pop();
		return local.getThis(interpreter).getInterface( type );
	}
// combine part of this with primitiveArrayAllocation
    private Object objectArrayAllocation(
		BSHAmbiguousName nameNode, BSHArrayDimensions dimensionsNode, 
		CallStack callstack, Interpreter interpreter 
	) 
		throws EvalError
    {
		NameSpace namespace = callstack.top();
        Class type = nameNode.toClass(namespace);
        if(type == null)
            throw new EvalError(
				""Class "" + nameNode.getName(namespace) + "" not found."", this);
		// dimensionsNode can return either an intialized version or none.
        Object result = dimensionsNode.eval( type, callstack, interpreter );
        if(result != Primitive.VOID)
            return result;
		else
			return arrayNewInstance( type, dimensionsNode );
    }
// combine part of this with objectArrayAllocation
    private Object primitiveArrayAllocation(
		BSHPrimitiveType typeNode, BSHArrayDimensions dimensionsNode, 
		CallStack callstack, Interpreter interpreter 
	) 
		throws EvalError
    {
        Class type = typeNode.getType();
		// dimensionsNode can return either an intialized version or none.
        Object result = dimensionsNode.eval( type, callstack, interpreter );
        if (result != Primitive.VOID) 
            return result;
		return arrayNewInstance( type, dimensionsNode );
    }
	private Object arrayNewInstance( 
		Class type, BSHArrayDimensions dimensionsNode )
		throws EvalError
	{
        try {
            return Array.newInstance(type, dimensionsNode.dimensions);
        } catch( NegativeArraySizeException e1) {
			throw new TargetError(""Negative Array Size"", e1);
        } catch(Exception e) {
            throw new EvalError(""Can't construct primitive array: "" +
                e.getMessage(), this);
        }
	}
}
"
bsh.BSHAmbiguousName,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHAmbiguousName extends SimpleNode
{
    public String text;
    BSHAmbiguousName(int id) { super(id); }
    public Name getName( NameSpace namespace )
    {
        return namespace.getNameResolver( text );
    }
    public Object toObject(CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        return getName( callstack.top() ).toObject( callstack, interpreter );
    }
    public Class toClass(NameSpace namespace) throws EvalError
    {
        return getName(namespace).toClass();
    }
    public LHS toLHS( CallStack callstack, Interpreter interpreter)
		throws EvalError
    {
        return getName( callstack.top() ).toLHS( callstack, interpreter );
    }
	/*
		The interpretation of an ambiguous name is context sensitive.
		We disallow a generic eval( ).
	*/
    public Object eval( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
		throw new InterpreterError( 
			""Don't know how to eval an ambiguous name!""
			+""  Use toObject() if you want an object."" );
    }
	public String toString() {
		return ""AmbigousName: ""+text;
	}
}
"
bsh.BSHArguments,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHArguments extends SimpleNode
{
    BSHArguments(int id) { super(id); }
    public Object[] getArguments( CallStack callstack, Interpreter interpreter)
		throws EvalError
    {
        // evaluate each child
        Object[] args = new Object[jjtGetNumChildren()];
        for(int i = 0; i < args.length; i++)
            args[i] = ((SimpleNode)jjtGetChild(i)).eval(callstack, interpreter);
        return args;
    }
}
"
bsh.BSHArrayDimensions,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Array;
/**
	The name of this class is somewhat misleading.  This covers both the case
	where there is an array initializer and 
*/
class BSHArrayDimensions extends SimpleNode
{
	public Class baseType;
    private int arrayDims;
	/** The Length in each dimension.  This value set by the eval() */
	// is it ok to cache this here?
	// it can't change, right?
    /*transient?why?*/ 
	public int [] dimensions;  
    BSHArrayDimensions(int id) { super(id); }
    public void addArrayDimension() { arrayDims++; }
    public Object eval( 
			Class type, CallStack callstack, Interpreter interpreter ) 
		throws EvalError 
	{
		Interpreter.debug(""array base type = ""+type);
		baseType = type;
		return eval( callstack, interpreter );
	}
	/**
		Evaluate the structure of the array in one of two ways:
			a) an initializer exists, evaluate it and return
			the fully constructed array object, also record the dimensions
			of that array
			b) evaluate and record the lengths in each dimension and 
			return void.
		The structure of the array dims is maintained in dimensions.
	*/
    public Object eval( CallStack callstack, Interpreter interpreter )  
		throws EvalError
    {
		SimpleNode child = (SimpleNode)jjtGetChild(0);
		if (child instanceof BSHArrayInitializer)
		// evaluate the initializer and the dimensions it returns
		{
			if ( baseType == null )
				throw new EvalError( 
					""Internal Array Eval err:  unknown base type"", this);
			Object initValue = ((BSHArrayInitializer)child).eval(
				baseType, arrayDims, callstack, interpreter);
			Class arrayClass = initValue.getClass();
			dimensions = new int[
				Reflect.getArrayDimensions(arrayClass) ];
			// compare with number of dimensions explicitly specified
			if (dimensions.length != arrayDims)
				throw new EvalError(
				""Incompatible initializer. Allocation calls for a "" + 
				arrayDims + "" dimensional array, but initializer is a "" +
					dimensions.length + "" dimensional array"", this);
			// fill in dimensions[] lengths
			Object arraySlice = initValue;
			for(int i = 0; i < dimensions.length; i++) {
				dimensions[i] = Array.getLength( arraySlice );
				if ( dimensions[i] > 0 )
					arraySlice = Array.get(arraySlice, 0);
			}
			return initValue;
		}
		else 
		// evaluate the dimensions of the array
		{
			dimensions = new int[ jjtGetNumChildren() ];
			for(int i = 0; i < dimensions.length; i++)
			{
				try {
					Object length = ((SimpleNode)jjtGetChild(i)).eval(
						callstack, interpreter);
					dimensions[i] = ((Primitive)length).intValue();
				}
				catch(Exception e)
				{
					throw new EvalError(
						""Array index: "" + i + 
						"" does not evaluate to an integer"", this);
				}
			}
		}
        return Primitive.VOID;
    }
}
"
bsh.BSHArrayInitializer,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Array;
class BSHArrayInitializer extends SimpleNode
{
    BSHArrayInitializer(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError 
	{
		throw new EvalError( ""Array initializer has no base type."");
	}
	/**
		Construct the array from the initializer syntax.
		@param baseType the base class type of the array (no dimensionality)
		@param dimensions the top number of dimensions of the array 
			e.g. 2 for a String [][];
	*/
    public Object eval( Class baseType, int dimensions, 
						CallStack callstack, Interpreter interpreter ) 
		throws EvalError
    {
        int numInitializers = jjtGetNumChildren();
		// allocate the array to store the initializers
		int [] dima = new int [dimensions]; // description of the array
		// The other dimensions default to zero and are assigned when 
		// the values are set.
		dima[0] = numInitializers;
        Object initializers = 
			Array.newInstance( baseType, dima );
		// Evaluate the initializers
        for (int i = 0; i < numInitializers; i++)
        {
			SimpleNode node = (SimpleNode)jjtGetChild(i);
            Object currentInitializer;
			if ( node instanceof BSHArrayInitializer ) {
				if ( dimensions < 2 )
					throw new EvalError(
						""Invalid Location for Intializer, position: ""+i, this);
            	currentInitializer = 
					((BSHArrayInitializer)node).eval( 
						baseType, dimensions-1, callstack, interpreter);
			} else
            	currentInitializer = node.eval( callstack, interpreter);
			if ( currentInitializer == Primitive.VOID )
				throw new EvalError(
					""Void in array initializer, position""+i, this);
			// unwrap primitive to the wrapper type
			Object value;
			if ( currentInitializer instanceof Primitive )
				value = ((Primitive)currentInitializer).getValue();
			else
				value = currentInitializer;
			// store the value in the array
            try {
				Array.set(initializers, i, value);
            } catch( IllegalArgumentException e ) {
				Interpreter.debug(""illegal arg""+e);
				throwTypeError( baseType, currentInitializer, i );
            } catch( ArrayStoreException e ) { // I think this can happen
				Interpreter.debug(""arraystore""+e);
				throwTypeError( baseType, currentInitializer, i );
            }
        }
        return initializers;
    }
	private void throwTypeError( 
		Class baseType, Object initializer, int argNum ) 
		throws EvalError
	{
		String lhsType = Reflect.normalizeClassName(baseType);
		String rhsType;
		if (initializer instanceof Primitive)
			rhsType = 
				((Primitive)initializer).getType().getName();
		else
			rhsType = Reflect.normalizeClassName(
				initializer.getClass());
		throw new EvalError ( ""Incompatible type: "" + rhsType 
			+"" in initializer of array type: ""+ baseType
			+"" at position: ""+argNum, this );
	}
}
"
bsh.BSHAssignment,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHAssignment extends SimpleNode implements ParserConstants
{
    public int operator;
    BSHAssignment(int id) { super(id); }
    public Object eval(
		CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        BSHLHSPrimaryExpression lhsNode = 
			(BSHLHSPrimaryExpression)jjtGetChild(0);
if ( lhsNode == null )
	throw new InterpreterError( ""Error, null LHSnode"" );
        LHS lhs = lhsNode.toLHS( callstack, interpreter);
        if ( lhs == null )
            throw new InterpreterError( ""Error, null LHS"" );
        Object rhs = ((SimpleNode)jjtGetChild(1)).eval(callstack, interpreter);
        if ( rhs == Primitive.VOID )
            throw new EvalError(""Void assignment."", this);
        switch(operator)
        {
            case ASSIGN:
				try {
					//Interpreter.debug(""lhs assign: ""+rhs);
					return lhs.assign(rhs);
				} catch ( EvalError e ) {
					e.reThrow(this);
				}
            case PLUSASSIGN:
                return lhs.assign(operation(lhs.getValue(), rhs, PLUS));
            case MINUSASSIGN:
                return lhs.assign(operation(lhs.getValue(), rhs, MINUS));
            case STARASSIGN:
                return lhs.assign(operation(lhs.getValue(), rhs, STAR));
            case SLASHASSIGN:
                return lhs.assign(operation(lhs.getValue(), rhs, SLASH));
            case ANDASSIGN:
            case ANDASSIGNX:
                return lhs.assign(operation(lhs.getValue(), rhs, BIT_AND));
            case ORASSIGN:
            case ORASSIGNX:
                return lhs.assign(operation(lhs.getValue(), rhs, BIT_OR));
            case XORASSIGN:
                return lhs.assign(operation(lhs.getValue(), rhs, XOR));
            case MODASSIGN:
                return lhs.assign(operation(lhs.getValue(), rhs, MOD));
            case LSHIFTASSIGN:
            case LSHIFTASSIGNX:
                return lhs.assign(operation(lhs.getValue(), rhs, LSHIFT));
            case RSIGNEDSHIFTASSIGN:
            case RSIGNEDSHIFTASSIGNX:
                return lhs.assign(operation(lhs.getValue(), rhs, RSIGNEDSHIFT));
            case RUNSIGNEDSHIFTASSIGN:
            case RUNSIGNEDSHIFTASSIGNX:
                return lhs.assign(operation(lhs.getValue(), rhs, RUNSIGNEDSHIFT));
            default:
                throw new InterpreterError(""unimplemented operator in assignment BSH"");
        }
    }
    private Object operation(Object lhs, Object rhs, int kind) 
		throws EvalError
    {
		/*
			Implement String += value;
			According to the JLS, value may be anything.
			In BeanShell, we'll disallow VOID (undefined) values.
			(or should we map them to the empty string?)
		*/
		if ( lhs instanceof String && rhs != Primitive.VOID ) {
			if ( kind != PLUS )
				throw new EvalError(
					""Use of non + operator with String LHS"", this);     
			return (String)lhs + rhs;
		}
        if ( lhs instanceof Primitive || rhs instanceof Primitive )
            if(lhs == Primitive.VOID || rhs == Primitive.VOID)
                throw new EvalError(
					""Illegal use of undefined object or 'void' literal"", this);
            else if ( lhs == Primitive.NULL || rhs == Primitive.NULL )
                throw new EvalError(
					""Illegal use of null object or 'null' literal"", this);
        if( (lhs instanceof Boolean || lhs instanceof Character ||
             lhs instanceof Number || lhs instanceof Primitive) &&
            (rhs instanceof Boolean || rhs instanceof Character ||
             rhs instanceof Number || rhs instanceof Primitive) )
        {
            return Primitive.binaryOperation(lhs, rhs, kind);
        }
        throw new EvalError(""Non primitive value in operator: "" +
            lhs.getClass() + "" "" + tokenImage[kind] + "" "" + rhs.getClass(), this);
    }
}
"
bsh.BSHBinaryExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	Implement binary expressions...
	Note: this is too complicated... need some cleanup and simplification.
	@see Primitive.binaryOperation
*/
class BSHBinaryExpression extends SimpleNode 
	implements ParserConstants 
{
    public int kind;
    BSHBinaryExpression(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
        Object lhs = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);
		/*
			Doing instanceof?  Next node is a type.
		*/
        if (kind == INSTANCEOF)
        {
			// null object ref is not instance of any type
			if ( lhs == Primitive.NULL )
				return new Primitive(false);
		/*
			// primitive (number or void) cannot be tested for instanceof
            if (lhs instanceof Primitive)
				throw new EvalError(""Cannot be instance of primitive type."" );
		*/
			// Primitive (number or void) is not an instanceof anything
            if (lhs instanceof Primitive)
				return new Primitive(false);
			// General case - performe the instanceof based on assignability
			NameSpace namespace = callstack.top();
            Class rhs = ((BSHType)jjtGetChild(1)).getType(namespace);
            boolean ret = (Reflect.isAssignableFrom(rhs, lhs.getClass()));
            return new Primitive(ret);
        }
		// The following two boolean checks were tacked on.
		// This could probably be smoothed out.
		/*
			Look ahead and short circuit evaluation of the rhs if:
				we're a boolean AND and the lhs is false.
		*/
		if ( kind == BOOL_AND || kind == BOOL_ANDX ) {
			Object obj = lhs;
			if ( isPrimitiveValue(lhs) )
				obj = ((Primitive)lhs).getValue();
			if ( obj instanceof Boolean && 
				( ((Boolean)obj).booleanValue() == false ) )
				return new Primitive(false);
		}
		/*
			Look ahead and short circuit evaluation of the rhs if:
				we're a boolean AND and the lhs is false.
		*/
		if ( kind == BOOL_OR || kind == BOOL_ORX ) {
			Object obj = lhs;
			if ( isPrimitiveValue(lhs) )
				obj = ((Primitive)lhs).getValue();
			if ( obj instanceof Boolean && 
				( ((Boolean)obj).booleanValue() == true ) )
				return new Primitive(true);
		}
		// end stuff that was tacked on for boolean short-circuiting.
		/*
			Are both the lhs and rhs either wrappers or primitive values?
			do binary op
		*/
		boolean isLhsWrapper = isWrapper( lhs );
        Object rhs = ((SimpleNode)jjtGetChild(1)).eval(callstack, interpreter);
		boolean isRhsWrapper = isWrapper( rhs );
		if ( 
			( isLhsWrapper || isPrimitiveValue( lhs ) )
			&& ( isRhsWrapper || isPrimitiveValue( rhs ) )
		)
        {
			// Special case for EQ on two wrapper objects
			if ( (isLhsWrapper && isRhsWrapper && kind == EQ)) 
			{
				/*  
					Don't auto-unwrap wrappers (preserve identity semantics)
					FALL THROUGH TO OBJECT OPERATIONS BELOW.
				*/
			} else
				try {
					return Primitive.binaryOperation(lhs, rhs, kind);
				} catch ( TargetError e ) {
					// this doesn't really help...  need to catch it higher?
					e.reThrow( this );
				}
        }
		/*
			Do we have a mixture of primitive values and non-primitives ?  
			(primitiveValue = not null, not void)
			god, this is getting ugly...
		*/
	/*
	Removing this restriction for now...
		int primCount = 0;
		if ( isPrimitiveValue( lhs ) )
			++primCount;
		if ( isPrimitiveValue( rhs ) )
			++primCount;
		if ( primCount > 1 )
			// both primitive types, should have been handled above
			throw new InterpreterError(""should not be here"");
		else if ( primCount == 1 )
			// mixture of one and the other
			throw new EvalError( ""Invalid use of primitive and non-primitive""
				+"" values in binary operation."");
		// else fall through to handle both non-primitive types
		// end check for primitive and non-primitive mix 
	*/
		/*
			Treat lhs and rhs as arbitrary objects and do the operation.
			(including NULL and VOID represented by their Primitive types)
		*/
		//System.out.println(""binary op arbitrary obj: {""+lhs+""}, {""+rhs+""}"");
        switch(kind)
        {
            case EQ:
                return new Primitive((lhs == rhs));
            case NE:
                return new Primitive((lhs != rhs));
            case PLUS:
                if(lhs instanceof String || rhs instanceof String)
                    return lhs.toString() + rhs.toString();
            // FALL THROUGH TO DEFAULT CASE!!!
            default:
                if(lhs instanceof Primitive || rhs instanceof Primitive)
                    if(lhs == Primitive.VOID || rhs == Primitive.VOID)
                        throw new EvalError(
		""illegal use of undefined variable, class, or 'void' literal"", this);
                    else 
					if(lhs == Primitive.NULL || rhs == Primitive.NULL)
                        throw new EvalError(
				""illegal use of null value or 'null' literal"", this);
                throw new EvalError(""Operator: '"" + tokenImage[kind] +
                    ""' inappropriate for objects"", this);
        }
    }
	/*
		object is a non-null and non-void Primitive type
	*/
	private boolean isPrimitiveValue( Object obj ) {
        return ( (obj instanceof Primitive) 
			&& (obj != Primitive.VOID) && (obj != Primitive.NULL) );
	}
	/*
		object is a java.lang wrapper for boolean, char, or number type
	*/
	private boolean isWrapper( Object obj ) {
        return ( obj instanceof Boolean || 
			obj instanceof Character || obj instanceof Number );
	}
}
"
bsh.BSHBlock,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHBlock extends SimpleNode
{
	BSHBlock(int id) { super(id); }
	public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		return eval( callstack, interpreter, false );
	}
	/**
		@param overrideNamespace if set to true *no* new BlockNamespace will
		be swapped onto the stack and the eval will happen in the current
		top namespace.  This is used by ForStatement, etc.  which must 
		intialize the block with the for-init and also for those that 
		perform multiple passes in the same block.
	*/
	public Object eval( 
		CallStack callstack, Interpreter interpreter, 
		boolean overrideNamespace ) 
		throws EvalError
	{
		Object ret = Primitive.VOID;
		int statements = jjtGetNumChildren();
		NameSpace enclosingNameSpace = null;
		if ( !overrideNamespace ) 
		{
			enclosingNameSpace= callstack.top();
			BlockNameSpace bodyNameSpace = 
				new BlockNameSpace( enclosingNameSpace );
			callstack.swap( bodyNameSpace );
		}
		for(int i=0; i<statements; i++)
		{
			SimpleNode node = ((SimpleNode)jjtGetChild(i));
			ret = node.eval( callstack, interpreter );
			// some statement or embedded block evaluated a return statement
			if (ret instanceof ReturnControl)
				break;
		}
		if ( !overrideNamespace ) 
			callstack.swap( enclosingNameSpace );
		return ret;
	}
}
"
bsh.BSHCastExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	Implement casts.
	I think it should be possible to simplify some of the code here by
	using the NameSpace.getAssignableForm() method, but I haven't looked 
	into it.
*/
class BSHCastExpression extends SimpleNode {
    public BSHCastExpression(int id) { super(id); }
	/**
		@return the result of the cast.
	*/
	public Object eval(
		CallStack callstack, Interpreter interpreter ) throws EvalError
    {
		NameSpace namespace = callstack.top();
        Class toType = ((BSHType)jjtGetChild(0)).getType(namespace);
		SimpleNode expression = (SimpleNode)jjtGetChild(1);
        // evaluate the expression
        Object fromValue = expression.eval(callstack, interpreter);
        Class fromType = fromValue.getClass();
		try {
			return castObject( fromValue, toType );
		} catch ( EvalError e ) {
			e.reThrow( this );
			throw new InterpreterError(""can't happen""); // help the compiler
		}
    }
	/**
		Cast an object to a new type.
		This method can handle bsh.Primitive types (representing primitive 
		casts) as well as arbitrary object casts.
		@param fromValue an Object or bsh.Primitive primitive value 
		@param toType the class type of the cast result, which may include
		primitive types, e.g. Byte.TYPE
	*/
	public static Object castObject( Object fromValue, Class toType )
		throws EvalError
	{
        Class fromType = fromValue.getClass();
		// The compiler isn't smart enough to allow me to leave this unassigned
		// even though it is clearly assigned in all cases below.
        Object result = null;
		// Going to a primitive type
        if ( toType.isPrimitive() ) 
			if ( fromValue instanceof Primitive )
				result = castPrimitive( (Primitive)fromValue, toType );
			else
				// cannot convert from object to primitive
                castError(fromValue.getClass(), toType);
        else 
			// Going to an object type
			if ( fromValue instanceof Primitive )
				// let castPrimitive handle trivial but legit case of NULL
				result = castPrimitive( (Primitive)fromValue, toType );
			else
				// Can we use the proxy mechanism to cast a bsh.This to 
				// the correct interface?
				if ( Capabilities.canGenerateInterfaces() &&
					(fromValue instanceof bsh.This) && toType.isInterface() ) 
						result = ((bsh.This)fromValue).getInterface( toType );
				else 
					// Could probably add getAssignableForm here to allow 
					// special bsh widening converions... wrappers to wrappers
					if ( toType.isInstance(fromValue ) )
						result = fromValue;
					else
						castError(fromType, toType);
		if ( result == null )
			throw new InternalError(""bad construct somewhere..."");
		return result;
	}
	/**
		Wrap up the ClassCastException in a TargetError so that it can
		be caught...
		Node user should catch and add the node
	*/
    public static void castError(Class from, Class to) throws EvalError {
		castError( 
			Reflect.normalizeClassName(from), Reflect.normalizeClassName(to) );
    }
    public static void castError(String from, String to) throws EvalError 
	{
		Exception cce = new ClassCastException(""Illegal cast. Cannot cast "" +
            from + "" to "" + to );
		throw new TargetError( ""Cast"", cce );
    }
	/**
		Cast the bsh.Primitive value to a new bsh.Primitive value
		This is usually a numeric type cast.  Other cases include:
			boolean can be cast to boolen
			null can be cast to any object type
			void cannot be cast to anything
	*/
	public static Primitive castPrimitive( Primitive primValue, Class toType ) 
		throws EvalError
	{
		// can't cast void to anything
		if ( primValue == Primitive.VOID )
			castError( ""void value"", Reflect.normalizeClassName(toType) );
		// unwrap, etc.
		Object value = primValue.getValue();
		Class fromType = primValue.getType();
		// Trying to cast primitive to an object type?
		// only works for Primitive.NULL
		if ( !toType.isPrimitive() )
			if ( primValue != Primitive.NULL )
				castError(""primitive value"", ""object type:"" + toType);
			else
				return primValue;
		// can only cast boolean to boolean
		if ( fromType == Boolean.TYPE )
		{
			if ( toType != Boolean.TYPE )
				castError(fromType, toType);
			else 
				return primValue;
		}
		// trying to do numeric promotion
		// first promote char to Number type to avoid duplicating code
		if (value instanceof Character)
			value = new Integer(((Character)value).charValue());
		if (value instanceof Number)
		{
			Number number = (Number)value;
			if (toType == Byte.TYPE)
				value = new Primitive(number.byteValue());
			else if(toType == Short.TYPE)
				value = new Primitive(number.shortValue());
			else if(toType == Character.TYPE)
				value = new Primitive((char)number.intValue());
			else if(toType == Integer.TYPE)
				value = new Primitive(number.intValue());
			else if(toType == Long.TYPE)
				value = new Primitive(number.longValue());
			else if(toType == Float.TYPE)
				value = new Primitive(number.floatValue());
			else if(toType == Double.TYPE)
				value = new Primitive(number.doubleValue());
			else
				castError(fromType, toType);
			return (Primitive)value;
		} 
		throw new EvalError(""unknown type in cast"");
	}
}
"
bsh.BshClassManager,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.net.*;
import java.util.*;
import java.io.IOException;
import java.io.*;
/**
	BshClassManager manages all classloading in BeanShell.
	It also supports a dynamically loaded extension (bsh.classpath package)
	which allows classpath extension and class file reloading.
	Currently the extension relies on 1.2 for BshClassLoader and weak 
	references.  
	See http://www.beanshell.org/manual/classloading.html for details
	on the bsh classloader architecture.
	<p>
	Bsh has a multi-tiered class loading architecture.  No class loader is
	used unless/until the classpath is modified or a class is reloaded.
	<p>
	Note: currently class loading features affect all instances of the
	Interpreter.  However the basic design of this class will allow for
	per instance class management in the future if it is desired.
*/
/*
	Implementation notes:
	Note: we may need some synchronization in here
	Note on jdk1.2 dependency:
	<p>
	We are forced to use weak references here to accomodate all of the 
	fleeting namespace listeners as they fall out of scope.  (NameSpaces must 
	be informed if the class space changes so that they can un-cache names).  
	I had the thought that a way around this would be to implement BeanShell's 
	own garbage collector...  Then I came to my senses.
	<p>
	Perhaps a simpler idea would be to have entities that reference cached
	types always perform a light weight check with a counter / reference
	value and use that to detect changes in the namespace.  This puts the 
	burden on the consumer to check at appropriate times, but could eliminate
	the need for the listener system in many places and the necessity of weak 
	references in this package.
	<p>
*/
public abstract class BshClassManager
{
	/** Singleton class manager */
	private static BshClassManager manager;
	private static boolean checkedForManager;
	// Use a hashtable as a Set...
	private static Object NOVALUE = new Object(); 
	/**
		An external classloader supplied by the setClassLoader() command.
	*/
	private static ClassLoader externalClassLoader;
	/**
		Global cache for things we know are classes.
		Note: these should probably be re-implemented with Soft references.
		(as opposed to strong or Weak)
	*/
    protected transient static Hashtable absoluteClassCache = new Hashtable();
	/**
		Global cache for things we know are *not* classes.
		Note: these should probably be re-implemented with Soft references.
		(as opposed to strong or Weak)
	*/
    protected transient static Hashtable absoluteNonClasses = new Hashtable();
	// Begin static methods
	/**
		@return the BshClassManager singleton or null, indicating no
		class manager is available.
	*/
// Note: this should probably throw Capabilities.Unavailable instead of
// returning null
	public static BshClassManager getClassManager() 
	{
		// Bootstrap the class manager if it exists
		// have we loaded it before?
		if ( !checkedForManager && manager == null )
			// Do we have the necessary jdk1.2 packages?
			try {
				if ( plainClassForName(""java.lang.ref.WeakReference"") != null
					&& plainClassForName(""java.util.HashMap"")  != null )
				{
					// try to load the implementation
					Class bcm = plainClassForName(
						""bsh.classpath.ClassManagerImpl"");
					manager = (BshClassManager)bcm.newInstance();
				}
			} catch ( ClassNotFoundException e ) {
				//System.err.println(""No class manager available."");
			} catch ( Exception e ) {
				System.err.println(""Error loading classmanager: ""+e);
			}
		checkedForManager = true;
		return manager;
	}
	public static boolean classExists( String name ) {
		return ( classForName( name ) != null );
	}
	/**
		Load the specified class by name, taking into account added classpath
		and reloaded classes, etc.
		@return the class or null
	*/
	public static Class classForName( String name ) {
		BshClassManager manager = getClassManager(); // prime the singleton
		if ( manager != null )
			return manager.getClassForName( name );
		else
			try {
				return plainClassForName( name );
			} catch ( ClassNotFoundException e ) {
				return null;
			}
	}
	/**
		Perform a plain Class.forName() 
		This simply wraps that method call and provides a central point for
		monitoring and handling certain Java version dependent bugs, etc.
		Note: this used to be called loadSystemClass()
		@return the class
	*/
	public static Class plainClassForName( String name ) 
		throws ClassNotFoundException 
	{
		try {
			Class c;
			if ( externalClassLoader != null ) {
				c = externalClassLoader.loadClass( name );
			}else
				c = Class.forName(name);
			cacheClassInfo( name, c );
			return c;
		/*
			This is weird... jdk under Win is throwing these to
			warn about lower case / upper case possible mismatch.
			e.g. bsh.console bsh.Console
		*/
		} catch ( NoClassDefFoundError e ) {
			cacheClassInfo( name, null ); // non-class
			throw new ClassNotFoundException( e.toString() );
		}
	}
	/**
		Cache info about whether name is a class or not.
		@param value 
			if value is non-null, cache the class
			if value is null, set the flag that it is *not* a class to
			speed later resolution
	*/
	public static void cacheClassInfo( String name, Class value ) {
		if ( value != null )
			absoluteClassCache.put( name, value );
		else
			absoluteNonClasses.put( name, NOVALUE );
	}
	/**
		Clear the static caches in BshClassManager
	*/
	protected void clearCaches() {
    	absoluteNonClasses = new Hashtable();
    	absoluteClassCache = new Hashtable();
	}
	/**
		Add a BshClassManager.Listener to the class manager.
		The listener is informed upon changes to the classpath.
		This is a static convenience form of BshClassManager addListener().
		If there is no class manager the listener will be ignored.
	*/
	public static void addCMListener( Listener l ) {
		getClassManager(); // prime it
		if ( manager != null )
			manager.addListener( l );
	}
	/**
		Set an external class loader.  BeanShell will use this at the same 
		point it would otherwise use the plain Class.forName().
		i.e. if no explicit classpath management is done from the script
		(addClassPath(), setClassPath(), reloadClasses()) then BeanShell will
		only use the supplied classloader.  If additional classpath management
		is done then BeanShell will perform that in addition to the supplied
		external classloader.
		However BeanShell is not currently able to reload
		classes supplied through the external classloader.
	*/
	public static void setClassLoader( ClassLoader externalCL ) 
	{
		externalClassLoader = externalCL;
		//getClassManager().classLoaderChanged();
	}
	// end static methods
	public static interface Listener 
	{
		public void classLoaderChanged();
	}
	// Begin interface methods
	public abstract Class getClassForName( String name );
	public abstract ClassLoader getBaseLoader();
	public abstract ClassLoader getLoaderForClass( String name );
	public abstract void addClassPath( URL path )
		throws IOException;
	/**
		Clear all loaders and start over.  No class loading.
	*/
	public abstract void reset();
	/**
		Set a new base classpath and create a new base classloader.
		This means all types change. 
	*/
	public abstract void setClassPath( URL [] cp );
	/**
		Overlay the entire path with a new class loader.
		Set the base path to the user path + base path.
		No point in including the boot class path (can't reload thos).
	*/
	public abstract void reloadAllClasses() throws ClassPathException;
	/**
		Reloading classes means creating a new classloader and using it
		whenever we are asked for classes in the appropriate space.
		For this we use a DiscreteFilesClassLoader
	*/
	public abstract void reloadClasses( String [] classNames )
		throws ClassPathException;
	/**
		Reload all classes in the specified package: e.g. ""com.sun.tools""
		The special package name ""<unpackaged>"" can be used to refer 
		to unpackaged classes.
	*/
	public abstract void reloadPackage( String pack ) 
		throws ClassPathException ;
	/**
		This has been removed from the interface to shield the core from the
		rest of the classpath package. If you need the classpath you will have
		to cast the classmanager to its impl.
		public abstract BshClassPath getClassPath() throws ClassPathException;
	*/
	/**
		Support for ""import *;""
		Hide details in here as opposed to NameSpace.
	Note: this used to be package private...
	*/
	public abstract void doSuperImport() throws EvalError;
	/**
		Return the name or null if none is found,
		Throw an ClassPathException containing detail if name is ambigous.
	Note: this used to be package private...
	*/
	public abstract String getClassNameByUnqName( String name ) 
		throws ClassPathException;
	public abstract void addListener( Listener l );
	public abstract void removeListener( Listener l );
	public abstract void dump( PrintWriter pw );
	protected abstract void classLoaderChanged();
}
"
bsh.BSHFormalParameter,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	A formal parameter declaration.
	For loose variable declaration type is null.
*/
class BSHFormalParameter extends SimpleNode
{
	public static final Class UNTYPED = null;
	public String name;
	public Class type;
	BSHFormalParameter(int id) { super(id); }
	/**
		Evaluate the type.  Note that type resolution does not require 
		the interpreter instance.
	*/
	public Object eval( NameSpace namespace )  
		throws EvalError
	{
		if(jjtGetNumChildren() > 0)
			type = ((BSHType)jjtGetChild(0)).getType(namespace);
		else
			type = UNTYPED;
		return Primitive.VOID;
	}
}
"
bsh.BSHFormalParameters,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	For loose type parameters the argTypes are null.
*/
class BSHFormalParameters extends SimpleNode
{
	int numArgs;
// I'm not sure doing this is thread safe...
//Will we be hit by different threads...  I think the namespace is the declaring
//one... so it would be the same...
// caching of the method structure happens in BshMethod, so it's not necessary
//here...
	String[] argNames;
	Class[] argTypes;
	BSHFormalParameters(int id) { super(id); }
	/**
		Evaluate the types.  
		Note that type resolution does not require the interpreter instance.
	*/
	public Object eval( NameSpace namespace )  
		throws EvalError
	{
		numArgs = jjtGetNumChildren();
		argNames = new String[numArgs];
		argTypes = new Class[numArgs];
		for(int i=0; i<numArgs; i++)
		{
			BSHFormalParameter param = (BSHFormalParameter)jjtGetChild(i);
			param.eval( namespace );
			argNames[i] = param.name;
			argTypes[i] = param.type;
		}
		return Primitive.VOID;
	}
}
"
bsh.BSHForStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	Implementation of the for(;;) statement.
*/
class BSHForStatement extends SimpleNode implements ParserConstants
{
    public boolean hasForInit;
    public boolean hasExpression;
    public boolean hasForUpdate;
    private SimpleNode forInit;
    private SimpleNode expression;
    private SimpleNode forUpdate;
    private SimpleNode statement;
    private boolean parsed;
    BSHForStatement(int id) { super(id); }
    public Object eval(CallStack callstack , Interpreter interpreter)  
		throws EvalError
    {
        int i = 0;
        if(hasForInit)
            forInit = ((SimpleNode)jjtGetChild(i++));
        if(hasExpression)
            expression = ((SimpleNode)jjtGetChild(i++));
        if(hasForUpdate)
            forUpdate = ((SimpleNode)jjtGetChild(i++));
        if(i < jjtGetNumChildren()) // should normally be
            statement = ((SimpleNode)jjtGetChild(i));
		NameSpace enclosingNameSpace= callstack.top();
		BlockNameSpace forNameSpace = new BlockNameSpace( enclosingNameSpace );
		/*
			Note: some interesting things are going on here.
			1) We swap instead of push...  The primary mode of operation acts 
			like we are in the enclosing namespace...  (super must be 
			preserved, etc.)
			2) We do *not* call the body block eval with the namespace override
			We allow it to create a second subordinate BlockNameSpace child
			of the forNameSpace.  Variable propogation still works through
			the chain, but the block's child cleans the state between iteration.
			(which is correct Java behavior... see forscope4.bsh)
		*/
		callstack.swap( forNameSpace );
		// Note: it's important that there is only one exit point from this
		// method so that we can swap back the namespace.
        // Do the for init
        if ( hasForInit ) 
            forInit.eval( callstack, interpreter );
		Object returnControl = Primitive.VOID;
        while(true)
        {
            if ( hasExpression ) 
			{
				boolean cond = BSHIfStatement.evaluateCondition(
					expression, callstack, interpreter );
				if ( !cond ) 
					break;
			}
            boolean breakout = false; // switch eats a multi-level break here?
            if ( statement != null ) // not empty statement
            {
				// do *not* invoke special override for block... (see above)
                Object ret = statement.eval( callstack, interpreter );
                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case RETURN:
							returnControl = ret;
							breakout = true;
                            break;
                        case CONTINUE:
                            break;
                        case BREAK:
                            breakout = true;
                            break;
                    }
                }
            }
            if ( breakout )
                break;
            if ( hasForUpdate )
                forUpdate.eval( callstack, interpreter );
        }
		callstack.swap( enclosingNameSpace );  // put it back
        return returnControl;
    }
}
"
bsh.BSHIfStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHIfStatement extends SimpleNode
{
    BSHIfStatement(int id) { super(id); }
    public Object eval(CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
        Object ret = null;
        if( evaluateCondition( 
			(SimpleNode)jjtGetChild(0), callstack, interpreter ) )
            ret = ((SimpleNode)jjtGetChild(1)).eval(callstack, interpreter);
        else
            if(jjtGetNumChildren() > 2)
                ret = ((SimpleNode)jjtGetChild(2)).eval(callstack, interpreter);
        if(ret instanceof ReturnControl)
            return ret;
        else    
            return Primitive.VOID;
    }
    public static boolean evaluateCondition(
		SimpleNode condExp, CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        Object obj = condExp.eval(callstack, interpreter);
        if(obj instanceof Primitive) {
			if ( obj == Primitive.VOID )
				throw new EvalError(""Condition evaluates to void type"", condExp );
            obj = ((Primitive)obj).getValue();
		}
        if(obj instanceof Boolean)
            return ((Boolean)obj).booleanValue();
        else
            throw new EvalError(
				""Condition must evaluate to a Boolean or boolean."", condExp );
    }
}
"
bsh.BSHImportDeclaration,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHImportDeclaration extends SimpleNode
{
	public boolean importPackage;
	public boolean superImport;
	BSHImportDeclaration(int id) { super(id); }
	public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		if ( superImport )
			NameSpace.doSuperImport();
		else {
			NameSpace namespace = callstack.top();
			String name = 
				((BSHAmbiguousName)jjtGetChild(0)).getName(namespace).value;
			if ( importPackage )
				namespace.importPackage(name);
			else
				namespace.importClass(name);
		}
        return Primitive.VOID;
	}
}
"
bsh.BSHLHSPrimaryExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHLHSPrimaryExpression extends SimpleNode
{
	BSHLHSPrimaryExpression(int id) { super(id); }
	public LHS toLHS(CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		/*
			Get the prefix, which may be either an ambiguous name or a
			method invocation.  
			The method invocation bit here is somewhat of a hack to handle 
			the fact that we have moved prefix method invocation into the 
			PrimaryPrefix in order to get it to always produce an object type.
			This is too complicated.
		*/
		int childNum = 0;
		SimpleNode prefixNode = (SimpleNode)jjtGetChild(childNum++);
		Object prefixValue = null;
		LHS lhs = null;
		if ( prefixNode instanceof BSHAmbiguousName )   {
			lhs = ((BSHAmbiguousName)prefixNode).toLHS( callstack, interpreter);
//System.err.println(""lhs is ambig name (""+prefixNode+"")= ""+lhs);
		} else
			// Currently the only case is for BSHMethodInvocation
			prefixValue = 
				((SimpleNode)prefixNode).eval( callstack, interpreter);
		// If the prefix is an object and not an LHS it requires at least
		// one suffix to make an LHS
		// Currently the only case is for BSHMethodInvocation
		if ( prefixValue != null )
			lhs = ((BSHLHSPrimarySuffix)jjtGetChild(childNum++)).doLHSSuffix(
				prefixValue, callstack, interpreter);
		// Apply the suffixes
		int numChildren = jjtGetNumChildren(); 
		while( childNum<numChildren ) 
			lhs = ((BSHLHSPrimarySuffix)jjtGetChild(childNum++)).doLHSSuffix(
				lhs.getValue(), callstack, interpreter);
		return lhs;
	}
}
"
bsh.BSHLHSPrimarySuffix,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
/*
	Warning: this is a hack... should be unified with BSHPrimarySuffix
*/
package bsh;
import java.util.Hashtable;
import java.lang.reflect.InvocationTargetException;
class BSHLHSPrimarySuffix extends SimpleNode
{
	public static final int
		INDEX = 1,
		NAME = 2,
		PROPERTY = 3;
	public int operation;	// field access or index
	Object index;			// the index value if any
	/*
		If this is a simple field access field is the field
		If we're hopscotching a method to a field, method is the
		method name and field is the field of the resulting object
	*/
	public String field;
	public String method;
	BSHLHSPrimarySuffix(int id) { super(id); }
	public LHS doLHSSuffix(
		Object obj, CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		try
		{
			switch(operation)
			{
				case INDEX:
					return doIndex(obj, callstack, interpreter);
				case NAME:
					return doName(obj, callstack, interpreter);
				case PROPERTY:
					return doProperty(obj, callstack, interpreter);
				default:
					throw new InterpreterError(""LHS suffix"");
			}
		}
		catch(ReflectError e)
		{
			throw new EvalError(""reflection error: "" + e, this);
		}
		catch(InvocationTargetException e)
		{
			throw new TargetError(e.getTargetException(), this);
		}
	}
	private LHS doName(
		Object obj, CallStack callstack, Interpreter interpreter) 
		throws EvalError, ReflectError, InvocationTargetException 
	{
		if (jjtGetNumChildren() == 0)
			// simple field access
			return Reflect.getLHSObjectField(obj, field);
		else {
			// intermediate method invocation, and field access
			Object[] oa = ((BSHArguments)jjtGetChild(0)).getArguments(
				callstack, interpreter);
			try {
				obj = Reflect.invokeObjectMethod(interpreter, obj, method, oa, this);
			} catch ( EvalError ee ) {
				// catch and re-throw to get line number right
				throw new EvalError( ee.getMessage(), this );
			}
			return Reflect.getLHSObjectField(obj, field);
		}
	}
	private LHS doIndex(
		Object obj, CallStack callstack, Interpreter interpreter) 
		throws EvalError, ReflectError
	{
		if(!obj.getClass().isArray())
			throw new EvalError(""Not an array"", this);
		int index;
		try
		{
			Primitive val = (Primitive)(((SimpleNode)jjtGetChild(0)).eval(
				callstack, interpreter));
			index = val.intValue();
		}
		catch(Exception e)
		{
			throw new EvalError(""You can only index arrays by integer types"", this);
		}
		return new LHS(obj, index);
	}
	private LHS doProperty(
		Object obj, CallStack callstack, Interpreter interpreter) 
		throws EvalError, ReflectError
	{
		if(obj == Primitive.VOID)
			throw new EvalError(""Attempt to access property on a void type"", this);
		else if(obj instanceof Primitive)
			throw new EvalError(""Attempt to access property on a primitive"", this);
		Object value = ((SimpleNode)jjtGetChild(0)).eval(
			callstack, interpreter);
		if(!(value instanceof String))
			throw new EvalError(""Property expression must be a String or identifier."", this);
		Interpreter.debug(""LHS property access: "");
		return new LHS(obj, (String)value);
	}
}
"
bsh.BSHLiteral,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHLiteral extends SimpleNode
{
    public Object value;
    BSHLiteral(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
    {
		if ( value == null )
			throw new InterpreterError(""Null in bsh literal: ""+value);
        return value;
    }
    private char getEscapeChar(char ch)
    {
        switch(ch)
        {
            case 'b':
                ch = '\b';
                break;
            case 't':
                ch = '\t';
                break;
            case 'n':
                ch = '\n';
                break;
            case 'f':
                ch = '\f';
                break;
            case 'r':
                ch = '\r';
                break;
            // do nothing - ch already contains correct character
            case '""':
            case '\'':
            case '\\':
                break;
        }
        return ch;
    }
    public void charSetup(String str)
    {
        char ch = str.charAt(0);
        if(ch == '\\')
        {
            // get next character
            ch = str.charAt(1);
            if(Character.isDigit(ch))
                ch = (char)Integer.parseInt(str.substring(1), 8);
            else
                ch = getEscapeChar(ch);
        }
        value = new Primitive(new Character(ch));
    }
    void stringSetup(String str)
    {
        StringBuffer buffer = new StringBuffer();
        for(int i = 0; i < str.length(); i++)
        {
            char ch = str.charAt(i);
            if(ch == '\\')
            {
                // get next character
                ch = str.charAt(++i);
                if(Character.isDigit(ch))
                {
                    int endPos = i;
                    // check the next two characters
                    while(endPos < i + 2)
                    {
                        if(Character.isDigit(str.charAt(endPos + 1)))
                            endPos++;
                        else
                            break;
                    }
                    ch = (char)Integer.parseInt(str.substring(i, endPos + 1), 8);
                    i = endPos;
                }
                else
                    ch = getEscapeChar(ch);
            }
            buffer.append(ch);
        }
        value = buffer.toString();
    }
}
"
bsh.BshMethod,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	This represents an *instance* of a bsh method declaration in a particular
	namespace.  This is a thin wrapper around the BSHMethodDeclaration
	with a pointer to the declaring namespace.
	The issue is that when a method is located in a subordinate namespace or
	invoked from an arbitrary namespace it must nontheless execute with its
	'super' as the context in which it was declared.
	i.e.
	The local method context is a child namespace of the declaring namespace.
*/
class BshMethod implements java.io.Serializable 
{
	public BSHMethodDeclaration method;
	/* 
		I believe this is always the namespace in which the method is
		defined...  It is a back-reference for the node, which needs to
		execute under this namespace.
		So it is not necessary to declare this transient, because we can
		only be saved as part of our namespace anyway... (currently).
	*/
	NameSpace declaringNameSpace;
	private Class [] argTypes;
	public BshMethod( 
		BSHMethodDeclaration method, NameSpace declaringNameSpace ) 
	{
		this.method = method;
		this.declaringNameSpace = declaringNameSpace;
	}
	/**
		Note: bshmethod needs to re-evaluate arg types here
		This is broken
	*/
	public Class [] getArgTypes() {
		if ( argTypes == null )
			// should re-eval here...
			argTypes = method.params.argTypes ;
		return argTypes;
	}
	/**
		Invoke the bsh method with the specified args, interpreter ref,
		and callstack.
		callerInfo is the node representing the method invocation
		It is used primarily for debugging in order to provide access to the 
		text of the construct that invoked the method through the namespace.
		@param callerInfo is the node representing the method invocation
			This is used primarily for debugging and may be null.
		@param callstack is the callstack of course.  If you are using a 
		hacked version of BeanShell that exposed this method take a look
		at NameSpace invokeMethod to see how to make a fake callstack...
	*/
	public Object invokeDeclaredMethod( 
		Object[] argValues, Interpreter interpreter, CallStack callstack,
			SimpleNode callerInfo ) 
		throws EvalError 
	{
		if ( argValues == null )
			argValues = new Object [] { };
		// Cardinality (number of args) mismatch
		if ( argValues.length != method.params.numArgs ) {
			// look for help string
			try {
				// should check for null namespace here
				String help = 
					(String)declaringNameSpace.get(
					""bsh.help.""+method.name, interpreter );
				interpreter.println(help);
				return Primitive.VOID;
			} catch ( Exception e ) {
				throw new EvalError( 
					""Wrong number of arguments for local method: "" 
					+ method.name, callerInfo);
			}
		}
		// Make the local namespace for the method invocation
		NameSpace localNameSpace = new NameSpace( 
			declaringNameSpace, method.name );
		localNameSpace.setNode( callerInfo );
		// set the method parameters in the local namespace
		for(int i=0; i<method.params.numArgs; i++)
		{
			// Set typed variable
			if ( method.params.argTypes[i] != null ) 
			{
				try {
					argValues[i] = NameSpace.getAssignableForm(argValues[i],
					    method.params.argTypes[i]);
				}
				catch(EvalError e) {
					throw new EvalError(
						""Invalid argument: "" 
						+ ""`""+method.params.argNames[i]+""'"" + "" for method: "" 
						+ method.name + "" : "" + 
						e.getMessage(), callerInfo);
				}
				localNameSpace.setTypedVariable( method.params.argNames[i], 
					method.params.argTypes[i], argValues[i], false);
			} 
			// Set untyped variable
			else  // untyped param
			{
				// checkAssignable would catch this for typed param
				if ( argValues[i] == Primitive.VOID)
					throw new EvalError(
						""Undefined variable or class name, parameter: "" +
						method.params.argNames[i] + "" to method: "" 
						+ method.name, callerInfo);
				else
					localNameSpace.setVariable(
						method.params.argNames[i], argValues[i]);
			}
		}
		// Push the new namespace on the call stack
		callstack.push( localNameSpace );
		// Invoke the method
		Object ret = method.block.eval( callstack, interpreter, true );
		// pop back to caller namespace
		callstack.pop();
		if ( ret instanceof ReturnControl )
		{
			ReturnControl rs = (ReturnControl)ret;
			if(rs.kind == rs.RETURN)
				ret = ((ReturnControl)ret).value;
			else 
				// This error points to the method, should it?
				throw new EvalError(""continue or break in method body"", method);
		}
		// there should be a check in here for an explicit value return 
		// from a void type method... (throw evalerror)
		if(method.returnType != null)
		{
			// if void return type throw away any value
			// ideally, we'd error on an explicit 'return' of value
			if(method.returnType == Primitive.VOID)
				return method.returnType;
			// return type is a class
			try {
				ret = NameSpace.getAssignableForm(
					ret, (Class)method.returnType);
			}
			catch(EvalError e) {
				// This error points to the method, should it?
				throw new EvalError(
					""Incorrect type returned from method: "" 
					+ method.name + e.getMessage(), method);
			}
		}
		return ret;
	}
	public String toString() {
		return ""Bsh Method: ""+method.name;
	}
}
"
bsh.BSHMethodDeclaration,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Vector;
/*
	This shouldn't have to be public.	
	We should add to bsh.This allowing us to invoke a method.
	If we do that we should probably use it in Reflect.java
	Note: caching of the structure is done in BshMethod
	no caching need be done here or in formal param, etc.
*/
class BSHMethodDeclaration extends SimpleNode
{
	String name;
	BSHFormalParameters params;
	BSHBlock block;
	Object returnType; 	// null (none), Primitive.VOID, or a Class
	BSHMethodDeclaration(int id)
	{
		super(id);
	}
	/**
		Evaluate the declaration of the method.  That is, determine the
		structure of the method and install it into the caller's namespace.
		Since the structure of the method is only determined by type evaluation
		(through eval of BSHFormalParameters) we do not need the interpreter 
		or callstack.
	*/
	public Object eval( NameSpace namespace )  
		throws EvalError
	{
		if ( block == null ) 
		{
			// We will allow methods to be re-written.
			/*  
			if( namespace has method )
				throw new EvalError(
				""Method: "" + name + "" already defined in scope"", this);
			*/
			if(jjtGetNumChildren() == 3)
			{
				returnType = 
					((BSHReturnType)jjtGetChild(0)).getReturnType( namespace );
				params = (BSHFormalParameters)jjtGetChild(1);
				block = (BSHBlock)jjtGetChild(2);
			}
			else
			{
				params = (BSHFormalParameters)jjtGetChild(0);
				block = (BSHBlock)jjtGetChild(1);
			}
			params.eval( namespace );
			// if strictJava mode, check for loose parameters and return type
			if ( Interpreter.strictJava )
			{
				for(int i=0; i<params.argTypes.length; i++)
					if ( params.argTypes[i] == null )
						throw new EvalError(
					""(Strict Java Mode) Undeclared argument type, parameter: "" +
						params.argNames[i] + "" in method: "" 
						+ name, this );
				if ( returnType == null )
					throw new EvalError(
					""(Strict Java Mode) Undeclared return type for method: ""
						+ name, this );
			}
		}
		// Install an *instance* of this method in the namespace.
		// See notes in BshMethod 
// This is not good...
// need a way to update eval without re-installing...
// so that we can re-eval params, etc. when classloader changes
// look into this
		namespace.setMethod( name, new BshMethod( this, namespace ) );
		return Primitive.VOID;
	}
	public String toString() {
		return ""MethodDeclaration: ""+name;
	}
}
"
bsh.BSHMethodInvocation,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHMethodInvocation extends SimpleNode
{
	BSHMethodInvocation (int id) { super(id); }
	/**
		Evaluate the method invocation with the specified callstack and 
		interpreter
	*/
	public Object eval( CallStack callstack, Interpreter interpreter)
		throws EvalError
	{
		NameSpace namespace = callstack.top();
		Name name = ((BSHAmbiguousName)jjtGetChild(0)).getName(namespace);
		Object[] args = 
			((BSHArguments)jjtGetChild(1)).getArguments(callstack, interpreter);
		try {
			return name.invokeMethod(interpreter, args, callstack, this);
		} catch (ReflectError e) {
			throw new EvalError(
				""Error in method invocation: "" + e.getMessage(), this);
		} catch (java.lang.reflect.InvocationTargetException e) {
			throw new TargetError(e.getTargetException(), this);
		} catch ( EvalError ee ) {
			ee.reThrow( this );
			throw new Error(""should be unreachable..."");
		}
	}
}
"
bsh.BSHPrimaryExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHPrimaryExpression extends SimpleNode
{
	BSHPrimaryExpression(int id) { super(id); }
	/*
		Should contain a prefix expression and any number of suffixes.
		We don't eval( ) any nodes until the suffixes have had an
		opportunity to work through them.  This let's the suffixes decide
		how to interpret an ambiguous name (e.g. for the .class operation).
	*/
	public Object eval(CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		Object obj = jjtGetChild(0);
		int n = jjtGetNumChildren(); 
		for(int i=1; i<n; i++)
			obj = ((BSHPrimarySuffix)jjtGetChild(i)).doSuffix(
				obj, callstack, interpreter);
		/*
			eval the node to an object
			Note: This construct is now necessary where the node may be
			an ambiguous name.  If this becomes common we might want to 
			make a static method nodeToObject() or something.
		*/
		if ( obj instanceof SimpleNode )
			if ( obj instanceof BSHAmbiguousName )
				obj = ((BSHAmbiguousName)obj).toObject(callstack, interpreter);
			else
				obj = ((SimpleNode)obj).eval(callstack, interpreter);	
		return obj;
	}
}
"
bsh.BSHPrimarySuffix,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
/*
	Warning: this is a hack... should be unified with BSHLHSPrimarySuffix
*/
package bsh;
import java.util.Hashtable;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
class BSHPrimarySuffix extends SimpleNode
{
	public static final int
		CLASS = 0,
		INDEX = 1,
		NAME = 2,
		PROPERTY = 3;
	public int operation;
	Object index;
	public String field;
	BSHPrimarySuffix(int id) { super(id); }
	/*
		Perform a suffix operation on the given object and return the 
		new value.
		obj will be a Node when suffix evaluation begins, allowing us to
		interpret it contextually. (e.g. for .class) Thereafter it will be 
		a normal object.
	*/
	public Object doSuffix(
		Object obj, CallStack callstack, Interpreter interpreter) 
		throws EvalError
	{
		// Handle "".class"" suffix operation
		/*
		if ( operation == CLASS )
			if ( obj instanceof BSHAmbiguousName ) {
				NameSpace namespace = callstack.top();
				return ((BSHAmbiguousName)obj).toClass( namespace );
			} else
				throw new EvalError(
					""Attemp to .class on non class..."", this);
		*/
		if ( operation == CLASS )
			if ( obj instanceof BSHType ) {
				NameSpace namespace = callstack.top();
				return ((BSHType)obj).getType( namespace );
			} else
				throw new EvalError(
					""Attemp to invoke .class on non class."", this);
		// Handle other suffix operations
		/*
			eval( ) the node to an object
			Note: This construct is now necessary where the node may be
			an ambiguous name.  If this becomes common we might want to 
			make a static method nodeToObject() or something.
		*/
		if ( obj instanceof SimpleNode )
			if ( obj instanceof BSHAmbiguousName )
				obj = ((BSHAmbiguousName)obj).toObject(callstack, interpreter);
			else
				obj = ((SimpleNode)obj).eval(callstack, interpreter);	
		try
		{
			switch(operation)
			{
				case INDEX:
					return doIndex(obj, callstack, interpreter );
				case NAME:
					return doName(obj, callstack, interpreter );
				case PROPERTY:
					return doProperty(obj, callstack, interpreter );
				default:
					throw new InterpreterError(""LHS suffix"");
			} 
		}
		catch(ReflectError e)
		{
			throw new EvalError(""reflection error: "" + e, this);
		}
		catch(InvocationTargetException e)
		{
			throw new TargetError(e.getTargetException(), this);
		}
	}
	/*
		Field access or a method invocation
		Field access might be .length on an array
	*/
	private Object doName(
		Object obj, CallStack callstack, Interpreter interpreter) 
		throws EvalError, ReflectError, InvocationTargetException
	{
		if(field.equals(""length"") && obj.getClass().isArray())
			return new Primitive(Array.getLength(obj));
		if (jjtGetNumChildren() == 0)
			// field access
			return Reflect.getObjectField(obj, field);
		else
		{
			// method invocation
			Object[] oa = ((BSHArguments)jjtGetChild(0)).getArguments(
				callstack, interpreter);
			try {
				return Reflect.invokeObjectMethod(interpreter, obj, field, oa, this);
			} catch ( EvalError ee ) {
				// catch and re-throw to get line number right
				throw new EvalError( ee.getMessage(), this );
			}
		}
	}
	private Object doIndex(
		Object obj, CallStack callstack, Interpreter interpreter) 
		throws EvalError, ReflectError
	{
		if(!obj.getClass().isArray())
			throw new EvalError(""Not an array"", this);
		int index;
		try
		{
			Primitive val = (Primitive)(((SimpleNode)jjtGetChild(0)).eval(
				callstack, interpreter ));
			index = val.intValue();
		}
		catch(Exception e)
		{
			throw new EvalError(""You can only index arrays by integer types"", this);
		}
		return Reflect.getIndex(obj, index);
	}
	private Object doProperty( 
		Object obj, CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		if(obj == Primitive.VOID)
			throw new EvalError(""Attempt to access property on undefined variable or class name"", this);
		if(obj instanceof Primitive)
			throw new EvalError(""Attempt to access property on a primitive"", this);
		Object value = ((SimpleNode)jjtGetChild(0)).eval(
			callstack, interpreter);
		if(!(value instanceof String))
			throw new EvalError(""Property expression must be a String or identifier."", this);
		// property style access to hashtable
		if(obj instanceof Hashtable)
		{
			Object val = ((Hashtable)obj).get((String)value);
			if(val == null)
				val = Primitive.NULL;
			return val;
		}
		try
		{
			return Reflect.getObjectProperty(obj, (String)value);
		}
		catch(ReflectError e)
		{
			Interpreter.debug(e.toString());
			throw new EvalError(""No such property: "" + value, this);
		}
	}
}
"
bsh.BSHPrimitiveType,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHPrimitiveType extends SimpleNode
{
	public Class type;
	BSHPrimitiveType(int id) { super(id); }
	public Class getType() { return type; }
}
"
bsh.BSHReturnStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHReturnStatement extends SimpleNode implements ParserConstants
{
	public int kind;
	BSHReturnStatement(int id) { super(id); }
	public Object eval(CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		Object value;
		if(jjtGetNumChildren() > 0)
			value = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);
		else
			value = Primitive.VOID;
		return new ReturnControl( kind, value );
	}
}
"
bsh.BSHReturnType,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHReturnType extends SimpleNode
{
	public boolean isVoid;
	BSHReturnType(int id) { super(id); }
	public Object getReturnType( NameSpace namespace ) throws EvalError
	{
		if(isVoid)
			return Primitive.VOID;
		else
			return ((BSHType)jjtGetChild(0)).getType( namespace );
	}
}
"
bsh.BSHStatementExpressionList,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHStatementExpressionList extends SimpleNode
{
	BSHStatementExpressionList(int id) { super(id); }
	public Object eval(CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		int n = jjtGetNumChildren();
		for(int i=0; i<n; i++)
		{
			SimpleNode node = ((SimpleNode)jjtGetChild(i));
			node.eval(callstack, interpreter);
		}
		return Primitive.VOID;
	}
}
"
bsh.BSHSwitchLabel,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHSwitchLabel extends SimpleNode {
	boolean isDefault;
	public BSHSwitchLabel(int id) { super(id); }
	public Object eval(
		CallStack callstack, Interpreter interpreter) throws EvalError
	{
		if ( isDefault )
			return null; // should probably error
		SimpleNode label = ((SimpleNode)jjtGetChild(0));
		return label.eval( callstack, interpreter );
	}
}
"
bsh.BSHSwitchStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHSwitchStatement 
	extends SimpleNode 
	implements ParserConstants 
{
	public BSHSwitchStatement(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		int numchild = jjtGetNumChildren();
		int child = 0;
		SimpleNode switchExp = ((SimpleNode)jjtGetChild(child++));
		Object switchVal = switchExp.eval( callstack, interpreter );
		/*
			Note: this could be made clearer by adding an inner class for the
			cases and an object context for the child traversal.
		*/
		// first label
		BSHSwitchLabel label;
		Object node;
		ReturnControl returnControl=null;
		// get the first label
		if ( child >= numchild )
			throw new EvalError(""Empty switch statement..."");
		label = ((BSHSwitchLabel)jjtGetChild(child++));
		// while more labels or blocks and haven't hit return control
		while ( child < numchild && returnControl == null ) 
		{
			// if label is default or equals switchVal
			if ( label.isDefault 
				|| label.eval( callstack, interpreter ).equals( switchVal ) )
			{
				// execute nodes, skipping labels, until a break or return
				while ( child < numchild ) 
				{
					node = jjtGetChild(child++);
					if ( node instanceof BSHSwitchLabel )
						continue;
					// eval it
					Object value = 
						((SimpleNode)node).eval( callstack, interpreter ); 
					// should check to disallow continue here?
					if ( value instanceof ReturnControl ) {
						returnControl = (ReturnControl)value;
						break;
					}
				}
			} else 
			{
				// skip nodes until next label
				while ( child < numchild ) 
				{
					node = jjtGetChild(child++);
					if ( node instanceof BSHSwitchLabel ) {
						label = (BSHSwitchLabel)node;
						break;
					}
				}
			}
		}
		if ( returnControl != null && returnControl.kind == RETURN )
			return returnControl;
		else
			return Primitive.VOID;
	}
}
"
bsh.BSHTernaryExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	This class needs logic to prevent the right hand side of boolean logical
	expressions from being naively evaluated...  e.g. for ""foo && bar"" bar 
	should not be evaluated in the case where foo is true.
*/
class BSHTernaryExpression extends SimpleNode {
    BSHTernaryExpression(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter) 
		throws EvalError
    {
        SimpleNode
			cond = (SimpleNode)jjtGetChild(0),
			evalTrue = (SimpleNode)jjtGetChild(1),
			evalFalse = (SimpleNode)jjtGetChild(2);
		if ( BSHIfStatement.evaluateCondition( cond, callstack, interpreter ) )
			return evalTrue.eval( callstack, interpreter );
		else
			return evalFalse.eval( callstack, interpreter );
    }
}
"
bsh.BSHThrowStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHThrowStatement extends SimpleNode
{
	BSHThrowStatement(int id) { super(id); }
	public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		Object obj = ((SimpleNode)jjtGetChild(0)).eval(callstack, interpreter);
		// need to loosen this to any throwable... do we need to handle
		// that in interpreter somewhere?  check first...
		if(!(obj instanceof Exception))
			throw new EvalError(""Expression in 'throw' must be Exception type"", this);
		// wrap the exception in a TargetException to propogate it up
		throw new TargetError((Exception)obj, this);
	}
}
"
bsh.BSHTryStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Vector;
class BSHTryStatement extends SimpleNode
{
	BSHTryStatement(int id)
	{
		super(id);
	}
	public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
	{
		BSHBlock tryBlock = ((BSHBlock)jjtGetChild(0));
		Vector catchParams = new Vector();
		Vector catchBlocks = new Vector();
		int nchild = jjtGetNumChildren();
		Node node = null;
		int i=1;
		while((i < nchild) && ((node = jjtGetChild(i++)) instanceof BSHFormalParameter))
		{
			catchParams.addElement(node);
			catchBlocks.addElement(jjtGetChild(i++));
			node = null;
		}
		// finaly block
		BSHBlock finallyBlock = null;
		if(node != null)
			finallyBlock = (BSHBlock)node;
// Why both of these?
		TargetError target = null;
		Throwable thrown = null;
		Object ret = null;
		/*
			Evaluate the contents of the try { } block and catch any resulting
			TargetErrors generated by the script.
			We save the callstack depth and if an exception is thrown we pop
			back to that depth before contiuing.  The exception short circuited
			any intervening method context pops.
			Note: we the stack info... what do we do with it?  append
			to exception message?
		*/
		int callstackDepth = callstack.depth();
		try {
			ret = tryBlock.eval(callstack, interpreter);
		}
		catch( TargetError e ) {
			target = e;
			String stackInfo = ""Bsh Stack: "";
			while ( callstack.depth() > callstackDepth )
				stackInfo += ""\t"" + callstack.pop() +""\n"";
		}
		// unwrap the target error
		if ( target != null )
			thrown = target.getTarget();
		// If we have an exception, find a catch
		if (thrown != null) 
		{
			int n = catchParams.size();
			for(i=0; i<n; i++)
			{
				NameSpace namespace = callstack.top();
				// get catch block
				BSHFormalParameter fp = 
					(BSHFormalParameter)catchParams.elementAt(i);
				// should cache this subject to classloader change message
				fp.eval( namespace );
				// If the param is typed check assignability
				if ( fp.type != null ) 
					try {
						thrown = (Throwable)NameSpace.getAssignableForm(
							thrown, fp.type);
					} catch(EvalError e) {
						/* Catch the mismatch and continue to try the next
							Note: this is innefficient, should have an 
							isAssignableFrom() that doesn't throw */
						continue;
					}
				// Found match, execute catch block
				BSHBlock cb = (BSHBlock)(catchBlocks.elementAt(i));
				if ( fp.type == BSHFormalParameter.UNTYPED )
					namespace.setVariable(fp.name, thrown );
				else
					namespace.setTypedVariable(fp.name, fp.type, thrown,false);
				ret = cb.eval( callstack, interpreter );
				target = null;  // handled target
				break;
			}
		}
		// evaluate finally block
		if(finallyBlock != null)
			ret = finallyBlock.eval(callstack, interpreter);
		// exception fell through, throw it upward...
		if(target != null)
			throw target;
		if(ret instanceof ReturnControl)
			return ret;
		else	
			return Primitive.VOID;
	}
}
"
bsh.BSHType,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Array;
class BSHType extends SimpleNode 
	implements BshClassManager.Listener
{
	/**
		baseType is used during evaluation of full type and retained for the
		case where we are an array type.
		In the case where we are not an array this will be the same as type.
	*/
	private Class baseType;
	/** 
		If we are an array type this will be non zero and indicate the 
		dimensionality of the array.  e.g. 2 for String[][];
	*/
    private int arrayDims;
	/** 
		Internal cache of the fully expressed type. 
		i.e. primtive, class, or array.  Cleared on classloader change.
	*/
    private Class type;
    BSHType(int id) { 
		super(id); 
		BshClassManager.addCMListener(this);
	}
	/**
		Used by the grammar to indicate dimensions of array types 
		during parsing.
	*/
    public void addArrayDimension() { 
		arrayDims++; 
	}
    /**
		 Returns a class for the type
	*/
    public Class getType( NameSpace namespace ) 
		throws EvalError
    {
        // return cached type if available
		if (type != null)
			return type;
        //  first node will either be PrimitiveType or AmbiguousName
        SimpleNode node = (SimpleNode)jjtGetChild(0);
        if(node instanceof BSHPrimitiveType)
            baseType = ((BSHPrimitiveType)node).getType();
        else 
            baseType = ((BSHAmbiguousName)node).toClass( namespace );
        if(arrayDims > 0) {
            try {
                // Get the type by constructing a prototype array with
				// arbitrary (zero) length in each dimension.
                int[] dims = new int[arrayDims]; // int array default zeros
                Object obj = Array.newInstance(baseType, dims);
                type = obj.getClass(); 
            } catch(Exception e) {
                throw new EvalError(""Couldn't construct array type"", this);
            }
        } else
            type = baseType;
        return type;
    }
	/**
		baseType is used during evaluation of full type and retained for the
		case where we are an array type.
		In the case where we are not an array this will be the same as type.
	*/
	public Class getBaseType() {
		return baseType;
	}
	/** 
		If we are an array type this will be non zero and indicate the 
		dimensionality of the array.  e.g. 2 for String[][];
	*/
	public int getArrayDims() {
		return arrayDims;
	}
	public void classLoaderChanged() {
		type = null;
		baseType = null;
	}
}
"
bsh.BSHTypedVariableDeclaration,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHTypedVariableDeclaration extends SimpleNode
{
    public boolean isFinal;
    BSHTypedVariableDeclaration(int id) { super(id); }
	/**
		evaluate the type and one or more variable declarators, e.g.:
			int a, b=5, c;
	*/
    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
		try {
			NameSpace namespace = callstack.top();
			BSHType typeNode = ((BSHType)jjtGetChild(0));
			Class type = typeNode.getType( namespace );
			int n = jjtGetNumChildren();
			for (int i = 1; i < n; i++)
			{
				BSHVariableDeclarator dec = 
					(BSHVariableDeclarator)jjtGetChild(i);
				// Type node is passed down the chain for array initializers
				// which need it under some circumstances
				Object value = dec.eval( typeNode, callstack, interpreter);
				// simple declaration with no value, e.g. int a;
				// null in value will prompt defaulting in setTypedVariable
				if ( value == Primitive.VOID ) 
					value = null;
				else 
				// true null value being assigned
				if ( value == Primitive.NULL ) {
					// leave as Primitive.NULL
				}
				else
				// allow specific numeric conversions on declaration
				if ( canCastToDeclaredType( value, type ) )
					value = BSHCastExpression.castObject( value, type );
				else {
					// leave value alone
				}
				namespace.setTypedVariable( dec.name, type, value, isFinal );
			}
		} catch ( EvalError e ) {
			e.reThrow( ""Typed variable declaration"", this );
		}
        return Primitive.VOID;
    }
	/**
		Determine if a cast would be legitimate in order to handle the 
		special cases where a numeric declared var is assigned a type larger 
		than it can handle. (JLS cite??)
			byte b = 5;
			byte b1 = 5*10;
		Normally the above would be int types.
	*/
	/*
		Note: in theory this probably shouldn't be considered a cast, but 
		should be taken into account during literal and expression evaluation
		where the result type is guided by the context.  However this is much
		simpler to deal with and there is no other use for the other that I'm
		aware of.
	*/
	boolean canCastToDeclaredType( Object value, Class toType ) {
		if ( !(value instanceof Primitive) )
			return false;
		Class fromType = ((Primitive)value).getType();
		if ( (toType==Byte.TYPE || toType==Short.TYPE || toType==Character.TYPE)
			&& fromType == Integer.TYPE 
		)
			return true;
		else
			return false;
	}
}
"
bsh.BSHUnaryExpression,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class BSHUnaryExpression extends SimpleNode implements ParserConstants
{
    public int kind;
	public boolean postfix = false;
    BSHUnaryExpression(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
        SimpleNode node = (SimpleNode)jjtGetChild(0);
        if(node instanceof BSHLHSPrimaryExpression)
            return lhsUnaryOperation(
				((BSHLHSPrimaryExpression)node).toLHS(callstack, interpreter));
        else
            return unaryOperation(node.eval(callstack, interpreter), kind);
    }
    private Object lhsUnaryOperation(LHS lhs) throws EvalError
    {
        Interpreter.debug(""lhsUnaryOperation"");
        Object prevalue, postvalue;
        prevalue = lhs.getValue();
        postvalue = unaryOperation(prevalue, kind);
		Object retVal;
		if ( postfix )
			retVal = prevalue;
		else
			retVal = postvalue;
		lhs.assign(postvalue);
		return retVal;
    }
    private Object unaryOperation(Object op, int kind) throws EvalError
    {
        if(op instanceof Boolean || op instanceof Character || op instanceof Number)
            return primitiveWrapperUnaryOperation(op, kind);
        if(!(op instanceof Primitive))
            throw new EvalError(""Unary operation "" + tokenImage[kind]
                + "" inappropriate for object"", this);
        return Primitive.unaryOperation((Primitive)op, kind);
    }
    private Object primitiveWrapperUnaryOperation(Object val, int kind)
        throws EvalError
    {
        Class operandType = val.getClass();
        Object operand = Primitive.promoteToInteger(val);
        if(operand instanceof Boolean)
            return new Boolean(
				Primitive.booleanUnaryOperation((Boolean)operand, kind));
        else if(operand instanceof Integer)
        {
            int result = Primitive.intUnaryOperation((Integer)operand, kind);
            // ++ and -- must be cast back the original type
            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Byte((byte)result);
                if(operandType == Short.TYPE)
                    return new Short((short)result);
                if(operandType == Character.TYPE)
                    return new Character((char)result);
            }
            return new Integer(result);
        }
        else if(operand instanceof Long)
            return new Long(Primitive.longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Float(Primitive.floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Double(Primitive.doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError(""An error occurred.  Please call technical support."");
    }
}
"
bsh.BSHVariableDeclarator,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	name [ = initializer ]
	evaluate name and return optional initializer
*/
class BSHVariableDeclarator extends SimpleNode
{
	// The token.image text of the name... never changes.
    public String name;
    BSHVariableDeclarator(int id) { super(id); }
	/**
		Evaluate the optional initializer value.  
		(The name was set at parse time.)
		A variable declarator can be evaluated with or without preceding
		type information. Currently the type info is only used by array 
		initializers in the case where there is no explicitly declared type.
		@param typeNode is the BSHType node.  Its info is passed through to any
		variable intializer children for the case where the array initializer
		does not declare the type explicitly. e.g.
			int [] a = { 1, 2 };
		typeNode may be null to indicate no type information available.
	*/
    public Object eval( 
		BSHType typeNode, CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
		Object value = Primitive.VOID;
        if ( jjtGetNumChildren() > 0 ) 
		{
            SimpleNode initializer = (SimpleNode)jjtGetChild(0);
			/*
				If we have type info and the child is an array initializer
				pass it along...  Else use the default eval style.
				(This allows array initializer to handle the problem... 
				allowing for future enhancements in loosening types there).	
			*/
			if ( (typeNode != null) 
				&& initializer instanceof BSHArrayInitializer 
			)
            	value = ((BSHArrayInitializer)initializer).eval( 
					typeNode.getBaseType(), typeNode.getArrayDims(), 
					callstack, interpreter);
			else
				value = initializer.eval( callstack, interpreter);
		}
        return value;
    }
}
"
bsh.BSHWhileStatement,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	This class handles both while(){} statements and do{}while() statements.
*/
class BSHWhileStatement extends SimpleNode implements ParserConstants
{
	public boolean isDoStatement;
    BSHWhileStatement(int id) { super(id); }
    public Object eval( CallStack callstack, Interpreter interpreter)  
		throws EvalError
    {
		int numChild = jjtGetNumChildren();
		// Order of body and condition is swapped for do / while
        SimpleNode condExp, body = null;
		if ( isDoStatement ) {
			condExp = (SimpleNode)jjtGetChild(1);
			body =(SimpleNode)jjtGetChild(0);
		} else {
			condExp = (SimpleNode)jjtGetChild(0);
			if ( numChild > 1 )	// has body, else just for side effects
				body =(SimpleNode)jjtGetChild(1);
		}
		boolean doOnceFlag = isDoStatement;
        while( 
			doOnceFlag || 
			BSHIfStatement.evaluateCondition(condExp, callstack, interpreter )
		)
		{
			if ( body == null ) // no body?
				continue;
			Object ret = body.eval(callstack, interpreter);
			boolean breakout = false;
			if(ret instanceof ReturnControl)
			{
				switch(((ReturnControl)ret).kind )
				{
					case RETURN:
						return ret;
					case CONTINUE:
						continue;
					case BREAK:
						breakout = true;
						break;
				}
			}
			if(breakout)
				break;
			doOnceFlag = false;
		}
        return Primitive.VOID;
    }
}
"
bsh.CallStack,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Vector;
/**
	A stack of namespaces representing the call path.
	The top of the stack is always the current namespace of evaluation.
	This is necessary to support this this.caller magic reference and will
	also be used to provide additional debug/tracking and error reporting
	information in the future.
	Note: it would be awefully nice to use the java.util.Stack here.
	Sigh... have to stay 1.1 compatible.
	We don't want to serialize this, do we?  It should be ephemeral, like
	the interpreter reference I think.
*/
public class CallStack /*implements java.io.Serializable*/
{
	private Vector stack = new Vector(2);
	public void clear() {
		stack.removeAllElements();
	}
	public void push( NameSpace ns ) {
		stack.insertElementAt( ns, 0 );
	}
	public NameSpace top() {
		return get(0);
	}
	/**
		zero based.
	*/
	public NameSpace get(int depth) {
		if ( depth >= depth() )
			return NameSpace.JAVACODE;
		else
			return (NameSpace)(stack.elementAt(depth));
	}
	/**
		This is kind of crazy, but used by the setNameSpace command.
		zero based.
	*/
	public void set(int depth, NameSpace ns) {
		stack.setElementAt(ns, depth );
	}
	public NameSpace pop() {
		if ( depth() < 1 )
			throw new InterpreterError(""pop on empty CallStack"");
		NameSpace top = top();
		stack.removeElementAt(0);
		return top;
	}
	/**
		Swap in the value as the new top of the stack and return the old
		value.
	*/
	public NameSpace swap( NameSpace newTop ) {
		NameSpace oldTop = (NameSpace)(stack.elementAt(0));
		stack.setElementAt( newTop, 0 );
		return oldTop;
	}
	public int depth() {
		return stack.size();
	}
	public NameSpace [] toArray() {
		NameSpace [] nsa = new NameSpace [ depth() ];
		stack.copyInto( nsa );
		return nsa;
	}
	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append(""CallStack:\n"");
		NameSpace [] nsa = toArray();
		for(int i=0; i<nsa.length; i++)
			sb.append(""\t""+nsa[i]+""\n"");
		return sb.toString();
	}
}
"
bsh.Capabilities,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Hashtable;
/**
	The map of extended features supported by the runtime in which we live.
	<p>
	This class should be independent of all other bsh classes!
	<p>
	Note that tests for class existence here do *not* use the 
	BshClassManager, as it may require other optional class files to be 
	loaded.  
*/
public class Capabilities 
{
	private static boolean accessibility = false;
	public static boolean haveSwing() {
		// classExists caches info for us
		return classExists( ""javax.swing.JButton"" );
	}
	public static boolean canGenerateInterfaces() {
		// classExists caches info for us
		return classExists( ""java.lang.reflect.Proxy"" );
	}
	/**
		If accessibility is enabled
		determine if the accessibility mechanism exists and if we have
		the optional bsh package to use it.
		Note that even if both are true it does not necessarily mean that we 
		have runtime permission to access the fields... Java security has
	 	a say in it.
		@see ReflectManager.java
	*/
	public static boolean haveAccessibility() 
	{
		// classExists caches the tests for us
		return ( accessibility 
			&& classExists( ""java.lang.reflect.AccessibleObject"" )
			&& classExists(""bsh.reflect.ReflectManagerImpl"") 
		);
	}
	public static void setAccessibility( boolean b ) { accessibility = b; }
	private static Hashtable classes = new Hashtable();
	/**
		Use direct Class.forName() to test for the existence of a class.
		We should not use BshClassManager here because:
			a) the systems using these tests would probably not load the
			classes through it anyway.
			b) bshclassmanager is heavy and touches other class files.  
			this capabilities code must be light enough to be used by any
			system including the remote applet.
	*/
	public static boolean classExists( String name ) 
	{
		Object c = classes.get( name );
		if ( c == null ) {
			try {
				/*
					Note: do *not* change this to 
					BshClassManager.plainClassForName() or equivalent.
					This class must not touch any other bsh classes.
				*/
				c = Class.forName( name );
			} catch ( ClassNotFoundException e ) { }
			if ( c != null )
				classes.put(c,""unused"");
		}
		return c != null;
	}
	/**
		An attempt was made to use an unavailable capability supported by
		an optional package.  The normal operation is to test before attempting
		to use these packages... so this is runtime exception.
	*/
	public static class Unavailable extends RuntimeException 
	{
		public Unavailable(String s ){ super(s); }
	}
}
"
bsh.ClassPathException,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
public class ClassPathException extends EvalError {
	public ClassPathException( String msg ) { super(msg); }
}
"
bsh.CommandLineReader,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.io.*;
/**
	This is a quick hack to turn empty lines entered interactively on the 
	command line into ';\n' empty lines for the interpreter.  It's just more 
	pleasant to be able to hit return on an empty line and see the prompt 
	reappear.
	This is *not* used when text is sourced from a file non-interactively.
*/
class CommandLineReader extends FilterReader {
    public CommandLineReader( Reader in ) {
		super(in);
    }
	static final int 
		normal = 0,
		lastCharNL = 1,
		sentSemi = 2;
	int state = lastCharNL;
    public int read() throws IOException {
		int b;
		if ( state == sentSemi ) {
			state = lastCharNL;
			return '\n';
		}
		// skip CR
        while ( (b = in.read()) == '\r' );
		if ( b == '\n' )
			if ( state == lastCharNL ) {
				b = ';';
				state = sentSemi;
			} else
				state = lastCharNL;
		else
			state = normal;
		return b;
    }
	/**
		This is a degenerate implementation.
		I don't know how to keep this from blocking if we try to read more
		than one char...  There is no available() for Readers ??
	*/
    public int read(char buff[], int off, int len) throws IOException {
		int b = read();
		if ( b == -1 )
			return -1;  // EOF, not zero read apparently
		else {
			buff[off]=(char)b;
			return 1;
		}
    }
	// Test it
	public static void main( String [] args ) throws Exception {
		Reader in = new CommandLineReader( new InputStreamReader(System.in) );
		while ( true )
			System.out.println( in.read() );
	}
}
"
bsh.ConsoleInterface,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.io.*;
/**
	The capabilities of a minimal console for BeanShell.
	Stream I/O and optimized print for output.
	A simple console may ignore some of these or map them to trivial
	implementations.  e.g. print() with color can be mapped to plain text.
	@see bsh.util.GUIConsoleInterface
*/
public interface ConsoleInterface {
	public Reader getIn();
	public PrintStream getOut();
	public PrintStream getErr();
	public void println( String s );
	public void print( String s );
	public void error( String s );
}
"
bsh.EvalError,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	EvalError indicates that we cannot continue evaluating the script
	or the script has thrown an exception.
	EvalError may be thrown for a script syntax error, an evaluation 
	error such as referring to an undefined variable, an internal error.
	If the script has thrown an exception the exception will be wrapped
	in a TargetError.  
	@see TargetError
*/
public class EvalError extends Exception {
	SimpleNode node;
	public EvalError(String s) {
		super(s);
	}
	public EvalError(String s, SimpleNode node) {
		super(s);
		this.node = node;
	}
	/**
	*/
	public String toString() {
		String trace;
		if ( node != null )
			trace = "" : at Line: ""+ node.getLineNumber() 
				+ "" : in file: ""+ node.getSourceFile()
				+ "" : ""+node.getText();
		else
			// users should not see this, in the worst case the interpreter
			// should insert the Line() AST node.
			trace = "": <at unknown location>"";
			//return super.toString() + trace;
			return getMessage() + trace;
	}
	/**
		Re-throw the eval error, prefixing msg to the message.
		<p>
		Unfortunately at the moment java.lang.Exception's message isn't 
		mutable so we just make a new one... could do something about this 
		later.
	*/
	public void reThrow( String msg ) 
		throws EvalError 
	{
		reThrow( msg, null );
	}
	/**
		Re-throw the eval error, specifying the node.
		If a node already exists the node is ignored.
		@see setNode()
		<p>
		Unfortunately at the moment java.lang.Exception's message isn't 
		mutable so we just make a new one... could do something about this 
		later.
	*/
	public void reThrow( SimpleNode node ) 
		throws EvalError 
	{
		reThrow( null, node );
	}
	/**
		Re-throw the eval error, prefixing msg to the message and specifying
		the node.
		If a node already exists the addNode is ignored.
		@see setNode()
		<p>
		@param msg may be null for no additional message.
		Unfortunately at the moment java.lang.Exception's message isn't 
		mutable so we just make a new one... could do something about this 
		later.
	*/
	public void reThrow( String addMsg, SimpleNode addNode ) 
		throws EvalError 
	{
		String msg = getMessage();
		if ( addMsg != null )
			msg = addMsg +"" : "" + msg;
		SimpleNode node = this.node;
		if ( node == null && addNode != null )
			node = addNode;
		throw new EvalError( msg, node );
	}
	/**
		Set the AST node for trace info.
		@see reThrow
		This is useful for the interpreter if it detects that there is no
		trace info and wants to supply the Line() AST before printing.
	*/
	void setNode( SimpleNode node ) {
		this.node = node;
	}
	/**
		The error has trace info associated with it. 
		i.e. It has an AST node that can print its location and source text.
	*/
	SimpleNode getNode() {
		return node;
	}
	public String getErrorText() { 
		if ( node != null )
			return node.getText() ;
		else
			return ""<unknown error>"";
	}
	public int getErrorLineNumber() { 
		if ( node != null )
			return node.getLineNumber() ;
		else
			return -1;
	}
	public String getErrorSourceFile() {
		if ( node != null )
			return node.getSourceFile() ;
		else
			return ""<unknown file>"";
	}
}
"
bsh.Interpreter,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.Vector;
import java.io.*;
/**
	The BeanShell script interpreter.
	An instance of Interpreter can be used to source scripts and evaluate 
	statements or expressions.  
	<p>
	Here are some examples:
	<p><blockquote><pre>
		Interpeter bsh = new Interpreter();
		// Evaluate statements and expressions
		bsh.eval(""foo=Math.sin(0.5)"");
		bsh.eval(""bar=foo*5; bar=Math.cos(bar);"");
		bsh.eval(""for(i=0; i<10; i++) { print(\""hello\""); }"");
		// same as above using java syntax and apis only
		bsh.eval(""for(int i=0; i<10; i++) { System.out.println(\""hello\""); }"");
		// Source from files or streams
		bsh.source(""myscript.bsh"");  // or bsh.eval(""source(\""myscript.bsh\"")"");
		// Use set() and get() to pass objects in and out of variables
		bsh.set( ""date"", new Date() );
		Date date = (Date)bsh.get( ""date"" );
		// This would also work:
		Date date = (Date)bsh.eval( ""date"" );
		bsh.eval(""year = date.getYear()"");
		Integer year = (Integer)bsh.get(""year"");  // primitives use wrappers
		// With Java1.3+ scripts can implement arbitrary interfaces...
		// Script an awt event handler (or source it from a file, more likely)
		bsh.eval( ""actionPerformed( e ) { print( e ); }"");
		// Get a reference to the script object (implementing the interface)
		ActionListener scriptedHandler = 
			(ActionListener)bsh.eval(""return (ActionListener)this"");
		// Use the scripted event handler normally...
		new JButton.addActionListener( script );
	</pre></blockquote>
	<p>
	In the above examples we showed a single interpreter instance, however 
	you may wish to use many instances, depending on the application and how
	you structure your scripts.  Interpreter instances are very light weight
	to create, however if you are going to execute the same script repeatedly
	and require maximum performance you should consider scripting the code as 
	a method and invoking the scripted method each time on the same interpreter
	instance (using eval()). 
	<p>
	See the BeanShell User's Manual for more information.
*/
public class Interpreter 
	implements Runnable, ConsoleInterface /*,Serializable*/ 
{
	/* --- Begin static stuff --- */
	public static final String VERSION = ""1.2b1"";
	/* 
		Debug utils are static so that they are reachable by code that doesn't
		necessarily have an interpreter reference (e.g. tracing in utils).
		In the future we may want to allow debug/trace to be turned on on
		a per interpreter basis, in which case we'll need to use the parent 
		reference in some way to determine the scope of the command that 
		turns it on or off...
	*/
    public static boolean DEBUG, TRACE;
	// This should be per instance
    static PrintStream debug;
	static { 
		staticInit();
	}
	/** Shared system object visible under bsh.system */
	static This systemObject;
	/** Strict Java mode */
	public static boolean strictJava = false;
	/* --- end static stuff --- */
	/* --- Instance data --- */
	Parser parser;
    NameSpace globalNameSpace;
    Reader in;
    PrintStream out;
    PrintStream err;
    ConsoleInterface console; 
	/** If this interpeter is a child of another, the parent */
	Interpreter parent;
	/** The name of the file or other source that this interpreter is reading */
	String sourceFileInfo;
	/** 
		Do we override exit on EOF as normally done in iteractive mode?
		(This is used by Sessiond)
	*/
	public boolean noExitOnEOF;
    private boolean 
		evalOnly, 		// Interpreter has no input stream, use eval() only
		interactive;	// Interpreter has a user, print prompts, etc.
	/* --- End instance data --- */
	/**
		The main constructor.
		All constructors should now pass through here.
		@param namespace If namespace is non-null then this interpreter's 
		root namespace will be set to the one provided.  If it is null a new 
		one will be created for it.
		@param parent The parent interpreter if this interpreter is a child 
			of another.  May be null.
		@param sourceFileInfo An informative string holding the filename 
		or other description of the source from which this interpreter is
		reading... used for debugging.  May be null.
	*/
    public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace,
		Interpreter parent, String sourceFileInfo )
    {
		parser = new Parser( in );
		long t1=System.currentTimeMillis();
        this.in = in;
        this.out = out;
        this.err = err;
        this.interactive = interactive;
		debug = err;
		this.parent = parent;
		this.sourceFileInfo = sourceFileInfo;
		if ( namespace == null )
        	this.globalNameSpace = new NameSpace(""global"");
		else
			this.globalNameSpace = namespace;
		// The classes which are imported by default
		globalNameSpace.loadDefaultImports();
		/* 
			Create the root ""bsh"" system object if it doesn't exist.
		*/
		if ( ! ( getu(""bsh"") instanceof bsh.This ) )
			initRootSystemObject();
		if ( interactive )
			loadRCFiles();
		long t2=System.currentTimeMillis();
		Interpreter.debug(""Time to initialize interpreter: ""+(t2-t1));
    }
    public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace)
    {
		this( in, out, err, interactive, namespace, null, null );
	}
    public Interpreter(
		Reader in, PrintStream out, PrintStream err, boolean interactive)
    {
        this(in, out, err, interactive, null);
    }
	/**
		Construct a new interactive interpreter attached to the specified 
		console using the specified parent namespace.
	*/
    public Interpreter(ConsoleInterface console, NameSpace globalNameSpace) {
        this( console.getIn(), console.getOut(), console.getErr(), 
			true, globalNameSpace );
		setConsole( console );
    }
	/**
		Construct a new interactive interpreter attached to the specified 
		console.
	*/
    public Interpreter(ConsoleInterface console) {
        this(console, null);
    }
	/**
		Create an interpreter for evaluation only.
	*/
    public Interpreter()
    {
		this( new StringReader(""""), 
			System.out, System.err, false, null );
        evalOnly = true;
		setu( ""bsh.evalOnly"", new Primitive(true) );
    }
	// End constructors
	/**
		Attach the console thusly... ;)
	*/
	public void setConsole( ConsoleInterface console ) {
		this.console = console;
		setu( ""bsh.console"", console );
	}
	private void initRootSystemObject() 
	{
		// bsh
		setu(""bsh"", new NameSpace( ""Bsh Object"" ).getThis( this ) );
		// init the static shared systemObject if it's not there yet
		if ( systemObject == null )
			systemObject = new NameSpace( 
				""Bsh System Object"" ).getThis( this );
		// bsh.system
		setu( ""bsh.system"", systemObject );
		// bsh.help
		This helpText = new NameSpace( 
			""Bsh Command Help Text"" ).getThis( this );
		setu( ""bsh.help"", helpText );
		// bsh.cwd
		try {
			setu( ""bsh.cwd"", System.getProperty(""user.dir"") );
		} catch ( SecurityException e ) { 
			// applets can't see sys props
			setu( ""bsh.cwd"", ""."" );
		}
		// bsh.interactive
		setu( ""bsh.interactive"", new Primitive(interactive) );
		// bsh.evalOnly
		setu( ""bsh.evalOnly"", new Primitive(evalOnly) );
	}
	/**
		Set the global namespace for this interpreter.
		<p>
		Note: This is here for completeness.  If you're using this a lot 
		it may be an indication that you are doing more work than you have 
		to.  For example, caching the interpreter instance rather than the 
		namespace should not add a significant overhead.  No state other 
		than the debug status is stored in the interpreter.
		<p>
		All features of the namespace can also be accessed using the 
		interpreter via eval() and the script variable 'this.namespace'
		(or global.namespace as necessary).
	*/
	public void setNameSpace( NameSpace globalNameSpace ) {
		this.globalNameSpace = globalNameSpace;
	}
	/**
		Get the global namespace of this interpreter.
		<p>
		Note: This is here for completeness.  If you're using this a lot 
		it may be an indication that you are doing more work than you have 
		to.  For example, caching the interpreter instance rather than the 
		namespace should not add a significant overhead.  No state other than 
		the debug status is stored in the interpreter.  
		<p>
		All features of the namespace can also be accessed using the 
		interpreter via eval() and the script variable 'this.namespace'
		(or global.namespace as necessary).
	*/
	public NameSpace getNameSpace() {
		return globalNameSpace;
	}
	/**
		Run the text only interpreter on the command line or specify a file.
	*/
    public static void main( String [] args ) 
	{
        if ( args.length > 0 ) {
			String filename = args[0];
			String [] bshArgs;
			if ( args.length > 1 ) {
				bshArgs = new String [ args.length -1 ];
				System.arraycopy( args, 1, bshArgs, 0, args.length-1 );
			} else
				bshArgs = new String [0];
            Interpreter interpreter = new Interpreter();
			interpreter.setu( ""bsh.args"", bshArgs );
			try {
				interpreter.source( filename, interpreter.globalNameSpace );
			} catch ( FileNotFoundException e ) {
				System.out.println(""File not found: ""+e);
			} catch ( EvalError e ) {
				System.out.println(""Evaluation Error: ""+e);
			} catch ( IOException e ) {
				System.out.println(""I/O Error: ""+e);
			}
        } else {
			// Workaround for JDK bug 4071281, where system.in.available() 
			// returns too large a value. This bug has been fixed in JDK 1.2.
			InputStream src;
			if ( System.getProperty(""os.name"").startsWith(""Windows"") 
				&& System.getProperty(""java.version"").startsWith(""1.1.""))
			{
				src = new FilterInputStream(System.in) {
					public int available() throws IOException {
						return 0;
					}
				};
			}
			else
				src = System.in;
            Reader in = new CommandLineReader( new InputStreamReader(src));
            Interpreter interpreter = 
				new Interpreter( in, System.out, System.err, true );
        	interpreter.run();
        }
    }
	/**
		Run interactively.  (printing prompts, etc.)
	*/
    public void run() {
        if(evalOnly)
            throw new RuntimeException(""bsh Interpreter: No stream"");
        /*
          We'll print our banner using eval(String) in order to
          exercise the parser and get the basic expression classes loaded...
          This ameliorates the delay after typing the first statement.
        */
        if ( interactive )
			try { 
				eval(""printBanner();""); 
			} catch ( EvalError e ) {
				println(
					""BeanShell ""+VERSION+"" - by Pat Niemeyer (pat@pat.net)"");
			}
        boolean eof = false;
		// init the callstack.  
		CallStack callstack = new CallStack();
		callstack.push( globalNameSpace );
        while(!eof)
        {
            try
            {
                // try to sync up the console
                System.out.flush();
                System.err.flush();
                Thread.yield();  // this helps a little
                if(interactive)
                    print(""bsh % "");
                eof = Line();
                if(get_jjtree().nodeArity() > 0)  // number of child nodes 
                {
                    SimpleNode node = (SimpleNode)(get_jjtree().rootNode());
                    if(DEBUG)
                        node.dump("">"");
                    Object ret = node.eval( callstack, this );
					// sanity check during development
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							""Callstack growing: ""+callstack);
                    if(ret instanceof ReturnControl)
                        ret = ((ReturnControl)ret).value;
                    if(ret != Primitive.VOID)
                    {
                        setVariable(""$_"", ret);
                        Object show = getu(""bsh.show"");
                        if(show instanceof Boolean &&
                            ((Boolean)show).booleanValue() == true)
                            println(""<"" + ret + "">"");
                    }
                }
            }
            catch(ParseException e)
            {
                error(""Parser Error: "" + e.getMessage(DEBUG));
                if(DEBUG)
                    e.printStackTrace();
                if(!interactive)
                    eof = true;
                parser.reInitInput(in);
            }
            catch(InterpreterError e)
            {
                error(""Internal Error: "" + e.getMessage());
                e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch(TargetError e)
            {
                error(""// Uncaught Exception: "" + e );
                if(DEBUG)
                    e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch (EvalError e)
            {
				if ( interactive )
					error( e.toString() );
				else
					error( e.getMessage() );
                if(DEBUG)
                    e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch(Exception e)
            {
                error(""Unknown error: "" + e);
                e.printStackTrace();
                if(!interactive)
                    eof = true;
            }
            catch(TokenMgrError e)
            {
				error(""Error parsing input: "" + e);
				/*
					We get stuck in infinite loops here when unicode escapes
					fail.  Must re-init the char stream reader 
					(ASCII_UCodeESC_CharStream.java)
				*/
				parser.reInitTokenInput( in );
                if(!interactive)
                    eof = true;
            }
            finally
            {
                get_jjtree().reset();
				// reinit the callstack
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( globalNameSpace );
				}
            }
        }
		if ( interactive && !noExitOnEOF ) 
			System.exit(0);
    }
	// begin source and eval
	/**
		Read text from fileName and eval it.
	*/
    public Object source( String filename, NameSpace nameSpace ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		File file = pathToFile( filename );
		debug(""Sourcing file: ""+file);
		Reader in = new BufferedReader( new FileReader(file) );
		return eval( in, nameSpace, filename );
	}
	/**
		Read text from fileName and eval it.
		Convenience method.  Use the global namespace.
	*/
    public Object source( String filename ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		return source( filename, globalNameSpace );
	}
    /**
        Spawn a non-interactive local interpreter to evaluate text in the 
		specified namespace.  
		Return value is the evaluated object (or corresponding primitive 
		wrapper).
		@param sourceFileInfo is for information purposes only.  It is used to
		display error messages (and in the future may be made available to
		the script).
		@throws EvalError on script problems
		@throws TargetError on unhandled exceptions from the script
    */
	/*
		Note: we need a form of eval that passes the callstack through...
	*/
	/*
	Can't this be combined with run() ?
	run seems to have stuff in it for interactive vs. non-interactive...
	compare them side by side and see what they do differently, aside from the
	exception handling.
	*/
    public Object eval( 
		Reader in, NameSpace nameSpace, String sourceFileInfo ) 
		throws EvalError 
	{
		Object retVal = null;
		debug(""eval: nameSpace = ""+nameSpace);
		/* 
			Create non-interactive local interpreter for this namespace
			with source from the input stream and out/err same as 
			this interpreter.
		*/
        Interpreter localInterpreter = 
			new Interpreter( 
				in, out, err, false, nameSpace, this, sourceFileInfo  );
		CallStack callstack = new CallStack();
		callstack.push( nameSpace );
        boolean eof = false;
        while(!eof)
        {
			SimpleNode node = null;
            try
            {
                eof = localInterpreter.Line();
                if (localInterpreter.get_jjtree().nodeArity() > 0)
                {
                    node = (SimpleNode)localInterpreter.get_jjtree().rootNode();
					// nodes remember from where they were sourced
					node.setSourceFile( sourceFileInfo );
					if ( TRACE )
						println( ""// "" +node.getText() );
                    retVal = node.eval( callstack, localInterpreter );
					// sanity check during development
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							""Callstack growing: ""+callstack);
                    if ( retVal instanceof ReturnControl ) {
                        retVal = ((ReturnControl)retVal).value;
						break; // non-interactive, return control now
					}
                }
            } catch(ParseException e) {
                throw new EvalError(
					""Sourced file: ""+sourceFileInfo+"" parser Error: "" 
					+ e.getMessage( DEBUG ), node );
            } catch(InterpreterError e) {
                e.printStackTrace();
                throw new EvalError(
					""Sourced file: ""+sourceFileInfo+"" internal Error: "" 
					+ e.getMessage(), node);
            } catch( TargetError e ) {
                if(DEBUG)
                    e.printStackTrace();
				// failsafe, set the Line as the origin of the error.
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow(""Sourced file: ""+sourceFileInfo);
            } catch(EvalError e) {
                if(DEBUG)
                    e.printStackTrace();
				// failsafe, set the Line as the origin of the error.
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow( ""Sourced file: ""+sourceFileInfo );
            } catch(Exception e) {
                e.printStackTrace();
                throw new EvalError(
					""Sourced file: ""+sourceFileInfo+"" unknown error: "" 
					+ e.getMessage(), node);
            } catch(TokenMgrError e) {
                throw new EvalError(
					""Sourced file: ""+sourceFileInfo+"" Token Parsing Error: "" 
					+ e.getMessage(), node );
            } finally {
                localInterpreter.get_jjtree().reset();
				// reinit the callstack
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( nameSpace );
				}
            }
        }
		return Primitive.unwrap( retVal );
    }
	/**
		Evaluate the inputstream in this interpreter's global namespace.
	*/
    public Object eval( Reader in ) throws EvalError 
	{
		return eval( in, globalNameSpace, ""eval stream"" );
	}
	/**
		Evaluate the string in this interpreter's global namespace.
	*/
    public Object eval( String statement ) throws EvalError {
		return eval(statement, globalNameSpace);
	}
	/**
		Evaluate the string in the specified namespace.
	*/
    public Object eval( String statement, NameSpace nameSpace ) 
		throws EvalError {
		String s = ( statement.endsWith("";"") ? statement : statement+"";"" );
        return eval( 
			new StringReader(s), nameSpace, ""<Inline eval of: ""+s+"" >"" );
    }
	// end source and eval
	/**
		Print an error message in a standard format on the output stream
		associated with this interpreter. On the GUI console this will appear 
		in red, etc.
	*/
    public final void error(String s) {
		if ( console != null )
				console.error( ""// Error: "" + s +""\n"" );
		else {
			err.println(""// Error: "" + s);
			err.flush();
		}
    }
	// ConsoleInterface
	// The interpreter reflexively implements the console interface that it 
	// uses.  Should clean this up by using an inner class to implement the
	// console for us.
	/** 
		Get the input stream associated with this interpreter.
		This may be be stdin or the GUI console.
	*/
	public Reader getIn() { return in; }
	/** 
		Get the outptut stream associated with this interpreter.
		This may be be stdout or the GUI console.
	*/
	public PrintStream getOut() { return out; }
	/** 
		Get the error output stream associated with this interpreter.
		This may be be stderr or the GUI console.
	*/
	public PrintStream getErr() { return err; }
    public final void println(String s)
    {
        print(s + ""\n"");
    }
    public final void print(String s)
    {
		if (console != null) {
            console.print(s);
        } else {
            out.print(s);
            out.flush();
        }
    }
	// End ConsoleInterface
	/**
		Print a debug message on debug stream associated with this interpreter
		only if debugging is turned on.
	*/
    public final static void debug(String s)
    {
        if(DEBUG)
            debug.println(""// Debug: "" + s);
    }
	/* 
		Primary interpreter set and get variable methods
		Note: These are squeltching errors... should they?
	*/
	/**
		Get the value of the name.
		name may be any value. e.g. a variable or field
	*/
    public Object get( String name ) throws EvalError {
		Object ret = globalNameSpace.get( name, this );
		return Primitive.unwrap( ret );
	}
	/**
		Unchecked get for internal use
	*/
    Object getu( String name ) {
		try { 
			return get( name );
		} catch ( EvalError e ) { 
			throw new InterpreterError(""set: ""+e);
		}
	}
	/**
		Assign the value to the name.	
		name may evaluate to anything assignable. e.g. a variable or field.
	*/
    public void set(String name, Object value) 
		throws EvalError 
	{
		// map null to Primtive.NULL coming in...
		if ( value == null )
			value = Primitive.NULL;
		CallStack callstack = new CallStack();
		LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( 
			callstack, this );
		lhs.assign( value );
	}
	/**
		Unchecked set for internal use
	*/
    void setu(String name, Object value) {
		try { 
			set(name, value);
		} catch ( EvalError e ) { 
			throw new InterpreterError(""set: ""+e);
		}
	}
    public void set(String name, long value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, int value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, double value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, float value) throws EvalError {
        set(name, new Primitive(value));
	}
    public void set(String name, boolean value) throws EvalError {
        set(name, new Primitive(value));
	}
	/**
		Unassign the variable name.	
		Name should evaluate to a variable.
	*/
    public void unset( String name ) 
		throws EvalError 
	{
		CallStack callstack = new CallStack();
		LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( 
			callstack, this );
		if ( lhs.type != LHS.VARIABLE )
			throw new EvalError(""Can't unset, not a variable: ""+name);
		// null means remove it
		lhs.assign( null );
	}
	/**
		@deprecated does not properly evaluate compound names
	*/
    public Object getVariable(String name)
    {
        Object obj = globalNameSpace.getVariable(name);
		return Primitive.unwrap( obj );
    }
	/**
		@deprecated does not properly evaluate compound names
	*/
    public void setVariable(String name, Object value)
    {
        try { globalNameSpace.setVariable(name, value); }
        catch(EvalError e) { error(e.toString()); }
    }
	/**
		@deprecated does not properly evaluate compound names
	*/
    public void setVariable(String name, int value)
    {
        try { globalNameSpace.setVariable(name, new Primitive(value)); }
        catch(EvalError e) { error(e.toString()); }
    }
	/**
		@deprecated does not properly evaluate compound names
	*/
    public void setVariable(String name, float value)
    {
        try { globalNameSpace.setVariable(name, new Primitive(value)); }
        catch(EvalError e) { error(e.toString()); }
    }
	/**
		@deprecated does not properly evaluate compound names
	*/
    public void setVariable(String name, boolean value)
    {
        try { globalNameSpace.setVariable(name, new Primitive(value)); }
        catch(EvalError e) { error(e.toString()); }
    }
	// end primary set and get methods
	/*	Methods for interacting with Parser */
	private JJTParserState get_jjtree() {
		return parser.jjtree;
	}
  	private ASCII_UCodeESC_CharStream get_jj_input_stream() {
		return parser.jj_input_stream;
	}
  	private boolean Line() throws ParseException {
		return parser.Line();
	}
	/*	End methods for interacting with Parser */
	void loadRCFiles() {
		try {
			String rcfile = 
				// Default is c:\windows under win98, $HOME under Unix
				System.getProperty(""user.home"") + File.separator + "".bshrc"";
			source( rcfile, globalNameSpace );
		} catch ( Exception e ) { 
			// squeltch security exception, filenotfoundexception
			debug(""Could not find rc file: ""+e);
		}
	}
	/**
		Localize a path to the file name based on the bsh.cwd interpreter 
		working directory.
	*/
    public File pathToFile( String fileName ) 
		throws IOException
	{
		File file = new File( fileName );
		// if relative, fix up to bsh.cwd
		if ( !file.isAbsolute() ) {
			String cwd = (String)getu(""bsh.cwd"");
			file = new File( cwd + File.separator + fileName );
		}
		return new File( file.getCanonicalPath() );
	}
	public static void redirectOutputToFile( String filename ) 
	{
		try {
			PrintStream pout = new PrintStream( 
				new FileOutputStream( filename ) );
			System.setOut( pout );
			System.setErr( pout );
		} catch ( IOException e ) {
			System.err.println(""Can't redirect output to file: ""+filename );
		}
	}
	/**
		Set an external class loader to be used for all basic class loading
		in BeanShell.  
		<p>
		BeanShell will use this at the same point it would otherwise use the 
		plain Class.forName().
		i.e. if no explicit classpath management is done from the script
		(addClassPath(), setClassPath(), reloadClasses()) then BeanShell will
		only use the supplied classloader.  If additional classpath management
		is done then BeanShell will perform that in addition to the supplied
		external classloader.  
		However BeanShell is not currently able to reload
		classes supplied through the external classloader.
		<p>
		@see BshClassManager.setClassLoader()
	*/
	public void setClassLoader( ClassLoader externalCL ) {
		BshClassManager.setClassLoader( externalCL );
	}
	static void staticInit() {
	/* 
		Apparently in some environments you can't catch the security exception
		at all...  e.g. as an applet in IE  ... will probably have to work 
		around 
	*/
		try {
    		debug = System.err;
    		DEBUG = Boolean.getBoolean(""debug"");
    		TRACE = Boolean.getBoolean(""trace"");
			String outfilename = System.getProperty(""outfile"");
			if ( outfilename != null )
				redirectOutputToFile( outfilename );
		} catch ( SecurityException e ) { 
			System.err.println(""Could not init static:""+e);
		} catch ( Exception e ) {
			System.err.println(""Could not init static(2):""+e);
		} catch ( Throwable e ) { 
			System.err.println(""Could not init static(3):""+e);
		}
	}
	/**
		Specify the source of the text from which this interpreter is reading.
		Note: there is a difference between what file the interrpeter is 
		sourcing and from what file a method was originally parsed.  One
		file may call a method sourced from another file.  See SimpleNode
		for origination file info.
		@see SimpleNode.getSourceFile 
	*/
	public String getSourceFileInfo() { 
		if ( sourceFileInfo != null )
			return sourceFileInfo;
		else
			return ""<unknown source>"";
	}
	public Interpreter getParent() {
		return parent;
	}
}
"
bsh.InterpreterError,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	An internal error in the interpreter has occurred.
*/
public class InterpreterError extends RuntimeException
{
	public InterpreterError(String s)
	{
		super(s);
	}
}
"
bsh.JJTParserState,"/* Generated By:JJTree: Do not edit this line. JJTParserState.java */
package bsh;
class JJTParserState {
  private java.util.Stack nodes;
  private java.util.Stack marks;
  private int sp;		// number of nodes on stack
  private int mk;		// current mark
  private boolean node_created;
  JJTParserState() {
    nodes = new java.util.Stack();
    marks = new java.util.Stack();
    sp = 0;
    mk = 0;
  }
  /* Determines whether the current node was actually closed and
     pushed.  This should only be called in the final user action of a
     node scope.  */
  boolean nodeCreated() {
    return node_created;
  }
  /* Call this to reinitialize the node stack.  It is called
     automatically by the parser's ReInit() method. */
  void reset() {
    nodes.removeAllElements();
    marks.removeAllElements();
    sp = 0;
    mk = 0;
  }
  /* Returns the root node of the AST.  It only makes sense to call
     this after a successful parse. */
  Node rootNode() {
    return (Node)nodes.elementAt(0);
  }
  /* Pushes a node on to the stack. */
  void pushNode(Node n) {
    nodes.push(n);
    ++sp;
  }
  /* Returns the node on the top of the stack, and remove it from the
     stack.  */
  Node popNode() {
    if (--sp < mk) {
      mk = ((Integer)marks.pop()).intValue();
    }
    return (Node)nodes.pop();
  }
  /* Returns the node currently on the top of the stack. */
  Node peekNode() {
    return (Node)nodes.peek();
  }
  /* Returns the number of children on the stack in the current node
     scope. */
  int nodeArity() {
    return sp - mk;
  }
  void clearNodeScope(Node n) {
    while (sp > mk) {
      popNode();
    }
    mk = ((Integer)marks.pop()).intValue();
  }
  void openNodeScope(Node n) {
    marks.push(new Integer(mk));
    mk = sp;
    n.jjtOpen();
  }
  /* A definite node is constructed from a specified number of
     children.  That number of nodes are popped from the stack and
     made the children of the definite node.  Then the definite node
     is pushed on to the stack. */
  void closeNodeScope(Node n, int num) {
    mk = ((Integer)marks.pop()).intValue();
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }
  /* A conditional node is constructed if its condition is true.  All
     the nodes that have been pushed since the node was opened are
     made children of the the conditional node, which is then pushed
     on to the stack.  If the condition is false the node is not
     constructed and they are left on the stack. */
  void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = ((Integer)marks.pop()).intValue();
      while (a-- > 0) {
	Node c = popNode();
	c.jjtSetParent(n);
	n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = ((Integer)marks.pop()).intValue();
      node_created = false;
    }
  }
}
"
bsh.JThis,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.io.*;
import java.beans.*;
/**
	JThis is a dynamically loaded extension which extends This and adds 
	explicit support for AWT and JFC events, etc.  This is a backwards 
	compatability measure for JDK 1.2.  With 1.3+ there is a general 
	reflection proxy mechanism that allows the base This to implement 
	arbitrary interfaces.
	The NameSpace getThis() method will produce instances of JThis if 
	the java version is prior to 1.3 and swing is available...  (e.g. 1.2
	or 1.1 + swing installed)  
	Users of 1.1 without swing will have minimal interface support (just run()).
	Bsh doesn't run on 1.02 and below because there is no reflection! 
	Note: This module relies on features of Swing and will only compile
	with JDK1.2 or JDK1.1 + the swing package.  For other environments simply 
	do not compile this class.
*/
class JThis extends This implements
	// All core AWT listeners
	ActionListener, AdjustmentListener, ComponentListener,
	ContainerListener, FocusListener, ItemListener, KeyListener,
	MouseListener, MouseMotionListener, TextListener, WindowListener,
	PropertyChangeListener, 
	// All listeners in javax.swing.event as of Swing 1.1
	AncestorListener, CaretListener, CellEditorListener, ChangeListener,
	DocumentListener, HyperlinkListener, 
	InternalFrameListener, ListDataListener, ListSelectionListener, 
	MenuDragMouseListener, MenuKeyListener, MenuListener, MouseInputListener, 
	PopupMenuListener, TableColumnModelListener, TableModelListener, 
	TreeExpansionListener, TreeModelListener, TreeSelectionListener, 
	TreeWillExpandListener, UndoableEditListener
{
	JThis( NameSpace namespace, Interpreter declaringInterp ) { 
		super( namespace, declaringInterp );
	}
	public String toString() {
		return ""'this' reference (JThis) to Bsh object: "" + namespace.name;
	}
	void event(String name, Object event)
	{
		BshMethod method;
		// handleEvent gets all events
		method = namespace.getMethod( 
			""handleEvent"", new Class [] { null } );
		if (method != null)
			try {
				method.invokeDeclaredMethod( 
					new Object[] { event }, declaringInterpreter, callstack, null );
			} catch(EvalError e) {
				declaringInterpreter.error(
					""local event hander method invocation error:"" + e );
			}
		// send to specific event handler
		method = namespace.getMethod( name, new Class [] { null } );
		if (method != null)
			try {
				method.invokeDeclaredMethod( 
					new Object[] { event }, declaringInterpreter, callstack, null );
			} catch(EvalError e) {
				declaringInterpreter.error(
					""local event hander method invocation error:"" + e );
			}
	}
	// Listener interfaces
    public void ancestorAdded(AncestorEvent e) { event(""ancestorAdded"", e); }
    public void ancestorRemoved(AncestorEvent e) { event(""ancestorRemoved"", e); }
    public void ancestorMoved(AncestorEvent e) { event(""ancestorMoved"", e); }
    public void caretUpdate(CaretEvent e) { event(""caretUpdate"", e); }
    public void editingStopped(ChangeEvent e) { event(""editingStopped"", e); }
    public void editingCanceled(ChangeEvent e) { event(""editingCanceled"", e); }
    public void stateChanged(ChangeEvent e) { event(""stateChanged"", e); }
    public void insertUpdate(DocumentEvent e) { event(""insertUpdate"", e); }
    public void removeUpdate(DocumentEvent e) { event(""removeUpdate"", e); }
    public void changedUpdate(DocumentEvent e) { event(""changedUpdate"", e); }
    public void hyperlinkUpdate(HyperlinkEvent e) { event(""internalFrameOpened"", e); }
    public void internalFrameOpened(InternalFrameEvent e) { event(""internalFrameOpened"", e); }
    public void internalFrameClosing(InternalFrameEvent e) { event(""internalFrameClosing"", e); }
    public void internalFrameClosed(InternalFrameEvent e) { event(""internalFrameClosed"", e); }
    public void internalFrameIconified(InternalFrameEvent e) { event(""internalFrameIconified"", e); }
    public void internalFrameDeiconified(InternalFrameEvent e) { event(""internalFrameDeiconified"", e); }
    public void internalFrameActivated(InternalFrameEvent e) { event(""internalFrameActivated"", e); }
    public void internalFrameDeactivated(InternalFrameEvent e) { event(""internalFrameDeactivated"", e); }
    public void intervalAdded(ListDataEvent e) { event(""intervalAdded"", e); }
    public void intervalRemoved(ListDataEvent e) { event(""intervalRemoved"", e); }
    public void contentsChanged(ListDataEvent e) { event(""contentsChanged"", e); }
  	public void valueChanged(ListSelectionEvent e) { event(""valueChanged"", e); }
    public void menuDragMouseEntered(MenuDragMouseEvent e) { event(""menuDragMouseEntered"", e); }
    public void menuDragMouseExited(MenuDragMouseEvent e) { event(""menuDragMouseExited"", e); }
    public void menuDragMouseDragged(MenuDragMouseEvent e) { event(""menuDragMouseDragged"", e); }
    public void menuDragMouseReleased(MenuDragMouseEvent e) { event(""menuDragMouseReleased"", e); }
    public void menuKeyTyped(MenuKeyEvent e) { event(""menuKeyTyped"", e); }
    public void menuKeyPressed(MenuKeyEvent e) { event(""menuKeyPressed"", e); }
    public void menuKeyReleased(MenuKeyEvent e) { event(""menuKeyReleased"", e); }
    public void menuSelected(MenuEvent e) { event(""menuSelected"", e); }
    public void menuDeselected(MenuEvent e) { event(""menuDeselected"", e); }
    public void menuCanceled(MenuEvent e) { event(""menuCanceled"", e); }
    public void popupMenuWillBecomeVisible(PopupMenuEvent e) { event(""popupMenuWillBecomeVisible"", e); }
    public void popupMenuWillBecomeInvisible(PopupMenuEvent e) { event(""popupMenuWillBecomeInvisible"", e); }
    public void popupMenuCanceled(PopupMenuEvent e) { event(""popupMenuCanceled"", e); }
    public void columnAdded(TableColumnModelEvent e) { event(""columnAdded"", e); }
    public void columnRemoved(TableColumnModelEvent e) { event(""columnRemoved"", e); }
    public void columnMoved(TableColumnModelEvent e) { event(""columnMoved"", e); }
    public void columnMarginChanged(ChangeEvent e) { event(""columnMarginChanged"", e); }
    public void columnSelectionChanged(ListSelectionEvent e) { event(""columnSelectionChanged"", e); }
    public void tableChanged(TableModelEvent e) { event(""tableChanged"", e); }
    public void treeExpanded(TreeExpansionEvent e) { event(""treeExpanded"", e); }
    public void treeCollapsed(TreeExpansionEvent e) { event(""treeCollapsed"", e); }
    public void treeNodesChanged(TreeModelEvent e) { event(""treeNodesChanged"", e); }
    public void treeNodesInserted(TreeModelEvent e) { event(""treeNodesInserted"", e); }
    public void treeNodesRemoved(TreeModelEvent e) { event(""treeNodesRemoved"", e); }
    public void treeStructureChanged(TreeModelEvent e) { event(""treeStructureChanged"", e); }
    public void valueChanged(TreeSelectionEvent e) { event(""valueChanged"", e); }
    public void treeWillExpand(TreeExpansionEvent e) { event(""treeWillExpand"", e); }
    public void treeWillCollapse(TreeExpansionEvent e) { event(""treeWillCollapse"", e); }
    public void undoableEditHappened(UndoableEditEvent e) { event(""undoableEditHappened"", e); }
	// Listener interfaces
	public void actionPerformed(ActionEvent e) { event(""actionPerformed"", e); }
	public void adjustmentValueChanged(AdjustmentEvent e) { event(""adjustmentValueChanged"", e); }
	public void componentResized(ComponentEvent e) { event(""componentResized"", e); }
	public void componentMoved(ComponentEvent e) { event(""componentMoved"", e); }
	public void componentShown(ComponentEvent e) { event(""componentShown"", e); }
	public void componentHidden(ComponentEvent e) { event(""componentHidden"", e); }
	public void componentAdded(ContainerEvent e) { event(""componentAdded"", e); }
	public void componentRemoved(ContainerEvent e) { event(""componentRemoved"", e); }
	public void focusGained(FocusEvent e) { event(""focusGained"", e); }
	public void focusLost(FocusEvent e) { event(""focusLost"", e); }
	public void itemStateChanged(ItemEvent e) { event(""itemStateChanged"", e); }
	public void keyTyped(KeyEvent e) { event(""keyTyped"", e); }
	public void keyPressed(KeyEvent e) { event(""keyPressed"", e); }
	public void keyReleased(KeyEvent e) { event(""keyReleased"", e); }
	public void mouseClicked(MouseEvent e) { event(""mouseClicked"", e); }
	public void mousePressed(MouseEvent e) { event(""mousePressed"", e); }
	public void mouseReleased(MouseEvent e) { event(""mouseReleased"", e); }
	public void mouseEntered(MouseEvent e) { event(""mouseEntered"", e); }
	public void mouseExited(MouseEvent e) { event(""mouseExited"", e); }
	public void mouseDragged(MouseEvent e) { event(""mouseDragged"", e); }
	public void mouseMoved(MouseEvent e) { event(""mouseMoved"", e); }
	public void textValueChanged(TextEvent e) { event(""textValueChanged"", e); }
	public void windowOpened(WindowEvent e) { event(""windowOpened"", e); }
	public void windowClosing(WindowEvent e) { event(""windowClosing"", e); }
	public void windowClosed(WindowEvent e) { event(""windowClosed"", e); }
	public void windowIconified(WindowEvent e) { event(""windowIconified"", e); }
	public void windowDeiconified(WindowEvent e) { event(""windowDeiconified"", e); }
	public void windowActivated(WindowEvent e) { event(""windowActivated"", e); }
	public void windowDeactivated(WindowEvent e) { event(""windowDeactivated"", e); }
	public void propertyChange(PropertyChangeEvent e) { 
		event(""propertyChange"", e ); }
    public void vetoableChange(PropertyChangeEvent e) {
		event(""vetoableChange"", e ); }
    public boolean imageUpdate(java.awt.Image img, int infoflags,
                               int x, int y, int width, int height) {
		BshMethod method = namespace.getMethod( ""imageUpdate"",
			new Class [] { null, null, null, null, null, null } );
		if(method != null)
			try {
				method.invokeDeclaredMethod( 
					new Object[] { 
						img, new Primitive(infoflags), new Primitive(x), 
						new Primitive(y), new Primitive(width), 
						new Primitive(height) }, 
					declaringInterpreter, callstack, null
				);
			} catch(EvalError e) {
				declaringInterpreter.error(
					""local event handler imageUpdate: method invocation error:"" + e );
			}
		return true;
	}
	/**
		For serialization.
		Note: this is copied from superclass... 
		It must be private, but we can probably add an accessor to allow
		us to call the super method explicitly.
		Just testing to see if this is causing a problem.
	*/
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException {
		// Temporarily prune the namespace.
		NameSpace parent = namespace.getParent();
		// Bind would set the interpreter, but it's possible that the parent
		// is null (it's the root).  So save it...
		Interpreter interpreter = declaringInterpreter;
		namespace.prune();
		s.defaultWriteObject();
		// put it back
		namespace.setParent( parent );
		declaringInterpreter = interpreter;
	}
}
"
bsh.LHS,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Field;
import java.util.Hashtable;
/**
	The left hand side in an assignment
	This is probably the most debatable design issue in bsh...
	Because of the way things started, the grammar splits on whether
	something is an LHS or not...  The alternative would be to wrap all
	objects in bsh, rather than just carrying types that might be used in
	an assignment.  Wrapping all objects, say, in a generalized BshObject 
	type, would also provide a nice place to put all the reflection stuff, 
	which is now static in bsh.Reflect
	Note: moving some stuff from Reflect to a BshObject, but not going
	as far as the above yet...
*/
class LHS implements ParserConstants, java.io.Serializable
{
	NameSpace nameSpace;
	static final int
		VARIABLE = 0,
		FIELD = 1,
		PROPERTY = 2,
		INDEX = 3;
	int type;
	String varName;
	String propName;
	Field field;
	Object object;
	int index;
	LHS(NameSpace nameSpace, String varName)
	{
		type = VARIABLE;
		this.varName = varName;
		this.nameSpace = nameSpace;
	}
	// Static field
	LHS(Field field)
	{
		type = FIELD;
		this.object = null;
		this.field = field;
	}
	// Object field
	LHS(Object object, Field field)
	{
		if(object == null)
			throw new NullPointerException(""constructed empty LHS"");
		type = FIELD;
		this.object = object;
		this.field = field;
	}
	// Object property
	LHS(Object object, String propName)
	{
		if(object == null)
			throw new NullPointerException(""constructed empty LHS"");
		type = PROPERTY;
		this.object = object;
		this.propName = propName;
	}
	// Array index
	LHS(Object array, int index)
	{
		if(array == null)
			throw new NullPointerException(""constructed empty LHS"");
		type = INDEX;
		this.object = array;
		this.index = index;
	}
	public Object getValue() throws EvalError
	{
		if(type == VARIABLE)
			return nameSpace.getVariable(varName);
		else if (type == FIELD)
			try {
				return field.get(object);
			}
			catch(IllegalAccessException e2) {
				throw new EvalError(""Can't read field: "" + field);
			}
		else if(type == PROPERTY)
			try {
				return Reflect.getObjectProperty(object, propName);
			}
			catch(ReflectError e) {
				Interpreter.debug(e.getMessage());
				throw new EvalError(""No such property: "" + propName);
			}
		else if(type == INDEX)
			try
			{
				return Reflect.getIndex(object, index);
			}
			catch(Exception e)
			{
				throw new EvalError(""Array access: "" + e);
			}
		throw new InterpreterError(""LHS type"");
	}
	public Object assign( Object val ) throws EvalError
	{
		if ( type == VARIABLE )
			nameSpace.setVariable(varName, val);
		else 
		if ( type == FIELD )
			try {
				if(val instanceof Primitive)
					val = ((Primitive)val).getValue();
				field.set(object, val);
				return val;
			}
			catch( NullPointerException e) {   
    			throw new EvalError(
					""LHS (""+field.getName()+"") not a static field."");
			}     
   			catch( IllegalAccessException e2) {   
				throw new EvalError(
					""LHS (""+field.getName()+"") can't access field."");
			}     
			catch( IllegalArgumentException e3) {
				throw new EvalError(
					""Argument type mismatch. ""
					+ (val == null ? ""null"" : val.getClass().getName())
					+ "" not assignable to field ""+field.getName());
			}
		else if(type == PROPERTY)
			if ( object instanceof Hashtable )
				((Hashtable)object).put(propName, val);
			else
				try {
					Reflect.setObjectProperty(object, propName, val);
				}
				catch(ReflectError e) {
					Interpreter.debug(""Assignment: "" + e.getMessage());
					throw new EvalError(""No such property: "" + propName);
				}
		else if(type == INDEX)
			try {
				Reflect.setIndex(object, index, val);
			} catch(TargetError e1) { // pass along target error
				throw e1;
			} catch(Exception e) {
				throw new EvalError(""Assignment: "" + e.getMessage());
			}
		return val;
	}
	public String toString() { return ""LHS""; }
}
"
bsh.Name,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.Array;
import java.util.Hashtable;
import java.io.*;
import java.lang.reflect.InvocationTargetException;
/**
	What's in a name?  I'll tell you...
	Name() is a somewhat ambiguous thing in the grammar and so is this.
	<p>
	This class is a name resolver.  It holds a possibly ambiguous dot 
	separated name and reference to a namespace in which it allegedly lives.  
	It provides methods that attempt to resolve the name to various types of 
	entities: e.g. an Object, a Class, a localy declared bsh method.
	<p>
	*** implementing ***
	Name objects are not to be constructed arbitrarily, but are to be 
	factoried by NameSpace.getNameResolver, which caches them subject to
	a namespace change.  This means that we can cache information about various
	types of resolution here.
*/
/*
	<strong>Implementation notes</strong>
	<pre>
	*** implementing ***
	Name objects are not to be constructed arbitrarily, but are to be 
	factoried by NameSpace.getNameResolver, which caches them subject to
	a namespace change.  This means that we can cache information about various
	types of resolution here.
	Note that we cannot simply cache any result, we must be smart about it.
	For example, the value of a variable may change between calls.  So we could	
	cache the knowledge that it is a variable, but must re-fetch the value
	each time.  We could even do cool optimizations such as knowing about
	'final' variables ;)
	Questions: how much will this actually buy us?  The simple cases are not
	expensive here, are they?  How often are long chains of names evaluated?
	*** implementing ***
	Threads:
	Thread safety: all of the work methods in this class must be synchronized
	because they share the internal intermediate evaluation state.
	Random note:
	In some ways Name wants to be a private inner class of NameSpace... 
	However it is used elsewhere as an absraction for objects which haven't
	been pinned down yet.  So it is exposed.
	Note on this.caller resolution:
	Although references like these do work:
		this.caller.caller.caller...   // works
	the equivalent using successive calls:
		// does *not* work
		for( caller=this.caller; caller != null; caller = caller.caller );
	is prohibited by the restriction that you can only call .caller on a 
	literal	this or caller reference.
	The effect is that magic caller reference only works through the current 
	'this' reference.
	The real explanation is that This referernces do not really know anything
	about their depth on the call stack.  It might even be hard to define
	such a thing...
	For those purposes we provide :
		this.callstack
	</pre>
*/
class Name implements java.io.Serializable
{
	// These do not change during evaluation
	public NameSpace namespace;
	String value = null;
	// ---------------------------------------------------------
	// The following instance variables mutate during evaluation and should
	// be reset by the reset() method where necessary
	// For evaluation
	private String evalName;		// text left to eval
	private Object evalBaseObject;	// base object for current eval
	private int callstackDepth;		// number of times eval hit 'this.caller'
	/** 
		The last round consume the literal 'this' reference (not super, 
		global, or another This type var).  We use this flag to support magic
		variables that can only be referenced through 'this.xxx', e.g.
		this.interpreter and this.caller;
	*/
	private boolean literalThisReference;
	/** 
		The last round consume the literal 'caller' reference (not super, 
		global, or another This type var).  This is used to limit references
		to .caller to only after a literal 'this' or compound '.caller'.
	*/
	private boolean literalCallerReference;
	//  
	//  End mutable instance variables.
	// ---------------------------------------------------------
	private void reset() {
		evalName = value;
		evalBaseObject = null;
		callstackDepth = 0;
		literalThisReference=false;
		literalCallerReference=false;
	}
	/**
		This constructor should *not* be used in general. 
		Use NameSpace getNameResolver() which supports caching.
		I wish I could make this ""friendly"" to just that class.
		@see NameSpace getNameResolver().
	*/
	public Name(NameSpace namespace, String s)
	{
		this.namespace = namespace;
		value = s;
	}
	/**
		Resolve possibly complex name to an object value.
		Throws EvalError on various failures.
		A null object value is indicated by a Primitive.NULL.
		A return type of Primitive.VOID comes from attempting to access
		an undefined variable.
		Some cases:
			myVariable
			myVariable.foo
			myVariable.foo.bar
			java.awt.GridBagConstraints.BOTH
			my.package.stuff.MyClass.someField.someField...
		Interpreter reference is necessary to allow resolution of 
		""this.interpreter"" magic field.
		CallStack reference is necessary to allow resolution of 
		""this.caller"" magic field.
		""this.callstack"" magic field.
	*/
	public Object toObject( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		return toObject( callstack, interpreter, false );
	}
	/**
		@see toObject()
		@param forceClass if true then resolution will only produce a class.
		This is necessary to disambiguate in cases where the grammar knows
		that we want a class; where in general the var path may be taken.
	*/
	synchronized public Object toObject( 
		CallStack callstack, Interpreter interpreter, boolean forceClass ) 
		throws EvalError
	{
		reset();
		Object obj = null;
		while( evalName != null )
			obj = consumeNextObjectField( callstack, interpreter, forceClass );
		if ( obj == null )
			throw new InterpreterError(""null value in toObject()"");
		return obj;
	}
	/**
		Get next prefixed object field component
	*/
	private Object consumeNextObjectField( 	
		CallStack callstack, Interpreter interpreter, boolean forceClass ) 
		throws EvalError
	{
		/*
			Is it a simple variable name?
			Doing this first gives the correct Java precedence for vars 
			vs. imported class names (at least in the simple case - see
			tests/precedence1.bsh).  It should also speed things up a bit.
		*/
		if ( (evalBaseObject == null && !isCompound(evalName) )
			&& !forceClass ) 
		{
			Object obj = resolveThisFieldReference( 
				callstack, namespace, interpreter, evalName, false );
			if ( obj != Primitive.VOID ) {
				evalName = null; // finished
				return evalBaseObject = obj;  // convention
			}
		}
		/*
			Is it a bsh script variable reference?
			If we're just starting the eval of name (no base object)
			or we're evaluating relative to a This reference check.
		*/
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass ) 
		{
			String varName = prefix(evalName, 1);
			Interpreter.debug(""trying to resolve variable: "" + varName);
			Object obj;
			if ( evalBaseObject == null ) {
				obj = resolveThisFieldReference( 
					callstack, namespace, interpreter, varName, false );
			} else {
				// null callstack, cannot be caller reference
				obj = resolveThisFieldReference( 
					callstack, ((This)evalBaseObject).namespace, 
					interpreter, varName, true );
			}
			if ( obj != Primitive.VOID ) 
			{
				// Resolved the variable
				Interpreter.debug( ""resolved variable: "" + varName + 
					"" in namespace: ""+namespace);
				evalName = suffix(evalName);
				return evalBaseObject = obj;
			}
		}
		/*
			Is it a class name?
			If we're just starting eval of name try to make it, else fail.
		*/
		if ( evalBaseObject == null ) {
			Interpreter.debug( ""trying class: "" + evalName);
			/*
				Keep adding parts until we have a class 
			*/
			Class clas = null;
			int i = 1;
			for(; i <= countParts(evalName); i++)
				if ( (clas = namespace.getClass(prefix(evalName, i))) != null )
					break;
			if( clas != null )  {
				evalName = suffix(evalName, countParts(evalName) - i);
				return ( evalBaseObject = new ClassIdentifier(clas) );
			}
			// not a class (or variable per above)
			Interpreter.debug( ""not a class, trying var prefix ""+evalName );
		}
		/*
			If we didn't find a class or variable name (or prefix) above
			there are two possibilities:
			- If we are a simple name then we can pass as a void variable 
			reference.
			- If we are compound then we must fail at this point.
		*/
		if ( evalBaseObject == null ) {
			if( !isCompound(evalName) ) {
				evalName = null; // finished
				return evalBaseObject = Primitive.VOID;  // convention
			} else
				throw new EvalError(
					""Class or variable not found:"" + evalName);
		}
		/*
			--------------------------------------------------------
			After this point we're definitely evaluating relative to
			a base object.
			--------------------------------------------------------
		*/
		/*
			Do some basic validity checks.
		*/
		if(evalBaseObject == Primitive.NULL) // previous round produced null
			throw new TargetError( ""Null Pointer while evaluating: ""
				+value, new NullPointerException() );
		if(evalBaseObject == Primitive.VOID) // previous round produced void
			throw new EvalError(
				""Undefined variable or class name while evaluating: ""+value);
		if(evalBaseObject instanceof Primitive)
			throw new EvalError(""Can't treat primitive like an object. ""+
			""Error while evaluating: ""+value);
		/* 
			Resolve relative to a class type
			static field, inner class, ?
		*/
		if ( evalBaseObject instanceof ClassIdentifier ) 
		{
			Class clas = ((ClassIdentifier)evalBaseObject).getTargetClass();
			String field = prefix(evalName, 1);
			Object obj = null;
			// static field?
			try {
//System.err.println(""Name call to getStaticField, class: ""
	//+clas+"", field:""+field);
				obj = Reflect.getStaticField(clas, field);
			} catch(ReflectError e) { }
			// inner class?
			if ( obj == null ) {
				String iclass = clas.getName()+""$""+field;
				Class c = namespace.getClass( iclass );
				if ( c != null )
					obj = new ClassIdentifier(c);
			}
			if ( obj == null )
				throw new EvalError(
					""No static field or inner class: "" + field + "" of "" + clas);
			evalName = suffix(evalName);
			return (evalBaseObject = obj);
		}
		/*
			If we've fallen through here we are no longer resolving to
			a class type.
		*/
		if ( forceClass )
			throw new EvalError( value +"" does not resolve to a class name."" );
		/* 
			Some kind of field access?
		*/
		String field = prefix(evalName, 1);
		/* length access on array? */
		if(field.equals(""length"") && evalBaseObject.getClass().isArray())
		{
			Object obj = new Primitive(Array.getLength(evalBaseObject));
			evalName = suffix(evalName);
			return (evalBaseObject = obj);
		}
		/* check for field on object */
		// Note: could eliminate throwing the exception somehow
		try
		{
			Object obj = Reflect.getObjectField(evalBaseObject, field);
			evalName = suffix(evalName);
			return (evalBaseObject = obj);
		}
		catch(ReflectError e) { /* not a field */ }
		// if we get here we have failed
		throw new EvalError(
			""Cannot access field: "" + field + "", on object: "" + evalBaseObject);
	}
	/**
		Resolve a variable relative to a This reference.
		This is the general variable resolution method, accomodating special
		fields from the This context.  Together the namespace and interpreter
		comprise the This context.  The callstack, if available allows for the
		this.caller construct.  
		Optionally interpret special ""magic"" field names: e.g. interpreter.
		@param callstack may be null, but this is only legitimate in special
		cases where we are sure resolution will not involve this.caller.
		@param namespace the namespace of the this reference (should be the
		same as the top of the stack?
	*/
	Object resolveThisFieldReference( 
		CallStack callstack, NameSpace thisNamespace, Interpreter interpreter, 
		String varName, boolean specialFieldsVisible ) 
		throws EvalError
	{
		Object obj = null;
		// preserve the state of the last round flags until the end
		boolean 
			wasThis = false,		
			wasCaller = false;
		if ( varName.equals(""this"") ) {
			// Hack! If the special fields are visible turn of further .this
			// prevent user from skipping to things like super.this.caller
			if ( specialFieldsVisible )
				throw new EvalError(""Redundant to call .this on This type"");
			obj = thisNamespace.getThis( interpreter );
			wasThis = true;
		} 
		if ( obj == null ) {
			if ( varName.equals(""super"") )
				obj = thisNamespace.getSuper().getThis( interpreter );
			else if ( varName.equals(""global"") )
				obj = thisNamespace.getGlobal().getThis( interpreter );
		}
		if ( obj == null && specialFieldsVisible ) {
			if (varName.equals(""namespace""))
				obj = thisNamespace;
			else if (varName.equals(""variables""))
				obj = thisNamespace.getVariableNames();
			else if (varName.equals(""methods""))
				obj = thisNamespace.getMethodNames();
			else if ( varName.equals(""interpreter"") )
				if ( literalThisReference )
					obj = interpreter;
				else
					throw new EvalError(
						""Can only call .interpreter on literal 'this'"");
		}
		if ( obj == null && specialFieldsVisible && varName.equals(""caller"") )
		{
			if ( literalThisReference || literalCallerReference ) 
			{
				// get the previous context (see notes for this class)
				if ( callstack == null )
					throw new InterpreterError(""no callstack"");
				obj = callstack.get( ++callstackDepth ).getThis( 
					interpreter ); 
			}
			else
				throw new EvalError(
				""Can only call .caller on literal 'this' or literal '.caller'"");
			wasCaller = true;
		}
		if ( obj == null && specialFieldsVisible 
			&& varName.equals(""callstack"") )
		{
			if ( literalThisReference ) 
			{
				// get the previous context (see notes for this class)
				if ( callstack == null )
					throw new InterpreterError(""no callstack"");
				obj = callstack;
			}
			else
				throw new EvalError(
				""Can only call .callstack on literal 'this'"");
		}
		if ( obj == null )
			obj = thisNamespace.getVariable(varName);
		literalThisReference = wasThis;
		literalCallerReference = wasCaller;
		return obj;
	}
	/**
		Check the cache, else use toObject() to try to resolve to a class
		identifier.  
		Throws EvalError on class not found...
	*/
	synchronized public Class toClass() throws EvalError 
	{
		reset();
		/* Try straightforward class name first */
		Class clas = namespace.getClass(evalName);
		if ( clas == null ) {
			/* 
				Try toObject() which knows how to work through inner classes
				and see what we end up with 
			*/
			Object obj = null;
			try {
				// Null interpreter and callstack references.
				// class only resolution should not require them.
				obj = toObject( null, null, true );  
			} catch ( EvalError  e ) { }; // couldn't resolve it
			if ( obj instanceof ClassIdentifier )
				clas = ((ClassIdentifier)obj).getTargetClass();
		}
		if( clas == null )
			throw new EvalError(
				""Class: "" + value+ "" not found in namespace"");
		return clas;
	}
	/*
	*/
	synchronized public LHS toLHS( 
		CallStack callstack, Interpreter interpreter )
		throws EvalError
	{
		reset();
		//Interpreter.debug(""Name toLHS: ""+evalName+ "" isCompound = ""
			//+isCompound(evalName));
		// variable
		if(!isCompound(evalName)) {
			//Interpreter.debug(""returning simple var LHS..."");
			return new LHS(namespace,evalName);
		}
		// field
		Object obj = null;
		try
		{
			while(isCompound(evalName))
				obj = consumeNextObjectField( callstack, interpreter, false );
		}
		catch( EvalError e )
		{
			throw new EvalError(""LHS evaluation: "" + e);
		}
		if ( obj == null )
			throw new InterpreterError(""internal error 2893749283"");
		if(obj instanceof This)
		{
			Interpreter.debug(""found This reference evaluating LHS"");
			return new LHS(((This)obj).namespace, evalName);
		}
		if(evalName != null)
		{
			try
			{
//System.err.println(""Name getLHSObjectField call obj = ""
//	+obj+"", name=""+evalName);
				if ( obj instanceof ClassIdentifier ) 
				{
					Class clas = ((ClassIdentifier)obj).getTargetClass();
					return Reflect.getLHSStaticField(clas, evalName);
				} else
					return Reflect.getLHSObjectField(obj, evalName);
			} catch(ReflectError e)
			{
				throw new EvalError(""Field access: ""+e);
			}
		}
		throw new InterpreterError(""Internal error in lhs..."");
	/*
	This appears to have been something very old and incorrect...
	I don't think we need it anymore.
		// We bit off our field in the very first bite
		// have to back off and make a class out of the prefix
		Interpreter.debug(""very first field was it..."");
		Class clas = namespace.getClass(prefix(value));
		if(clas == null)
			throw new InterpreterError(""internal error 238974983"");
		String field = suffix(value, 1);
		try
		{
			return Reflect.getLHSStaticField(clas, field);
		}
		catch(ReflectError e)
		{
			Interpreter.debug(""reflect error:"" + e);
			return null;
		}
	*/
	}
	private BshMethod toLocalMethod( Object [] args )
	{
		Class [] sig = Reflect.getTypes( args );
		return namespace.getMethod( value, sig );
	}
    /**
		Invoke the method identified by name.
        Name contains a wholely unqualfied messy name; resolve it to 
		( object | static prefix ) + method name and invoke.
        The interpreter is necessary to support 'this.interpreter' references
		in the called code. (e.g. debug());
        Some cases:
            // dynamic
            local();
            myVariable.foo();
            myVariable.bar.blah.foo();
            // static
            java.lang.Integer.getInteger(""foo"");
    */
    public Object invokeMethod(
		Interpreter interpreter, Object[] args, CallStack callstack,
		SimpleNode callerInfo
	)
        throws EvalError, ReflectError, InvocationTargetException
    {
        if ( !Name.isCompound(value) )
            return invokeLocalMethod(interpreter, args, callstack, callerInfo);
        // find target object
        Name targetName = namespace.getNameResolver( Name.prefix(value));
        String methodName = Name.suffix(value, 1);
        Object obj = targetName.toObject( callstack, interpreter );
		if ( obj == Primitive.VOID ) 
			throw new EvalError( ""Attempt to invoke method: ""+methodName
					+""() on undefined variable or class name: ""+targetName);
        // if we've got an object, invoke the method
        if ( !(obj instanceof Name.ClassIdentifier) ) {
            if (obj instanceof Primitive) {
                if (obj == Primitive.NULL)
                    throw new TargetError( ""Null Pointer in Method Invocation"",
					new NullPointerException() );
                // some other primitive
                // should avoid calling methods on primitive, as we do
                // in Name (can't treat primitive like an object message)
                // but the hole is useful right now.
                interpreter.error(""Attempt to access method on primitive..."" +
                    "" allowing bsh.Primitive to peek through for debugging"");
            }
            // found an object and it's not an undefined variable
            return Reflect.invokeObjectMethod(
				interpreter, obj, methodName, args, callerInfo);
        }
        // try static method
        Interpreter.debug(""invokeMethod: trying static - "" + targetName);
        Class clas = ((Name.ClassIdentifier)obj).getTargetClass();
        if (clas != null)
            return Reflect.invokeStaticMethod(clas, methodName, args);
        // return null; ???
		throw new EvalError(""unknown target: "" + targetName);
    }
	/**
		Invoke a locally declared method or a bsh command.
		If the method is not already declared in the namespace then try
		to load it as a resource from the /bsh/commands path.
		Note: instead of invoking the method directly here we should probably
		call invokeObjectMethod passing a This reference.  That would have
		the side effect of allowing a locally defined invoke() method to
		handle undeclared method invocations just like in objects.  Not sure
		if this is desirable...  It seems that if you invoke a method directly
		in scope it should be there.
		Keeping this code separate allows us to differentiate between methods
		invoked directly in scope and those invoked through object references.
	*/
    public Object invokeLocalMethod( 
		Interpreter interpreter, Object[] args, CallStack callstack,
		SimpleNode callerInfo
	)
        throws EvalError, ReflectError, InvocationTargetException
    {
        Interpreter.debug(""invoke local method: "" + value);
        // Check for locally declared method
        BshMethod meth = toLocalMethod( args );
        if ( meth != null )
            return meth.invokeDeclaredMethod( args, interpreter, callstack, callerInfo );
        else
            Interpreter.debug(""no locally declared method: "" + value);
        /*
			Look for scripted command as resource
		*/
		// Why not /bsh/commands here?  Why relative to Interpreter?
        String commandName = ""commands/"" + value + "".bsh"";
        InputStream in = Interpreter.class.getResourceAsStream(commandName);
        if (in != null)
        {
            Interpreter.debug(""loading resource: "" + commandName);
			if ( interpreter == null )
				throw new InterpreterError(""2234432 interpreter = null"");
            interpreter.eval( 
				new InputStreamReader(in), namespace, commandName);
            // try again
            meth = toLocalMethod( args );
            if(meth != null)
                return meth.invokeDeclaredMethod( 
					args, interpreter, callstack, callerInfo );
            else
                throw new EvalError(""Loaded resource: "" + commandName +
                    ""had an error or did not contain the correct method"");
        }
        // check for compiled bsh command class
        commandName = ""bsh.commands."" + value;
        // create class outside of any namespace
        Class c = BshClassManager.classForName( commandName );
        if(c == null)
            throw new EvalError(""Command not found: "" + value);
        // add interpereter and namespace to args list
        Object[] invokeArgs = new Object[args.length + 2];
        invokeArgs[0] = interpreter;
        invokeArgs[1] = namespace;
        System.arraycopy(args, 0, invokeArgs, 2, args.length);
        try
        {
            return Reflect.invokeStaticMethod(c, ""invoke"", invokeArgs);
        }
        catch(ReflectError e)
        {
            Interpreter.debug(""invoke command args error:"" + e);
            // bad args
        }
        // try to print help
        try
        {
            String s = (String)Reflect.invokeStaticMethod(c, ""usage"", null);
            interpreter.println(s);
            return Primitive.VOID;
        }
        catch(ReflectError e)
        {
            Interpreter.debug(""usage threw: "" + e);
            throw new EvalError(""Wrong number or type of args for command"");
        }
    }
	// Static methods that operate on compound ('.' separated) names
	static boolean isCompound(String value)
	{
		return countParts(value) > 1;
	}
	static int countParts(String value)
	{
		if(value == null)
			return 0;
		int count = 0;
		int index = -1;
		while((index = value.indexOf('.', index + 1)) != -1)
			count++;
		return count + 1;
	}
	static String prefix(String value)
	{
		if(!isCompound(value))
			return null;
		return prefix(value, countParts(value) - 1);
	}
	static String prefix(String value, int parts)
	{
		if(parts < 1)
			return null;
		int count = 0;
		int index = -1;
		while(((index = value.indexOf('.', index + 1)) != -1) && (++count < parts))
		{ ; }
		return (index == -1) ? value : value.substring(0, index);
	}
	static String suffix(String name)
	{
		if(!isCompound(name))
			return null;
		return suffix(name, countParts(name) - 1);
	}
	public static String suffix(String value, int parts)
	{
		if(parts < 1)
			return null;
		int count = 0;
		int index = value.length() + 1;
		while(((index = value.lastIndexOf('.', index - 1)) != -1) && (++count < parts))
		{ ; }
		return (index == -1) ? value : value.substring(index + 1);
	}
	// end compound name routines
	public String toString() { return value; }
	static class ClassIdentifier {
		Class clas;
		public ClassIdentifier( Class clas ) {
			this.clas = clas;
		}
		public Class getTargetClass() {
			return clas;
		}
		public String toString() {
			return ""Class Identifier: ""+clas.getName();
		}
	}
}
"
bsh.NameSource,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.*;
/**
	This interface supports name completion, which is used primarily for 
	command line tools, etc.  It provides a flat source of ""names"" in a 
	space.  For example all of the classes in the classpath or all of the 
	variables in a namespace (or all of those).
	<p>
	NameSource is the lightest weight mechanism for sources which wish to
	support name completion.  In the future it might be better for NameSpace
	to implement NameCompletion directly in a more native and efficient 
	fasion.  However in general name competion is used for human interaction
	and therefore does not require high performance.
	<p>
	@see bsh.util.NameCompletion
	@see bsh.util.NameCompletionTable
*/
public interface NameSource 
{
	public String [] getAllNames();
	public void addNameSourceListener( NameSource.Listener listener );
	public static interface Listener {
		public void nameSourceChanged( NameSource src );
		/**
			Provide feedback on the progress of mapping a namespace
			@param msg is an update about what's happening
			@perc is an integer in the range 0-100 indicating percentage done
		public void nameSourceMapping( 
			NameSource src, String msg, int perc );
		*/
	}
}
"
bsh.NameSpace,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package	bsh;
import java.util.*;
import java.io.InputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
/**
    A namespace	in which methods and variables live.  This is package public 
	because it is used in the implementation of some bsh commands.  However
	for normal use you should be using methods on bsh.Interpreter to interact
	with your scripts.
	<p>
	A bsh.This object is a thin layer over a NameSpace.  Together they 
	comprise a bsh scripted object context.
	<p>
	Note: I'd really like to use collections here, but we have to keep this
	compatible with JDK1.1 
*/
public class NameSpace 
	implements java.io.Serializable, BshClassManager.Listener, 
	NameSource
{
	public static final NameSpace JAVACODE = 
		new NameSpace(""Called from compiled Java code"");
	public String name; 
    private NameSpace parent;
    private Hashtable variables;
    private Hashtable methods;
    private Hashtable importedClasses;
    private This thisReference;
    private Vector importedPackages;
	//String debugInfo;
	/** ""import *;"" operation has been performed */
	transient private static boolean superImport;
	// Local class cache for classes resolved through this namespace using
	// getClass() (taking into account imports)
    transient private Hashtable classCache;
    public NameSpace( String name ) { 
		this( null, name );
	}
    public NameSpace( NameSpace parent, String name ) {
		setName(name);
		setParent(parent);
		// Register for notification of classloader change
		BshClassManager.addCMListener(this);
    }
	public void setName( String name ) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	SimpleNode callerInfoNode;
	/**
		Set the node associated with the creation of this namespace.
		This is used in debugging.
	*/
	void setNode( SimpleNode node ) {
		this.callerInfoNode= node;
	}
	SimpleNode getNode() {
		return this.callerInfoNode;
	}
	/**
		Resolve name to an object through this namespace.
	*/
	public Object get( String name, Interpreter interpreter ) 
		throws EvalError 
	{
		CallStack callstack = new CallStack();
		return getNameResolver( name ).toObject( callstack, interpreter );
	}
	/**
		Set a variable in this namespace.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to set variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
		@param value a value of null will remove the variable definition.
	*/
    public void	setVariable(String name, Object	value) throws EvalError 
	{
		if ( variables == null )
			variables =	new Hashtable();
		// hack... should factor this out...
		if ( value == null ) {
			variables.remove(name);
			return;
		}
		// Locate the variable definition if it exists
		// if strictJava then recurse, else default local scope
		boolean recurse = Interpreter.strictJava;
		Object current = getVariableImpl( name, recurse );
//if ( Interpreter.strictJava )
//System.err.println(""recursing, found: ""+current);
		//Object current = variables.get(name);
		// found a typed variable
		if ( (current != null) && (current instanceof TypedVariable) )
		{
//System.err.println(""found typed var: ""+current);
			try {
				((TypedVariable)current).setValue(value);
			} catch(EvalError e) {
				throw new EvalError(
					""Typed variable: "" + name + "": "" + e.getMessage());
			} 
		} else
			if ( Interpreter.strictJava )
				throw new EvalError(
					""(Strict Java mode) Assignment to undeclared variable: ""
					+name );
			else {
//System.err.println(""untyped assignment: ""+name);
				variables.put(name, value);
			}
    }
	/**
		Get the names of variables defined in this namespace.
		(This does not show variables in parent namespaces).
	*/
	public String [] getVariableNames() {
		if ( variables == null )
			return new String [0];
		else
			return enumerationToStringArray( variables.keys() );
	}
	/**
		Get the names of methods defined in this namespace.
		(This does not show methods in parent namespaces).
	*/
	public String [] getMethodNames() {
		if ( methods == null )
			return new String [0];
		else
			return enumerationToStringArray( methods.keys() );
	}
	private String [] enumerationToStringArray( Enumeration e ) {
		Vector v = new Vector();
		while ( e.hasMoreElements() )
			v.addElement( e.nextElement() );
		String [] sa = new String [ v.size() ];
		v.copyInto( sa );
		return sa;
	}
	/**
		Get the parent namespace.
		Note: this isn't quite the same as getSuper().
		getSuper() returns 'this' if we are at the root namespace.
	*/
	public NameSpace getParent() {
		return parent;
	}
    public NameSpace getSuper()
    {
		if(parent != null)
			return parent;
		else
			return this;
    }
    public NameSpace getGlobal()
    {
		if(parent != null)
			return parent.getGlobal();
		else
			return this;
    }
	/**
		A This object is a thin layer over a namespace, comprising a bsh object
		context.  We create it here only if needed for the namespace.
		Note: that This is factoried for different capabilities.  When we
		add classpath modification we'll have to have a listener here to
		uncache the This reference and allow it to be refactoried.
	*/
    This getThis( Interpreter declaringInterpreter ) {
		if ( thisReference == null )
			thisReference = This.getThis( this, declaringInterpreter );
		return thisReference;
    }
	/**
		Used for serialization
	*/
	public void prune() {
		parent = null;
	/*
	Do we need this?
	If so, fix the loop... can get Vectors of methods as well as methods
		if ( methods != null )
			// Prune the methods of this namespace - detach the nodes
			// from their parent nodes. 
			for( Enumeration e=methods.elements(); e.hasMoreElements(); )
				((BshMethod)e.nextElement()).method.prune();
	*/
	}
	public void setParent( NameSpace parent ) {
		this.parent = parent;
	}
	/**
		Get the specified variable in this namespace or a parent namespace.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to use 
		Primitive.unwrap() to get primitive values.
		@see Primitive.unwrap()
		@return The variable value or Primitive.VOID if it is not defined.
	*/
    public Object getVariable( String name ) {
		return getVariable( name, true );
	}
	/**
		Get the specified variable in this namespace.
		If recurse is true extend search through parent namespaces.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to use 
		Primitive.unwrap() to get primitive values.
		@see Primitive.unwrap()
		@return The variable value or Primitive.VOID if it is not defined.
	*/
    public Object getVariable( String name, boolean recurse ) {
		Object val = getVariableImpl( name, recurse );
		return unwrapVariable( val );
    }
	/**
		Unwrap a typed variable to its value.
		Turn null into Primitive.VOID
	*/
	protected Object unwrapVariable( Object val ) {
		if (val instanceof TypedVariable)
			val	= ((TypedVariable)val).getValue();
		return (val == null) ? Primitive.VOID :	val;
	}
	/**
		Return the raw variable retrieval (TypedVariable object or for untyped
		the simple value) with optional recursion.
		@return the raw variable value or null if it is not defined
	*/
    protected Object getVariableImpl( String name, boolean recurse ) {
		Object val = null;
		if(variables !=	null)
			val	= variables.get(name);
		if ( recurse && (val == null) && (parent != null) )
			val	= parent.getVariableImpl(name, recurse);
//System.err.println(""getVarImpl name: ""+name+"", val =""+val);
		return val;
    }
    /**
		Set the typed variable with the value.  
		An existing typed variable may only be set to the same type.
		If an untyped variable exists it will be overridden with the new
		typed var.
		The set will perform a getAssignableForm() on the value if necessary.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to set variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
		@param value If value is null, you'll get the default value for the type
    */
    public void	setTypedVariable(
		String	name, Class type, Object value,	boolean	isFinal) 
		throws EvalError 
	{
		if (variables == null)
			variables =	new Hashtable();
		if (value == null)
		{
			// initialize variable to appropriate default value	- JLS 4.5.4
			if(type.isPrimitive())
			{
			if(type	== Boolean.TYPE)
				value = new	Primitive(Boolean.FALSE);
			else if(type ==	Byte.TYPE)
				value = new	Primitive((byte)0);
			else if(type ==	Short.TYPE)
				value = new	Primitive((short)0);
			else if(type ==	Character.TYPE)
				value = new	Primitive((char)0);
			else if(type ==	Integer.TYPE)
				value = new	Primitive((int)0);
			else if(type ==	Long.TYPE)
				value = new	Primitive(0L);
			else if(type ==	Float.TYPE)
				value = new	Primitive(0.0f);
			else if(type ==	Double.TYPE)
				value = new	Primitive(0.0d);
			}
			else
				value =	Primitive.NULL;
		}
		// does the variable already exist?
		if ( variables.containsKey(name) ) 
		{
			Object existing = getVariableImpl( name, false );
			// is it typed?
			if ( existing instanceof TypedVariable ) 
			{
				// if it had a different type throw error
				if ( ((TypedVariable)existing).getType() != type )
					throw new EvalError( ""Typed variable: ""+name
						+"" was previously declared with type: "" 
						+ ((TypedVariable)existing).getType() );
				else {
					// else set it and return
					((TypedVariable)existing).setValue( value );
					return;
				}
			}
			// else fall through to override and install the new typed version
		} 
		// add the new typed var
		variables.put(name, new	TypedVariable(type, value, isFinal));
    }
	/**
		Note: this is primarily for internal use.
		@see Interpreter.source()
		@see Interpreter.eval()
	*/
    public void	setMethod(String name, BshMethod method) 
	{
		if(methods == null)
			methods = new Hashtable();
		Object m = methods.get(name);
		if ( m == null )
			methods.put(name, method);
		else 
		if ( m instanceof BshMethod ) {
			Vector v = new Vector();
			v.addElement( m );
			v.addElement( method );
			methods.put( name, v );
		} else // Vector
			((Vector)m).addElement( method );
    }
	/**
		Get the bsh method matching the specified signature declared in 
		this name space or a parent.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to be familiar
		with BeanShell's use of the Primitive wrapper class.
		@see bsh.Primitive
	*/
    public BshMethod getMethod( String name, Class [] sig ) 
	{
		BshMethod method = null;
		Object m = null;
		if ( methods != null )
			m = methods.get(name);
		if ( m instanceof Vector ) {
			Vector vm = (Vector)m;
			BshMethod [] ma = new BshMethod[ vm.size() ];
			vm.copyInto( ma );
			Class [][] candidates = new Class[ ma.length ][];
			for( int i=0; i< ma.length; i++ )
				candidates[i] = ma[i].getArgTypes();
			int match = Reflect.findMostSpecificSignature( sig, candidates );
			if ( match != -1 )
				method = ma[match];
		} else
			method = (BshMethod)m;
		if ((method == null) && (parent != null))
			return parent.getMethod( name, sig );
		return method;
    }
	/**
		Import a class name.
		Subsequent imports override earlier ones
	*/
    public void	importClass(String name)
    {
		if(importedClasses == null)
			importedClasses = new Hashtable();
		importedClasses.put(Name.suffix(name, 1), name);
		nameSpaceChanged();
    }
    private String getImportedClass(String name)
		throws ClassPathException
    {
		String s = null;
		// try imported in our space
		if ( importedClasses != null )
			s =	(String)importedClasses.get(name);
		// try imported in our parent's space
		if ((s == null) && (parent != null) )
			return (String)parent.getImportedClass(name);
		return s;
    }
	/**
		subsequent imports override earlier ones
	*/
    public void	importPackage(String name)
    {
		if(importedPackages == null)
			importedPackages = new Vector();
		importedPackages.addElement(name);
		nameSpaceChanged();
    }
	/**
		Get a list of all imported packages including parents.
		in the order in which they were imported...
		Note that the resolver may use them in the reverse order for
		precedece reasons.
	*/
    public String[] getImportedPackages()
    {
		Vector v = new Vector();
		// add parent's
		if ( parent != null ) {
			String [] psa = parent.getImportedPackages();
			for(int i=0; i<psa.length; i++)
				v.addElement(psa[i]);
		}
		// add ours
		if ( importedPackages != null )
			for(int i=0; i< importedPackages.size(); i++)
				v.addElement( importedPackages.elementAt(i) );
		String[] packages = new	String[ v.size() ];
		v.copyInto(packages);
		return packages;
    }
	/**
		Load class through this namespace, taking into account imports.
		Notes: This method does the caching for getClassImpl().
		The lazy instantiation of cache here parallels that in get()
	*/
    public Class getClass(String name)
		throws ClassPathException
    {
		Class c	= null;
		if(classCache != null)
			c =	(Class)classCache.get(name);
		if(c ==	null) {
			c =	getClassImpl( name );
			if(c != null) {
				if(classCache == null)
					classCache = new Hashtable();
				classCache.put(name, c);
			}
		}
		return c;
    }
	/**
		Implementation for getClass()
		If not a compound name look for imported class or package.
		Else try to load name.
	*/
    private Class getClassImpl( String name)
		throws ClassPathException
    {
		// Simple (non compound name) check if imported
		if ( !Name.isCompound(name) )
		{
			String fullname = getImportedClass(name);
			if ( fullname != null ) 
			{
				/*
					Found the full name in imported classes.
				*/
				// Try to make the full imported name
				Class clas=classForName(fullname);
				// If the imported name we found is compound, try to resolve
				// to an inner class.  
				if ( clas == null ) 
				{
					if ( Name.isCompound( fullname ) )
						try {
							clas = getNameResolver( fullname ).toClass();
						} catch ( EvalError e ) { /* not a class */ }
					else 
						Interpreter.debug(
							""imported unpackaged name not found:"" +fullname);
				}
				// Found something?  Cache the class and return it.
				if ( clas != null ) {
					// (should we cache info in not a class case too?)
					BshClassManager.cacheClassInfo( fullname, clas );
					return clas;
				}
				// It was explicitly imported, but we don't know what it is.
				// should we throw an error here??
				return null;  
			}
			/*
				Try imported packages (.*)
				in reverse order of import...
				(give later imports precedence...)
			*/
			String[] packages =	getImportedPackages();
			//for(int i=0; i<packages.length; i++)
			for(int i=packages.length-1; i>=0; i--)
			{
				String s = packages[i] + ""."" + name;
				Class c=classForName(s);
				if ( c != null )
					return c;
			}
			/*
				Try super imported if available
				Note: we do this last to allow explicitly imported classes
				and packages to take priority.  This method will also throw an
				error indicating ambiguity if it exists...
			*/
			if ( superImport ) {
				BshClassManager bcm = BshClassManager.getClassManager();
				if ( bcm != null ) {
					String s = bcm.getClassNameByUnqName( name );
					if ( s != null )
						return classForName( s );
				}
			}
		}
		Class c = classForName( name );
		if ( c != null )
			return c;
		Interpreter.debug(""getClass(): "" + name	+ "" not	found in ""+this);
		return null;
    }
	private Class classForName( String name ) 
	{
		return BshClassManager.classForName( name );
	}
	/**
		Implements NameSource
		@return all class and variable names in this and all parent
		namespaces
	*/
	public String [] getAllNames() 
	{
		Vector vec = new Vector();
		getAllNamesAux( vec );
		String [] names = new String [ vec.size() ];
		vec.copyInto( names );
		return names;
	}
	/**
		Helper for implementing NameSource
	*/
	protected void getAllNamesAux( Vector vec ) 
	{
		Enumeration varNames = variables.keys();
		while( varNames.hasMoreElements() )
			vec.addElement( varNames.nextElement() );
		Enumeration methodNames = methods.keys();
		while( methodNames.hasMoreElements() )
			vec.addElement( methodNames.nextElement() );
		if ( parent != null )
			parent.getAllNamesAux( vec );
	}
	Vector nameSourceListeners;
	/**
		Implements NameSource
		Add a listener who is notified upon changes to names in this space.
	*/
	public void addNameSourceListener( NameSource.Listener listener ) {
		if ( nameSourceListeners == null )
			nameSourceListeners = new Vector();
		nameSourceListeners.addElement( listener );
	}
	/**
		Perform ""import *;"" causing the entire classpath to be mapped.
		This can take a while.
	*/
	public static void doSuperImport() 
		throws EvalError
	{
		BshClassManager bcm = BshClassManager.getClassManager();
		if ( bcm != null )
			bcm.doSuperImport();
		superImport = true;
	}
    static class TypedVariable implements java.io.Serializable 
	{
		Class type;
		Object value = null; // uninitiailized
		boolean	isFinal;
		TypedVariable(Class type, Object value,	boolean	isFinal)
			throws EvalError
		{
			this.type =	type;
			if ( type == null )
				throw new InterpreterError(""null type in typed var: ""+value);
			this.isFinal = isFinal;
			setValue( value );
		}
		/**
			Set the value of the typed variable.
		*/
		void setValue(Object val) throws EvalError
		{
			if ( isFinal && value != null )
				throw new EvalError (""Final variable, can't assign"");
			// do basic assignability check
			val = getAssignableForm(val, type);
			// If we are a numeric primitive type we want to convert to the 
			// actual numeric type of this variable...  Being assignable is 
			// not good enough.
			if ( val instanceof Primitive && ((Primitive)val).isNumber() )
				try {
					val = BSHCastExpression.castPrimitive( 
						(Primitive)val, type );
				} catch ( EvalError e ) {
					throw new InterpreterError(""auto assignment cast failed"");
				}
			this.value= val;
		}
		Object getValue() { return value; }
		Class getType() { return type;	}
		public String toString() { 
			return ""TypedVariable: ""+type+"", value:""+value;
		}
    }
	/**
		@deprecated name changed.
		@see getAssignableForm()
	*/
    public static Object checkAssignableFrom(Object rhs, Class lhsType)
		throws EvalError
    {
		return getAssignableForm( rhs, lhsType );
	}
	/**
		<p>
		Determine if the RHS object can be assigned to the LHS type (as is,
		through widening, promotion, etc. ) and if so, return the 
		assignable form of the RHS.  Note that this is *not* a cast operation.
		Only assignments which are always legal (upcasts, promotion) are 
		passed.
		<p>
		In normal cases this functions as a simple check for assignability
		and the value is returned unchanged.  e.g. a String is assignable to
		an Object, but no conversion is necessary.  Similarly an int is 
		assignable to a long, so no conversion is done.
		In this sense assignability is in terms of what the Java reflection API
		will allow since the reflection api will do widening conversions in the 
		case of sets on fields and arrays.
		<p>
		The primary purpose of the abstraction ""returning the assignable form""			abstraction is to allow non standard bsh assignment conversions. e.g.
		the wrapper stuff.  I'm still not sure how much of that we should
		be doing.
		<p>
		This method is used in many places throughout bsh including assignment
		operations and method selection.
		<p>
		@returns an assignable form of the RHS or throws EvalError
		@throws EvalError on non assignable
		@see BSHCastExpression.castObject();
	*/
	/*
		Notes:
		Need to define the exact behavior here:
			Does this preserve Primitive types to Primitives, etc.?
		This is very confusing in general...  need to simplify and clarify the
		various places things are happening:
			Reflect.isAssignableFrom()
			Primitive?
			here?
	*/
    static Object getAssignableForm(Object rhs, Class lhsType)
		throws EvalError
    {
		Class originalType;
		if ( lhsType == null )
			throw new InterpreterError(
				""Null value for type in getAssignableForm"");
		if(rhs == null)
			throw new InterpreterError(""Null value in getAssignableForm."");
		if(rhs == Primitive.VOID)
			throw new EvalError( ""Undefined variable or class name"");
		if (rhs == Primitive.NULL)
			if(!lhsType.isPrimitive())
				return rhs;
			else
				throw new EvalError(
					""Can't assign null to primitive type "" + lhsType.getName());
		Class rhsType;
		if ( rhs instanceof Primitive ) 
		{
			// set the rhsType to the type of the primitive
			rhsType = originalType = ((Primitive)rhs).getType();
			// check for primitive/non-primitive mismatch
			if ( lhsType.isPrimitive() ) {
				// not doing this yet...  leaving as the assignable orig type
				/*
					We have two primitive types.  If Reflect.isAssignableFrom()
					which knows about primitive widening conversions says they
					are assignable, we will do a cast to change the value
				if ( Reflect.isAssignableFrom(
					((Primitive)lhs).getType(), ((Primitive)rhs).getType() )
				*/
			} else
			{
				// attempt promotion to	a primitive wrapper
				// if lhs a wrapper type, get the rhs as wrapper value
				// else error
				if( Boolean.class.isAssignableFrom(lhsType) ||
					Character.class.isAssignableFrom(lhsType) ||
					Number.class.isAssignableFrom(lhsType) )
				{
					rhs	= ((Primitive)rhs).getValue();
					// type is the wrapper class type
					rhsType = rhs.getClass();
				}
				else
					assignmentError(lhsType, originalType);
			}
		} else 
		{
			// set the rhs type
			rhsType = originalType = rhs.getClass();
			// check for primitive/non-primitive mismatch
			if ( lhsType.isPrimitive() ) {
				// attempt unwrapping wrapper class for assignment 
				// to a primitive
				if (rhsType == Boolean.class)
				{
					rhs	= new Primitive((Boolean)rhs);
					rhsType = Boolean.TYPE;
				}
				else if (rhsType == Character.class)
				{
					rhs	= new Primitive((Character)rhs);
					rhsType = Character.TYPE;
				}
				else if (Number.class.isAssignableFrom(rhsType))
				{
					rhs	= new Primitive((Number)rhs);
					rhsType = ((Primitive)rhs).getType();
				}
				else
					assignmentError(lhsType, originalType);
			}
		}
		// This handles both class types and primitive .TYPE types
		if ( Reflect.isAssignableFrom(lhsType, rhsType) )
			return rhs;
		/* 
			bsh extension -
			Attempt widening conversions as defined in JLS 5.1.2
			except perform them on primitive wrapper objects.
		*/
		if(lhsType == Short.class)
			if(rhsType == Byte.class)
				return new Short(((Number)rhs).shortValue());
		if(lhsType == Integer.class) {
			if(rhsType == Byte.class || rhsType == Short.class)
				return new Integer(((Number)rhs).intValue());
			if(rhsType == Character.class)
				return new Integer(((Number)rhs).intValue());
		}
		if(lhsType == Long.class) {
			if(rhsType == Byte.class || rhsType == Short.class ||
				rhsType == Integer.class)
				return new Long(((Number)rhs).longValue());
			if(rhsType == Character.class)
				return new Long(((Number)rhs).longValue());
		}
		if(lhsType == Float.class) {
			if(rhsType == Byte.class || rhsType == Short.class ||
				rhsType == Integer.class ||	rhsType	== Long.class)
				return new Float(((Number)rhs).floatValue());
			if(rhsType == Character.class)
				return new Float(((Number)rhs).floatValue());
		}
		if(lhsType == Double.class) {
			if(rhsType == Byte.class || rhsType == Short.class ||
				rhsType == Integer.class ||	rhsType	== Long.class ||
				rhsType == Float.class)
				return new Double(((Number)rhs).doubleValue());
			if(rhsType == Character.class)
				return new Double(((Number)rhs).doubleValue());
		}
		/*
			Bsh This objects may be able to use the proxy mechanism to 
			become an LHS type.
		*/
		if ( Capabilities.canGenerateInterfaces() && 
			lhsType.isInterface() && ( rhs instanceof bsh.This ) ) 
		{
			return ((bsh.This)rhs).getInterface( lhsType );
		}
		assignmentError(lhsType, originalType);
		return rhs;
    }
    private static void	assignmentError(Class lhs, Class rhs) throws EvalError
    {
		String lhsType = Reflect.normalizeClassName(lhs);
		String rhsType = Reflect.normalizeClassName(rhs);
		throw new EvalError (""Can't assign "" + rhsType + "" to ""	+ lhsType);
    }
	public String toString() {
		return
			""NameSpace: ""
			+ ( name==null
				? super.toString()
				: name + "" ("" + super.toString() +"")"" );
	}
	/*
		For serialization.
		Don't serialize non-serializable objects.
	*/
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException {
		// do something here
		s.defaultWriteObject();
	}
	/**
		Invoke a method in this namespace with the specified args and
		interpreter reference.  The caller namespace is set to this namespace.
		This is a convenience for users outside of this package.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to use variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
	*/
	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter ) 
		throws EvalError
	{
		return invokeMethod( methodName, args, interpreter, null, null );
	}
	/**
		invoke a method in this namespace with the specified args,
		interpreter reference, and callstack
		This is a convenience for users outside of this package.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to use variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@param if callStack is null a new CallStack will be created and
			initialized with this namespace.
		@see bsh.Primitive
	*/
	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter, 
		CallStack callstack, SimpleNode callerInfo ) 
		throws EvalError
	{
		if ( callstack == null ) {
			callstack = new CallStack();
			callstack.push( this );
		}
		// Look for method in the bsh object
        BshMethod meth = getMethod( methodName, Reflect.getTypes( args ) );
        if ( meth != null )
           return meth.invokeDeclaredMethod( args, interpreter, callstack, callerInfo );
		// Look for a default invoke() handler method
		meth = getMethod( ""invoke"", new Class [] { null, null } );
		// Call script ""invoke( String methodName, Object [] args );
		if ( meth != null )
			return meth.invokeDeclaredMethod( 
				new Object [] { methodName, args }, interpreter, callstack, callerInfo );
		throw new EvalError( ""No locally declared method: "" 
			+ methodName + "" in namespace: "" + this );
	}
	/**
		Clear all cached classes and names
	*/
	public void classLoaderChanged() {
		nameSpaceChanged();
	}
	/**
		Clear all cached classes and names
	*/
	public void nameSpaceChanged() {
		classCache = null;
	}
	/**
		Import standard packages.  Currently:
		<pre>
			importClass(""bsh.EvalError"");
			importPackage(""javax.swing.event"");
			importPackage(""javax.swing"");
			importPackage(""java.awt.event"");
			importPackage(""java.awt"");
			importPackage(""java.net"");
			importPackage(""java.util"");
			importPackage(""java.io"");
			importPackage(""java.lang"");
		</pre>
	*/
    public void loadDefaultImports()
    {
		/**
			Note: the resolver looks through these in reverse order, per
			precedence rules...  so for max efficiency put the most common
			ones later.
		*/
		importClass(""bsh.EvalError"");
		importPackage(""javax.swing.event"");
		importPackage(""javax.swing"");
		importPackage(""java.awt.event"");
		importPackage(""java.awt"");
		importPackage(""java.net"");
		importPackage(""java.util"");
		importPackage(""java.io"");
		importPackage(""java.lang"");
	/*
		String res = ""lib/defaultImports"";
		InputStream in = NameSpace.class.getResourceAsStream(res);
		if(in == null)
			throw new IOException(""couldn't load resource: "" + res);
		BufferedReader bin = new BufferedReader(new InputStreamReader(in));
		String s;
		try {
			while((s = bin.readLine()) != null)
			importPackage(s);
			bin.close();
		} catch(IOException e) {
			Interpreter.debug(""failed to load default imports..."");
		}
	*/
    }
	/**
		This is the factory for Name objects which resolve names within
		this namespace (e.g. toObject(), toClass(), toLHS()).
		This supports name resolver caching, allowing Name objects to 
		cache info about the resolution of names for performance reasons.
		(This would be called getName() if it weren't already used for the
		simple name of the NameSpace)
	*/
	Name getNameResolver( String name ) {
		// no caching yet
		return new Name(this,name);
	}
	public int getInvocationLine() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getLineNumber();
		else
			return -1;
	}
	public String getInvocationText() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getText();
		else
			return ""<invoked from Java code>"";
	}
	/**
		This is a helper method for working inside of bsh scripts and commands.
		In that context it is impossible to see a ClassIdentifier object
		for what it is.  Attempting to access a method on it will look like
		a static method invocation.
	*/
	public static Class identifierToClass( Name.ClassIdentifier ci ) 
	{
		return ci.getTargetClass();
	}
}
"
bsh.Node,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
/* Generated By:JJTree: Do not edit this line. Node.java */
package bsh;
/*
	All BSH nodes must implement this interface.  It provides basic
	machinery for constructing the parent and child relationships
	between nodes.
*/
interface Node extends java.io.Serializable
{
/**
	This method is called after the node has been made the current
	node.  It indicates that child nodes can now be added to it.
*/
	public void jjtOpen();
/**
	This method is called after all the child nodes have been
	added.
*/
	public void jjtClose();
/**
	This pair of methods are used to inform the node of its
	parent.
*/
	public void jjtSetParent(Node n);
	public Node jjtGetParent();
/**
	This method tells the node to add its argument to the node's
	list of children.
*/
	public void jjtAddChild(Node n, int i);
/**
	This method returns a child node.  The children are numbered
	from zero, left to right.
*/
	public Node jjtGetChild(int i);
/**
	Return the number of children the node has.
*/
	public int jjtGetNumChildren();
}
"
bsh.ParseException,"/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 0.7pre6 */
/* 	
	Note: Leave the ^M carriage return in the above auto-generated line or 
	JavaCC will complain about version on Win systems.
*/
/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package	bsh;
/*
	BeanShell - 
	Modified getMessage() to print more tersely.
	Removed the ""Was expecting one of...""
*/
/**
 * This	exception is thrown when parse errors are encountered.
 * You can explicitly create objects of	this exception type by
 * calling the method generateParseException in	the generated
 * parser.
 *
 * You can modify this class to	customize your error reporting
 * mechanisms so long as you retain the	public fields.
 */
class ParseException extends Exception {
  /**
   * This constructor is used by the method ""generateParseException""
   * in	the generated parser.  Calling this constructor	generates
   * a new object of this type with the	fields ""currentToken"",
   * ""expectedTokenSequences"", and ""tokenImage""	set.  The boolean
   * flag ""specialConstructor"" is also set to true to indicate that
   * this constructor was used to create this object.
   * This constructor calls its	super class with the empty string
   * to	force the ""toString"" method of parent class ""Throwable""	to
   * print the error message in	the form:
   *	 ParseException: <result of getMessage>
   */
  public ParseException(Token currentTokenVal,
			int[][]	expectedTokenSequencesVal,
			String[] tokenImageVal
		       )
  {
    super("""");
    specialConstructor = true;
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
  }
  /**
   * The following constructors	are for	use by you for whatever
   * purpose you can think of.	Constructing the exception in this
   * manner makes the exception	behave in the normal way - i.e., as
   * documented	in the class ""Throwable"".  The fields ""errorToken"",
   * ""expectedTokenSequences"", and ""tokenImage""	do not contain
   * relevant information.  The	JavaCC generated code does not use
   * these constructors.
   */
  public ParseException() {
    super();
    specialConstructor = false;
  }
  public ParseException(String message)	{
    super(message);
    specialConstructor = false;
  }
  /**
   * This variable determines which constructor	was used to create
   * this object and thereby affects the semantics of the
   * ""getMessage"" method (see below).
   */
  protected boolean specialConstructor;
  /**
   * This is the last token that has been consumed successfully.  If
   * this object has been created due to a parse error,	the token
   * followng this token will (therefore) be the first error token.
   */
  public Token currentToken;
  /**
   * Each entry	in this	array is an array of integers.	Each array
   * of	integers represents a sequence of tokens (by their ordinal
   * values) that is expected at this point of the parse.
   */
  public int[][] expectedTokenSequences;
  /**
   * This is a reference to the	""tokenImage"" array of the generated
   * parser within which the parse error occurred.  This array is
   * defined in	the generated ...Constants interface.
   */
  public String[] tokenImage;
  /**
   * This method has the standard behavior when	this object has	been
   * created using the standard	constructors.  Otherwise, it uses
   * ""currentToken"" and	""expectedTokenSequences"" to generate a parse
   * error message and returns it.  If this object has been created
   * due to a parse error, and you do not catch	it (it gets thrown
   * from the parser), then this method	is called during the printing
   * of	the final stack	trace, and hence the correct error message
   * gets displayed.
   */
  public String	getMessage() {
	return getMessage( true );
  }
  public String	getMessage( boolean debug ) {
    if (!specialConstructor) {
      return super.getMessage();
    }
    String expected = """";
    int	maxSize	= 0;
    for	(int i = 0; i <	expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
	maxSize	= expectedTokenSequences[i].length;
      }
      for (int j = 0; j	< expectedTokenSequences[i].length; j++) {
	expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0)	{
	expected += ""..."";
      }
      expected += eol +	""    "";
    }
    String retval = ""Encountered \"""";
    Token tok =	currentToken.next;
    for	(int i = 0; i <	maxSize; i++) {
      if (i != 0) retval += "" "";
      if (tok.kind == 0) {
	retval += tokenImage[0];
	break;
      }
      retval +=	add_escapes(tok.image);
      tok = tok.next;
    }
    retval += ""\"" at line "" + currentToken.next.beginLine + "", column ""	+ currentToken.next.beginColumn	+ ""."" +	eol;
	if ( debug ) {
		if (expectedTokenSequences.length == 1) {
		  retval +=	""Was expecting:"" + eol + ""    "";
		} else {
		  retval +=	""Was expecting one of:""	+ eol +	""    "";
		}
		retval += expected;
	}
    return retval;
  }
  /**
   * The end of	line string for	this machine.
   */
  protected String eol = System.getProperty(""line.separator"", ""\n"");
  /**
   * Used to convert raw characters to their escaped version
   * when these	raw version cannot be used as part of an ASCII
   * string literal.
   */
  protected String add_escapes(String str) {
      StringBuffer retval = new	StringBuffer();
      char ch;
      for (int i = 0; i	< str.length();	i++) {
	switch (str.charAt(i))
	{
	   case	0 :
	      continue;
	   case	'\b':
	      retval.append(""\\b"");
	      continue;
	   case	'\t':
	      retval.append(""\\t"");
	      continue;
	   case	'\n':
	      retval.append(""\\n"");
	      continue;
	   case	'\f':
	      retval.append(""\\f"");
	      continue;
	   case	'\r':
	      retval.append(""\\r"");
	      continue;
	   case	'\""':
	      retval.append(""\\\"""");
	      continue;
	   case	'\'':
	      retval.append(""\\\'"");
	      continue;
	   case	'\\':
	      retval.append(""\\\\"");
	      continue;
	   default:
	      if ((ch =	str.charAt(i)) < 0x20 || ch > 0x7e) {
		 String	s = ""0000"" + Integer.toString(ch, 16);
		 retval.append(""\\u"" + s.substring(s.length() -	4, s.length()));
	      }	else {
		 retval.append(ch);
	      }
	      continue;
	}
      }
      return retval.toString();
   }
}
"
bsh.Parser,"/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package bsh;
import java.io.Reader;
class Parser/*@bgen(jjtree)*/implements ParserTreeConstants, ParserConstants {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();
        void jjtreeOpenNodeScope(Node n) {
                ((SimpleNode)n).firstToken = getToken(1);
        }
        void jjtreeCloseNodeScope(Node n) {
                ((SimpleNode)n).lastToken = getToken(0);
        }
        /**
		Re-initialize the input stream and token source.
	*/
        void reInitInput( Reader in ) {
                ReInit(in);
        }
        /**
		Explicitly re-initialize just the token reader.
		This seems to be necessary to avoid certain looping errors when
		reading bogus input.  See Interpreter.
	*/
        void reInitTokenInput( Reader in ) {
                jj_input_stream.ReInit( in,
                        jj_input_stream.getEndLine(),
                        jj_input_stream.getEndColumn() );
        }
  final public boolean Line() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 0:
      jj_consume_token(0);
        Interpreter.debug(""End of File!"");
        {if (true) return true;}
      break;
    case BOOLEAN:
    case BREAK:
    case BYTE:
    case CHAR:
    case CONTINUE:
    case DO:
    case DOUBLE:
    case FALSE:
    case FINAL:
    case FLOAT:
    case FOR:
    case IF:
    case IMPORT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case RETURN:
    case SHORT:
    case SWITCH:
    case THROW:
    case TRUE:
    case TRY:
    case VOID:
    case WHILE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case LBRACE:
    case SEMICOLON:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      if (jj_2_1(2147483647)) {
        Expression();
        jj_consume_token(SEMICOLON);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BREAK:
        case BYTE:
        case CHAR:
        case CONTINUE:
        case DO:
        case DOUBLE:
        case FALSE:
        case FINAL:
        case FLOAT:
        case FOR:
        case IF:
        case IMPORT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case RETURN:
        case SHORT:
        case SWITCH:
        case THROW:
        case TRUE:
        case TRY:
        case VOID:
        case WHILE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACE:
        case SEMICOLON:
        case INCR:
        case DECR:
          BlockStatement();
          break;
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
                {if (true) return false;}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error(""Missing return statement in function"");
  }
/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/
  final public void MethodDeclaration() throws ParseException {
 /*@bgen(jjtree) MethodDeclaration */
  BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration(JJTMETHODDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      if (jj_2_2(2147483647)) {
        ReturnType();
        t = jj_consume_token(IDENTIFIER);
                                    jjtn000.name = t.image;
        FormalParameters();
        Block();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          t = jj_consume_token(IDENTIFIER);
                       jjtn000.name = t.image;
          FormalParameters();
          Block();
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
  }
  final public void MethodDeclarationLookahead() throws ParseException {
    if (jj_2_3(2147483647)) {
      ReturnType();
      jj_consume_token(IDENTIFIER);
      FormalParameters();
      jj_consume_token(LBRACE);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        FormalParameters();
        jj_consume_token(LBRACE);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void MethodDeclarationTypeLookahead() throws ParseException {
    ReturnType();
    jj_consume_token(IDENTIFIER);
    jj_consume_token(LPAREN);
  }
  final public void ImportDeclaration() throws ParseException {
 /*@bgen(jjtree) ImportDeclaration */
    BSHImportDeclaration jjtn000 = new BSHImportDeclaration(JJTIMPORTDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      if (jj_2_4(2)) {
        jj_consume_token(IMPORT);
        AmbiguousName();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          t = jj_consume_token(DOT);
          jj_consume_token(STAR);
          break;
        default:
          jj_la1[4] = jj_gen;
          ;
        }
        jj_consume_token(SEMICOLON);
                                                 jjtree.closeNodeScope(jjtn000, true);
                                                 jjtc000 = false;
                                                 jjtreeCloseNodeScope(jjtn000);
    if ( t != null )
        jjtn000.importPackage = true;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IMPORT:
          jj_consume_token(IMPORT);
          jj_consume_token(STAR);
          jj_consume_token(SEMICOLON);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtreeCloseNodeScope(jjtn000);
                jjtn000.superImport = true;
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void VariableDeclarator() throws ParseException {
 /*@bgen(jjtree) VariableDeclarator */
  BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator(JJTVARIABLEDECLARATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
        VariableInitializer();
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
                                                 jjtree.closeNodeScope(jjtn000, true);
                                                 jjtc000 = false;
                                                 jjtreeCloseNodeScope(jjtn000);
                                                 jjtn000.name = t.image;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
Can get rid of this if we ignore postfix array dimensions in declarations.
I don't like them and I don't want to deal with them right now.
void VariableDeclaratorId() #VariableDeclaratorId :
{ Token t; }
{
  t=<IDENTIFIER> { jjtThis.name = t.image; }
  ( ""["" ""]"" { jjtThis.addArrayDimension(); } )*
}
*/
  final public void VariableInitializer() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      ArrayInitializer();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      Expression();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }
  final public void ArrayInitializer() throws ParseException {
 /*@bgen(jjtree) ArrayInitializer */
  BSHArrayInitializer jjtn000 = new BSHArrayInitializer(JJTARRAYINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        VariableInitializer();
        label_1:
        while (true) {
          if (jj_2_5(2)) {
            ;
          } else {
            break label_1;
          }
          jj_consume_token(COMMA);
          VariableInitializer();
        }
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void FormalParameters() throws ParseException {
 /*@bgen(jjtree) FormalParameters */
  BSHFormalParameters jjtn000 = new BSHFormalParameters(JJTFORMALPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        FormalParameter();
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[10] = jj_gen;
            break label_2;
          }
          jj_consume_token(COMMA);
          FormalParameter();
        }
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
void FormalParameter() #FormalParameter :
{ Token t; }
{
    // added [] to Type for bsh.  Removed [ final ] - is that legal?
  [ LOOKAHEAD(2) Type() ] t=<IDENTIFIER> { jjtThis.name = t.image; }
}
*/
  final public void FormalParameter() throws ParseException {
 /*@bgen(jjtree) FormalParameter */
  BSHFormalParameter jjtn000 = new BSHFormalParameter(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      if (jj_2_6(2)) {
        Type();
        t = jj_consume_token(IDENTIFIER);
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                       jjtreeCloseNodeScope(jjtn000);
                                       jjtn000.name = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          t = jj_consume_token(IDENTIFIER);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   jjtreeCloseNodeScope(jjtn000);
                   jjtn000.name = t.image;
          break;
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	Type, name and expression syntax follows.
*/
  final public void Type() throws ParseException {
 /*@bgen(jjtree) Type */
  BSHType jjtn000 = new BSHType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
        PrimitiveType();
        break;
      case IDENTIFIER:
        AmbiguousName();
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_3:
      while (true) {
        if (jj_2_7(2)) {
          ;
        } else {
          break label_3;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
                                 jjtn000.addArrayDimension();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	Originally called ResultType in the grammar
*/
  final public void ReturnType() throws ParseException {
 /*@bgen(jjtree) ReturnType */
  BSHReturnType jjtn000 = new BSHReturnType(JJTRETURNTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        jj_consume_token(VOID);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.isVoid = true;
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        Type();
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void PrimitiveType() throws ParseException {
 /*@bgen(jjtree) PrimitiveType */
  BSHPrimitiveType jjtn000 = new BSHPrimitiveType(JJTPRIMITIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.type = Boolean.TYPE;
        break;
      case CHAR:
        jj_consume_token(CHAR);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Character.TYPE;
        break;
      case BYTE:
        jj_consume_token(BYTE);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Byte.TYPE;
        break;
      case SHORT:
        jj_consume_token(SHORT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.type =  Short.TYPE;
        break;
      case INT:
        jj_consume_token(INT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.type =  Integer.TYPE;
        break;
      case LONG:
        jj_consume_token(LONG);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Long.TYPE;
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.type =  Float.TYPE;
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtreeCloseNodeScope(jjtn000);
             jjtn000.type =  Double.TYPE;
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
    jjtreeCloseNodeScope(jjtn000);
  }
    }
  }
  final public void AmbiguousName() throws ParseException {
 /*@bgen(jjtree) AmbiguousName */
    BSHAmbiguousName jjtn000 = new BSHAmbiguousName(JJTAMBIGUOUSNAME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t;
    StringBuffer s;
    try {
      t = jj_consume_token(IDENTIFIER);
        s = new StringBuffer(t.image);
      label_4:
      while (true) {
        if (jj_2_8(2)) {
          ;
        } else {
          break label_4;
        }
        jj_consume_token(DOT);
        t = jj_consume_token(IDENTIFIER);
        s.append("".""+t.image);
      }
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
       jjtreeCloseNodeScope(jjtn000);
        jjtn000.text = s.toString();
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
 * Expression syntax follows.
 */
  final public void Expression() throws ParseException {
    if (jj_2_9(2147483647)) {
      Assignment();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ConditionalExpression();
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void Assignment() throws ParseException {
 /*@bgen(jjtree) Assignment */
  BSHAssignment jjtn000 = new BSHAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);int op ;
    try {
      LHSPrimaryExpression();
      op = AssignmentOperator();
    jjtn000.operator = op;
      Expression();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public int AssignmentOperator() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      break;
    case STARASSIGN:
      jj_consume_token(STARASSIGN);
      break;
    case SLASHASSIGN:
      jj_consume_token(SLASHASSIGN);
      break;
    case MODASSIGN:
      jj_consume_token(MODASSIGN);
      break;
    case PLUSASSIGN:
      jj_consume_token(PLUSASSIGN);
      break;
    case MINUSASSIGN:
      jj_consume_token(MINUSASSIGN);
      break;
    case ANDASSIGN:
      jj_consume_token(ANDASSIGN);
      break;
    case XORASSIGN:
      jj_consume_token(XORASSIGN);
      break;
    case ORASSIGN:
      jj_consume_token(ORASSIGN);
      break;
    case LSHIFTASSIGN:
      jj_consume_token(LSHIFTASSIGN);
      break;
    case LSHIFTASSIGNX:
      jj_consume_token(LSHIFTASSIGNX);
      break;
    case RSIGNEDSHIFTASSIGN:
      jj_consume_token(RSIGNEDSHIFTASSIGN);
      break;
    case RSIGNEDSHIFTASSIGNX:
      jj_consume_token(RSIGNEDSHIFTASSIGNX);
      break;
    case RUNSIGNEDSHIFTASSIGN:
      jj_consume_token(RUNSIGNEDSHIFTASSIGN);
      break;
    case RUNSIGNEDSHIFTASSIGNX:
      jj_consume_token(RUNSIGNEDSHIFTASSIGNX);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        t = getToken(0);
        {if (true) return t.kind;}
    throw new Error(""Missing return statement in function"");
  }
  final public void ConditionalExpression() throws ParseException {
    ConditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HOOK:
      jj_consume_token(HOOK);
      Expression();
      jj_consume_token(COLON);
                                                     BSHTernaryExpression jjtn001 = new BSHTernaryExpression(JJTTERNARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
      try {
        ConditionalExpression();
      } catch (Throwable jjte001) {
                                                     if (jjtc001) {
                                                       jjtree.clearNodeScope(jjtn001);
                                                       jjtc001 = false;
                                                     } else {
                                                       jjtree.popNode();
                                                     }
                                                     if (jjte001 instanceof RuntimeException) {
                                                       {if (true) throw (RuntimeException)jjte001;}
                                                     }
                                                     if (jjte001 instanceof ParseException) {
                                                       {if (true) throw (ParseException)jjte001;}
                                                     }
                                                     {if (true) throw (Error)jjte001;}
      } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  3);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
      }
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
  }
  final public void ConditionalOrExpression() throws ParseException {
  Token t=null;
    ConditionalAndExpression();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_OR:
      case BOOL_ORX:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_OR:
        t = jj_consume_token(BOOL_OR);
        break;
      case BOOL_ORX:
        t = jj_consume_token(BOOL_ORX);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ConditionalAndExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void ConditionalAndExpression() throws ParseException {
  Token t=null;
    InclusiveOrExpression();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_AND:
      case BOOL_ANDX:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_AND:
        t = jj_consume_token(BOOL_AND);
        break;
      case BOOL_ANDX:
        t = jj_consume_token(BOOL_ANDX);
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      InclusiveOrExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void InclusiveOrExpression() throws ParseException {
  Token t=null;
    ExclusiveOrExpression();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
      case BIT_ORX:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        t = jj_consume_token(BIT_OR);
        break;
      case BIT_ORX:
        t = jj_consume_token(BIT_ORX);
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ExclusiveOrExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void ExclusiveOrExpression() throws ParseException {
  Token t=null;
    AndExpression();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_8;
      }
      t = jj_consume_token(XOR);
      AndExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void AndExpression() throws ParseException {
  Token t=null;
    EqualityExpression();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
      case BIT_ANDX:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        t = jj_consume_token(BIT_AND);
        break;
      case BIT_ANDX:
        t = jj_consume_token(BIT_ANDX);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      EqualityExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void EqualityExpression() throws ParseException {
  Token t = null;
    InstanceOfExpression();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        t = jj_consume_token(EQ);
        break;
      case NE:
        t = jj_consume_token(NE);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      InstanceOfExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void InstanceOfExpression() throws ParseException {
  Token t = null;
    RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCEOF:
      t = jj_consume_token(INSTANCEOF);
      Type();
                              BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                              jjtreeOpenNodeScope(jjtn001);
      try {
                              jjtree.closeNodeScope(jjtn001,  2);
                              jjtc001 = false;
                              jjtreeCloseNodeScope(jjtn001);
                              jjtn001.kind = t.kind;
      } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  2);
                                jjtreeCloseNodeScope(jjtn001);
                              }
      }
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
  }
  final public void RelationalExpression() throws ParseException {
  Token t = null;
    ShiftExpression();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GT:
      case GTX:
      case LT:
      case LTX:
      case LE:
      case LEX:
      case GE:
      case GEX:
        ;
        break;
      default:
        jj_la1[31] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        t = jj_consume_token(LT);
        break;
      case LTX:
        t = jj_consume_token(LTX);
        break;
      case GT:
        t = jj_consume_token(GT);
        break;
      case GTX:
        t = jj_consume_token(GTX);
        break;
      case LE:
        t = jj_consume_token(LE);
        break;
      case LEX:
        t = jj_consume_token(LEX);
        break;
      case GE:
        t = jj_consume_token(GE);
        break;
      case GEX:
        t = jj_consume_token(GEX);
        break;
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      ShiftExpression();
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
      try {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
    jjtn001.kind = t.kind;
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
      }
    }
  }
  final public void ShiftExpression() throws ParseException {
  Token t = null;
    AdditiveExpression();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
      case LSHIFTX:
      case RSIGNEDSHIFT:
      case RSIGNEDSHIFTX:
      case RUNSIGNEDSHIFT:
      case RUNSIGNEDSHIFTX:
        ;
        break;
      default:
        jj_la1[33] = jj_gen;
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
        t = jj_consume_token(LSHIFT);
        break;
      case LSHIFTX:
        t = jj_consume_token(LSHIFTX);
        break;
      case RSIGNEDSHIFT:
        t = jj_consume_token(RSIGNEDSHIFT);
        break;
      case RSIGNEDSHIFTX:
        t = jj_consume_token(RSIGNEDSHIFTX);
        break;
      case RUNSIGNEDSHIFT:
        t = jj_consume_token(RUNSIGNEDSHIFT);
        break;
      case RUNSIGNEDSHIFTX:
        t = jj_consume_token(RUNSIGNEDSHIFTX);
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      AdditiveExpression();
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
      try {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
    jjtn001.kind = t.kind;
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
      }
    }
  }
  final public void AdditiveExpression() throws ParseException {
  Token t = null;
    MultiplicativeExpression();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_13;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      MultiplicativeExpression();
                                                     BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
      try {
                                                     jjtree.closeNodeScope(jjtn001,  2);
                                                     jjtc001 = false;
                                                     jjtreeCloseNodeScope(jjtn001);
                                                     jjtn001.kind = t.kind;
      } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  2);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
      }
    }
  }
  final public void MultiplicativeExpression() throws ParseException {
  Token t = null;
    UnaryExpression();
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
      case SLASH:
      case MOD:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_14;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        t = jj_consume_token(STAR);
        break;
      case SLASH:
        t = jj_consume_token(SLASH);
        break;
      case MOD:
        t = jj_consume_token(MOD);
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
                      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                      jjtreeOpenNodeScope(jjtn001);
      try {
                      jjtree.closeNodeScope(jjtn001,  2);
                      jjtc001 = false;
                      jjtreeCloseNodeScope(jjtn001);
                      jjtn001.kind = t.kind;
      } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  2);
                        jjtreeCloseNodeScope(jjtn001);
                      }
      }
    }
  }
  final public void UnaryExpression() throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    case INCR:
      PreIncrementExpression();
      break;
    case DECR:
      PreDecrementExpression();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
      UnaryExpressionNotPlusMinus();
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }
  final public void PreIncrementExpression() throws ParseException {
  Token t = null;
    t = jj_consume_token(INCR);
    LHSPrimaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
  }
  final public void PreDecrementExpression() throws ParseException {
  Token t = null;
    t = jj_consume_token(DECR);
    LHSPrimaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
  }
  final public void UnaryExpressionNotPlusMinus() throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case TILDE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        t = jj_consume_token(TILDE);
        break;
      case BANG:
        t = jj_consume_token(BANG);
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    default:
      jj_la1[42] = jj_gen;
      if (jj_2_10(2147483647)) {
        CastExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
          PostfixExpression();
          break;
        default:
          jj_la1[43] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }
// This production is to determine lookahead only.
  final public void CastLookahead() throws ParseException {
    if (jj_2_11(2)) {
      jj_consume_token(LPAREN);
      PrimitiveType();
    } else if (jj_2_12(2147483647)) {
      jj_consume_token(LPAREN);
      AmbiguousName();
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        AmbiguousName();
        jj_consume_token(RPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TILDE:
          jj_consume_token(TILDE);
          break;
        case BANG:
          jj_consume_token(BANG);
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          break;
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case NEW:
          jj_consume_token(NEW);
          break;
        case FALSE:
        case NULL:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
          Literal();
          break;
        default:
          jj_la1[44] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[45] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void PostfixExpression() throws ParseException {
  Token t = null;
    if (jj_2_13(2147483647)) {
      LHSPrimaryExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCR:
      case DECR:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INCR:
          t = jj_consume_token(INCR);
          break;
        case DECR:
          t = jj_consume_token(DECR);
          break;
        default:
          jj_la1[46] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                  BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
                                  boolean jjtc001 = true;
                                  jjtree.openNodeScope(jjtn001);
                                  jjtreeOpenNodeScope(jjtn001);
        try {
                                  jjtree.closeNodeScope(jjtn001,  1);
                                  jjtc001 = false;
                                  jjtreeCloseNodeScope(jjtn001);
                jjtn001.kind = t.kind; jjtn001.postfix = true;
        } finally {
                                  if (jjtc001) {
                                    jjtree.closeNodeScope(jjtn001,  1);
                                    jjtreeCloseNodeScope(jjtn001);
                                  }
        }
        break;
      default:
        jj_la1[47] = jj_gen;
        ;
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
        PrimaryExpression();
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void CastExpression() throws ParseException {
 /*@bgen(jjtree) CastExpression */
  BSHCastExpression jjtn000 = new BSHCastExpression(JJTCASTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_14(2147483647)) {
        jj_consume_token(LPAREN);
        Type();
        jj_consume_token(RPAREN);
        UnaryExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          Type();
          jj_consume_token(RPAREN);
          UnaryExpressionNotPlusMinus();
          break;
        default:
          jj_la1[49] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void PrimaryExpression() throws ParseException {
                                               /*@bgen(jjtree) PrimaryExpression */
  BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      PrimaryPrefix();
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case LBRACKET:
        case DOT:
          ;
          break;
        default:
          jj_la1[50] = jj_gen;
          break label_15;
        }
        PrimarySuffix();
      }
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtreeCloseNodeScope(jjtn000);
   }
    }
  }
// The MethodInvocation node here simplifies the prefix/suffix parsing a bit
//  by forcing the prefix to an object.
  final public void PrimaryPrefix() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
      Literal();
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      break;
    case NEW:
      AllocationExpression();
      break;
    default:
      jj_la1[52] = jj_gen;
      if (jj_2_15(2147483647)) {
        Type();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
    BSHMethodInvocation jjtn001 = new BSHMethodInvocation(JJTMETHODINVOCATION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
          try {
            AmbiguousName();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LPAREN:
              Arguments();
              break;
            default:
              jj_la1[51] = jj_gen;
              ;
            }
          } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
          } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      jjtreeCloseNodeScope(jjtn001);
    }
          }
          break;
        default:
          jj_la1[53] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }
  final public void PrimarySuffix() throws ParseException {
 /*@bgen(jjtree) PrimarySuffix */
    BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix(JJTPRIMARYSUFFIX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      if (jj_2_16(2)) {
        jj_consume_token(DOT);
        jj_consume_token(CLASS);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.CLASS;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          jj_consume_token(LBRACKET);
          Expression();
          jj_consume_token(RBRACKET);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.INDEX;
          break;
        case DOT:
          jj_consume_token(DOT);
          t = jj_consume_token(IDENTIFIER);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
            Arguments();
            break;
          default:
            jj_la1[54] = jj_gen;
            ;
          }
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.NAME;
        jjtn000.field = t.image;
          break;
        case LBRACE:
          jj_consume_token(LBRACE);
          Expression();
          jj_consume_token(RBRACE);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.PROPERTY;
          break;
        default:
          jj_la1[55] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	Begin LHS part of the grammar --
	The reason this stuff is duplicated (e.g. LHSPrimaryPrefix and 
	PrimaryPrefix) is that the whole grammar splits based on whether we 
	are preparig to do an assignment or not.  This is an important issue 
	to revisit in the future.
*/
/**
	The method invocation is here to force this to an object type in order 
	to simplify the suffix processing.  
*/
  final public void LHSPrimaryPrefix() throws ParseException {
    BSHMethodInvocation jjtn001 = new BSHMethodInvocation(JJTMETHODINVOCATION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
    try {
      AmbiguousName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        Arguments();
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
    } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte001;}
    }
    if (jjte001 instanceof ParseException) {
      {if (true) throw (ParseException)jjte001;}
    }
    {if (true) throw (Error)jjte001;}
    } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      jjtreeCloseNodeScope(jjtn001);
    }
    }
  }
  final public void LHSPrimaryExpression() throws ParseException {
                                                     /*@bgen(jjtree) LHSPrimaryExpression */
  BSHLHSPrimaryExpression jjtn000 = new BSHLHSPrimaryExpression(JJTLHSPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      LHSPrimaryPrefix();
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case LBRACKET:
        case DOT:
          ;
          break;
        default:
          jj_la1[57] = jj_gen;
          break label_16;
        }
        LHSPrimarySuffix();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void LHSPrimarySuffix() throws ParseException {
 /*@bgen(jjtree) LHSPrimarySuffix */
    BSHLHSPrimarySuffix jjtn000 = new BSHLHSPrimarySuffix(JJTLHSPRIMARYSUFFIX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t=null, t1, t2 = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        jj_consume_token(LBRACKET);
        Expression();
        jj_consume_token(RBRACKET);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHLHSPrimarySuffix.INDEX;
        break;
      case DOT:
        jj_consume_token(DOT);
        t1 = jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          Arguments();
          jj_consume_token(DOT);
          t2 = jj_consume_token(IDENTIFIER);
          break;
        default:
          jj_la1[58] = jj_gen;
          ;
        }
                                                                jjtree.closeNodeScope(jjtn000, true);
                                                                jjtc000 = false;
                                                                jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHLHSPrimarySuffix.NAME;
        if ( t2 == null )
            jjtn000.field = t1.image;
        else {
            jjtn000.method = t1.image;
            jjtn000.field = t2.image;
        }
        break;
      case LBRACE:
        jj_consume_token(LBRACE);
        Expression();
        jj_consume_token(RBRACE);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHLHSPrimarySuffix.PROPERTY;
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	-- End LHS part of the grammar
*/
  final public void Literal() throws ParseException {
 /*@bgen(jjtree) Literal */
    BSHLiteral jjtn000 = new BSHLiteral(JJTLITERAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token x;
    boolean b;
    String literal;
    char ch;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        x = jj_consume_token(INTEGER_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'l' || ch == 'L')
    {
        literal = literal.substring(0,literal.length()-1);
        // This really should be Long.decode, but there isn't one. As a result,
        // hex and octal literals ending in 'l' or 'L' don't work.
        jjtn000.value = new Primitive( new Long( literal ) );
    }
    else
        jjtn000.value = new Primitive( Integer.decode( literal ) );
        break;
      case FLOATING_POINT_LITERAL:
        x = jj_consume_token(FLOATING_POINT_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'f' || ch == 'F')
    {
        literal = literal.substring(0,literal.length()-1);
        jjtn000.value = new Primitive( new Float( literal ) );
    }
    else
    {
        if(ch == 'd' || ch == 'D')
            literal = literal.substring(0,literal.length()-1);
        jjtn000.value = new Primitive( new Double( literal ) );
    }
        break;
      case CHARACTER_LITERAL:
        x = jj_consume_token(CHARACTER_LITERAL);
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtreeCloseNodeScope(jjtn000);
                try {
                jjtn000.charSetup( x.image.substring(1, x.image.length() - 1) );
                } catch ( Exception e ) {
                        {if (true) throw new ParseException(""Error parsing character: ""+x.image);}
                }
        break;
      case STRING_LITERAL:
        x = jj_consume_token(STRING_LITERAL);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
                try {
                        jjtn000.stringSetup( x.image.substring(1, x.image.length() - 1) );
                } catch ( Exception e ) {
                        {if (true) throw new ParseException(""Error parsing string: ""+x.image);}
                }
        break;
      case FALSE:
      case TRUE:
        b = BooleanLiteral();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = new Primitive( new Boolean(b) );
        break;
      case NULL:
        NullLiteral();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = Primitive.NULL;
        break;
      case VOID:
        VoidLiteral();
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = Primitive.VOID;
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public boolean BooleanLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
           {if (true) return true;}
      break;
    case FALSE:
      jj_consume_token(FALSE);
            {if (true) return false;}
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error(""Missing return statement in function"");
  }
  final public void NullLiteral() throws ParseException {
    jj_consume_token(NULL);
  }
  final public void VoidLiteral() throws ParseException {
    jj_consume_token(VOID);
  }
  final public void Arguments() throws ParseException {
 /*@bgen(jjtree) Arguments */
  BSHArguments jjtn000 = new BSHArguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ArgumentList();
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
// leave these on the stack for Arguments() to handle
  final public void ArgumentList() throws ParseException {
    Expression();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[63] = jj_gen;
        break label_17;
      }
      jj_consume_token(COMMA);
      Expression();
    }
  }
  final public void AllocationExpression() throws ParseException {
 /*@bgen(jjtree) AllocationExpression */
  BSHAllocationExpression jjtn000 = new BSHAllocationExpression(JJTALLOCATIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_18(2)) {
        jj_consume_token(NEW);
        PrimitiveType();
        ArrayDimensions();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEW:
          jj_consume_token(NEW);
          AmbiguousName();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACKET:
            ArrayDimensions();
            break;
          case LPAREN:
            Arguments();
            if (jj_2_17(2)) {
              Block();
            } else {
              ;
            }
            break;
          default:
            jj_la1[64] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[65] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ArrayDimensions() throws ParseException {
 /*@bgen(jjtree) ArrayDimensions */
  BSHArrayDimensions jjtn000 = new BSHArrayDimensions(JJTARRAYDIMENSIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_20(2)) {
        label_18:
        while (true) {
          jj_consume_token(LBRACKET);
          Expression();
          jj_consume_token(RBRACKET);
                                        jjtn000.addArrayDimension();
          if (jj_2_19(2)) {
            ;
          } else {
            break label_18;
          }
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          label_19:
          while (true) {
            jj_consume_token(LBRACKET);
            jj_consume_token(RBRACKET);
              jjtn000.addArrayDimension();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LBRACKET:
              ;
              break;
            default:
              jj_la1[66] = jj_gen;
              break label_19;
            }
          }
          ArrayInitializer();
          break;
        default:
          jj_la1[67] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
 * Statement syntax follows.
 */
  final public void Statement() throws ParseException {
    if (jj_2_21(2)) {
      LabeledStatement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        Block();
        break;
      case SEMICOLON:
        EmptyStatement();
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case INCR:
      case DECR:
        StatementExpression();
        jj_consume_token(SEMICOLON);
        break;
      case SWITCH:
        SwitchStatement();
        break;
      case IF:
        IfStatement();
        break;
      case WHILE:
        WhileStatement();
        break;
      case DO:
        DoStatement();
        break;
      case FOR:
        ForStatement();
        break;
      case BREAK:
        BreakStatement();
        break;
      case CONTINUE:
        ContinueStatement();
        break;
      case RETURN:
        ReturnStatement();
        break;
      case THROW:
        ThrowStatement();
        break;
      case TRY:
        TryStatement();
        break;
      default:
        jj_la1[68] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void LabeledStatement() throws ParseException {
    jj_consume_token(IDENTIFIER);
    jj_consume_token(COLON);
    Statement();
  }
  final public void Block() throws ParseException {
 /*@bgen(jjtree) Block */
  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACE);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BREAK:
        case BYTE:
        case CHAR:
        case CONTINUE:
        case DO:
        case DOUBLE:
        case FALSE:
        case FINAL:
        case FLOAT:
        case FOR:
        case IF:
        case IMPORT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case RETURN:
        case SHORT:
        case SWITCH:
        case THROW:
        case TRUE:
        case TRY:
        case VOID:
        case WHILE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case LBRACE:
        case SEMICOLON:
        case INCR:
        case DECR:
          ;
          break;
        default:
          jj_la1[69] = jj_gen;
          break label_20;
        }
        BlockStatement();
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void BlockStatement() throws ParseException {
    if (jj_2_22(2147483647)) {
      MethodDeclaration();
    } else if (jj_2_23(2147483647)) {
      TypedVariableDeclaration();
      jj_consume_token(SEMICOLON);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BREAK:
      case BYTE:
      case CHAR:
      case CONTINUE:
      case DO:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case FOR:
      case IF:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case RETURN:
      case SHORT:
      case SWITCH:
      case THROW:
      case TRUE:
      case TRY:
      case VOID:
      case WHILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case SEMICOLON:
      case INCR:
      case DECR:
        Statement();
        break;
      case IMPORT:
        ImportDeclaration();
        break;
      default:
        jj_la1[70] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void EmptyStatement() throws ParseException {
    jj_consume_token(SEMICOLON);
  }
  final public void StatementExpression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCR:
      PreIncrementExpression();
      break;
    case DECR:
      PreDecrementExpression();
      break;
    default:
      jj_la1[71] = jj_gen;
      if (jj_2_24(2147483647)) {
        Assignment();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
          PostfixExpression();
          break;
        default:
          jj_la1[72] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }
  final public void SwitchStatement() throws ParseException {
 /*@bgen(jjtree) SwitchStatement */
  BSHSwitchStatement jjtn000 = new BSHSwitchStatement(JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SWITCH);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      jj_consume_token(LBRACE);
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASE:
        case _DEFAULT:
          ;
          break;
        default:
          jj_la1[73] = jj_gen;
          break label_21;
        }
        SwitchLabel();
        label_22:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BOOLEAN:
          case BREAK:
          case BYTE:
          case CHAR:
          case CONTINUE:
          case DO:
          case DOUBLE:
          case FALSE:
          case FINAL:
          case FLOAT:
          case FOR:
          case IF:
          case IMPORT:
          case INT:
          case LONG:
          case NEW:
          case NULL:
          case RETURN:
          case SHORT:
          case SWITCH:
          case THROW:
          case TRUE:
          case TRY:
          case VOID:
          case WHILE:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case CHARACTER_LITERAL:
          case STRING_LITERAL:
          case IDENTIFIER:
          case LPAREN:
          case LBRACE:
          case SEMICOLON:
          case INCR:
          case DECR:
            ;
            break;
          default:
            jj_la1[74] = jj_gen;
            break label_22;
          }
          BlockStatement();
        }
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void SwitchLabel() throws ParseException {
 /*@bgen(jjtree) SwitchLabel */
  BSHSwitchLabel jjtn000 = new BSHSwitchLabel(JJTSWITCHLABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
        jj_consume_token(CASE);
        Expression();
        jj_consume_token(COLON);
        break;
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
        jj_consume_token(COLON);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.isDefault = true;
        break;
      default:
        jj_la1[75] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void IfStatement() throws ParseException {
 /*@bgen(jjtree) IfStatement */
  BSHIfStatement jjtn000 = new BSHIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IF);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Statement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        Statement();
        break;
      default:
        jj_la1[76] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void WhileStatement() throws ParseException {
 /*@bgen(jjtree) WhileStatement */
  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(WHILE);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Statement();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	Do statement is just a While statement with a special hook to execute
	at least once.
*/
  final public void DoStatement() throws ParseException {
 /*@bgen(jjtree) WhileStatement */
  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(DO);
      Statement();
      jj_consume_token(WHILE);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.isDoStatement=true;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForStatement() throws ParseException {
 /*@bgen(jjtree) ForStatement */
  BSHForStatement jjtn000 = new BSHForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(FOR);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case INCR:
      case DECR:
        ForInit();
                          jjtn000.hasForInit=true;
        break;
      default:
        jj_la1[77] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        Expression();
                         jjtn000.hasExpression=true;
        break;
      default:
        jj_la1[78] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case INCR:
      case DECR:
        ForUpdate();
                        jjtn000.hasForUpdate=true;
        break;
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      Statement();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForInit() throws ParseException {
  Token t = null;
    if (jj_2_25(2147483647)) {
      TypedVariableDeclaration();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case INCR:
      case DECR:
        StatementExpressionList();
        break;
      default:
        jj_la1[80] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
/**
	Declared a typed variable.
	Untyped variables are not declared per-se but are handled by the part
	of the grammar that deals with assignments.
*/
  final public void TypedVariableDeclaration() throws ParseException {
 /*@bgen(jjtree) TypedVariableDeclaration */
        BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration(JJTTYPEDVARIABLEDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINAL:
        t = jj_consume_token(FINAL);
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
      Type();
      VariableDeclarator();
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[82] = jj_gen;
          break label_23;
        }
        jj_consume_token(COMMA);
        VariableDeclarator();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        jjtn000.isFinal = (t!=null);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void StatementExpressionList() throws ParseException {
 /*@bgen(jjtree) StatementExpressionList */
  BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList(JJTSTATEMENTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      StatementExpression();
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[83] = jj_gen;
          break label_24;
        }
        jj_consume_token(COMMA);
        StatementExpression();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForUpdate() throws ParseException {
    StatementExpressionList();
  }
  final public void BreakStatement() throws ParseException {
 /*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(BREAK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[84] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON);
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                                 jjtreeCloseNodeScope(jjtn000);
                                 jjtn000.kind = BREAK;
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ContinueStatement() throws ParseException {
 /*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(CONTINUE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[85] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON);
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                    jjtreeCloseNodeScope(jjtn000);
                                    jjtn000.kind = CONTINUE;
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ReturnStatement() throws ParseException {
 /*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(RETURN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        Expression();
        break;
      default:
        jj_la1[86] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                  jjtreeCloseNodeScope(jjtn000);
                                  jjtn000.kind = RETURN;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ThrowStatement() throws ParseException {
 /*@bgen(jjtree) ThrowStatement */
  BSHThrowStatement jjtn000 = new BSHThrowStatement(JJTTHROWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(THROW);
      Expression();
      jj_consume_token(SEMICOLON);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void TryStatement() throws ParseException {
 /*@bgen(jjtree) TryStatement */
  BSHTryStatement jjtn000 = new BSHTryStatement(JJTTRYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(TRY);
      Block();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CATCH:
          ;
          break;
        default:
          jj_la1[87] = jj_gen;
          break label_25;
        }
        jj_consume_token(CATCH);
        jj_consume_token(LPAREN);
        FormalParameter();
        jj_consume_token(RPAREN);
        Block();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINALLY:
        jj_consume_token(FINALLY);
        Block();
        break;
      default:
        jj_la1[88] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }
  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }
  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }
  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }
  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_5();
    jj_save(4, xla);
    return retval;
  }
  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_6();
    jj_save(5, xla);
    return retval;
  }
  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_7();
    jj_save(6, xla);
    return retval;
  }
  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_8();
    jj_save(7, xla);
    return retval;
  }
  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_9();
    jj_save(8, xla);
    return retval;
  }
  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_10();
    jj_save(9, xla);
    return retval;
  }
  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_11();
    jj_save(10, xla);
    return retval;
  }
  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_12();
    jj_save(11, xla);
    return retval;
  }
  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_13();
    jj_save(12, xla);
    return retval;
  }
  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_14();
    jj_save(13, xla);
    return retval;
  }
  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_15();
    jj_save(14, xla);
    return retval;
  }
  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_16();
    jj_save(15, xla);
    return retval;
  }
  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_17();
    jj_save(16, xla);
    return retval;
  }
  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_18();
    jj_save(17, xla);
    return retval;
  }
  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_19();
    jj_save(18, xla);
    return retval;
  }
  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_20();
    jj_save(19, xla);
    return retval;
  }
  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_21();
    jj_save(20, xla);
    return retval;
  }
  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_22();
    jj_save(21, xla);
    return retval;
  }
  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_23();
    jj_save(22, xla);
    return retval;
  }
  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_24();
    jj_save(23, xla);
    return retval;
  }
  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_25();
    jj_save(24, xla);
    return retval;
  }
  final private boolean jj_3R_27() {
    if (jj_3R_45()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_16() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLASS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_102() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_79() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_96()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_149() {
    if (jj_scan_token(FINAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_78() {
    if (jj_3R_45()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_96()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_2() {
    if (jj_3R_27()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_132() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_149()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_226()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_227()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3_15() {
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLASS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_42() {
    if (jj_scan_token(FINAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_148() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_96()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_36() {
    if (jj_scan_token(DECR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_243() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_133()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_81() {
    if (jj_3R_102()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_101() {
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_116()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_147() {
    if (jj_3R_45()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_96()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_92() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_35() {
    if (jj_scan_token(INCR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_269() {
    if (jj_3R_270()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_131() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_100() {
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_244() {
    if (jj_3R_261()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_268() {
    if (jj_3R_132()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_261() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_268()) {
    jj_scanpos = xsp;
    if (jj_3R_269()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_246() {
    if (jj_3R_262()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_99() {
    if (jj_3R_115()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_245() {
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_91() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_98() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_1() {
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_80() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_97() {
    if (jj_3R_109()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_14() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_34()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_90() {
    if (jj_scan_token(BANG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_280() {
    if (jj_scan_token(DECR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_181() {
    if (jj_scan_token(FOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_244()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_245()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_246()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_133()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_41() {
    if (jj_3R_80()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_81()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_89() {
    if (jj_scan_token(TILDE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_282() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_265()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_279() {
    if (jj_scan_token(INCR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_180() {
    if (jj_scan_token(DO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_133()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(WHILE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_281() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_238()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_278() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_281()) {
    jj_scanpos = xsp;
    if (jj_3R_282()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_274() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_279()) {
    jj_scanpos = xsp;
    if (jj_3R_280()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_13() {
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_209() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_179() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_133()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_12() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_208() {
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_274()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_260() {
    if (jj_3R_95()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_178() {
    if (jj_scan_token(IF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_133()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_243()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_201() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_68() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_67() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_10() {
    if (jj_3R_33()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_267() {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_11() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_34()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_277() {
    if (jj_scan_token(BANG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_266() {
    if (jj_scan_token(CASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_259() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_266()) {
    jj_scanpos = xsp;
    if (jj_3R_267()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_242() {
    if (jj_3R_259()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_260()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_273() {
    if (jj_3R_201()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_258() {
    if (jj_scan_token(MOD)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_272() {
    if (jj_3R_278()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_24() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_32()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_276() {
    if (jj_scan_token(TILDE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_177() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_242()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_271() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_276()) {
    jj_scanpos = xsp;
    if (jj_3R_277()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_238()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_265() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_271()) {
    jj_scanpos = xsp;
    if (jj_3R_272()) {
    jj_scanpos = xsp;
    if (jj_3R_273()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_257() {
    if (jj_scan_token(SLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_195() {
    if (jj_3R_201()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_233() {
    if (jj_scan_token(RSIGNEDSHIFTX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_200() {
    if (jj_scan_token(DECR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_194() {
    if (jj_3R_82()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_193() {
    if (jj_3R_200()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_256() {
    if (jj_scan_token(STAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_192() {
    if (jj_3R_199()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_176() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_239() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_256()) {
    jj_scanpos = xsp;
    if (jj_3R_257()) {
    jj_scanpos = xsp;
    if (jj_3R_258()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_238()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_199() {
    if (jj_scan_token(INCR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_232() {
    if (jj_scan_token(RSIGNEDSHIFT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_264() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_255() {
    if (jj_3R_265()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_225() {
    if (jj_scan_token(GEX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_254() {
    if (jj_3R_200()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_175() {
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_253() {
    if (jj_3R_199()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_263() {
    if (jj_scan_token(PLUS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_221() {
    if (jj_scan_token(GTX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_40() {
    if (jj_scan_token(FINAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_252() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_263()) {
    jj_scanpos = xsp;
    if (jj_3R_264()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_238()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_238() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_252()) {
    jj_scanpos = xsp;
    if (jj_3R_253()) {
    jj_scanpos = xsp;
    if (jj_3R_254()) {
    jj_scanpos = xsp;
    if (jj_3R_255()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_23() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_40()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_241() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_113() {
    if (jj_3R_134()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_22() {
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_224() {
    if (jj_scan_token(GE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_235() {
    if (jj_scan_token(RUNSIGNEDSHIFTX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_228() {
    if (jj_3R_238()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_239()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_112() {
    if (jj_3R_133()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_220() {
    if (jj_scan_token(GT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_231() {
    if (jj_scan_token(LSHIFTX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_240() {
    if (jj_scan_token(PLUS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_111() {
    if (jj_3R_132()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_229() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_240()) {
    jj_scanpos = xsp;
    if (jj_3R_241()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_228()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_213() {
    if (jj_scan_token(NE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_95() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_110() {
    if (jj_3R_131()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_77() {
    if (jj_3R_95()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_216() {
    if (jj_3R_228()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_229()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_223() {
    if (jj_scan_token(LEX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_234() {
    if (jj_scan_token(RUNSIGNEDSHIFT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_230() {
    if (jj_scan_token(LSHIFT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_219() {
    if (jj_scan_token(LTX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_37() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_77()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_217() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) {
    jj_scanpos = xsp;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) {
    jj_scanpos = xsp;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_216()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_212() {
    if (jj_scan_token(EQ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_214() {
    if (jj_3R_216()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_217()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_205() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_204()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_38() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_133()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_222() {
    if (jj_scan_token(LE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_218() {
    if (jj_scan_token(LT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_215() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) {
    jj_scanpos = xsp;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) {
    jj_scanpos = xsp;
    if (jj_3R_225()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_214()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_162() {
    if (jj_3R_186()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_161() {
    if (jj_3R_185()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_210() {
    if (jj_3R_214()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_215()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_160() {
    if (jj_3R_184()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_159() {
    if (jj_3R_183()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_211() {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_158() {
    if (jj_3R_182()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_204() {
    if (jj_3R_210()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_211()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_157() {
    if (jj_3R_181()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_207() {
    if (jj_scan_token(BIT_ANDX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_156() {
    if (jj_3R_180()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_155() {
    if (jj_3R_179()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_189() {
    if (jj_scan_token(XOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_188()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_154() {
    if (jj_3R_178()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_197() {
    if (jj_3R_204()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_205()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_153() {
    if (jj_3R_177()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_152() {
    if (jj_3R_176()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_60() {
    if (jj_scan_token(ORASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_17() {
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_206() {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_151() {
    if (jj_3R_175()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_198() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_206()) {
    jj_scanpos = xsp;
    if (jj_3R_207()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_197()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_150() {
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_188() {
    if (jj_3R_197()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_198()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_59() {
    if (jj_scan_token(XORASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_21() {
    if (jj_3R_38()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_133() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_191() {
    if (jj_scan_token(BIT_ORX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_168() {
    if (jj_3R_188()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_189()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_167() {
    if (jj_3R_105()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_58() {
    if (jj_scan_token(ANDASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_196() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_64() {
    if (jj_scan_token(RSIGNEDSHIFTASSIGNX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_171() {
    if (jj_scan_token(BOOL_ANDX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_187() {
    Token xsp;
    if (jj_3R_196()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_196()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_3R_86()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_166() {
    if (jj_3R_165()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_190() {
    if (jj_scan_token(BIT_OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_19() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_104() {
    if (jj_scan_token(HOOK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_83()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_169() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_168()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_165() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_57() {
    if (jj_scan_token(MINUSASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_20() {
    Token xsp;
    if (jj_3_19()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_19()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_63() {
    if (jj_scan_token(RSIGNEDSHIFTASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_139() {
    if (jj_3R_168()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_169()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_142() {
    if (jj_scan_token(BOOL_ORX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_170() {
    if (jj_scan_token(BOOL_AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_56() {
    if (jj_scan_token(PLUSASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_140() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_139()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_120() {
    if (jj_3R_139()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_140()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_137() {
    if (jj_scan_token(NEW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_55() {
    if (jj_scan_token(MODASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_141() {
    if (jj_scan_token(BOOL_OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_18() {
    if (jj_scan_token(NEW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_34()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_165()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_115() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_121() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_120()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_172() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_103() {
    if (jj_3R_120()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_121()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_54() {
    if (jj_scan_token(SLASHASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_143() {
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_172()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_66() {
    if (jj_scan_token(RUNSIGNEDSHIFTASSIGNX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_122() {
    if (jj_3R_143()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_62() {
    if (jj_scan_token(LSHIFTASSIGNX)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_83() {
    if (jj_3R_103()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_104()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_53() {
    if (jj_scan_token(STARASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_105() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_122()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_65() {
    if (jj_scan_token(RUNSIGNEDSHIFTASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_61() {
    if (jj_scan_token(LSHIFTASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_52() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_146() {
    if (jj_scan_token(VOID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_145() {
    if (jj_scan_token(NULL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_9() {
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_32()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_174() {
    if (jj_scan_token(FALSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_82() {
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_32()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_173() {
    if (jj_scan_token(TRUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_144() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3R_174()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_44() {
    if (jj_3R_83()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_43() {
    if (jj_3R_82()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_130() {
    if (jj_3R_146()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_129() {
    if (jj_3R_145()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_128() {
    if (jj_3R_144()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_127() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_8() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_28() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_8()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_126() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_203() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_76() {
    if (jj_scan_token(DOUBLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_75() {
    if (jj_scan_token(FLOAT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_74() {
    if (jj_scan_token(LONG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_73() {
    if (jj_scan_token(INT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_49() {
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_72() {
    if (jj_scan_token(SHORT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_71() {
    if (jj_scan_token(BYTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_70() {
    if (jj_scan_token(CHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_125() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_69() {
    if (jj_scan_token(BOOLEAN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_85() {
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_84() {
    if (jj_scan_token(VOID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_7() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_48() {
    if (jj_3R_34()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_109() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_124() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_123() {
    if (jj_3R_105()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_7()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_136() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_135()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_164() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_108() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_6() {
    if (jj_3R_30()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_135() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_6()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_51() {
    if (jj_3R_88()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_5() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_29()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_87() {
    if (jj_3R_105()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_107() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_123()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_114() {
    if (jj_3R_135()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_136()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_106() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_88() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_96() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_114()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_202() {
    if (jj_3R_29()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_5()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_86() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_202()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_203()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_31() {
    if (jj_3R_50()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_51()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  final private boolean jj_3R_251() {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_250() {
    if (jj_scan_token(CATCH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_135()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_47() {
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_186() {
    if (jj_scan_token(TRY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_250()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    xsp = jj_scanpos;
    if (jj_3R_251()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_46() {
    if (jj_3R_86()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_236() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_29()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_50() {
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_87()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_249() {
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_237() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(STAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_248() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_185() {
    if (jj_scan_token(THROW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_138() {
    if (jj_3R_105()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_227() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_226()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_94() {
    if (jj_3R_109()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_275() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_176()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_184() {
    if (jj_scan_token(RETURN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_249()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_247() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_226() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_236()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_93() {
    if (jj_scan_token(NEW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_183() {
    if (jj_scan_token(CONTINUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_248()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_163() {
    if (jj_scan_token(IMPORT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(STAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_182() {
    if (jj_scan_token(BREAK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_247()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_119() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBRACE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_118() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_138()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_262() {
    if (jj_3R_270()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_4() {
    if (jj_scan_token(IMPORT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_28()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_237()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SEMICOLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_116() {
    if (jj_3R_105()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3_3() {
    if (jj_3R_27()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_117() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_26()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBRACKET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }
  final private boolean jj_3R_270() {
    if (jj_3R_176()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_275()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }
  public ParserTokenManager token_source;
  ASCII_UCodeESC_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[89];
  final private int[] jj_la1_0 = {0xdb6a5800,0xdb6a5801,0x0,0x0,0x0,0x80000000,0x0,0x9424800,0x9424800,0x0,0x0,0x8424800,0x0,0x8424800,0x8424800,0x8424800,0x9424800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9424800,0x0,0x0,0x9424800,0x1000000,0x0,0x0,0x0,0x9424800,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x1000000,0x9424800,0x0,0x0,0x0,0x0,0x0,0x596a5800,0xdb6a5800,0xd96a5800,0x0,0x9424800,0x108000,0xdb6a5800,0x108000,0x800000,0xb424800,0x9424800,0x9424800,0x9424800,0x2000000,0x0,0x0,0x0,0x0,0x9424800,0x10000,0x4000000,};
  final private int[] jj_la1_1 = {0xa747f63a,0xa747f63a,0x4000000,0x4000000,0x0,0x0,0x0,0xa745443a,0xa745443a,0x0,0x0,0x400040a,0x4000000,0x400040a,0x401040a,0x40a,0x2745443a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2745443a,0x0,0x0,0x2745443a,0x27454030,0x20000000,0x0,0x0,0x2745443a,0x20000000,0x80000000,0x20000000,0x23454030,0x4000000,0x20000000,0x80000000,0x20000000,0x80000000,0x20000000,0x80000000,0x3454020,0x4000,0x2745443a,0x0,0x20000000,0x10,0x0,0x0,0xa747f63a,0xa747f63a,0xa747f63a,0x0,0x2745443a,0x0,0xa747f63a,0x0,0x0,0x2745443a,0x2745443a,0x2745443a,0x2745443a,0x0,0x0,0x0,0x4000000,0x4000000,0x2745443a,0x0,0x0,};
  final private int[] jj_la1_2 = {0x6000008,0x1e001808,0x0,0x0,0x20,0x0,0x40,0x1e001800,0x1e001800,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x1e001800,0x40,0x2000,0x600000,0x600000,0x1800000,0x1800000,0x0,0x0,0x0,0x80000000,0x80000000,0x108000,0x108000,0x0,0xf0780,0xf0780,0x0,0x0,0x18000000,0x18000000,0x60000000,0x60000000,0x18000000,0x1e001800,0x1800,0x1800,0x0,0x1800,0x0,0x6000000,0x6000000,0x0,0x0,0x22,0x0,0x0,0x0,0x0,0x22,0x0,0x22,0x0,0x22,0x0,0x0,0x1e001800,0x10,0x2,0x0,0x2,0x2,0x6000008,0x6000008,0x6000008,0x6000000,0x0,0x0,0x6000008,0x0,0x0,0x6000000,0x1e001800,0x6000000,0x6000000,0x0,0x10,0x10,0x0,0x0,0x1e001800,0x0,0x0,};
  final private int[] jj_la1_3 = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7faf800,0x0,0x0,0x0,0x0,0x0,0x6,0x6,0x8,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x7e0,0x7e0,0x0,0x0,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
  final private JJCalls[] jj_2_rtns = new JJCalls[25];
  private boolean jj_rescan = false;
  private int jj_gc = 0;
  public Parser(java.io.InputStream stream) {
    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  public Parser(java.io.Reader stream) {
    jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }
  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }
  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }
  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;
  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {
        int[] oldentry = (int[])(enum.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }
  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[123];
    for (int i = 0; i < 123; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 89; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 123; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }
  final public void enable_tracing() {
  }
  final public void disable_tracing() {
  }
  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 25; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }
  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }
  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }
}
"
bsh.ParserConstants,"/* Generated By:JJTree&JavaCC: Do not edit this line. ParserConstants.java */
package bsh;
public interface ParserConstants {
  int EOF = 0;
  int NONPRINTABLE = 6;
  int SINGLE_LINE_COMMENT = 7;
  int HASH_BANG_COMMENT = 8;
  int FORMAL_COMMENT = 9;
  int MULTI_LINE_COMMENT = 10;
  int BOOLEAN = 11;
  int BREAK = 12;
  int CLASS = 13;
  int BYTE = 14;
  int CASE = 15;
  int CATCH = 16;
  int CHAR = 17;
  int CONST = 18;
  int CONTINUE = 19;
  int _DEFAULT = 20;
  int DO = 21;
  int DOUBLE = 22;
  int ELSE = 23;
  int FALSE = 24;
  int FINAL = 25;
  int FINALLY = 26;
  int FLOAT = 27;
  int FOR = 28;
  int GOTO = 29;
  int IF = 30;
  int IMPORT = 31;
  int INSTANCEOF = 32;
  int INT = 33;
  int INTERFACE = 34;
  int LONG = 35;
  int NEW = 36;
  int NULL = 37;
  int PRIVATE = 38;
  int PROTECTED = 39;
  int PUBLIC = 40;
  int RETURN = 41;
  int SHORT = 42;
  int STATIC = 43;
  int SWITCH = 44;
  int THROW = 45;
  int TRUE = 46;
  int TRY = 47;
  int VOID = 48;
  int WHILE = 49;
  int INTEGER_LITERAL = 50;
  int DECIMAL_LITERAL = 51;
  int HEX_LITERAL = 52;
  int OCTAL_LITERAL = 53;
  int FLOATING_POINT_LITERAL = 54;
  int EXPONENT = 55;
  int CHARACTER_LITERAL = 56;
  int STRING_LITERAL = 57;
  int IDENTIFIER = 58;
  int LETTER = 59;
  int DIGIT = 60;
  int LPAREN = 61;
  int RPAREN = 62;
  int LBRACE = 63;
  int RBRACE = 64;
  int LBRACKET = 65;
  int RBRACKET = 66;
  int SEMICOLON = 67;
  int COMMA = 68;
  int DOT = 69;
  int ASSIGN = 70;
  int GT = 71;
  int GTX = 72;
  int LT = 73;
  int LTX = 74;
  int BANG = 75;
  int TILDE = 76;
  int HOOK = 77;
  int COLON = 78;
  int EQ = 79;
  int LE = 80;
  int LEX = 81;
  int GE = 82;
  int GEX = 83;
  int NE = 84;
  int BOOL_OR = 85;
  int BOOL_ORX = 86;
  int BOOL_AND = 87;
  int BOOL_ANDX = 88;
  int INCR = 89;
  int DECR = 90;
  int PLUS = 91;
  int MINUS = 92;
  int STAR = 93;
  int SLASH = 94;
  int BIT_AND = 95;
  int BIT_ANDX = 96;
  int BIT_OR = 97;
  int BIT_ORX = 98;
  int XOR = 99;
  int MOD = 100;
  int LSHIFT = 101;
  int LSHIFTX = 102;
  int RSIGNEDSHIFT = 103;
  int RSIGNEDSHIFTX = 104;
  int RUNSIGNEDSHIFT = 105;
  int RUNSIGNEDSHIFTX = 106;
  int PLUSASSIGN = 107;
  int MINUSASSIGN = 108;
  int STARASSIGN = 109;
  int SLASHASSIGN = 110;
  int ANDASSIGN = 111;
  int ANDASSIGNX = 112;
  int ORASSIGN = 113;
  int ORASSIGNX = 114;
  int XORASSIGN = 115;
  int MODASSIGN = 116;
  int LSHIFTASSIGN = 117;
  int LSHIFTASSIGNX = 118;
  int RSIGNEDSHIFTASSIGN = 119;
  int RSIGNEDSHIFTASSIGNX = 120;
  int RUNSIGNEDSHIFTASSIGN = 121;
  int RUNSIGNEDSHIFTASSIGNX = 122;
  int DEFAULT = 0;
  String[] tokenImage = {
    ""<EOF>"",
    ""\"" \"""",
    ""\""\\t\"""",
    ""\""\\r\"""",
    ""\""\\f\"""",
    ""\""\\n\"""",
    ""<NONPRINTABLE>"",
    ""<SINGLE_LINE_COMMENT>"",
    ""<HASH_BANG_COMMENT>"",
    ""<FORMAL_COMMENT>"",
    ""<MULTI_LINE_COMMENT>"",
    ""\""boolean\"""",
    ""\""break\"""",
    ""\""class\"""",
    ""\""byte\"""",
    ""\""case\"""",
    ""\""catch\"""",
    ""\""char\"""",
    ""\""const\"""",
    ""\""continue\"""",
    ""\""default\"""",
    ""\""do\"""",
    ""\""double\"""",
    ""\""else\"""",
    ""\""false\"""",
    ""\""final\"""",
    ""\""finally\"""",
    ""\""float\"""",
    ""\""for\"""",
    ""\""goto\"""",
    ""\""if\"""",
    ""\""import\"""",
    ""\""instanceof\"""",
    ""\""int\"""",
    ""\""interface\"""",
    ""\""long\"""",
    ""\""new\"""",
    ""\""null\"""",
    ""\""private\"""",
    ""\""protected\"""",
    ""\""public\"""",
    ""\""return\"""",
    ""\""short\"""",
    ""\""static\"""",
    ""\""switch\"""",
    ""\""throw\"""",
    ""\""true\"""",
    ""\""try\"""",
    ""\""void\"""",
    ""\""while\"""",
    ""<INTEGER_LITERAL>"",
    ""<DECIMAL_LITERAL>"",
    ""<HEX_LITERAL>"",
    ""<OCTAL_LITERAL>"",
    ""<FLOATING_POINT_LITERAL>"",
    ""<EXPONENT>"",
    ""<CHARACTER_LITERAL>"",
    ""<STRING_LITERAL>"",
    ""<IDENTIFIER>"",
    ""<LETTER>"",
    ""<DIGIT>"",
    ""\""(\"""",
    ""\"")\"""",
    ""\""{\"""",
    ""\""}\"""",
    ""\""[\"""",
    ""\""]\"""",
    ""\"";\"""",
    ""\"",\"""",
    ""\"".\"""",
    ""\""=\"""",
    ""\"">\"""",
    ""\""@gt\"""",
    ""\""<\"""",
    ""\""@lt\"""",
    ""\""!\"""",
    ""\""~\"""",
    ""\""?\"""",
    ""\"":\"""",
    ""\""==\"""",
    ""\""<=\"""",
    ""\""@lteq\"""",
    ""\"">=\"""",
    ""\""@gteq\"""",
    ""\""!=\"""",
    ""\""||\"""",
    ""\""@or\"""",
    ""\""&&\"""",
    ""\""@and\"""",
    ""\""++\"""",
    ""\""--\"""",
    ""\""+\"""",
    ""\""-\"""",
    ""\""*\"""",
    ""\""/\"""",
    ""\""&\"""",
    ""\""@bitwise_and\"""",
    ""\""|\"""",
    ""\""@bitwise_or\"""",
    ""\""^\"""",
    ""\""%\"""",
    ""\""<<\"""",
    ""\""@left_shift\"""",
    ""\"">>\"""",
    ""\""@right_shift\"""",
    ""\"">>>\"""",
    ""\""@right_unsigned_shift\"""",
    ""\""+=\"""",
    ""\""-=\"""",
    ""\""*=\"""",
    ""\""/=\"""",
    ""\""&=\"""",
    ""\""@and_assign\"""",
    ""\""|=\"""",
    ""\""@or_assign\"""",
    ""\""^=\"""",
    ""\""%=\"""",
    ""\""<<=\"""",
    ""\""@left_shift_assign\"""",
    ""\"">>=\"""",
    ""\""@right_shift_assign\"""",
    ""\"">>>=\"""",
    ""\""@right_unsigned_shift_assign\"""",
  };
}
"
bsh.ParserTokenManager,"/* Generated By:JJTree&JavaCC: Do not edit this line. ParserTokenManager.java */
package bsh;
import java.io.Reader;
class ParserTokenManager implements ParserConstants
{
private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x3eL) != 0L)
            return 0;
         if ((active1 & 0x400040000000L) != 0L)
            return 56;
         if ((active1 & 0x20L) != 0L)
            return 11;
         if ((active0 & 0x3fffffffff800L) != 0L)
         {
            jjmatchedKind = 58;
            return 35;
         }
         return -1;
      case 1:
         if ((active0 & 0x3ffffbf9ff800L) != 0L)
         {
            if (jjmatchedPos != 1)
            {
               jjmatchedKind = 58;
               jjmatchedPos = 1;
            }
            return 35;
         }
         if ((active0 & 0x40600000L) != 0L)
            return 35;
         return -1;
      case 2:
         if ((active0 & 0x37fe9afdff800L) != 0L)
         {
            if (jjmatchedPos != 2)
            {
               jjmatchedKind = 58;
               jjmatchedPos = 2;
            }
            return 35;
         }
         if ((active0 & 0x801610000000L) != 0L)
            return 35;
         return -1;
      case 3:
         if ((active0 & 0x140282082c000L) != 0L)
            return 35;
         if ((active0 & 0x23fc58f5d3800L) != 0L)
         {
            if (jjmatchedPos != 3)
            {
               jjmatchedKind = 58;
               jjmatchedPos = 3;
            }
            return 35;
         }
         return -1;
      case 4:
         if ((active0 & 0x1bc580580800L) != 0L)
         {
            if (jjmatchedPos != 4)
            {
               jjmatchedKind = 58;
               jjmatchedPos = 4;
            }
            return 35;
         }
         if ((active0 & 0x224000f053000L) != 0L)
            return 35;
         return -1;
      case 5:
         if ((active0 & 0xc504180800L) != 0L)
         {
            jjmatchedKind = 58;
            jjmatchedPos = 5;
            return 35;
         }
         if ((active0 & 0x1b0080400000L) != 0L)
            return 35;
         return -1;
      case 6:
         if ((active0 & 0x4004100800L) != 0L)
            return 35;
         if ((active0 & 0x8500080000L) != 0L)
         {
            jjmatchedKind = 58;
            jjmatchedPos = 6;
            return 35;
         }
         return -1;
      case 7:
         if ((active0 & 0x8500000000L) != 0L)
         {
            jjmatchedKind = 58;
            jjmatchedPos = 7;
            return 35;
         }
         if ((active0 & 0x80000L) != 0L)
            return 35;
         return -1;
      case 8:
         if ((active0 & 0x100000000L) != 0L)
         {
            jjmatchedKind = 58;
            jjmatchedPos = 8;
            return 35;
         }
         if ((active0 & 0x8400000000L) != 0L)
            return 35;
         return -1;
      case 9:
         if ((active0 & 0x100000000L) != 0L)
            return 35;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_0(int pos, long active0, long active1)
{
   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);
}
private final int jjStopAtPos(int pos, int kind)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   return pos + 1;
}
private final int jjStartNfaWithStates_0(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_0(state, pos + 1);
}
private final int jjMoveStringLiteralDfa0_0()
{
   switch(curChar)
   {
      case 9:
         return jjStartNfaWithStates_0(0, 2, 0);
      case 10:
         return jjStartNfaWithStates_0(0, 5, 0);
      case 12:
         return jjStartNfaWithStates_0(0, 4, 0);
      case 13:
         return jjStartNfaWithStates_0(0, 3, 0);
      case 32:
         return jjStartNfaWithStates_0(0, 1, 0);
      case 33:
         jjmatchedKind = 75;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x100000L);
      case 37:
         jjmatchedKind = 100;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x10000000000000L);
      case 38:
         jjmatchedKind = 95;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x800000800000L);
      case 40:
         return jjStopAtPos(0, 61);
      case 41:
         return jjStopAtPos(0, 62);
      case 42:
         jjmatchedKind = 93;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x200000000000L);
      case 43:
         jjmatchedKind = 91;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x80002000000L);
      case 44:
         return jjStopAtPos(0, 68);
      case 45:
         jjmatchedKind = 92;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x100004000000L);
      case 46:
         return jjStartNfaWithStates_0(0, 69, 11);
      case 47:
         jjmatchedKind = 94;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x400000000000L);
      case 58:
         return jjStopAtPos(0, 78);
      case 59:
         return jjStopAtPos(0, 67);
      case 60:
         jjmatchedKind = 73;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x20002000010000L);
      case 61:
         jjmatchedKind = 70;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000L);
      case 62:
         jjmatchedKind = 71;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x280028000040000L);
      case 63:
         return jjStopAtPos(0, 77);
      case 64:
         return jjMoveStringLiteralDfa1_0(0x0L, 0x5450545014a0500L);
      case 91:
         return jjStopAtPos(0, 65);
      case 93:
         return jjStopAtPos(0, 66);
      case 94:
         jjmatchedKind = 99;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000000000L);
      case 98:
         return jjMoveStringLiteralDfa1_0(0x5800L, 0x0L);
      case 99:
         return jjMoveStringLiteralDfa1_0(0xfa000L, 0x0L);
      case 100:
         return jjMoveStringLiteralDfa1_0(0x700000L, 0x0L);
      case 101:
         return jjMoveStringLiteralDfa1_0(0x800000L, 0x0L);
      case 102:
         return jjMoveStringLiteralDfa1_0(0x1f000000L, 0x0L);
      case 103:
         return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L);
      case 105:
         return jjMoveStringLiteralDfa1_0(0x7c0000000L, 0x0L);
      case 108:
         return jjMoveStringLiteralDfa1_0(0x800000000L, 0x0L);
      case 110:
         return jjMoveStringLiteralDfa1_0(0x3000000000L, 0x0L);
      case 112:
         return jjMoveStringLiteralDfa1_0(0x1c000000000L, 0x0L);
      case 114:
         return jjMoveStringLiteralDfa1_0(0x20000000000L, 0x0L);
      case 115:
         return jjMoveStringLiteralDfa1_0(0x1c0000000000L, 0x0L);
      case 116:
         return jjMoveStringLiteralDfa1_0(0xe00000000000L, 0x0L);
      case 118:
         return jjMoveStringLiteralDfa1_0(0x1000000000000L, 0x0L);
      case 119:
         return jjMoveStringLiteralDfa1_0(0x2000000000000L, 0x0L);
      case 123:
         return jjStopAtPos(0, 63);
      case 124:
         jjmatchedKind = 97;
         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000000200000L);
      case 125:
         return jjStopAtPos(0, 64);
      case 126:
         return jjStopAtPos(0, 76);
      default :
         return jjMoveNfa_0(6, 0);
   }
}
private final int jjMoveStringLiteralDfa1_0(long active0, long active1)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(0, active0, active1);
      return 1;
   }
   switch(curChar)
   {
      case 38:
         if ((active1 & 0x800000L) != 0L)
            return jjStopAtPos(1, 87);
         break;
      case 43:
         if ((active1 & 0x2000000L) != 0L)
            return jjStopAtPos(1, 89);
         break;
      case 45:
         if ((active1 & 0x4000000L) != 0L)
            return jjStopAtPos(1, 90);
         break;
      case 60:
         if ((active1 & 0x2000000000L) != 0L)
         {
            jjmatchedKind = 101;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x20000000000000L);
      case 61:
         if ((active1 & 0x8000L) != 0L)
            return jjStopAtPos(1, 79);
         else if ((active1 & 0x10000L) != 0L)
            return jjStopAtPos(1, 80);
         else if ((active1 & 0x40000L) != 0L)
            return jjStopAtPos(1, 82);
         else if ((active1 & 0x100000L) != 0L)
            return jjStopAtPos(1, 84);
         else if ((active1 & 0x80000000000L) != 0L)
            return jjStopAtPos(1, 107);
         else if ((active1 & 0x100000000000L) != 0L)
            return jjStopAtPos(1, 108);
         else if ((active1 & 0x200000000000L) != 0L)
            return jjStopAtPos(1, 109);
         else if ((active1 & 0x400000000000L) != 0L)
            return jjStopAtPos(1, 110);
         else if ((active1 & 0x800000000000L) != 0L)
            return jjStopAtPos(1, 111);
         else if ((active1 & 0x2000000000000L) != 0L)
            return jjStopAtPos(1, 113);
         else if ((active1 & 0x8000000000000L) != 0L)
            return jjStopAtPos(1, 115);
         else if ((active1 & 0x10000000000000L) != 0L)
            return jjStopAtPos(1, 116);
         break;
      case 62:
         if ((active1 & 0x8000000000L) != 0L)
         {
            jjmatchedKind = 103;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x280020000000000L);
      case 97:
         return jjMoveStringLiteralDfa2_0(active0, 0x1018000L, active1, 0x1000001000000L);
      case 98:
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x500000000L);
      case 101:
         return jjMoveStringLiteralDfa2_0(active0, 0x21000100000L, active1, 0L);
      case 102:
         if ((active0 & 0x40000000L) != 0L)
            return jjStartNfaWithStates_0(1, 30, 35);
         break;
      case 103:
         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x80100L);
      case 104:
         return jjMoveStringLiteralDfa2_0(active0, 0x2240000020000L, active1, 0L);
      case 105:
         return jjMoveStringLiteralDfa2_0(active0, 0x6000000L, active1, 0L);
      case 108:
         return jjMoveStringLiteralDfa2_0(active0, 0x8802000L, active1, 0x40004000020400L);
      case 109:
         return jjMoveStringLiteralDfa2_0(active0, 0x80000000L, active1, 0L);
      case 110:
         return jjMoveStringLiteralDfa2_0(active0, 0x700000000L, active1, 0L);
      case 111:
         if ((active0 & 0x200000L) != 0L)
         {
            jjmatchedKind = 21;
            jjmatchedPos = 1;
         }
         return jjMoveStringLiteralDfa2_0(active0, 0x10008304c0800L, active1, 0x4000000400000L);
      case 114:
         return jjMoveStringLiteralDfa2_0(active0, 0xc0c000001000L, active1, 0x500050000000000L);
      case 116:
         return jjMoveStringLiteralDfa2_0(active0, 0x80000000000L, active1, 0L);
      case 117:
         return jjMoveStringLiteralDfa2_0(active0, 0x12000000000L, active1, 0L);
      case 119:
         return jjMoveStringLiteralDfa2_0(active0, 0x100000000000L, active1, 0L);
      case 121:
         return jjMoveStringLiteralDfa2_0(active0, 0x4000L, active1, 0L);
      case 124:
         if ((active1 & 0x200000L) != 0L)
            return jjStopAtPos(1, 85);
         break;
      default :
         break;
   }
   return jjStartNfa_0(0, active0, active1);
}
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1)
{
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(0, old0, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(1, active0, active1);
      return 2;
   }
   switch(curChar)
   {
      case 61:
         if ((active1 & 0x20000000000000L) != 0L)
            return jjStopAtPos(2, 117);
         else if ((active1 & 0x80000000000000L) != 0L)
            return jjStopAtPos(2, 119);
         break;
      case 62:
         if ((active1 & 0x20000000000L) != 0L)
         {
            jjmatchedKind = 105;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x200000000000000L);
      case 97:
         return jjMoveStringLiteralDfa3_0(active0, 0x80000022000L, active1, 0L);
      case 98:
         return jjMoveStringLiteralDfa3_0(active0, 0x10000000000L, active1, 0L);
      case 101:
         return jjMoveStringLiteralDfa3_0(active0, 0x1000L, active1, 0x40004000000000L);
      case 102:
         return jjMoveStringLiteralDfa3_0(active0, 0x100000L, active1, 0L);
      case 105:
         return jjMoveStringLiteralDfa3_0(active0, 0x3104000000000L, active1, 0x500050500000000L);
      case 108:
         return jjMoveStringLiteralDfa3_0(active0, 0x2001000000L, active1, 0L);
      case 110:
         return jjMoveStringLiteralDfa3_0(active0, 0x8060c0000L, active1, 0x1000001000000L);
      case 111:
         return jjMoveStringLiteralDfa3_0(active0, 0x48008000800L, active1, 0L);
      case 112:
         return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L);
      case 114:
         if ((active0 & 0x10000000L) != 0L)
            return jjStartNfaWithStates_0(2, 28, 35);
         else if ((active1 & 0x400000L) != 0L)
         {
            jjmatchedKind = 86;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x200000000000L, active1, 0x4000000000000L);
      case 115:
         return jjMoveStringLiteralDfa3_0(active0, 0x100808000L, active1, 0L);
      case 116:
         if ((active0 & 0x200000000L) != 0L)
         {
            jjmatchedKind = 33;
            jjmatchedPos = 2;
         }
         else if ((active1 & 0x100L) != 0L)
         {
            jjmatchedKind = 72;
            jjmatchedPos = 2;
         }
         else if ((active1 & 0x400L) != 0L)
         {
            jjmatchedKind = 74;
            jjmatchedPos = 2;
         }
         return jjMoveStringLiteralDfa3_0(active0, 0x20420014000L, active1, 0xa0000L);
      case 117:
         return jjMoveStringLiteralDfa3_0(active0, 0x400000400000L, active1, 0L);
      case 119:
         if ((active0 & 0x1000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 36, 35);
         break;
      case 121:
         if ((active0 & 0x800000000000L) != 0L)
            return jjStartNfaWithStates_0(2, 47, 35);
         break;
      default :
         break;
   }
   return jjStartNfa_0(1, active0, active1);
}
private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1)
{
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(1, old0, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(2, active0, active1);
      return 3;
   }
   switch(curChar)
   {
      case 61:
         if ((active1 & 0x200000000000000L) != 0L)
            return jjStopAtPos(3, 121);
         break;
      case 95:
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x4000000000000L);
      case 97:
         return jjMoveStringLiteralDfa4_0(active0, 0xe101000L, active1, 0L);
      case 98:
         return jjMoveStringLiteralDfa4_0(active0, 0x400000L, active1, 0L);
      case 99:
         return jjMoveStringLiteralDfa4_0(active0, 0x10000L, active1, 0L);
      case 100:
         if ((active0 & 0x1000000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 48, 35);
         else if ((active1 & 0x1000000L) != 0L)
         {
            jjmatchedKind = 88;
            jjmatchedPos = 3;
         }
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x1000000000000L);
      case 101:
         if ((active0 & 0x4000L) != 0L)
            return jjStartNfaWithStates_0(3, 14, 35);
         else if ((active0 & 0x8000L) != 0L)
            return jjStartNfaWithStates_0(3, 15, 35);
         else if ((active0 & 0x800000L) != 0L)
            return jjStartNfaWithStates_0(3, 23, 35);
         else if ((active0 & 0x400000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 46, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x400000000L, active1, 0xa0000L);
      case 102:
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x40004000000000L);
      case 103:
         if ((active0 & 0x800000000L) != 0L)
            return jjStartNfaWithStates_0(3, 35, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x500050000000000L);
      case 108:
         if ((active0 & 0x2000000000L) != 0L)
            return jjStartNfaWithStates_0(3, 37, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x2010000000800L, active1, 0L);
      case 111:
         if ((active0 & 0x20000000L) != 0L)
            return jjStartNfaWithStates_0(3, 29, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x200080000000L, active1, 0L);
      case 114:
         if ((active0 & 0x20000L) != 0L)
            return jjStartNfaWithStates_0(3, 17, 35);
         return jjMoveStringLiteralDfa4_0(active0, 0x40000000000L, active1, 0L);
      case 115:
         return jjMoveStringLiteralDfa4_0(active0, 0x1042000L, active1, 0L);
      case 116:
         return jjMoveStringLiteralDfa4_0(active0, 0x188100080000L, active1, 0x500000000L);
      case 117:
         return jjMoveStringLiteralDfa4_0(active0, 0x20000000000L, active1, 0L);
      case 118:
         return jjMoveStringLiteralDfa4_0(active0, 0x4000000000L, active1, 0L);
      default :
         break;
   }
   return jjStartNfa_0(2, active0, active1);
}
private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1)
{
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(2, old0, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(3, active0, active1);
      return 4;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x1000000000000L);
      case 97:
         return jjMoveStringLiteralDfa5_0(active0, 0x4100000000L, active1, 0x4000000000000L);
      case 99:
         return jjMoveStringLiteralDfa5_0(active0, 0x100000000000L, active1, 0L);
      case 101:
         if ((active0 & 0x1000000L) != 0L)
            return jjStartNfaWithStates_0(4, 24, 35);
         else if ((active0 & 0x2000000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 49, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0x8000000800L, active1, 0L);
      case 104:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_0(4, 16, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x500050000000000L);
      case 105:
         return jjMoveStringLiteralDfa5_0(active0, 0x90000080000L, active1, 0L);
      case 107:
         if ((active0 & 0x1000L) != 0L)
            return jjStartNfaWithStates_0(4, 12, 35);
         break;
      case 108:
         if ((active0 & 0x2000000L) != 0L)
         {
            jjmatchedKind = 25;
            jjmatchedPos = 4;
         }
         return jjMoveStringLiteralDfa5_0(active0, 0x4400000L, active1, 0L);
      case 113:
         if ((active1 & 0x20000L) != 0L)
            return jjStopAtPos(4, 81);
         else if ((active1 & 0x80000L) != 0L)
            return jjStopAtPos(4, 83);
         break;
      case 114:
         return jjMoveStringLiteralDfa5_0(active0, 0x20480000000L, active1, 0L);
      case 115:
         if ((active0 & 0x2000L) != 0L)
            return jjStartNfaWithStates_0(4, 13, 35);
         break;
      case 116:
         if ((active0 & 0x40000L) != 0L)
            return jjStartNfaWithStates_0(4, 18, 35);
         else if ((active0 & 0x8000000L) != 0L)
            return jjStartNfaWithStates_0(4, 27, 35);
         else if ((active0 & 0x40000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 42, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x40004000000000L);
      case 117:
         return jjMoveStringLiteralDfa5_0(active0, 0x100000L, active1, 0L);
      case 119:
         if ((active0 & 0x200000000000L) != 0L)
            return jjStartNfaWithStates_0(4, 45, 35);
         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x500000000L);
      default :
         break;
   }
   return jjStartNfa_0(3, active0, active1);
}
private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1)
{
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(3, old0, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(4, active0, active1);
      return 5;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x40004000000000L);
      case 97:
         return jjMoveStringLiteralDfa6_0(active0, 0x800L, active1, 0x1000000000000L);
      case 99:
         if ((active0 & 0x10000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 40, 35);
         else if ((active0 & 0x80000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 43, 35);
         return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L);
      case 101:
         if ((active0 & 0x400000L) != 0L)
            return jjStartNfaWithStates_0(5, 22, 35);
         break;
      case 102:
         return jjMoveStringLiteralDfa6_0(active0, 0x400000000L, active1, 0L);
      case 104:
         if ((active0 & 0x100000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 44, 35);
         break;
      case 105:
         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x500000000L);
      case 108:
         return jjMoveStringLiteralDfa6_0(active0, 0x4100000L, active1, 0L);
      case 110:
         if ((active0 & 0x20000000000L) != 0L)
            return jjStartNfaWithStates_0(5, 41, 35);
         return jjMoveStringLiteralDfa6_0(active0, 0x100080000L, active1, 0L);
      case 115:
         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x4000000000000L);
      case 116:
         if ((active0 & 0x80000000L) != 0L)
            return jjStartNfaWithStates_0(5, 31, 35);
         return jjMoveStringLiteralDfa6_0(active0, 0x4000000000L, active1, 0x500050000000000L);
      default :
         break;
   }
   return jjStartNfa_0(4, active0, active1);
}
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1)
{
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(4, old0, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(5, active0, active1);
      return 6;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x500050000000000L);
      case 97:
         return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L);
      case 99:
         return jjMoveStringLiteralDfa7_0(active0, 0x100000000L, active1, 0L);
      case 101:
         if ((active0 & 0x4000000000L) != 0L)
            return jjStartNfaWithStates_0(6, 38, 35);
         break;
      case 110:
         if ((active0 & 0x800L) != 0L)
            return jjStartNfaWithStates_0(6, 11, 35);
         break;
      case 115:
         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x45004500000000L);
      case 116:
         if ((active0 & 0x100000L) != 0L)
            return jjStartNfaWithStates_0(6, 20, 35);
         return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L);
      case 117:
         return jjMoveStringLiteralDfa7_0(active0, 0x80000L, active1, 0L);
      case 121:
         if ((active0 & 0x4000000L) != 0L)
            return jjStartNfaWithStates_0(6, 26, 35);
         break;
      default :
         break;
   }
   return jjStartNfa_0(5, active0, active1);
}
private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1)
{
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(5, old0, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(6, active0, active1);
      return 7;
   }
   switch(curChar)
   {
      case 99:
         return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L);
      case 101:
         if ((active0 & 0x80000L) != 0L)
            return jjStartNfaWithStates_0(7, 19, 35);
         return jjMoveStringLiteralDfa8_0(active0, 0x8100000000L, active1, 0x500000000L);
      case 104:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x40004000000000L);
      case 105:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x4000000000000L);
      case 115:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x101010000000000L);
      case 117:
         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x400040000000000L);
      default :
         break;
   }
   return jjStartNfa_0(6, active0, active1);
}
private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1)
{
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(6, old0, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(7, active0, active1);
      return 8;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x500000000L);
      case 100:
         if ((active0 & 0x8000000000L) != 0L)
            return jjStartNfaWithStates_0(8, 39, 35);
         break;
      case 101:
         if ((active0 & 0x400000000L) != 0L)
            return jjStartNfaWithStates_0(8, 34, 35);
         break;
      case 103:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x4000000000000L);
      case 104:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x100010000000000L);
      case 105:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x41004000000000L);
      case 110:
         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x400040000000000L);
      case 111:
         return jjMoveStringLiteralDfa9_0(active0, 0x100000000L, active1, 0L);
      default :
         break;
   }
   return jjStartNfa_0(7, active0, active1);
}
private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1)
{
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(7, old0, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(8, active0, active1);
      return 9;
   }
   switch(curChar)
   {
      case 97:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x100000000L);
      case 102:
         if ((active0 & 0x100000000L) != 0L)
            return jjStartNfaWithStates_0(9, 32, 35);
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x40004000000000L);
      case 103:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x1000000000000L);
      case 105:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x100010000000000L);
      case 110:
         if ((active1 & 0x4000000000000L) != 0L)
            return jjStopAtPos(9, 114);
         break;
      case 111:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x400000000L);
      case 115:
         return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x400040000000000L);
      default :
         break;
   }
   return jjStartNfa_0(8, active0, active1);
}
private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1)
{
   if (((active0 &= old0) | (active1 &= old1)) == 0L)
      return jjStartNfa_0(8, old0, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(9, 0L, active1);
      return 10;
   }
   switch(curChar)
   {
      case 102:
         return jjMoveStringLiteralDfa11_0(active1, 0x100010000000000L);
      case 105:
         return jjMoveStringLiteralDfa11_0(active1, 0x400040000000000L);
      case 110:
         if ((active1 & 0x1000000000000L) != 0L)
            return jjStopAtPos(10, 112);
         return jjMoveStringLiteralDfa11_0(active1, 0x100000000L);
      case 114:
         if ((active1 & 0x400000000L) != 0L)
            return jjStopAtPos(10, 98);
         break;
      case 116:
         if ((active1 & 0x4000000000L) != 0L)
         {
            jjmatchedKind = 102;
            jjmatchedPos = 10;
         }
         return jjMoveStringLiteralDfa11_0(active1, 0x40000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(9, 0L, active1);
}
private final int jjMoveStringLiteralDfa11_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(9, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(10, 0L, active1);
      return 11;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa12_0(active1, 0x40000000000000L);
      case 100:
         if ((active1 & 0x100000000L) != 0L)
            return jjStopAtPos(11, 96);
         break;
      case 103:
         return jjMoveStringLiteralDfa12_0(active1, 0x400040000000000L);
      case 116:
         if ((active1 & 0x10000000000L) != 0L)
         {
            jjmatchedKind = 104;
            jjmatchedPos = 11;
         }
         return jjMoveStringLiteralDfa12_0(active1, 0x100000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(10, 0L, active1);
}
private final int jjMoveStringLiteralDfa12_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(10, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(11, 0L, active1);
      return 12;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa13_0(active1, 0x100000000000000L);
      case 97:
         return jjMoveStringLiteralDfa13_0(active1, 0x40000000000000L);
      case 110:
         return jjMoveStringLiteralDfa13_0(active1, 0x400040000000000L);
      default :
         break;
   }
   return jjStartNfa_0(11, 0L, active1);
}
private final int jjMoveStringLiteralDfa13_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(11, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(12, 0L, active1);
      return 13;
   }
   switch(curChar)
   {
      case 97:
         return jjMoveStringLiteralDfa14_0(active1, 0x100000000000000L);
      case 101:
         return jjMoveStringLiteralDfa14_0(active1, 0x400040000000000L);
      case 115:
         return jjMoveStringLiteralDfa14_0(active1, 0x40000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(12, 0L, active1);
}
private final int jjMoveStringLiteralDfa14_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(12, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(13, 0L, active1);
      return 14;
   }
   switch(curChar)
   {
      case 100:
         return jjMoveStringLiteralDfa15_0(active1, 0x400040000000000L);
      case 115:
         return jjMoveStringLiteralDfa15_0(active1, 0x140000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(13, 0L, active1);
}
private final int jjMoveStringLiteralDfa15_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(13, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(14, 0L, active1);
      return 15;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa16_0(active1, 0x400040000000000L);
      case 105:
         return jjMoveStringLiteralDfa16_0(active1, 0x40000000000000L);
      case 115:
         return jjMoveStringLiteralDfa16_0(active1, 0x100000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(14, 0L, active1);
}
private final int jjMoveStringLiteralDfa16_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(14, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(15, 0L, active1);
      return 16;
   }
   switch(curChar)
   {
      case 103:
         return jjMoveStringLiteralDfa17_0(active1, 0x40000000000000L);
      case 105:
         return jjMoveStringLiteralDfa17_0(active1, 0x100000000000000L);
      case 115:
         return jjMoveStringLiteralDfa17_0(active1, 0x400040000000000L);
      default :
         break;
   }
   return jjStartNfa_0(15, 0L, active1);
}
private final int jjMoveStringLiteralDfa17_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(15, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(16, 0L, active1);
      return 17;
   }
   switch(curChar)
   {
      case 103:
         return jjMoveStringLiteralDfa18_0(active1, 0x100000000000000L);
      case 104:
         return jjMoveStringLiteralDfa18_0(active1, 0x400040000000000L);
      case 110:
         if ((active1 & 0x40000000000000L) != 0L)
            return jjStopAtPos(17, 118);
         break;
      default :
         break;
   }
   return jjStartNfa_0(16, 0L, active1);
}
private final int jjMoveStringLiteralDfa18_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(16, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(17, 0L, active1);
      return 18;
   }
   switch(curChar)
   {
      case 105:
         return jjMoveStringLiteralDfa19_0(active1, 0x400040000000000L);
      case 110:
         if ((active1 & 0x100000000000000L) != 0L)
            return jjStopAtPos(18, 120);
         break;
      default :
         break;
   }
   return jjStartNfa_0(17, 0L, active1);
}
private final int jjMoveStringLiteralDfa19_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(17, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(18, 0L, active1);
      return 19;
   }
   switch(curChar)
   {
      case 102:
         return jjMoveStringLiteralDfa20_0(active1, 0x400040000000000L);
      default :
         break;
   }
   return jjStartNfa_0(18, 0L, active1);
}
private final int jjMoveStringLiteralDfa20_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(18, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(19, 0L, active1);
      return 20;
   }
   switch(curChar)
   {
      case 116:
         if ((active1 & 0x40000000000L) != 0L)
         {
            jjmatchedKind = 106;
            jjmatchedPos = 20;
         }
         return jjMoveStringLiteralDfa21_0(active1, 0x400000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(19, 0L, active1);
}
private final int jjMoveStringLiteralDfa21_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(19, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(20, 0L, active1);
      return 21;
   }
   switch(curChar)
   {
      case 95:
         return jjMoveStringLiteralDfa22_0(active1, 0x400000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(20, 0L, active1);
}
private final int jjMoveStringLiteralDfa22_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(20, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(21, 0L, active1);
      return 22;
   }
   switch(curChar)
   {
      case 97:
         return jjMoveStringLiteralDfa23_0(active1, 0x400000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(21, 0L, active1);
}
private final int jjMoveStringLiteralDfa23_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(21, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(22, 0L, active1);
      return 23;
   }
   switch(curChar)
   {
      case 115:
         return jjMoveStringLiteralDfa24_0(active1, 0x400000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(22, 0L, active1);
}
private final int jjMoveStringLiteralDfa24_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(22, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(23, 0L, active1);
      return 24;
   }
   switch(curChar)
   {
      case 115:
         return jjMoveStringLiteralDfa25_0(active1, 0x400000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(23, 0L, active1);
}
private final int jjMoveStringLiteralDfa25_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(23, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(24, 0L, active1);
      return 25;
   }
   switch(curChar)
   {
      case 105:
         return jjMoveStringLiteralDfa26_0(active1, 0x400000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(24, 0L, active1);
}
private final int jjMoveStringLiteralDfa26_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(24, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(25, 0L, active1);
      return 26;
   }
   switch(curChar)
   {
      case 103:
         return jjMoveStringLiteralDfa27_0(active1, 0x400000000000000L);
      default :
         break;
   }
   return jjStartNfa_0(25, 0L, active1);
}
private final int jjMoveStringLiteralDfa27_0(long old1, long active1)
{
   if (((active1 &= old1)) == 0L)
      return jjStartNfa_0(25, 0L, old1); 
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(26, 0L, active1);
      return 27;
   }
   switch(curChar)
   {
      case 110:
         if ((active1 & 0x400000000000000L) != 0L)
            return jjStopAtPos(27, 122);
         break;
      default :
         break;
   }
   return jjStartNfa_0(26, 0L, active1);
}
private final void jjCheckNAdd(int state)
{
   if (jjrounds[state] != jjround)
   {
      jjstateSet[jjnewStateCnt++] = state;
      jjrounds[state] = jjround;
   }
}
private final void jjAddStates(int start, int end)
{
   do {
      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
   } while (start++ != end);
}
private final void jjCheckNAddTwoStates(int state1, int state2)
{
   jjCheckNAdd(state1);
   jjCheckNAdd(state2);
}
private final void jjCheckNAddStates(int start, int end)
{
   do {
      jjCheckNAdd(jjnextStates[start]);
   } while (start++ != end);
}
private final void jjCheckNAddStates(int start)
{
   jjCheckNAdd(jjnextStates[start]);
   jjCheckNAdd(jjnextStates[start + 1]);
}
static final long[] jjbitVec0 = {
   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec1 = {
   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec3 = {
   0x1ff00000fffffffeL, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L
};
static final long[] jjbitVec4 = {
   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL
};
static final long[] jjbitVec5 = {
   0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec6 = {
   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L
};
static final long[] jjbitVec7 = {
   0xffffffffffffffffL, 0xffffffffffffffffL, 0x0L, 0x0L
};
static final long[] jjbitVec8 = {
   0x3fffffffffffL, 0x0L, 0x0L, 0x0L
};
private final int jjMoveNfa_0(int startState, int curPos)
{
   int[] nextStates;
   int startsAt = 0;
   jjnewStateCnt = 74;
   int i = 1;
   jjstateSet[0] = startState;
   int j, kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
                  if ((0x1ffffffffL & l) != 0L)
                  {
                     if (kind > 6)
                        kind = 6;
                     jjCheckNAdd(0);
                  }
                  else if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddStates(0, 6);
                  else if (curChar == 47)
                     jjAddStates(7, 9);
                  else if (curChar == 36)
                  {
                     if (kind > 58)
                        kind = 58;
                     jjCheckNAdd(35);
                  }
                  else if (curChar == 34)
                     jjCheckNAddStates(10, 12);
                  else if (curChar == 39)
                     jjAddStates(13, 14);
                  else if (curChar == 46)
                     jjCheckNAdd(11);
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 1;
                  if ((0x3fe000000000000L & l) != 0L)
                  {
                     if (kind > 50)
                        kind = 50;
                     jjCheckNAddTwoStates(8, 9);
                  }
                  else if (curChar == 48)
                  {
                     if (kind > 50)
                        kind = 50;
                     jjCheckNAddStates(15, 17);
                  }
                  break;
               case 56:
                  if (curChar == 42)
                     jjCheckNAddTwoStates(69, 70);
                  else if (curChar == 47)
                     jjCheckNAddStates(18, 20);
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 61;
                  break;
               case 0:
                  if ((0x1ffffffffL & l) == 0L)
                     break;
                  if (kind > 6)
                     kind = 6;
                  jjCheckNAdd(0);
                  break;
               case 1:
                  if (curChar == 33)
                     jjCheckNAddStates(21, 23);
                  break;
               case 2:
                  if ((0xffffffffffffdbffL & l) != 0L)
                     jjCheckNAddStates(21, 23);
                  break;
               case 3:
                  if ((0x2400L & l) != 0L && kind > 8)
                     kind = 8;
                  break;
               case 4:
                  if (curChar == 10 && kind > 8)
                     kind = 8;
                  break;
               case 5:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 4;
                  break;
               case 7:
                  if ((0x3fe000000000000L & l) == 0L)
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjCheckNAddTwoStates(8, 9);
                  break;
               case 8:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjCheckNAddTwoStates(8, 9);
                  break;
               case 10:
                  if (curChar == 46)
                     jjCheckNAdd(11);
                  break;
               case 11:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 54)
                     kind = 54;
                  jjCheckNAddStates(24, 26);
                  break;
               case 13:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(14);
                  break;
               case 14:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 54)
                     kind = 54;
                  jjCheckNAddTwoStates(14, 15);
                  break;
               case 16:
                  if (curChar == 39)
                     jjAddStates(13, 14);
                  break;
               case 17:
                  if ((0xffffff7fffffdbffL & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 18:
                  if (curChar == 39 && kind > 56)
                     kind = 56;
                  break;
               case 20:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 21:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(22, 18);
                  break;
               case 22:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 23:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 24;
                  break;
               case 24:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(22);
                  break;
               case 25:
                  if (curChar == 34)
                     jjCheckNAddStates(10, 12);
                  break;
               case 26:
                  if ((0xfffffffbffffdbffL & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 28:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 29:
                  if (curChar == 34 && kind > 57)
                     kind = 57;
                  break;
               case 30:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(27, 30);
                  break;
               case 31:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 32:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 33;
                  break;
               case 33:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(31);
                  break;
               case 34:
                  if (curChar != 36)
                     break;
                  if (kind > 58)
                     kind = 58;
                  jjCheckNAdd(35);
                  break;
               case 35:
                  if ((0x3ff001000000000L & l) == 0L)
                     break;
                  if (kind > 58)
                     kind = 58;
                  jjCheckNAdd(35);
                  break;
               case 36:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddStates(0, 6);
                  break;
               case 37:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(37, 38);
                  break;
               case 38:
                  if (curChar != 46)
                     break;
                  if (kind > 54)
                     kind = 54;
                  jjCheckNAddStates(31, 33);
                  break;
               case 39:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 54)
                     kind = 54;
                  jjCheckNAddStates(31, 33);
                  break;
               case 41:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(42);
                  break;
               case 42:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 54)
                     kind = 54;
                  jjCheckNAddTwoStates(42, 15);
                  break;
               case 43:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(43, 44);
                  break;
               case 45:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(46);
                  break;
               case 46:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 54)
                     kind = 54;
                  jjCheckNAddTwoStates(46, 15);
                  break;
               case 47:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddStates(34, 36);
                  break;
               case 49:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(50);
                  break;
               case 50:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(50, 15);
                  break;
               case 51:
                  if (curChar != 48)
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjCheckNAddStates(15, 17);
                  break;
               case 53:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjCheckNAddTwoStates(53, 9);
                  break;
               case 54:
                  if ((0xff000000000000L & l) == 0L)
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjCheckNAddTwoStates(54, 9);
                  break;
               case 55:
                  if (curChar == 47)
                     jjAddStates(7, 9);
                  break;
               case 57:
                  if ((0xffffffffffffdbffL & l) != 0L)
                     jjCheckNAddStates(18, 20);
                  break;
               case 58:
                  if ((0x2400L & l) != 0L && kind > 7)
                     kind = 7;
                  break;
               case 59:
                  if (curChar == 10 && kind > 7)
                     kind = 7;
                  break;
               case 60:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 59;
                  break;
               case 61:
                  if (curChar == 42)
                     jjCheckNAddTwoStates(62, 63);
                  break;
               case 62:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(62, 63);
                  break;
               case 63:
                  if (curChar == 42)
                     jjCheckNAddStates(37, 39);
                  break;
               case 64:
                  if ((0xffff7bffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(65, 63);
                  break;
               case 65:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(65, 63);
                  break;
               case 66:
                  if (curChar == 47 && kind > 9)
                     kind = 9;
                  break;
               case 67:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 61;
                  break;
               case 68:
                  if (curChar == 42)
                     jjCheckNAddTwoStates(69, 70);
                  break;
               case 69:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(69, 70);
                  break;
               case 70:
                  if (curChar == 42)
                     jjCheckNAddStates(40, 42);
                  break;
               case 71:
                  if ((0xffff7bffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(72, 70);
                  break;
               case 72:
                  if ((0xfffffbffffffffffL & l) != 0L)
                     jjCheckNAddTwoStates(72, 70);
                  break;
               case 73:
                  if (curChar == 47 && kind > 10)
                     kind = 10;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
               case 35:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 58)
                     kind = 58;
                  jjCheckNAdd(35);
                  break;
               case 2:
                  jjAddStates(21, 23);
                  break;
               case 9:
                  if ((0x100000001000L & l) != 0L && kind > 50)
                     kind = 50;
                  break;
               case 12:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(43, 44);
                  break;
               case 15:
                  if ((0x5000000050L & l) != 0L && kind > 54)
                     kind = 54;
                  break;
               case 17:
                  if ((0xffffffffefffffffL & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 19:
                  if (curChar == 92)
                     jjAddStates(45, 47);
                  break;
               case 20:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAdd(18);
                  break;
               case 26:
                  if ((0xffffffffefffffffL & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 27:
                  if (curChar == 92)
                     jjAddStates(48, 50);
                  break;
               case 28:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 40:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(51, 52);
                  break;
               case 44:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(53, 54);
                  break;
               case 48:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(55, 56);
                  break;
               case 52:
                  if ((0x100000001000000L & l) != 0L)
                     jjCheckNAdd(53);
                  break;
               case 53:
                  if ((0x7e0000007eL & l) == 0L)
                     break;
                  if (kind > 50)
                     kind = 50;
                  jjCheckNAddTwoStates(53, 9);
                  break;
               case 57:
                  jjAddStates(18, 20);
                  break;
               case 62:
                  jjCheckNAddTwoStates(62, 63);
                  break;
               case 64:
               case 65:
                  jjCheckNAddTwoStates(65, 63);
                  break;
               case 69:
                  jjCheckNAddTwoStates(69, 70);
                  break;
               case 71:
               case 72:
                  jjCheckNAddTwoStates(72, 70);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         MatchLoop: do
         {
            switch(jjstateSet[--i])
            {
               case 6:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                  {
                     if (kind > 6)
                        kind = 6;
                     jjCheckNAdd(0);
                  }
                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
                  {
                     if (kind > 58)
                        kind = 58;
                     jjCheckNAdd(35);
                  }
                  break;
               case 0:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 6)
                     kind = 6;
                  jjCheckNAdd(0);
                  break;
               case 2:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjAddStates(21, 23);
                  break;
               case 17:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjstateSet[jjnewStateCnt++] = 18;
                  break;
               case 26:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjAddStates(10, 12);
                  break;
               case 34:
               case 35:
                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 58)
                     kind = 58;
                  jjCheckNAdd(35);
                  break;
               case 57:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjAddStates(18, 20);
                  break;
               case 62:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(62, 63);
                  break;
               case 64:
               case 65:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(65, 63);
                  break;
               case 69:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(69, 70);
                  break;
               case 71:
               case 72:
                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
                     jjCheckNAddTwoStates(72, 70);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 74 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
static final int[] jjnextStates = {
   37, 38, 43, 44, 47, 48, 15, 56, 67, 68, 26, 27, 29, 17, 19, 52, 
   54, 9, 57, 58, 60, 2, 3, 5, 11, 12, 15, 26, 27, 31, 29, 39, 
   40, 15, 47, 48, 15, 63, 64, 66, 70, 71, 73, 13, 14, 20, 21, 23, 
   28, 30, 32, 41, 42, 45, 46, 49, 50, 
};
private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec0[i2] & l2) != 0L);
      default : 
         return false;
   }
}
private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec0[i2] & l2) != 0L);
      default : 
         if ((jjbitVec1[i1] & l1) != 0L)
            return true;
         return false;
   }
}
private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec4[i2] & l2) != 0L);
      case 48:
         return ((jjbitVec5[i2] & l2) != 0L);
      case 49:
         return ((jjbitVec6[i2] & l2) != 0L);
      case 51:
         return ((jjbitVec7[i2] & l2) != 0L);
      case 61:
         return ((jjbitVec8[i2] & l2) != 0L);
      default : 
         if ((jjbitVec3[i1] & l1) != 0L)
            return true;
         return false;
   }
}
public static final String[] jjstrLiteralImages = {
"""", null, null, null, null, null, null, null, null, null, null, 
""\142\157\157\154\145\141\156"", ""\142\162\145\141\153"", ""\143\154\141\163\163"", ""\142\171\164\145"", 
""\143\141\163\145"", ""\143\141\164\143\150"", ""\143\150\141\162"", ""\143\157\156\163\164"", 
""\143\157\156\164\151\156\165\145"", ""\144\145\146\141\165\154\164"", ""\144\157"", ""\144\157\165\142\154\145"", 
""\145\154\163\145"", ""\146\141\154\163\145"", ""\146\151\156\141\154"", 
""\146\151\156\141\154\154\171"", ""\146\154\157\141\164"", ""\146\157\162"", ""\147\157\164\157"", ""\151\146"", 
""\151\155\160\157\162\164"", ""\151\156\163\164\141\156\143\145\157\146"", ""\151\156\164"", 
""\151\156\164\145\162\146\141\143\145"", ""\154\157\156\147"", ""\156\145\167"", ""\156\165\154\154"", 
""\160\162\151\166\141\164\145"", ""\160\162\157\164\145\143\164\145\144"", ""\160\165\142\154\151\143"", 
""\162\145\164\165\162\156"", ""\163\150\157\162\164"", ""\163\164\141\164\151\143"", 
""\163\167\151\164\143\150"", ""\164\150\162\157\167"", ""\164\162\165\145"", ""\164\162\171"", 
""\166\157\151\144"", ""\167\150\151\154\145"", null, null, null, null, null, null, null, null, null, 
null, null, ""\50"", ""\51"", ""\173"", ""\175"", ""\133"", ""\135"", ""\73"", ""\54"", ""\56"", 
""\75"", ""\76"", ""\100\147\164"", ""\74"", ""\100\154\164"", ""\41"", ""\176"", ""\77"", ""\72"", 
""\75\75"", ""\74\75"", ""\100\154\164\145\161"", ""\76\75"", ""\100\147\164\145\161"", ""\41\75"", 
""\174\174"", ""\100\157\162"", ""\46\46"", ""\100\141\156\144"", ""\53\53"", ""\55\55"", ""\53"", 
""\55"", ""\52"", ""\57"", ""\46"", ""\100\142\151\164\167\151\163\145\137\141\156\144"", 
""\174"", ""\100\142\151\164\167\151\163\145\137\157\162"", ""\136"", ""\45"", ""\74\74"", 
""\100\154\145\146\164\137\163\150\151\146\164"", ""\76\76"", ""\100\162\151\147\150\164\137\163\150\151\146\164"", ""\76\76\76"", 
""\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164"", ""\53\75"", ""\55\75"", ""\52\75"", ""\57\75"", ""\46\75"", 
""\100\141\156\144\137\141\163\163\151\147\156"", ""\174\75"", ""\100\157\162\137\141\163\163\151\147\156"", ""\136\75"", ""\45\75"", 
""\74\74\75"", ""\100\154\145\146\164\137\163\150\151\146\164\137\141\163\163\151\147\156"", 
""\76\76\75"", 
""\100\162\151\147\150\164\137\163\150\151\146\164\137\141\163\163\151\147\156"", ""\76\76\76\75"", 
""\100\162\151\147\150\164\137\165\156\163\151\147\156\145\144\137\163\150\151\146\164\137\141\163\163\151\147\156"", };
public static final String[] lexStateNames = {
   ""DEFAULT"", 
};
static final long[] jjtoToken = {
   0xe747fffffffff801L, 0x7ffffffffffffffL, 
};
static final long[] jjtoSkip = {
   0x7feL, 0x0L, 
};
static final long[] jjtoSpecial = {
   0x780L, 0x0L, 
};
private ASCII_UCodeESC_CharStream input_stream;
private final int[] jjrounds = new int[74];
private final int[] jjstateSet = new int[148];
protected char curChar;
public ParserTokenManager(ASCII_UCodeESC_CharStream stream)
{
   if (ASCII_UCodeESC_CharStream.staticFlag)
      throw new Error(""ERROR: Cannot use a static CharStream class with a non-static lexical analyzer."");
   input_stream = stream;
}
public ParserTokenManager(ASCII_UCodeESC_CharStream stream, int lexState)
{
   this(stream);
   SwitchTo(lexState);
}
public void ReInit(ASCII_UCodeESC_CharStream stream)
{
   jjmatchedPos = jjnewStateCnt = 0;
   curLexState = defaultLexState;
   input_stream = stream;
   ReInitRounds();
}
private final void ReInitRounds()
{
   int i;
   jjround = 0x80000001;
   for (i = 74; i-- > 0;)
      jjrounds[i] = 0x80000000;
}
public void ReInit(ASCII_UCodeESC_CharStream stream, int lexState)
{
   ReInit(stream);
   SwitchTo(lexState);
}
public void SwitchTo(int lexState)
{
   if (lexState >= 1 || lexState < 0)
      throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
   else
      curLexState = lexState;
}
private final Token jjFillToken()
{
   Token t = Token.newToken(jjmatchedKind);
   t.kind = jjmatchedKind;
   String im = jjstrLiteralImages[jjmatchedKind];
   t.image = (im == null) ? input_stream.GetImage() : im;
   t.beginLine = input_stream.getBeginLine();
   t.beginColumn = input_stream.getBeginColumn();
   t.endLine = input_stream.getEndLine();
   t.endColumn = input_stream.getEndColumn();
   return t;
}
int curLexState = 0;
int defaultLexState = 0;
int jjnewStateCnt;
int jjround;
int jjmatchedPos;
int jjmatchedKind;
public final Token getNextToken() 
{
  int kind;
  Token specialToken = null;
  Token matchedToken;
  int curPos = 0;
  EOFLoop :
  for (;;)
  {   
   try   
   {     
      curChar = input_stream.BeginToken();
   }     
   catch(java.io.IOException e)
   {        
      jjmatchedKind = 0;
      matchedToken = jjFillToken();
      matchedToken.specialToken = specialToken;
      return matchedToken;
   }
   jjmatchedKind = 0x7fffffff;
   jjmatchedPos = 0;
   curPos = jjMoveStringLiteralDfa0_0();
   if (jjmatchedKind != 0x7fffffff)
   {
      if (jjmatchedPos + 1 < curPos)
         input_stream.backup(curPos - jjmatchedPos - 1);
      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
      {
         matchedToken = jjFillToken();
         matchedToken.specialToken = specialToken;
         return matchedToken;
      }
      else
      {
         if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
         {
            matchedToken = jjFillToken();
            if (specialToken == null)
               specialToken = matchedToken;
            else
            {
               matchedToken.specialToken = specialToken;
               specialToken = (specialToken.next = matchedToken);
            }
         }
         continue EOFLoop;
      }
   }
   int error_line = input_stream.getEndLine();
   int error_column = input_stream.getEndColumn();
   String error_after = null;
   boolean EOFSeen = false;
   try { input_stream.readChar(); input_stream.backup(1); }
   catch (java.io.IOException e1) {
      EOFSeen = true;
      error_after = curPos <= 1 ? """" : input_stream.GetImage();
      if (curChar == '\n' || curChar == '\r') {
         error_line++;
         error_column = 0;
      }
      else
         error_column++;
   }
   if (!EOFSeen) {
      input_stream.backup(1);
      error_after = curPos <= 1 ? """" : input_stream.GetImage();
   }
   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
  }
}
}
"
bsh.ParserTreeConstants,"/* Generated By:JJTree: Do not edit this line. src/bsh/ParserTreeConstants.java */
package bsh;
public interface ParserTreeConstants
{
  public int JJTVOID = 0;
  public int JJTMETHODDECLARATION = 1;
  public int JJTIMPORTDECLARATION = 2;
  public int JJTVARIABLEDECLARATOR = 3;
  public int JJTARRAYINITIALIZER = 4;
  public int JJTFORMALPARAMETERS = 5;
  public int JJTFORMALPARAMETER = 6;
  public int JJTTYPE = 7;
  public int JJTRETURNTYPE = 8;
  public int JJTPRIMITIVETYPE = 9;
  public int JJTAMBIGUOUSNAME = 10;
  public int JJTASSIGNMENT = 11;
  public int JJTTERNARYEXPRESSION = 12;
  public int JJTBINARYEXPRESSION = 13;
  public int JJTUNARYEXPRESSION = 14;
  public int JJTCASTEXPRESSION = 15;
  public int JJTPRIMARYEXPRESSION = 16;
  public int JJTMETHODINVOCATION = 17;
  public int JJTPRIMARYSUFFIX = 18;
  public int JJTLHSPRIMARYEXPRESSION = 19;
  public int JJTLHSPRIMARYSUFFIX = 20;
  public int JJTLITERAL = 21;
  public int JJTARGUMENTS = 22;
  public int JJTALLOCATIONEXPRESSION = 23;
  public int JJTARRAYDIMENSIONS = 24;
  public int JJTBLOCK = 25;
  public int JJTSWITCHSTATEMENT = 26;
  public int JJTSWITCHLABEL = 27;
  public int JJTIFSTATEMENT = 28;
  public int JJTWHILESTATEMENT = 29;
  public int JJTFORSTATEMENT = 30;
  public int JJTTYPEDVARIABLEDECLARATION = 31;
  public int JJTSTATEMENTEXPRESSIONLIST = 32;
  public int JJTRETURNSTATEMENT = 33;
  public int JJTTHROWSTATEMENT = 34;
  public int JJTTRYSTATEMENT = 35;
  public String[] jjtNodeName = {
    ""void"",
    ""MethodDeclaration"",
    ""ImportDeclaration"",
    ""VariableDeclarator"",
    ""ArrayInitializer"",
    ""FormalParameters"",
    ""FormalParameter"",
    ""Type"",
    ""ReturnType"",
    ""PrimitiveType"",
    ""AmbiguousName"",
    ""Assignment"",
    ""TernaryExpression"",
    ""BinaryExpression"",
    ""UnaryExpression"",
    ""CastExpression"",
    ""PrimaryExpression"",
    ""MethodInvocation"",
    ""PrimarySuffix"",
    ""LHSPrimaryExpression"",
    ""LHSPrimarySuffix"",
    ""Literal"",
    ""Arguments"",
    ""AllocationExpression"",
    ""ArrayDimensions"",
    ""Block"",
    ""SwitchStatement"",
    ""SwitchLabel"",
    ""IfStatement"",
    ""WhileStatement"",
    ""ForStatement"",
    ""TypedVariableDeclaration"",
    ""StatementExpressionList"",
    ""ReturnStatement"",
    ""ThrowStatement"",
    ""TryStatement"",
  };
}
"
bsh.Primitive,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
    Wrapper for primitive types in Bsh.  This is package public because it 
	is used in the implementation of some bsh commands.
    See the note in LHS.java about wrapping objects.
*/
public class Primitive implements ParserConstants, java.io.Serializable
{
    // stored internally in java.lang. wrappers
    private Object value;
    private static class Special implements java.io.Serializable
    {
        private Special() { }
        public static final Special NULL_VALUE = new Special();
        public static final Special VOID_TYPE = new Special();
    }
    /*
        NULL means ""no value"".
        This ia a placeholder for primitive null value.
    */
    public static final Primitive NULL = new Primitive(Special.NULL_VALUE);
    /**
        VOID means ""no type"".
        Strictly speaking, this makes no sense here.  But for practical
        reasons we'll consider the lack of a type to be a special value.
    */
    public static final Primitive VOID = new Primitive(Special.VOID_TYPE);
    // private to prevent invocation with param that isn't a primitive-wrapper
    private Primitive(Object value)
    {
        if(value == null)
            throw new InterpreterError(
				""Use Primitve.NULL instead of Primitive(null)"");
        this.value = value;
    }
    public Primitive(Number number) { this((Object)number); }
    public Primitive(Boolean value) { this((Object)value); }
    public Primitive(Byte value) { this((Object)value); }
    public Primitive(Short value) { this((Object)value); }
    public Primitive(Character value) { this((Object)value); }
    public Primitive(Integer value) { this((Object)value); }
    public Primitive(Long value) { this((Object)value); }
    public Primitive(Float value) { this((Object)value); }
    public Primitive(Double value) { this((Object)value); }
    public Primitive(boolean value) { this(new Boolean(value)); }
    public Primitive(byte value) { this(new Byte(value)); }
    public Primitive(short value) { this(new Short(value)); }
    public Primitive(char value) { this(new Character(value)); }
    public Primitive(int value) { this(new Integer(value)); }
    public Primitive(long value) { this(new Long(value)); }
    public Primitive(float value) { this(new Float(value)); }
    public Primitive(double value) { this(new Double(value)); }
    public Object getValue()
    {
        if(value == Special.NULL_VALUE)
            return null;
        else if(value == Special.VOID_TYPE)
                throw new InterpreterError(""attempt to unwrap void type"");
        else
            return value;
    }
    public String toString()
    {
        if(value == Special.NULL_VALUE)
            return ""null"";
        else if(value == Special.VOID_TYPE)
            return ""void"";
        else
            return value.toString();
    }
    public Class getType()
    {
        return getType(value);
    }
    private Class getType(Object o)
    {
        if(o instanceof Boolean)
            return Boolean.TYPE;
        else if(o instanceof Byte)
            return Byte.TYPE;
        else if(o instanceof Short)
            return Short.TYPE;
        else if(o instanceof Character)
            return Character.TYPE;
        else if(o instanceof Integer)
            return Integer.TYPE;
        else if(o instanceof Long)
            return Long.TYPE;
        else if(o instanceof Float)
            return Float.TYPE;
        else if(o instanceof Double)
            return Double.TYPE;
        return null;
    }
/*
    public static Primitive binaryOperation(
		Primitive p1, Primitive p2, int kind )
        throws EvalError
    {
		return new Primitive( binaryOperation( p1, p2, kind ) );
    }
*/
	/**
		Allow primitive operations on wrapper types such as Integer and Boolean.
		This is static so that it can be reached from wherever...
	*/
    public static Object binaryOperation(
		Object obj1, Object obj2, int kind)
        throws EvalError
    {
		// special primitive types
        if(obj1 == NULL || obj2 == NULL)
            throw new EvalError(
				""Null value or 'null' literal in binary operation"");
        if(obj1 == VOID || obj2 == VOID)
            throw new EvalError(
			""Undefined variable, class, or 'void' literal in binary operation"");
		// keep track of the original types
		Class lhsOrgType = obj1.getClass();
		Class rhsOrgType = obj2.getClass();
		// Unwrap primitives
        if(obj1 instanceof Primitive)
            obj1 = ((Primitive)obj1).getValue();
        if(obj2 instanceof Primitive)
            obj2 = ((Primitive)obj2).getValue();
        Object[] operands = promotePrimitives(obj1, obj2);
        Object lhs = operands[0];
        Object rhs = operands[1];
        if(lhs.getClass() != rhs.getClass())
            throw new EvalError(""type mismatch in operator.  "" 
			+ lhs.getClass() + "" cannot be used with "" + rhs.getClass() );
		Object result;
		try {
			result = binaryOperationImpl( lhs, rhs, kind );
		} catch ( ArithmeticException e ) {
			throw new TargetError(""Arithemetic Exception in binary op"", e);
		}
		// If both original args were Primitives return a Primitive result
		// else it was mixed (wrapper/primitive) return the wrapper type
		if ( lhsOrgType == Primitive.class && rhsOrgType == Primitive.class )
			return new Primitive( result );
		else
			return result;
    }
    static Object binaryOperationImpl( Object lhs, Object rhs, int kind )
        throws EvalError
	{
        if(lhs instanceof Boolean)
            return booleanBinaryOperation((Boolean)lhs, (Boolean)rhs, kind);
        else if(lhs instanceof Integer)
            return intBinaryOperation( (Integer)lhs, (Integer)rhs, kind );
        else if(lhs instanceof Long)
            return longBinaryOperation((Long)lhs, (Long)rhs, kind);
        else if(lhs instanceof Float)
            return floatBinaryOperation((Float)lhs, (Float)rhs, kind);
        else if(lhs instanceof Double)
            return doubleBinaryOperation( (Double)lhs, (Double)rhs, kind);
        else
            throw new EvalError(""Invalid types in binary operator"" );
	}
    static Boolean booleanBinaryOperation(Boolean B1, Boolean B2, int kind)
        throws EvalError
    {
        boolean lhs = B1.booleanValue();
        boolean rhs = B2.booleanValue();
        switch(kind)
        {
            case EQ:
                return new Boolean(lhs == rhs);
            case NE:
                return new Boolean(lhs != rhs);
            case BOOL_OR:
            case BOOL_ORX:
                return new Boolean( lhs || rhs );
            case BOOL_AND:
            case BOOL_ANDX:
                return new Boolean( lhs && rhs );
            default:
                throw new InterpreterError(""unimplemented binary operator"");
        }
    }
    // returns Object covering both Long and Boolean return types
    static Object longBinaryOperation(Long L1, Long L2, int kind)
    {
        long lhs = L1.longValue();
        long rhs = L2.longValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Long(lhs + rhs);
            case MINUS:
                return new Long(lhs - rhs);
            case STAR:
                return new Long(lhs * rhs);
            case SLASH:
                return new Long(lhs / rhs);
            case MOD:
                return new Long(lhs % rhs);
            // bitwise
            case LSHIFT:
            case LSHIFTX:
                return new Long(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Long(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Long(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Long(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Long(lhs | rhs);
            case XOR:
                return new Long(lhs ^ rhs);
            default:
                throw new InterpreterError(""Unimplemented binary long operator"");
        }
    }
    // returns Object covering both Integer and Boolean return types
    static Object intBinaryOperation(Integer I1, Integer I2, int kind)
    {
        int lhs = I1.intValue();
        int rhs = I2.intValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Integer(lhs + rhs);
            case MINUS:
                return new Integer(lhs - rhs);
            case STAR:
                return new Integer(lhs * rhs);
            case SLASH:
                return new Integer(lhs / rhs);
            case MOD:
                return new Integer(lhs % rhs);
            // bitwise
            case LSHIFT:
            case LSHIFTX:
                return new Integer(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Integer(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Integer(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Integer(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Integer(lhs | rhs);
            case XOR:
                return new Integer(lhs ^ rhs);
            default:
                throw new InterpreterError(""Unimplemented binary integer operator"");
        }
    }
    // returns Object covering both Double and Boolean return types
    static Object doubleBinaryOperation(Double D1, Double D2, int kind)
        throws EvalError
    {
        double lhs = D1.doubleValue();
        double rhs = D2.doubleValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Double(lhs + rhs);
            case MINUS:
                return new Double(lhs - rhs);
            case STAR:
                return new Double(lhs * rhs);
            case SLASH:
                return new Double(lhs / rhs);
            case MOD:
                return new Double(lhs % rhs);
            // can't shift floating-point values
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new EvalError(""Can't shift doubles"");
            default:
                throw new InterpreterError(""Unimplemented binary double operator"");
        }
    }
    // returns Object covering both Long and Boolean return types
    static Object floatBinaryOperation(Float F1, Float F2, int kind)
        throws EvalError
    {
        float lhs = F1.floatValue();
        float rhs = F2.floatValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Float(lhs + rhs);
            case MINUS:
                return new Float(lhs - rhs);
            case STAR:
                return new Float(lhs * rhs);
            case SLASH:
                return new Float(lhs / rhs);
            case MOD:
                return new Float(lhs % rhs);
            // can't shift floats
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new EvalError(""Can't shift floats "");
            default:
                throw new InterpreterError(""Unimplemented binary float operator"");
        }
    }
	/**
		Promote primitive wrapper type to to Integer wrapper type
		Can we use the castPrimitive() (in BSHCastExpression) for this?
	*/
    static Object promoteToInteger(Object primitive)
    {
        if(primitive instanceof Character)
            return new Integer(((Character)primitive).charValue());
        else if((primitive instanceof Byte) || (primitive instanceof Short))
            return new Integer(((Number)primitive).intValue());
        return primitive;
    }
	/**
		Promote the pair of primitives to the maximum type of the two.
		e.g. [int,long]->[long,long]
	*/
    static Object[] promotePrimitives(Object lhs, Object rhs)
    {
        lhs = promoteToInteger(lhs);
        rhs = promoteToInteger(rhs);
        if((lhs instanceof Number) && (rhs instanceof Number))
        {
            Number lnum = (Number)lhs;
            Number rnum = (Number)rhs;
            boolean b;
            if((b = (lnum instanceof Double)) || (rnum instanceof Double))
            {
                if(b)
                    rhs = new Double(rnum.doubleValue());
                else
                    lhs = new Double(lnum.doubleValue());
            }
            else if((b = (lnum instanceof Float)) || (rnum instanceof Float))
            {
                if(b)
                    rhs = new Float(rnum.floatValue());
                else
                    lhs = new Float(lnum.floatValue());
            }
            else if((b = (lnum instanceof Long)) || (rnum instanceof Long))
            {
                if(b)
                    rhs = new Long(rnum.longValue());
                else
                    lhs = new Long(lnum.longValue());
            }
        }
        return new Object[] { lhs, rhs };
    }
    public static Primitive unaryOperation(Primitive val, int kind)
        throws EvalError
    {
        if(val == NULL)
            throw new EvalError(""illegal use of null object or 'null' literal"");
        if(val == VOID)
            throw new EvalError(""illegal use of undefined object or 'void' literal"");
        Class operandType = val.getType();
        Object operand = promoteToInteger(val.getValue());
        if(operand instanceof Boolean)
            return new Primitive(booleanUnaryOperation((Boolean)operand, kind));
        else if(operand instanceof Integer)
        {
            int result = intUnaryOperation((Integer)operand, kind);
            // ++ and -- must be cast back the original type
            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Primitive((byte)result);
                if(operandType == Short.TYPE)
                    return new Primitive((short)result);
                if(operandType == Character.TYPE)
                    return new Primitive((char)result);
            }
            return new Primitive(result);
        }
        else if(operand instanceof Long)
            return new Primitive(longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Primitive(floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Primitive(doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError(""An error occurred.  Please call technical support."");
    }
    static boolean booleanUnaryOperation(Boolean B, int kind) throws EvalError
    {
        boolean operand = B.booleanValue();
        switch(kind)
        {
            case BANG:
                return !operand;
            default:
                throw new EvalError(""Operator inappropriate for boolean"");
        }
    }
    static int intUnaryOperation(Integer I, int kind)
    {
        int operand = I.intValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError(""bad integer unaryOperation"");
        }
    }
    static long longUnaryOperation(Long L, int kind)
    {
        long operand = L.longValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError(""bad long unaryOperation"");
        }
    }
    static float floatUnaryOperation(Float F, int kind)
    {
        float operand = F.floatValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError(""bad float unaryOperation"");
        }
    }
    static double doubleUnaryOperation(Double D, int kind)
    {
        double operand = D.doubleValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError(""bad double unaryOperation"");
        }
    }
    public int intValue() throws EvalError
    {
        if(value instanceof Number)
            return((Number)value).intValue();
        else
            throw new EvalError(""Primitive not a number"");
    }
    public boolean booleanValue() throws EvalError
    {
        if(value instanceof Boolean)
            return((Boolean)value).booleanValue();
        else
            throw new EvalError(""Primitive not a boolean"");
    }
	/**
		Are we a numeric type:
		i.e. not boolean, null, or void
		(but including char)
	*/
	public boolean isNumber() {
		return ( !(value instanceof Boolean) 
			&& !(this == NULL) && !(this == VOID) );
	}
    public Number numberValue() throws EvalError
    {
		Object value = this.value;
		// Promote character to Number type for these purposes
		if (value instanceof Character)
			value = new Integer(((Character)value).charValue());
        if (value instanceof Number)
            return (Number)value;
        else
            throw new EvalError(""Primitive not a number"");
    }
	public boolean equals( Object obj ) {
		if ( obj instanceof Primitive )
			return ((Primitive)obj).value.equals( this.value );
		else
			return obj.equals( this.value );
	}
	/**
		Unwrap primitive values and map voids to nulls.
		Normal (non Primitive) types remain unchanged.
		@param obj object type which may be bsh.Primitive
		@return corresponding ""normal"" Java type, ""unwrapping"" 
			any bsh.Primitive types to their wrapper types.
	*/
	public static Object unwrap( Object obj ) {
		if ( obj == null )
			return null;
        // map voids to nulls for the outside world
        if(obj == Primitive.VOID)
            return null;
        // unwrap primitives
        if(obj instanceof Primitive)
            return((Primitive)obj).getValue();
        else
            return obj;
	}
}
"
bsh.Reflect,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.*;
import java.io.*;
import java.util.Vector;
/**
    All of the reflection API code lies here.  It is in the form
	of static utilities.  See the design note about object wrappers 
	in LHS.java for lamentations regarding this.
	Note: More work to do in here to fix up the extended signature matching.
	need to work in a search along with findMostSpecificSignature...
*/
class Reflect {
    /**
		Invoke method on object.
		invocation may be static (through the object instance) or dynamic.
		Object may be This type.
		The This handling is necessary here (previously thought it might 
		not be).
		@param callerInfo will be passed along in the caes where the method
		is a bsh scripted method.  It may be null to indicate no caller info.
	*/
/*
	In the case where this method calls a bsh scripted method the callstack
	is currently lost
*/
    public static Object invokeObjectMethod(
		Interpreter interpreter, Object object, String methodName, 
		Object[] args, SimpleNode callerInfo 
	) 
		throws ReflectError, InvocationTargetException, EvalError 
	{
        /*
		Interpreter.debug(""invoke Method "" + methodName + "" on object "" 
			+ object + "" with args ("");
		*/
		if ( object instanceof This )
			// This .invokeMethod() just calls the namespace invokeMethod
			return ((This)object).invokeMethod( 
				methodName, args, interpreter, null, callerInfo );
        else
			return invokeMethod( 
				object.getClass(), object, methodName, args, false );
    }
    /** 
		Invoke a static method.  No object instance is provided.
	*/
    public static Object invokeStaticMethod(
		Class clas, String methodName, Object [] args)
        throws ReflectError, InvocationTargetException, EvalError
    {
        Interpreter.debug(""invoke static Method"");
        return invokeMethod( clas, null, methodName, args, true );
    }
    public static Object getIndex(Object array, int index)
        throws ReflectError, TargetError
    {
        try {
            Object val = Array.get(array, index);
            return wrapPrimitive(val, array.getClass().getComponentType());
        }
        catch( ArrayIndexOutOfBoundsException  e1 ) {
			throw new TargetError( ""Array Index"", e1 );
        } catch(Exception e) {
            throw new ReflectError(""Array access:"" + e);
        }
    }
    public static void setIndex(Object array, int index, Object val)
        throws ReflectError, TargetError
    {
        try {
            val = unwrapPrimitive(val);
            Array.set(array, index, val);
        }
        catch( ArrayStoreException e2 ) {
			throw new TargetError( ""Array store exception"", e2 );
        } catch( IllegalArgumentException e1 ) {
			throw new TargetError( ""Illegal Argument"", 
				new ArrayStoreException( e1.toString() ) );
        } catch(Exception e) {
            throw new ReflectError(""Array access:"" + e);
        }
    }
    public static Object getStaticField(Class clas, String fieldName)
        throws ReflectError
    {
        return getFieldValue(clas, null, fieldName);
    }
    public static Object getObjectField(Object object, String fieldName)
        throws ReflectError
    {
		if ( object instanceof This )
			return ((This)object).namespace.getVariable( fieldName );
		else {
			try {
				return getFieldValue(object.getClass(), object, fieldName);
			} catch ( ReflectError e ) {
				// no field, try property acces
				if ( hasObjectPropertyGetter( object.getClass(), fieldName ) )
					return getObjectProperty( object, fieldName );
				else
					throw e;
			}
		}
    }
    static LHS getLHSStaticField(Class clas, String fieldName)
        throws ReflectError
    {
        Field f = getField(clas, fieldName);
        return new LHS(f);
    }
	/**
		Get an LHS reference to an object field.
		This method also deals with the field style property access.
		In the field does not exist we check for a property setter.
	*/
    static LHS getLHSObjectField(Object object, String fieldName)
        throws ReflectError
    {
		if ( object instanceof This )
			return new LHS(((This)object).namespace, fieldName );
		try {
			Field f = getField(object.getClass(), fieldName);
			return new LHS(object, f);
		} catch ( ReflectError e ) {
			// not a field, try property access
			if ( hasObjectPropertySetter( object.getClass(), fieldName ) )
				return new LHS( object, fieldName );
			else
				throw e;
		}
    }
    private static Object getFieldValue(
		Class clas, Object object, String fieldName) throws ReflectError
    {
        try {
            Field f = getField(clas, fieldName);
            if ( f == null )
                throw new ReflectError(""internal: field not found:""+fieldName);
            Object value = f.get(object);
            Class returnType = f.getType();
            return wrapPrimitive(value, returnType);
        }
        catch(NullPointerException e) {
            throw new ReflectError(
				""???"" + fieldName + "" is not a static field."");
        }
        catch(IllegalAccessException e) {
            throw new ReflectError(""Can't access field: "" + fieldName);
        }
    }
	/**
		All field lookup should come through here.
		i.e. this method owns Class getField();
	*/
    private static Field getField(Class clas, String fieldName)
        throws ReflectError
    {
        try
        {
			if ( Capabilities.haveAccessibility() )
				return findAccessibleField( clas, fieldName );
			else
				// this one only finds public 
				return clas.getField(fieldName);
        }
        catch(NoSuchFieldException e)
        {
			// try declaredField
            throw new ReflectError(""No such field: "" + fieldName );
        }
    }
	/**
		Used when accessibility capability is available to locate an occurrance
		of the field in the most derived class or superclass and set its 
		accessibility flag.
		Note that this method is not needed in the simple non accessible
		case because we don't have to hunt for fields.
		Note that classes may declare overlapping private fields, so the 
		distinction about the most derived is important.  Java doesn't normally
		allow this kind of access (super won't show private variables) so 
		there is no real syntax for specifying which class scope to use...
		Need to improve this to handle interfaces.
	*/
	private static Field findAccessibleField( Class clas, String fieldName ) 
		throws NoSuchFieldException
	{
		while ( clas != null )
		{
			try {
				Field field = clas.getDeclaredField(fieldName);
				if ( ReflectManager.RMSetAccessible( field ) )
					return field;
				// else fall through
			}
			catch(NoSuchFieldException e) { }
			clas = clas.getSuperclass();
		}
		throw new NoSuchFieldException( fieldName );
	}
    /**
        The full blown invoke method.  Everybody should come here.
		The invoked method may be static or dynamic unless onlyStatic is set
		(in which case object may be null).
		@param onlyStatic 
			The method located must be static, the object param may be null.
		Note: Method invocation could probably be speeded up if we eliminated
		the throwing of exceptions in the search for the proper method.
		We could probably cache our knowledge of method structure as well.
    */
    private static Object invokeMethod(
		Class clas, Object object, String name, Object[] args,
		boolean onlyStatic
	)
        throws ReflectError, InvocationTargetException, EvalError
    {
		if ( object == Primitive.NULL )
			throw new TargetError(""Attempt to invoke method ""
				+name+"" on null value"", new NullPointerException() );
		if ( object == Primitive.VOID )
			throw new EvalError(""Attempt to invoke method ""
				+name+"" on undefined variable or class name"" );
        if (args == null)
            args = new Object[] { };
        // Simple sanity check for voids
        // (maybe this should have been caught further up?)
        for(int i=0; i<args.length; i++)
            if(args[i] == Primitive.VOID)
                throw new ReflectError(""Attempt to pass void argument "" +
                    ""(position "" + i + "") to method: "" + name);
        Class returnType = null;
        Object returnValue = null;
        Class[] types = getTypes(args);
        unwrapPrimitives(args);
        try
        {
			// Try the easy case: Look for an accessible version of the 
			// direct match.
			Method m = null;
			try {
				m  = findAccessibleMethod(clas, name, types, onlyStatic);
			} catch ( SecurityException e ) { }
			if ( m == null )
				Interpreter.debug(""Exact method "" + 
					StringUtil.methodString(name, types) +
					"" not found in '"" + clas.getName() + ""'"" );
			// Next look for an assignable match
            if ( m == null ) {
				// If no args stop here
				if ( types.length == 0 )
					throw new ReflectError(
						""No args ""+ ( onlyStatic ? ""static "" : """" )
						+""method "" + StringUtil.methodString(name, types) + 
						"" not found in class'"" + clas.getName() + ""'"");
				// try to find an assignable method
				Method[] methods = clas.getMethods();
				if ( onlyStatic )
					// only try the static methods
					methods = retainStaticMethods( methods );
				m = findMostSpecificMethod(name, types, methods);
				// try to find an extended method
				methods = clas.getMethods();
				if ( m == null )
					m = findExtendedMethod(name, args, methods);
				// If we found an assignable method, make sure it's accessible
				if ( m != null ) {
					try {
						m = findAccessibleMethod( clas, m.getName(), 
							m.getParameterTypes(), onlyStatic);
					} catch ( SecurityException e ) { }
				}
            }
			// Found something?
			if (m == null )
				throw new ReflectError(
					( onlyStatic ? ""Static method "" : ""Method "" )
					+ StringUtil.methodString(name, types) + 
					"" not found in class'"" + clas.getName() + ""'"");
			// Invoke it
            returnValue =  m.invoke(object, args);
            if(returnValue == null)
                returnValue = Primitive.NULL;
            returnType = m.getReturnType();
        } catch(IllegalAccessException e) {
            throw new ReflectError( 
				""Cannot access method "" + StringUtil.methodString(name, types) +
                "" in '"" + clas.getName() + ""' :"" + e);
        }
        return wrapPrimitive(returnValue, returnType);
    }
	/**
		Return only the static methods
	*/
	private static Method [] retainStaticMethods( Method [] methods ) {
		Vector v = new Vector();
		for(int i=0; i<methods.length; i++)
			if ( Modifier.isStatic( methods[i].getModifiers() ) )
				v.addElement( methods[i] );
		Method [] ma = new Method [ v.size() ];
		v.copyInto( ma );
		return ma;
	}
	/**
		Locate a version of the method with the exact signature specified 
		that is accessible via a public interface or through a public 
		superclass.
		This solves the problem that arises when a package private class
		or private inner class implements a public interface or derives from
		a public type.
		@param onlyStatic the method located must be static.
		@returns null on not found
	*/
	static Method findAccessibleMethod( 
		Class clas, String name, Class [] types, boolean onlyStatic ) 
	{
		Method meth = null;
		Vector classQ = new Vector();
		classQ.addElement( clas );
		Method found = null;
		while ( classQ.size() > 0 ) 
		{
			Class c = (Class)classQ.firstElement();
			classQ.removeElementAt(0);
			// Is this it?
			// Is the class public or can we use accessibility?
			if ( Modifier.isPublic( c.getModifiers() )
				|| ( Capabilities.haveAccessibility() 
					&& ReflectManager.RMSetAccessible( c ) ) )
			{
				try {
					meth = c.getDeclaredMethod( name, types );
					// Is the method public or are we in accessibility mode?
					if ( Modifier.isPublic( meth.getModifiers() )  
						|| ( Capabilities.haveAccessibility() 
							&& ReflectManager.RMSetAccessible( meth ) ) )
					{
						found = meth; // Yes, it is.
						break;
					}
				} catch ( NoSuchMethodException e ) { 
					// ignore and move on
				}
			}
			// No, it is not.
			// Is this a class?
			if ( !c.isInterface() ) {
				Class superclass = c.getSuperclass();
				if ( superclass != null )
					classQ.addElement((Object)superclass);
			}
			// search all of its interfaces breadth first
			Class [] intfs = c.getInterfaces();
			for( int i=0; i< intfs.length; i++ )
				classQ.addElement((Object)intfs[i]);
		}
		/* 
			If we found one and it satisfies onlyStatic return it
			Note: I don't believe it is necessary to check for the static
			condition in the above search because the Java compiler will not
			let dynamic and static methods hide/override one another.  So
			we simply check what is found, if any, at the end.
		*/
		if ( found != null &&
			( !onlyStatic || Modifier.isStatic( found.getModifiers() ) ) )
			return found;
		// Didn't find one
		/*
		Interpreter.debug(
			""Can't find publically accessible ""+
			( onlyStatic ? "" static "" : """" )
			+"" version of method: ""+
			StringUtil.methodString(name, types) +
			"" in interfaces or class hierarchy of class ""+clas.getName() );
		*/
		return null;
	}
    private static Object wrapPrimitive(
		Object value, Class returnType) throws ReflectError
    {
        if(value == null)
            return Primitive.NULL;
        if(returnType == Void.TYPE)
            return Primitive.VOID;
        else
            if(returnType.isPrimitive())
            {
                if(value instanceof Number)
                    return new Primitive((Number)value);
                if(value instanceof Boolean)
                    return new Primitive((Boolean)value);
                if(value instanceof Character)
                    return new Primitive((Character)value);
                throw new ReflectError(""Something bad happened"");
            }
            else
                return value;
    }
    public static Class[] getTypes( Object[] args)
    {
        if(args == null)
            return new Class[0];
        Class[] types = new Class[args.length];
        for(int i=0; i<args.length; i++)
        {
            if(args[i] instanceof Primitive)
                types[i] = ((Primitive)args[i]).getType();
            else
                types[i] = args[i].getClass();
        }
        return types;
    }
    /*
        Replace Primitive wrappers with their java.lang wrapper values
        These barf if one of the args is void...  maybe these should throw
        an exception on void arg to force the rest of the code to clean up.
        There are places where we don't check right now... (constructors, index)
    */
    private static void unwrapPrimitives(Object[] args)
    {
        for(int i=0; i<args.length; i++)
            args[i] = unwrapPrimitive(args[i]);
    }
    private static Object unwrapPrimitive(Object arg)
    {
        if(arg instanceof Primitive)
            return((Primitive)arg).getValue();
        else
            return arg;
    }
    static Object constructObject(String clas, Object[] args)
        throws ReflectError, InvocationTargetException
    {
		Class c = BshClassManager.classForName( clas );
		if ( c == null )
			throw new ReflectError(""Class not found: ""+clas); 
		return constructObject( c, args );
	}
	/**
		Primary object constructor
	*/
    static Object constructObject(Class clas, Object[] args)
        throws ReflectError, InvocationTargetException
    {
        // simple sanity check for arguments
        for(int i=0; i<args.length; i++)
            if(args[i] == Primitive.VOID)
                throw new ReflectError(""Attempt to pass void argument "" +
                    ""(position "" + i + "") to constructor for: "" + clas);
		if ( clas.isInterface() )
			throw new ReflectError(
				""Can't create instance of an interface: ""+clas);
        Object obj = null;
        Class[] types = getTypes(args);
        unwrapPrimitives(args);
        Constructor con = null;
		/* 
			Find an appropriate constructor
			use declared here to see package and private as well
			(there are no inherited constructors to worry about) 
		*/
		Constructor[] constructors = clas.getDeclaredConstructors();
		Interpreter.debug(""Looking for most specific constructor: ""+clas);
		con = findMostSpecificConstructor(types, constructors);
		if ( con == null )
			if ( types.length == 0 )
				throw new ReflectError(
					""Can't find default constructor for: ""+clas);
			else
				con = findExtendedConstructor(args, constructors);
		if(con == null)
			throw new ReflectError(""Can't find constructor: "" 
				+ clas );
        try {
            obj = con.newInstance(args);
        } catch(InstantiationException e) {
            throw new ReflectError(""the class is abstract "");
        } catch(IllegalAccessException e) {
            throw new ReflectError(
				""we don't have permission to create an instance"");
        } catch(IllegalArgumentException e) {
            throw new ReflectError(""the number of arguments was wrong"");
        } 
		if (obj == null)
            throw new ReflectError(""couldn't construct the object"");
        return obj;
    }
    /**
        Implement JLS 15.11.2 for method resolution
		@param onlyStatic  only static methods will be considered.
		@returns null on no match
    */
    static Method findMostSpecificMethod(
		String name, Class[] idealMatch, Method[] methods )
    {
		// Pull out the method signatures whos name matches
		Vector sigs = new Vector();
		Vector meths = new Vector();
		for(int i=0; i<methods.length; i++)
			// method matches name 
			if ( methods[i].getName().equals( name )  ) 
			{
				meths.addElement( methods[i] );
				sigs.addElement( methods[i].getParameterTypes() );
			}
		Class [][] candidates = new Class [ sigs.size() ][];
		sigs.copyInto( candidates );
		Interpreter.debug(""Looking for most specific method: ""+name);
		int match = findMostSpecificSignature( idealMatch, candidates );
		if ( match == -1 )
			return null;
		else
			return (Method)meths.elementAt( match );
    }
	/**
		This uses the NameSpace.getAssignableForm() method to determine
		compatability of args.  This allows special (non standard Java) bsh 
		widening operations...
		@returns null on not found
	*/
    static Method findExtendedMethod(
		String name, Object[] args, Method[] methods)
    {
        Method bestMatch = null;
        Object[] tempArgs = new Object[args.length];
        for(int i = 0; i < methods.length; i++) {
            Method currentMethod = methods[i];
            if ( name.equals( currentMethod.getName() )) {
                Class[] parameters = currentMethod.getParameterTypes();
				if ( parameters.length != args.length )
					continue;
                try {
                    for(int j = 0; j < parameters.length; j++)
                        tempArgs[j] = NameSpace.getAssignableForm( 
							args[j], parameters[j]);
                    // if you get here, all the arguments were assignable
                    System.arraycopy(tempArgs, 0, args, 0, args.length);
                    return currentMethod;
                } catch(EvalError e) {
                    // do nothing (exception breaks you out of the for loop).
                }
            }
        }
        return null;
    }
    /*
        This method should exactly parallel findMostSpecificMethod()
    */
    static Constructor findMostSpecificConstructor(Class[] idealMatch,
        Constructor[] constructors)
    {
		Class [][] candidates = new Class [ constructors.length ] [];
		for(int i=0; i< candidates.length; i++ )
			candidates[i] = constructors[i].getParameterTypes();
		int match = findMostSpecificSignature( idealMatch, candidates );
		if ( match == -1 )
			return null;
		else
			return constructors[ match ];
    }
	/**
		This uses the NameSpace.getAssignableForm() method to determine
		compatability of args.  This allows special (non standard Java) bsh 
		widening operations...
	*/
    static Constructor findExtendedConstructor(
		Object[] args, Constructor[] constructors )
    {
        Constructor bestMatch = null;
        Object[] tempArgs = new Object[args.length];
        for(int i = 0; i < constructors.length; i++)
        {
            Constructor currentConstructor = constructors[i];
            Class[] parameters = currentConstructor.getParameterTypes();
			if ( parameters.length != args.length )
				continue;
            try {
                for(int j = 0; j < parameters.length; j++)
                    tempArgs[j] = 
						NameSpace.getAssignableForm(args[j], parameters[j]);
                // if you get here, all the arguments were assignable
                System.arraycopy(tempArgs, 0, args, 0, args.length);
                return currentConstructor;
            }
            catch(EvalError e)
            {
                // do nothing (exception breaks you out of the for loop).
            }
        }
        return null;
    }
	/**
        Implement JLS 15.11.2
		Return the index of the most specific arguments match or -1 if no	
		match is found.
	*/
	static int findMostSpecificSignature(
		Class [] idealMatch, Class [][] candidates )
	{
		Class [] bestMatch = null;
		int bestMatchIndex = -1;
		for (int i=0; i < candidates.length; i++) {
			Class[] targetMatch = candidates[i];
            /*
                If idealMatch fits targetMatch and this is the first match 
				or targetMatch is more specific than the best match, make it 
				the new best match.
            */
			if ( isAssignable(idealMatch, targetMatch ) &&
				((bestMatch == null) ||
					isAssignable( targetMatch, bestMatch )))
			{
				bestMatch = targetMatch;
				bestMatchIndex = i;
			}
		}
		if ( bestMatch != null ) {
			/*
			Interpreter.debug(""best match: "" 
				+ StringUtil.methodString(""args"",bestMatch));
			*/
			return bestMatchIndex;
		}
		else {
			Interpreter.debug(""no match found"");
			return -1;
		}
	}
	/**
		Determine if the 'from' signature is assignable to the 'to' signature
		'from' arg types, 'to' candidate types
		null value in 'to' type parameter indicates loose type.
		null value in either arg is considered empty array
	*/
    static boolean isAssignable(Class[] from, Class[] to)
    {
		if ( from == null )
			from = new Class[0];
		if ( to == null )
			to = new Class[0];
        if (from.length != to.length)
            return false;
        for(int i=0; i<from.length; i++)
        {
			// Null type indicates loose type.  Match anything.
			if ( to[i] == null )
				continue;
            // Let null arg type match any reference type
            if (from[i] == null) {
                if (!(to[i].isPrimitive()))
                    continue;
                else
                    return false;
            }
            if(!isAssignableFrom(to[i], from[i]))
                return false;
        }
        return true;
    }
    /**
		This base method is meant to address a deficiency of 
		Class.isAssignableFrom() which does not take primitive widening 
		conversions into account.
		Note that the getAssigbableForm() method in NameSpace is the primary
		bsh method for checking assignability.  It adds extended bsh
		conversions, etc.
		@param lhs assigning from rhs to lhs
		@param rhs assigning from rhs to lsh
	*/
    static boolean isAssignableFrom(Class lhs, Class rhs)
    {
        if(lhs.isPrimitive() && rhs.isPrimitive())
        {
            if(lhs == rhs)
                return true;
            // handle primitive widening conversions - JLS 5.1.2
            if((rhs == Byte.TYPE) && (lhs == Short.TYPE || lhs == Integer.TYPE ||
                lhs == Long.TYPE || lhs == Float.TYPE || lhs == Double.TYPE))
                    return true;
            if((rhs == Short.TYPE) && (lhs == Integer.TYPE || lhs == Long.TYPE ||
                lhs == Float.TYPE || lhs == Double.TYPE))
                    return true;
            if((rhs == Character.TYPE) && (lhs == Integer.TYPE || lhs == Long.TYPE ||
                lhs == Float.TYPE || lhs == Double.TYPE))
                    return true;
            if((rhs == Integer.TYPE) && (lhs == Long.TYPE || lhs == Float.TYPE ||
                lhs == Double.TYPE))
                    return true;
            if((rhs == Long.TYPE) && (lhs == Float.TYPE || lhs == Double.TYPE))
                return true;
            if((rhs == Float.TYPE) && (lhs == Double.TYPE))
                return true;
        }
        else
            if(lhs.isAssignableFrom(rhs))
                return true;
        return false;
    }
	private static String accessorName( String getorset, String propName ) {
        return getorset 
			+ String.valueOf(Character.toUpperCase(propName.charAt(0))) 
			+ propName.substring(1);
	}
    public static boolean hasObjectPropertyGetter( 
		Class clas, String propName ) 
	{
		String getterName = accessorName(""get"", propName );
		try {
			clas.getMethod( getterName, new Class [0] );
			return true;
		} catch ( NoSuchMethodException e ) {
			return false;
		}
	}
    public static boolean hasObjectPropertySetter( 
		Class clas, String propName ) 
	{
		String setterName = accessorName(""set"", propName );
		Class [] sig = new Class [] { clas };
		Method [] methods = clas.getMethods();
		// we don't know the right hand side of the assignment yet.
		// has at least one setter of the right name?
		for(int i=0; i<methods.length; i++)
			if ( methods[i].getName().equals( setterName ) )
				return true;
		return false;
	}
    public static Object getObjectProperty(
		Object obj, String propName)
        throws ReflectError
    {
        String accessorName = accessorName( ""get"", propName );
        Object[] args = new Object[] { };
        Interpreter.debug(""property access: "");
        try {
			try {
            	// null interpreter, accessor doesn't need to know
				// null callerInfo
				return invokeObjectMethod(null, obj, accessorName, args, null);
			} catch ( EvalError e ) {
				// what does this mean?
				throw new ReflectError(""getter: ""+e);
			}
        }
        catch(InvocationTargetException e)
        {
            throw new ReflectError(
			""Property accessor threw exception:"" + e );
        }
    }
    public static void setObjectProperty(
		Object obj, String propName, Object value)
        throws ReflectError, EvalError
    {
        String accessorName = accessorName( ""set"", propName );
        Object[] args = new Object[] { value };
        Interpreter.debug(""property access: "");
        try {
            // null interpreter, accessor doesn't need to know
			// null callerInfo
            invokeObjectMethod(null, obj, accessorName, args, null);
        }
        catch(InvocationTargetException e)
        {
            throw new EvalError(""Property accessor threw exception!"");
        }
    }
    /** 
		This method is meant to convert a JVM-array class name to the correct
    	'fully-qualified name' for the array class - JLS 6.7
	*/
    public static String normalizeClassName(Class type)
    {
        if(!type.isArray())
            return type.getName();
        StringBuffer className = new StringBuffer();
        try
        {
            className.append(getArrayBaseType(type).getName());
            for(int i = 0; i < getArrayDimensions(type); i++)
                className.append(""[]"");
        }
        catch(Exception e) { }
        return className.toString();
    }
	/**[
		returns the dimensionality of the Class
		returns 0 if the Class is not an array class
	*/
    public static int getArrayDimensions(Class arrayClass)
    {
        if(!arrayClass.isArray())
            return 0;
        return arrayClass.getName().lastIndexOf('[') + 1;
    }
    /**
		Returns the base type of an array Class.
    	throws ReflectError if the Class is not an array class.
	*/
    public static Class getArrayBaseType(Class arrayClass) throws ReflectError
    {
        if(!arrayClass.isArray())
            throw new ReflectError(""The class is not an array."");
		return arrayClass.getComponentType();
    }
}
"
bsh.ReflectError,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
class ReflectError extends Exception
{
	public ReflectError() { super(); }
	public ReflectError(String s) { super(s); }
}
"
bsh.ReflectManager,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import bsh.Capabilities.Unavailable;
/**
	ReflectManager is a dynamically loaded extension that supports extended
	reflection features supported by JDK1.2 and greater.
	In particular it currently supports accessible method and field access 
	supported by JDK1.2 and greater.
*/
public abstract class ReflectManager
{
	private static ReflectManager rfm;
	/**
		Return the singleton bsh ReflectManager.
		@throws Unavailable
	*/
	public static ReflectManager getReflectManager() 
	{
		if ( rfm == null ) 
		{
			Class clas;
			try {
				clas = BshClassManager.plainClassForName(
					""bsh.reflect.ReflectManagerImpl"" );
				rfm = (ReflectManager)clas.newInstance();
			} catch ( Exception e ) {
				throw new Unavailable(""Reflect Manager unavailable: ""+e);
			}
		}
		return rfm;
	}
	/**
		Reflect Manager Set Accessible.
		Convenience method to invoke the reflect manager.
		@throws Unavailable
	*/
	public static boolean RMSetAccessible( Object obj ) 
		throws Unavailable
	{
		return getReflectManager().setAccessible( obj );
	}
	/**
		Set a java.lang.reflect Field, Method, Constructor, or Array of
		accessible objects to accessible mode.
		@return true if the object was accessible or false if it was not.
	*/
	public abstract boolean setAccessible( Object o );
}
"
bsh.ReturnControl,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/**
	Represents a Return, Break, or Continue statement
*/
class ReturnControl implements ParserConstants {
	public int kind;
	public Object value;
	public ReturnControl( int kind, Object value ) {
		this.kind = kind;
		this.value = value;
	}
}
"
bsh.SimpleNode,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
/*
	Note: great care (and lots of typing) were taken to insure that the
	namespace and interpreter references are passed on the stack and not 
	(as they were erroneously before) installed in instance variables...
	Each of these node objects must be re-entrable to allow for recursive 
	situations.
	The only data which should really be stored in instance vars here should 
	be parse tree data... features of the node which should never change (e.g.
	the number of arguments, etc.)
	Exceptions would be public fields of simple classes that just publish
	data produced by the last eval()... data that is used immediately. We'll
	try to remember to mark these as transient to highlight them.
*/
class SimpleNode implements Node {
	protected Node parent;
	protected Node[] children;
	protected int id;
	Token firstToken, lastToken;
	/** the source of the text from which this was parsed */
	String sourceFile;
	public SimpleNode(int i) {
		id = i;
	}
	public void jjtOpen() { }
	public void jjtClose() { }
	public void jjtSetParent(Node n) { parent = n; }
	public Node jjtGetParent() { return parent; }
	//public SimpleNode getParent() { return (SimpleNode)parent; }
	public void jjtAddChild(Node n, int i)
	{
		if (children == null)
			children = new Node[i + 1];
		else
			if (i >= children.length)
			{
				Node c[] = new Node[i + 1];
				System.arraycopy(children, 0, c, 0, children.length);
				children = c;
			}
		children[i] = n;
	}
	public Node jjtGetChild(int i) { 
		return children[i]; 
	}
	public SimpleNode getChild( int i ) {
		return (SimpleNode)jjtGetChild(i);
	}
	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}
	/*
		You can override these two methods in subclasses of SimpleNode to
		customize the way the node appears when the tree is dumped.  If
		your output uses more than one line you should override
		toString(String), otherwise overriding toString() is probably all
		you need to do.
	*/
	public String toString() { return ParserTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) { return prefix + toString(); }
	/*
		Override this method if you want to customize how the node dumps
		out its children.
	*/
	public void dump(String prefix)
	{
		System.out.println(toString(prefix));
		if(children != null)
		{
			for(int i = 0; i < children.length; ++i)
			{
				SimpleNode n = (SimpleNode)children[i];
				if (n != null)
				{
					n.dump(prefix + "" "");
				}
			}
		}
	}
	//  ---- BeanShell specific stuff hereafter ----  //
	/**
		Detach this node from its parent.
		This is primarily useful in node serialization.
		(see BSHMethodDeclaration)
	*/
	public void prune() {
		jjtSetParent( null );
	}
	/**
		Some nodes require only a namespace for evaluation.
	*/
	public Object eval( NameSpace namespace ) 
		throws EvalError
	{
		throw new EvalError(
			""Unimplemented or inappropriate for "" + getClass().getName());
	}
	/**
		This is the general signature for evaluation of a node.
	*/
	public Object eval( CallStack callstack, Interpreter interpreter ) 
		throws EvalError
	{
		/*
			Try to call the simpler signature
			I don't ilke this, but it's the price we pay for being able to
			eval() any simplenode and still limit the signature on those
			that only need namespace.
		*/
		return eval( callstack.top() );
	}
	/**
		Set the name of the source file (or more generally source) of
		the text from which this node was parsed.
	*/
	public void setSourceFile( String sourceFile ) {
		this.sourceFile = sourceFile;
	}
	/**
		Get the name of the source file (or more generally source) of
		the text from which this node was parsed.
		This will recursively search up the chain of parent nodes until
		a source is found or return a string indicating that the source
		is unknown.
	*/
	public String getSourceFile() {
		if ( sourceFile == null )
			if ( parent != null )
				return ((SimpleNode)parent).getSourceFile();
			else
				return ""<unknown file>"";
		else
			return sourceFile;
	}
	/**
		Get the line number of the starting token
	*/
	public int getLineNumber() {
		return firstToken.beginLine;
	}
	/**
		Get the text of the tokens comprising this node.
	*/
	public String getText() 
	{
		StringBuffer text = new StringBuffer();
		Token t = firstToken;
		while ( t!=null ) {
			text.append(t.image);
			if ( !t.image.equals(""."") )
				text.append("" "");
			if ( t==lastToken ||
				t.image.equals(""{"") || t.image.equals("";"") )
				break;
			t=t.next;
		}
		return text.toString();
	}
}
"
bsh.StringUtil,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.util.*;
public class StringUtil {
	public static String [] split( String s, String delim) {
		Vector v = new Vector();
		StringTokenizer st = new StringTokenizer(s, delim);
		while ( st.hasMoreTokens() )
			v.addElement( st.nextToken() );
		String [] sa = new String [ v.size() ];
		v.copyInto( sa );
		return sa;
	}
	public static String [] bubbleSort( String [] in ) {
		Vector v = new Vector();
		for(int i=0; i<in.length; i++)
			v.addElement(in[i]);
		int n = v.size();
		boolean swap = true;
		while ( swap ) {
			swap = false;
			for(int i=0; i<(n-1); i++)
				if ( ((String)v.elementAt(i)).compareTo(
						((String)v.elementAt(i+1)) ) > 0 ) {
					String tmp = (String)v.elementAt(i+1);
					v.removeElementAt( i+1 );
					v.insertElementAt( tmp, i );
					swap = true;
				}
		}
		String [] out = new String [ n ];
		v.copyInto(out);
		return out;
	}
	public static String maxCommonPrefix( String one, String two ) {
		int i=0;
		while( one.regionMatches( 0, two, 0, i ) )
			i++;
		return one.substring(0, i-1);
	}
	// Clean this up later...
    public static String methodString(String name, Class[] types)
    {
        StringBuffer sb = new StringBuffer(name + ""("");
        if(types.length > 0)
			sb.append("" "");
        for(int i=0; i<(types.length - 1); i++)
        {
            Class c = types[i];
            sb.append(((c == null) ? ""null"" : c.getName()) + "", "");
        }
        if(types.length > 0)
        {
            Class c = types[types.length - 1];
            sb.append(((c == null) ? ""null"" : c.getName()));
			sb.append("" "");
        }
        sb.append("")"");
        return sb.toString();
    }
	/**
		Split a filename into dirName, baseName
		@return String [] { dirName, baseName }
    public String [] splitFileName( String fileName ) 
	{ 
		String dirName, baseName;
		int i = fileName.lastIndexOf( File.separator );
		if ( i != -1 ) {
			dirName = fileName.substring(0, i);
			baseName = fileName.substring(i+1);
		} else
			baseName = fileName;
		return new String[] { dirName, baseName };
	}
	*/
}
"
bsh.TargetError,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.InvocationTargetException;
/**
	TargetError is an EvalError that wraps an exception thrown by the script	
	(or by code called from the script).  TargetErrors indicate exceptions 
	which can be caught within the script itself, whereas a general EvalError 
	indicates that the script cannot be evaluated further for some reason.
	If the exception is caught within the script it is automatically unwrapped,
	so the code looks like normal Java code.  If the TargetError is thrown
	from the eval() or interpreter.eval() method it may be caught and unwrapped
	to determine what exception was thrown.
*/
/*
	Implementation note: 
	Although it is easy to catch exceptions generated by called Java code
	and wrap them (e.g. in the method dispatching code), we must be careful 
	do the same with arbitrary exceptions that we generate in interpreted
	code, e.g. ArithmeticException, ClassCastException.
	Also an important location to look at is BSHMethodInvocation.  There
	we catch eval errors and rethrow them to compound the location information
*/
public class TargetError extends EvalError 
{
	Throwable target;
	public TargetError(String msg, Throwable t, SimpleNode node )
	{
		super(msg, node);
		target = t;
	}
	public TargetError(Throwable t, SimpleNode node )
	{
		this(""TargetError"", t, node);
	}
	/**
		If you're going to use this please catch and re-throw the exception
		in an AST and add the node...
		@see reThrow()
	*/
	public TargetError( String s, Throwable t )
	{
		this(s, t, null);
	}
	public Throwable getTarget()
	{
		// check for easy mistake
		if(target instanceof InvocationTargetException)
			return((InvocationTargetException)target).getTargetException();
		else
			return target;
	}
	public String toString() {
		return super.toString() 
			+ ""\nTarget exception: "" + 
			printTargetError( target );
	}
    public void printStackTrace() { 
		super.printStackTrace();
		System.out.println(""--- Target Stack Trace ---"");
		target.printStackTrace();
	}
	/**
		Re-throw the target error, prefixing msg to the message.
		Unfortunately at the moment java.lang.Exception's message isn't 
		mutable so we just make a new one... could do something about this 
		later.
	*/
	public void reThrow( String msg ) 
		throws TargetError 
	{
		throw new TargetError( msg+"":""+getMessage(),  target, node );
	}
	/**
		Re-throw the target error, prefixing msg and Node to the message.
		msg may be null for no message
	*/
	public void reThrow( String msg, SimpleNode node  ) 
		throws TargetError 
	{
		String m = ( msg == null ) ? """" : (msg + "" : "");
		throw new TargetError( m+getMessage(),  target, node );
	}
	/**
		Re-throw the target error adding the Node 
	*/
	public void reThrow( SimpleNode node  ) 
		throws TargetError 
	{
		reThrow( null, node );
	}
	/**
		Generate a printable string showing the wrapped target exception.
		//If the exception is an InvocationTargetException further unwrap it.
		If the proxy mechanism is available, allow the extended print to
		check for UndeclaredThrowableException and print that embedded error.
	*/
	public String printTargetError( Throwable t ) 
	{
		String s = target.toString();
	/*
		if ( target instanceof InvocationTargetException )
			s +=  ((InvocationTargetException)target).getTargetException();
		else 
	*/
		if ( Capabilities.canGenerateInterfaces() )
			s += ""\n"" + xPrintTargetError( t );
		return s;
	}
	/**
		Extended form of print target error.
		This indirection is used to print UndeclaredThrowableExceptions 
		which are possible when the proxy mechanism is available.
		We are shielded from compile problems by using a bsh script.
		This is acceptable here because we're not in a critical path...
		Otherwise we'd need yet another dynamically loaded module just for this.
	*/
	public String xPrintTargetError( Throwable t ) 
	{
		String getTarget =
			""import java.lang.reflect.UndeclaredThrowableException;""+
			""if ( target instanceof UndeclaredThrowableException )""+
			""	return target.getUndeclaredThrowable().toString();"" +
			""else return \""\"""";
		Interpreter i = new Interpreter();
		try {
			i.set(""target"", t);
			return (String)i.eval( getTarget );
		} catch ( EvalError e ) {
			throw new InterpreterError(""xprintarget: ""+e.toString() );
		}
	}
}
"
bsh.This,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.io.IOException;
/**
	'This' is the type of bsh scripted objects.
	A 'This' object is a bsh scripted object context.  It holds a namespace 
	reference and implements event listeners and various other interfaces.
	This holds a reference to the declaring interpreter for callbacks from
	outside of bsh.
*/
public class This implements java.io.Serializable, Runnable {
	/**
		The namespace that this This reference wraps.
	*/
	NameSpace namespace;
	/**
		This is the interpreter running when the This ref was created.
		It's used as a default interpreter for callback through the This
		where there is no current interpreter instance 
		e.g. interface proxy or event call backs from outside of bsh.
	*/
	transient Interpreter declaringInterpreter;
	/**
		invokeMethod() here is generally used by outside code to callback
		into the bsh interpreter. e.g. when we are acting as an interface
		for a scripted listener, etc.  In this case there is no real call stack
		so we make a default one starting with the special JAVACODE namespace
		and our namespace as the next.
	*/
	transient CallStack callstack;
	/**
		getThis() is a factory for bsh.This type references.  The capabilities
		of "".this"" references in bsh are version dependent up until jdk1.3.
		The version dependence was to support different default interface
		implementations.  i.e. different sets of listener interfaces which
		scripted objects were capable of implementing.  In jdk1.3 the 
		reflection proxy mechanism was introduced which allowed us to 
		implement arbitrary interfaces.  This is fantastic.
		A This object is a thin layer over a namespace, comprising a bsh object
		context.  We create it here only if needed for the namespace.
		Note: this method could be considered slow because of the way it 
		dynamically factories objects.  However I've also done tests where 
		I hard-code the factory to return JThis and see no change in the 
		rough test suite time.  This references are also cached in NameSpace.  
	*/
    static This getThis( 
		NameSpace namespace, Interpreter declaringInterpreter ) 
	{
		try {
			if ( Capabilities.canGenerateInterfaces() )
				return (This)Reflect.constructObject( ""bsh.XThis"",
					new Object [] { namespace, declaringInterpreter } );
			else if ( Capabilities.haveSwing() )
				return (This)Reflect.constructObject( ""bsh.JThis"",
					new Object [] { namespace, declaringInterpreter } );
			else
				return new This( namespace, declaringInterpreter );
		} catch ( Exception e ) {
			throw new InterpreterError(""internal error 1 in This: ""+e);
		} 
    }
	/**
		Get a version of the interface.
		If this type of This implements it directly return this,
		else try complain that we don't have the proxy mechanism.
	*/
	public Object getInterface( Class clas ) 
		throws EvalError
	{
		if ( clas.isInstance( this ) )
			return this;
		else
			throw new EvalError( ""Dynamic proxy mechanism not available. ""
			+ ""Cannot construct interface type: ""+clas );
	}
	/*
		I wish protected access were limited to children and not also 
		package scope... I want this to be a singleton implemented by various
		children.  
	*/
	protected This( NameSpace namespace, Interpreter declaringInterpreter ) { 
		this.namespace = namespace; 
		this.declaringInterpreter = declaringInterpreter;
		initCallStack( namespace );
	}
	public NameSpace getNameSpace() {
		return namespace;
	}
	public String toString() {
		return ""'this' reference to Bsh object: "" + namespace.name;
	}
	public void run() {
		try {
			invokeMethod( ""run"", new Object[0] );
		} catch( EvalError e ) {
			declaringInterpreter.error(
				""Exception in runnable:"" + e );
		}
	}
	/**
		Invoke specified method from outside java code, using the declaring 
		interpreter and current namespace.
		The call stack will appear as if the method is being invoked from
		outside of bsh in native java code.
	*/
	public Object invokeMethod( String name, Object [] args ) 
		throws EvalError
	{
		// null callstack, one will be created for us in namespace.invokMethod
		// null callerInfo is legal
		return invokeMethod( name, args, declaringInterpreter, null, null );
	}
	/**
		Invoke specified method with specified interpreter.
		This is simply a convenience method.
	*/
	public Object invokeMethod( 
		String name, Object [] args, Interpreter interpreter, 
			CallStack callstack, SimpleNode callerInfo  ) 
		throws EvalError
	{
		return namespace.invokeMethod( 
			name, args, interpreter, callstack, callerInfo );
	}
	/**
		Bind a This reference to a parent's namespace with the specified
		declaring interpreter.  Also re-init the callstack.  It's necessary 
		to bind a This reference before it can be used after deserialization.
		<p>
		This is a static utility method because it's used by a bsh command
		bind() and the interpreter doesn't currently allow access to direct 
		methods of This objects (small hack)
	*/
	public static void bind( 
		This ths, NameSpace namespace, Interpreter declaringInterpreter ) 
	{ 
		ths.namespace.setParent( namespace ); 
		ths.declaringInterpreter = declaringInterpreter;
		ths.initCallStack( namespace );
	}
	/**
		For serialization.
	*/
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException {
		// Temporarily prune the namespace.
		NameSpace parent = namespace.getParent();
		// Bind would set the interpreter, but it's possible that the parent
		// is null (it's the root).  So save it...
		//?Interpreter interpreter = declaringInterpreter;
		namespace.prune();
		s.defaultWriteObject();
		// put it back
		namespace.setParent( parent );
		//?declaringInterpreter = interpreter;
		//?initCallStack( namespace );
	}
	private final void initCallStack( NameSpace namespace ) {
		callstack = new CallStack();
		callstack.push( namespace );
	}
}
"
bsh.Token,"/* Generated By:JavaCC: Do not edit this line. Token.java Version 0.7pre3 */
package bsh;
/**
 * Describes the input token stream.
 */
// Note: bsh added serializable
class Token implements java.io.Serializable {
  /**
   * An integer that describes the kind of this token.  This numbering
   * system is determined by JavaCCParser, and a table of these numbers is
   * stored in the file ...Constants.java.
   */
  public int kind;
  /**
   * beginLine and beginColumn describe the position of the first character
   * of this token; endLine and endColumn describe the position of the
   * last character of this token.
   */
  public int beginLine, beginColumn, endLine, endColumn;
  /**
   * The string image of the token.
   */
  public String image;
  /**
   * A reference to the next regular (non-special) token from the input
   * stream.  If this is the last token from the input stream, or if the
   * token manager has not read tokens beyond this one, this field is
   * set to null.  This is true only if this token is also a regular
   * token.  Otherwise, see below for a description of the contents of
   * this field.
   */
  public Token next;
  /**
   * This field is used to access special tokens that occur prior to this
   * token, but after the immediately preceding regular (non-special) token.
   * If there are no such special tokens, this field is set to null.
   * When there are more than one such special token, this field refers
   * to the last of these special tokens, which in turn refers to the next
   * previous special token through its specialToken field, and so on
   * until the first special token (whose specialToken field is null).
   * The next fields of special tokens refer to other special tokens that
   * immediately follow it (without an intervening regular token).  If there
   * is no such token, this field is null.
   */
  public Token specialToken;
  /**
   * Returns the image.
   */
  public final String toString()
  {
     return image;
  }
  /**
   * Returns a new Token object, by default. However, if you want, you
   * can create and return subclass objects based on the value of ofKind.
   * Simply add the cases to the switch for all those special cases.
   * For example, if you have a subclass of Token called IDToken that
   * you want to create if ofKind is ID, simlpy add something like :
   *
   *    case MyParserConstants.ID : return new IDToken();
   *
   * to the following switch statement. Then you can cast matchedToken
   * variable to the appropriate type and use it in your lexical actions.
   */
  public static final Token newToken(int ofKind)
  {
     switch(ofKind)
     {
       default : return new Token();
     }
  }
}
"
bsh.TokenMgrError,"/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 0.7pre2 */
package bsh;
class TokenMgrError extends Error
{
   /*
    * Ordinals for various reasons why an Error of this type can be thrown.
    */
   /**
    * Lexical error occured.
    */
   static final int LEXICAL_ERROR = 0;
   /**
    * An attempt wass made to create a second instance of a static token manager.
    */
   static final int STATIC_LEXER_ERROR = 1;
   /**
    * Tried to change to an invalid lexical state.
    */
   static final int INVALID_LEXICAL_STATE = 2;
   /**
    * Detected (and bailed out of) an infinite loop in the token manager.
    */
   static final int LOOP_DETECTED = 3;
   /**
    * Indicates the reason why the exception is thrown. It will have
    * one of the above 4 values.
    */
   int errorCode;
   /**
    * Replaces unprintable characters by their espaced (or unicode escaped)
    * equivalents in the given string
    */
   protected static final String addEscapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append(""\\b"");
              continue;
           case '\t':
              retval.append(""\\t"");
              continue;
           case '\n':
              retval.append(""\\n"");
              continue;
           case '\f':
              retval.append(""\\f"");
              continue;
           case '\r':
              retval.append(""\\r"");
              continue;
           case '\""':
              retval.append(""\\\"""");
              continue;
           case '\'':
              retval.append(""\\\'"");
              continue;
           case '\\':
              retval.append(""\\\\"");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = ""0000"" + Integer.toString(ch, 16);
                 retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }
   /**
    * Returns a detailed message for the Error when it is thrown by the
    * token manager to indicate a lexical error.
    * Parameters : 
    *    EOFSeen     : indicates if EOF caused the lexicl error
    *    curLexState : lexical state in which this error occured
    *    errorLine   : line number when the error occured
    *    errorColumn : column number when the error occured
    *    errorAfter  : prefix that was seen before this error occured
    *    curchar     : the offending character
    * Note: You can customize the lexical error message by modifying this method.
    */
   private static final String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
      return(""Lexical error at line "" +
           errorLine + "", column "" +
           errorColumn + "".  Encountered: "" +
           (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""") + "" ("" + (int)curChar + ""), "") +
           ""after : \"""" + addEscapes(errorAfter) + ""\"""");
   }
   /**
    * You can also modify the body of this method to customize your error messages.
    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
    * of end-users concern, so you can return something like : 
    *
    *     ""Internal Error : Please file a bug report .... ""
    *
    * from this method for such cases in the release version of your parser.
    */
   public String getMessage() {
      return super.getMessage();
   }
   /*
    * Constructors of various flavors follow.
    */
   public TokenMgrError() {
   }
   public TokenMgrError(String message, int reason) {
      super(message);
      errorCode = reason;
   }
   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
   }
}
"
bsh.XThis,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh;
import java.lang.reflect.*;
import java.lang.reflect.InvocationHandler;
import java.io.*;
/**
	XThis is a dynamically loaded extension which extends This.java and adds 
	support for the generalized interface proxy mechanism introduced in 
	JDK1.3.  XThis allows bsh scripted objects to implement arbitrary 
	interfaces (be arbitrary event listener types).
	Note: This module relies on new features of JDK1.3 and will not compile
	with JDK1.2 or lower.  For those environments simply do not compile this
	class.
	Eventually XThis should become simply This, but for backward compatability
	we will maintain This without requiring support for the proxy mechanism.
	XThis stands for ""eXtended This"" (I had to call it something).
	@see JThis	 See also JThis with explicit JFC support for compatability.
	@see This	
*/
class XThis extends This {
	InvocationHandler invocationHandler = new Handler();
	XThis( NameSpace namespace, Interpreter declaringInterp ) { 
		super( namespace, declaringInterp ); 
	}
	public String toString() {
		return ""'this' reference (XThis) to Bsh object: "" + namespace.name;
	}
	String toStringShowInts( Class [] ints ) {
		StringBuffer sb = new StringBuffer( toString() + ""\nimplements:"" );
		for(int i=0; i<ints.length; i++)
			sb.append( "" ""+ ints[i].getName() + ((ints.length > 1)?"","":"""") );
		return sb.toString();
	}
	/**
		Get dynamic proxy for interface.
	*/
	public Object getInterface( Class clas ) {
		return Proxy.newProxyInstance(
			clas.getClassLoader(), new Class[] { clas }, invocationHandler );
	}
	/**
		Get a proxy interface for the specified XThis reference.
		This is a static utility method because the interpreter doesn't 
		currently allow access to direct methods of This objects.
	public static Object getInterface( XThis ths, Class interf ) { 
		return ths.getInterface( interf ); 
	}
	*/
	/**
		Inner class for the invocation handler seems to shield this unavailable
		interface from JDK1.2 VM...  
		I don't understand this.  JThis works just fine even if those
		classes aren't there (doesn't it?)  This class shouldn't be loaded
		if an XThis isn't instantiated in NameSpace.java, should it?
	*/
	class Handler implements InvocationHandler, java.io.Serializable {
		public Object invoke( Object proxy, Method method, Object[] args ) 
			throws EvalError 
		{
			Class [] sig = Reflect.getTypes( args );
			BshMethod bmethod = 
				namespace.getMethod( method.getName(), sig );
			if ( bmethod != null )
				return Primitive.unwrap( 
					bmethod.invokeDeclaredMethod( 
					args, declaringInterpreter, callstack, null ) );
			// Look for the default handler
			bmethod = namespace.getMethod( ""invoke"", 
				new Class [] { null, null } );
			// Call script ""invoke( String methodName, Object [] args );
			if ( bmethod != null )
				return Primitive.unwrap( 
					bmethod.invokeDeclaredMethod( 
					new Object [] { method.getName(), args }, 
					declaringInterpreter, callstack, null ) );
			/*
				implement the required part of the Object protocol:
					public int hashCode();
					public boolean equals(java.lang.Object);
					public java.lang.String toString();
				if these were not handled by scripted methods we must provide
				a default impl.
			*/
			// a default toString() that shows the interfaces we implement
			if ( method.getName().equals(""toString"" ) )
				return toStringShowInts( proxy.getClass().getInterfaces());
			// a default hashCode()
			if ( method.getName().equals(""hashCode"" ) )
				return new Integer(this.hashCode());
			// a default equals()
			if ( method.getName().equals(""equals"" ) ) {
				Object obj = args[0];
				return new Boolean( proxy == obj );
			}
			throw new EvalError(""Bsh script method: ""+ method.getName()
				+ "" not found in namespace: ""+ namespace.name );
		}
	};
	/**
		For serialization.
		Note: this is copied from superclass... 
		It must be private, but we can probably add an accessor to allow
		us to call the super method explicitly.
		Just testing to see if this is causing a problem.
	*/
    private synchronized void writeObject(ObjectOutputStream s)
        throws IOException {
		// Temporarily prune the namespace.
		NameSpace parent = namespace.getParent();
		// Bind would set the interpreter, but it's possible that the parent
		// is null (it's the root).  So save it...
		Interpreter interpreter = declaringInterpreter;
		namespace.prune();
		s.defaultWriteObject();
		// put it back
		namespace.setParent( parent );
		declaringInterpreter = interpreter;
	}
}
"
bsh.commands.dir,"package bsh.commands;
import java.io.*;
import bsh.*;
import java.util.Date;
import java.util.Vector;
import java.util.GregorianCalendar;
import java.util.Calendar;
/**
	This is an example of a bsh command written in Java for speed.
*/
public class dir 
{
	static final String [] months = { ""Jan"", ""Feb"", ""Mar"", ""Apr"", 
		""May"", ""Jun"", ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec"" };
	public static String usage() {
		return ""usage: dir( String dir )\n       dir()"";
	}
	public static void invoke( Interpreter env, NameSpace namespace ) {
		//String dir = getCWD( namespace );
		String dir = ""."";
		invoke( env, namespace, dir );
	}
	public static void invoke( 
		Interpreter env, NameSpace namespace, String dir ) 
	{
		File file;
		try {
			file =  env.pathToFile( dir );
		} catch (IOException e ) {
			env.println(""error reading path: ""+e);
			return;
		}
		if ( !file.exists() || !file.canRead() ) {
			env.println( ""Can't read "" + file );
			return;
		}
		if ( !file.isDirectory() )  {
			env.println(""'""+dir+""' is not a directory"");
		}
		String [] files = file.list();
		files = bubbleSort(files);
		for( int i=0; i< files.length; i++ ) {
			File f = new File( dir + File.separator + files[i] );
			StringBuffer sb = new StringBuffer();
			sb.append( f.canRead() ? ""r"": ""-"" );
			sb.append( f.canWrite() ? ""w"": ""-"" );
			sb.append( ""_"" );
			sb.append( "" "");
			Date d = new Date(f.lastModified());
			GregorianCalendar c = new GregorianCalendar();
			c.setTime(d);
			int day	= c.get(Calendar.DAY_OF_MONTH);
			sb.append( months[ c.get(Calendar.MONTH) ] + "" "" + day );
			if ( day < 10 ) 
				sb.append("" "");
			sb.append("" "");
			// hack to get fixed length 'length' field
			int fieldlen = 8;
			StringBuffer len = new StringBuffer();
			for(int j=0; j<fieldlen; j++)
				len.append("" "");
			len.insert(0, f.length());
			len.setLength(fieldlen);
			// hack to move the spaces to the front
			int si = len.toString().indexOf("" "");
			if ( si != -1 ) {
				String pad = len.toString().substring(si);
				len.setLength(si);
				len.insert(0, pad);
			}
			sb.append( len );
			sb.append( "" "" + f.getName() );
			if ( f.isDirectory() ) 
				sb.append(""/"");
			env.println( sb.toString() );
		}
	}
	public static String [] bubbleSort( String [] in ) {
		Vector v = new Vector();
		for(int i=0; i<in.length; i++)
			v.addElement(in[i]);
		int n = v.size();
		boolean swap = true;
		while ( swap ) {
			swap = false;
			for(int i=0; i<(n-1); i++)
				if ( ((String)v.elementAt(i)).compareTo(
						((String)v.elementAt(i+1)) ) > 0 ) {
					String tmp = (String)v.elementAt(i+1);
					v.removeElementAt( i+1 );
					v.insertElementAt( tmp, i );
					swap = true;
				}
		}
		String [] out = new String [ n ];
		v.copyInto(out);
		return out;
	}
}
"
bsh.reflect.ReflectManagerImpl,"/*****************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the ""License""); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    * 
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the ""LGPL""), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/
package bsh.reflect;
import bsh.ReflectManager;
import java.lang.reflect.AccessibleObject;
/**
	This is the implementation of:
	ReflectManager - a dynamically loaded extension that supports extended
	reflection features supported by JDK1.2 and greater.
	In particular it currently supports accessible method and field access 
	supported by JDK1.2 and greater.
*/
public class ReflectManagerImpl extends ReflectManager
{
	/**
		Set a java.lang.reflect Field, Method, Constructor, or Array of
		accessible objects to accessible mode.
		If the object is not an AccessibleObject then do nothing.
		@return true if the object was accessible or false if it was not.
	*/
// Arrays incomplete... need to use the array setter
	public boolean setAccessible( Object obj ) 
	{
		if ( obj instanceof AccessibleObject ) {
			((AccessibleObject)obj).setAccessible(true);
			return true;
		} else
			return false;
	}
}
"
com.microstar.xml.HandlerBase,"// HandlerBase.java: Simple base class for AElfred processors.
// NO WARRANTY! See README, and copyright below.
// $Id: HandlerBase.java,v 1.1.1.1 2000/01/15 23:54:04 mdillon Exp $
package com.microstar.xml;
import com.microstar.xml.XmlHandler;
import com.microstar.xml.XmlException;
import java.io.Reader;
/**
  * Convenience base class for AElfred handlers.
  * <p>This base class implements the XmlHandler interface with
  * (mostly empty) default handlers.  You are not required to use this,
  * but if you need to handle only a few events, you might find
  * it convenient to extend this class rather than implementing
  * the entire interface.  This example overrides only the
  * <code>charData</code> method, using the defaults for the others:
  * <pre>
  * import com.microstar.xml.HandlerBase;
  *
  * public class MyHandler extends HandlerBase {
  *   public void charData (char ch[], int start, int length)
  *   {
  *     System.out.println(""Data: "" + new String (ch, start, length));
  *   }
  * }
  * </pre>
  * <p>This class is optional, but if you use it, you must also
  * include the <code>XmlException</code> class.
  * <p>Do not extend this if you are using SAX; extend
  * <code>org.xml.sax.HandlerBase</code> instead.
  * @author Copyright (c) 1998 by Microstar Software Ltd.
  * @author written by David Megginson &lt;dmeggins@microstar.com&gt;
  * @version 1.1
  * @see XmlHandler
  * @see XmlException
  * @see org.xml.sax.HandlerBase
  */
public class HandlerBase implements XmlHandler {
  /**
    * Handle the start of the document.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#startDocument
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void startDocument () 
    throws java.lang.Exception
  {
  }
  /**
    * Handle the end of the document.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#endDocument
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void endDocument ()
    throws java.lang.Exception
  {
  }
  /**
    * Resolve an external entity.
    * <p>The default implementation simply returns the supplied
    * system identifier.
    * @see com.microstar.xml.XmlHandler#resolveEntity
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public Object resolveEntity (String publicId, String systemId) 
    throws java.lang.Exception
  {
    return null;
  }
  /**
    * Handle the start of an external entity.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#startExternalEntity
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void startExternalEntity (String systemId)
    throws java.lang.Exception
  {
  }
  /**
    * Handle the end of an external entity.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#endExternalEntity
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void endExternalEntity (String systemId)
    throws java.lang.Exception
  {
  }
  /**
    * Handle a document type declaration.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#doctypeDecl
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void doctypeDecl (String name, String publicId, String systemId)
    throws java.lang.Exception
  {
  }
  /**
    * Handle an attribute assignment.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#attribute
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void attribute (String aname, String value, boolean isSpecified)
    throws java.lang.Exception
  {
  }
  /**
    * Handle the start of an element.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#startElement
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void startElement (String elname)
    throws java.lang.Exception
  {
  }
  /**
    * Handle the end of an element.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#endElement
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void endElement (String elname)
    throws java.lang.Exception
  {
  }
  /**
    * Handle character data.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#charData
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void charData (char ch[], int start, int length)
    throws java.lang.Exception
  {
  }
  /**
    * Handle ignorable whitespace.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#ignorableWhitespace
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void ignorableWhitespace (char ch[], int start, int length)
    throws java.lang.Exception
  {
  }
  /**
    * Handle a processing instruction.
    * <p>The default implementation does nothing.
    * @see com.microstar.xml.XmlHandler#processingInstruction
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void processingInstruction (String target, String data)
    throws java.lang.Exception
  {
  }
  /**
    * Throw an exception for a fatal error.
    * <p>The default implementation throws <code>XmlException</code>.
    * @see com.microstar.xml.XmlHandler#error
    * @exception com.microstar.xml.XmlException A specific parsing error.
    * @exception java.lang.Exception Derived methods may throw exceptions.
    */
  public void error (String message, String systemId, int line, int column)
    throws XmlException, java.lang.Exception
  {
    throw new XmlException(message, systemId, line, column);
  }
}
"
com.microstar.xml.XmlException,"// XmlException.java: Simple base class for AElfred processors.
// NO WARRANTY! See README, and copyright below.
// $Id: XmlException.java,v 1.1.1.1 2000/01/15 23:54:05 mdillon Exp $
package com.microstar.xml;
/**
  * Convenience exception class for reporting XML parsing errors.
  * <p>This is an exception class that you can use to encapsulate all
  * of the information from &AElig;lfred's <code>error</code> callback.
  * This is not necessary for routine use of &AElig;lfred, but it
  * is used by the optional <code>HandlerBase</code> class.
  * <p>Note that the core &AElig;lfred classes do <em>not</em>
  * use this exception.
  * @author Copyright (c) 1998 by Microstar Software Ltd.
  * @author written by David Megginson &lt;dmeggins@microstar.com&gt;
  * @version 1.1
  * @see XmlHandler#error
  * @see HandlerBase
  */
public class XmlException extends Exception
{
  private String message;
  private String systemId;
  private int line;
  private int column;
  /**
    * Construct a new XML parsing exception.
    * @param message The error message from the parser.
    * @param systemId The URI of the entity containing the error.
    * @param line The line number where the error appeared.
    * @param column The column number where the error appeared.
    */
  public XmlException (String message, String systemId, int line, int column)
  {
    this.message = message;
    this.systemId = systemId;
    this.line = line;
    this.column = column;
  }
  /**
    * Get the error message from the parser.
    * @return A string describing the error.
    */
  public String getMessage ()
  {
    return message;
  }
  /**
    * Get the URI of the entity containing the error.
    * @return The URI as a string.
    */
  public String getSystemId ()
  {
    return systemId;
  }
  /**
    * Get the line number containing the error.
    * @return The line number as an integer.
    */
  public int getLine ()
  {
    return line;
  }
  /**
    * Get the column number containing the error.
    * @return The column number as an integer.
    */
  public int getColumn ()
  {
    return column;
  }
}
"
com.microstar.xml.XmlHandler,"// XmlHandler.java: the callback interface.
// NO WARRANTY! See README, and copyright below.
// $Id: XmlHandler.java,v 1.1.1.1 2000/01/15 23:54:05 mdillon Exp $
package com.microstar.xml;
/**
  * XML Processing Interface.
  * <p>Whenever you parse an XML document, you must provide an object
  * from a class that implements this interface to receive the parsing 
  * events.
  * <p>If you do not want to implement this entire interface, you
  * can extend the <code>HandlerBase</code> convenience class and
  * then implement only what you need.
  * <p>If you are using SAX, you should implement the SAX handler
  * interfaces rather than this one.
  * @author Copyright (c) 1997, 1998 by Microstar Software Ltd.
  * @author written by David Megginson &lt;dmeggins@microstar.com&gt;
  * @version 1.1
  * @see XmlParser
  * @see HandlerBase
  * @see org.xml.sax.EntityHandler
  * @see org.xml.sax.DocumentHandler
  * @see org.xml.sax.ErrorHandler
  */
public interface XmlHandler {
  /**
    * Start the document.
    * <p>&AElig;lfred will call this method just before it
    * attempts to read the first entity (the root of the document).
    * It is guaranteed that this will be the first method called.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #endDocument
    */
  public void startDocument ()
    throws java.lang.Exception;
  /**
    * End the document.
    * <p>&AElig;lfred will call this method once, when it has
    * finished parsing the XML document.
    * It is guaranteed that this will be the last method called.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #startDocument
    */
  public void endDocument ()
    throws java.lang.Exception;
  /**
    * Resolve an External Entity.
    * <p>Give the handler a chance to redirect external entities
    * to different URIs.  &AElig;lfred will call this method for the
    * top-level document entity, for external text (XML) entities, 
    * and the external DTD subset (if any).
    * @param publicId The public identifier, or null if none was supplied.
    * @param systemId The system identifier.
    * @return The replacement system identifier, or null to use
    *         the default.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #startExternalEntity
    * @see #endExternalEntity
    */
  public Object resolveEntity (String publicId, String systemId)
    throws java.lang.Exception;
  /**
    * Begin an external entity.
    * <p>&AElig;lfred will call this method at the beginning of
    * each external entity, including the top-level document entity
    * and the external DTD subset (if any).
    * <p>If necessary, you can use this method to track the location
    * of the current entity so that you can resolve relative URIs
    * correctly.
    * @param systemId The URI of the external entity that is starting.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #endExternalEntity
    * @see #resolveEntity
    */
  public void startExternalEntity (String systemId)
    throws java.lang.Exception;
  /**
    * End an external entity.
    * <p>&AElig;lfred will call this method at the end of
    * each external entity, including the top-level document entity
    * and the external DTD subset.
    * <p>If necessary, you can use this method to track the location
    * of the current entity so that you can resolve relative URIs
    * correctly.
    * @param systemId The URI of the external entity that is ending.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #startExternalEntity
    * @see #resolveEntity
    */
  public void endExternalEntity (String systemId)
    throws java.lang.Exception;
  /**
    * Document type declaration.
    * <p>&AElig;lfred will call this method when or if it encounters
    * the document type (DOCTYPE) declaration.
    * <p>Please note that the public and system identifiers will
    * not always be a reliable indication of the DTD in use.
    * @param name The document type name.
    * @param publicId The public identifier, or null if unspecified.
    * @param systemId The system identifier, or null if unspecified.
    * @exception java.lang.Exception The handler may throw any exception.
    */
  public void doctypeDecl (String name, String publicId, String systemId)
    throws java.lang.Exception;
  /**
    * Attribute.
    * <p>&AElig;lfred will call this method once for each attribute 
    * (specified or defaulted) before reporting a startElement event.
    * It is up to your handler to collect the attributes, if
    * necessary.
    * <p>You may use XmlParser.getAttributeType() to find the attribute's
    * declared type.
    * @param name The name of the attribute.
    * @param type The type of the attribute (see below).
    * @param value The value of the attribute, or null if the attribute
    *        is <code>#IMPLIED</code>.
    * @param isSpecified True if the value was specified, false if it
    *       was defaulted from the DTD.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #startElement
    * @see XmlParser#declaredAttributes
    * @see XmlParser#getAttributeType
    * @see XmlParser#getAttributeDefaultValue
    */
  public void attribute (String aname, String value, boolean isSpecified)
    throws java.lang.Exception;
  /**
    * Start an element.
    * <p>&AElig;lfred will call this method at the beginning of each
    * element.  By the time this is called, all of the attributes
    * for the element will already have been reported using the
    * <code>attribute</code> method.
    * @param elname The element type name.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #attribute
    * @see #endElement
    * @see XmlParser#declaredElements
    * @see XmlParser#getElementContentType
    */
  public void startElement (String elname)
    throws java.lang.Exception;
  /**
    * End an element.
    * <p>&AElig;lfred will call this method at the end of each element
    * (including EMPTY elements).
    * @param elname The element type name.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see #startElement
    * @see XmlParser#declaredElements
    * @see XmlParser#getElementContentType
    */
  public void endElement (String elname)
    throws java.lang.Exception;
  /**
    * Character data.
    * <p>&AElig;lfred will call this method once for each chunk of
    * character data found in the contents of elements.  Note that
    * the parser may break up a long sequence of characters into
    * smaller chunks and call this method once for each chunk.
    * <p>Do <em>not</em> attempt to read more than <var>length</var>
    * characters from the array, or to read before the 
    * <var>start</var> position.
    * @param ch The character data.
    * @param start The starting position in the array.
    * @param length The number of characters available.
    * @exception java.lang.Exception The handler may throw any exception.
    */
  public void charData (char ch[], int start, int length)
    throws java.lang.Exception;
  /**
    * Ignorable whitespace.
    * <p>&AElig;lfred will call this method once for each sequence
    * of ignorable whitespace in element content (never in mixed content).
    * <p>For details, see section 2.10 of the XML 1.0 recommendation.
    * <p>Do <em>not</em> attempt to read more than <var>length</var>
    * characters from the array or to read before the <var>start</var>
    * position.
    * @param ch The literal whitespace characters.
    * @param start The starting position in the array.
    * @param length The number of whitespace characters available.
    * @exception java.lang.Exception The handler may throw any exception.
    */
  public void ignorableWhitespace (char ch[], int start, int length)
    throws java.lang.Exception;
  /**
    * Processing instruction.
    * <p>&AElig;lfred will call this method once for each
    * processing instruction.  Note that processing instructions may
    * appear outside of the top-level element.  The
    * @param target The target (the name at the start of the PI).
    * @param data The data, if any (the rest of the PI).
    * @exception java.lang.Exception The handler may throw any exception.
    */
  public void processingInstruction (String target, String data)
    throws java.lang.Exception;
  /**
    * Fatal XML parsing error.
    * <p>&AElig;lfred will call this method whenever it encounters
    * a serious error.  The parser will attempt to continue past this 
    * point so that you can find more possible error points, but if
    * this method is called you should assume that the document is
    * corrupt and you should not try to use its contents.
    * <p>Note that you can use the <code>XmlException</code> class
    * to encapsulate all of the information provided, though the
    * use of the class is not mandatory.
    * @param message The error message.
    * @param systemId The system identifier of the entity that 
    *        contains the error.
    * @param line The approximate line number of the error.
    * @param column The approximate column number of the error.
    * @exception java.lang.Exception The handler may throw any exception.
    * @see XmlException
    */
  public void error (String message, String systemId, int line, int column)
    throws java.lang.Exception;
}
"
com.microstar.xml.XmlParser,"// XmlParser.java: the main parser class.
// NO WARRANTY! See README, and copyright below.
// $Id: XmlParser.java,v 1.1.1.1 2000/01/15 23:54:13 mdillon Exp $
package com.microstar.xml;
import java.io.BufferedInputStream;
import java.io.EOFException;
import java.io.InputStream;
import java.io.Reader;
import java.net.URL;
import java.net.URLConnection;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Stack;
/**
  * Parse XML documents and return parse events through call-backs.
  * <p>You need to define a class implementing the <code>XmlHandler</code>
  * interface: an object belonging to this class will receive the
  * callbacks for the events.  (As an alternative to implementing
  * the full XmlHandler interface, you can simply extend the 
  * <code>HandlerBase</code> convenience class.)
  * <p>Usage (assuming that <code>MyHandler</code> is your implementation
  * of the <code>XmlHandler</code> interface):
  * <pre>
  * XmlHandler handler = new MyHandler();
  * XmlParser parser = new XmlParser();
  * parser.setHandler(handler);
  * try {
  *   parser.parse(""http://www.host.com/doc.xml"", null);
  * } catch (Exception e) {
  *   [do something interesting]
  * }
  * </pre>
  * <p>Alternatively, you can use the standard SAX interfaces
  * with the <code>SAXDriver</code> class as your entry point.
  * @author Copyright (c) 1997, 1998 by Microstar Software Ltd.
  * @author Written by David Megginson &lt;dmeggins@microstar.com&gt;
  * @version 1.1
  * @see XmlHandler
  * @see HandlerBase
  * @see SAXDriver
  */
public class XmlParser {
  //
  // Use special cheats that speed up the code (currently about 50%),
  // but may cause problems with future maintenance and add to the
  // class file size (about 500 bytes).
  //
  private final static boolean USE_CHEATS = true;
  //////////////////////////////////////////////////////////////////////
  // Constructors.
  ////////////////////////////////////////////////////////////////////////
  /**
    * Construct a new parser with no associated handler.
    * @see #setHandler
    * @see #parse
    */
  public XmlParser ()
  {
  }
  /**
    * Set the handler that will receive parsing events.
    * @param handler The handler to receive callback events.
    * @see #parse
    * @see XmlHandler
    */
  public void setHandler (XmlHandler handler)
  {
    this.handler = handler;
  }
  /**
    * Parse an XML document from a URI.
    * <p>You may parse a document more than once, but only one thread
    * may call this method for an object at one time.
    * @param systemId The URI of the document.
    * @param publicId The public identifier of the document, or null.
    * @param encoding The suggested encoding, or null if unknown.
    * @exception java.lang.Exception Any exception thrown by your
    *            own handlers, or any derivation of java.io.IOException
    *            thrown by the parser itself.
    */
  public void parse (String systemId, String publicId, String encoding)
    throws java.lang.Exception
  {
    doParse(systemId, publicId, null, null, encoding);
  }
  /**
    * Parse an XML document from a byte stream.
    * <p>The URI that you supply will become the base URI for
    * resolving relative links, but &AElig;lfred will actually read
    * the document from the supplied input stream.
    * <p>You may parse a document more than once, but only one thread
    * may call this method for an object at one time.
    * @param systemId The base URI of the document, or null if not
    *                 known.
    * @param publicId The public identifier of the document, or null
    *                 if not known.
    * @param stream A byte input stream.
    * @param encoding The suggested encoding, or null if unknown.
    * @exception java.lang.Exception Any exception thrown by your
    *            own handlers, or any derivation of java.io.IOException
    *            thrown by the parser itself.
    */
  public void parse (String systemId, String publicId,
		     InputStream stream, String encoding)
    throws java.lang.Exception
  {
    doParse(systemId, publicId, null, stream, encoding);
  }
  /**
    * Parse an XML document from a character stream.
    * <p>The URI that you supply will become the base URI for
    * resolving relative links, but &AElig;lfred will actually read
    * the document from the supplied input stream.
    * <p>You may parse a document more than once, but only one thread
    * may call this method for an object at one time.
    * @param systemId The base URI of the document, or null if not
    *                 known.
    * @param publicId The public identifier of the document, or null
    *                 if not known.
    * @param reader A character stream.
    * @exception java.lang.Exception Any exception thrown by your
    *            own handlers, or any derivation of java.io.IOException
    *            thrown by the parser itself.
    */
  public void parse (String systemId, String publicId, Reader reader)
    throws java.lang.Exception
  {
    doParse(systemId, publicId, reader, null, null);
  }
  private synchronized void doParse (String systemId, String publicId,
				     Reader reader, InputStream stream,
				     String encoding)
    throws java.lang.Exception
  {
    basePublicId = publicId;
    baseURI = systemId;
    baseReader = reader;
    baseInputStream = stream;
    initializeVariables();
				// Set the default entities here.
    setInternalEntity(intern(""amp""), ""&#38;"");
    setInternalEntity(intern(""lt""), ""&#60;"");
    setInternalEntity(intern(""gt""), ""&#62;"");
    setInternalEntity(intern(""apos""), ""&#39;"");
    setInternalEntity(intern(""quot""), ""&#34;"");
    if (handler != null) {
      handler.startDocument();
    }
    pushURL(""[document]"", basePublicId, baseURI, baseReader, baseInputStream,
	    encoding);
    parseDocument();
    if (handler != null) {
      handler.endDocument();
    }
    cleanupVariables();
  }
  ////////////////////////////////////////////////////////////////////////
  // Constants.
  ////////////////////////////////////////////////////////////////////////
  //
  // Constants for element content type.
  //
  /**
    * Constant: an element has not been declared.
    * @see #getElementContentType
    */
  public final static int CONTENT_UNDECLARED = 0;
  /**
    * Constant: the element has a content model of ANY.
    * @see #getElementContentType
    */
  public final static int CONTENT_ANY = 1;
  /**
    * Constant: the element has declared content of EMPTY.
    * @see #getElementContentType
    */
  public final static int CONTENT_EMPTY = 2;
  /**
    * Constant: the element has mixed content.
    * @see #getElementContentType
    */
  public final static int CONTENT_MIXED = 3;
  /**
    * Constant: the element has element content.
    * @see #getElementContentType
    */
  public final static int CONTENT_ELEMENTS = 4;
  //
  // Constants for the entity type.
  //
  /**
    * Constant: the entity has not been declared.
    * @see #getEntityType
    */
  public final static int ENTITY_UNDECLARED = 0;
  /**
    * Constant: the entity is internal.
    * @see #getEntityType
    */
  public final static int ENTITY_INTERNAL = 1;
  /**
    * Constant: the entity is external, non-XML data.
    * @see #getEntityType
    */
  public final static int ENTITY_NDATA = 2;
  /**
    * Constant: the entity is external XML data.
    * @see #getEntityType
    */
  public final static int ENTITY_TEXT = 3;
  //
  // Constants for attribute type.
  //
  /**
    * Constant: the attribute has not been declared for this element type.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_UNDECLARED = 0;
  /**
    * Constant: the attribute value is a string value.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_CDATA = 1;
  /**
    * Constant: the attribute value is a unique identifier.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_ID = 2;
  /**
    * Constant: the attribute value is a reference to a unique identifier.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_IDREF = 3;
  /**
    * Constant: the attribute value is a list of ID references.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_IDREFS = 4;
  /**
    * Constant: the attribute value is the name of an entity.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_ENTITY = 5;
  /**
    * Constant: the attribute value is a list of entity names.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_ENTITIES = 6;
  /**
    * Constant: the attribute value is a name token.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_NMTOKEN = 7;
  /**
    * Constant: the attribute value is a list of name tokens.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_NMTOKENS = 8;
  /**
    * Constant: the attribute value is a token from an enumeration.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_ENUMERATED = 9;
  /**
    * Constant: the attribute is the name of a notation.
    * @see #getAttributeType
    */
  public final static int ATTRIBUTE_NOTATION = 10;
  //
  // When the class is loaded, populate the hash table of
  // attribute types.
  //
  /**
    * Hash table of attribute types.
    */
  private static Hashtable attributeTypeHash;
  static {
    attributeTypeHash = new Hashtable();
    attributeTypeHash.put(""CDATA"", new Integer(ATTRIBUTE_CDATA));
    attributeTypeHash.put(""ID"", new Integer(ATTRIBUTE_ID));
    attributeTypeHash.put(""IDREF"", new Integer(ATTRIBUTE_IDREF));
    attributeTypeHash.put(""IDREFS"", new Integer(ATTRIBUTE_IDREFS));
    attributeTypeHash.put(""ENTITY"", new Integer(ATTRIBUTE_ENTITY));
    attributeTypeHash.put(""ENTITIES"", new Integer(ATTRIBUTE_ENTITIES));
    attributeTypeHash.put(""NMTOKEN"", new Integer(ATTRIBUTE_NMTOKEN));
    attributeTypeHash.put(""NMTOKENS"", new Integer(ATTRIBUTE_NMTOKENS));
    attributeTypeHash.put(""NOTATION"", new Integer(ATTRIBUTE_NOTATION));
  }
  //
  // Constants for supported encodings.
  //
  private final static int ENCODING_UTF_8 = 1;
  private final static int ENCODING_ISO_8859_1 = 2;
  private final static int ENCODING_UCS_2_12 = 3;
  private final static int ENCODING_UCS_2_21 = 4;
  private final static int ENCODING_UCS_4_1234 = 5;
  private final static int ENCODING_UCS_4_4321 = 6;
  private final static int ENCODING_UCS_4_2143 = 7;
  private final static int ENCODING_UCS_4_3412 = 8;
  //
  // Constants for attribute default value.
  //
  /**
    * Constant: the attribute is not declared.
    * @see #getAttributeDefaultValueType
    */
  public final static int ATTRIBUTE_DEFAULT_UNDECLARED = 0;
  /**
    * Constant: the attribute has a literal default value specified.
    * @see #getAttributeDefaultValueType
    * @see #getAttributeDefaultValue
    */
  public final static int ATTRIBUTE_DEFAULT_SPECIFIED = 1;
  /**
    * Constant: the attribute was declared #IMPLIED.
    * @see #getAttributeDefaultValueType
    */
  public final static int ATTRIBUTE_DEFAULT_IMPLIED = 2;
  /**
    * Constant: the attribute was declared #REQUIRED.
    * @see #getAttributeDefaultValueType
    */
  public final static int ATTRIBUTE_DEFAULT_REQUIRED = 3;
  /**
    * Constant: the attribute was declared #FIXED.
    * @see #getAttributeDefaultValueType
    * @see #getAttributeDefaultValue
    */
  public final static int ATTRIBUTE_DEFAULT_FIXED = 4;
  //
  // Constants for input.
  //
  private final static int INPUT_NONE = 0;
  private final static int INPUT_INTERNAL = 1;
  private final static int INPUT_EXTERNAL = 2;
  private final static int INPUT_STREAM = 3;
  private final static int INPUT_BUFFER = 4;
  private final static int INPUT_READER = 5;
  //
  // Flags for reading literals.
  //
  private final static int LIT_CHAR_REF = 1;
  private final static int LIT_ENTITY_REF = 2;
  private final static int LIT_PE_REF = 4;
  private final static int LIT_NORMALIZE = 8;
  //
  // Flags for parsing context.
  //
  private final static int CONTEXT_NONE = 0;
  private final static int CONTEXT_DTD = 1;
  private final static int CONTEXT_ENTITYVALUE = 2;
  private final static int CONTEXT_ATTRIBUTEVALUE = 3;
  //////////////////////////////////////////////////////////////////////
  // Error reporting.
  //////////////////////////////////////////////////////////////////////
  /**
    * Report an error.
    * @param message The error message.
    * @param textFound The text that caused the error (or null).
    * @see XmlHandler#error
    * @see #line
    */
  void error (String message, String textFound, String textExpected)
    throws java.lang.Exception
  {
    errorCount++;
    if (textFound != null) {
      message = message + "" (found \"""" + textFound + ""\"")"";
    }
    if (textExpected != null) {
      message = message + "" (expected \"""" + textExpected + ""\"")"";
    }
    if (handler != null) {
      String uri = null;
      if (externalEntity != null) {
	uri = externalEntity.getURL().toString();
      }
      handler.error(message, uri, line, column);
    }
  }
  /**
    * Report a serious error.
    * @param message The error message.
    * @param textFound The text that caused the error (or null).
    */
  void error (String message, char textFound, String textExpected)
    throws java.lang.Exception
  {
    error(message, new Character(textFound).toString(), textExpected);
  }
  //////////////////////////////////////////////////////////////////////
  // Major syntactic productions.
  //////////////////////////////////////////////////////////////////////
  /**
    * Parse an XML document.
    * <pre>
    * [1] document ::= prolog element Misc*
    * </pre>
    * <p>This is the top-level parsing function for a single XML
    * document.  As a minimum, a well-formed document must have
    * a document element, and a valid document must have a prolog
    * as well.
    */
  void parseDocument ()
    throws java.lang.Exception
    {
    char c;
    parseProlog();
    require('<');
    parseElement();
    try
      {
      parseMisc();  //skip all white, PIs, and comments
      c=readCh();   //if this doesn't throw an exception...
      error(""unexpected characters after document end"",c,null);
      }
    catch (EOFException e)
      {return;}
    }
  /**
    * Skip a comment.
    * <pre>
    * [18] Comment ::= '&lt;!--' ((Char - '-') | ('-' (Char - '-')))* ""-->""
    * </pre>
    * <p>(The <code>&lt;!--</code> has already been read.)
    */
  void parseComment ()
    throws java.lang.Exception
  {
    skipUntil(""-->"");
  }
  /**
    * Parse a processing instruction and do a call-back.
    * <pre>
    * [19] PI ::= '&lt;?' Name (S (Char* - (Char* '?&gt;' Char*)))? '?&gt;'
    * </pre>
    * <p>(The <code>&lt;?</code> has already been read.)
    * <p>An XML processing instruction <em>must</em> begin with
    * a Name, which is the instruction's target.
    */
  void parsePI ()
    throws java.lang.Exception
  {
    String name;
    name = readNmtoken(true);
    if (!tryRead(""?>"")) {
      requireWhitespace();
      parseUntil(""?>"");
    }
    if (handler != null) {
      handler.processingInstruction(name, dataBufferToString());
    }
  }
  /**
    * Parse a CDATA marked section.
    * <pre>
    * [20] CDSect ::= CDStart CData CDEnd
    * [21] CDStart ::= '&lt;![CDATA['
    * [22] CData ::= (Char* - (Char* ']]&gt;' Char*))
    * [23] CDEnd ::= ']]&gt;'
    * </pre>
    * <p>(The '&lt;![CDATA[' has already been read.)
    * <p>Note that this just appends characters to the dataBuffer,
    * without actually generating an event.
    */
  void parseCDSect ()
    throws java.lang.Exception
  {
    parseUntil(""]]>"");
  }
  /**
    * Parse the prolog of an XML document.
    * <pre>
    * [24] prolog ::= XMLDecl? Misc* (Doctypedecl Misc*)?
    * </pre>
    * <p>There are a couple of tricks here.  First, it is necessary to
    * declare the XML default attributes after the DTD (if present)
    * has been read.  Second, it is not possible to expand general
    * references in attribute value literals until after the entire
    * DTD (if present) has been parsed.
    * <p>We do not look for the XML declaration here, because it is
    * handled by pushURL().
    * @see pushURL
    */
  void parseProlog ()
    throws java.lang.Exception
  {
    parseMisc();
    if (tryRead(""<!DOCTYPE"")) {
      parseDoctypedecl();
      parseMisc();
    }
  }
  /**
    * Parse the XML declaration.
    * <pre>
    * [25] XMLDecl ::= '&lt;?xml' VersionInfo EncodingDecl? SDDecl? S? '?&gt;'
    * [26] VersionInfo ::= S 'version' Eq ('""1.0""' | ""'1.0'"")
    * [33] SDDecl ::= S 'standalone' Eq ""'"" ('yes' | 'no') ""'""
    *               | S 'standalone' Eq '""' (""yes"" | ""no"") '""'
    * [78] EncodingDecl ::= S 'encoding' Eq QEncoding
    * </pre>
    * <p>([80] to [82] are also significant.)
    * <p>(The <code>&lt;?xml</code> and whitespace have already been read.)
    * <p>TODO: validate value of standalone.
    * @see #parseTextDecl
    * @see #checkEncoding
    */
  void parseXMLDecl (boolean ignoreEncoding)
    throws java.lang.Exception
  {
    String version;
    String encodingName = null;
    String standalone = null;
				// Read the version.
    require(""version"");
    parseEq();
    version = readLiteral(0);
    if (!version.equals(""1.0"")) {
      error(""unsupported XML version"", version, ""1.0"");
    }
				// Try reading an encoding declaration.
    skipWhitespace();
    if (tryRead(""encoding"")) {
      parseEq();
      encodingName = readLiteral(0);
      checkEncoding(encodingName, ignoreEncoding);
    }
				// Try reading a standalone declaration
    skipWhitespace();
    if (tryRead(""standalone"")) {
      parseEq();
      standalone = readLiteral(0);
    }
    skipWhitespace();
    require(""?>"");
  }
  /**
    * Parse the Encoding PI.
    * <pre>
    * [78] EncodingDecl ::= S 'encoding' Eq QEncoding
    * [79] EncodingPI ::= '&lt;?xml' S 'encoding' Eq QEncoding S? '?&gt;'
    * [80] QEncoding ::= '""' Encoding '""' | ""'"" Encoding ""'""
    * [81] Encoding ::= LatinName
    * [82] LatinName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
    * </pre>
    * <p>(The <code>&lt;?xml</code>' and whitespace have already been read.)
    * @see #parseXMLDecl
    * @see #checkEncoding
    */
  void parseTextDecl (boolean ignoreEncoding)
    throws java.lang.Exception
  {
    String encodingName = null;
				// Read an optional version.
    if (tryRead(""version"")) {
      String version;
      parseEq();
      version = readLiteral(0);
      if (!version.equals(""1.0"")) {
	error(""unsupported XML version"", version, ""1.0"");
      }
      requireWhitespace();
    }
				// Read the encoding.
    require(""encoding"");
    parseEq();
    encodingName = readLiteral(0);
    checkEncoding(encodingName, ignoreEncoding);
    skipWhitespace();
    require(""?>"");
  }
  /**
    * Check that the encoding specified makes sense.
    * <p>Compare what the author has specified in the XML declaration
    * or encoding PI with what we have detected.
    * <p>This is also important for distinguishing among the various
    * 7- and 8-bit encodings, such as ISO-LATIN-1 (I cannot autodetect
    * those).
    * @param encodingName The name of the encoding specified by the user.
    * @see #parseXMLDecl
    * @see #parseTextDecl
    */
  void checkEncoding (String encodingName, boolean ignoreEncoding)
    throws java.lang.Exception
  {
    encodingName = encodingName.toUpperCase();
    if (ignoreEncoding) {
      return;
    }
    switch (encoding) {
				// 8-bit encodings
    case ENCODING_UTF_8:
      if (encodingName.equals(""ISO-8859-1"")) {
	encoding = ENCODING_ISO_8859_1;
      } else if (!encodingName.equals(""UTF-8"")) {
	error(""unsupported 8-bit encoding"",
	      encodingName,
	      ""UTF-8 or ISO-8859-1"");
      }
      break;
				// 16-bit encodings
    case ENCODING_UCS_2_12:
    case ENCODING_UCS_2_21:
      if (!encodingName.equals(""ISO-10646-UCS-2"") &&
	  !encodingName.equals(""UTF-16"")) {
	error(""unsupported 16-bit encoding"",
	      encodingName,
	      ""ISO-10646-UCS-2"");
      }
      break;
				// 32-bit encodings
    case ENCODING_UCS_4_1234:
    case ENCODING_UCS_4_4321:
    case ENCODING_UCS_4_2143:
    case ENCODING_UCS_4_3412:
      if (!encodingName.equals(""ISO-10646-UCS-4"")) {
	error(""unsupported 32-bit encoding"",
	      encodingName,
	      ""ISO-10646-UCS-4"");
      }
    }
  }
  /**
    * Parse miscellaneous markup outside the document element and DOCTYPE
    * declaration.
    * <pre>
    * [27] Misc ::= Comment | PI | S
    * </pre>
    */
  void parseMisc ()
    throws java.lang.Exception
    {
    while (true)
      {
      skipWhitespace();
      if (tryRead(""<?""))
        {parsePI();}
      else if (tryRead(""<!--""))
        {parseComment();}
      else
        {return;}
      }
    }
  /**
    * Parse a document type declaration.
    * <pre>
    * [28] doctypedecl ::= '&lt;!DOCTYPE' S Name (S ExternalID)? S?
    *                      ('[' %markupdecl* ']' S?)? '&gt;'
    * </pre>
    * <p>(The <code>&lt;!DOCTYPE</code> has already been read.)
    */
  void parseDoctypedecl ()
    throws java.lang.Exception
  {
    char c;
    String doctypeName, ids[];
				// Read the document type name.
    requireWhitespace();
    doctypeName = readNmtoken(true);
				// Read the ExternalIDs.
    skipWhitespace();
    ids = readExternalIds(false);
				// Look for a declaration subset.
    skipWhitespace();
    if (tryRead('[')) {
				// loop until the subset ends
      while (true) {
	context = CONTEXT_DTD;
	skipWhitespace();
	context = CONTEXT_NONE;
	if (tryRead(']')) {
	  break;		// end of subset
	} else {
	  context = CONTEXT_DTD;
	  parseMarkupdecl();
	  context = CONTEXT_NONE;
	}
      }
    }
				// Read the external subset, if any
    if (ids[1] != null) {
      pushURL(""[external subset]"", ids[0], ids[1], null, null, null);
				// Loop until we end up back at '>'
      while (true) {
	context = CONTEXT_DTD;
	skipWhitespace();
	context = CONTEXT_NONE;
	if (tryRead('>')) {
	  break;
	} else {
	  context = CONTEXT_DTD;
	  parseMarkupdecl();
	  context = CONTEXT_NONE;
	}
      }
    } else {
				// No external subset.
      skipWhitespace();
      require('>');
    }
    if (handler != null) {
      handler.doctypeDecl(doctypeName, ids[0], ids[1]);
    }
				// Expand general entities in
				// default values of attributes.
				// (Do this after the doctypeDecl
				// event!).
    // expandAttributeDefaultValues();
  }
  /**
    * Parse a markup declaration in the internal or external DTD subset.
    * <pre>
    * [29] markupdecl ::= ( %elementdecl | %AttlistDecl | %EntityDecl |
    *                       %NotationDecl | %PI | %S | %Comment |
    *                       InternalPERef )
    * [30] InternalPERef ::= PEReference
    * [31] extSubset ::= (%markupdecl | %conditionalSect)*
    * </pre>
    */
  void parseMarkupdecl ()
    throws java.lang.Exception
  {
    if (tryRead(""<!ELEMENT"")) {
      parseElementdecl();
    } else if (tryRead(""<!ATTLIST"")) {
      parseAttlistDecl();
    } else if (tryRead(""<!ENTITY"")) {
      parseEntityDecl();
    } else if (tryRead(""<!NOTATION"")) {
      parseNotationDecl();
    } else if (tryRead(""<?"")) {
      parsePI();
    } else if (tryRead(""<!--"")) {
      parseComment();
    } else if (tryRead(""<!["")) {
      parseConditionalSect();
    } else {
      error(""expected markup declaration"", null, null);
    }
  }
  /**
    * Parse an element, with its tags.
    * <pre>
    * [33] STag ::= '&lt;' Name (S Attribute)* S? '&gt;' [WFC: unique Att spec]
    * [38] element ::= EmptyElement | STag content ETag
    * [39] EmptyElement ::= '&lt;' Name (S Attribute)* S? '/&gt;'
    *                       [WFC: unique Att spec]
    * </pre>
    * <p>(The '&lt;' has already been read.)
    * <p>NOTE: this method actually chains onto parseContent(), if necessary,
    * and parseContent() will take care of calling parseETag().
    */
  void parseElement ()
    throws java.lang.Exception
  {
    String gi;
    char c;
    int oldElementContent = currentElementContent;
    String oldElement = currentElement;
				// This is the (global) counter for the
				// array of specified attributes.
    tagAttributePos = 0;
				// Read the element type name.
    gi = readNmtoken(true);
				// Determine the current content type.
    currentElement = gi;
    currentElementContent = getElementContentType(gi);
    if (currentElementContent == CONTENT_UNDECLARED) {
      currentElementContent = CONTENT_ANY;
    }
				// Read the attributes, if any.
				// After this loop, we should be just
				// in front of the closing delimiter.
    skipWhitespace();
    c = readCh();
    while (c != '/' && c != '>') {
      unread(c);
      parseAttribute(gi);
      skipWhitespace();
      c = readCh();
    }
    unread(c);
				// Supply any defaulted attributes.
    Enumeration atts = declaredAttributes(gi);
    if (atts != null) {
      String aname;
    loop: while (atts.hasMoreElements()) {
      aname = (String)atts.nextElement();
				// See if it was specified.
      for (int i = 0; i < tagAttributePos; i++) {
	if (tagAttributes[i] == aname) {
	  continue loop;
	}
      }
				// I guess not...
      if (handler != null) {
	handler.attribute(aname,
			  getAttributeExpandedValue(gi, aname),
			  false);
      }
    }
    }
				// Figure out if this is a start tag
				// or an empty element, and dispatch an
				// event accordingly.
    c = readCh();
    switch (c) {
    case '>':
      if (handler != null) {
	handler.startElement(gi);
      }
      parseContent();
      break;
    case '/':
      require('>');
      if (handler != null) {
	handler.startElement(gi);
	handler.endElement(gi);
      }
      break;
    }
				// Restore the previous state.
    currentElement = oldElement;
    currentElementContent = oldElementContent;
  }
  /**
    * Parse an attribute assignment.
    * <pre>
    * [34] Attribute ::= Name Eq AttValue
    * </pre>
    * @param name The name of the attribute's element.
    * @see XmlHandler#attribute
    */
  void parseAttribute (String name)
    throws java.lang.Exception
  {
    String aname;
    int type;
    String value;
				// Read the attribute name.
    aname = readNmtoken(true).intern();
    type = getAttributeDefaultValueType(name, aname);
				// Parse '='
    parseEq();
				// Read the value, normalizing whitespace
				// if it is not CDATA.
    if (type == ATTRIBUTE_CDATA || type == ATTRIBUTE_UNDECLARED) {
      value = readLiteral(LIT_CHAR_REF | LIT_ENTITY_REF);
    } else {
      value = readLiteral(LIT_CHAR_REF | LIT_ENTITY_REF | LIT_NORMALIZE);
    }
				// Inform the handler about the
				// attribute.
    if (handler != null) {
      handler.attribute(aname, value, true);
    }
    dataBufferPos = 0;
				// Note that the attribute has been
				// specified.
    if (tagAttributePos == tagAttributes.length) {
      String newAttrib[] = new String[tagAttributes.length * 2];
      System.arraycopy(tagAttributes, 0, newAttrib, 0, tagAttributePos);
      tagAttributes = newAttrib;
    }
    tagAttributes[tagAttributePos++] = aname;
  }
  /**
    * Parse an equals sign surrounded by optional whitespace.
    * [35] Eq ::= S? '=' S?
    */
  void parseEq ()
    throws java.lang.Exception
  {
    skipWhitespace();
    require('=');
    skipWhitespace();
  }
  /**
    * Parse an end tag.
    * [36] ETag ::= '</' Name S? '>'
    * *NOTE: parseContent() chains to here.
    */
  void parseETag ()
    throws java.lang.Exception
  {
    String name;
    name = readNmtoken(true);
    if (name != currentElement) {
      error(""mismatched end tag"", name, currentElement);
    }
    skipWhitespace();
    require('>');
    if (handler != null) {
      handler.endElement(name);
    }
  }
  /**
    * Parse the content of an element.
    * [37] content ::= (element | PCData | Reference | CDSect | PI | Comment)*
    * [68] Reference ::= EntityRef | CharRef
    */
  void parseContent ()
    throws java.lang.Exception
  {
    String data;
    char c;
    while (true) {
      switch (currentElementContent) {
      case CONTENT_ANY:
      case CONTENT_MIXED:
	parsePCData();
	break;
      case CONTENT_ELEMENTS:
	parseWhitespace();
	break;
      }
				// Handle delimiters
      c = readCh();
      switch (c) {
      case '&':			// Found ""&""
	c = readCh();
	if (c == '#') {
	  parseCharRef();
	} else {
	  unread(c);
	  parseEntityRef(true);
	}
	break;
      case '<':			// Found ""<""
	c = readCh();
	switch (c) {
	case '!':		// Found ""<!""
	  c = readCh();
	  switch (c) {
	  case '-':		// Found ""<!-""
	    require('-');
	    parseComment();
	    break;
	  case '[':		// Found ""<![""
	    require(""CDATA["");
	    parseCDSect();
	    break;
	  default:
	    error(""expected comment or CDATA section"", c, null);
	    break;
	  }
	  break;
	case '?':		// Found ""<?""
	  dataBufferFlush();
	  parsePI();
	  break;
	case '/':		// Found ""</""
	  dataBufferFlush();
	  parseETag();
	  return;
	default:		// Found ""<"" followed by something else
	  dataBufferFlush();
	  unread(c);
	  parseElement();
	  break;
	}
      }
    }
  }
  /**
    * Parse an element type declaration.
    * [40] elementdecl ::= '<!ELEMENT' S %Name S (%S S)? %contentspec S? '>'
    *                      [VC: Unique Element Declaration]
    * *NOTE: the '<!ELEMENT' has already been read.
    */
  void parseElementdecl ()
    throws java.lang.Exception
  {
    String name;
    requireWhitespace();
				// Read the element type name.
    name = readNmtoken(true);
    requireWhitespace();
				// Read the content model.
    parseContentspec(name);
    skipWhitespace();
    require('>');
  }
  /**
    * Content specification.
    * [41] contentspec ::= 'EMPTY' | 'ANY' | Mixed | elements
    */
  void parseContentspec (String name)
    throws java.lang.Exception
  {
    if (tryRead(""EMPTY"")) {
      setElement(name, CONTENT_EMPTY, null, null);
      return;
    } else if (tryRead(""ANY"")) {
      setElement(name, CONTENT_ANY, null, null);
      return;
    } else {
      require('(');
      dataBufferAppend('(');
      skipWhitespace();
      if (tryRead(""#PCDATA"")) {
	dataBufferAppend(""#PCDATA"");
	parseMixed();
	setElement(name, CONTENT_MIXED, dataBufferToString(), null);
      } else {
	parseElements();
	setElement(name, CONTENT_ELEMENTS, dataBufferToString(), null);
      }
    }
  }
  /**
    * Parse an element-content model.
    * [42] elements ::= (choice | seq) ('?' | '*' | '+')?
    * [44] cps ::= S? %cp S?
    * [45] choice ::= '(' S? %ctokplus (S? '|' S? %ctoks)* S? ')'
    * [46] ctokplus ::= cps ('|' cps)+
    * [47] ctoks ::= cps ('|' cps)*
    * [48] seq ::= '(' S? %stoks (S? ',' S? %stoks)* S? ')'
    * [49] stoks ::= cps (',' cps)*
    * *NOTE: the opening '(' and S have already been read.
    * *TODO: go over parameter entity boundaries more carefully.
    */
  void parseElements ()
    throws java.lang.Exception
  {
    char c;
    char sep;
				// Parse the first content particle
    skipWhitespace();
    parseCp();
				// Check for end or for a separator.
    skipWhitespace();
    c = readCh();
    switch (c) {
    case ')':
      dataBufferAppend(')');
      c = readCh();
      switch (c) {
      case '*':
      case '+':
      case '?':
	dataBufferAppend(c);
	break;
      default:
	unread(c);
      }
      return;
    case ',':			// Register the separator.
    case '|':
      sep = c;
      dataBufferAppend(c);
      break;
    default:
      error(""bad separator in content model"", c, null);
      return;
    }
				// Parse the rest of the content model.
    while (true) {
      skipWhitespace();
      parseCp();
      skipWhitespace();
      c = readCh();
      if (c == ')') {
	dataBufferAppend(')');
	break;
      } else if (c != sep) {
	error(""bad separator in content model"", c, null);
	return;
      } else {
	dataBufferAppend(c);
      }
    }
				// Check for the occurrence indicator.
    c = readCh();
    switch (c) {
    case '?':
    case '*':
    case '+':
      dataBufferAppend(c);
      return;
    default:
      unread(c);
      return;
    }
  }
  /**
    * Parse a content particle.
    * [43] cp ::= (Name | choice | seq) ('?' | '*' | '+')
    * *NOTE: I actually use a slightly different production here:
    *        cp ::= (elements | (Name ('?' | '*' | '+')?))
    */
  void parseCp ()
    throws java.lang.Exception
  {
    char c;
    if (tryRead('(')) {
      dataBufferAppend('(');
      parseElements();
    } else {
      dataBufferAppend(readNmtoken(true));
      c = readCh();
      switch (c) {
      case '?':
      case '*':
      case '+':
	dataBufferAppend(c);
	break;
      default:
	unread(c);
	break;
      }
    }
  }
  /**
    * Parse mixed content.
    * [50] Mixed ::= '(' S? %( %'#PCDATA' (S? '|' S? %Mtoks)* ) S? ')*'
    *              | '(' S? %('#PCDATA') S? ')'
    * [51] Mtoks ::= %Name (S? '|' S? %Name)*
    * *NOTE: the S and '#PCDATA' have already been read.
    */
  void parseMixed ()
    throws java.lang.Exception
  {
    char c;
				// Check for PCDATA alone.
    skipWhitespace();
    if (tryRead(')')) {
      dataBufferAppend("")*"");
      tryRead('*');
      return;
    }
				// Parse mixed content.
    skipWhitespace();
    while (!tryRead("")*"")) {
      require('|');
      dataBufferAppend('|');
      skipWhitespace();
      dataBufferAppend(readNmtoken(true));
      skipWhitespace();
    }
    dataBufferAppend("")*"");
  }
  /**
    * Parse an attribute list declaration.
    * [52] AttlistDecl ::= '<!ATTLIST' S %Name S? %AttDef+ S? '>'
    * *NOTE: the '<!ATTLIST' has already been read.
    */
  void parseAttlistDecl ()
    throws java.lang.Exception
  {
    String elementName;
    requireWhitespace();
    elementName = readNmtoken(true);
    requireWhitespace();
    while (!tryRead('>')) {
      parseAttDef(elementName);
      skipWhitespace();
    }
  }
  /**
    * Parse a single attribute definition.
    * [53] AttDef ::= S %Name S %AttType S %Default
    */
  void parseAttDef (String elementName)
    throws java.lang.Exception
  {
    String name;
    int type;
    String enum = null;
				// Read the attribute name.
    name = readNmtoken(true);
				// Read the attribute type.
    requireWhitespace();
    type = readAttType();
				// Get the string of enumerated values
				// if necessary.
    if (type == ATTRIBUTE_ENUMERATED || type == ATTRIBUTE_NOTATION) {
      enum = dataBufferToString();
    }
				// Read the default value.
    requireWhitespace();
    parseDefault(elementName, name, type, enum);
  }
  /**
    * Parse the attribute type.
    * [54] AttType ::= StringType | TokenizedType | EnumeratedType
    * [55] StringType ::= 'CDATA'
    * [56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' |
    *                        'NMTOKEN' | 'NMTOKENS'
    * [57] EnumeratedType ::= NotationType | Enumeration
    * *TODO: validate the type!!
    */
  int readAttType ()
    throws java.lang.Exception
  {
    String typeString;
    Integer type;
    if (tryRead('(')) {
      parseEnumeration();
      return ATTRIBUTE_ENUMERATED;
    } else {
      typeString = readNmtoken(true);
      if (typeString.equals(""NOTATION"")) {
	parseNotationType();
      }
      type = (Integer)attributeTypeHash.get(typeString);
      if (type == null) {
	error(""illegal attribute type"", typeString, null);
	return ATTRIBUTE_UNDECLARED;
      } else {
	return type.intValue();
      }
    }
  }
  /**
    * Parse an enumeration.
    * [60] Enumeration ::= '(' S? %Etoks (S? '|' S? %Etoks)* S? ')'
    * [61] Etoks ::= %Nmtoken (S? '|' S? %Nmtoken)*
    * *NOTE: the '(' has already been read.
    */
  void parseEnumeration ()
    throws java.lang.Exception
  {
    char c;
    dataBufferAppend('(');
				// Read the first token.
    skipWhitespace();
    dataBufferAppend(readNmtoken(true));
				// Read the remaining tokens.
    skipWhitespace();
    while (!tryRead(')')) {
      require('|');
      dataBufferAppend('|');
      skipWhitespace();
      dataBufferAppend(readNmtoken(true));
      skipWhitespace();
    }
    dataBufferAppend(')');
  }
  /**
    * Parse a notation type for an attribute.
    * [58] NotationType ::= %'NOTATION' S '(' S? %Ntoks (S? '|' S? %Ntoks)*
    *                       S? ')'
    * [59] Ntoks ::= %Name (S? '|' S? %Name)
    * *NOTE: the 'NOTATION' has already been read
    */
  void parseNotationType ()
    throws java.lang.Exception
  {
    requireWhitespace();
    require('(');
    parseEnumeration();
  }
  /**
    * Parse the default value for an attribute.
    * [62] Default ::= '#REQUIRED' | '#IMPLIED' | ((%'#FIXED' S)? %AttValue
    */
  void parseDefault (String elementName, String name, int type, String enum)
    throws java.lang.Exception
  {
    int valueType = ATTRIBUTE_DEFAULT_SPECIFIED;
    String value = null;
    boolean normalizeWSFlag;
    if (tryRead('#')) {
      if (tryRead(""FIXED"")) {
	valueType = ATTRIBUTE_DEFAULT_FIXED;
	requireWhitespace();
	context = CONTEXT_ATTRIBUTEVALUE;
	value = readLiteral(LIT_CHAR_REF);
	context = CONTEXT_DTD;
      } else if (tryRead(""REQUIRED"")) {
	valueType = ATTRIBUTE_DEFAULT_REQUIRED;
      } else if (tryRead(""IMPLIED"")) {
	valueType = ATTRIBUTE_DEFAULT_IMPLIED;
      } else {
	error(""illegal keyword for attribute default value"", null, null);
      }
    } else {
      context = CONTEXT_ATTRIBUTEVALUE;
      value = readLiteral(LIT_CHAR_REF);
      context = CONTEXT_DTD;
    }
    setAttribute(elementName, name, type, enum, value, valueType);
  }
  /**
    * Parse a conditional section.
    * [63] conditionalSect ::= includeSect || ignoreSect
    * [64] includeSect ::= '<![' %'INCLUDE' '[' (%markupdecl*)* ']]>'
    * [65] ignoreSect ::= '<![' %'IGNORE' '[' ignoreSectContents* ']]>'
    * [66] ignoreSectContents ::= ((SkipLit | Comment | PI) -(Char* ']]>'))
    *                           | ('<![' ignoreSectContents* ']]>')
    *                           | (Char - (']' | [<'""]))
    *                           | ('<!' (Char - ('-' | '[')))
    * *NOTE: the '<![' has already been read.
    * *TODO: verify that I am handling ignoreSectContents right.
    */
  void parseConditionalSect ()
    throws java.lang.Exception
  {
    skipWhitespace();
    if (tryRead(""INCLUDE"")) {
      skipWhitespace();
      require('[');
      skipWhitespace();
      while (!tryRead(""]]>"")) {
	parseMarkupdecl();
	skipWhitespace();
      }
    } else if (tryRead(""IGNORE"")) {
      skipWhitespace();
      require('[');
      int nesting = 1;
      char c;
      for (int nest = 1; nest > 0; ) {
	c = readCh();
	switch (c) {
	case '<':
	  if (tryRead(""!["")) {
	    nest++;
	  }
	case ']':
	  if (tryRead(""]>"")) {
	    nest--;
	  }
	}
      }
    } else {
      error(""conditional section must begin with INCLUDE or IGNORE"",
	    null, null);
    }
  }
  /**
    * Read a character reference.
    * [67] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
    * *NOTE: the '&#' has already been read.
    */
  void parseCharRef ()
    throws java.lang.Exception
  {
    int value = 0;
    char c;
    if (tryRead('x')) {
      loop1: while (true) {
	c = readCh();
	switch (c) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'a':
	case 'A':
	case 'b':
	case 'B':
	case 'c':
	case 'C':
	case 'd':
	case 'D':
	case 'e':
	case 'E':
	case 'f':
	case 'F':
	  value *= 16;
	  value += Integer.parseInt(new Character(c).toString(), 16);
	  break;
	case ';':
	  break loop1;
	default:
	  error(""illegal character in character reference"", c, null);
	  break loop1;
	}
      }
    } else {
      loop2: while (true) {
	c = readCh();
	switch (c) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  value *= 10;
	  value += Integer.parseInt(new Character(c).toString(), 10);
	  break;
	case ';':
	  break loop2;
	default:
	  error(""illegal character in character reference"", c, null);
	  break loop2;
	}
      }
    }
    // Check for surrogates: 00000000 0000xxxx yyyyyyyy zzzzzzzz
    //  (1101|10xx|xxyy|yyyy + 1101|11yy|zzzz|zzzz: 
    if (value <= 0x0000ffff) {
				// no surrogates needed
      dataBufferAppend((char)value);
    } else if (value <= 0x000fffff) {
				// > 16 bits, surrogate needed
      dataBufferAppend((char)(0xd8 | ((value & 0x000ffc00) >> 10)));
      dataBufferAppend((char)(0xdc | (value & 0x0003ff)));
    } else {
				// too big for surrogate
      error(""character reference "" + value + "" is too large for UTF-16"",
	    new Integer(value).toString(), null);
    }
  }
  /**
    * Parse a reference.
    * [69] EntityRef ::= '&' Name ';'
    * *NOTE: the '&' has already been read.
    * @param externalAllowed External entities are allowed here.
    */
  void parseEntityRef (boolean externalAllowed)
    throws java.lang.Exception
  {
    String name;
    name = readNmtoken(true);
    require(';');
    switch (getEntityType(name)) {
    case ENTITY_UNDECLARED:
      error(""reference to undeclared entity"", name, null);
      break;
    case ENTITY_INTERNAL:
      pushString(name, getEntityValue(name));
      break;
    case ENTITY_TEXT:
      if (externalAllowed) {
	pushURL(name, getEntityPublicId(name),
		getEntitySystemId(name),
		null, null, null);
      } else {
	error(""reference to external entity in attribute value."", name, null);
      }
      break;
    case ENTITY_NDATA:
      if (externalAllowed) {
	error(""data entity reference in content"", name, null);
      } else {
	error(""reference to external entity in attribute value."", name, null);
      }
      break;
    }
  }
  /**
    * Parse a parameter entity reference.
    * [70] PEReference ::= '%' Name ';'
    * *NOTE: the '%' has already been read.
    */
  void parsePEReference (boolean isEntityValue)
    throws java.lang.Exception
  {
    String name;
    name = ""%"" + readNmtoken(true);
    require(';');
    switch (getEntityType(name)) {
    case ENTITY_UNDECLARED:
      error(""reference to undeclared parameter entity"", name, null);
      break;
    case ENTITY_INTERNAL:
      if (isEntityValue) {
	pushString(name, getEntityValue(name));
      } else {
	pushString(name, "" "" + getEntityValue(name) + ' ');
      }
      break;
    case ENTITY_TEXT:
      if (isEntityValue) {
	pushString(null, "" "");
      }
      pushURL(name, getEntityPublicId(name),
	      getEntitySystemId(name),
	      null, null, null);
      if (isEntityValue) {
	pushString(null, "" "");
      }
      break;
    }
  }
  /**
    * Parse an entity declaration.
    * [71] EntityDecl ::= '<!ENTITY' S %Name S %EntityDef S? '>'
    *                   | '<!ENTITY' S '%' S %Name S %EntityDef S? '>'
    * [72] EntityDef ::= EntityValue | ExternalDef
    * [73] ExternalDef ::= ExternalID %NDataDecl?
    * [74] ExternalID ::= 'SYSTEM' S SystemLiteral
    *                   | 'PUBLIC' S PubidLiteral S SystemLiteral
    * [75] NDataDecl ::= S %'NDATA' S %Name
    * *NOTE: the '<!ENTITY' has already been read.
    */
  void parseEntityDecl ()
    throws java.lang.Exception
  {
    char c;
    boolean peFlag = false;
    String name, value, notationName, ids[];
				// Check for a parameter entity.
    requireWhitespace();
    if (tryRead('%')) {
      peFlag = true;
      requireWhitespace();
    }
				// Read the entity name, and prepend
				// '%' if necessary.
    name = readNmtoken(true);
    if (peFlag) {
      name = ""%"" + name;
    }
				// Read the entity value.
    requireWhitespace();
    c = readCh();
    unread(c);
    if (c == '""' || c == '\'') {
				// Internal entity.
      context = CONTEXT_ENTITYVALUE;
      value = readLiteral(LIT_CHAR_REF|LIT_PE_REF);
      context = CONTEXT_DTD;
      setInternalEntity(name,value);
    } else {
				// Read the external IDs
      ids = readExternalIds(false);
      if (ids[1] == null) {
	error(""system identifer missing"", name, null);
      }
				// Check for NDATA declaration.
      skipWhitespace();
      if (tryRead(""NDATA"")) {
	requireWhitespace();
	notationName = readNmtoken(true);
	setExternalDataEntity(name, ids[0], ids[1], notationName);
      } else {
	setExternalTextEntity(name, ids[0], ids[1]);
      }
    }
				// Finish the declaration.
    skipWhitespace();
    require('>');
  }
  /**
    * Parse a notation declaration.
    * [81] NotationDecl ::= '<!NOTATION' S %Name S %ExternalID S? '>'
    * *NOTE: the '<!NOTATION' has already been read.
    */
  void parseNotationDecl ()
    throws java.lang.Exception
  {
    String nname, ids[];
    requireWhitespace();
    nname = readNmtoken(true);
    requireWhitespace();
				// Read the external identifiers.
    ids = readExternalIds(true);
    if (ids[0] == null && ids[1] == null) {
      error(""external identifer missing"", nname, null);
    }
				// Register the notation.
    setNotation(nname, ids[0], ids[1]);
    skipWhitespace();
    require('>');
  }
  /**
    * Parse PCDATA.
    * <pre>
    * [16] PCData ::= [^&lt;&amp;]*
    * </pre>
    * <p>The trick here is that the data stays in the dataBuffer without
    * necessarily being converted to a string right away.
    */
  void parsePCData ()
    throws java.lang.Exception
  {
    char c;
				// Start with a little cheat -- in most
				// cases, the entire sequence of
				// character data will already be in
				// the readBuffer; if not, fall through to
				// the normal approach.
    if (USE_CHEATS) {
      int lineAugment = 0;
      int columnAugment = 0;
      loop: for (int i = readBufferPos; i < readBufferLength; i++) {
	switch (readBuffer[i]) {
	case '\n':
	  lineAugment++;
	  columnAugment = 0;
	  break;
	case '&':
	case '<':
	  int start = readBufferPos;
	  columnAugment++;
	  readBufferPos = i;
	  if (lineAugment > 0) {
	    line += lineAugment;
	    column = columnAugment;
	  } else {
	    column += columnAugment;
	  }
	  dataBufferAppend(readBuffer, start, i-start);
	  return;
	default:
	  columnAugment++;
	}
      }
    }
				// OK, the cheat didn't work; start over
				// and do it by the book.
    while (true) {
      c = readCh();
      switch (c) {
      case '<':
      case '&':
	unread(c);
	return;
      default:
	dataBufferAppend(c);
	break;
      }
    }
  }
  //////////////////////////////////////////////////////////////////////
  // High-level reading and scanning methods.
  //////////////////////////////////////////////////////////////////////
  /**
    * Require whitespace characters.
    * [1] S ::= (#x20 | #x9 | #xd | #xa)+
    */
  void requireWhitespace ()
    throws java.lang.Exception
  {
    char c = readCh();
    if (isWhitespace(c)) {
      skipWhitespace();
    } else {
      error(""whitespace expected"", c, null);
    }
  }
  /**
    * Parse whitespace characters, and leave them in the data buffer.
    */
  void parseWhitespace ()
    throws java.lang.Exception
  {
    char c = readCh();
    while (isWhitespace(c)) {
      dataBufferAppend(c);
      c = readCh();
    }
    unread(c);
  }
  /**
    * Skip whitespace characters.
    * [1] S ::= (#x20 | #x9 | #xd | #xa)+
    */
  void skipWhitespace ()
    throws java.lang.Exception
  {
				// Start with a little cheat.  Most of
				// the time, the white space will fall
				// within the current read buffer; if
				// not, then fall through.
    if (USE_CHEATS) {
      int lineAugment = 0;
      int columnAugment = 0;
      loop: for (int i = readBufferPos; i < readBufferLength; i++) {
	switch (readBuffer[i]) {
	case ' ':
	case '\t':
	case '\r':
	  columnAugment++;
	  break;
	case '\n':
	  lineAugment++;
	  columnAugment = 0;
	  break;
	case '%':
	  if (context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE) {
	    break loop;
	  } // else fall through...
	default:
	  readBufferPos = i;
	  if (lineAugment > 0) {
	    line += lineAugment;
	    column = columnAugment;
	  } else {
	    column += columnAugment;
	  }
	  return;
	}
      }
    }
				// OK, do it by the book.
    char c = readCh();
    while (isWhitespace(c)) {
      c = readCh();
    }
    unread(c);
  }
  /**
    * Read a name or name token.
    * [5] Name ::= (Letter | '_' | ':') (NameChar)*
    * [7] Nmtoken ::= (NameChar)+
    * *NOTE: [6] is implemented implicitly where required.
    */
  String readNmtoken (boolean isName)
    throws java.lang.Exception
  {
    char c;
    if (USE_CHEATS) {
      loop: for (int i = readBufferPos; i < readBufferLength; i++) {
	switch (readBuffer[i]) {
	case '%':
	  if (context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE) {
	    break loop;
	  } // else fall through...
	case '<':
	case '>':
	case '&':
	case ',':
	case '|':
	case '*':
	case '+':
	case '?':
	case ')':
	case '=':
	case '\'':
	case '""':
	case '[':
	case ' ':
	case '\t':
	case '\r':
	case '\n':
	case ';':
	case '/':
	case '#':
	  int start = readBufferPos;
	  if (i == start) {
	    error(""name expected"", readBuffer[i], null);
	  }
	  readBufferPos = i;
	  return intern(readBuffer, start, i - start);
	}
      }
    }
    nameBufferPos = 0;
				// Read the first character.
    loop: while (true) {
      c = readCh();
      switch (c) {
      case '%':
      case '<':
      case '>':
      case '&':
      case ',':
      case '|':
      case '*':
      case '+':
      case '?':
      case ')':
      case '=':
      case '\'':
      case '""':
      case '[':
      case ' ':
      case '\t':
      case '\n':
      case '\r':
      case ';':
      case '/':
	unread(c);
	if (nameBufferPos == 0) {
	  error(""name expected"", null, null);
	}
	String s = intern(nameBuffer,0,nameBufferPos);
	nameBufferPos = 0;
	return s;
      default:
	nameBuffer =
	  (char[])extendArray(nameBuffer, nameBuffer.length, nameBufferPos);
	nameBuffer[nameBufferPos++] = c;
      }
    }
  }
  /**
    * Read a literal.
    * [10] AttValue ::= '""' ([^<&""] | Reference)* '""'
    *                 | ""'"" ([^<&'] | Reference)* ""'""
    * [11] SystemLiteral ::= '""' URLchar* '""' | ""'"" (URLchar - ""'"")* ""'""
    * [13] PubidLiteral ::= '""' PubidChar* '""' | ""'"" (PubidChar - ""'"")* ""'""
    * [9] EntityValue ::= '""' ([^%&""] | PEReference | Reference)* '""'
    *                   | ""'"" ([^%&'] | PEReference | Reference)* ""'""
    */
  String readLiteral (int flags)
    throws java.lang.Exception
  {
    char delim, c;
    int startLine = line;
				// Find the delimiter.
    delim = readCh();
    if (delim != '""' && delim != '\'' && delim != (char)0) {
      error(""expected '\""' or \""'\"""", delim, null);
      return null;
    }
				// Read the literal.
    try {
      c = readCh();
    loop: while (c != delim) {
      switch (c) {
				// Literals never have line ends
      case '\n':
      case '\r':
	c = ' ';
	break;
				// References may be allowed
      case '&':
	if ((flags & LIT_CHAR_REF) > 0) {
	  c = readCh();
	  if (c == '#') {
	    parseCharRef();
	    c = readCh();
	    continue loop;		// check the next character
	  } else if ((flags & LIT_ENTITY_REF) > 0) {
	    unread(c);
	    parseEntityRef(false);
	    c = readCh();
	    continue loop;
	  } else {
	    dataBufferAppend('&');
	  }
	}
	break;
      default:
	break;
      }
      dataBufferAppend(c);
      c = readCh();
    }
    } catch (EOFException e) {
      error(""end of input while looking for delimiter (started on line ""
	    + startLine + ')', null, new Character(delim).toString());
    }
				// Normalise whitespace if necessary.
    if ((flags & LIT_NORMALIZE) > 0) {
      dataBufferNormalize();
    }
				// Return the value.
    return dataBufferToString();
  }
  /**
    * Try reading external identifiers.
    * <p>The system identifier is not required for notations.
    * @param inNotation Are we in a notation?
    * @return A two-member String array containing the identifiers.
    */
  String[] readExternalIds (boolean inNotation)
    throws java.lang.Exception
  {
    char c;
    String ids[] = new String[2];
    if (tryRead(""PUBLIC"")) {
      requireWhitespace();
      ids[0] = readLiteral(LIT_NORMALIZE); // public id
      if (inNotation) {
	skipWhitespace();
	if (tryRead('""') || tryRead('\'')) {
	  ids[1] = readLiteral(0);
	}
      } else {
	requireWhitespace();
	ids[1] = readLiteral(0); // system id
      }
    } else if (tryRead(""SYSTEM"")) {
      requireWhitespace();
      ids[1] = readLiteral(0);	// system id
    }
    return ids;
  }
  /**
    * Test if a character is whitespace.
    * <pre>
    * [1] S ::= (#x20 | #x9 | #xd | #xa)+
    * </pre>
    * @param c The character to test.
    * @return true if the character is whitespace.
    */
  final boolean isWhitespace (char c)
  {
    switch ((int)c) {
    case 0x20:
    case 0x09:
    case 0x0d:
    case 0x0a:
      return true;
    default:
      return false;
    }
  }
  //////////////////////////////////////////////////////////////////////
  // Utility routines.
  //////////////////////////////////////////////////////////////////////
  /**
    * Add a character to the data buffer.
    */
  void dataBufferAppend (char c)
  {
				// Expand buffer if necessary.
    dataBuffer =
      (char[])extendArray(dataBuffer, dataBuffer.length, dataBufferPos);
    dataBuffer[dataBufferPos++] = c;
  }
  /** 
    * Add a string to the data buffer.
    */
  void dataBufferAppend (String s)
  {
    dataBufferAppend(s.toCharArray(), 0, s.length());
  }
  /**
    * Append (part of) a character array to the data buffer.
    */
  void dataBufferAppend (char ch[], int start, int length)
  {
    dataBuffer =
      (char[])extendArray(dataBuffer, dataBuffer.length,
			  dataBufferPos + length);
    System.arraycopy((Object)ch, start,
		     (Object)dataBuffer, dataBufferPos,
		     length);
    dataBufferPos += length;
  }
  /**
    * Normalise whitespace in the data buffer.
    */
  void dataBufferNormalize ()
  {
    int i = 0;
    int j = 0;
    int end = dataBufferPos;
				// Skip whitespace at the start.
    while (j < end && isWhitespace(dataBuffer[j])) {
      j++;
    }
				// Skip whitespace at the end.
    while (end > j && isWhitespace(dataBuffer[end - 1])) {
      end --;
    }
				// Start copying to the left.
    while (j < end) {
      char c = dataBuffer[j++];
				// Normalise all other whitespace to
				// a single space.
      if (isWhitespace(c)) {
	while (j < end && isWhitespace(dataBuffer[j++])) {
	}
	dataBuffer[i++] = ' ';
	dataBuffer[i++] = dataBuffer[j-1];
      } else {
	dataBuffer[i++] = c;
      }
    }
				// The new length is <= the old one.
    dataBufferPos = i;
  }
  /**
    * Convert the data buffer to a string.
    * @param internFlag true if the contents should be interned.
    * @see #intern(char[],int,int)
    */
  String dataBufferToString ()
  {
    String s = new String(dataBuffer, 0, dataBufferPos);
    dataBufferPos = 0;
    return s;
  }
  /**
    * Flush the contents of the data buffer to the handler, if
    * appropriate, and reset the buffer for new input.
    */
  void dataBufferFlush ()
    throws java.lang.Exception
  {
    if (dataBufferPos > 0) {
      switch (currentElementContent) {
      case CONTENT_UNDECLARED:
      case CONTENT_EMPTY:
	// do nothing
	break;
      case CONTENT_MIXED:
      case CONTENT_ANY:
	if (handler != null) {
	  handler.charData(dataBuffer, 0, dataBufferPos);
	}
	break;
      case CONTENT_ELEMENTS:
	if (handler != null) {
	  handler.ignorableWhitespace(dataBuffer, 0, dataBufferPos);
	}
	break;
      }
      dataBufferPos = 0;
    }
  }
  /**
    * Require a string to appear, or throw an exception.
    */
  void require (String delim)
    throws java.lang.Exception
  {
    char ch[] = delim.toCharArray();
    for (int i = 0; i < ch.length; i++) {
      require(ch[i]);
    }
  }
  /**
    * Require a character to appear, or throw an exception.
    */
  void require (char delim)
       throws java.lang.Exception
  {
    char c = readCh();
    if (c != delim) {
      error(""expected character"", c, new Character(delim).toString());
    }
  }
  /**
    * Return an internalised version of a string.
    * <p>&AElig;lfred uses this method to create an internalised version
    * of all names and attribute values, so that it can test equality
    * with <code>==</code> instead of <code>String.equals()</code>.
    * <p>If you want to be able to test for equality in the same way,
    * you can use this method to internalise your own strings first:
    * <pre>
    * String PARA = handler.intern(""PARA"");
    * </pre>
    * <p>Note that this will not return the same results as String.intern().
    * @param s The string to internalise.
    * @return An internalised version of the string.
    * @see #intern(char[],int,int)
    * @see java.lang.String#intern
    */
  public String intern (String s)
  {
    char ch[] = s.toCharArray();
    return intern(ch, 0, ch.length);
  }
  /**
    * Create an internalised string from a character array.
    * <p>This is much more efficient than constructing a non-internalised
    * string first, and then internalising it.
    * <p>Note that this will not return the same results as String.intern().
    * @param ch an array of characters for building the string.
    * @param start the starting position in the array.
    * @param length the number of characters to place in the string.
    * @return an internalised string.
    * @see #intern(String)
    * @see java.lang.String#intern
    */
  public String intern (char ch[], int start, int length)
  {
    int index;
    int hash = 0;
				// Generate a hash code.
    for (int i = start; i < start + length; i++) {
      hash = ((hash << 1) & 0xffffff) + (int)ch[i];
    }
    hash = hash % SYMBOL_TABLE_LENGTH;
				// Get the bucket.
    Object bucket[] = (Object[])symbolTable[hash];
    if (bucket == null) {
      symbolTable[hash] = bucket = new Object[8];
    }
				// Search for a matching tuple, and
				// return the string if we find one.
    for (index = 0; index < bucket.length; index += 2) {
      char chFound[] = (char[])bucket[index];
				// Stop when we hit a null index.
      if (chFound == null) {
	break;
      }
				// If they're the same length,
				// check for a match.
				// If the loop finishes, 'index' will
				// contain the current bucket
				// position.
      if (chFound.length == length) {
	for (int i = 0; i < chFound.length; i++) {
				// Stop if there are no more tuples.
	  if (ch[start+i] != chFound[i]) {
	    break;
	  } else if (i == length-1) {
				// That's it, we have a match!
	    return (String)bucket[index+1];
	  }
	}
      }
    }
				// Not found -- we'll have to add it.
				// Do we have to grow the bucket?
    bucket =
      (Object[])extendArray(bucket, bucket.length, index);
				// OK, add it to the end of the
				// bucket.
    String s = new String(ch, start, length);
    bucket[index] = s.toCharArray();
    bucket[index+1] = s;
    symbolTable[hash] = bucket;
    return s;
  }
  /**
    * Ensure the capacity of an array, allocating a new one if
    * necessary.
    */
  Object extendArray (Object array, int currentSize, int requiredSize)
  {
    if (requiredSize < currentSize) {
      return array;
    } else {
      Object newArray = null;
      int newSize = currentSize * 2;
      if (newSize <= requiredSize) {
	newSize = requiredSize + 1;
      }
      if (array instanceof char[]) {
	newArray = new char[currentSize * 2];
      } else if (array instanceof Object[]) {
	newArray = new Object[currentSize * 2];
      }
      System.arraycopy(array, 0, newArray, 0, currentSize);
      return newArray;
    }
  }
  //////////////////////////////////////////////////////////////////////
  // XML query routines.
  //////////////////////////////////////////////////////////////////////
  //
  // Elements
  //
  /**
    * Get the declared elements for an XML document.
    * <p>The results will be valid only after the DTD (if any) has been
    * parsed.
    * @return An enumeration of all element types declared for this
    *         document (as Strings).
    * @see #getElementContentType
    * @see #getElementContentModel
    */
  public Enumeration declaredElements ()
  {
    return elementInfo.keys();
  }
  /**
    * Look up the content type of an element.
    * @param name The element type name.
    * @return An integer constant representing the content type.
    * @see #getElementContentModel
    * @see #CONTENT_UNDECLARED
    * @see #CONTENT_ANY
    * @see #CONTENT_EMPTY
    * @see #CONTENT_MIXED
    * @see #CONTENT_ELEMENTS
    */
  public int getElementContentType (String name)
  {
    Object element[] = (Object[])elementInfo.get(name);
    if (element == null) {
      return CONTENT_UNDECLARED;
    } else {
      return ((Integer)element[0]).intValue();
    }
  }
  /**
    * Look up the content model of an element.
    * <p>The result will always be null unless the content type is
    * CONTENT_ELEMENTS or CONTENT_MIXED.
    * @param name The element type name.
    * @return The normalised content model, as a string.
    * @see #getElementContentType
    */
  public String getElementContentModel (String name)
  {
    Object element[] = (Object[])elementInfo.get(name);
    if (element == null) {
      return null;
    } else {
      return (String)element[1];
    }
  }
  /**
    * Register an element.
    * Array format:
    *  element type
    *  attribute hash table
    */
  void setElement (String name, int contentType,
		   String contentModel, Hashtable attributes)
    throws java.lang.Exception
  {
    Object element[];
				// Try looking up the element
    element = (Object[])elementInfo.get(name);
				// Make a new one if necessary.
    if (element == null) {
      element = new Object[3];
      element[0] = new Integer(CONTENT_UNDECLARED);
      element[1] = null;
      element[2] = null;
    } else if (contentType != CONTENT_UNDECLARED &&
	       ((Integer)element[0]).intValue() != CONTENT_UNDECLARED) {
      error(""multiple declarations for element type"", name, null);
      return;
    }
				// Insert the content type, if any.
    if (contentType != CONTENT_UNDECLARED) {
      element[0] = new Integer(contentType);
    }
				// Insert the content model, if any.
    if (contentModel != null) {
      element[1] = contentModel;
    }
				// Insert the attributes, if any.
    if (attributes != null) {
      element[2] =attributes;
    }
				// Save the element info.
    elementInfo.put(name,element);
  }
  /**
    * Look up the attribute hash table for an element.
    * The hash table is the second item in the element array.
    */
  Hashtable getElementAttributes (String name)
  {
    Object element[] = (Object[])elementInfo.get(name);
    if (element == null) {
      return null;
    } else {
      return (Hashtable)element[2];
    }
  }
  //
  // Attributes
  //
  /**
    * Get the declared attributes for an element type.
    * @param elname The name of the element type.
    * @return An Enumeration of all the attributes declared for
    *         a specific element type.  The results will be valid only
    *         after the DTD (if any) has been parsed.
    * @see #getAttributeType
    * @see #getAttributeEnumeration
    * @see #getAttributeDefaultValueType
    * @see #getAttributeDefaultValue
    * @see #getAttributeExpandedValue
    */
  public Enumeration declaredAttributes (String elname)
  {
    Hashtable attlist = getElementAttributes(elname);
    if (attlist == null) {
      return null;
    } else {
      return attlist.keys();
    }
  }
  /**
    * Retrieve the declared type of an attribute.
    * @param name The name of the associated element.
    * @param aname The name of the attribute.
    * @return An integer constant representing the attribute type.
    * @see #ATTRIBUTE_UNDECLARED
    * @see #ATTRIBUTE_CDATA
    * @see #ATTRIBUTE_ID
    * @see #ATTRIBUTE_IDREF
    * @see #ATTRIBUTE_IDREFS
    * @see #ATTRIBUTE_ENTITY
    * @see #ATTRIBUTE_ENTITIES
    * @see #ATTRIBUTE_NMTOKEN
    * @see #ATTRIBUTE_NMTOKENS
    * @see #ATTRIBUTE_ENUMERATED
    * @see #ATTRIBUTE_NOTATION
    */
  public int getAttributeType (String name, String aname)
  {
    Object attribute[] = getAttribute(name, aname);
    if (attribute == null) {
      return ATTRIBUTE_UNDECLARED;
    } else {
      return ((Integer)attribute[0]).intValue();
    }
  }
  /**
    * Retrieve the allowed values for an enumerated attribute type.
    * @param name The name of the associated element.
    * @param aname The name of the attribute.
    * @return A string containing the token list.
    * @see #ATTRIBUTE_ENUMERATED
    * @see #ATTRIBUTE_NOTATION
    */
  public String getAttributeEnumeration (String name, String aname)
  {
    Object attribute[] = getAttribute(name, aname);
    if (attribute == null) {
      return null;
    } else {
      return (String)attribute[3];
    }
  }
  /**
    * Retrieve the default value of a declared attribute.
    * @param name The name of the associated element.
    * @param aname The name of the attribute.
    * @return The default value, or null if the attribute was
    *         #IMPLIED or simply undeclared and unspecified.
    * @see #getAttributeExpandedValue
    */
  public String getAttributeDefaultValue (String name, String aname)
  {
    Object attribute[] = getAttribute(name, aname);
    if (attribute == null) {
      return null;
    } else {
      return (String)attribute[1];
    }
  }
  /**
    * Retrieve the expanded value of a declared attribute.
    * <p>All general entities will be expanded.
    * @param name The name of the associated element.
    * @param aname The name of the attribute.
    * @return The expanded default value, or null if the attribute was
    *         #IMPLIED or simply undeclared
    * @see #getAttributeDefaultValue
    */
  public String getAttributeExpandedValue (String name, String aname)
  {
    Object attribute[] = getAttribute(name, aname);
    if (attribute == null) {
      return null;
    } else if (attribute[4] == null && attribute[1] != null) {
      try {
	pushString(null, (char)0 + (String)attribute[1] + (char)0);
	attribute[4] = readLiteral(LIT_NORMALIZE |
				   LIT_CHAR_REF |
				   LIT_ENTITY_REF);
      } catch (Exception e) {}
    }
    return (String)attribute[4];
  }
  /**
    * Retrieve the default value type of a declared attribute.
    * @see #ATTRIBUTE_DEFAULT_SPECIFIED
    * @see #ATTRIBUTE_DEFAULT_IMPLIED
    * @see #ATTRIBUTE_DEFAULT_REQUIRED
    * @see #ATTRIBUTE_DEFAULT_FIXED
    */
  public int getAttributeDefaultValueType (String name, String aname)
  {
    Object attribute[] = getAttribute(name, aname);
    if (attribute == null) {
      return ATTRIBUTE_DEFAULT_UNDECLARED;
    } else {
      return ((Integer)attribute[2]).intValue();
    }
  }
  /**
    * Register an attribute declaration for later retrieval.
    * Format:
    * - String type
    * - String default value
    * - int value type
    * *TODO: do something with attribute types.
    */
  void setAttribute (String elName, String name, int type, String enumeration,
		     String value, int valueType)
    throws java.lang.Exception
  {
    Hashtable attlist;
    Object attribute[];
				// Create a new hashtable if necessary.
    attlist = getElementAttributes(elName);
    if (attlist == null) {
      attlist = new Hashtable();
    }
				// Check that the attribute doesn't
				// already exist!
    if (attlist.get(name) != null) {
      return;
    } else {
      attribute = new Object[5];
      attribute[0] = new Integer(type);
      attribute[1] = value;
      attribute[2] = new Integer(valueType);
      attribute[3] = enumeration;
      attribute[4] = null;
      attlist.put(name.intern(), attribute);
				// Use CONTENT_UNDECLARED to avoid overwriting
				// existing element declaration.
      setElement(elName,CONTENT_UNDECLARED, null, attlist);
    }
  }
  /**
    * Retrieve the three-member array representing an
    * attribute declaration.
    */
  Object[] getAttribute (String elName, String name)
  {
    Hashtable attlist;
    Object attribute[];
    attlist = getElementAttributes(elName);
    if (attlist == null) {
      return null;
    }
    attribute = (Object[])attlist.get(name);
    return attribute;
  }
  //
  // Entities
  //
  /**
    * Get declared entities.
    * @return An Enumeration of all the entities declared for
    *         this XML document.  The results will be valid only
    *         after the DTD (if any) has been parsed.
    * @see #getEntityType
    * @see #getEntityPublicId
    * @see #getEntitySystemId
    * @see #getEntityValue
    * @see #getEntityNotationName
    */
  public Enumeration declaredEntities ()
  {
    return entityInfo.keys();
  }
  /**
    * Find the type of an entity.
    * @returns An integer constant representing the entity type.
    * @see #ENTITY_UNDECLARED
    * @see #ENTITY_INTERNAL
    * @see #ENTITY_NDATA
    * @see #ENTITY_TEXT
    */
  public int getEntityType (String ename)
  {
    Object entity[] = (Object[])entityInfo.get(ename);
    if (entity == null) {
      return ENTITY_UNDECLARED;
    } else {
      return ((Integer)entity[0]).intValue();
    }
  }
  /**
    * Return an external entity's public identifier, if any.
    * @param ename The name of the external entity.
    * @return The entity's system identifier, or null if the
    *         entity was not declared, if it is not an
    *         external entity, or if no public identifier was
    *         provided.
    * @see #getEntityType
    */
  public String getEntityPublicId (String ename)
  {
    Object entity[] = (Object[])entityInfo.get(ename);
    if (entity == null) {
      return null;
    } else {
      return (String)entity[1];
    }
  }
  /**
    * Return an external entity's system identifier.
    * @param ename The name of the external entity.
    * @return The entity's system identifier, or null if the
    *         entity was not declared, or if it is not an
    *         external entity.
    * @see #getEntityType
    */
  public String getEntitySystemId (String ename)
  {
    Object entity[] = (Object[])entityInfo.get(ename);
    if (entity == null) {
      return null;
    } else {
      return (String)entity[2];
    }
  }
  /**
    * Return the value of an internal entity.
    * @param ename The name of the internal entity.
    * @return The entity's value, or null if the entity was
    *         not declared, or if it is not an internal entity.
    * @see #getEntityType
    */
  public String getEntityValue (String ename)
  {
    Object entity[] = (Object[])entityInfo.get(ename);
    if (entity == null) {
      return null;
    } else {
      return (String)entity[3];
    }
  }
  /**
    * Get the notation name associated with an NDATA entity.
    * @param ename The NDATA entity name.
    * @return The associated notation name, or null if the
    *         entity was not declared, or if it is not an
    *         NDATA entity.
    * @see #getEntityType
    */
  public String getEntityNotationName (String eName)
  {
    Object entity[] = (Object[])entityInfo.get(eName);
    if (entity == null) {
      return null;
    } else {
      return (String)entity[4];
    }
  }
  /**
    * Register an entity declaration for later retrieval.
    */
  void setInternalEntity (String eName, String value)
  {
    setEntity(eName, ENTITY_INTERNAL, null, null, value, null);
  }
  /**
    * Register an external data entity.
    */
  void setExternalDataEntity (String eName, String pubid,
			      String sysid, String nName)
  {
    setEntity(eName, ENTITY_NDATA, pubid, sysid, null, nName);
  }
  /**
    * Register an external text entity.
    */
  void setExternalTextEntity (String eName, String pubid, String sysid)
  {
    setEntity(eName, ENTITY_TEXT, pubid, sysid, null, null);
  }
  /**
    * Register an entity declaration for later retrieval.
    */
  void setEntity (String eName, int eClass,
		  String pubid, String sysid,
		  String value, String nName)
  {
    Object entity[];
    if (entityInfo.get(eName) == null) {
      entity = new Object[5];
      entity[0] = new Integer(eClass);
      entity[1] = pubid;
      entity[2] = sysid;
      entity[3] = value;
      entity[4] = nName;
      entityInfo.put(eName,entity);
    }
  }
  //
  // Notations.
  //
  /**
    * Get declared notations.
    * @return An Enumeration of all the notations declared for
    *         this XML document.  The results will be valid only
    *         after the DTD (if any) has been parsed.
    * @see #getNotationPublicId
    * @see #getNotationSystemId
    */
  public Enumeration declaredNotations ()
  {
    return notationInfo.keys();
  }
  /**
    * Look up the public identifier for a notation.
    * You will normally use this method to look up a notation
    * that was provided as an attribute value or for an NDATA entity.
    * @param nname The name of the notation.
    * @return A string containing the public identifier, or null
    *         if none was provided or if no such notation was
    *         declared.
    * @see #getNotationSystemId
    */
  public String getNotationPublicId (String nname)
  {
    Object notation[] = (Object[])notationInfo.get(nname);
    if (notation == null) {
      return null;
    } else {
      return (String)notation[0];
    }
  }
  /**
    * Look up the system identifier for a notation.
    * You will normally use this method to look up a notation
    * that was provided as an attribute value or for an NDATA entity.
    * @param nname The name of the notation.
    * @return A string containing the system identifier, or null
    *         if no such notation was declared.
    * @see #getNotationPublicId
    */
  public String getNotationSystemId (String nname)
  {
    Object notation[] = (Object[])notationInfo.get(nname);
    if (notation == null) {
      return null;
    } else {
      return (String)notation[1];
    }
  }
  /**
    * Register a notation declaration for later retrieval.
    * Format:
    * - public id
    * - system id
    */
  void setNotation (String nname, String pubid, String sysid)
    throws java.lang.Exception
  {
    Object notation[];
    if (notationInfo.get(nname) == null) {
      notation = new Object[2];
      notation[0] = pubid;
      notation[1] = sysid;
      notationInfo.put(nname,notation);
    } else {
      error(""multiple declarations of notation"", nname, null);
    }
  }
  //
  // Location.
  //
  /**
    * Return the current line number.
    */
  public int getLineNumber ()
  {
    return line;
  }
  /**
    * Return the current column number.
    */
  public int getColumnNumber ()
  {
    return column;
  }
  //////////////////////////////////////////////////////////////////////
  // High-level I/O.
  //////////////////////////////////////////////////////////////////////
  /**
    * Read a single character from the readBuffer.
    * <p>The readDataChunk() method maintains the buffer.
    * <p>If we hit the end of an entity, try to pop the stack and
    * keep going.
    * <p>(This approach doesn't really enforce XML's rules about
    * entity boundaries, but this is not currently a validating
    * parser).
    * <p>This routine also attempts to keep track of the current
    * position in external entities, but it's not entirely accurate.
    * @return The next available input character.
    * @see #unread(char)
    * @see #unread(String)
    * @see #readDataChunk
    * @see #readBuffer
    * @see #line
    * @return The next character from the current input source.
    */
  char readCh ()
    throws java.lang.Exception
    {
    char c;
    // As long as there's nothing in the
    // read buffer, try reading more data
    // (for an external entity) or popping
    // the entity stack (for either).
    while (readBufferPos >= readBufferLength)
      {
      switch (sourceType)
        {
        case INPUT_READER:
        case INPUT_EXTERNAL:
        case INPUT_STREAM:
        readDataChunk();
        while (readBufferLength < 1)
          {
          popInput();
          if (readBufferLength <1)
            {
            readDataChunk();
            }
          }
        break;
        default:
        popInput();
        break;
        }
      }
    c = readBuffer[readBufferPos++];
    // This is a particularly nasty bit
    // of code, that checks for a parameter
    // entity reference but peeks ahead to
    // catch the '%' in parameter entity
    // declarations.
    if
      (
      c == '%' && 
      (context == CONTEXT_DTD || context == CONTEXT_ENTITYVALUE)
      )
      {
      char c2 = readCh();
      unread(c2);
      if (!isWhitespace(c2))
        {
        parsePEReference(context == CONTEXT_ENTITYVALUE);
        return readCh();
        }
      }
    if (c == '\n')
      {
      line++;
      column = 0;
      }
    else
      {
      column++;
      }
    return c;
    }
  /**
    * Push a single character back onto the current input stream.
    * <p>This method usually pushes the character back onto
    * the readBuffer, while the unread(String) method treats the
    * string as a new internal entity.
    * <p>I don't think that this would ever be called with 
    * readBufferPos = 0, because the methods always reads a character
    * before unreading it, but just in case, I've added a boundary
    * condition.
    * @param c The character to push back.
    * @see #readCh
    * @see #unread(String)
    * @see #unread(char[])
    * @see #readBuffer
    */
  void unread (char c)
    throws java.lang.Exception
    {
    // Normal condition.
    if (c == '\n')
      {
      line--;
      column = -1;
      }
    if (readBufferPos > 0)
      {
      readBuffer[--readBufferPos] = c;
      }
    else
      {
      pushString(null, new Character(c).toString());
      }
    }
  /**
    * Push a char array back onto the current input stream.
    * <p>NOTE: you must <em>never</em> push back characters that you
    * haven't actually read: use pushString() instead.
    * @see #readCh
    * @see #unread(char)
    * @see #unread(String)
    * @see #readBuffer
    * @see #pushString
    */
  void unread (char ch[], int length) 
    throws java.lang.Exception
    {
    for (int i = 0; i < length; i++)
        {
        if (ch[i] == '\n')
          {line--;column = -1;}
        }
    if (length < readBufferPos)
      {readBufferPos -= length;}
    else
      {
      pushCharArray(null, ch, 0, length);
      sourceType = INPUT_BUFFER;
      }
    }
  /**
    * Push a new external input source.
    * <p>The source will be either an external text entity, or the DTD
    * external subset.
    * <p>TO DO: Right now, this method always attempts to autodetect
    * the encoding; in the future, it should allow the caller to 
    * request an encoding explicitly, and it should also look at the
    * headers with an HTTP connection.
    * @param url The java.net.URL object for the entity.
    * @see XmlHandler#resolveEntity
    * @see #pushString
    * @see #sourceType
    * @see #pushInput
    * @see #detectEncoding
    * @see #sourceType
    * @see #readBuffer
    */
  void pushURL (String ename, String publicId, String systemId,
		Reader reader, InputStream stream, String encoding)
    throws java.lang.Exception
  {
    URL url;
    boolean ignoreEncoding = false;
				// Push the existing status.
    pushInput(ename);
				// Create a new read buffer.
				// (Note the four-character margin)
    readBuffer = new char[READ_BUFFER_MAX+4];
    readBufferPos = 0;
    readBufferLength = 0;
    readBufferOverflow = -1;
    is = null;
    line = 1;
    currentByteCount = 0;
				// Flush any remaining data.
    dataBufferFlush();
				// Make the URL absolute.
    if (systemId != null && externalEntity != null) {
      systemId = new URL(externalEntity.getURL(), systemId).toString();
    } else if (baseURI != null) {
      try {
	systemId = new URL(new URL(baseURI), systemId).toString();
      } catch (Exception e) {}
    }
				// See if the application wants to
				// redirect the system ID and/or
				// supply its own character stream.
    if (systemId != null && handler != null) {
      Object input = handler.resolveEntity(publicId, systemId);
      if (input != null) {
	if (input instanceof String) {
	  systemId = (String)input;
	} else if (input instanceof InputStream) {
	  stream = (InputStream)input;
	} else if (input instanceof Reader) {
	  reader = (Reader)input;
	}
      }
    }
				// Start the entity.
    if (handler != null) {
      if (systemId != null) {
	handler.startExternalEntity(systemId);
      } else {
	handler.startExternalEntity(""[external stream]"");
      }
    }
				// Figure out what we're reading from.
    if (reader != null) {
				// There's an explicit character stream.
      sourceType = INPUT_READER;
      this.reader = reader;
      tryEncodingDecl(true);
      return;
    } else if (stream != null) {
      sourceType = INPUT_STREAM;
      is = stream;
    } else {
				// We have to open our own stream
				// to the URL.
				// Set the new status
      sourceType = INPUT_EXTERNAL;
      url = new URL(systemId);
      externalEntity = url.openConnection();
      externalEntity.connect();
      is = externalEntity.getInputStream();
    }
				// If we get to here, there must be
				// an InputStream available.
    if (!is.markSupported()) {
      is = new BufferedInputStream(is);
    }
				// Attempt to detect the encoding.
    if (encoding == null && externalEntity != null) {
      encoding = externalEntity.getContentEncoding();
    }
    if (encoding != null) {
      checkEncoding(encoding, false);
      ignoreEncoding = true;
    } else {
      detectEncoding();
      ignoreEncoding = false;
    }
				// Read an XML or text declaration.
    tryEncodingDecl(ignoreEncoding);
  }
  /**
    * Check for an encoding declaration.
    */
  void tryEncodingDecl (boolean ignoreEncoding)
    throws java.lang.Exception
  {
				// Read the XML/Encoding declaration.
    if (tryRead(""<?xml"")) {
      if (tryWhitespace()) {
	if (inputStack.size() > 0) {
	  parseTextDecl(ignoreEncoding);
	} else {
	  parseXMLDecl(ignoreEncoding);
	}
      } else {
	unread(""xml"".toCharArray(), 3);
	parsePI();
      }
    }
  }
  /**
    * Attempt to detect the encoding of an entity.
    * <p>The trick here (as suggested in the XML standard) is that
    * any entity not in UTF-8, or in UCS-2 with a byte-order mark, 
    * <b>must</b> begin with an XML declaration or an encoding
    * declaration; we simply have to look for ""&lt;?XML"" in various
    * encodings.
    * <p>This method has no way to distinguish among 8-bit encodings.
    * Instead, it assumes UTF-8, then (possibly) revises its assumption
    * later in checkEncoding().  Any ASCII-derived 8-bit encoding
    * should work, but most will be rejected later by checkEncoding().
    * <p>I don't currently detect EBCDIC, since I'm concerned that it
    * could also be a valid UTF-8 sequence; I'll have to do more checking
    * later.
    * @see #tryEncoding(byte[], byte, byte, byte, byte)
    * @see #tryEncoding(byte[], byte, byte)
    * @see #checkEncoding
    * @see #read8bitEncodingDeclaration
    */
  void detectEncoding ()
    throws java.lang.Exception
  {
    byte signature[] = new byte[4];
				// Read the first four bytes for
				// autodetection.
    is.mark(4);
    is.read(signature);
    is.reset();
				// Look for a known signature.
    if (tryEncoding(signature, (byte)0x00, (byte)0x00,
		    (byte)0x00, (byte)0x3c)) {
      // UCS-4 must begin with ""<!XML""
      // 0x00 0x00 0x00 0x3c: UCS-4, big-endian (1234)
      encoding = ENCODING_UCS_4_1234;
    } else if (tryEncoding(signature, (byte)0x3c, (byte)0x00,
			   (byte)0x00, (byte)0x00)) {
      // UCS-4 must begin with ""<!XML""
      // 0x3c 0x00 0x00 0x00: UCS-4, little-endian (4321)
      encoding = ENCODING_UCS_4_4321;
    } else if (tryEncoding(signature, (byte)0x00, (byte)0x00,
			   (byte)0x3c, (byte)0x00)) {
      // UCS-4 must begin with ""<!XML""
      // 0x00 0x00 0x3c 0x00: UCS-4, unusual (2143)
      encoding = ENCODING_UCS_4_2143;
    } else if (tryEncoding(signature, (byte)0x00, (byte)0x3c,
			   (byte)0x00, (byte)0x00)) {
      // UCS-4 must begin with ""<!XML""
      // 0x00 0x3c 0x00 0x00: UCS-4, unusual (3421)
      encoding = ENCODING_UCS_4_3412;
    } else if (tryEncoding(signature, (byte)0xfe, (byte)0xff)) {
      // UCS-2 with a byte-order marker.
      // 0xfe 0xff: UCS-2, big-endian (12)
      encoding = ENCODING_UCS_2_12;
      is.read(); is.read();
    } else if (tryEncoding(signature, (byte)0xff, (byte)0xfe)) {
      // UCS-2 with a byte-order marker.
      // 0xff 0xfe: UCS-2, little-endian (21)
      encoding = ENCODING_UCS_2_21;
      is.read(); is.read();
    } else if (tryEncoding(signature, (byte)0x00, (byte)0x3c,
			   (byte)0x00, (byte)0x3f)) {
      // UCS-2 without a BOM must begin with ""<?XML""
      // 0x00 0x3c 0x00 0x3f: UCS-2, big-endian, no byte-order mark
      encoding = ENCODING_UCS_2_12;
      error(""no byte-order mark for UCS-2 entity"", null, null);
    } else if (tryEncoding(signature, (byte)0x3c, (byte)0x00,
			   (byte)0x3f, (byte)0x00)) {
      // UCS-2 without a BOM must begin with ""<?XML""
      // 0x3c 0x00 0x3f 0x00: UCS-2, little-endian, no byte-order mark
      encoding = ENCODING_UCS_2_21;
      error(""no byte-order mark for UCS-2 entity"", null, null);
    } else if (tryEncoding(signature, (byte)0x3c, (byte)0x3f,
			   (byte)0x78, (byte)0x6d)) {
      // Some kind of 8-bit encoding with ""<?XML""
      // 0x3c 0x3f 0x78 0x6d: UTF-8 or other 8-bit markup (read ENCODING)
      encoding = ENCODING_UTF_8;
      read8bitEncodingDeclaration();
    } else {
      // Some kind of 8-bit encoding without ""<?XML""
      // (otherwise) UTF-8 without encoding/XML declaration
      encoding = ENCODING_UTF_8;
    }
  }
  /**
    * Check for a four-byte signature.
    * <p>Utility routine for detectEncoding().
    * <p>Always looks for some part of ""<?XML"" in a specific encoding.
    * @param sig The first four bytes read.
    * @param b1 The first byte of the signature
    * @param b2 The second byte of the signature
    * @param b3 The third byte of the signature
    * @param b4 The fourth byte of the signature
    * @see #detectEncoding
    */
  boolean tryEncoding (byte sig[], byte b1, byte b2, byte b3, byte b4)
  {
    return (sig[0] == b1 && sig[1] == b2 && sig[2] == b3 && sig[3] == b4);
  }
  /**
    * Check for a two-byte signature.
    * <p>Looks for a UCS-2 byte-order mark.
    * <p>Utility routine for detectEncoding().
    * @param sig The first four bytes read.
    * @param b1 The first byte of the signature
    * @param b2 The second byte of the signature
    * @see #detectEncoding
    */
  boolean tryEncoding (byte sig[], byte b1, byte b2)
  {
    return ((sig[0] == b1) && (sig[1] == b2));
  }
  /**
    * This method pushes a string back onto input.
    * <p>It is useful either as the expansion of an internal entity, 
    * or for backtracking during the parse.
    * <p>Call pushCharArray() to do the actual work.
    * @param s The string to push back onto input.
    * @see #pushCharArray
    */
  void pushString (String ename, String s) 
    throws java.lang.Exception
  {
    char ch[] = s.toCharArray();
    pushCharArray(ename, ch, 0, ch.length);
  }
  /**
    * Push a new internal input source.
    * <p>This method is useful for expanding an internal entity,
    * or for unreading a string of characters.  It creates a new
    * readBuffer containing the characters in the array, instead
    * of characters converted from an input byte stream.
    * <p>I've added a couple of optimisations: don't push zero-
    * length strings, and just push back a single character
    * for 1-character strings; this should save some time and memory.
    * @param ch The char array to push.
    * @see #pushString
    * @see #pushURL
    * @see #readBuffer
    * @see #sourceType
    * @see #pushInput
    */
  void pushCharArray (String ename, char ch[], int start, int length)
    throws java.lang.Exception
  {
				// Push the existing status
    pushInput(ename);
    sourceType = INPUT_INTERNAL;
    readBuffer = ch;
    readBufferPos = start;
    readBufferLength = length;
    readBufferOverflow = -1;
  }
  /**
    * Save the current input source onto the stack.
    * <p>This method saves all of the global variables associated with
    * the current input source, so that they can be restored when a new
    * input source has finished.  It also tests for entity recursion.
    * <p>The method saves the following global variables onto a stack
    * using a fixed-length array:
    * <ol>
    * <li>sourceType
    * <li>externalEntity
    * <li>readBuffer
    * <li>readBufferPos
    * <li>readBufferLength
    * <li>line
    * <li>encoding
    * </ol>
    * @param ename The name of the entity (if any) causing the new input.
    * @see #popInput
    * @see #sourceType
    * @see #externalEntity
    * @see #readBuffer
    * @see #readBufferPos
    * @see #readBufferLength
    * @see #line
    * @see #encoding
    */
  void pushInput (String ename)
    throws java.lang.Exception
  {
    Object input[] = new Object[12];
				// Check for entity recursion.
    if (ename != null) {
      Enumeration entities = entityStack.elements();
      while (entities.hasMoreElements()) {
	String e = (String)entities.nextElement();
	if (e == ename) {
	  error(""recursive reference to entity"", ename, null);
	}
      }
    }
    entityStack.push(ename);
				// Don't bother if there is no input.
    if (sourceType == INPUT_NONE) {
      return;
    }
				// Set up a snapshot of the current
				// input source.
    input[0] = new Integer(sourceType);
    input[1] = externalEntity;
    input[2] = readBuffer;
    input[3] = new Integer(readBufferPos);
    input[4] = new Integer(readBufferLength);
    input[5] = new Integer(line);
    input[6] = new Integer(encoding);
    input[7] = new Integer(readBufferOverflow);
    input[8] = is;
    input[9] = new Integer(currentByteCount);
    input[10] = new Integer(column);
    input[11] = reader;
				// Push it onto the stack.
    inputStack.push(input);
  }
  /**
    * Restore a previous input source.
    * <p>This method restores all of the global variables associated with
    * the current input source.
    * @exception java.io.EOFException
    *    If there are no more entries on the input stack.
    * @see #pushInput
    * @see #sourceType
    * @see #externalEntity
    * @see #readBuffer
    * @see #readBufferPos
    * @see #readBufferLength
    * @see #line
    * @see #encoding
    */
  void popInput ()
    throws java.lang.Exception
  {
    Object input[];
    switch (sourceType) {
    case INPUT_EXTERNAL:
      dataBufferFlush();
      if (handler != null && externalEntity != null) {
	handler.endExternalEntity(externalEntity.getURL().toString());
      }
      break;
    case INPUT_STREAM:
      dataBufferFlush();
      if (baseURI != null) {
	if (handler != null) {
	  handler.endExternalEntity(baseURI);
	}
      }
      break;
    case INPUT_READER:
      dataBufferFlush();
      if (baseURI != null) {
	if (handler != null) {
	  handler.endExternalEntity(baseURI);
	}
      }
      break;
    }
				// Throw an EOFException if there
				// is nothing else to pop.
    if (inputStack.isEmpty()) {
      throw new EOFException();
    } else {
      String s;
      input = (Object[])inputStack.pop();
      s = (String)entityStack.pop();
    }
    sourceType = ((Integer)input[0]).intValue();
    externalEntity = (URLConnection)input[1];
    readBuffer = (char[])input[2];
    readBufferPos = ((Integer)input[3]).intValue();
    readBufferLength = ((Integer)input[4]).intValue();
    line = ((Integer)input[5]).intValue();
    encoding = ((Integer)input[6]).intValue();
    readBufferOverflow = ((Integer)input[7]).intValue();
    is = (InputStream)input[8];
    currentByteCount = ((Integer)input[9]).intValue();
    column = ((Integer)input[10]).intValue();
    reader = (Reader)input[11];
  }
  /**
    * Return true if we can read the expected character.
    * <p>Note that the character will be removed from the input stream
    * on success, but will be put back on failure.  Do not attempt to
    * read the character again if the method succeeds.
    * @param delim The character that should appear next.  For a
    *              insensitive match, you must supply this in upper-case.
    * @return true if the character was successfully read, or false if
    *         it was not.
    * @see #tryRead(String)
    */
  boolean tryRead (char delim)
    throws java.lang.Exception
  {
    char c;
				// Read the character
    c = readCh();
				// Test for a match, and push the character
				// back if the match fails.
    if (c == delim) {
      return true;
    } else {
      unread(c);
      return false;
    }
  }
  /**
    * Return true if we can read the expected string.
    * <p>This is simply a convenience method.
    * <p>Note that the string will be removed from the input stream
    * on success, but will be put back on failure.  Do not attempt to
    * read the string again if the method succeeds.
    * <p>This method will push back a character rather than an
    * array whenever possible (probably the majority of cases).
    * <p><b>NOTE:</b> This method currently has a hard-coded limit
    * of 100 characters for the delimiter.
    * @param delim The string that should appear next.
    * @return true if the string was successfully read, or false if
    *         it was not.
    * @see #tryRead(char)
    */
  boolean tryRead (String delim)
    throws java.lang.Exception
    {
    char ch[] = delim.toCharArray();
    char c;
    // Compare the input, character-
    // by character.
    for (int i = 0; i < ch.length; i++)
      {
      c=readCh();
      if (c!=ch[i])
        {
        unread(c);
        if (i!=0)
          {unread(ch,i);}
        return false;
        }
      }
    return true;
    }
  /**
    * Return true if we can read some whitespace.
    * <p>This is simply a convenience method.
    * <p>This method will push back a character rather than an
    * array whenever possible (probably the majority of cases).
    * @return true if whitespace was found.
    */
  boolean tryWhitespace ()
    throws java.lang.Exception
  {
    char c;
    c = readCh();
    if (isWhitespace(c)) {
      skipWhitespace();
      return true;
    } else {
      unread(c);
      return false;
    }
  }
  /**
    * Read all data until we find the specified string.
    * <p>This is especially useful for scanning marked sections.
    * <p>This is a a little inefficient right now, since it calls tryRead()
    * for every character.
    * @param delim The string delimiter
    * @see #tryRead(String, boolean)
    * @see #readCh
    */
  void parseUntil (String delim)
    throws java.lang.Exception
  {
    char c;
    int startLine = line;
    try {
      while (!tryRead(delim)) {
	c = readCh();
	dataBufferAppend(c);
      }
    } catch (EOFException e) {
      error(""end of input while looking for delimiter (started on line "" +
	    startLine + ')', null, delim);
    }
  }
  /**
    * Skip all data until we find the specified string.
    * <p>This is especially useful for scanning comments.
    * <p>This is a a little inefficient right now, since it calls tryRead()
    * for every character.
    * @param delim The string delimiter
    * @see #tryRead(String, boolean)
    * @see #readCh
    */
  void skipUntil (String delim)
    throws java.lang.Exception
  {
    while (!tryRead(delim)) {
      readCh();
    }
  }
  /**
    * Read just the encoding declaration (or XML declaration) at the 
    * start of an external entity.
    * When this method is called, we know that the declaration is
    * present (or appears to be).  We also know that the entity is
    * in some sort of ASCII-derived 8-bit encoding.
    * The idea of this is to let us read what the 8-bit encoding is
    * before we've committed to converting any more of the file; the
    * XML or encoding declaration must be in 7-bit ASCII, so we're
    * safe as long as we don't go past it.
    */
  void read8bitEncodingDeclaration ()
    throws java.lang.Exception
  {
    int ch;
    readBufferPos = readBufferLength = 0;
    while (true) {
      ch = is.read();
      readBuffer[readBufferLength++] = (char)ch;
      switch (ch) {
      case (int)'>':
	return;
      case -1:
	error(""end of file before end of XML or encoding declaration."",
	      null, ""?>"");
	return;
      }
      if (readBuffer.length == readBufferLength) {
	error(""unfinished XML or encoding declaration"", null, null);
      }
    }
  }
  //////////////////////////////////////////////////////////////////////
  // Low-level I/O.
  //////////////////////////////////////////////////////////////////////
  /**
    * Read a chunk of data from an external input source.
    * <p>This is simply a front-end that fills the rawReadBuffer
    * with bytes, then calls the appropriate encoding handler.
    * @see #encoding
    * @see #rawReadBuffer
    * @see #readBuffer
    * @see #filterCR
    * @see #copyUtf8ReadBuffer
    * @see #copyIso8859_1ReadBuffer
    * @see #copyUcs_2ReadBuffer
    * @see #copyUcs_4ReadBuffer
    */
  void readDataChunk ()
    throws java.lang.Exception
    {
    int count, i, j;
    // See if we have any overflow.
    if (readBufferOverflow > -1)
      {
      readBuffer[0] = (char)readBufferOverflow;
      readBufferOverflow = -1;
      readBufferPos = 1;
      sawCR = true;
      }
    else
      {
      readBufferPos = 0;
      sawCR = false;
      }
    // Special situation -- we're taking
    // input from a character stream.
    if (sourceType == INPUT_READER)
      {
      count = reader.read(readBuffer, readBufferPos, READ_BUFFER_MAX-1);
      if (count < 0)
        {readBufferLength = -1;}
      else
        {
        readBufferLength = readBufferPos+count;
        filterCR();
        sawCR = false;
        }
      return;
      }
    // Read as many bytes as possible
    // into the read buffer.
    count = is.read(rawReadBuffer, 0, READ_BUFFER_MAX);
    // Dispatch to an encoding-specific
    // reader method to populate the
    // readBuffer.
    switch (encoding)
      {
      case ENCODING_UTF_8:
      copyUtf8ReadBuffer(count);
      break;
      case ENCODING_ISO_8859_1:
      copyIso8859_1ReadBuffer(count);
      break;
      case ENCODING_UCS_2_12:
      copyUcs2ReadBuffer(count, 8, 0);
      break;
      case ENCODING_UCS_2_21:
      copyUcs2ReadBuffer(count, 0, 8);
      break;
      case ENCODING_UCS_4_1234:
      copyUcs4ReadBuffer(count, 24, 16, 8, 0);
      break;
      case ENCODING_UCS_4_4321:
      copyUcs4ReadBuffer(count, 0, 8, 16, 24);
      break;
      case ENCODING_UCS_4_2143:
      copyUcs4ReadBuffer(count, 16, 24, 0, 8);
      break;
      case ENCODING_UCS_4_3412:
      copyUcs4ReadBuffer(count, 8, 0, 24, 16);
      break;
      }
    // Filter out all carriage returns
    // if we've seen any.
    if (sawCR)
      {
      filterCR();
      sawCR = false;
      }
    // Reset the position.
    readBufferPos = 0;
    currentByteCount += count;
    }
  /**
    * Filter carriage returns in the read buffer.
    * <p>CRLF becomes LF; CR becomes LF.
    * @see #readDataChunk
    * @see #readBuffer
    * @see #readBufferOverflow
    */
  void filterCR ()
    {
    int i, j;
    readBufferOverflow = -1;
    loop: for (i = 0, j = 0; j < readBufferLength; i++, j++)
      {
      switch (readBuffer[j])
        {
        case '\r':
        if (j == readBufferLength - 1)
          {
          readBufferOverflow = '\r';
          readBufferLength--;
          break loop;
          }
        else if (readBuffer[j+1] == '\n')
          {j++;}
        readBuffer[i] = '\n';
        break;
        case '\n':
        default:
        readBuffer[i] = readBuffer[j];
        break;
        }
      }
    readBufferLength = i;
    }
  /**
    * Convert a buffer of UTF-8-encoded bytes into UTF-16 characters.
    * <p>When readDataChunk() calls this method, the raw bytes are in 
    * rawReadBuffer, and the final characters will appear in 
    * readBuffer.
    * <p>The tricky part of this is dealing with UTF-8 multi-byte 
    * sequences, but it doesn't seem to slow things down too much.
    * @param count The number of bytes to convert.
    * @see #readDataChunk
    * @see #rawReadBuffer
    * @see #readBuffer
    * @see #getNextUtf8Byte
    */
  void copyUtf8ReadBuffer (int count)
    throws java.lang.Exception
  {
    int i = 0;
    int j = readBufferPos;
    int b1;
    boolean isSurrogate = false;
    while (i < count) {
      b1 = rawReadBuffer[i++];
      isSurrogate = false;
				// Determine whether we are dealing
				// with a one-, two-, three-, or four-
				// byte sequence.
      if ((b1 & 0x80) == 0) {
	// 1-byte sequence: 000000000xxxxxxx = 0xxxxxxx
	readBuffer[j++] = (char)b1;
      } else if ((b1 & 0xe0) == 0xc0) {
	// 2-byte sequence: 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
	readBuffer[j++] =
	  (char)(((b1 & 0x1f) << 6) |
		 getNextUtf8Byte(i++, count));
      } else if ((b1 & 0xf0) == 0xe0) {
	// 3-byte sequence: zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
	readBuffer[j++] =
	  (char)(((b1 & 0x0f) << 12) |
		 (getNextUtf8Byte(i++, count) << 6) |
		 getNextUtf8Byte(i++, count));
      } else if ((b1 & 0xf8) == 0xf0) {
	// 4-byte sequence: 11101110wwwwzzzzyy + 110111yyyyxxxxxx
	//     = 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
	// (uuuuu = wwww + 1)
	isSurrogate = true;
	int b2 = getNextUtf8Byte(i++, count);
	int b3 = getNextUtf8Byte(i++, count);
	int b4 = getNextUtf8Byte(i++, count);
	readBuffer[j++] =
	  (char)(0xd800 |
		 ((((b1 & 0x07) << 2) | ((b2 & 0x30) >> 4) - 1) << 6) |
		 ((b2 & 0x0f) << 2) |
		 ((b3 & 0x30) >> 4));
	readBuffer[j++] =
	  (char)(0xdc |
		 ((b3 & 0x0f) << 6) |
		 b4);
				// TODO: test that surrogate value is legal.
      } else {
	// Otherwise, the 8th bit may not be set in UTF-8
	encodingError(""bad start for UTF-8 multi-byte sequence"", b1, i);
      }
      if (readBuffer[j-1] == '\r') {
	sawCR = true;
      }
    }
				// How many characters have we read?
    readBufferLength = j;
  }
  /**
    * Return the next byte value in a UTF-8 sequence.
    * If it is not possible to get a byte from the current
    * entity, throw an exception.
    * @param pos The current position in the rawReadBuffer.
    * @param count The number of bytes in the rawReadBuffer
    * @return The significant six bits of a non-initial byte in
    *         a UTF-8 sequence.
    * @exception EOFException If the sequence is incomplete.
    */
  int getNextUtf8Byte (int pos, int count)
    throws java.lang.Exception
  {
    int val;
				// Take a character from the buffer
				// or from the actual input stream.
    if (pos < count) {
      val = rawReadBuffer[pos];
    } else {
      val = is.read();
      if (val == -1) {
	encodingError(""unfinished multi-byte UTF-8 sequence at EOF"", -1, pos);
      }
    }
				// Check for the correct bits at the
				// start.
    if ((val & 0xc0) != 0x80) {
      encodingError(""bad continuation of multi-byte UTF-8 sequence"", val,
		    pos + 1);
    }
				// Return the significant bits.
    return (val & 0x3f);
  }
  /**
    * Convert a buffer of ISO-8859-1-encoded bytes into UTF-16 characters.
    * <p>When readDataChunk() calls this method, the raw bytes are in 
    * rawReadBuffer, and the final characters will appear in 
    * readBuffer.
    * <p>This is a direct conversion, with no tricks.
    * @param count The number of bytes to convert.
    * @see #readDataChunk
    * @see #rawReadBuffer
    * @see #readBuffer
    */
  void copyIso8859_1ReadBuffer (int count)
  {
    int i, j;
    for (i = 0, j = readBufferPos; i < count; i++, j++) {
      readBuffer[j] = (char)(rawReadBuffer[i] & 0xff);
      if (readBuffer[j] == '\r') {
	sawCR = true;
      }
    }
    readBufferLength = j;
  }
  /**
    * Convert a buffer of UCS-2-encoded bytes into UTF-16 characters.
    * <p>When readDataChunk() calls this method, the raw bytes are in 
    * rawReadBuffer, and the final characters will appear in 
    * readBuffer.
    * @param count The number of bytes to convert.
    * @param shift1 The number of bits to shift byte 1.
    * @param shift2 The number of bits to shift byte 2
    * @see #readDataChunk
    * @see #rawReadBuffer
    * @see #readBuffer
    */
  void copyUcs2ReadBuffer (int count, int shift1, int shift2)
    throws java.lang.Exception
  {
    int j = readBufferPos;
    if (count > 0 && (count % 2) != 0) {
      encodingError(""odd number of bytes in UCS-2 encoding"", -1, count);
    }
    for (int i = 0; i < count; i+=2) {
      readBuffer[j++] =
	(char)(((rawReadBuffer[i] & 0xff) << shift1) |
	       ((rawReadBuffer[i+1] & 0xff) << shift2));
      if (readBuffer[j-1] == '\r') {
	sawCR = true;
      }
    }
    readBufferLength = j;
  }
  /**
    * Convert a buffer of UCS-4-encoded bytes into UTF-16 characters.
    * <p>When readDataChunk() calls this method, the raw bytes are in 
    * rawReadBuffer, and the final characters will appear in 
    * readBuffer.
    * <p>Java has 16-bit chars, but this routine will attempt to use
    * surrogates to encoding values between 0x00010000 and 0x000fffff.
    * @param count The number of bytes to convert.
    * @param shift1 The number of bits to shift byte 1.
    * @param shift2 The number of bits to shift byte 2
    * @param shift3 The number of bits to shift byte 2
    * @param shift4 The number of bits to shift byte 2
    * @see #readDataChunk
    * @see #rawReadBuffer
    * @see #readBuffer
    */
  void copyUcs4ReadBuffer (int count, int shift1, int shift2,
			   int shift3, int shift4)
    throws java.lang.Exception
  {
    int j = readBufferPos;
    int value;
    if (count > 0 && (count % 4) != 0) {
      encodingError(""number of bytes in UCS-4 encoding not divisible by 4"",
		    -1, count);
    }
    for (int i = 0; i < count; i+=4) {
      value = (((rawReadBuffer[i] & 0xff) << shift1) |
	       ((rawReadBuffer[i+1] & 0xff) << shift2) |
	       ((rawReadBuffer[i+2] & 0xff) << shift3) |
	       ((rawReadBuffer[i+3] & 0xff) << shift4));
      if (value < 0x0000ffff) {
	readBuffer[j++] = (char)value;
	if (value == (int)'\r') {
	  sawCR = true;
	}
      } else if (value < 0x000fffff) {
	readBuffer[j++] = (char)(0xd8 | ((value & 0x000ffc00) >> 10));
	readBuffer[j++] = (char)(0xdc | (value & 0x0003ff));
      } else {
	encodingError(""value cannot be represented in UTF-16"",
		      value, i);
      }
    }
    readBufferLength = j;
  }
  /**
    * Report a character encoding error.
    */
  void encodingError (String message, int value, int offset)
    throws java.lang.Exception
  {
    String uri;
    if (value >= 0) {
      message = message + "" (byte value: 0x"" +
	Integer.toHexString(value) + ')';
    }
    if (externalEntity != null) {
      uri = externalEntity.getURL().toString();
    } else {
      uri = baseURI;
    }
    handler.error(message, uri, -1, offset + currentByteCount);
  }
  //////////////////////////////////////////////////////////////////////
  // Local Variables.
  //////////////////////////////////////////////////////////////////////
  /**
    * Re-initialize the variables for each parse.
    */
  void initializeVariables ()
  {
				// No errors; first line
    errorCount = 0;
    line = 1;
    column = 0;
				// Set up the buffers for data and names
    dataBufferPos = 0;
    dataBuffer = new char[DATA_BUFFER_INITIAL];
    nameBufferPos = 0;
    nameBuffer = new char[NAME_BUFFER_INITIAL];
				// Set up the DTD hash tables
    elementInfo = new Hashtable();
    entityInfo = new Hashtable();
    notationInfo = new Hashtable();
				// Set up the variables for the current
				// element context.
    currentElement = null;
    currentElementContent = CONTENT_UNDECLARED;
				// Set up the input variables
    sourceType = INPUT_NONE;
    inputStack = new Stack();
    entityStack = new Stack();
    externalEntity = null;
    tagAttributePos = 0;
    tagAttributes = new String[100];
    rawReadBuffer = new byte[READ_BUFFER_MAX];
    readBufferOverflow = -1;
    context = CONTEXT_NONE;
    symbolTable = new Object[SYMBOL_TABLE_LENGTH];
  }
  /**
    * Clean up after the parse to allow some garbage collection.
    * Leave around anything that might be useful for queries.
    */
  void cleanupVariables ()
  {
    errorCount = -1;
    line = -1;
    column = -1;
    dataBuffer = null;
    nameBuffer = null;
    currentElement = null;
    currentElementContent = CONTENT_UNDECLARED;
    sourceType = INPUT_NONE;
    inputStack = null;
    externalEntity = null;
    entityStack = null;
  }
  //
  // The current XML handler interface.
  //
  XmlHandler handler;
  //
  // I/O information.
  //
  private Reader reader;	// current reader
  private InputStream is;	// current input stream
  private int line;		// current line number
  private int column;		// current column number
  private int sourceType;	// type of input source
  private Stack inputStack;	// stack of input soruces
  private URLConnection externalEntity;	// current external entity
  private int encoding;		// current character encoding.
  private int currentByteCount;	// how many bytes read from current source.
  //
  // Maintain a count of errors.
  //
  private int errorCount;
  //
  // Buffers for decoded but unparsed character input.
  //
  private final static int READ_BUFFER_MAX = 16384;
  private char readBuffer[];
  private int readBufferPos;
  private int readBufferLength;
  private int readBufferOverflow; // overflow character from last data chunk.
  //
  // Buffer for undecoded raw byte input.
  //
  private byte rawReadBuffer[];
  //
  // Buffer for parsed character data.
  //
  private static int DATA_BUFFER_INITIAL = 4096;
  private char dataBuffer[];
  private int dataBufferPos;
  //
  // Buffer for parsed names.
  //
  private static int NAME_BUFFER_INITIAL = 1024;
  private char nameBuffer[];
  private int nameBufferPos;
  //
  // Hashtables for DTD information on elements, entities, and notations.
  //
  private Hashtable elementInfo;
  private Hashtable entityInfo;
  private Hashtable notationInfo;
  //
  // Element type currently in force.
  //
  private String currentElement;
  private int currentElementContent;
  //
  // Base external identifiers for resolution.
  //
  private String basePublicId;
  private String baseURI;
  private int baseEncoding;
  private Reader baseReader;
  private InputStream baseInputStream;
  private char baseInputBuffer[];
  private int baseInputBufferStart;
  private int baseInputBufferLength;
  //
  // Stack of entity names, to help detect recursion.
  //
  private Stack entityStack;
  //
  // Are we in a context where PEs are allowed?
  //
  private int context;
  //
  // Symbol table, for internalising names.
  //
  private Object symbolTable[];
  private final static int SYMBOL_TABLE_LENGTH = 1087;
  //
  // Hash table of attributes found in current start tag.
  //
  private String tagAttributes[];
  private int tagAttributePos;
  //
  // Utility flag: have we noticed a CR while reading the last
  // data chunk?  If so, we will have to go back and normalise
  // CR/LF.
  //
  private boolean sawCR;
}
"
gnu.regexp.CharIndexed,"/*
 *  gnu/regexp/CharIndexed.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
/**
 * Defines the interface used internally so that different types of source
 * text can be accessed in the same way.  Built-in concrete classes provide
 * support for String, StringBuffer, InputStream and char[] types.
 * A class that is CharIndexed supports the notion of a cursor within a
 * block of text.  The cursor must be able to be advanced via the move()
 * method.  The charAt() method returns the character at the cursor position
 * plus a given offset.
 */
public interface CharIndexed {
    /**
     * Defines a constant (0xFFFF was somewhat arbitrarily chosen)
     * that can be returned by the charAt() function indicating that
     * the specified index is out of range.
     */
    public static final char OUT_OF_BOUNDS = '\uFFFF';
    /**
     * Returns the character at the given offset past the current cursor
     * position in the input.  The index of the current position is zero.
     * It is possible for this method to be called with a negative index.
     * This happens when using the '^' operator in multiline matching mode
     * or the '\b' or '\<' word boundary operators.  In any case, the lower
     * bound is currently fixed at -2 (for '^' with a two-character newline).
     */
    public char charAt(int index);
    /**
     * Shifts the input buffer by a given number of positions.  Returns
     * true if the new cursor position is valid.
     */
    public boolean move(int index);
    /**
     * Returns true if the most recent move() operation placed the cursor
     * position at a valid position in the input.
     */
    public boolean isValid();
}
"
gnu.regexp.CharIndexedCharArray,"/*
 *  gnu/regexp/CharIndexedCharArray.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
class CharIndexedCharArray implements CharIndexed, Serializable {
    private char[] s;
    private int anchor;
    CharIndexedCharArray(char[] str, int index) {
	s = str;
	anchor = index;
    }
    public char charAt(int index) {
	int pos = anchor + index;
	return ((pos < s.length) && (pos >= 0)) ? s[pos] : OUT_OF_BOUNDS;
    }
    public boolean isValid() {
	return (anchor < s.length);
    }
    public boolean move(int index) {
	return ((anchor += index) < s.length);
    }
}
"
gnu.regexp.CharIndexedInputStream,"/*
 *  gnu/regexp/CharIndexedReader.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.IOException;
// TODO: move(x) shouldn't rely on calling next() x times
class CharIndexedInputStream implements CharIndexed {
    private static final int BUFFER_INCREMENT = 1024;
    private static final int UNKNOWN = Integer.MAX_VALUE; // value for end
    private BufferedInputStream br;
    // so that we don't try to reset() right away
    private int index = -1;
    private int bufsize = BUFFER_INCREMENT;
    private int end = UNKNOWN;
    private char cached = OUT_OF_BOUNDS;
    // Big enough for a \r\n pair
    // lookBehind[0] = most recent
    // lookBehind[1] = second most recent
    private char[] lookBehind = new char[] { OUT_OF_BOUNDS, OUT_OF_BOUNDS }; 
    CharIndexedInputStream(InputStream str, int index) {
	if (str instanceof BufferedInputStream) br = (BufferedInputStream) str;
	else br = new BufferedInputStream(str,BUFFER_INCREMENT);
	next();
	if (index > 0) move(index);
    }
    private boolean next() {
	if (end == 1) return false;
	end--; // closer to end
	try {
	    if (index != -1) {
		br.reset();
	    }
	    int i = br.read();
	    br.mark(bufsize);
	    if (i == -1) {
		end = 1;
		cached = OUT_OF_BOUNDS;
		return false;
	    }
	    cached = (char) i;
	    index = 1;
	} catch (IOException e) { 
	    e.printStackTrace();
	    cached = OUT_OF_BOUNDS;
	    return false; 
	}
	return true;
    }
    public char charAt(int index) {
	if (index == 0) {
	    return cached;
	} else if (index >= end) {
	    return OUT_OF_BOUNDS;
	} else if (index == -1) {
	    return lookBehind[0];
	} else if (index == -2) {
	    return lookBehind[1];
	} else if (index < -2) {
	    return OUT_OF_BOUNDS;
	} else if (index >= bufsize) {
	    // Allocate more space in the buffer.
	    try {
		while (bufsize <= index) bufsize += BUFFER_INCREMENT;
		br.reset();
		br.mark(bufsize);
		br.skip(index-1);
	    } catch (IOException e) { }
	} else if (this.index != index) {
	    try {
		br.reset();
		br.skip(index-1);
	    } catch (IOException e) { }
	}
	char ch = OUT_OF_BOUNDS;
	try {
	    int i = br.read();
	    this.index = index+1; // this.index is index of next pos relative to charAt(0)
	    if (i == -1) {
		// set flag that next should fail next time?
		end = index;
		return ch;
	    }
	    ch = (char) i;
	} catch (IOException ie) { }
	return ch;
    }
    public boolean move(int index) {
	// move read position [index] clicks from 'charAt(0)'
	boolean retval = true;
	while (retval && (index-- > 0)) retval = next();
	return retval;
    }
    public boolean isValid() {
	return (cached != OUT_OF_BOUNDS);
    }
}
"
gnu.regexp.CharIndexedReader,"/*
 *  gnu/regexp/CharIndexedReader.java
 *  Copyright (C) 2001 Lee Sau Dan
 *  Based on gnu.regexp.CharIndexedInputStream by Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Reader;
import java.io.BufferedReader;
import java.io.IOException;
// TODO: move(x) shouldn't rely on calling next() x times
class CharIndexedReader implements CharIndexed {
    private static final int BUFFER_INCREMENT = 1024;
    private static final int UNKNOWN = Integer.MAX_VALUE; // value for end
    private final BufferedReader br;
    // so that we don't try to reset() right away
    private int index = -1;
    private int bufsize = BUFFER_INCREMENT;
    private int end = UNKNOWN;
    private char cached = OUT_OF_BOUNDS;
    // Big enough for a \r\n pair
    // lookBehind[0] = most recent
    // lookBehind[1] = second most recent
    private char[] lookBehind = new char[] { OUT_OF_BOUNDS, OUT_OF_BOUNDS }; 
    CharIndexedReader(Reader reader, int index) {
	if (reader instanceof BufferedReader) {
	    br = (BufferedReader) reader; 
	} else {
	    br = new BufferedReader(reader,BUFFER_INCREMENT);
	}
	next();
	if (index > 0) move(index);
    }
    private boolean next() {
	lookBehind[1] = lookBehind[0];
	lookBehind[0] = cached;
	if (end == 1) {
	    cached = OUT_OF_BOUNDS;
	    return false;
	}
	end--; // closer to end
	try {
	    if (index != -1) {
		br.reset();
	    }
	    int i = br.read();
	    br.mark(bufsize);
	    if (i == -1) {
		end = 1;
		cached = OUT_OF_BOUNDS;
		return false;
	    }
	    // convert the byte read into a char
	    cached = (char) i;
	    index = 1;
	} catch (IOException e) { 
	    e.printStackTrace();
	    cached = OUT_OF_BOUNDS;
	    return false; 
	}
	return true;
    }
    public char charAt(int index) {
	if (index == 0) {
	    return cached;
	} else if (index >= end) {
	    return OUT_OF_BOUNDS;
	} else if (index >= bufsize) {
	    // Allocate more space in the buffer.
	    try {
		while (bufsize <= index) bufsize += BUFFER_INCREMENT;
		br.reset();
		br.mark(bufsize);
		br.skip(index-1);
	    } catch (IOException e) { }
	} else if (this.index != index) {
	    try {
		br.reset();
		br.skip(index-1);
	    } catch (IOException e) { }
	} else if (index == -1) {
	    return lookBehind[0];
	} else if (index == -2) {
	    return lookBehind[1];
	} else if (index < -2) {
	    return OUT_OF_BOUNDS;
	}
	char ch = OUT_OF_BOUNDS;
	try {
	    int i = br.read();
	    this.index = index+1; // this.index is index of next pos relative to charAt(0)
	    if (i == -1) {
		// set flag that next should fail next time?
		end = index;
		return ch;
	    }
	    ch = (char) i;
	} catch (IOException ie) { }
	return ch;
    }
    public boolean move(int index) {
	// move read position [index] clicks from 'charAt(0)'
	boolean retval = true;
	while (retval && (index-- > 0)) retval = next();
	return retval;
    }
    public boolean isValid() {
	return (cached != OUT_OF_BOUNDS);
    }
}
"
gnu.regexp.CharIndexedString,"/*
 *  gnu/regexp/CharIndexedString.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
class CharIndexedString implements CharIndexed, Serializable {
    private String s;
    private int anchor;
    private int len;
    CharIndexedString(String str, int index) {
	s = str;
	len = s.length();
	anchor = index;
    }
    public char charAt(int index) {
	int pos = anchor + index;
	return ((pos < len) && (pos >= 0)) ? s.charAt(pos) : OUT_OF_BOUNDS;
    }
    public boolean isValid() {
	return (anchor < len);
    }
    public boolean move(int index) {
	return ((anchor += index) < len);
    }
}
"
gnu.regexp.CharIndexedStringBuffer,"/*
 *  gnu/regexp/CharIndexedStringBuffer.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
class CharIndexedStringBuffer implements CharIndexed, Serializable {
    private StringBuffer s;
    private int anchor;
    CharIndexedStringBuffer(StringBuffer str, int index) {
	s = str;
	anchor = index;
    }
  public char charAt(int index) {
      int pos = anchor + index;
    return ((pos < s.length()) && (pos >= 0)) ? s.charAt(pos) : OUT_OF_BOUNDS;
  }
  public boolean isValid() {
    return (anchor < s.length());
  }
  public boolean move(int index) {
    return ((anchor += index) < s.length());
  }
}
"
gnu.regexp.RE,"/*
 *  gnu/regexp/RE.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.InputStream;
import java.io.Reader;
import java.io.Serializable;
import java.util.Locale;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Vector;
class IntPair implements Serializable {
  public int first, second;
}
class CharUnit implements Serializable {
  public char ch;
  public boolean bk;
}
/**
 * RE provides the user interface for compiling and matching regular
 * expressions.
 * <P>
 * A regular expression object (class RE) is compiled by constructing it
 * from a String, StringBuffer or character array, with optional 
 * compilation flags (below)
 * and an optional syntax specification (see RESyntax; if not specified,
 * <code>RESyntax.RE_SYNTAX_PERL5</code> is used).
 * <P>
 * Various methods attempt to match input text against a compiled
 * regular expression.  These methods are:
 * <LI><code>isMatch</code>: returns true if the input text in its entirety
 * matches the regular expression pattern.
 * <LI><code>getMatch</code>: returns the first match found in the input text,
 * or null if no match is found.
 * <LI><code>getAllMatches</code>: returns an array of all non-overlapping 
 * matches found in the input text.  If no matches are found, the array is
 * zero-length.
 * <LI><code>substitute</code>: substitute the first occurence of the pattern
 * in the input text with a replacement string (which may include
 * metacharacters $0-$9, see REMatch.substituteInto).
 * <LI><code>substituteAll</code>: same as above, but repeat for each match
 * before returning.
 * <LI><code>getMatchEnumeration</code>: returns an REMatchEnumeration object
 * that allows iteration over the matches (see REMatchEnumeration for some
 * reasons why you may want to do this instead of using <code>getAllMatches</code>.
 * <P>
 *
 * These methods all have similar argument lists.  The input can be a
 * String, a character array, a StringBuffer, a Reader or an
 * InputStream of some sort.  Note that when using a Reader or
 * InputStream, the stream read position cannot be guaranteed after
 * attempting a match (this is not a bug, but a consequence of the way
 * regular expressions work).  Using an REMatchEnumeration can
 * eliminate most positioning problems.
 *
 * <P>
 *
 * The optional index argument specifies the offset from the beginning
 * of the text at which the search should start (see the descriptions
 * of some of the execution flags for how this can affect positional
 * pattern operators).  For a Reader or InputStream, this means an
 * offset from the current read position, so subsequent calls with the
 * same index argument on a Reader or an InputStream will not
 * necessarily be accessing the same position on the stream, whereas
 * repeated searches at a given index in a fixed string will return
 * consistent results.
 *
 * <P>
 * You can optionally affect the execution environment by using a
 * combination of execution flags (constants listed below).
 * 
 * <P>
 * All operations on a regular expression are performed in a
 * thread-safe manner.
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 * @version 1.1.3, 18 June 2001 
 */
public final class RE extends REToken {
  // This String will be returned by getVersion()
  private static final String s_version = ""1.1.3"";
  // The localized strings are kept in a separate file
  private static ResourceBundle messages = PropertyResourceBundle.getBundle(""gnu/regexp/MessagesBundle"", Locale.getDefault());
  // These are, respectively, the first and last tokens in our linked list
  // If there is only one token, firstToken == lastToken
  private REToken firstToken, lastToken;
  // This is the number of subexpressions in this regular expression,
  // with a minimum value of zero.  Returned by getNumSubs()
  private int numSubs;
    /** Minimum length, in characters, of any possible match. */
    private int minimumLength;
  /**
   * Compilation flag. Do  not  differentiate  case.   Subsequent
   * searches  using  this  RE will be case insensitive.
   */
  public static final int REG_ICASE = 2;
  /**
   * Compilation flag. The match-any-character operator (dot)
   * will match a newline character.  When set this overrides the syntax
   * bit RE_DOT_NEWLINE (see RESyntax for details).  This is equivalent to
   * the ""/s"" operator in Perl.
   */
  public static final int REG_DOT_NEWLINE = 4;
  /**
   * Compilation flag. Use multiline mode.  In this mode, the ^ and $
   * anchors will match based on newlines within the input. This is
   * equivalent to the ""/m"" operator in Perl.
   */
  public static final int REG_MULTILINE = 8;
  /**
   * Execution flag.
   * The match-beginning operator (^) will not match at the beginning
   * of the input string. Useful for matching on a substring when you
   * know the context of the input is such that position zero of the
   * input to the match test is not actually position zero of the text.
   * <P>
   * This example demonstrates the results of various ways of matching on
   * a substring.
   * <P>
   * <CODE>
   * String s = ""food bar fool"";<BR>
   * RE exp = new RE(""^foo."");<BR>
   * REMatch m0 = exp.getMatch(s);<BR>
   * REMatch m1 = exp.getMatch(s.substring(8));<BR>
   * REMatch m2 = exp.getMatch(s.substring(8),0,RE.REG_NOTBOL); <BR>
   * REMatch m3 = exp.getMatch(s,8);                            <BR>
   * REMatch m4 = exp.getMatch(s,8,RE.REG_ANCHORINDEX);         <BR>
   * <P>
   * // Results:<BR>
   * //  m0 = ""food""<BR>
   * //  m1 = ""fool""<BR>
   * //  m2 = null<BR>
   * //  m3 = null<BR>
   * //  m4 = ""fool""<BR>
   * </CODE>
   */
  public static final int REG_NOTBOL = 16;
  /**
   * Execution flag.
   * The match-end operator ($) does not match at the end
   * of the input string. Useful for matching on substrings.
   */
  public static final int REG_NOTEOL = 32;
  /**
   * Execution flag.
   * When a match method is invoked that starts matching at a non-zero
   * index into the input, treat the input as if it begins at the index
   * given.  The effect of this flag is that the engine does not ""see""
   * any text in the input before the given index.  This is useful so
   * that the match-beginning operator (^) matches not at position 0
   * in the input string, but at the position the search started at
   * (based on the index input given to the getMatch function).  See
   * the example under REG_NOTBOL.  It also affects the use of the \&lt;
   * and \b operators.
   */
  public static final int REG_ANCHORINDEX = 64;
  /**
   * Execution flag.
   * The substitute and substituteAll methods will not attempt to
   * interpolate occurrences of $1-$9 in the replacement text with
   * the corresponding subexpressions.  For example, you may want to
   * replace all matches of ""one dollar"" with ""$1"".
   */
  public static final int REG_NO_INTERPOLATE = 128;
  /** Returns a string representing the version of the gnu.regexp package. */
  public static final String version() {
    return s_version;
  }
  // Retrieves a message from the ResourceBundle
  static final String getLocalizedMessage(String key) {
    return messages.getString(key);
  }
  /**
   * Constructs a regular expression pattern buffer without any compilation
   * flags set, and using the default syntax (RESyntax.RE_SYNTAX_PERL5).
   *
   * @param pattern A regular expression pattern, in the form of a String,
   *   StringBuffer or char[].  Other input types will be converted to
   *   strings using the toString() method.
   * @exception REException The input pattern could not be parsed.
   * @exception NullPointerException The pattern was null.
   */
  public RE(Object pattern) throws REException {
    this(pattern,0,RESyntax.RE_SYNTAX_PERL5,0,0);
  }
  /**
   * Constructs a regular expression pattern buffer using the specified
   * compilation flags and the default syntax (RESyntax.RE_SYNTAX_PERL5).
   *
   * @param pattern A regular expression pattern, in the form of a String,
   *   StringBuffer, or char[].  Other input types will be converted to
   *   strings using the toString() method.
   * @param cflags The logical OR of any combination of the compilation flags listed above.
   * @exception REException The input pattern could not be parsed.
   * @exception NullPointerException The pattern was null.
   */
  public RE(Object pattern, int cflags) throws REException {
    this(pattern,cflags,RESyntax.RE_SYNTAX_PERL5,0,0);
  }
  /**
   * Constructs a regular expression pattern buffer using the specified
   * compilation flags and regular expression syntax.
   *
   * @param pattern A regular expression pattern, in the form of a String,
   *   StringBuffer, or char[].  Other input types will be converted to
   *   strings using the toString() method.
   * @param cflags The logical OR of any combination of the compilation flags listed above.
   * @param syntax The type of regular expression syntax to use.
   * @exception REException The input pattern could not be parsed.
   * @exception NullPointerException The pattern was null.
   */
  public RE(Object pattern, int cflags, RESyntax syntax) throws REException {
    this(pattern,cflags,syntax,0,0);
  }
  // internal constructor used for alternation
  private RE(REToken first, REToken last,int subs, int subIndex, int minLength) {
    super(subIndex);
    firstToken = first;
    lastToken = last;
    numSubs = subs;
    minimumLength = minLength;
    addToken(new RETokenEndSub(subIndex));
  }
  // Actual constructor implementation
  private RE(Object patternObj, int cflags, RESyntax syntax, int myIndex, int nextSub) throws REException {
    super(myIndex); // Subexpression index of this token.
    char[] pattern;
    if (patternObj instanceof String) {
      pattern = ((String) patternObj).toCharArray();
    } else if (patternObj instanceof char[]) {
      pattern = (char[]) patternObj;
    } else if (patternObj instanceof StringBuffer) {
      pattern = new char [((StringBuffer) patternObj).length()];
      ((StringBuffer) patternObj).getChars(0,pattern.length,pattern,0);
    } else {
	pattern = patternObj.toString().toCharArray();
    }
    int pLength = pattern.length;
    numSubs = 0; // Number of subexpressions in this token.
    Vector branches = null;
    // linked list of tokens (sort of -- some closed loops can exist)
    firstToken = lastToken = null;
    // Precalculate these so we don't pay for the math every time we
    // need to access them.
    boolean insens = ((cflags & REG_ICASE) > 0);
    // Parse pattern into tokens.  Does anyone know if it's more efficient
    // to use char[] than a String.charAt()?  I'm assuming so.
    // index tracks the position in the char array
    int index = 0;
    // this will be the current parse character (pattern[index])
    CharUnit unit = new CharUnit();
    // This is used for {x,y} calculations
    IntPair minMax = new IntPair();
    // Buffer a token so we can create a TokenRepeated, etc.
    REToken currentToken = null;
    char ch;
    while (index < pLength) {
      // read the next character unit (including backslash escapes)
      index = getCharUnit(pattern,index,unit);
      // ALTERNATION OPERATOR
      //  \| or | (if RE_NO_BK_VBAR) or newline (if RE_NEWLINE_ALT)
      //  not available if RE_LIMITED_OPS is set
      // TODO: the '\n' literal here should be a test against REToken.newline,
      // which unfortunately may be more than a single character.
      if ( ( (unit.ch == '|' && (syntax.get(RESyntax.RE_NO_BK_VBAR) ^ unit.bk))
	     || (syntax.get(RESyntax.RE_NEWLINE_ALT) && (unit.ch == '\n') && !unit.bk) )
	   && !syntax.get(RESyntax.RE_LIMITED_OPS)) {
	// make everything up to here be a branch. create vector if nec.
	addToken(currentToken);
	RE theBranch = new RE(firstToken, lastToken, numSubs, subIndex, minimumLength);
	if (branches == null) {
	    branches = new Vector();
	    minimumLength = 0;
	}
	branches.addElement(theBranch);
	firstToken = lastToken = currentToken = null;
      }
      // INTERVAL OPERATOR:
      //  {x} | {x,} | {x,y}  (RE_INTERVALS && RE_NO_BK_BRACES)
      //  \{x\} | \{x,\} | \{x,y\} (RE_INTERVALS && !RE_NO_BK_BRACES)
      //
      // OPEN QUESTION: 
      //  what is proper interpretation of '{' at start of string?
      else if ((unit.ch == '{') && syntax.get(RESyntax.RE_INTERVALS) && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk)) {
	int newIndex = getMinMax(pattern,index,minMax,syntax);
        if (newIndex > index) {
          if (minMax.first > minMax.second)
            throw new REException(getLocalizedMessage(""interval.order""),REException.REG_BADRPT,newIndex);
          if (currentToken == null)
            throw new REException(getLocalizedMessage(""repeat.no.token""),REException.REG_BADRPT,newIndex);
          if (currentToken instanceof RETokenRepeated) 
            throw new REException(getLocalizedMessage(""repeat.chained""),REException.REG_BADRPT,newIndex);
          if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
            throw new REException(getLocalizedMessage(""repeat.assertion""),REException.REG_BADRPT,newIndex);
          if ((currentToken.getMinimumLength() == 0) && (minMax.second == Integer.MAX_VALUE))
            throw new REException(getLocalizedMessage(""repeat.empty.token""),REException.REG_BADRPT,newIndex);
          index = newIndex;
          currentToken = setRepeated(currentToken,minMax.first,minMax.second,index); 
        }
        else {
          addToken(currentToken);
          currentToken = new RETokenChar(subIndex,unit.ch,insens);
        } 
      }
      // LIST OPERATOR:
      //  [...] | [^...]
      else if ((unit.ch == '[') && !unit.bk) {
	Vector options = new Vector();
	boolean negative = false;
	char lastChar = 0;
	if (index == pLength) throw new REException(getLocalizedMessage(""unmatched.bracket""),REException.REG_EBRACK,index);
	// Check for initial caret, negation
	if ((ch = pattern[index]) == '^') {
	  negative = true;
	  if (++index == pLength) throw new REException(getLocalizedMessage(""class.no.end""),REException.REG_EBRACK,index);
	  ch = pattern[index];
	}
	// Check for leading right bracket literal
	if (ch == ']') {
	  lastChar = ch;
	  if (++index == pLength) throw new REException(getLocalizedMessage(""class.no.end""),REException.REG_EBRACK,index);
	}
	while ((ch = pattern[index++]) != ']') {
	  if ((ch == '-') && (lastChar != 0)) {
	    if (index == pLength) throw new REException(getLocalizedMessage(""class.no.end""),REException.REG_EBRACK,index);
	    if ((ch = pattern[index]) == ']') {
	      options.addElement(new RETokenChar(subIndex,lastChar,insens));
	      lastChar = '-';
	    } else {
	      options.addElement(new RETokenRange(subIndex,lastChar,ch,insens));
	      lastChar = 0;
	      index++;
	    }
          } else if ((ch == '\\') && syntax.get(RESyntax.RE_BACKSLASH_ESCAPE_IN_LISTS)) {
            if (index == pLength) throw new REException(getLocalizedMessage(""class.no.end""),REException.REG_EBRACK,index);
	    int posixID = -1;
	    boolean negate = false;
            char asciiEsc = 0;
	    if ((""dswDSW"".indexOf(pattern[index]) != -1) && syntax.get(RESyntax.RE_CHAR_CLASS_ESC_IN_LISTS)) {
	      switch (pattern[index]) {
	      case 'D':
		negate = true;
	      case 'd':
		posixID = RETokenPOSIX.DIGIT;
		break;
	      case 'S':
		negate = true;
	      case 's':
		posixID = RETokenPOSIX.SPACE;
		break;
	      case 'W':
		negate = true;
	      case 'w':
		posixID = RETokenPOSIX.ALNUM;
		break;
	      }
	    }
            else if (""nrt"".indexOf(pattern[index]) != -1) {
              switch (pattern[index]) {
                case 'n':
                  asciiEsc = '\n';
                  break;
                case 't':
                  asciiEsc = '\t';
                  break;
                case 'r':
                  asciiEsc = '\r';
                  break;
              }
            }
	    if (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));
	    if (posixID != -1) {
	      options.addElement(new RETokenPOSIX(subIndex,posixID,insens,negate));
	    } else if (asciiEsc != 0) {
	      lastChar = asciiEsc;
	    } else {
	      lastChar = pattern[index];
	    }
	    ++index;
	  } else if ((ch == '[') && (syntax.get(RESyntax.RE_CHAR_CLASSES)) && (index < pLength) && (pattern[index] == ':')) {
	    StringBuffer posixSet = new StringBuffer();
	    index = getPosixSet(pattern,index+1,posixSet);
	    int posixId = RETokenPOSIX.intValue(posixSet.toString());
	    if (posixId != -1)
	      options.addElement(new RETokenPOSIX(subIndex,posixId,insens,false));
	  } else {
	    if (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));
	    lastChar = ch;
	  }
	  if (index == pLength) throw new REException(getLocalizedMessage(""class.no.end""),REException.REG_EBRACK,index);
	} // while in list
	// Out of list, index is one past ']'
	if (lastChar != 0) options.addElement(new RETokenChar(subIndex,lastChar,insens));
	// Create a new RETokenOneOf
	addToken(currentToken);
	options.trimToSize();
	currentToken = new RETokenOneOf(subIndex,options,negative);
      }
      // SUBEXPRESSIONS
      //  (...) | \(...\) depending on RE_NO_BK_PARENS
      else if ((unit.ch == '(') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk)) {
	boolean pure = false;
	boolean comment = false;
        boolean lookAhead = false;
        boolean negativelh = false;
	if ((index+1 < pLength) && (pattern[index] == '?')) {
	  switch (pattern[index+1]) {
          case '!':
            if (syntax.get(RESyntax.RE_LOOKAHEAD)) {
              pure = true;
              negativelh = true;
              lookAhead = true;
              index += 2;
            }
            break;
          case '=':
            if (syntax.get(RESyntax.RE_LOOKAHEAD)) {
              pure = true;
              lookAhead = true;
              index += 2;
            }
            break;
	  case ':':
	    if (syntax.get(RESyntax.RE_PURE_GROUPING)) {
	      pure = true;
	      index += 2;
	    }
	    break;
	  case '#':
	    if (syntax.get(RESyntax.RE_COMMENTS)) {
	      comment = true;
	    }
	    break;
          default:
            throw new REException(getLocalizedMessage(""repeat.no.token""), REException.REG_BADRPT, index);
	  }
	}
	if (index >= pLength) {
	    throw new REException(getLocalizedMessage(""unmatched.paren""), REException.REG_ESUBREG,index);
	}
	// find end of subexpression
	int endIndex = index;
	int nextIndex = index;
	int nested = 0;
	while ( ((nextIndex = getCharUnit(pattern,endIndex,unit)) > 0)
		&& !(nested == 0 && (unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk)) )
	  if ((endIndex = nextIndex) >= pLength)
	    throw new REException(getLocalizedMessage(""subexpr.no.end""),REException.REG_ESUBREG,nextIndex);
	  else if (unit.ch == '(' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))
	    nested++;
	  else if (unit.ch == ')' && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))
	    nested--;
	// endIndex is now position at a ')','\)' 
	// nextIndex is end of string or position after ')' or '\)'
	if (comment) index = nextIndex;
	else { // not a comment
	  // create RE subexpression as token.
	  addToken(currentToken);
	  if (!pure) {
	    numSubs++;
	  }
          if (lookAhead)
            currentToken = new RETokenLookAhead(String.valueOf(pattern,index,endIndex-index).toCharArray(),cflags,syntax,negativelh);
          else {
            int useIndex = pure ? 0 : nextSub + numSubs;
            currentToken = new RE(String.valueOf(pattern,index,endIndex-index).toCharArray(),cflags,syntax,useIndex,nextSub + numSubs);
            numSubs += ((RE) currentToken).getNumSubs();
          }
	  index = nextIndex;
	} // not a comment
      } // subexpression
      // UNMATCHED RIGHT PAREN
      // ) or \) throw exception if
      // !syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD)
      else if (!syntax.get(RESyntax.RE_UNMATCHED_RIGHT_PAREN_ORD) && ((unit.ch == ')') && (syntax.get(RESyntax.RE_NO_BK_PARENS) ^ unit.bk))) {
	throw new REException(getLocalizedMessage(""unmatched.paren""),REException.REG_EPAREN,index);
      }
      // START OF LINE OPERATOR
      //  ^
      else if ((unit.ch == '^') && !unit.bk) {
	addToken(currentToken);
	currentToken = null;
	addToken(new RETokenStart(subIndex,((cflags & REG_MULTILINE) > 0) ? syntax.getLineSeparator() : null));
      }
      // END OF LINE OPERATOR
      //  $
      else if ((unit.ch == '$') && !unit.bk) {
	addToken(currentToken);
	currentToken = null;
	addToken(new RETokenEnd(subIndex,((cflags & REG_MULTILINE) > 0) ? syntax.getLineSeparator() : null));
      }
      // MATCH-ANY-CHARACTER OPERATOR (except possibly newline and null)
      //  .
      else if ((unit.ch == '.') && !unit.bk) {
	addToken(currentToken);
	currentToken = new RETokenAny(subIndex,syntax.get(RESyntax.RE_DOT_NEWLINE) || ((cflags & REG_DOT_NEWLINE) > 0),syntax.get(RESyntax.RE_DOT_NOT_NULL));
      }
      // ZERO-OR-MORE REPEAT OPERATOR
      //  *
      else if ((unit.ch == '*') && !unit.bk) {
	if (currentToken == null)
          throw new REException(getLocalizedMessage(""repeat.no.token""),REException.REG_BADRPT,index);
	if (currentToken instanceof RETokenRepeated)
          throw new REException(getLocalizedMessage(""repeat.chained""),REException.REG_BADRPT,index);
	if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
	  throw new REException(getLocalizedMessage(""repeat.assertion""),REException.REG_BADRPT,index);
	if (currentToken.getMinimumLength() == 0)
	  throw new REException(getLocalizedMessage(""repeat.empty.token""),REException.REG_BADRPT,index);
	currentToken = setRepeated(currentToken,0,Integer.MAX_VALUE,index);
      }
      // ONE-OR-MORE REPEAT OPERATOR
      //  + | \+ depending on RE_BK_PLUS_QM
      //  not available if RE_LIMITED_OPS is set
      else if ((unit.ch == '+') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ unit.bk)) {
	if (currentToken == null)
          throw new REException(getLocalizedMessage(""repeat.no.token""),REException.REG_BADRPT,index);
	if (currentToken instanceof RETokenRepeated)
          throw new REException(getLocalizedMessage(""repeat.chained""),REException.REG_BADRPT,index);
	if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
	  throw new REException(getLocalizedMessage(""repeat.assertion""),REException.REG_BADRPT,index);
	if (currentToken.getMinimumLength() == 0)
	  throw new REException(getLocalizedMessage(""repeat.empty.token""),REException.REG_BADRPT,index);
	currentToken = setRepeated(currentToken,1,Integer.MAX_VALUE,index);
      }
      // ZERO-OR-ONE REPEAT OPERATOR / STINGY MATCHING OPERATOR
      //  ? | \? depending on RE_BK_PLUS_QM
      //  not available if RE_LIMITED_OPS is set
      //  stingy matching if RE_STINGY_OPS is set and it follows a quantifier
      else if ((unit.ch == '?') && !syntax.get(RESyntax.RE_LIMITED_OPS) && (!syntax.get(RESyntax.RE_BK_PLUS_QM) ^ unit.bk)) {
	if (currentToken == null) throw new REException(getLocalizedMessage(""repeat.no.token""),REException.REG_BADRPT,index);
	// Check for stingy matching on RETokenRepeated
	if (currentToken instanceof RETokenRepeated) {
          if (syntax.get(RESyntax.RE_STINGY_OPS) && !((RETokenRepeated)currentToken).isStingy())
            ((RETokenRepeated)currentToken).makeStingy();
          else
            throw new REException(getLocalizedMessage(""repeat.chained""),REException.REG_BADRPT,index);
        }
        else if (currentToken instanceof RETokenWordBoundary || currentToken instanceof RETokenWordBoundary)
          throw new REException(getLocalizedMessage(""repeat.assertion""),REException.REG_BADRPT,index);
	else
	  currentToken = setRepeated(currentToken,0,1,index);
      }
      // BACKREFERENCE OPERATOR
      //  \1 \2 ... \9
      // not available if RE_NO_BK_REFS is set
      else if (unit.bk && Character.isDigit(unit.ch) && !syntax.get(RESyntax.RE_NO_BK_REFS)) {
	addToken(currentToken);
	currentToken = new RETokenBackRef(subIndex,Character.digit(unit.ch,10),insens);
      }
      // START OF STRING OPERATOR
      //  \A if RE_STRING_ANCHORS is set
      else if (unit.bk && (unit.ch == 'A') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
	addToken(currentToken);
	currentToken = new RETokenStart(subIndex,null);
      }
      // WORD BREAK OPERATOR
      //  \b if ????
      else if (unit.bk && (unit.ch == 'b') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
	  addToken(currentToken);
	  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN | RETokenWordBoundary.END, false);
      } 
      // WORD BEGIN OPERATOR 
      //  \< if ????
      else if (unit.bk && (unit.ch == '<')) {
	  addToken(currentToken);
	  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN, false);
      } 
      // WORD END OPERATOR 
      //  \> if ????
      else if (unit.bk && (unit.ch == '>')) {
	  addToken(currentToken);
	  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.END, false);
      } 
      // NON-WORD BREAK OPERATOR
      // \B if ????
      else if (unit.bk && (unit.ch == 'B') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
	  addToken(currentToken);
	  currentToken = new RETokenWordBoundary(subIndex, RETokenWordBoundary.BEGIN | RETokenWordBoundary.END, true);
      } 
      // DIGIT OPERATOR
      //  \d if RE_CHAR_CLASS_ESCAPES is set
      else if (unit.bk && (unit.ch == 'd') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	addToken(currentToken);
	currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.DIGIT,insens,false);
      }
      // NON-DIGIT OPERATOR
      //  \D
	else if (unit.bk && (unit.ch == 'D') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	  addToken(currentToken);
	  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.DIGIT,insens,true);
	}
	// NEWLINE ESCAPE
        //  \n
	else if (unit.bk && (unit.ch == 'n')) {
	  addToken(currentToken);
	  currentToken = new RETokenChar(subIndex,'\n',false);
	}
	// RETURN ESCAPE
        //  \r
	else if (unit.bk && (unit.ch == 'r')) {
	  addToken(currentToken);
	  currentToken = new RETokenChar(subIndex,'\r',false);
	}
	// WHITESPACE OPERATOR
        //  \s if RE_CHAR_CLASS_ESCAPES is set
	else if (unit.bk && (unit.ch == 's') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	  addToken(currentToken);
	  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.SPACE,insens,false);
	}
	// NON-WHITESPACE OPERATOR
        //  \S
	else if (unit.bk && (unit.ch == 'S') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	  addToken(currentToken);
	  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.SPACE,insens,true);
	}
	// TAB ESCAPE
        //  \t
	else if (unit.bk && (unit.ch == 't')) {
	  addToken(currentToken);
	  currentToken = new RETokenChar(subIndex,'\t',false);
	}
	// ALPHANUMERIC OPERATOR
        //  \w
	else if (unit.bk && (unit.ch == 'w') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	  addToken(currentToken);
	  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.ALNUM,insens,false);
	}
	// NON-ALPHANUMERIC OPERATOR
        //  \W
	else if (unit.bk && (unit.ch == 'W') && syntax.get(RESyntax.RE_CHAR_CLASS_ESCAPES)) {
	  addToken(currentToken);
	  currentToken = new RETokenPOSIX(subIndex,RETokenPOSIX.ALNUM,insens,true);
	}
	// END OF STRING OPERATOR
        //  \Z
	else if (unit.bk && (unit.ch == 'Z') && syntax.get(RESyntax.RE_STRING_ANCHORS)) {
	  addToken(currentToken);
	  currentToken = new RETokenEnd(subIndex,null);
	}
	// NON-SPECIAL CHARACTER (or escape to make literal)
        //  c | \* for example
	else {  // not a special character
	  addToken(currentToken);
	  currentToken = new RETokenChar(subIndex,unit.ch,insens);
	} 
      } // end while
    // Add final buffered token and an EndSub marker
    addToken(currentToken);
    if (branches != null) {
	branches.addElement(new RE(firstToken,lastToken,numSubs,subIndex,minimumLength));
	branches.trimToSize(); // compact the Vector
	minimumLength = 0;
	firstToken = lastToken = null;
	addToken(new RETokenOneOf(subIndex,branches,false));
    } 
    else addToken(new RETokenEndSub(subIndex));
  }
  private static int getCharUnit(char[] input, int index, CharUnit unit) throws REException {
    unit.ch = input[index++];
    if (unit.bk = (unit.ch == '\\'))
      if (index < input.length)
	unit.ch = input[index++];
      else throw new REException(getLocalizedMessage(""ends.with.backslash""),REException.REG_ESCAPE,index);
    return index;
  }
  /**
   * Checks if the input in its entirety is an exact match of
   * this regular expression.
   *
   * @param input The input text.
   */
  public boolean isMatch(Object input) {
    return isMatch(input,0,0);
  }
  /**
   * Checks if the input string, starting from index, is an exact match of
   * this regular expression.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   */
  public boolean isMatch(Object input,int index) {
    return isMatch(input,index,0);
  }
  /**
   * Checks if the input, starting from index and using the specified
   * execution flags, is an exact match of this regular expression.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   */
  public boolean isMatch(Object input,int index,int eflags) {
    return isMatchImpl(makeCharIndexed(input,index),index,eflags);
  }
  private boolean isMatchImpl(CharIndexed input, int index, int eflags) {
    if (firstToken == null)  // Trivial case
      return (input.charAt(0) == CharIndexed.OUT_OF_BOUNDS);
    REMatch m = new REMatch(numSubs, index, eflags);
    if (firstToken.match(input, m)) {
	while (m != null) {
	    if (input.charAt(m.index) == CharIndexed.OUT_OF_BOUNDS) {
		return true;
	    }
	    m = m.next;
	}
    }
    return false;
  }
  /**
   * Returns the maximum number of subexpressions in this regular expression.
   * If the expression contains branches, the value returned will be the
   * maximum subexpressions in any of the branches.
   */
  public int getNumSubs() {
    return numSubs;
  }
  // Overrides REToken.setUncle
  void setUncle(REToken uncle) {
      if (lastToken != null) {
	  lastToken.setUncle(uncle);
      } else super.setUncle(uncle); // to deal with empty subexpressions
  }
  // Overrides REToken.chain
  boolean chain(REToken next) {
    super.chain(next);
    setUncle(next);
    return true;
  }
  /**
   * Returns the minimum number of characters that could possibly
   * constitute a match of this regular expression.
   */
  public int getMinimumLength() {
      return minimumLength;
  }
  /**
   * Returns an array of all matches found in the input.
   *
   * If the regular expression allows the empty string to match, it will
   * substitute matches at all positions except the end of the input.
   *
   * @param input The input text.
   * @return a non-null (but possibly zero-length) array of matches
   */
  public REMatch[] getAllMatches(Object input) {
    return getAllMatches(input,0,0);
  }
  /**
   * Returns an array of all matches found in the input,
   * beginning at the specified index position.
   *
   * If the regular expression allows the empty string to match, it will
   * substitute matches at all positions except the end of the input.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @return a non-null (but possibly zero-length) array of matches
   */
  public REMatch[] getAllMatches(Object input, int index) {
    return getAllMatches(input,index,0);
  }
  /**
   * Returns an array of all matches found in the input string,
   * beginning at the specified index position and using the specified
   * execution flags.
   *
   * If the regular expression allows the empty string to match, it will
   * substitute matches at all positions except the end of the input.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   * @return a non-null (but possibly zero-length) array of matches
   */
  public REMatch[] getAllMatches(Object input, int index, int eflags) {
    return getAllMatchesImpl(makeCharIndexed(input,index),index,eflags);
  }
  // this has been changed since 1.03 to be non-overlapping matches
  private REMatch[] getAllMatchesImpl(CharIndexed input, int index, int eflags) {
    Vector all = new Vector();
    REMatch m = null;
    while ((m = getMatchImpl(input,index,eflags,null)) != null) {
      all.addElement(m);
      index = m.getEndIndex();
      if (m.end[0] == 0) {   // handle pathological case of zero-length match
	index++;
	input.move(1);
      } else {
	input.move(m.end[0]);
      }
      if (!input.isValid()) break;
    }
    REMatch[] mset = new REMatch[all.size()];
    all.copyInto(mset);
    return mset;
  }
    /* Implements abstract method REToken.match() */
    boolean match(CharIndexed input, REMatch mymatch) { 
	if (firstToken == null) return next(input, mymatch);
	// Note the start of this subexpression
	mymatch.start[subIndex] = mymatch.index;
	return firstToken.match(input, mymatch);
    }
  /**
   * Returns the first match found in the input.  If no match is found,
   * null is returned.
   *
   * @param input The input text.
   */
  public REMatch getMatch(Object input) {
    return getMatch(input,0,0);
  }
  /**
   * Returns the first match found in the input, beginning
   * the search at the specified index.  If no match is found,
   * returns null.
   *
   * @param input The input text.
   * @param index The offset within the text to begin looking for a match.
   */
  public REMatch getMatch(Object input, int index) {
    return getMatch(input,index,0);
  }
  /**
   * Returns the first match found in the input, beginning
   * the search at the specified index, and using the specified
   * execution flags.  If no match is found, returns null.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   */
  public REMatch getMatch(Object input, int index, int eflags) {
    return getMatch(input,index,eflags,null);
  }
  /**
   * Returns the first match found in the input, beginning
   * the search at the specified index, and using the specified
   * execution flags.  If no match is found, returns null.  If a StringBuffer
   * is provided and is non-null, the contents of the input text from the index to the
   * beginning of the match (or to the end of the input, if there is no match)
   * are appended to the StringBuffer.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   * @param buffer The StringBuffer to save pre-match text in.
   */
  public REMatch getMatch(Object input, int index, int eflags, StringBuffer buffer) {
    return getMatchImpl(makeCharIndexed(input,index),index,eflags,buffer);
  }
  REMatch getMatchImpl(CharIndexed input, int index, int eflags, StringBuffer buffer) {
      // Create a new REMatch to hold results
      REMatch mymatch = new REMatch(numSubs, index, eflags);
      do {
	  // Optimization: check if index + minimumLength > length
	  if (minimumLength == 0 || input.charAt(minimumLength-1) != CharIndexed.OUT_OF_BOUNDS) {
	      if (match(input, mymatch)) {
		  // Find longest match of them all to observe leftmost longest
		  REMatch longest = mymatch;
		  while ((mymatch = mymatch.next) != null) {
		      if (mymatch.index > longest.index) {
			  longest = mymatch;
		      }
		  }
		  longest.end[0] = longest.index;
		  longest.finish(input);
		  return longest;
	      }
	  }
	  mymatch.clear(++index);
	  // Append character to buffer if needed
	  if (buffer != null && input.charAt(0) != CharIndexed.OUT_OF_BOUNDS) {
	      buffer.append(input.charAt(0));
	  }
      } while (input.move(1));
      return null;
  }
  /**
   * Returns an REMatchEnumeration that can be used to iterate over the
   * matches found in the input text.
   *
   * @param input The input text.
   */
  public REMatchEnumeration getMatchEnumeration(Object input) {
    return getMatchEnumeration(input,0,0);
  }
  /**
   * Returns an REMatchEnumeration that can be used to iterate over the
   * matches found in the input text.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   */
  public REMatchEnumeration getMatchEnumeration(Object input, int index) {
    return getMatchEnumeration(input,index,0);
  }
  /**
   * Returns an REMatchEnumeration that can be used to iterate over the
   * matches found in the input text.
   *
   * @param input The input text.
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   */
  public REMatchEnumeration getMatchEnumeration(Object input, int index, int eflags) {
    return new REMatchEnumeration(this,makeCharIndexed(input,index),index,eflags);
  }
  /**
   * Substitutes the replacement text for the first match found in the input.
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @see REMatch#substituteInto
   */
  public String substitute(Object input,String replace) {
    return substitute(input,replace,0,0);
  }
  /**
   * Substitutes the replacement text for the first match found in the input
   * beginning at the specified index position.
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @param index The offset index at which the search should be begin.
   * @see REMatch#substituteInto
   */
  public String substitute(Object input,String replace,int index) {
    return substitute(input,replace,index,0);
  }
  /**
   * Substitutes the replacement text for the first match found in the input
   * string, beginning at the specified index position and using the
   * specified execution flags.
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   * @see REMatch#substituteInto
   */
  public String substitute(Object input,String replace,int index,int eflags) {
    return substituteImpl(makeCharIndexed(input,index),replace,index,eflags);
  }
  private String substituteImpl(CharIndexed input,String replace,int index,int eflags) {
    StringBuffer buffer = new StringBuffer();
    REMatch m = getMatchImpl(input,index,eflags,buffer);
    if (m==null) return buffer.toString();
    buffer.append( ((eflags & REG_NO_INTERPOLATE) > 0) ?
		   replace : m.substituteInto(replace) );
    if (input.move(m.end[0])) {
      do {
	buffer.append(input.charAt(0));
      } while (input.move(1));
    }
    return buffer.toString();
  }
  /**
   * Substitutes the replacement text for each non-overlapping match found 
   * in the input text.
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @see REMatch#substituteInto
   */
  public String substituteAll(Object input,String replace) {
    return substituteAll(input,replace,0,0);
  }
  /**
   * Substitutes the replacement text for each non-overlapping match found 
   * in the input text, starting at the specified index.
   *
   * If the regular expression allows the empty string to match, it will
   * substitute matches at all positions except the end of the input.
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @param index The offset index at which the search should be begin.
   * @see REMatch#substituteInto
   */
  public String substituteAll(Object input,String replace,int index) {
    return substituteAll(input,replace,index,0);
  }
  /**
   * Substitutes the replacement text for each non-overlapping match found 
   * in the input text, starting at the specified index and using the
   * specified execution flags.
   *
   * @param input The input text.
   * @param replace The replacement text, which may contain $x metacharacters (see REMatch.substituteInto).
   * @param index The offset index at which the search should be begin.
   * @param eflags The logical OR of any execution flags above.
   * @see REMatch#substituteInto
   */
  public String substituteAll(Object input,String replace,int index,int eflags) {
    return substituteAllImpl(makeCharIndexed(input,index),replace,index,eflags);
  }
  private String substituteAllImpl(CharIndexed input,String replace,int index,int eflags) {
    StringBuffer buffer = new StringBuffer();
    REMatch m;
    while ((m = getMatchImpl(input,index,eflags,buffer)) != null) {
	buffer.append( ((eflags & REG_NO_INTERPOLATE) > 0) ?
		       replace : m.substituteInto(replace) );
      index = m.getEndIndex();
      if (m.end[0] == 0) {
	char ch = input.charAt(0);
	if (ch != CharIndexed.OUT_OF_BOUNDS) 
	    buffer.append(ch);
	input.move(1);
      } else {
	  input.move(m.end[0]);
      }
      if (!input.isValid()) break;
    }
    return buffer.toString();
  }
  /* Helper function for constructor */
  private void addToken(REToken next) {
    if (next == null) return;
    minimumLength += next.getMinimumLength();
    if (firstToken == null) {
	lastToken = firstToken = next;
    } else {
      // if chain returns false, it ""rejected"" the token due to
      // an optimization, and next was combined with lastToken
      if (lastToken.chain(next)) {
	  lastToken = next;
      }
    }
  }
  private static REToken setRepeated(REToken current, int min, int max, int index) throws REException {
    if (current == null) throw new REException(getLocalizedMessage(""repeat.no.token""),REException.REG_BADRPT,index);
    return new RETokenRepeated(current.subIndex,current,min,max);
  }
  private static int getPosixSet(char[] pattern,int index,StringBuffer buf) {
    // Precondition: pattern[index-1] == ':'
    // we will return pos of closing ']'.
    int i;
    for (i=index; i<(pattern.length-1); i++) {
      if ((pattern[i] == ':') && (pattern[i+1] == ']'))
	return i+2;
      buf.append(pattern[i]);
    }
    return index; // didn't match up
  }
  private int getMinMax(char[] input,int index,IntPair minMax,RESyntax syntax) throws REException {
    // Precondition: input[index-1] == '{', minMax != null
    boolean mustMatch = !syntax.get(RESyntax.RE_NO_BK_BRACES);
    int startIndex = index;
    if (index == input.length) {
      if (mustMatch)
        throw new REException(getLocalizedMessage(""unmatched.brace""),REException.REG_EBRACE,index);
      else
        return startIndex;
    }
    int min,max=0;
    CharUnit unit = new CharUnit();
    StringBuffer buf = new StringBuffer();
    // Read string of digits
    do {
      index = getCharUnit(input,index,unit);
      if (Character.isDigit(unit.ch))
        buf.append(unit.ch);
    } while ((index != input.length) && Character.isDigit(unit.ch));
    // Check for {} tomfoolery
    if (buf.length() == 0) {
      if (mustMatch)
        throw new REException(getLocalizedMessage(""interval.error""),REException.REG_EBRACE,index);
      else
        return startIndex;
    }
    min = Integer.parseInt(buf.toString());
    if ((unit.ch == '}') && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk))
      max = min;
    else if (index == input.length)
      if (mustMatch)
        throw new REException(getLocalizedMessage(""interval.no.end""),REException.REG_EBRACE,index);
      else
        return startIndex;
    else if ((unit.ch == ',') && !unit.bk) {
      buf = new StringBuffer();
      // Read string of digits
      while (((index = getCharUnit(input,index,unit)) != input.length) && Character.isDigit(unit.ch))
	buf.append(unit.ch);
      if (!((unit.ch == '}') && (syntax.get(RESyntax.RE_NO_BK_BRACES) ^ unit.bk)))
        if (mustMatch)
          throw new REException(getLocalizedMessage(""interval.error""),REException.REG_EBRACE,index);
        else
          return startIndex;
      // This is the case of {x,}
      if (buf.length() == 0) max = Integer.MAX_VALUE;
      else max = Integer.parseInt(buf.toString());
    } else
      if (mustMatch)
        throw new REException(getLocalizedMessage(""interval.error""),REException.REG_EBRACE,index);
      else
        return startIndex;
    // We know min and max now, and they are valid.
    minMax.first = min;
    minMax.second = max;
    // return the index following the '}'
    return index;
  }
   /**
    * Return a human readable form of the compiled regular expression,
    * useful for debugging.
    */
   public String toString() {
     StringBuffer sb = new StringBuffer();
     dump(sb);
     return sb.toString();
   }
  void dump(StringBuffer os) {
    os.append('(');
    if (subIndex == 0)
      os.append(""?:"");
    if (firstToken != null)
      firstToken.dumpAll(os);
    os.append(')');
  }
  // Cast input appropriately or throw exception
  private static CharIndexed makeCharIndexed(Object input, int index) {
      // We could let a String fall through to final input, but since
      // it's the most likely input type, we check it first.
    if (input instanceof String)
      return new CharIndexedString((String) input,index);
    else if (input instanceof char[])
      return new CharIndexedCharArray((char[]) input,index);
    else if (input instanceof StringBuffer)
      return new CharIndexedStringBuffer((StringBuffer) input,index);
    else if (input instanceof InputStream)
      return new CharIndexedInputStream((InputStream) input,index);
    else if (input instanceof Reader)
	return new CharIndexedReader((Reader) input, index);
    else if (input instanceof CharIndexed)
	return (CharIndexed) input;
    else 
	return new CharIndexedString(input.toString(), index);
  }
}
"
gnu.regexp.REException,"/*
 *  gnu/regexp/REException.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.text.MessageFormat;
/**
 * This is the regular expression exception class.  An exception of this type
 * defines the three attributes:
 * <OL>
 * <LI> A descriptive message of the error.
 * <LI> An integral type code equivalent to one of the statically
 *      defined symbols listed below.
 * <LI> The approximate position in the input string where the error
 *      occurred.
 * </OL>
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 */
public class REException extends Exception {
  private int type;
  private int pos;
  // Error conditions from GNU regcomp(3) manual
  /**
   * Error flag.
   * Invalid use of repetition operators such  as  using
   * `*' as the first character.
   */
  public static final int REG_BADRPT  =  1;
  /**
   * Error flag.
   * Invalid use of back reference operator.
   */
  public static final int REG_BADBR   =  2;
  /**
   * Error flag.
   * Un-matched brace interval operators.
   */
  public static final int REG_EBRACE  =  3;
  /**
   * Error flag.
   * Un-matched bracket list operators.
   */
  public static final int REG_EBRACK  =  4;
  /**
   * Error flag.
   * Invalid  use  of the range operator, eg. the ending
   * point of the range occurs  prior  to  the  starting
   * point.
   */
  public static final int REG_ERANGE  =  5;
  /**
   * Error flag.
   * Unknown character class name. <B>Not implemented</B>.
   */
  public static final int REG_ECTYPE  =  6;
  /**
   * Error flag.
   * Un-matched parenthesis group operators.
   */
  public static final int REG_EPAREN  =  7;
  /**
   * Error flag.
   * Invalid back reference to a subexpression.
   */
  public static final int REG_ESUBREG =  8;
  /**
   * Error flag.
   * Non specific error. <B>Not implemented</B>.
   */
  public static final int REG_EEND    =  9;
  /**
   * Error flag.
   * Invalid escape sequence. <B>Not implemented</B>.
   */
  public static final int REG_ESCAPE  = 10;
  /**
   * Error flag.
   * Invalid  use  of pattern operators such as group or list.
   */
  public static final int REG_BADPAT  = 11;
  /**
   * Error flag.
   * Compiled  regular  expression  requires  a  pattern
   * buffer larger than 64Kb. <B>Not implemented</B>.
   */
  public static final int REG_ESIZE   = 12;
  /**
   * Error flag.
   * The regex routines ran out of memory. <B>Not implemented</B>.
   */
  public static final int REG_ESPACE  = 13;
  REException(String msg, int type, int position) { 
    super(msg); 
    this.type = type;
    this.pos = position;
  }
  /**
   * Returns the type of the exception, one of the constants listed above.
   */
  public int getType() {
    return type;
  }
  /**
   * Returns the position, relative to the string or character array being
   * compiled, where the error occurred.  This position is generally the point
   * where the error was detected, not necessarily the starting index of
   * a bad subexpression.
   */
  public int getPosition() {
    return pos;
  }
  /**
   * Reports the descriptive message associated with this exception
   * as well as its index position in the string or character array
   * being compiled.
   */
  public String getMessage() {
    Object[] args = {new Integer(pos)};
    StringBuffer sb = new StringBuffer();
    String prefix = RE.getLocalizedMessage(""error.prefix"");
    sb.append(MessageFormat.format(prefix, args));
    sb.append('\n');
    sb.append(super.getMessage());
    return sb.toString();
  }
}
"
gnu.regexp.REFilterInputStream,"/*
 *  gnu/regexp/REFilterInputStream.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.FilterInputStream;
import java.io.InputStream;
/**
 * Replaces instances of a given RE found within an InputStream
 * with replacement text.   The replacements are interpolated into the
 * stream when a match is found.
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 * @deprecated This class cannot properly handle all character
 *             encodings.  For proper handling, use the REFilterReader
 *             class instead.
 */
public class REFilterInputStream extends FilterInputStream {
    private RE expr;
    private String replace;
    private String buffer;
    private int bufpos;
    private int offset;
    private CharIndexedInputStream stream;
  /**
   * Creates an REFilterInputStream.  When reading from this stream,
   * occurrences of patterns matching the supplied regular expression
   * will be replaced with the supplied replacement text (the
   * metacharacters $0 through $9 may be used to refer to the full
   * match or subexpression matches).
   *
   * @param stream The InputStream to be filtered.
   * @param expr The regular expression to search for.
   * @param replace The text pattern to replace matches with.  
   */
  public REFilterInputStream(InputStream stream, RE expr, String replace) {
    super(stream);
    this.stream = new CharIndexedInputStream(stream,0);
    this.expr = expr;
    this.replace = replace;
  }
  /**
   * Reads the next byte from the stream per the general contract of
   * InputStream.read().  Returns -1 on error or end of stream.
   */
  public int read() {
    // If we have buffered replace data, use it.
    if ((buffer != null) && (bufpos < buffer.length())) {
      return (int) buffer.charAt(bufpos++);
    }
    // check if input is at a valid position
    if (!stream.isValid()) return -1;
    REMatch mymatch = new REMatch(expr.getNumSubs(),offset,0);
    if (expr.match(stream, mymatch)) {
      mymatch.end[0] = mymatch.index;
      mymatch.finish(stream);
      stream.move(mymatch.toString().length());
      offset += mymatch.toString().length();
      buffer = mymatch.substituteInto(replace);
      bufpos = 1;
      // This is prone to infinite loops if replace string turns out empty.
      if (buffer.length() > 0) {
	  return buffer.charAt(0);
      }
    }
    char ch = stream.charAt(0);
    if (ch == CharIndexed.OUT_OF_BOUNDS) return -1;
    stream.move(1);
    offset++;
    return ch;
  }
  /** 
   * Returns false.  REFilterInputStream does not support mark() and
   * reset() methods. 
   */
  public boolean markSupported() {
    return false;
  }
  /** Reads from the stream into the provided array. */
  public int read(byte[] b, int off, int len) {
    int i;
    int ok = 0;
    while (len-- > 0) {
      i = read();
      if (i == -1) return (ok == 0) ? -1 : ok;
      b[off++] = (byte) i;
      ok++;
    }
    return ok;
  }
  /** Reads from the stream into the provided array. */
  public int read(byte[] b) {
    return read(b,0,b.length);
  }
}
"
gnu.regexp.REFilterReader,"/*
 *  gnu/regexp/REFilterReader.java
 *  Copyright (C) 2001 Lee Sau Dan
 *  Based on gnu.regexp.REFilterInputStream by Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.FilterReader;
import java.io.Reader;
/**
 * Replaces instances of a given RE with replacement text. 
 *
 * @author <A HREF=""http://www.csis.hku.hk/~sdlee/"">Lee Sau Dan</A>
 * @since gnu.regexp 1.1.0
 */
public class REFilterReader extends FilterReader {
  private RE expr;
  private String replace;
  private String buffer;
  private int bufpos;
  private int offset;
  private CharIndexedReader stream;
  /**
   * Creates an REFilterReader.  When reading from this stream,
   * occurrences of patterns matching the supplied regular expression
   * will be replaced with the supplied replacement text (the
   * metacharacters $0 through $9 may be used to refer to the full
   * match or subexpression matches.
   *
   * @param stream The Reader to be filtered.
   * @param expr The regular expression to search for.
   * @param replace The text pattern to replace matches with.  
   */
  public REFilterReader(Reader stream, RE expr, String replace) {
    super(stream);
    this.stream = new CharIndexedReader(stream,0);
    this.expr = expr;
    this.replace = replace;
  }
  /**
   * Reads the next character from the stream per the general contract of
   * Reader.read().  Returns -1 on error or end of stream.
   */
  public int read() {
    // If we have buffered replace data, use it.
    if ((buffer != null) && (bufpos < buffer.length())) {
      return (int) buffer.charAt(bufpos++);
    }
    // check if input is at a valid position
    if (!stream.isValid()) return -1;
    REMatch mymatch = new REMatch(expr.getNumSubs(),offset,0);
    if (expr.match(stream,mymatch)) {
      mymatch.end[0] = mymatch.index;
      mymatch.finish(stream);
      stream.move(mymatch.toString().length());
      offset += mymatch.toString().length();
      buffer = mymatch.substituteInto(replace);
      bufpos = 1;
      if (buffer.length() > 0) {
	  return buffer.charAt(0);
      }
    }
    char ch = stream.charAt(0);
    if (ch == CharIndexed.OUT_OF_BOUNDS) return -1;
    stream.move(1);
    offset++;
    return ch;
  }
  /** 
   * Returns false.  REFilterReader does not support mark() and
   * reset() methods. 
   */
  public boolean markSupported() {
    return false;
  }
  /** Reads from the stream into the provided array. */
  public int read(char[] b, int off, int len) {
    int i;
    int ok = 0;
    while (len-- > 0) {
      i = read();
      if (i == -1) return (ok == 0) ? -1 : ok;
      b[off++] = (char) i;
      ok++;
    }
    return ok;
  }
  /** Reads from the stream into the provided array. */
  public int read(char[] b) {
    return read(b,0,b.length);
  }
}
"
gnu.regexp.REMatch,"/*
 *  gnu/regexp/REMatch.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
/**
 * An instance of this class represents a match
 * completed by a gnu.regexp matching function. It can be used
 * to obtain relevant information about the location of a match
 * or submatch.
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 */
public final class REMatch implements Serializable, Cloneable {
    private String matchedText;
    // These variables are package scope for fast access within the engine
    int eflags; // execution flags this match was made using
    int offset; // offset in source text where match was tried
    int anchor; // anchor position, for ANCHORINDEX option
    int[] start; // start positions (relative to offset) for each (sub)exp.
    int[] end;   // end positions for the same
    int index; // used while matching to mark current match position in input
    REMatch next; // other possibility (to avoid having to use arrays)
    public Object clone() {
	try {
	    REMatch copy = (REMatch) super.clone();
	    copy.next = null;
	    copy.start = (int[]) start.clone();
	    copy.end = (int[]) end.clone();
	    return copy;
	} catch (CloneNotSupportedException e) {
	    throw new Error(); // doesn't happen
	}
    }
    void assignFrom(REMatch other) {
	start = other.start;
	end = other.end;
	index = other.index;
	// need to deep clone?
	next = other.next;
    }
    REMatch(int subs, int index, int eflags) {
	start = new int[subs+1];
	end = new int[subs+1];
	anchor = index;
	this.eflags = eflags;
	clear(index);
    }
    void finish(CharIndexed text) {
	start[0] = 0;
	StringBuffer sb = new StringBuffer();
	int i;
	for (i = 0; i < end[0]; i++)
	    sb.append(text.charAt(i));
	matchedText = sb.toString();
	for (i = 0; i < start.length; i++) {
	    // If any subexpressions didn't terminate, they don't count
	    // TODO check if this code ever gets hit
	    if ((start[i] == -1) ^ (end[i] == -1)) {
		start[i] = -1;
		end[i] = -1;
	    }
	}
	next = null; // cut off alternates
    }
    /** Clears the current match and moves the offset to the new index. */
    void clear(int index) {
	offset = index;
	this.index = 0;
	for (int i = 0; i < start.length; i++) {
	    start[i] = end[i] = -1;
	}
	next = null; // cut off alternates
    }
    /**
     * Returns the string matching the pattern.  This makes it convenient
     * to write code like the following:
     * <P>
     * <code> 
     * REMatch myMatch = myExpression.getMatch(myString);<br>
     * if (myMatch != null) System.out.println(""Regexp found: ""+myMatch);
     * </code>
     */
    public String toString() {
	return matchedText;
    }
    /**
     * Returns the index within the input text where the match in its entirety
     * began.
     */
    public int getStartIndex() {
	return offset + start[0];
    }
    /**
     * Returns the index within the input string where the match in
     * its entirety ends.  The return value is the next position after
     * the end of the string; therefore, a match created by the
     * following call:
     *
     * <P>
     * <code>REMatch myMatch = myExpression.getMatch(myString);</code>
     * <P>
     * can be viewed (given that myMatch is not null) by creating
     * <P>
     * <code>String theMatch = myString.substring(myMatch.getStartIndex(),
     * myMatch.getEndIndex());</code>
     * <P>
     * But you can save yourself that work, since the <code>toString()</code>
     * method (above) does exactly that for you.  
     */
    public int getEndIndex() {
	return offset + end[0];
    }
    /**
     * Returns the string matching the given subexpression.  The subexpressions
     * are indexed starting with one, not zero.  That is, the subexpression
     * identified by the first set of parentheses in a regular expression
     * could be retrieved from an REMatch by calling match.toString(1).
     *
     * @param sub Index of the subexpression.
     */
    public String toString(int sub) {
	if ((sub >= start.length) || (start[sub] == -1)) return """";
	return (matchedText.substring(start[sub],end[sub]));
    }
    /** 
     * Returns the index within the input string used to generate this match
     * where subexpression number <i>sub</i> begins, or <code>-1</code> if
     * the subexpression does not exist.  The initial position is zero.
     *
     * @param sub Subexpression index
     * @deprecated Use getStartIndex(int) instead.
     */
    public int getSubStartIndex(int sub) {
	if (sub >= start.length) return -1;
	int x = start[sub];
	return (x == -1) ? x : offset + x;
    }
    /** 
     * Returns the index within the input string used to generate this match
     * where subexpression number <i>sub</i> begins, or <code>-1</code> if
     * the subexpression does not exist.  The initial position is zero.
     *
     * @param sub Subexpression index
     * @since gnu.regexp 1.1.0
     */
    public int getStartIndex(int sub) {
	if (sub >= start.length) return -1;
	int x = start[sub];
	return (x == -1) ? x : offset + x;
    }
    /** 
     * Returns the index within the input string used to generate this match
     * where subexpression number <i>sub</i> ends, or <code>-1</code> if
     * the subexpression does not exist.  The initial position is zero.
     *
     * @param sub Subexpression index
     * @deprecated Use getEndIndex(int) instead
     */
    public int getSubEndIndex(int sub) {
	if (sub >= start.length) return -1;
	int x = end[sub];
	return (x == -1) ? x : offset + x;
    }
    /** 
     * Returns the index within the input string used to generate this match
     * where subexpression number <i>sub</i> ends, or <code>-1</code> if
     * the subexpression does not exist.  The initial position is zero.
     *
     * @param sub Subexpression index
     */
    public int getEndIndex(int sub) {
	if (sub >= start.length) return -1;
	int x = end[sub];
	return (x == -1) ? x : offset + x;
    }
    /**
     * Returns the number of subexpressions in this match.
     * @author Slava Pestov
     */
    public int getSubCount()
    {
        return start.length;
    }
    /**
     * Substitute the results of this match to create a new string.
     * This is patterned after PERL, so the tokens to watch out for are
     * <code>$0</code> through <code>$9</code>.  <code>$0</code> matches
     * the full substring matched; <code>$<i>n</i></code> matches
     * subexpression number <i>n</i>.
     *
     * @param input A string consisting of literals and <code>$<i>n</i></code> tokens.
     */
    public String substituteInto(String input) {
	// a la Perl, $0 is whole thing, $1 - $9 are subexpressions
	StringBuffer output = new StringBuffer();
	int pos;
	for (pos = 0; pos < input.length()-1; pos++) {
	    if ((input.charAt(pos) == '$') && (Character.isDigit(input.charAt(pos+1)))) {
		int val = Character.digit(input.charAt(++pos),10);
		if (val < start.length) {
		    output.append(toString(val));
		} 
	    } else output.append(input.charAt(pos));
	}
	if (pos < input.length()) output.append(input.charAt(pos));
	return output.toString();
    }
}
"
gnu.regexp.REMatchEnumeration,"/*
 *  gnu/regexp/REMatchEnumeration.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
import java.util.Enumeration;
import java.util.NoSuchElementException;
/**
 * An REMatchEnumeration enumerates regular expression matches over a
 * given input text.  You obtain a reference to an enumeration using
 * the <code>getMatchEnumeration()</code> methods on an instance of
 * RE. 
 *
 * <P>
 *
 * REMatchEnumeration does lazy computation; that is, it will not
 * search for a match until it needs to.  If you'd rather just get all
 * the matches at once in a big array, use the
 * <code>getAllMatches()</code> methods on RE.  However, using an
 * enumeration can help speed performance when the entire text does
 * not need to be searched immediately.
 *
 * <P>
 * 
 * The enumerated type is especially useful when searching on a Reader
 * or InputStream, because the InputStream read position cannot be
 * guaranteed after calling <code>getMatch()</code> (see the
 * description of that method for an explanation of why).  Enumeration
 * also saves a lot of overhead required when calling
 * <code>getMatch()</code> multiple times.
 * 
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A> 
 */
public class REMatchEnumeration implements Enumeration, Serializable {
  private static final int YES = 1;
  private static final int MAYBE = 0;
  private static final int NO = -1;
  private int more;
  private REMatch match;
  private RE expr;
  private CharIndexed input;
  private int eflags;
  private StringBuffer buffer;
  // Package scope constructor is used by RE.getMatchEnumeration()
  REMatchEnumeration(RE expr, CharIndexed input, int index, int eflags) {
    more = MAYBE;
    this.expr = expr;
    this.input = input;
    input.move(index);
    this.eflags = eflags;
  }
  /** Returns true if there are more matches in the input text. */
  public boolean hasMoreElements() {
    return hasMoreMatches(null);
  }
  /** Returns true if there are more matches in the input text. */
  public boolean hasMoreMatches() {
    return hasMoreMatches(null);
  }
  /** Returns true if there are more matches in the input text.
   * Saves the text leading up to the match (or to the end of the input)
   * in the specified buffer.
   */
  public boolean hasMoreMatches(StringBuffer buffer) {
    if (more == MAYBE) {
	match = expr.getMatchImpl(input,0,eflags,buffer);
	if (match != null) {
	    input.move((match.end[0] > 0) ? match.end[0] : 1);
	    more = YES;
	} else more = NO;
    }
    return (more == YES);
  }
  /** Returns the next match in the input text. */
  public Object nextElement() throws NoSuchElementException {
    return nextMatch();
  }
  /** 
   * Returns the next match in the input text. This method is provided
   * for convenience to avoid having to explicitly cast the return value
   * to class REMatch.
   */
  public REMatch nextMatch() throws NoSuchElementException {
    if (hasMoreElements()) {
	more = (input.isValid()) ? MAYBE : NO;
	return match;
    }
    throw new NoSuchElementException();
  }
}
"
gnu.regexp.RESyntax,"/*
 *  gnu/regexp/RESyntax.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
import java.util.BitSet;
/**
 * An RESyntax specifies the way a regular expression will be compiled.
 * This class provides a number of predefined useful constants for
 * emulating popular regular expression syntaxes.  Additionally the
 * user may construct his or her own syntax, using any combination of the
 * syntax bit constants.  The syntax is an optional argument to any of the
 * matching methods on class RE.
 *
 * @author <A HREF=""mailto:wes@cacas.org"">Wes Biggs</A>
 */
public final class RESyntax implements Serializable {
    static final String DEFAULT_LINE_SEPARATOR = System.getProperty(""line.separator"");
    private static final String SYNTAX_IS_FINAL = RE.getLocalizedMessage(""syntax.final"");
    private BitSet bits;
    // true for the constant defined syntaxes
    private boolean isFinal = false;
    private String lineSeparator = DEFAULT_LINE_SEPARATOR;
  // Values for constants are bit indexes
  /**
   * Syntax bit. Backslash is an escape character in lists.
   */
  public static final int RE_BACKSLASH_ESCAPE_IN_LISTS =  0;
  /**
   * Syntax bit. Use \? instead of ? and \+ instead of +.
   */
  public static final int RE_BK_PLUS_QM                =  1;
  /**
   * Syntax bit. POSIX character classes ([:...:]) in lists are allowed.
   */
  public static final int RE_CHAR_CLASSES              =  2;
  /**
   * Syntax bit. ^ and $ are special everywhere.
   * <B>Not implemented.</B>
   */
  public static final int RE_CONTEXT_INDEP_ANCHORS     =  3; 
  /**
   * Syntax bit. Repetition operators are only special in valid positions.
   * <B>Not implemented.</B>
   */
  public static final int RE_CONTEXT_INDEP_OPS         =  4; 
  /**
   * Syntax bit. Repetition and alternation operators are invalid
   * at start and end of pattern and other places. 
   * <B>Not implemented</B>.
   */
  public static final int RE_CONTEXT_INVALID_OPS       =  5; 
  /**
   * Syntax bit. Match-any-character operator (.) matches a newline.
   */
  public static final int RE_DOT_NEWLINE               =  6;
  /**
   * Syntax bit. Match-any-character operator (.) does not match a null.
   */
  public static final int RE_DOT_NOT_NULL              =  7;
  /**
   * Syntax bit. Intervals ({x}, {x,}, {x,y}) are allowed.
   */
  public static final int RE_INTERVALS                 =  8;
  /**
   * Syntax bit. No alternation (|), match one-or-more (+), or 
   * match zero-or-one (?) operators.
   */
  public static final int RE_LIMITED_OPS               =  9;
  /**
   * Syntax bit. Newline is an alternation operator.
   */
  public static final int RE_NEWLINE_ALT               = 10; // impl.
  /**
   * Syntax bit. Intervals use { } instead of \{ \}
   */
  public static final int RE_NO_BK_BRACES              = 11; 
  /**
   * Syntax bit. Grouping uses ( ) instead of \( \).
   */
  public static final int RE_NO_BK_PARENS              = 12;
  /**
   * Syntax bit. Backreferences not allowed.
   */
  public static final int RE_NO_BK_REFS                = 13;
  /**
   * Syntax bit. Alternation uses | instead of \|
   */
  public static final int RE_NO_BK_VBAR                = 14;
  /**
   * Syntax bit. <B>Not implemented</B>.
   */
  public static final int RE_NO_EMPTY_RANGES           = 15;
  /**
   * Syntax bit. An unmatched right parenthesis (')' or '\)', depending
   * on RE_NO_BK_PARENS) will throw an exception when compiling.
   */
  public static final int RE_UNMATCHED_RIGHT_PAREN_ORD = 16;
  /**
   * Syntax bit. <B>Not implemented.</B>
   */
  public static final int RE_HAT_LISTS_NOT_NEWLINE     = 17;
  /**
   * Syntax bit.  Stingy matching is allowed (+?, *?, ??, {x,y}?).
   */
  public static final int RE_STINGY_OPS                = 18;
  /**
   * Syntax bit. Allow character class escapes (\d, \D, \s, \S, \w, \W).
   */
  public static final int RE_CHAR_CLASS_ESCAPES        = 19;
  /**
   * Syntax bit. Allow use of (?:xxx) grouping (subexpression is not saved).
   */
  public static final int RE_PURE_GROUPING             = 20;
  /**
   * Syntax bit. Allow use of (?=xxx) and (?!xxx) apply the subexpression
   * to the text following the current position without cousuming that text.
   */
  public static final int RE_LOOKAHEAD                 = 21;
  /**
   * Syntax bit. Allow beginning- and end-of-string anchors (\A, \Z).
   */
  public static final int RE_STRING_ANCHORS            = 22;
  /**
   * Syntax bit. Allow embedded comments, (#comment), as in Perl5.
   */
  public static final int RE_COMMENTS                  = 23;
  /**
   * Syntax bit. Allow character class escapes within lists, as in Perl5.
   */
  public static final int RE_CHAR_CLASS_ESC_IN_LISTS   = 24;
  private static final int BIT_TOTAL                   = 25;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the awk utility.
   */
  public static final RESyntax RE_SYNTAX_AWK;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the ed utility.
   */
  public static final RESyntax RE_SYNTAX_ED;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the egrep utility.
   */
  public static final RESyntax RE_SYNTAX_EGREP;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the GNU Emacs editor.
   */
  public static final RESyntax RE_SYNTAX_EMACS;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the grep utility.
   */
  public static final RESyntax RE_SYNTAX_GREP;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the POSIX awk specification.
   */
  public static final RESyntax RE_SYNTAX_POSIX_AWK;
  /**
   * Predefined syntax.
   * Emulates POSIX basic regular expression support.
   */
  public static final RESyntax RE_SYNTAX_POSIX_BASIC;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the POSIX egrep specification.
   */
  public static final RESyntax RE_SYNTAX_POSIX_EGREP;
  /**
   * Predefined syntax.
   * Emulates POSIX extended regular expression support.
   */
  public static final RESyntax RE_SYNTAX_POSIX_EXTENDED;
  /**
   * Predefined syntax.
   * Emulates POSIX basic minimal regular expressions.
   */
  public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_BASIC;
  /**
   * Predefined syntax.
   * Emulates POSIX extended minimal regular expressions.
   */
  public static final RESyntax RE_SYNTAX_POSIX_MINIMAL_EXTENDED;
  /**
   * Predefined syntax.
   * Emulates regular expression support in the sed utility.
   */
  public static final RESyntax RE_SYNTAX_SED;
  /**
   * Predefined syntax.
   * Emulates regular expression support in Larry Wall's perl, version 4,
   */
  public static final RESyntax RE_SYNTAX_PERL4;
  /**
   * Predefined syntax.
   * Emulates regular expression support in Larry Wall's perl, version 4,
   * using single line mode (/s modifier).
   */
  public static final RESyntax RE_SYNTAX_PERL4_S; // single line mode (/s)
  /**
   * Predefined syntax.
   * Emulates regular expression support in Larry Wall's perl, version 5.
   */
  public static final RESyntax RE_SYNTAX_PERL5;  
  /**
   * Predefined syntax.
   * Emulates regular expression support in Larry Wall's perl, version 5,
   * using single line mode (/s modifier).
   */
  public static final RESyntax RE_SYNTAX_PERL5_S;
  static {
      // Define syntaxes
      RE_SYNTAX_EMACS = new RESyntax().makeFinal();
      RESyntax RE_SYNTAX_POSIX_COMMON = new RESyntax()
	  .set(RE_CHAR_CLASSES)
	  .set(RE_DOT_NEWLINE)
	  .set(RE_DOT_NOT_NULL)
	  .set(RE_INTERVALS)
	  .set(RE_NO_EMPTY_RANGES)
	  .makeFinal();
      RE_SYNTAX_POSIX_BASIC = new RESyntax(RE_SYNTAX_POSIX_COMMON)
	  .set(RE_BK_PLUS_QM)
	  .makeFinal();
      RE_SYNTAX_POSIX_EXTENDED = new RESyntax(RE_SYNTAX_POSIX_COMMON)
	  .set(RE_CONTEXT_INDEP_ANCHORS)
	  .set(RE_CONTEXT_INDEP_OPS)
	  .set(RE_NO_BK_BRACES)
	  .set(RE_NO_BK_PARENS)
	  .set(RE_NO_BK_VBAR)
	  .set(RE_UNMATCHED_RIGHT_PAREN_ORD)
	  .makeFinal();
      RE_SYNTAX_AWK = new RESyntax()
	  .set(RE_BACKSLASH_ESCAPE_IN_LISTS)
	  .set(RE_DOT_NOT_NULL)
	  .set(RE_NO_BK_PARENS)
	  .set(RE_NO_BK_REFS)
	  .set(RE_NO_BK_VBAR)
	  .set(RE_NO_EMPTY_RANGES)
	  .set(RE_UNMATCHED_RIGHT_PAREN_ORD)
	  .makeFinal();
      RE_SYNTAX_POSIX_AWK = new RESyntax(RE_SYNTAX_POSIX_EXTENDED)
	  .set(RE_BACKSLASH_ESCAPE_IN_LISTS)
	  .makeFinal();
      RE_SYNTAX_GREP = new RESyntax()
	  .set(RE_BK_PLUS_QM)
	  .set(RE_CHAR_CLASSES)
	  .set(RE_HAT_LISTS_NOT_NEWLINE)
	  .set(RE_INTERVALS)
	  .set(RE_NEWLINE_ALT)
	  .makeFinal();
      RE_SYNTAX_EGREP = new RESyntax()
	  .set(RE_CHAR_CLASSES)
	  .set(RE_CONTEXT_INDEP_ANCHORS)
	  .set(RE_CONTEXT_INDEP_OPS)
	  .set(RE_HAT_LISTS_NOT_NEWLINE)
	  .set(RE_NEWLINE_ALT)
	  .set(RE_NO_BK_PARENS)
	  .set(RE_NO_BK_VBAR)
	  .makeFinal();
      RE_SYNTAX_POSIX_EGREP = new RESyntax(RE_SYNTAX_EGREP)
	  .set(RE_INTERVALS)
	  .set(RE_NO_BK_BRACES)
	  .makeFinal();
      /* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
      RE_SYNTAX_ED = new RESyntax(RE_SYNTAX_POSIX_BASIC)
	  .makeFinal();
      RE_SYNTAX_SED = new RESyntax(RE_SYNTAX_POSIX_BASIC)
	  .makeFinal();
      RE_SYNTAX_POSIX_MINIMAL_BASIC = new RESyntax(RE_SYNTAX_POSIX_COMMON)
	  .set(RE_LIMITED_OPS)
	  .makeFinal();
      /* Differs from RE_SYNTAX_POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
	 replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added. */
      RE_SYNTAX_POSIX_MINIMAL_EXTENDED = new RESyntax(RE_SYNTAX_POSIX_COMMON)
	  .set(RE_CONTEXT_INDEP_ANCHORS)
	  .set(RE_CONTEXT_INVALID_OPS)
	  .set(RE_NO_BK_BRACES)
	  .set(RE_NO_BK_PARENS)
	  .set(RE_NO_BK_REFS)
	  .set(RE_NO_BK_VBAR)
	  .set(RE_UNMATCHED_RIGHT_PAREN_ORD)
	  .makeFinal();
      /* There is no official Perl spec, but here's a ""best guess"" */
      RE_SYNTAX_PERL4 = new RESyntax()
	  .set(RE_BACKSLASH_ESCAPE_IN_LISTS)
	  .set(RE_CONTEXT_INDEP_ANCHORS)
	  .set(RE_CONTEXT_INDEP_OPS)          // except for '{', apparently
	  .set(RE_INTERVALS)
	  .set(RE_NO_BK_BRACES)
	  .set(RE_NO_BK_PARENS)
	  .set(RE_NO_BK_VBAR)
	  .set(RE_NO_EMPTY_RANGES)
	  .set(RE_CHAR_CLASS_ESCAPES)    // \d,\D,\w,\W,\s,\S
	  .makeFinal();
      RE_SYNTAX_PERL4_S = new RESyntax(RE_SYNTAX_PERL4)
	  .set(RE_DOT_NEWLINE)
	  .makeFinal();
      RE_SYNTAX_PERL5 = new RESyntax(RE_SYNTAX_PERL4)
	  .set(RE_PURE_GROUPING)          // (?:)
	  .set(RE_STINGY_OPS)             // *?,??,+?,{}?
	  .set(RE_LOOKAHEAD)              // (?=)(?!) not implemented
	  .set(RE_STRING_ANCHORS)         // \A,\Z
	  .set(RE_CHAR_CLASS_ESC_IN_LISTS)// \d,\D,\w,\W,\s,\S within []
	  .set(RE_COMMENTS)              // (?#)
	  .makeFinal();
      RE_SYNTAX_PERL5_S = new RESyntax(RE_SYNTAX_PERL5)
	  .set(RE_DOT_NEWLINE)
	  .makeFinal();
  }
  /**
   * Construct a new syntax object with all bits turned off.
   * This is equivalent to RE_SYNTAX_EMACS.
   */
  public RESyntax() {
    bits = new BitSet(BIT_TOTAL);
  }
    /**
     * Called internally when constructing predefined syntaxes
     * so their interpretation cannot vary.  Conceivably useful
     * for your syntaxes as well.  Causes IllegalAccessError to
     * be thrown if any attempt to modify the syntax is made.
     *
     * @return this object for convenient chaining
     */
    public RESyntax makeFinal() {
	isFinal = true;
	return this;
    }
  /**
   * Construct a new syntax object with all bits set the same 
   * as the other syntax.
   */
  public RESyntax(RESyntax other) {
    bits = (BitSet) other.bits.clone();
  }
  /**
   * Check if a given bit is set in this syntax.
   */
  public boolean get(int index) {
    return bits.get(index);
  }
  /**
   * Set a given bit in this syntax. 
   *
   * @param index the constant (RESyntax.RE_xxx) bit to set.
   * @return a reference to this object for easy chaining.
   */
  public RESyntax set(int index) {
      if (isFinal) throw new IllegalAccessError(SYNTAX_IS_FINAL);
    bits.set(index);
    return this;
  }
  /**
   * Clear a given bit in this syntax. 
   *
   * @param index the constant (RESyntax.RE_xxx) bit to clear.
   * @return a reference to this object for easy chaining.
   */
  public RESyntax clear(int index) {
      if (isFinal) throw new IllegalAccessError(SYNTAX_IS_FINAL);
      bits.clear(index);
      return this;
  }
    /**
     * Changes the line separator string for regular expressions
     * created using this RESyntax.  The default separator is the
     * value returned by the system property ""line.separator"", which
     * should be correct when reading platform-specific files from a
     * filesystem.  However, many programs may collect input from
     * sources where the line separator is differently specified (for
     * example, in the applet environment, the text box widget
     * interprets line breaks as single-character newlines,
     * regardless of the host platform.
     *
     * Note that setting the line separator to a character or
     * characters that have specific meaning within the current syntax
     * can cause unexpected chronosynclastic infundibula.
     *
     * @return this object for convenient chaining 
     */
    public RESyntax setLineSeparator(String aSeparator) {
	if (isFinal) throw new IllegalAccessError(SYNTAX_IS_FINAL);
	lineSeparator = aSeparator;
	return this;
    }
    /**
     * Returns the currently active line separator string.  The default
     * is the platform-dependent system property ""line.separator"".
     */
    public String getLineSeparator() {
	return lineSeparator;
    }
}
"
gnu.regexp.REToken,"/*
 *  gnu/regexp/REToken.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.io.Serializable;
abstract class REToken implements Serializable {
  protected REToken next = null;
  protected REToken uncle = null;
  protected int subIndex;
  protected REToken(int aSubIndex) {
      subIndex = aSubIndex;
  }
  int getMinimumLength() {
    return 0;
  }
  void setUncle(REToken anUncle) {
    uncle = anUncle;
  }
    /** Returns true if the match succeeded, false if it failed. */
    abstract boolean match(CharIndexed input, REMatch mymatch);
    /** Returns true if the rest of the tokens match, false if they fail. */
    protected boolean next(CharIndexed input, REMatch mymatch) {
	if (next == null) {
	    if (uncle == null) {
		return true;
	    } else {
		return uncle.match(input, mymatch);
	    }
	} else {
	    return next.match(input, mymatch);
	}
    }
  boolean chain(REToken token) {
      next = token;
      return true; // Token was accepted
  }
  void dump(StringBuffer os) { 
  }
  void dumpAll(StringBuffer os) {
    dump(os);
    if (next != null) next.dumpAll(os);
  }
}
"
gnu.regexp.RETokenAny,"/*
 *  gnu/regexp/RETokenAny.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenAny extends REToken {
  /** True if '.' can match a newline (RE_DOT_NEWLINE) */
  private boolean newline; 
  /** True if '.' can't match a null (RE_DOT_NOT_NULL) */
  private boolean matchNull;    
  RETokenAny(int subIndex, boolean newline, boolean matchNull) { 
    super(subIndex);
    this.newline = newline;
    this.matchNull = matchNull;
  }
  int getMinimumLength() {
    return 1;
  }
    boolean match(CharIndexed input, REMatch mymatch) {
    char ch = input.charAt(mymatch.index);
    if ((ch == CharIndexed.OUT_OF_BOUNDS)
	|| (!newline && (ch == '\n'))
	|| (matchNull && (ch == 0))) {
	return false;
    }
    ++mymatch.index;
    return next(input, mymatch);
  }
  void dump(StringBuffer os) {
    os.append('.');
  }
}
"
gnu.regexp.RETokenBackRef,"/*
 *  gnu/regexp/RETokenBackRef.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenBackRef extends REToken {
  private int num;
  private boolean insens;
  RETokenBackRef(int subIndex, int num, boolean insens) {
    super(subIndex);
    this.num = num;
    this.insens = insens;
  }
  // should implement getMinimumLength() -- any ideas?
    boolean match(CharIndexed input, REMatch mymatch) {
	int b,e;
	b = mymatch.start[num];
	e = mymatch.end[num];
	if ((b==-1)||(e==-1)) return false; // this shouldn't happen, but...
	for (int i=b; i<e; i++) {
	    if (input.charAt(mymatch.index+i-b) != input.charAt(i)) {
		return false;
	    }
	}
	mymatch.index += e-b;
	return next(input, mymatch);
    }
    void dump(StringBuffer os) {
	os.append('\\').append(num);
    }
}
"
gnu.regexp.RETokenChar,"/*
 *  gnu/regexp/RETokenChar.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenChar extends REToken {
  private char[] ch;
  private boolean insens;
  RETokenChar(int subIndex, char c, boolean ins) {
    super(subIndex);
    ch = new char [1];
    ch[0] = (insens = ins) ? Character.toLowerCase(c) : c;
  }
  int getMinimumLength() {
    return ch.length;
  }
    boolean match(CharIndexed input, REMatch mymatch) {
	int z = ch.length;
	char c;
	for (int i=0; i<z; i++) {
	    c = input.charAt(mymatch.index+i);
	    if (( (insens) ? Character.toLowerCase(c) : c ) != ch[i]) {
		return false;
	    }
	}
	mymatch.index += z;
	return next(input, mymatch);
    }
  // Overrides REToken.chain() to optimize for strings
  boolean chain(REToken next) {
    if (next instanceof RETokenChar) {
      RETokenChar cnext = (RETokenChar) next;
      // assume for now that next can only be one character
      int newsize = ch.length + cnext.ch.length;
      char[] chTemp = new char [newsize];
      System.arraycopy(ch,0,chTemp,0,ch.length);
      System.arraycopy(cnext.ch,0,chTemp,ch.length,cnext.ch.length);
      ch = chTemp;
      return false;
    } else return super.chain(next);
  }
  void dump(StringBuffer os) {
    os.append(ch);
  }
}
"
gnu.regexp.RETokenEnd,"/*
 *  gnu/regexp/RETokenEnd.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenEnd extends REToken {
    /**
     * Indicates whether this token should match on a line break.
     */
  private String newline;
  RETokenEnd(int subIndex,String newline) { 
    super(subIndex);
    this.newline = newline;
  }
    boolean match(CharIndexed input, REMatch mymatch) {
	char ch = input.charAt(mymatch.index);
	if (ch == CharIndexed.OUT_OF_BOUNDS)
	    return ((mymatch.eflags & RE.REG_NOTEOL)>0) ? 
		false : next(input, mymatch);
	if (newline != null) {
	    char z;
	    int i = 0; // position in newline
	    do {
		z = newline.charAt(i);
		if (ch != z) return false;
		++i;
		ch = input.charAt(mymatch.index + i);
	    } while (i < newline.length());
	    return next(input, mymatch);
	}
	return false;
    }
  void dump(StringBuffer os) {
    os.append('$');
  }
}
"
gnu.regexp.RETokenEndSub,"/*
 *  gnu/regexp/RETokenEndSub.java
 *  Copyright (C) 2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenEndSub extends REToken {
    RETokenEndSub(int subIndex) {
	super(subIndex);
    }
    boolean match(CharIndexed input, REMatch mymatch) {
	mymatch.end[subIndex] = mymatch.index;
	return next(input, mymatch);
    }
    void dump(StringBuffer os) {
	// handled by RE
    }
}
"
gnu.regexp.RETokenLookAhead,"/*
 *  gnu/regexp/RETokenOneOf.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenLookAhead extends REToken
{
  RE re;
  boolean negative;
  RETokenLookAhead(Object pattern, int cflags, RESyntax syntax, boolean negative) throws REException {
    super(0);
    re = new RE(pattern, cflags, syntax);
    this.negative = negative;
  }
  boolean match(CharIndexed input, REMatch mymatch)
  {
    REMatch trymatch = (REMatch)mymatch.clone();
    REMatch trymatch1 = (REMatch)mymatch.clone();
    REMatch newMatch = null;
    if (re.match(input, trymatch)) {
      if (negative) return false;
      if (next(input, trymatch1))
        newMatch = trymatch1;
    }
    if (newMatch != null) {
      if (negative) return false;
      //else
      mymatch.assignFrom(newMatch);
      return true;
    }
    else { // no match
      if (negative)
        return next(input, mymatch);
      //else
      return false;
    }
  }
}
"
gnu.regexp.RETokenOneOf,"/*
 *  gnu/regexp/RETokenOneOf.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.util.Vector;
final class RETokenOneOf extends REToken {
  private Vector options;
  private boolean negative;
  // This constructor is used for convenience when we know the set beforehand,
  // e.g. \d --> new RETokenOneOf(""0123456789"",false, ..)
  //      \D --> new RETokenOneOf(""0123456789"",true, ..)
  RETokenOneOf(int subIndex, String optionsStr, boolean negative, boolean insens) {
    super(subIndex);
    options = new Vector();
    this.negative = negative;
    for (int i = 0; i < optionsStr.length(); i++)
      options.addElement(new RETokenChar(subIndex,optionsStr.charAt(i),insens));
  }
  RETokenOneOf(int subIndex, Vector options, boolean negative) {
    super(subIndex);
    this.options = options;
    this.negative = negative;
  }
  int getMinimumLength() {
    int min = Integer.MAX_VALUE;
    int x;
    for (int i=0; i < options.size(); i++) {
      if ((x = ((REToken) options.elementAt(i)).getMinimumLength()) < min)
	min = x;
    }
    return min;
  }
    boolean match(CharIndexed input, REMatch mymatch) {
    if (negative && (input.charAt(mymatch.index) == CharIndexed.OUT_OF_BOUNDS)) 
      return false;
    REMatch newMatch = null;
    REMatch last = null;
    REToken tk;
    boolean isMatch;
    for (int i=0; i < options.size(); i++) {
	tk = (REToken) options.elementAt(i);
	REMatch tryMatch = (REMatch) mymatch.clone();
	if (tk.match(input, tryMatch)) { // match was successful
	    if (negative) return false;
	    if (next(input, tryMatch)) {
		// Add tryMatch to list of possibilities.
		if (last == null) {
		    newMatch = tryMatch;
		    last = tryMatch;
		} else {
		    last.next = tryMatch;
		    last = tryMatch;
		}
	    } // next succeeds
	} // is a match
    } // try next option
    if (newMatch != null) {
	if (negative) {
	    return false;
	} else {
	    // set contents of mymatch equal to newMatch
	    // try each one that matched
	    mymatch.assignFrom(newMatch);
	    return true;
	}
    } else {
	if (negative) {
	    ++mymatch.index;
	    return next(input, mymatch);
	} else {
	    return false;
	}
    }
    // index+1 works for [^abc] lists, not for generic lookahead (--> index)
  }
  void dump(StringBuffer os) {
    os.append(negative ? ""[^"" : ""(?:"");
    for (int i = 0; i < options.size(); i++) {
      if (!negative && (i > 0)) os.append('|');
      ((REToken) options.elementAt(i)).dumpAll(os);
    }
    os.append(negative ? ']' : ')');
  }  
}
"
gnu.regexp.RETokenPOSIX,"/*
 *  gnu/regexp/RETokenPOSIX.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenPOSIX extends REToken {
  int type;
  boolean insens;
  boolean negated;
  static final int  ALNUM = 0;
  static final int  ALPHA = 1;
  static final int  BLANK = 2;
  static final int  CNTRL = 3;
  static final int  DIGIT = 4;
  static final int  GRAPH = 5;
  static final int  LOWER = 6;
  static final int  PRINT = 7;
  static final int  PUNCT = 8;
  static final int  SPACE = 9;
  static final int  UPPER = 10;
  static final int XDIGIT = 11;
  // Array indices correspond to constants defined above.
  static final String[] s_nameTable =  {
    ""alnum"", ""alpha"", ""blank"", ""cntrl"", ""digit"", ""graph"", ""lower"",
    ""print"", ""punct"", ""space"", ""upper"", ""xdigit"" 
  };
  // The RE constructor uses this to look up the constant for a string
  static int intValue(String key) {
    for (int i = 0; i < s_nameTable.length; i++) {
      if (s_nameTable[i].equals(key)) return i;
    }
    return -1;
  }
  RETokenPOSIX(int subIndex, int type, boolean insens, boolean negated) {
    super(subIndex);
    this.type = type;
    this.insens = insens;
    this.negated = negated;
  }
    int getMinimumLength() {
	return 1;
    }
    boolean match(CharIndexed input, REMatch mymatch) {
    char ch = input.charAt(mymatch.index);
    if (ch == CharIndexed.OUT_OF_BOUNDS)
      return false;
    boolean retval = false;
    switch (type) {
    case ALNUM:
	// Note that there is some debate over whether '_' should be included
	retval = Character.isLetterOrDigit(ch) || (ch == '_');
	break;
    case ALPHA:
	retval = Character.isLetter(ch);
	break;
    case BLANK:
	retval = ((ch == ' ') || (ch == '\t'));
	break;
    case CNTRL:
	retval = Character.isISOControl(ch);
	break;
    case DIGIT:
	retval = Character.isDigit(ch);
	break;
    case GRAPH:
	retval = (!(Character.isWhitespace(ch) || Character.isISOControl(ch)));
	break;
    case LOWER:
	retval = ((insens && Character.isLetter(ch)) || Character.isLowerCase(ch));
	break;
    case PRINT:
	retval = (!(Character.isWhitespace(ch) || Character.isISOControl(ch)))
	    || (ch == ' ');
	break;
    case PUNCT:
	// This feels sloppy, especially for non-U.S. locales.
	retval = (""`~!@#$%^&*()-_=+[]{}\\|;:'\""/?,.<>"".indexOf(ch)!=-1);
	break;
    case SPACE:
	retval = Character.isWhitespace(ch);
	break;
    case UPPER:
	retval = ((insens && Character.isLetter(ch)) || Character.isUpperCase(ch));
	break;
    case XDIGIT:
	retval = (Character.isDigit(ch) || (""abcdefABCDEF"".indexOf(ch)!=-1));
	break;
    }
    if (negated) retval = !retval;
    if (retval) {
	++mymatch.index;
	return next(input, mymatch);
    }
    else return false;
  }
  void dump(StringBuffer os) {
    if (negated) os.append('^');
    os.append(""[:"" + s_nameTable[type] + "":]"");
  }
}
"
gnu.regexp.RETokenRange,"/*
 *  gnu/regexp/RETokenRange.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
final class RETokenRange extends REToken {
  private char lo, hi;
  private boolean insens;
  RETokenRange(int subIndex, char lo, char hi, boolean ins) {
    super(subIndex);
    this.lo = (insens = ins) ? Character.toLowerCase(lo) : lo;
    this.hi = ins ? Character.toLowerCase(hi) : hi;
  }
  int getMinimumLength() {
    return 1;
  }
    boolean match(CharIndexed input, REMatch mymatch) {
	char c = input.charAt(mymatch.index);
	if (c == CharIndexed.OUT_OF_BOUNDS) return false;
	if (insens) c = Character.toLowerCase(c);
	if ((c >= lo) && (c <= hi)) {
	    ++mymatch.index;
	    return next(input, mymatch);
	}
	return false;
    }
  void dump(StringBuffer os) {
    os.append(lo).append('-').append(hi);
  }
}
"
gnu.regexp.RETokenRepeated,"/*
 *  gnu/regexp/RETokenRepeated.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
import java.util.Vector;
final class RETokenRepeated extends REToken {
    private REToken token;
    private int min,max;
    private boolean stingy;
    RETokenRepeated(int subIndex, REToken token, int min, int max) {
	super(subIndex);
	this.token = token;
	this.min = min;
	this.max = max;
    }
    /** Sets the minimal matching mode to true. */
    void makeStingy() {
	stingy = true;
    }
    /** Queries if this token has minimal matching enabled. */
    boolean isStingy() {
	return stingy;
    }
    /**
     * The minimum length of a repeated token is the minimum length
     * of the token multiplied by the minimum number of times it must
     * match.
     */
    int getMinimumLength() {
	return (min * token.getMinimumLength());
    }
    // We do need to save every possible point, but the number of clone()
    // invocations here is really a killer for performance on non-stingy
    // repeat operators.  I'm open to suggestions...
    // Hypothetical question: can you have a RE that matches 1 times,
    // 3 times, 5 times, but not 2 times or 4 times?  Does having
    // the subexpression back-reference operator allow that?
    boolean match(CharIndexed input, REMatch mymatch) {
	// number of times we've matched so far
	int numRepeats = 0; 
	// Possible positions for the next repeat to match at
	REMatch newMatch = mymatch;
	REMatch last = null;
	REMatch current;
	// Add the '0-repeats' index
	// positions.elementAt(z) == position [] in input after <<z>> matches
	Vector positions = new Vector();
	positions.addElement(newMatch);
	// Declare variables used in loop
	REMatch doables;
	REMatch doablesLast;
	REMatch recurrent;
	do {
	    // Check for stingy match for each possibility.
	    if (stingy && (numRepeats >= min)) {
		REMatch result = matchRest(input, newMatch);
		if (result != null) {
		    mymatch.assignFrom(result);
		    return true;
		}
	    }
	    doables = null;
	    doablesLast = null;
	    // try next repeat at all possible positions
	    for (current = newMatch; current != null; current = current.next) {
		recurrent = (REMatch) current.clone();
		if (token.match(input, recurrent)) {
		    // add all items in current to doables array
		    if (doables == null) {
			doables = recurrent;
			doablesLast = recurrent;
		    } else {
			// Order these from longest to shortest
			// Start by assuming longest (more repeats)
			doablesLast.next = recurrent;
		    }
		    // Find new doablesLast
		    while (doablesLast.next != null) {
			doablesLast = doablesLast.next;
		    }
		}
	    }
	    // if none of the possibilities worked out, break out of do/while
	    if (doables == null) break;
	    // reassign where the next repeat can match
	    newMatch = doables;
	    // increment how many repeats we've successfully found
	    ++numRepeats;
	    positions.addElement(newMatch);
	} while (numRepeats < max);
	// If there aren't enough repeats, then fail
	if (numRepeats < min) return false;
	// We're greedy, but ease off until a true match is found 
	int posIndex = positions.size();
	// At this point we've either got too many or just the right amount.
	// See if this numRepeats works with the rest of the regexp.
	REMatch allResults = null;
	REMatch allResultsLast = null;
	REMatch results = null;
	while (--posIndex >= min) {
	    newMatch = (REMatch) positions.elementAt(posIndex);
	    results = matchRest(input, newMatch);
	    if (results != null) {
		if (allResults == null) {
		    allResults = results;
		    allResultsLast = results;
		} else {
		    // Order these from longest to shortest
		    // Start by assuming longest (more repeats)
		    allResultsLast.next = results;
		}
		// Find new doablesLast
		while (allResultsLast.next != null) {
		    allResultsLast = allResultsLast.next;
		}
	    }
	    // else did not match rest of the tokens, try again on smaller sample
	}
	if (allResults != null) {
	    mymatch.assignFrom(allResults); // does this get all?
	    return true;
	}
	// If we fall out, no matches.
	return false;
    }
    private REMatch matchRest(CharIndexed input, final REMatch newMatch) {
	REMatch current, single;
	REMatch doneIndex = null;
	REMatch doneIndexLast = null;
	// Test all possible matches for this number of repeats
	for (current = newMatch; current != null; current = current.next) {
	    // clone() separates a single match from the chain
	    single = (REMatch) current.clone();
	    if (next(input, single)) {
		// chain results to doneIndex
		if (doneIndex == null) {
		    doneIndex = single;
		    doneIndexLast = single;
		} else {
		    doneIndexLast.next = single;
		}
		// Find new doneIndexLast
		while (doneIndexLast.next != null) {
		    doneIndexLast = doneIndexLast.next;
		}
	    }
	}
	return doneIndex;
    }
    void dump(StringBuffer os) {
	os.append(""(?:"");
	token.dumpAll(os);
	os.append(')');
	if ((max == Integer.MAX_VALUE) && (min <= 1))
	    os.append( (min == 0) ? '*' : '+' );
	else if ((min == 0) && (max == 1))
	    os.append('?');
	else {
	    os.append('{').append(min);
	    if (max > min) {
		os.append(',');
		if (max != Integer.MAX_VALUE) os.append(max);
	    }
	    os.append('}');
	}
	if (stingy) os.append('?');
    }
}
"
gnu.regexp.RETokenStart,"/*
 *  gnu/regexp/RETokenStart.java
 *  Copyright (C) 1998-2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
class RETokenStart extends REToken {
    private String newline; // matches after a newline
    RETokenStart(int subIndex, String newline) {
	super(subIndex);
	this.newline = newline;
    }
    boolean match(CharIndexed input, REMatch mymatch) {
	// charAt(index-n) may be unknown on a Reader/InputStream. FIXME
	// Match after a newline if in multiline mode
	if (newline != null) {
	    int len = newline.length();
	    if (mymatch.offset >= len) {
		boolean found = true;
		char z;
		int i = 0; // position in REToken.newline
		char ch = input.charAt(mymatch.index - len);
		do {
		    z = newline.charAt(i);
		    if (ch != z) {
			found = false;
			break;
		    }
		    ++i;
		    ch = input.charAt(mymatch.index - len + i);
		} while (i < len);
		if (found) return next(input, mymatch);
	    }
	}
	// Don't match at all if REG_NOTBOL is set.
	if ((mymatch.eflags & RE.REG_NOTBOL) > 0) return false;
	if ((mymatch.eflags & RE.REG_ANCHORINDEX) > 0)
	    return (mymatch.anchor == mymatch.offset) ? 
		next(input, mymatch) : false;
	else
	    return ((mymatch.index == 0) && (mymatch.offset == 0)) ?
		next(input, mymatch) : false;
    }
    void dump(StringBuffer os) {
	os.append('^');
    }
}
"
gnu.regexp.RETokenWordBoundary,"/*
 *  gnu/regexp/RETokenWordBoundary.java
 *  Copyright (C) 2001 Wes Biggs
 *
 *  This library is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation; either version 2.1 of the License, or
 *  (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package gnu.regexp;
/**
 * Represents a combination lookahead/lookbehind for POSIX [:alnum:].
 */
final class RETokenWordBoundary extends REToken {
    private boolean negated;
    private int where;
    static final int BEGIN = 1;
    static final int END = 2;
    RETokenWordBoundary(int subIndex, int where, boolean negated) {
	super(subIndex);
	this.where = where;
	this.negated = negated;
    }
    boolean match(CharIndexed input, REMatch mymatch) {
	// Word boundary means input[index-1] was a word character
	// and input[index] is not, or input[index] is a word character
	// and input[index-1] was not
	//  In the string ""one two three"", these positions match:
	//  |o|n|e| |t|w|o| |t|h|r|e|e|
	//  ^     ^ ^     ^ ^         ^
	boolean after = false;  // is current character a letter or digit?
	boolean before = false; // is previous character a letter or digit?
	char ch;
	// TODO: Also check REG_ANCHORINDEX vs. anchor
	if (((mymatch.eflags & RE.REG_ANCHORINDEX) != RE.REG_ANCHORINDEX) 
	    || (mymatch.offset + mymatch.index > mymatch.anchor)) {
	    if ((ch = input.charAt(mymatch.index - 1)) != CharIndexed.OUT_OF_BOUNDS) {
		before = Character.isLetterOrDigit(ch) || (ch == '_');
	    }
	}
	if ((ch = input.charAt(mymatch.index)) != CharIndexed.OUT_OF_BOUNDS) {
	    after = Character.isLetterOrDigit(ch) || (ch == '_');
	}
	// if (before) and (!after), we're at end (\>)
	// if (after) and (!before), we're at beginning (\<)
	boolean doNext = false;
	if ((where & BEGIN) == BEGIN) {
	    doNext = after && !before;
	}
	if ((where & END) == END) {
	    doNext ^= before && !after;
	}
	if (negated) doNext = !doNext;
	return (doNext ? next(input, mymatch) : false);
    }
    void dump(StringBuffer os) {
	if (where == (BEGIN | END)) {
	    os.append( negated ? ""\\B"" : ""\\b"" );
	} else if (where == BEGIN) {
	    os.append(""\\<"");
	} else {
	    os.append(""\\>"");
	}
    }
}
"
installer.ConsoleInstall,"/*
 * ConsoleInstall.java
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package installer;
import java.io.*;
import java.util.Vector;
/*
 * Performs text-only installation.
 */
public class ConsoleInstall
{
	public ConsoleInstall()
	{
		installer = new Install();
		String appName = installer.getProperty(""app.name"");
		String appVersion = installer.getProperty(""app.version"");
		BufferedReader in = new BufferedReader(new InputStreamReader(
			System.in));
		System.out.println(""*** "" + appName + "" "" + appVersion + "" installer"");
		OperatingSystem os = OperatingSystem.getOperatingSystem();
		String installDir = OperatingSystem.getOperatingSystem()
			.getInstallDirectory(appName,appVersion);
		System.out.print(""Installation directory ["" + installDir + ""]: "");
		System.out.flush();
		String _installDir = readLine(in);
		if(_installDir.length() != 0)
			installDir = _installDir;
		String binDir = OperatingSystem.getOperatingSystem()
			.getShortcutDirectory(appName,appVersion);
		if(binDir != null)
		{
			System.out.print(""Shortcut directory ["" + binDir + ""]: "");
			System.out.flush();
			String _binDir = readLine(in);
			if(_binDir.length() != 0)
				binDir = _binDir;
		}
		int compCount = installer.getIntProperty(""comp.count"");
		Vector components = new Vector(compCount);
		System.out.println(""*** Program components to install"");
		for(int i = 0; i < compCount; i++)
		{
			String fileset = installer.getProperty(""comp."" + i + "".fileset"");
			String osDep = installer.getProperty(""comp."" + i + "".os"");
			if(osDep != null)
			{
				if(!OperatingSystem.getOperatingSystem()
					.getClass().getName().endsWith(osDep))
				{
					continue;
				}
			}
			System.out.print(""Install ""
				+ installer.getProperty(""comp."" + i + "".name"")
				+ "" (""
				+ installer.getProperty(""comp."" + i + "".size"")
				+ ""Kb) [Y/n]? "");
			String line = readLine(in);
			if(line.length() == 0 || line.charAt(0) == 'y'
				|| line.charAt(0) == 'Y')
				components.addElement(fileset);
		}
		System.out.println(""*** Starting installation..."");
		ConsoleProgress progress = new ConsoleProgress();
		InstallThread thread = new InstallThread(
			installer,progress,installDir,binDir,
			0 /* XXX */,components);
		thread.start();
	}
	// private members
	private Install installer;
	private String readLine(BufferedReader in)
	{
		try
		{
			String line = in.readLine();
			if(line == null)
			{
				System.err.println(""\nEOF in input!"");
				System.exit(1);
				// can't happen
				throw new InternalError();
			}
			return line;
		}
		catch(IOException io)
		{
			System.err.println(""\nI/O error: "" + io);
			System.exit(1);
			// can't happen
			throw new InternalError();
		}
	}
}
"
installer.ConsoleProgress,"/*
 * ConsoleProgress.java
 * Copyright (C) 1999, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package installer;
/*
 * Displays install progress when running in text-only mode.
 */
public class ConsoleProgress implements Progress
{
	public void setMaximum(int max)
	{
	}
	public void advance(int value)
	{
	}
	public void done()
	{
		System.out.println(""*** Installation complete"");
	}
	public void error(String message)
	{
		System.err.println(""*** An error occurred: "" + message);
	}
}
"
installer.Install,"/*
 * Install.java - Main class of the installer
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package installer;
import java.io.InputStream;
import java.io.IOException;
import java.util.Properties;
public class Install
{
	public static void main(String[] args)
	{
		if(args.length == 0)
			new SwingInstall();
		else if(args.length == 1 && args[0].equals(""text""))
			new ConsoleInstall();
		else if(args.length == 3 && args[0].equals(""auto""))
			new NonInteractiveInstall(args[1],args[2]);
		else
		{
			System.err.println(""Usage:"");
			System.err.println(""jre -cp <installer JAR> installer.Install [text] (Java 1.1)"");
			System.err.println(""java -jar <installer JAR> [text] (Java 2)"");
			System.err.println(""text parameter starts installer in text-only mode"");
		}
	}
	public Install()
	{
		props = new Properties();
		try
		{
			InputStream in = getClass().getResourceAsStream(""install.props"");
			props.load(in);
			in.close();
		}
		catch(IOException io)
		{
			System.err.println(""Error loading 'install.props':"");
			io.printStackTrace();
		}
	}
	public String getProperty(String name)
	{
		return props.getProperty(name);
	}
	public int getIntProperty(String name)
	{
		try
		{
			return Integer.parseInt(props.getProperty(name));
		}
		catch(Exception e)
		{
			return -1;
		}
	}
	// private members
	private Properties props;
}
"
installer.InstallThread,"/*
 * InstallThread.java
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package installer;
import java.io.*;
import java.util.Vector;
/*
 * The thread that performs installation.
 */
public class InstallThread extends Thread
{
	public InstallThread(Install installer, Progress progress,
		String installDir, String binDir, int size, Vector components)
	{
		super(""Install thread"");
		this.installer = installer;
		this.progress = progress;
		this.installDir = installDir;
		this.binDir = binDir;
		this.size = size;
		this.components = components;
		buf = new byte[32768];
	}
	public void setProgress(Progress progress)
	{
		this.progress = progress;
	}
	public void run()
	{
		progress.setMaximum(size * 1024);
		try
		{
			for(int i = 0; i < components.size(); i++)
			{
				installComponent((String)components.elementAt(i));
			}
			// create it in case it doesn't already exist
			if(binDir != null)
				OperatingSystem.getOperatingSystem().mkdirs(binDir);
			OperatingSystem.getOperatingSystem().createScript(
				installer,installDir,binDir,
				installer.getProperty(""app.name""));
		}
		catch(IOException io)
		{
			progress.error(io.toString());
			return;
		}
		progress.done();
	}
	// private members
	private Install installer;
	private Progress progress;
	private String installDir;
	private String binDir;
	private int size;
	private Vector components;
	private byte[] buf;
	private void installComponent(String name) throws IOException
	{
		BufferedReader fileList = new BufferedReader(
			new InputStreamReader(getClass()
			.getResourceAsStream(name)));
		String fileName;
		while((fileName = fileList.readLine()) != null)
		{
			String outfile = installDir + File.separatorChar
				+ fileName.replace('/',File.separatorChar);
			InputStream in = new BufferedInputStream(
				getClass().getResourceAsStream(""/"" + fileName));
			if(in == null)
				throw new FileNotFoundException(fileName);
			copy(in,outfile);
			in.close();
		}
		fileList.close();
	}
	private void copy(InputStream in, String outfile) throws IOException
	{
		File outFile = new File(outfile);
		OperatingSystem.getOperatingSystem().mkdirs(outFile.getParent());
		BufferedOutputStream out = new BufferedOutputStream(
			new FileOutputStream(outFile));
		int count;
		for(;;)
		{
			count = in.read(buf,0,buf.length);
			if(count == -1)
				break;
			out.write(buf,0,count);
			progress.advance(count);
		}
		in.close();
		out.close();
	}
}
"
installer.NonInteractiveInstall,"/*
 * NonInteractiveInstall.java
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package installer;
import java.io.*;
import java.util.Vector;
/*
 * Performs non-interactive installation.
 */
public class NonInteractiveInstall
{
	public NonInteractiveInstall(String installDir, String binDir)
	{
		installer = new Install();
		OperatingSystem os = OperatingSystem.getOperatingSystem();
		int compCount = installer.getIntProperty(""comp.count"");
		Vector components = new Vector(compCount);
		for(int i = 0; i < compCount; i++)
		{
			String fileset = installer.getProperty(""comp."" + i + "".fileset"");
			String osDep = installer.getProperty(""comp."" + i + "".os"");
			if(osDep != null)
			{
				if(!OperatingSystem.getOperatingSystem()
					.getClass().getName().endsWith(osDep))
				{
					continue;
				}
			}
			components.addElement(fileset);
		}
		ConsoleProgress progress = new ConsoleProgress();
		InstallThread thread = new InstallThread(
			installer,progress,installDir,binDir,
			0 /* XXX */,components);
		thread.start();
	}
	// private members
	private Install installer;
}
"
installer.OperatingSystem,"/*
 * OperatingSystem.java
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package installer;
import java.io.*;
/*
 * Abstracts away operating-specific stuff, like finding out the installation
 * directory, creating a shortcut to start to program, and such.
 */
public abstract class OperatingSystem
{
	public abstract String getInstallDirectory(String name, String version);
	public String getShortcutDirectory(String name, String version)
	{
		return null;
	}
	public void createScript(Install installer, String installDir,
		String binDir, String name) throws IOException {}
	public void mkdirs(String directory) throws IOException
	{
		File file = new File(directory);
		if(!file.exists())
			file.mkdirs();
	}
	public static OperatingSystem getOperatingSystem()
	{
		if(os != null)
			return os;
		String osName = System.getProperty(""os.name"");
		if(osName.indexOf(""Windows"") != -1)
			os = new Windows();
		else if(osName.indexOf(""Mac"") != -1)
			os = new MacOS();
		else if(osName.indexOf(""OS/2"") != -1)
			os = new HalfAnOS();
		else
			os = new Unix();
		return os;
	}
	public static class MacOS extends OperatingSystem
	{
		public String getInstallDirectory(String name, String version)
		{
			return ""/Applications/"" + name + "" "" + version;
		}
	}
	public static class Unix extends OperatingSystem
	{
		public String getInstallDirectory(String name, String version)
		{
			return ""/usr/local/share/"" + name.toLowerCase()
				+ ""/"" + version;
		}
		public String getShortcutDirectory(String name, String version)
		{
			return ""/usr/local/bin"";
		}
		public void createScript(Install installer,
			String installDir, String binDir, String name)
			throws IOException
		{
			// create app start script
			String script = binDir + File.separatorChar
				+ name.toLowerCase();
			// Delete existing copy
			new File(script).delete();
			// Write simple script
			FileWriter out = new FileWriter(script);
			out.write(""#!/bin/sh\n"");
			out.write(""# Java heap size, in megabytes (see doc/README.txt)\n"");
			out.write(""JAVA_HEAP_SIZE=32\n"");
			out.write(""exec ""
				+ System.getProperty(""java.home"")
				+ ""/bin/java -mx${JAVA_HEAP_SIZE}m ${""
				+ name.toUpperCase() + ""} "");
			String jar = installDir + File.separator
				+ name.toLowerCase() + "".jar"";
			if(System.getProperty(""java.version"").compareTo(""1.2"") >= 0)
			{
				out.write(""-jar \"""" + jar + ""\"" "");
			}
			else
			{
				out.write(""-classpath \""${CLASSPATH}:""
					+ jar + ""\"" ""
					+ installer.getProperty(""app.main.class""));
			}
			out.write("" $@\n"");
			out.close();
			// Make it executable
			String[] chmodArgs = { ""chmod"", ""755"", script };
			exec(chmodArgs);
		}
		public void mkdirs(String directory) throws IOException
		{
			File file = new File(directory);
			if(!file.exists())
			{
				String[] mkdirArgs = { ""mkdir"", ""-m"", ""755"",
					""-p"", directory };
				exec(mkdirArgs);
			}
		}
		public void exec(String[] args) throws IOException
		{
			Process proc = Runtime.getRuntime().exec(args);
			proc.getInputStream().close();
			proc.getOutputStream().close();
			proc.getErrorStream().close();
			try
			{
				proc.waitFor();
			}
			catch(InterruptedException ie)
			{
			}
		}
	}
	public static class Windows extends OperatingSystem
	{
		public String getInstallDirectory(String name, String version)
		{
			return ""C:\\Program Files\\"" + name + "" "" + version;
		}
		public void createScript(Install installer,
			String installDir, String binDir, String name)
			throws IOException
		{
			// run jEditLauncher installation
			File executable = new File(installDir,""jedit.exe"");
			if(!executable.exists())
				return;
			String[] args = { executable.getPath(), ""/i"",
				System.getProperty(""java.home"")
				+ File.separator
				+ ""bin"" };
			try
			{
				Runtime.getRuntime().exec(args).waitFor();
			}
			catch(InterruptedException ie)
			{
			}
		}
	}
	public static class HalfAnOS extends OperatingSystem
	{
		public String getInstallDirectory(String name, String version)
		{
			return ""C:\\"" + name + "" "" + version;
		}
	}
	// private members
	private static OperatingSystem os;
}
"
installer.Progress,"/*
 * Progress.java
 * Copyright (C) 1999, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package installer;
/*
 * An interface for reporting installation progress. ConsoleProgress and
 * SwingProcess are the two existing implementations.
 */
public interface Progress
{
	public void setMaximum(int max);
	public void advance(int value);
	public void done();
	public void error(String message);
}
"
installer.SwingInstall,"/*
 * SwingInstall.java
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package installer;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
/*
 * Graphical front-end to installer.
 */
public class SwingInstall extends JFrame
{
	public SwingInstall()
	{
		installer = new Install();
		appName = installer.getProperty(""app.name"");
		appVersion = installer.getProperty(""app.version"");
		setTitle(appName + "" "" + appVersion + "" installer"");
		JPanel content = new JPanel(new WizardLayout());
		setContentPane(content);
		caption = new JLabel();
		caption.setFont(new Font(""SansSerif"",Font.BOLD,18));
		ActionHandler actionHandler = new ActionHandler();
		cancelButton = new JButton(""Cancel"");
		cancelButton.setRequestFocusEnabled(false);
		cancelButton.addActionListener(actionHandler);
		prevButton = new JButton(""Previous"");
		prevButton.setRequestFocusEnabled(false);
		prevButton.addActionListener(actionHandler);
		nextButton = new JButton();
		nextButton.setRequestFocusEnabled(false);
		nextButton.addActionListener(actionHandler);
		content.add(caption);
		content.add(cancelButton);
		content.add(prevButton);
		content.add(nextButton);
		pages = new Component[] {
			new About(),
			chooseDirectory = new ChooseDirectory(),
			selectComponents = new SelectComponents(),
			progress = new SwingProgress(),
			new Complete()
		};
		for(int i = 0; i < pages.length; i++)
			content.add(pages[i]);
		pageChanged();
		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowHandler());
		Dimension screen = getToolkit().getScreenSize();
		pack();
		setLocation((screen.width - getSize().width) / 2,
			(screen.height - getSize().height) / 2);
		show();
	}
	// package-private members
	Install installer;
	String appName;
	String appVersion;
	JLabel caption;
	ChooseDirectory chooseDirectory;
	SelectComponents selectComponents;
	SwingProgress progress;
	JButton cancelButton;
	JButton prevButton;
	JButton nextButton;
	Component[] pages;
	int currentPage;
	private static final int PADDING = 12;
	void install()
	{
		Vector components = new Vector();
		int size = 0;
		JPanel comp = selectComponents.comp;
		for(int i = 0; i < comp.getComponentCount(); i++)
		{
			if(((JCheckBox)comp.getComponent(i))
				.getModel().isSelected())
			{
				size += installer.getIntProperty(
					""comp."" + i + "".size"");
				components.addElement(installer.getProperty(
					""comp."" + i + "".fileset""));
			}
		}
		JTextField binDir = chooseDirectory.binDir;
		String installDir = chooseDirectory.installDir.getText();
		InstallThread thread = new InstallThread(
			installer,progress,
			(installDir == null ? null : installDir),
			(binDir == null ? null : binDir.getText()),
			size,components);
		progress.setThread(thread);
		thread.start();
	}
	private void pageChanged()
	{
		switch(currentPage)
		{
		case 0:
			caption.setText(""Installing "" + appName);
			nextButton.setText(""Next"");
			prevButton.setEnabled(false);
			break;
		case 1:
			caption.setText(""Specify where "" + appName
				+ "" is to be installed"");
			nextButton.setText(""Next"");
			prevButton.setEnabled(true);
			break;
		case 2:
			caption.setText(""Choose components to install"");
			nextButton.setText(""Install"");
			prevButton.setEnabled(true);
			break;
		case 3:
			caption.setText(""Installing "" + appName);
			nextButton.setText(""Finish"");
			prevButton.setEnabled(false);
			nextButton.setEnabled(false);
			install();
			break;
		case 4:;
			caption.setText(""Installation complete"");
			nextButton.setText(""Finish"");
			prevButton.setEnabled(false);
			nextButton.setEnabled(true);
			break;
		}
		getRootPane().invalidate();
		getRootPane().validate();
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(evt.getSource() == cancelButton)
				System.exit(0);
			else if(evt.getSource() == prevButton)
			{
				currentPage--;
				pageChanged();
			}
			else if(evt.getSource() == nextButton)
			{
				if(currentPage == pages.length - 1)
					System.exit(0);
				else
				{
					currentPage++;
					pageChanged();
				}
			}
		}
	}
	class WindowHandler extends WindowAdapter
	{
		public void windowClosing(WindowEvent evt)
		{
			System.exit(0);
		}
	}
	class WizardLayout implements LayoutManager
	{
		public void addLayoutComponent(String name, Component comp)
		{
		}
		public void removeLayoutComponent(Component comp)
		{
		}
		public Dimension preferredLayoutSize(Container parent)
		{
			Dimension dim = new Dimension();
			Dimension captionSize = caption.getPreferredSize();
			dim.width = captionSize.width;
			for(int i = 0; i < pages.length; i++)
			{
				Dimension _dim = pages[i].getPreferredSize();
				dim.width = Math.max(_dim.width,dim.width);
				dim.height = Math.max(_dim.height,dim.height);
			}
			dim.width += PADDING * 2;
			dim.height += PADDING * 2;
			dim.height += nextButton.getPreferredSize().height;
			dim.height += captionSize.height;
			return dim;
		}
		public Dimension minimumLayoutSize(Container parent)
		{
			return preferredLayoutSize(parent);
		}
		public void layoutContainer(Container parent)
		{
			Dimension size = parent.getSize();
			Dimension captionSize = caption.getPreferredSize();
			caption.setBounds(PADDING,PADDING,captionSize.width,
				captionSize.height);
			// make all buttons the same size
			Dimension buttonSize = cancelButton.getPreferredSize();
			buttonSize.width = Math.max(buttonSize.width,prevButton.getPreferredSize().width);
			buttonSize.width = Math.max(buttonSize.width,nextButton.getPreferredSize().width);
			int bottomBorder = buttonSize.height + PADDING;
			// cancel button goes on far left
			cancelButton.setBounds(
				PADDING,
				size.height - buttonSize.height - PADDING,
				buttonSize.width,
				buttonSize.height);
			// prev and next buttons are on the right
			prevButton.setBounds(
				size.width - buttonSize.width * 2 - 6 - PADDING,
				size.height - buttonSize.height - PADDING,
				buttonSize.width,
				buttonSize.height);
			nextButton.setBounds(
				size.width - buttonSize.width - PADDING,
				size.height - buttonSize.height - PADDING,
				buttonSize.width,
				buttonSize.height);
			// calculate size for current page
			Rectangle currentPageBounds = new Rectangle();
			currentPageBounds.x = PADDING;
			currentPageBounds.y = PADDING * 2 + captionSize.height;
			currentPageBounds.width = size.width - currentPageBounds.x
				- PADDING;
			currentPageBounds.height = size.height - buttonSize.height
				- currentPageBounds.y - PADDING * 2;
			for(int i = 0; i < pages.length; i++)
			{
				Component page = pages[i];
				page.setBounds(currentPageBounds);
				page.setVisible(i == currentPage);
			}
		}
	}
	class About extends JPanel
	{
		About()
		{
			super(new BorderLayout());
			JEditorPane text = new JEditorPane();
			String readme = installer.getProperty(""app.readme"");
			try
			{
				text.setPage(About.this.getClass().getResource(readme));
			}
			catch(Exception e)
			{
				text.setText(""Error loading '"" + readme + ""'"");
				e.printStackTrace();
			}
			text.setEditable(false);
			JScrollPane scrollPane = new JScrollPane(text);
			Dimension dim = new Dimension();
			dim.height = 200;
			scrollPane.setPreferredSize(dim);
			About.this.add(BorderLayout.CENTER,scrollPane);
		}
	}
	class ChooseDirectory extends JPanel
	implements ActionListener
	{
		JTextField installDir;
		JButton chooseInstall;
		JTextField binDir;
		JButton chooseBin;
		ChooseDirectory()
		{
			super(new BorderLayout());
			String _binDir = OperatingSystem.getOperatingSystem()
				.getShortcutDirectory(appName,appVersion);
			JPanel directoryPanel = new JPanel();
			GridBagLayout layout = new GridBagLayout();
			directoryPanel.setLayout(layout);
			GridBagConstraints cons = new GridBagConstraints();
			cons.anchor = GridBagConstraints.WEST;
			cons.fill = GridBagConstraints.HORIZONTAL;
			cons.gridy = 1;
			cons.insets = new Insets(0,0,6,0);
			JLabel label = new JLabel(""Install program in: "",SwingConstants.RIGHT);
			label.setBorder(new EmptyBorder(0,0,0,12));
			layout.setConstraints(label,cons);
			directoryPanel.add(label);
			cons.weightx = 1.0f;
			installDir = new JTextField();
			installDir.setText(OperatingSystem.getOperatingSystem()
				.getInstallDirectory(appName,appVersion));
			layout.setConstraints(installDir,cons);
			directoryPanel.add(installDir);
			if(_binDir != null)
			{
				cons.gridy = 2;
				cons.weightx = 0.0f;
				cons.insets = new Insets(0,0,0,0);
				label = new JLabel(""Install shortcut in: "",SwingConstants.RIGHT);
				label.setBorder(new EmptyBorder(0,0,0,12));
				layout.setConstraints(label,cons);
				directoryPanel.add(label);
				cons.weightx = 1.0f;
				binDir = new JTextField(_binDir);
				layout.setConstraints(binDir,cons);
				directoryPanel.add(binDir);
			}
			ChooseDirectory.this.add(BorderLayout.NORTH,directoryPanel);
			Box buttons = new Box(BoxLayout.X_AXIS);
			buttons.add(Box.createGlue());
			chooseInstall = new JButton(""Choose Install Directory..."");
			chooseInstall.setRequestFocusEnabled(false);
			chooseInstall.addActionListener(this);
			buttons.add(chooseInstall);
			if(_binDir != null)
			{
				buttons.add(Box.createHorizontalStrut(6));
				chooseBin = new JButton(""Choose Shortcut Directory..."");
				chooseBin.setRequestFocusEnabled(false);
				chooseBin.addActionListener(this);
				buttons.add(chooseBin);
			}
			buttons.add(Box.createGlue());
			ChooseDirectory.this.add(BorderLayout.SOUTH,buttons);
		}
		public void actionPerformed(ActionEvent evt)
		{
			JTextField field = (evt.getSource() == chooseInstall
				? installDir : binDir);
			File directory = new File(field.getText());
			JFileChooser chooser = new JFileChooser(directory.getParent());
			chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
			chooser.setSelectedFile(directory);
			if(chooser.showOpenDialog(SwingInstall.this)
				== JFileChooser.APPROVE_OPTION)
				field.setText(chooser.getSelectedFile().getPath());
		}
	}
	class SelectComponents extends JPanel
	implements ActionListener
	{
		JPanel comp;
		JLabel sizeLabel;
		Vector filesets;
		SelectComponents()
		{
			super(new BorderLayout());
			comp = createCompPanel();
			SelectComponents.this.add(BorderLayout.NORTH,comp);
			sizeLabel = new JLabel("""",SwingConstants.LEFT);
			SelectComponents.this.add(BorderLayout.SOUTH,sizeLabel);
			updateSize();
		}
		public void actionPerformed(ActionEvent evt)
		{
			updateSize();
		}
		private JPanel createCompPanel()
		{
			filesets = new Vector();
			int count = installer.getIntProperty(""comp.count"");
			JPanel panel = new JPanel(new GridLayout(count,1));
			String osClass = OperatingSystem.getOperatingSystem()
				.getClass().getName();
			osClass = osClass.substring(osClass.indexOf('$') + 1);
			for(int i = 0; i < count; i++)
			{
				String os = installer.getProperty(""comp."" + i + "".os"");
				if(os != null && !osClass.equals(os))
					continue;
				JCheckBox checkBox = new JCheckBox(
					installer.getProperty(""comp."" + i + "".name"")
					+ "" ("" + installer.getProperty(""comp."" + i + "".size"")
					+ ""Kb)"");
				checkBox.getModel().setSelected(true);
				checkBox.addActionListener(this);
				checkBox.setRequestFocusEnabled(false);
				filesets.addElement(new Integer(i));
				panel.add(checkBox);
			}
			Dimension dim = panel.getPreferredSize();
			dim.width = Integer.MAX_VALUE;
			panel.setMaximumSize(dim);
			return panel;
		}
		private void updateSize()
		{
			int size = 0;
			for(int i = 0; i < filesets.size(); i++)
			{
				if(((JCheckBox)comp.getComponent(i))
					.getModel().isSelected())
				{
					size += installer.getIntProperty(""comp.""
						+ filesets.elementAt(i)
						+ "".size"");
				}
			}
			sizeLabel.setText(""Estimated disk usage of selected""
				+ "" components: "" + size + ""Kb"");
		}
	}
	class SwingProgress extends JPanel implements Progress
	{
		JProgressBar progress;
		InstallThread thread;
		SwingProgress()
		{
			super(new BorderLayout());
			progress = new JProgressBar();
			progress.setStringPainted(true);
			SwingProgress.this.add(BorderLayout.NORTH,progress);
		}
		public void setMaximum(final int max)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					progress.setMaximum(max);
				}
			});
		}
		public void advance(final int value)
		{
			try
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						progress.setValue(progress
							.getValue() + value);
					}
				});
				Thread.yield();
			}
			catch(Exception e)
			{
			}
		}
		public void done()
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					currentPage++;
					pageChanged();
				}
			});
		}
		public void error(final String message)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					dispose();
					JOptionPane.showMessageDialog(null,
						message,
						""Installation aborted"",
						JOptionPane.ERROR_MESSAGE);
					System.exit(1);
				}
			});
		}
		public void setThread(InstallThread thread)
		{
			this.thread = thread;
		}
	}
	class Complete extends JPanel
	{
		Complete()
		{
			super(new BorderLayout());
			JEditorPane text = new JEditorPane();
			String clazz = OperatingSystem.getOperatingSystem()
				.getClass().getName();
			String readme = ""done-"" + clazz.substring(clazz.indexOf('$') + 1) + "".html"";
			try
			{
				text.setPage(Complete.this.getClass().getResource(readme));
			}
			catch(Exception e)
			{
				text.setText(""Error loading '"" + readme + ""'"");
				e.printStackTrace();
			}
			text.setEditable(false);
			JScrollPane scrollPane = new JScrollPane(text);
			Dimension dim = new Dimension();
			dim.height = 200;
			scrollPane.setPreferredSize(dim);
			Complete.this.add(BorderLayout.CENTER,scrollPane);
		}
	}
}
"
jars.Firewall.FirewallOptionPane,"/*
 * FirewallOptionPane.java - Firewall plugin options panel
 * Copyright (C) 1999 Dirk Moebius
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;
import org.gjt.sp.jedit.*;
public class FirewallOptionPane extends AbstractOptionPane {
    // private members
    private JCheckBox      cEnabled;
    private JTextField     tHost;
    private JTextField     tPort;
    private JTextField     tUser;
    private JPasswordField tPass;
    private JTextField     tNonProxy;
    public FirewallOptionPane() {
        super(""firewall"");
    }
    public void _init()
    {
        // checkbox ""Enable firewall authentication""
        addComponent(cEnabled = new JCheckBox(jEdit.getProperty(
            ""options.firewall.enabled"")));
        // proxy host
        addComponent(jEdit.getProperty(""options.firewall.host""), 
            tHost = new JTextField(jEdit.getProperty(""firewall.host""), 15));
        // proxy port
        addComponent(jEdit.getProperty(""options.firewall.port""), 
            tPort = new JTextField(jEdit.getProperty(""firewall.port""), 15));
        // proxy username
        addComponent(jEdit.getProperty(""options.firewall.user""),
            tUser = new JTextField(jEdit.getProperty(""firewall.user""), 15));
        // proxy password
        addComponent(jEdit.getProperty(""options.firewall.password""),
            tPass = new JPasswordField(jEdit.getProperty(""firewall.password""), 15));
        // no proxy for
        addComponent(jEdit.getProperty(""options.firewall.nonProxy""),
            tNonProxy = new JTextField(jEdit.getProperty(""firewall.nonProxyHosts""), 15));
        boolean enabled = jEdit.getBooleanProperty(""firewall.enabled"");
        cEnabled.setSelected(enabled);
        tHost.setEnabled(enabled);
        tPort.setEnabled(enabled);
        tUser.setEnabled(enabled);
        tPass.setEnabled(enabled);
        tNonProxy.setEnabled(enabled);
        cEnabled.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                boolean enbld = cEnabled.isSelected();
                cEnabled.setSelected(enbld);
                tHost.setEnabled(enbld);
                tPort.setEnabled(enbld);
                tUser.setEnabled(enbld);
                tPass.setEnabled(enbld);
                tNonProxy.setEnabled(enbld);
            }
        });
    }
    /**
     * Called when the options dialog's `OK' button is pressed.
     * This should save any properties saved in this option pane.
     */
    public void _save() {
        jEdit.setBooleanProperty(""firewall.enabled"", cEnabled.isSelected());
        jEdit.setProperty(""firewall.host"", tHost.getText());            
        jEdit.setProperty(""firewall.port"", tPort.getText());
        jEdit.setProperty(""firewall.user"", tUser.getText());
        jEdit.setProperty(""firewall.password"", new String(tPass.getPassword()));
        jEdit.setProperty(""firewall.nonProxyHosts"", tNonProxy.getText());
    }
}
"
jars.Firewall.FirewallPlugin,"/*
 * FirewallPlugin.java - a firewall authenticator plugin for jEdit
 * Copyright (C) 1999 Dirk Moebius
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
import java.net.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.OptionsDialog;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.util.Log;
/**
 * FirewallPlugin - a firewall authenticator plugin for jEdit
 * @author Dirk Moebius <dmoebius@gmx.net>
 * @version 0.2.1
 */
public class FirewallPlugin extends EBPlugin {
    // begin EBPlugin implementation
    public void start() { 
        propertiesChanged();
    }
    public void createOptionPanes(OptionsDialog optionsDialog) {
        optionsDialog.addOptionPane(new FirewallOptionPane());
    }
    public void handleMessage(EBMessage msg) {
        if (msg instanceof PropertiesChanged) {
            propertiesChanged();
        }
    }
    // end EBPlugin implementation
    private void propertiesChanged() {
        boolean enabled = jEdit.getBooleanProperty(""firewall.enabled"");
        if (!enabled) {
            Log.log(Log.DEBUG, this, ""Firewall disabled"");
            System.getProperties().remove(""proxySet"");
            System.getProperties().remove(""proxyHost"");
            System.getProperties().remove(""proxyPort"");        
            System.getProperties().remove(""http.proxyHost"");
            System.getProperties().remove(""http.proxyPort"");
            System.getProperties().remove(""http.nonProxyHosts"");
            Authenticator.setDefault(null);
        } else {
            // set proxy host
            String host = jEdit.getProperty(""firewall.host"");
            if (host == null) {
                return;
            }
            System.setProperty(""http.proxyHost"", host);
            Log.log(Log.DEBUG, this, ""Firewall enabled: "" + host);
            // set proxy port
            String port = jEdit.getProperty(""firewall.port"");
            if (port != null) {
                System.setProperty(""http.proxyPort"", port);
            }
            // set non proxy hosts list
            String nonProxyHosts = jEdit.getProperty(""firewall.nonProxyHosts"");
            if (nonProxyHosts != null) {
                System.setProperty(""http.nonProxyHosts"", nonProxyHosts);
            }
            // set proxy authentication
            String username = jEdit.getProperty(""firewall.user"");
            if (username == null || username.length()==0) {
                Log.log(Log.DEBUG, this, ""Firewall without user"");
                Authenticator.setDefault(new FirewallAuthenticator(null));
            } else {
                Log.log(Log.DEBUG, this, ""Firewall user: "" + username);
                PasswordAuthentication pw = new PasswordAuthentication(
                    username, 
                    jEdit.getProperty(""firewall.password"").toCharArray()
                );
                Authenticator.setDefault(new FirewallAuthenticator(pw));
            }
        }
    }
}
class FirewallAuthenticator extends Authenticator {
    PasswordAuthentication pw = null;
    public FirewallAuthenticator(PasswordAuthentication pw) {
        this.pw = pw;
    }
    protected PasswordAuthentication getPasswordAuthentication() {
        return pw;
    }
}
"
jars.LatestVersion.LatestVersionPlugin,"/*
 * LatestVersionPlugin.java - Latest Version Check Plugin
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
import javax.swing.JOptionPane;
import java.awt.event.ActionEvent;
import java.io.*;
import java.net.URL;
import java.util.Vector;
import org.gjt.sp.jedit.*;
public class LatestVersionPlugin extends EditPlugin
{
	public void createMenuItems(Vector menuItems)
	{
		menuItems.addElement(GUIUtilities.loadMenuItem(""version-check""));
	}
	public static void doVersionCheck(View view)
	{
		view.showWaitCursor();
		try
		{
			URL url = new URL(jEdit.getProperty(
				""version-check.url""));
			InputStream in = url.openStream();
			BufferedReader bin = new BufferedReader(
				new InputStreamReader(in));
			String line;
			String version = null;
			String build = null;
			while((line = bin.readLine()) != null)
			{
				if(line.startsWith("".version""))
					version = line.substring(8).trim();
				else if(line.startsWith("".build""))
					build = line.substring(6).trim();
			}
			bin.close();
			if(version != null && build != null)
			{
				if(jEdit.getBuild().compareTo(build) < 0)
					newVersionAvailable(view,version,url);
				else
				{
					GUIUtilities.message(view,""version-check""
						+ "".up-to-date"",new String[0]);
				}
			}
		}
		catch(IOException e)
		{
			String[] args = { jEdit.getProperty(""version-check.url""),
				e.toString() };
			GUIUtilities.error(view,""read-error"",args);
		}
		view.hideWaitCursor();
	}
	public static void newVersionAvailable(View view, String version, URL url)
	{
		String[] args = { version };
		int result = GUIUtilities.confirm(view,""version-check.new-version"",
			args,JOptionPane.YES_NO_OPTION,JOptionPane.INFORMATION_MESSAGE);
		if(result == JOptionPane.YES_OPTION)
			jEdit.openFile(view,url.toString());
	}
}
"
jars.QuickNotepad.QuickNotepad,"/*
 * QuickNotepad.java
 * part of the QuickNotepad plugin for the jEdit text editor
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id$
 */
// from Java:
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.Vector;
// from Swing:
import javax.swing.*;
import javax.swing.event.*;
// from jEdit:
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.msg.CreateDockableWindow;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.util.Log;
public class QuickNotepad extends JPanel implements EBComponent, QuickNotepadActions
{
	private String filename;
	private String defaultFilename;
    private View view;
	private boolean floating;
	private QuickNotepadTextArea textArea;
	private QuickNotepadToolPanel toolPanel;
	//
	// Constructor
	//
    public QuickNotepad(View view, String position)
	{
		super(new BorderLayout());
        this.view = view;
		this.floating  = position.equals(DockableWindowManager.FLOATING);
		this.filename = jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""filepath"");
		if(this.filename == null || this.filename.length() == 0)
		{
			this.filename = new String(jEdit.getSettingsDirectory()
				+ File.separator + ""qn.txt"");
			jEdit.setProperty(
				QuickNotepadPlugin.OPTION_PREFIX + ""filepath"",
				this.filename);
		}
		this.defaultFilename = new String(this.filename);
		this.toolPanel = new QuickNotepadToolPanel(this);
		add(BorderLayout.NORTH, this.toolPanel);
		if(floating)
			this.setPreferredSize(new Dimension(500, 250));
		textArea = new QuickNotepadTextArea();
		textArea.setFont(QuickNotepadOptionPane.makeFont());
		textArea.addKeyListener(new KeyHandler());
		textArea.addAncestorListener(new AncestorHandler());
        JScrollPane pane = new JScrollPane(textArea);
        add(BorderLayout.CENTER, pane);
		readFile();
    }
	//
	// Attribute methods
	//
	// for toolbar display
	public String getFilename()
	{
		return filename;
	}
	//
	// EBComponent implementation
	//
    public void handleMessage(EBMessage message)
	{
        if (message instanceof PropertiesChanged)
		{
            propertiesChanged();
        }
    }
    private void propertiesChanged()
	{
		String propertyFilename = jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""filepath"");
		if(!defaultFilename.equals(propertyFilename))
		{
			saveFile();
			toolPanel.propertiesChanged();
			defaultFilename = new String(propertyFilename);
			filename = new String(defaultFilename);
			readFile();
		}
		Font newFont = QuickNotepadOptionPane.makeFont();
		if(!newFont.equals(textArea.getFont()))
		{
			textArea.setFont(newFont);
			textArea.invalidate();
		}
	}
	// These JComponent methods provide the appropriate points
	// to subscribe and unsubscribe this object to the EditBus
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	}
	public void removeNotify()
	{
		saveFile();
		super.removeNotify();
		EditBus.removeFromBus(this);
	}
	//
	// QuickNotepadActions implementation
	//
	public void saveFile()
	{
		if(filename.length() == 0) return;
		try
		{
			DataOutputStream dos = new DataOutputStream(
			new FileOutputStream(filename));
			dos.writeBytes(textArea.getText());
			dos.close();
		}
		catch (IOException ioe)
		{
			Log.log(Log.ERROR, QuickNotepad.class,
				""Could not write notepad text to "" + filename);
		}
    }
	public void chooseFile()
	{
		String[] paths = GUIUtilities.showVFSFileDialog(view,
			null,JFileChooser.OPEN_DIALOG,false);
		if(paths != null && !paths[0].equals(filename))
		{
			saveFile();
			filename = paths[0];
			toolPanel.propertiesChanged();
			readFile();
		}
	}
	public void copyToBuffer()
	{
		jEdit.newFile(view);
		view.getEditPane().getTextArea().setText(textArea.getText());
	}
	//
	// helper methods
	//
	private void readFile()
	{
		FileInputStream fis = null;
		BufferedReader bf = null;
		try
		{
			fis = new FileInputStream(filename);
			bf = new BufferedReader(new InputStreamReader(fis));
			StringBuffer sb = new StringBuffer(2048);
			String str;
			while((str = bf.readLine()) != null)
			{
				sb.append(str).append('\n');
			}
       		bf.close();
			fis.close();
			textArea.setText(sb.toString());
   		}
		catch (FileNotFoundException fnf)
		{
			Log.log(Log.ERROR, QuickNotepad.class,
				""notepad file "" + filename + "" does not exist"");
		}
		catch (IOException ioe)
		{
        	Log.log(Log.ERROR, QuickNotepad.class,
				""could not read notepad file "" + filename);
		}
	}
	//
	// Listener objects
	//
	// <Esc> closes a floating window
    private class KeyHandler extends KeyAdapter {
        public void keyPressed(KeyEvent evt) {
			if(QuickNotepad.this.floating &&
            	evt.getKeyCode() == KeyEvent.VK_ESCAPE) {
                evt.consume();
				DockableWindowManager wm =
					QuickNotepad.this.view.getDockableWindowManager();
            	wm.removeDockableWindow(QuickNotepadPlugin.NAME);
            }
        }
    }
	private class AncestorHandler implements AncestorListener
	{
		public void ancestorAdded(AncestorEvent e)
		{
			if(e.getSource() == QuickNotepad.this.textArea)
			{
				if(QuickNotepad.this.floating)
					QuickNotepad.this.textArea.requestFocus();
			}
		}
		public void ancestorMoved(AncestorEvent e) {}
		public void ancestorRemoved(AncestorEvent e) {}
	}
}
"
jars.QuickNotepad.QuickNotepadActions,"/*
 * QuickNotepadActions.java
 * part of the QuickNotepad plugin for the jEdit text editor
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id$
 */
interface QuickNotepadActions
{
	void chooseFile();
	void saveFile();
	void copyToBuffer();
}
"
jars.QuickNotepad.QuickNotepadDockable,"/*
 * QuickNotepadDockable.java
 * part of the QuickNotepad plugin for the jEdit text editor
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id$
 */
import java.awt.Component;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.*;
public class QuickNotepadDockable implements DockableWindow, QuickNotepadActions
{
    private QuickNotepad notepad;
    public QuickNotepadDockable(View view, String position) {
        notepad = new QuickNotepad(view, position);
    }
    public String getName() {
        return QuickNotepadPlugin.NAME;
    }
    public Component getComponent() {
        return notepad;
    }
    public void chooseFile() {
      notepad.chooseFile();
    }
    public void saveFile() {
      notepad.saveFile();
    }
    public void copyToBuffer() {
      notepad.copyToBuffer();
    }
}
"
jars.QuickNotepad.QuickNotepadOptionPane,"/*
 * QuickNotepadOptionPane.java
 * part of the QuickNotepad plugin for the jEdit text editor
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
import java.io.File;
import java.io.IOException;
import java.awt.Font;
import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.JFileChooser;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.AbstractOptionPane;
import org.gjt.sp.jedit.gui.FontSelector;
public class QuickNotepadOptionPane extends AbstractOptionPane
			implements ActionListener
{
	private JCheckBox showPath;
	private JTextField pathName;
	private FontSelector font;
    public QuickNotepadOptionPane()
	{
		super(QuickNotepadPlugin.NAME);
    }
    public void _init()
    {
		showPath = new JCheckBox(jEdit.getProperty(
            QuickNotepadPlugin.OPTION_PREFIX + ""show-filepath.title""),
			jEdit.getProperty(QuickNotepadPlugin.OPTION_PREFIX +
				""show-filepath"").equals(""true""));
		addComponent(showPath);
        pathName = new JTextField(jEdit.getProperty(
            QuickNotepadPlugin.OPTION_PREFIX + ""filepath""));
        JButton pickPath = new JButton(jEdit.getProperty(
            QuickNotepadPlugin.OPTION_PREFIX + ""choose-file""));
        pickPath.addActionListener(this);
        JPanel pathPanel = new JPanel(new BorderLayout(0, 0));
        pathPanel.add(pathName, BorderLayout.CENTER);
        pathPanel.add(pickPath, BorderLayout.EAST);
        addComponent(jEdit.getProperty(
            QuickNotepadPlugin.OPTION_PREFIX + ""file""),
            pathPanel);
        font = new FontSelector(makeFont());
        addComponent(jEdit.getProperty(
            QuickNotepadPlugin.OPTION_PREFIX + ""choose-font""),
            font);
    }
	public void _save()
	{
		jEdit.setProperty(QuickNotepadPlugin.OPTION_PREFIX + ""filepath"",
			pathName.getText());
		Font _font = font.getFont();
		jEdit.setProperty(QuickNotepadPlugin.OPTION_PREFIX + ""font"",
			_font.getFamily());
		jEdit.setProperty(QuickNotepadPlugin.OPTION_PREFIX + ""fontsize"",
			String.valueOf(_font.getSize()));
		jEdit.setProperty(QuickNotepadPlugin.OPTION_PREFIX + ""fontstyle"",
			String.valueOf(_font.getStyle()));
		jEdit.setProperty(QuickNotepadPlugin.OPTION_PREFIX + ""show-filepath"",
			String.valueOf(showPath.isSelected()));
	}
	// end AbstractOptionPane implementation
	// begin ActionListener implementation
	public void actionPerformed(ActionEvent evt)
	{
		String[] paths = GUIUtilities.showVFSFileDialog(null,
			null,JFileChooser.OPEN_DIALOG,false);
		if(paths != null)
		{
			pathName.setText(paths[0]);
		}
	}
	// helper method to get Font from plugin properties
	static public Font makeFont()
	{
		int style, size;
 		String family = jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""font"");
		try
		{
			size = Integer.parseInt(jEdit.getProperty(
				QuickNotepadPlugin.OPTION_PREFIX + ""fontsize""));
		}
		catch(NumberFormatException nf)
		{
			size = 14;
		}
		try
		{
			style = Integer.parseInt(jEdit.getProperty(
				QuickNotepadPlugin.OPTION_PREFIX + ""fontstyle""));
		}
		catch(NumberFormatException nf)
		{
			style = Font.PLAIN;
		}
		return new Font(family, style, size);
	}
}
"
jars.QuickNotepad.QuickNotepadPlugin,"/*
 * QuickNotepadPlugin.java
 * part of the QuickNotepad plugin for the jEdit text editor
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id$
 */
import java.util.Vector;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.msg.CreateDockableWindow;
/**
 * The QuickNotepad plugin
 *
 * @author John Gellene
 */
public class QuickNotepadPlugin extends EBPlugin
{
    public static final String NAME = ""quicknotepad"";
	public static final String MENU = ""quicknotepad.menu"";
    public static final String PROPERTY_PREFIX = ""plugin.QuickNotepadPlugin."";
    public static final String OPTION_PREFIX = ""options.quicknotepad."";
    public void start()
	{
        EditBus.addToNamedList(DockableWindow.DOCKABLE_WINDOW_LIST, NAME);
    }
	public void stop()
	{
	}
    public void createMenuItems(Vector menuItems)
	{
        menuItems.addElement(GUIUtilities.loadMenu(MENU));
    }
    public void createOptionPanes(OptionsDialog od)
	{
        od.addOptionPane(new QuickNotepadOptionPane());
    }
    public void handleMessage(EBMessage message)
	{
        if(message instanceof CreateDockableWindow)
		{
            CreateDockableWindow cmsg = (CreateDockableWindow)message;
            if (cmsg.getDockableWindowName().equals(NAME))
			{
//				try {
//					Runtime.getRuntime().exec(""start cmd /C"");
//				} catch (java.io.IOException e) {}
				DockableWindow win = new QuickNotepadDockable(
					cmsg.getView(), cmsg.getPosition());
				cmsg.setDockableWindow(win);
            }
        }
    }
}
"
jars.QuickNotepad.QuickNotepadTextArea,"/*
 * QuickNotepadTextArea.java
 * part of the QuickNotepad plugin for the jEditTextArea
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id$
 */
import javax.swing.JTextArea;
public class QuickNotepadTextArea extends JTextArea
{
 	public QuickNotepadTextArea()
 	{
		super();
	 	setLineWrap(true);
	 	setWrapStyleWord(true);
	 	setTabSize(4);
 	}
}
"
jars.QuickNotepad.QuickNotepadToolPanel,"/*
 * QuickNotepadToolPanel.java
 * part of the QuickNotepad plugin for the jEdit text editor
 * Copyright (C) 2001 John Gellene
 * jgellene@nyc.rr.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 * $Id$
 */
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.util.Log;
public class QuickNotepadToolPanel extends JPanel
{
	private QuickNotepad pad;
	private JLabel label;
    public QuickNotepadToolPanel(QuickNotepad qnpad)
	{
		pad = qnpad;
        JToolBar toolBar = new JToolBar();
        toolBar.setFloatable(false);
        toolBar.add(makeCustomButton(""quicknotepad.choose-file"",
			new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					QuickNotepadToolPanel.this.pad.chooseFile();
				}
			}));
        toolBar.add(makeCustomButton(""quicknotepad.save-file"",
			new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					QuickNotepadToolPanel.this.pad.saveFile();
				}
			}));
        toolBar.add(makeCustomButton(""quicknotepad.copy-to-buffer"",
			new ActionListener() {
				public void actionPerformed(ActionEvent evt) {
					QuickNotepadToolPanel.this.pad.copyToBuffer();
				}
			}));
		label = new JLabel(pad.getFilename(), SwingConstants.RIGHT);
		label.setForeground(Color.black);
		label.setVisible(jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""show-filepath"").equals(""true""));
        this.setLayout(new BorderLayout(10, 0));
        this.add(BorderLayout.WEST, toolBar);
		this.add(BorderLayout.CENTER, label);
        this.setBorder(BorderFactory.createEmptyBorder(0, 0, 3, 10));
    }
	void propertiesChanged()
	{
		label.setText(pad.getFilename());
		label.setVisible(jEdit.getProperty(
			QuickNotepadPlugin.OPTION_PREFIX + ""show-filepath"").equals(""true""));
	}
    private AbstractButton makeCustomButton(String name, ActionListener listener)
	{
        String icon = jEdit.getProperty(name + "".icon"");
        java.net.URL u = getClass().getResource(icon);
        String toolTip = jEdit.getProperty(name.concat("".label""));
        AbstractButton b = new JButton(new ImageIcon(u));
		if(listener != null)
		{
			b.addActionListener(listener);
			b.setEnabled(true);
		}
		else
		{
			b.setEnabled(false);
		}
        b.setToolTipText(toolTip);
        b.setMargin(new Insets(0,0,0,0));
		b.setAlignmentY(0.0f);
        b.setRequestFocusEnabled(false);
        return b;
    }
}
"
org.gjt.sp.jedit.Abbrevs,"/*
 * Abbrevs.java - Abbreviation manager
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.text.BadLocationException;
import javax.swing.text.Element;
import javax.swing.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.gui.AddAbbrevDialog;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
/**
 * Abbreviation manager.
 * @author Slava Pestov
 * @version $Id: Abbrevs.java,v 1.26 2001/07/12 05:06:52 sp Exp $
 */
public class Abbrevs
{
	/**
	 * Returns if abbreviations should be expanded after the
	 * user finishes typing a word.
	 */
	public static boolean getExpandOnInput()
	{
		return expandOnInput;
	}
	/**
	 * Sets if abbreviations should be expanded after the
	 * user finishes typing a word.
	 * @param true If true, typing a non-alphanumeric characater will
	 * automatically attempt to expand the current abbrev
	 */
	public static void setExpandOnInput(boolean expandOnInput)
	{
		Abbrevs.expandOnInput = expandOnInput;
	}
	/**
	 * Expands the abbrev at the caret position in the specified
	 * view.
	 * @param view The view
	 * @param add If true and abbrev not found, will ask user if
	 * it should be added
	 * @since jEdit 2.6pre4
	 */
	public static boolean expandAbbrev(View view, boolean add)
	{
		JEditTextArea textArea = view.getTextArea();
		if(!textArea.isEditable())
		{
			view.getToolkit().beep();
			return false;
		}
		Buffer buffer = view.getBuffer();
		int line = textArea.getCaretLine();
		int lineStart = textArea.getLineStartOffset(line);
		int caret = textArea.getCaretPosition();
		String lineText = textArea.getLineText(line);
		if(lineText.length() == 0)
		{
			if(add)
				view.getToolkit().beep();
			return false;
		}
		int pos = caret - lineStart;
		if(pos == 0)
		{
			if(add)
				view.getToolkit().beep();
			return false;
		}
		// we reuse the 'pp' vector to save time
		pp.removeAllElements();
		int wordStart;
		String abbrev;
		// handle abbrevs of the form abbrev#pos1#pos2#pos3#...
		if(lineText.charAt(pos-1) == '#')
		{
			wordStart = lineText.indexOf('#');
			wordStart = TextUtilities.findWordStart(lineText,wordStart,
				(String)buffer.getProperty(""noWordSep"") + '#');
			abbrev = lineText.substring(wordStart,pos - 1);
			// positional parameters will be inserted where $1, $2, $3, ...
			// occurs in the expansion
			int lastIndex = 0;
			for(int i = 0; i < abbrev.length(); i++)
			{
				if(abbrev.charAt(i) == '#')
				{
					pp.addElement(abbrev.substring(lastIndex,i));
					lastIndex = i + 1;
				}
			}
			pp.addElement(abbrev.substring(lastIndex));
			// the first element of pp is the abbrev itself
			abbrev = (String)pp.elementAt(0);
		}
		else
		{
			wordStart = TextUtilities.findWordStart(lineText,pos - 1,
				(String)buffer.getProperty(""noWordSep""));
			abbrev = lineText.substring(wordStart,pos);
		}
		Expansion expand = expandAbbrev(buffer.getMode().getName(),
			abbrev,(buffer.getBooleanProperty(""noTabs"") ?
			buffer.getTabSize() : 0),pp);
		if(expand == null)
		{
			if(add)
				new AddAbbrevDialog(view,abbrev);
			return false;
		}
		else
		{
			buffer.beginCompoundEdit();
			try
			{
				// obtain the leading indent for later use
				lineText = buffer.getText(lineStart,wordStart);
				int leadingIndent = MiscUtilities.getLeadingWhiteSpaceWidth(
					lineText,buffer.getTabSize());
				buffer.remove(lineStart + wordStart,pos - wordStart);
				buffer.insertString(lineStart + wordStart,expand.text,null);
				if(expand.caretPosition != -1)
				{
					textArea.setCaretPosition(lineStart + wordStart
						+ expand.caretPosition);
				}
				String whiteSpace = MiscUtilities.createWhiteSpace(
					leadingIndent,buffer.getBooleanProperty(""noTabs"")
					? 0 : buffer.getTabSize());
				Element map = buffer.getDefaultRootElement();
				// note that if expand.lineCount is 0, we
				// don't do any indentation at all
				for(int i = line + 1; i <= line + expand.lineCount; i++)
				{
					Element elem = map.getElement(i);
					buffer.insertString(elem.getStartOffset(),
						whiteSpace,null);
				}
			}
			catch(BadLocationException bl)
			{
				Log.log(Log.ERROR,Abbrevs.class,bl);
			}
			buffer.endCompoundEdit();
			return true;
		}
	}
	/**
	 * Returns the global abbreviation set.
	 * @since jEdit 2.3pre1
	 */
	public static Hashtable getGlobalAbbrevs()
	{
		return globalAbbrevs;
	}
	/**
	 * Sets the global abbreviation set.
	 * @param globalAbbrevs The new global abbrev set
	 * @since jEdit 2.3pre1
	 */
	public static void setGlobalAbbrevs(Hashtable globalAbbrevs)
	{
		abbrevsChanged = true;
		Abbrevs.globalAbbrevs = globalAbbrevs;
	}
	/**
	 * Returns the mode-specific abbreviation set.
	 * @since jEdit 2.3pre1
	 */
	public static Hashtable getModeAbbrevs()
	{
		return modes;
	}
	/**
	 * Sets the mode-specific abbreviation set.
	 * @param globalAbbrevs The new global abbrev set
	 * @since jEdit 2.3pre1
	 */
	public static void setModeAbbrevs(Hashtable modes)
	{
		abbrevsChanged = true;
		Abbrevs.modes = modes;
	}
	/**
	 * Adds an abbreviation to the global abbreviation list.
	 * @param abbrev The abbreviation
	 * @param expansion The expansion
	 * @since jEdit 3.1pre1
	 */
	public static void addGlobalAbbrev(String abbrev, String expansion)
	{
		globalAbbrevs.put(abbrev,expansion);
		abbrevsChanged = true;
	}
	/**
	 * Adds a mode-specific abbrev.
	 * @param mode The edit mode
	 * @param abbrev The abbrev
	 * @param expansion The expansion
	 * @since jEdit 3.1pre1
	 */
	public static void addModeAbbrev(String mode, String abbrev, String expansion)
	{
		Hashtable modeAbbrevs = (Hashtable)modes.get(mode);
		if(modeAbbrevs == null)
		{
			modeAbbrevs = new Hashtable();
			modes.put(mode,modeAbbrevs);
		}
		modeAbbrevs.put(abbrev,expansion);
		abbrevsChanged = true;
	}
	// package-private members
	static void load()
	{
		expandOnInput = jEdit.getBooleanProperty(""view.expandOnInput"");
		globalAbbrevs = new Hashtable();
		modes = new Hashtable();
		boolean loaded = false;
		String settings = jEdit.getSettingsDirectory();
		if(settings != null)
		{
			File file = new File(MiscUtilities.constructPath(settings,""abbrevs""));
			abbrevsModTime = file.lastModified();
			try
			{
				loadAbbrevs(new FileReader(file));
				loaded = true;
			}
			catch(FileNotFoundException fnf)
			{
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,Abbrevs.class,""Error while loading "" + file);
				Log.log(Log.ERROR,Abbrevs.class,e);
			}
		}
		// only load global abbrevs if user abbrevs file could not be loaded
		if(!loaded)
		{
			try
			{
				loadAbbrevs(new InputStreamReader(Abbrevs.class
					.getResourceAsStream(""default.abbrevs"")));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,Abbrevs.class,""Error while loading default.abbrevs"");
				Log.log(Log.ERROR,Abbrevs.class,e);
			}
		}
	}
	static void save()
	{
		jEdit.setBooleanProperty(""view.expandOnInput"",expandOnInput);
		String settings = jEdit.getSettingsDirectory();
		if(abbrevsChanged && settings != null)
		{
			File file = new File(MiscUtilities.constructPath(settings,""abbrevs""));
			if(file.exists() && file.lastModified() != abbrevsModTime)
			{
				Log.log(Log.WARNING,Abbrevs.class,file + "" changed on disk;""
					+ "" will not save abbrevs"");
			}
			else
			{
				try
				{
					saveAbbrevs(new FileWriter(file));
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,Abbrevs.class,""Error while saving "" + file);
					Log.log(Log.ERROR,Abbrevs.class,e);
				}
				abbrevsModTime = file.lastModified();
			}
		}
	}
	// private members
	private static boolean abbrevsChanged;
	private static long abbrevsModTime;
	private static boolean expandOnInput;
	private static Hashtable globalAbbrevs;
	private static Hashtable modes;
	private static Vector pp = new Vector();
	private Abbrevs() {}
	private static Expansion expandAbbrev(String mode, String abbrev,
		int softTabSize, Vector pp)
	{
		// try mode-specific abbrevs first
		String expand = null;
		Hashtable modeAbbrevs = (Hashtable)modes.get(mode);
		if(modeAbbrevs != null)
			expand = (String)modeAbbrevs.get(abbrev);
		if(expand == null)
			expand = (String)globalAbbrevs.get(abbrev);
		if(expand == null)
			return null;
		else
			return new Expansion(expand,softTabSize,pp);
	}
	private static void loadAbbrevs(Reader _in) throws Exception
	{
		BufferedReader in = new BufferedReader(_in);
		Hashtable currentAbbrevs = null;
		String line;
		while((line = in.readLine()) != null)
		{
			if(line.length() == 0)
				continue;
			else if(line.startsWith(""["") && line.indexOf('|') == -1)
			{
				if(line.equals(""[global]""))
					currentAbbrevs = globalAbbrevs;
				else
				{
					String mode = line.substring(1,
						line.length() - 1);
					currentAbbrevs = (Hashtable)modes.get(mode);
					if(currentAbbrevs == null)
					{
						currentAbbrevs = new Hashtable();
						modes.put(mode,currentAbbrevs);
					}
				}
			}
			else
			{
				int index = line.indexOf('|');
				currentAbbrevs.put(line.substring(0,index),
					line.substring(index + 1));
			}
		}
		in.close();
	}
	private static void saveAbbrevs(Writer _out) throws Exception
	{
		BufferedWriter out = new BufferedWriter(_out);
		String lineSep = System.getProperty(""line.separator"");
		// write global abbrevs
		out.write(""[global]"");
		out.write(lineSep);
		saveAbbrevs(out,globalAbbrevs);
		// write mode abbrevs
		Enumeration keys = modes.keys();
		Enumeration values = modes.elements();
		while(keys.hasMoreElements())
		{
			out.write('[');
			out.write((String)keys.nextElement());
			out.write(']');
			out.write(lineSep);
			saveAbbrevs(out,(Hashtable)values.nextElement());
		}
		out.close();
	}
	private static void saveAbbrevs(Writer out, Hashtable abbrevs)
		throws Exception
	{
		String lineSep = System.getProperty(""line.separator"");
		Enumeration keys = abbrevs.keys();
		Enumeration values = abbrevs.elements();
		while(keys.hasMoreElements())
		{
			String abbrev = (String)keys.nextElement();
			out.write(abbrev);
			out.write('|');
			out.write(values.nextElement().toString());
			out.write(lineSep);
		}
	}
	static class Expansion
	{
		String text;
		int caretPosition = -1;
		int lineCount;
		Expansion(String text, int softTabSize, Vector pp)
		{
			StringBuffer buf = new StringBuffer();
			boolean backslash = false;
			for(int i = 0; i < text.length(); i++)
			{
				char ch = text.charAt(i);
				if(backslash)
				{
					backslash = false;
					if(ch == '|')
						caretPosition = buf.length();
					else if(ch == 'n')
					{
						buf.append('\n');
						lineCount++;
					}
					else if(ch == 't')
					{
						if(softTabSize == 0)
							buf.append('\t');
						else
						{
							for(int j = 0; j < softTabSize; j++)
								buf.append(' ');
						}
					}
					else
						buf.append(ch);
				}
				else if(ch == '\\')
					backslash = true;
				else if(ch == '$')
				{
					if(i != text.length() - 1)
					{
						ch = text.charAt(i + 1);
						if(Character.isDigit(ch) && ch != '0')
						{
							i++;
							int pos = ch - '0';
							if(pos < pp.size())
								buf.append(pp.elementAt(pos));
							else
							{
								// so the user knows
								// a positional is
								// expected
								buf.append('$');
								buf.append(ch);
							}
						}
						else
						{
							// $key will be $key, for
							// example
							buf.append('$');
						}
					}
				}
				else
					buf.append(ch);
			}
			this.text = buf.toString();
		}
	}
}
"
org.gjt.sp.jedit.AbstractOptionPane,"/*
 * AbstractOptionPane.java - Abstract option pane
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.*;
/**
 * The default implementation of the option pane interface. It lays out
 * components in a vertical fashion.
 *
 * @see org.gjt.sp.jedit.OptionPane
 */
public abstract class AbstractOptionPane extends JPanel implements OptionPane
{
	/**
	 * Creates a new option pane.
	 * @param name The internal name
	 */
	public AbstractOptionPane(String name)
	{
		this.name = name;
		setLayout(gridBag = new GridBagLayout());
	}
	/**
	 * Returns the internal name of this option pane.
	 */
	public String getName()
	{
		return name;
	}
	/**
	 * Returns the component that should be displayed for this option pane.
	 * Because this class extends Component, it simply returns ""this"".
	 */
	public Component getComponent()
	{
		return this;
	}
	public void init()
	{
		if(!initialized)
		{
			initialized = true;
			_init();
		}
	}
	public void save()
	{
		if(initialized)
			_save();
	}
	// protected members
	/**
	 * Has the option pane been initialized?
	 */
	protected boolean initialized;
	/**
	 * The layout manager.
	 */
	protected GridBagLayout gridBag;
	/**
	 * The number of components already added to the layout manager.
	 */
	protected int y;
	/**
	 * This method should create the option pane's GUI.
	 */
	protected void _init() {}
	/**
	 * Called when the options dialog's ""ok"" button is clicked.
	 * This should save any properties being edited in this option
	 * pane.
	 */
	protected void _save() {}
	/**
	 * Adds a labeled component to the option pane. Components are
	 * added in a vertical fashion, one per row. The label is
	 * displayed to the left of the component.
	 * @param label The label
	 * @param comp The component
	 */
	protected void addComponent(String label, Component comp)
	{
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = 1;
		cons.weightx = 0.0f;
		cons.fill = GridBagConstraints.BOTH;
		JLabel l = new JLabel(label,SwingConstants.RIGHT);
		l.setBorder(new EmptyBorder(0,0,0,12));
		gridBag.setConstraints(l,cons);
		add(l);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		gridBag.setConstraints(comp,cons);
		add(comp);
	}
	/**
	 * Adds a component to the option pane. Components are
	 * added in a vertical fashion, one per row.
	 * @param comp The component
	 */
	protected void addComponent(Component comp)
	{
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = GridBagConstraints.NONE;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		gridBag.setConstraints(comp,cons);
		add(comp);
	}
	/**
	 * Adds a separator component.
	 * @param label The separator label property
	 * @since jEdit 2.6pre2
	 */
	protected void addSeparator(String label)
	{
		Box box = new Box(BoxLayout.X_AXIS);
		Box box2 = new Box(BoxLayout.Y_AXIS);
		box2.add(Box.createGlue());
		box2.add(new JSeparator(JSeparator.HORIZONTAL));
		box2.add(Box.createGlue());
		box.add(box2);
		JLabel l = new JLabel(jEdit.getProperty(label));
		l.setMaximumSize(l.getPreferredSize());
		box.add(l);
		Box box3 = new Box(BoxLayout.Y_AXIS);
		box3.add(Box.createGlue());
		box3.add(new JSeparator(JSeparator.HORIZONTAL));
		box3.add(Box.createGlue());
		box.add(box3);
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		gridBag.setConstraints(box,cons);
		add(box);
	}
	// private members
	private String name;
}
/*
 * ChangeLog:
 * $Log: AbstractOptionPane.java,v $
 * Revision 1.7  2000/08/10 08:30:40  sp
 * VFS browser work, options dialog work, more random tweaks
 *
 * Revision 1.6  2000/08/05 07:16:11  sp
 * Global options dialog box updated, VFS browser now supports right-click menus
 *
 * Revision 1.5  2000/07/15 10:10:17  sp
 * improved printing
 *
 * Revision 1.4  2000/04/16 08:56:24  sp
 * Option pane updates
 *
 * Revision 1.3  1999/11/21 01:20:30  sp
 * Bug fixes, EditBus updates, fixed some warnings generated by jikes +P
 *
 * Revision 1.2  1999/10/10 06:38:45  sp
 * Bug fixes and quicksort routine
 *
 * Revision 1.1  1999/10/04 03:20:50  sp
 * Option pane change, minor tweaks and bug fixes
 *
 */
"
org.gjt.sp.jedit.ActionListHandler,"/*
 * ActionListHandler.java - XML handler for action files
 * Copyright (C) 2000, 2001 Slava Pestov
 * Portions copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import com.microstar.xml.*;
import java.io.*;
import java.util.Stack;
import org.gjt.sp.util.Log;
class ActionListHandler extends HandlerBase
{
	ActionListHandler(String path, boolean plugin)
	{
		this.path = path;
		this.plugin = plugin;
		stateStack = new Stack();
	}
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""actions.dtd"".equals(systemId))
		{
			try
			{
				return new BufferedReader(new InputStreamReader(
					getClass().getResourceAsStream(""actions.dtd"")));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,""Error while opening""
					+ "" actions.dtd:"");
				Log.log(Log.ERROR,this,e);
			}
		}
		return null;
	}
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();
		if(aname == ""NAME"")
			actionName = value;
		else if(aname == ""NO_REPEAT"")
			noRepeat = (value == ""TRUE"");
		else if(aname == ""NO_RECORD"")
			noRecord = (value == ""TRUE"");
	}
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if(""ACTIONS"".equals(name))
			return;
		Log.log(Log.ERROR,this,path + "": DOCTYPE must be ACTIONS"");
	}
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);
		if (tag == ""CODE"")
		{
			code = text;
		}
		else if (tag == ""IS_SELECTED"")
		{
			isSelected = text;
		}
	}
	public void startElement(String tag)
	{
		tag = pushElement(tag);
		if (tag == ""ACTION"")
		{
			code = null;
			isSelected = null;
		}
	}
	public void endElement(String name)
	{
		if(name == null)
			return;
		String tag = peekElement();
		if(name.equals(tag))
		{
			if(tag == ""ACTION"")
			{
				jEdit.addAction(new BeanShellAction(actionName,
					plugin,code,isSelected,noRepeat,noRecord));
			}
			popElement();
		}
		else
		{
			// can't happen
			throw new InternalError();
		}
	}
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}
	// end HandlerBase implementation
	// private members
	private String path;
	private boolean plugin;
	private String actionName;
	private String code;
	private String isSelected;
	private boolean noRepeat;
	private boolean noRecord;
	private Stack stateStack;
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();
		stateStack.push(name);
		return name;
	}
	private String peekElement()
	{
		return (String) stateStack.peek();
	}
	private String popElement()
	{
		return (String) stateStack.pop();
	}
}
"
org.gjt.sp.jedit.Autosave,"/*
 * Autosave.java - Autosave manager
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.Timer;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
/**
 * @author Slava Pestov
 * @version $Id: Autosave.java,v 1.8 2000/08/03 07:43:41 sp Exp $
 */
class Autosave implements ActionListener
{
	public static void setInterval(int interval)
	{
		if(interval == 0)
		{
			if(timer != null)
			{
				timer.stop();
				timer = null;
			}
			return;
		}
		interval *= 1000;
		if(timer == null)
		{
			timer = new Timer(interval,new Autosave());
			timer.start();
		}
		else
			timer.setDelay(interval);
	}
	public static void stop()
	{
		if(timer != null)
			timer.stop();
	}
	public void actionPerformed(ActionEvent evt)
	{
		Buffer[] bufferArray = jEdit.getBuffers();
		for(int i = 0; i < bufferArray.length; i++)
			bufferArray[i].autosave();
	}
	// private members
	private static Timer timer;
	private Autosave() {}
}
/*
 * ChangeLog:
 * $Log: Autosave.java,v $
 * Revision 1.8  2000/08/03 07:43:41  sp
 * Favorites added to browser, lots of other stuff too
 *
 * Revision 1.7  2000/07/22 03:27:03  sp
 * threaded I/O improved, autosave rewrite started
 *
 * Revision 1.6  2000/06/12 02:43:29  sp
 * pre6 almost ready
 *
 * Revision 1.5  1999/10/01 07:31:39  sp
 * RMI server replaced with socket-based server, minor changes
 *
 */
"
org.gjt.sp.jedit.BeanShell,"/*
 * BeanShell.java - BeanShell scripting support
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import bsh.*;
import javax.swing.text.BadLocationException;
import javax.swing.text.Segment;
import javax.swing.JFileChooser;
import java.lang.reflect.InvocationTargetException;
import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.gui.BeanShellErrorDialog;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.util.Log;
public class BeanShell
{
	/**
	 * Evaluates the text selected in the specified text area.
	 * @since jEdit 2.7pre2
	 */
	public static void evalSelection(View view, JEditTextArea textArea)
	{
		String command = textArea.getSelectedText();
		if(command == null)
		{
			view.getToolkit().beep();
			return;
		}
		Object returnValue = eval(view,command,false);
		if(returnValue != null)
			textArea.setSelectedText(returnValue.toString());
	}
	/**
	 * Prompts for a BeanShell expression to evaluate;
	 * @since jEdit 2.7pre2
	 */
	public static void showEvaluateDialog(View view)
	{
		String command = GUIUtilities.input(view,""beanshell-eval-input"",null);
		if(command != null)
		{
			if(!command.endsWith("";""))
				command = command + "";"";
			int repeat = view.getInputHandler().getRepeatCount();
			if(view.getMacroRecorder() != null)
			{
				view.getMacroRecorder().record(repeat,command);
			}
			Object returnValue = null;
			try
			{
				for(int i = 0; i < repeat; i++)
				{
					returnValue = eval(view,command,true);
				}
			}
			catch(Error t)
			{
				// BeanShell error occured, abort execution
			}
			if(returnValue != null)
			{
				String[] args = { returnValue.toString() };
				GUIUtilities.message(view,""beanshell-eval"",args);
			}
		}
	}
	/**
	 * Prompts for a BeanShell script to run.
	 * @since jEdit 2.7pre2
	 */
	public static void showRunScriptDialog(View view)
	{
		String[] paths = GUIUtilities.showVFSFileDialog(view,
			null,JFileChooser.OPEN_DIALOG,true);
		if(paths != null)
		{
			Buffer buffer = view.getBuffer();
			try
			{
				buffer.beginCompoundEdit();
				for(int i = 0; i < paths.length; i++)
					runScript(view,paths[i],true,false);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	}
	/**
	 * Runs a BeanShell script.
	 * @param view The view
	 * @param path The path name of the script. May be a jEdit VFS path
	 * @param ownNamespace Macros are run in their own namespace, startup
	 * scripts are run on the global namespace
	 * @param rethrowBshErrors Rethrow BeanShell errors, in addition to
	 * showing an error dialog box
	 * @since jEdit 2.7pre3
	 */
	public static void runScript(View view, String path,
		boolean ownNamespace, boolean rethrowBshErrors)
	{
		Reader in;
		Buffer buffer = jEdit.getBuffer(path);
		VFS vfs = VFSManager.getVFSForPath(path);
		Object session = vfs.createVFSSession(path,view);
		if(session == null)
		{
			// user cancelled???
			return;
		}
		try
		{
			if(buffer != null && buffer.isLoaded())
			{
				StringBuffer buf = new StringBuffer();
				try
				{
					buf.append(buffer.getText(0,buffer.getLength()));
				}
				catch(BadLocationException e)
				{
					// XXX
					throw new InternalError();
				}
				// Ugly workaround for a BeanShell bug
				buf.append(""\n"");
				in = new StringReader(buf.toString());
			}
			else
			{
				in = new BufferedReader(new InputStreamReader(
					vfs._createInputStream(session,path,
					true,view)));
			}
			runScript(view,path,in,ownNamespace,rethrowBshErrors);
		}
		catch(IOException e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);
			GUIUtilities.error(view,""read-error"",
				new String[] { path, e.toString() });
			return;
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,BeanShell.class,io);
				GUIUtilities.error(view,""read-error"",
					new String[] { path, io.toString() });
			}
		}
	}
	/**
	 * Runs a BeanShell script.
	 * @param view The view
	 * @param path For error reporting only
	 * @param in The reader to read the script from
	 * @param ownNamespace Macros are run in their own namespace, startup
	 * scripts are run on the global namespace
	 * @param rethrowBshErrors Rethrow BeanShell errors, in addition to
	 * showing an error dialog box
	 * @since jEdit 3.2pre4
	 */
	public static void runScript(View view, String path, Reader in,
		boolean ownNamespace, boolean rethrowBshErrors)
	{
		Log.log(Log.MESSAGE,BeanShell.class,""Running script "" + path);
		NameSpace namespace;
		if(ownNamespace)
			namespace = new NameSpace(global,""script namespace"");
		else
			namespace = global;
		Interpreter interp = createInterpreter(namespace);
		try
		{
			if(view != null)
			{
				EditPane editPane = view.getEditPane();
				interp.set(""view"",view);
				interp.set(""editPane"",editPane);
				interp.set(""buffer"",editPane.getBuffer());
				interp.set(""textArea"",editPane.getTextArea());
			}
			running = true;
			interp.eval(in,namespace,path);
		}
		catch(Throwable e)
		{
			if(e instanceof TargetError)
				e = ((TargetError)e).getTarget();
			if(e instanceof InvocationTargetException)
				e = ((InvocationTargetException)e).getTargetException();
			Log.log(Log.ERROR,BeanShell.class,e);
			new BeanShellErrorDialog(view,e.toString());
			if(e instanceof Error && rethrowBshErrors)
				throw (Error)e;
		}
		finally
		{
			running = false;
		}
	}
	/**
	 * Evaluates the specified BeanShell expression.
	 * @param view The view (may be null)
	 * @param command The expression
	 * @param rethrowBshErrors If true, BeanShell errors will
	 * be re-thrown to the caller
	 * @since jEdit 2.7pre3
	 */
	public static Object eval(View view, String command,
		boolean rethrowBshErrors)
	{
		return eval(view,global,command,rethrowBshErrors);
	}
	/**
	 * Evaluates the specified BeanShell expression.
	 * @param view The view (may be null)
	 * @param namespace The namespace
	 * @param command The expression
	 * @param rethrowBshErrors If true, BeanShell errors will
	 * be re-thrown to the caller
	 * @since jEdit 3.2pre7
	 */
	public static Object eval(View view, NameSpace namespace,
		String command, boolean rethrowBshErrors)
	{
		Interpreter interp = createInterpreter(namespace);
		try
		{
			if(view != null)
			{
				EditPane editPane = view.getEditPane();
				interp.set(""view"",view);
				interp.set(""editPane"",editPane);
				interp.set(""buffer"",editPane.getBuffer());
				interp.set(""textArea"",editPane.getTextArea());
			}
			return interp.eval(command);
		}
		catch(Throwable e)
		{
			if(e instanceof TargetError)
				e = ((TargetError)e).getTarget();
			if(e instanceof InvocationTargetException)
				e = ((InvocationTargetException)e).getTargetException();
			Log.log(Log.ERROR,BeanShell.class,e);
			new BeanShellErrorDialog(view,e.toString());
			if(e instanceof Error && rethrowBshErrors)
				throw (Error)e;
		}
		return null;
	}
	/**
	 * Caches a block of code, returning a handle that can be passed to
	 * runCachedBlock().
	 * @param id An identifier. If null, a unique identifier is generated
	 * @param code The code
	 * @param childNamespace If the method body should be run in a new
	 * namespace (slightly faster). Note that you must pass a null namespace
	 * to the runCachedBlock() method if you do this
	 * @since jEdit 3.2pre5
	 */
	public static String cacheBlock(String id, String code, boolean childNamespace)
	{
		String name;
		if(id == null)
			name = ""b_"" + (cachedBlockCounter++);
		else
			name = ""b_"" + id;
		code = ""setNameSpace(__cruft.namespace);\n""
			+ name
			+ ""(ns) {\n""
			+ ""setNameSpace(ns);""
			+ code
			+ ""\n}"";
		eval(null,code,false);
		return name;
	}
	/**
	 * Runs a cached block of code in the specified namespace. Faster than
	 * evaluating the block each time.
	 * @param id The identifier returned by cacheBlock()
	 * @param view The view
	 * @param namespace The namespace to run the code in. Can only be null if
	 * childNamespace parameter was true in cacheBlock() call
	 * @since jEdit 3.2pre5
	 */
	public static Object runCachedBlock(String id, View view, NameSpace namespace)
	{
		if(namespace == null)
			namespace = internal;
		Object[] args = { namespace };
		try
		{
			if(view != null)
			{
				namespace.setVariable(""view"",view);
				EditPane editPane = view.getEditPane();
				namespace.setVariable(""editPane"",editPane);
				namespace.setVariable(""buffer"",editPane.getBuffer());
				namespace.setVariable(""textArea"",editPane.getTextArea());
			}
			Object retVal = internal.invokeMethod(id,args,interpForMethods);
			if(retVal instanceof Primitive)
			{
				if(retVal == Primitive.VOID)
					return null;
				else
					return ((Primitive)retVal).getValue();
			}
			else
				return retVal;
		}
		catch(Throwable e)
		{
			if(e instanceof TargetError)
				e = ((TargetError)e).getTarget();
			if(e instanceof InvocationTargetException)
				e = ((InvocationTargetException)e).getTargetException();
			Log.log(Log.ERROR,BeanShell.class,e);
			new BeanShellErrorDialog(view,e.toString());
		}
		finally
		{
			try
			{
				namespace.setVariable(""view"",null);
				namespace.setVariable(""editPane"",null);
				namespace.setVariable(""buffer"",null);
				namespace.setVariable(""textArea"",null);
			}
			catch(EvalError e)
			{
				// can't do much
			}
		}
		return null;
	}
	/**
	 * Returns if a BeanShell script or macro is currently running.
	 * @since jEdit 2.7pre2
	 */
	public static boolean isScriptRunning()
	{
		return running;
	}
	/**
	 * Returns the global namespace.
	 * @since jEdit 3.2pre5
	 */
	public static NameSpace getNameSpace()
	{
		return global;
	}
	static void init()
	{
		Log.log(Log.DEBUG,BeanShell.class,""Initializing BeanShell""
			+ "" interpreter"");
		BshClassManager.setClassLoader(new JARClassLoader());
		global = new NameSpace(""jEdit embedded BeanShell Interpreter"");
		interpForMethods = createInterpreter(global);
		try
		{
			Interpreter interp = createInterpreter(global);
			BufferedReader in = new BufferedReader(new InputStreamReader(
				BeanShell.class.getResourceAsStream(""jedit.bsh"")));
			interp.eval(in,global,""jedit.bsh"");
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,BeanShell.class,t);
			System.exit(1);
		}
		// jedit object in global namespace is set up by jedit.bsh
		internal = (NameSpace)eval(null,""__cruft.namespace;"",false);
	}
	// private members
	private static Interpreter interpForMethods;
	private static NameSpace global;
	private static NameSpace internal;
	private static boolean running;
	private static int cachedBlockCounter;
	// until Pat updates Interpreter.java
	private static Interpreter createInterpreter(NameSpace nameSpace)
	{
		return new Interpreter(null,System.out,System.err,
			false,nameSpace);
	}
}
"
org.gjt.sp.jedit.BeanShellAction,"/*
 * BeanShellAction.java - BeanShell action
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.awt.event.ActionEvent;
import java.awt.*;
public class BeanShellAction extends EditAction
{
	public BeanShellAction(String name, boolean plugin, String code,
		String isSelected, boolean noRepeat, boolean noRecord)
	{
		super(name,plugin);
		this.code = code;
		this.isSelected = isSelected;
		this.noRepeat = noRepeat;
		this.noRecord = noRecord;
		/* Some characters that we like to use in action names
		 * ('.', '-') are not allowed in BeanShell identifiers. */
		sanitizedName = name.replace('.','_').replace('-','_');
	}
	public void invoke(View view)
	{
		if(cachedCode == null)
		{
			String cachedCodeName = ""action_"" + sanitizedName;
			cachedCode = BeanShell.cacheBlock(cachedCodeName,code,true);
		}
		BeanShell.runCachedBlock(cachedCode,view,null);
	}
	public boolean isToggle()
	{
		return isSelected != null;
	}
	public boolean isSelected(View view)
	{
		if(isSelected == null)
			return false;
		if(cachedIsSelected == null)
		{
			String cachedIsSelectedName = ""selected_"" + sanitizedName;
			cachedIsSelected = BeanShell.cacheBlock(cachedIsSelectedName,
				isSelected,true);
		}
		return Boolean.TRUE.equals(BeanShell.runCachedBlock(cachedIsSelected,
			view,null));
	}
	public boolean noRepeat()
	{
		return noRepeat;
	}
	public boolean noRecord()
	{
		return noRecord;
	}
	public String getCode()
	{
		return code.trim();
	}
	// private members
	private boolean noRepeat;
	private boolean noRecord;
	private String code;
	private String isSelected;
	private String cachedCode;
	private String cachedIsSelected;
	private String sanitizedName;
}
"
org.gjt.sp.jedit.Buffer,"/*
 * Buffer.java - jEdit buffer
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 * Portions copyright (C) 1999, 2000 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import gnu.regexp.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.undo.*;
import java.awt.*;
import java.io.File;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.search.RESearchMatcher;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
/**
 * An in-memory copy of an open file.<p>
 *
 * Buffers extend Swing document properties to obtain the default values
 * from jEdit's global properties.
 *
 * @author Slava Pestov
 * @version $Id: Buffer.java,v 1.243 2001/08/23 07:39:09 sp Exp $
 */
public class Buffer extends PlainDocument implements EBComponent
{
	/**
	 * Line separator property.
	 */
	public static final String LINESEP = ""lineSeparator"";
	/**
	 * Backed up property.
	 * @since jEdit 3.2pre2
	 */
	public static final String BACKED_UP = ""Buffer__backedUp"";
	/**
	 * Caret info properties.
	 * @since jEdit 3.2pre1
	 */
	public static final String CARET = ""Buffer__caret"";
	public static final String SELECTION = ""Buffer__selection"";
	public static final String SCROLL_VERT = ""Buffer__scrollVert"";
	public static final String SCROLL_HORIZ = ""Buffer__scrollHoriz"";
	/**
	 * Character encoding used when loading and saving.
	 * @since jEdit 3.2pre4
	 */
	public static final String ENCODING = ""encoding"";
	/**
	 * Reloads settings from the properties. This should be called
	 * after the <code>syntax</code> buffer-local property is
	 * changed.
	 */
	public void propertiesChanged()
	{
		if(getBooleanProperty(""syntax""))
			setTokenMarker(mode.getTokenMarker());
		else
			setTokenMarker(jEdit.getMode(""text"").getTokenMarker());
		if(undo != null)
		{
			try
			{
				undo.setLimit(Integer.parseInt(jEdit.getProperty(
					""buffer.undoCount"")));
			}
			catch(NumberFormatException nf)
			{
				undo.setLimit(100);
			}
		}
		// cache these for improved performance
		putProperty(""tabSize"",getProperty(""tabSize""));
		putProperty(""maxLineLen"",getProperty(""maxLineLen""));
	}
	/**
	 * Displays the 'insert file' dialog box and inserts the selected file
	 * into the buffer.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public void showInsertFileDialog(View view)
	{
		String[] files = GUIUtilities.showVFSFileDialog(view,null,
			VFSBrowser.OPEN_DIALOG,false);
		if(files != null)
			insert(view,files[0]);
	}
	/**
	 * Prints the buffer.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public void print(View view)
	{
		PrintJob job = view.getToolkit().getPrintJob(view,name,null);
		if(job == null)
			return;
		view.showWaitCursor();
		int topMargin;
		int leftMargin;
		int bottomMargin;
		int rightMargin;
		int ppi = job.getPageResolution();
		try
		{
			topMargin = (int)(Float.valueOf(jEdit.getProperty(
				""print.margin.top"")).floatValue() * ppi);
		}
		catch(NumberFormatException nf)
		{
			topMargin = ppi / 2;
		}
		try
		{
			leftMargin = (int)(Float.valueOf(jEdit.getProperty(
				""print.margin.left"")).floatValue() * ppi);
		}
		catch(NumberFormatException nf)
		{
			leftMargin = ppi / 2;
		}
		try
		{
			bottomMargin = (int)(Float.valueOf(jEdit.getProperty(
				""print.margin.bottom"")).floatValue() * ppi);
		}
		catch(NumberFormatException nf)
		{
			bottomMargin = topMargin;
		}
		try
		{
			rightMargin = (int)(Float.valueOf(jEdit.getProperty(
				""print.margin.right"")).floatValue() * ppi);
		}
		catch(NumberFormatException nf)
		{
			rightMargin = leftMargin;
		}
		boolean printHeader = jEdit.getBooleanProperty(""print.header"");
		boolean printFooter = jEdit.getBooleanProperty(""print.footer"");
		boolean printLineNumbers = jEdit.getBooleanProperty(""print.lineNumbers"");
		boolean syntax = jEdit.getBooleanProperty(""print.syntax"");
		String header = path;
		String footer = new Date().toString();
		int lineCount = getDefaultRootElement().getElementCount();
		TabExpander expander = null;
		Graphics gfx = null;
		String fontFamily = jEdit.getProperty(""print.font"");
		int fontSize;
		try
		{
			fontSize = Integer.parseInt(jEdit.getProperty(
				""print.fontsize""));
		}
		catch(NumberFormatException nf)
		{
			fontSize = 10;
		}
		int fontStyle;
		try
		{
			fontStyle = Integer.parseInt(jEdit.getProperty(
				""print.fontstyle""));
		}
		catch(NumberFormatException nf)
		{
			fontStyle = Font.PLAIN;
		}
		SyntaxStyle[] styles = GUIUtilities.loadStyles(fontFamily,fontSize);
		boolean style = jEdit.getBooleanProperty(""print.style"");
		boolean color = jEdit.getBooleanProperty(""print.color"");
		Font font = new Font(fontFamily,fontStyle,fontSize);
		FontMetrics fm = null;
		Dimension pageDimension = job.getPageDimension();
		int pageWidth = pageDimension.width;
		int pageHeight = pageDimension.height;
		int y = 0;
		int tabSize = 0;
		int lineHeight = 0;
		int page = 0;
		int lineNumberDigits = (int)Math.ceil(Math.log(
			lineCount) / Math.log(10));
		int lineNumberWidth = 0;
		TextRenderer renderer = TextRenderer.createPrintTextRenderer();
		renderer.configure(false,false);
		for(int i = 0; i < lineCount; i++)
		{
			if(gfx == null)
			{
				page++;
				gfx = job.getGraphics();
				renderer.setupGraphics(gfx);
				gfx.setFont(font);
				fm = gfx.getFontMetrics();
				if(printLineNumbers)
				{
					lineNumberWidth = fm.charWidth('0')
						* lineNumberDigits;
				}
				else
					lineNumberWidth = 0;
				lineHeight = fm.getHeight();
				tabSize = getTabSize() * fm.charWidth(' ');
				expander = new PrintTabExpander(leftMargin
					+ lineNumberWidth,tabSize);
				y = topMargin + lineHeight - fm.getDescent()
					- fm.getLeading();
				if(printHeader)
				{
					gfx.setColor(Color.lightGray);
					gfx.fillRect(leftMargin,topMargin,pageWidth
						- leftMargin - rightMargin,lineHeight);
					gfx.setColor(Color.black);
					gfx.drawString(header,leftMargin,y);
					y += lineHeight;
				}
			}
			y += lineHeight;
			gfx.setColor(Color.black);
			gfx.setFont(font);
			int x = leftMargin;
			if(printLineNumbers)
			{
				String lineNumber = String.valueOf(i + 1);
				gfx.drawString(lineNumber,(leftMargin + lineNumberWidth)
					- fm.stringWidth(lineNumber),y);
				x += lineNumberWidth + fm.charWidth('0');
			}
			paintSyntaxLine(i,gfx,x,y,expander,style,color,
				font,Color.black,Color.white,styles,
				renderer);
			int bottomOfPage = pageHeight - bottomMargin - lineHeight;
			if(printFooter)
				bottomOfPage -= lineHeight * 2;
			if(y >= bottomOfPage || i == lineCount - 1)
			{
				if(printFooter)
				{
					y = pageHeight - bottomMargin;
					gfx.setColor(Color.lightGray);
					gfx.setFont(font);
					gfx.fillRect(leftMargin,y - lineHeight,pageWidth
						- leftMargin - rightMargin,lineHeight);
					gfx.setColor(Color.black);
					y -= (lineHeight - fm.getAscent());
					gfx.drawString(footer,leftMargin,y);
					Integer[] args = { new Integer(page) };
					String pageStr = jEdit.getProperty(""print.page"",args);
					int width = fm.stringWidth(pageStr);
					gfx.drawString(pageStr,pageWidth - rightMargin
						- width,y);
				}
				gfx.dispose();
				gfx = null;
			}
		}
		job.end();
		view.hideWaitCursor();
	}
	/**
	 * Reloads the buffer from disk, asking for confirmation if the buffer
	 * is dirty.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public void reload(View view)
	{
		if(getFlag(DIRTY))
		{
			String[] args = { name };
			int result = GUIUtilities.confirm(view,""changedreload"",
				args,JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}
		view.getEditPane().saveCaretInfo();
		load(view,true);
	}
	/**
	 * Loads the buffer from disk, even if it is loaded already.
	 * @param view The view
	 * @param reload If true, user will not be asked to recover autosave
	 * file, if any
	 *
	 * @since 2.5pre1
	 */
	public boolean load(final View view, final boolean reload)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}
		setFlag(LOADING,true);
		// view text areas temporarily blank out while a buffer is
		// being loaded, to indicate to the user that there is no
		// data available yet.
		EditBus.send(new BufferUpdate(this,view,BufferUpdate.LOAD_STARTED));
		undo = null;
		final boolean loadAutosave;
		if(reload || !getFlag(NEW_FILE))
		{
			if(file != null)
				modTime = file.lastModified();
			// Only on initial load
			if(!reload && autosaveFile != null && autosaveFile.exists())
				loadAutosave = recoverAutosave(view);
			else
			{
				if(autosaveFile != null)
					autosaveFile.delete();
				loadAutosave = false;
			}
			if(!loadAutosave)
			{
				// this returns false if initial sanity
				// checks (if the file is a directory, etc)
				// fail
				if(!vfs.load(view,this,path))
				{
					setFlag(LOADING,false);
					return false;
				}
			}
		}
		else
			loadAutosave = false;
		// Do some stuff once loading is finished
		Runnable runnable = new Runnable()
		{
			public void run()
			{
				StringBuffer sbuf = (StringBuffer)getProperty(
					BufferIORequest.LOAD_DATA);
				if(sbuf != null)
				{
					try
					{
						// For `reload' command
						remove(0,getLength());
						insertString(0,sbuf.toString(),null);
					}
					catch(BadLocationException bl)
					{
						bl.printStackTrace();
					}
				}
				// reload maxLineLen and tabSize
				// from the global/mode properties
				getDocumentProperties().remove(""tabSize"");
				getDocumentProperties().remove(""indentSize"");
				getDocumentProperties().remove(""maxLineLen"");
				getDocumentProperties().remove(
					BufferIORequest.LOAD_DATA);
				undo = new MyUndoManager();
				try
				{
					undo.setLimit(Integer.parseInt(
						jEdit.getProperty(
						""buffer.undoCount"")));
				}
				catch(NumberFormatException nf)
				{
					undo.setLimit(100);
				}
				setMode();
				setFlag(LOADING,false);
				// if reloading a file, clear dirty flag
				if(reload)
					setDirty(false);
				// if loadAutosave is false, we loaded an
				// autosave file, so we set 'dirty' to true
				// note that we don't use setDirty(),
				// because a) that would send an unnecessary
				// message, b) it would also set the
				// AUTOSAVE_DIRTY flag, which will make
				// the autosave thread write out a
				// redundant autosave file
				if(loadAutosave)
					setFlag(DIRTY,true);
				if(jEdit.getBooleanProperty(""parseFully""))
				{
					for(int i = 0; i < lineCount; i++)
						markTokens(i);
				}
				try
				{
					int collapseFolds = ((Integer)
						getProperty(""collapseFolds""))
						.intValue();
					if(collapseFolds != 0)
						expandFolds(collapseFolds);
				}
				catch(Exception e)
				{
				}
				// send some EditBus messages
				if(!getFlag(TEMPORARY))
				{
					EditBus.send(new BufferUpdate(Buffer.this,
						view,BufferUpdate.LOADED));
					EditBus.send(new BufferUpdate(Buffer.this,
						view,BufferUpdate.MARKERS_CHANGED));
				}
			}
		};
		if(getFlag(TEMPORARY))
			runnable.run();
		else
			VFSManager.runInAWTThread(runnable);
		return true;
	}
	/**
	 * Loads a file from disk, and inserts it into this buffer.
	 * @param view The view
	 *
	 * @since 2.7pre1
	 */
	public boolean insert(final View view, String path)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}
		if(!MiscUtilities.isURL(path))
			path = MiscUtilities.constructPath(this.path,path);
		Buffer buffer = jEdit.getBuffer(path);
		if(buffer != null)
		{
			try
			{
				view.getTextArea().setSelectedText(
					buffer.getText(0,buffer.getLength()));
			}
			catch(BadLocationException bl)
			{
				bl.printStackTrace();
			}
			return true;
		}
		VFS vfs = VFSManager.getVFSForPath(path);
		setFlag(IO,true);
		// this returns false if initial sanity
		// checks (if the file is a directory, etc)
		// fail
		if(!vfs.insert(view,this,path))
		{
			setFlag(IO,false);
			return false;
		}
		// Do some stuff once loading is finished
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				setFlag(IO,false);
				StringBuffer sbuf = (StringBuffer)getProperty(
					BufferIORequest.LOAD_DATA);
				if(sbuf != null)
				{
					getDocumentProperties().remove(
						BufferIORequest.LOAD_DATA);
					view.getTextArea().setSelectedText(sbuf.toString());
				}
			}
		});
		return true;
	}
	/**
	 * Autosaves this buffer.
	 */
	public void autosave()
	{
		if(autosaveFile == null || !getFlag(AUTOSAVE_DIRTY)
			|| !getFlag(DIRTY)
			|| getFlag(LOADING)
			|| getFlag(IO))
			return;
		setFlag(AUTOSAVE_DIRTY,false);
		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.AUTOSAVE,null,this,null,
			VFSManager.getFileVFS(),autosaveFile.getPath()));
	}
	/**
	 * Prompts the user for a file to save this buffer to.
	 * @param view The view
	 * @param rename True if the buffer's path should be changed, false
	 * if only a copy should be saved to the specified filename
	 * @since jEdit 2.6pre5
	 */
	public boolean saveAs(View view, boolean rename)
	{
		String[] files = GUIUtilities.showVFSFileDialog(view,path,
			VFSBrowser.SAVE_DIALOG,false);
		// files[] should have length 1, since the dialog type is
		// SAVE_DIALOG
		if(files == null)
			return false;
		return save(view,files[0],rename);
	}
	/**
	 * Saves this buffer to the specified path name, or the current path
	 * name if it's null.
	 * @param view The view
	 * @param path The path name to save the buffer to, or null to use
	 * the existing path
	 */
	public boolean save(View view, String path)
	{
		return save(view,path,true);
	}
	/**
	 * Saves this buffer to the specified path name, or the current path
	 * name if it's null.
	 * @param view The view
	 * @param path The path name to save the buffer to, or null to use
	 * the existing path
	 * @param rename True if the buffer's path should be changed, false
	 * if only a copy should be saved to the specified filename
	 * @since jEdit 2.6pre5
	 */
	public boolean save(final View view, String path, final boolean rename)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}
		if(path == null && getFlag(NEW_FILE))
			return saveAs(view,rename);
		if(path == null && file != null)
		{
			long newModTime = file.lastModified();
			if(newModTime != modTime)
			{
				Object[] args = { this.path };
				int result = GUIUtilities.confirm(view,
					""filechanged-save"",args,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.WARNING_MESSAGE);
				if(result != JOptionPane.YES_OPTION)
					return false;
			}
		}
		setFlag(IO,true);
		EditBus.send(new BufferUpdate(this,view,BufferUpdate.SAVING));
		if(path == null)
			path = this.path;
		// can't call setPath() here because we don't want a failed
		// 'save as' to change the buffer's path, so obtain the VFS
		// instance 'manually'
		VFS vfs = VFSManager.getVFSForPath(path);
		if(!vfs.save(view,this,path))
		{
			setFlag(IO,false);
			return false;
		}
		final String oldPath = this.path;
		if(rename)
			setPath(path);
		// Once save is complete, do a few other things
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				// Saving a NEW_FILE will create a file on
				// disk, thus file system browsers must reload
				if(getFlag(NEW_FILE) || !getPath().equals(oldPath))
					VFSManager.sendVFSUpdate(getVFS(),getPath(),true);
				setFlag(IO,false);
				if(rename)
				{
					// we do a write lock so that the
					// autosave, which grabs a read lock,
					// is not executed between the
					// deletion of the autosave file
					// and clearing of the dirty flag
					try
					{
						Buffer.this._writeLock();
						if(autosaveFile != null)
							autosaveFile.delete();
						setFlag(AUTOSAVE_DIRTY,false);
						setFlag(READ_ONLY,false);
						setFlag(NEW_FILE,false);
						setFlag(UNTITLED,false);
						setFlag(DIRTY,false);
					}
					finally
					{
						Buffer.this._writeUnlock();
					}
					if(!getPath().equals(oldPath))
					{
						jEdit.updatePosition(Buffer.this);
						setMode();
					}
					if(file != null)
						modTime = file.lastModified();
					EditBus.send(new BufferUpdate(Buffer.this,
						view,BufferUpdate.DIRTY_CHANGED));
				}
			}
		});
		return true;
	}
	// these are only public so that an inner class can access them!
	public void _writeLock()
	{
		writeLock();
	}
	public void _writeUnlock()
	{
		writeUnlock();
	}
	/**
	 * Returns the last time jEdit modified the file on disk.
	 */
	public long getLastModified()
	{
		return modTime;
	}
	/**
	 * Sets the last time jEdit modified the file on disk.
	 * @param modTime The new modification time
	 */
	public void setLastModified(long modTime)
	{
		this.modTime = modTime;
	}
	/**
	 * Check if the buffer has changed on disk.
	 */
	public void checkModTime(View view)
	{
		// don't do these checks while a save is in progress,
		// because for a moment newModTime will be greater than
		// oldModTime, due to the multithreading
		if(file == null || getFlag(NEW_FILE) || getFlag(IO))
			return;
		boolean newReadOnly = (file.exists() && !file.canWrite());
		if(newReadOnly != getFlag(READ_ONLY))
		{
			setFlag(READ_ONLY,newReadOnly);
			EditBus.send(new BufferUpdate(this,
				view,BufferUpdate.DIRTY_CHANGED));
		}
		if(!jEdit.getBooleanProperty(""view.checkModStatus""))
			return;
		long oldModTime = modTime;
		long newModTime = file.lastModified();
		if(newModTime != oldModTime)
		{
			modTime = newModTime;
			if(!file.exists())
			{
				setFlag(NEW_FILE,true);
				EditBus.send(new BufferUpdate(this,
					view,BufferUpdate.DIRTY_CHANGED));
				Object[] args = { path };
				GUIUtilities.message(view,""filedeleted"",args);
				return;
			}
			String prop = (isDirty() ? ""filechanged-dirty""
				: ""filechanged-focus"");
			Object[] args = { path };
			int result = GUIUtilities.confirm(view,
				prop,args,JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result == JOptionPane.YES_OPTION)
			{
				view.getEditPane().saveCaretInfo();
				load(view,true);
			}
		}
	}
	/**
	 * Returns the virtual filesystem responsible for loading and
	 * saving this buffer.
	 */
	public VFS getVFS()
	{
		return vfs;
	}
	/**
	 * Returns the file for this buffer. This may be null if the buffer
	 * is non-local.
	 */
	public final File getFile()
	{
		return file;
	}
	/**
	 * Returns the autosave file for this buffer. This may be null if
	 * the file is non-local.
	 */
	public final File getAutosaveFile()
	{
		return autosaveFile;
	}
	/**
	 * Returns the name of this buffer.
	 */
	public final String getName()
	{
		return name;
	}
	/**
	 * Returns the path name of this buffer.
	 */
	public final String getPath()
	{
		return path;
	}
	/**
	 * Returns true if this buffer has been closed with
	 * <code>jEdit.closeBuffer()</code>.
	 */
	public final boolean isClosed()
	{
		return getFlag(CLOSED);
	}
	/**
	 * Returns true if the buffer is loaded.
	 */
	public final boolean isLoaded()
	{
		return !getFlag(LOADING);
	}
	/**
	 * Returns true if the buffer is currently performing I/O.
	 * @since jEdit 2.7pre1
	 */
	public final boolean isPerformingIO()
	{
		return getFlag(LOADING) || getFlag(IO);
	}
	/**
	 * @deprecated Call isPerformingIO() instead
	 */
	public final boolean isSaving()
	{
		return getFlag(IO);
	}
	/**
	 * Returns true if this file doesn't exist on disk.
	 */
	public final boolean isNewFile()
	{
		return getFlag(NEW_FILE);
	}
	/**
	 * Sets the new file flag.
	 * @param newFile The new file flag
	 */
	public final void setNewFile(boolean newFile)
	{
		setFlag(NEW_FILE,newFile);
	}
	/**
	 * Returns true if this file is 'untitled'.
	 */
	public final boolean isUntitled()
	{
		return getFlag(UNTITLED);
	}
	/**
	 * Returns true if this file has changed since last save, false
	 * otherwise.
	 */
	public final boolean isDirty()
	{
		return getFlag(DIRTY);
	}
	/**
	 * Returns true if this file is read only, false otherwise.
	 */
	public final boolean isReadOnly()
	{
		return getFlag(READ_ONLY);
	}
	/**
	 * Returns true if this file is editable, false otherwise.
	 * @since jEdit 2.7pre1
	 */
	public final boolean isEditable()
	{
		return !(getFlag(READ_ONLY) || getFlag(IO) || getFlag(LOADING));
	}
	/**
	 * Sets the read only flag.
	 * @param readOnly The read only flag
	 */
	public final void setReadOnly(boolean readOnly)
	{
		setFlag(READ_ONLY,readOnly);
	}
	/**
	 * Sets the `dirty' (changed since last save) flag of this buffer.
	 */
	public void setDirty(boolean d)
	{
		boolean old_d = getFlag(DIRTY);
		if(d)
		{
			if(getFlag(LOADING) || getFlag(READ_ONLY))
				return;
			if(getFlag(DIRTY) && getFlag(AUTOSAVE_DIRTY))
				return;
			setFlag(DIRTY,true);
			setFlag(AUTOSAVE_DIRTY,true);
		}
		else
		{
			setFlag(DIRTY,false);
			setFlag(AUTOSAVE_DIRTY,false);
		}
		if(d != old_d)
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.DIRTY_CHANGED));
		}
	}
	/**
	 * Returns if this is a temporary buffer.
	 * @see jEdit#openTemporary(View,String,String,boolean,boolean)
	 * @see jEdit#commitTemporary(Buffer)
	 * @since jEdit 2.2pre7
	 */
	public boolean isTemporary()
	{
		return getFlag(TEMPORARY);
	}
	/**
	 * Returns this buffer's icon.
	 * @since jEdit 2.6pre6
	 */
	public Icon getIcon()
	{
		if(getFlag(DIRTY))
			return GUIUtilities.DIRTY_BUFFER_ICON;
		else if(getFlag(READ_ONLY))
			return GUIUtilities.READ_ONLY_BUFFER_ICON;
		else if(getFlag(NEW_FILE))
			return GUIUtilities.NEW_BUFFER_ICON;
		else
			return GUIUtilities.NORMAL_BUFFER_ICON;
	}
	/**
	 * Undoes the most recent edit.
	 *
	 * @since jEdit 2.7pre2
	 */
	public void undo()
	{
		if(undo == null)
			return;
		if(!isEditable())
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}
		try
		{
			setFlag(UNDO_IN_PROGRESS,true);
			undo.undo();
		}
		catch(CannotUndoException cu)
		{
			Log.log(Log.DEBUG,this,cu);
			Toolkit.getDefaultToolkit().beep();
			return;
		}
		finally
		{
			setFlag(UNDO_IN_PROGRESS,false);
		}
	}
	/**
	 * Redoes the most recently undone edit. Returns true if the redo was
	 * successful.
	 *
	 * @since jEdit 2.7pre2
	 */
	public void redo()
	{
		if(undo == null)
			return;
		if(!isEditable())
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}
		try
		{
			setFlag(UNDO_IN_PROGRESS,true);
			undo.redo();
		}
		catch(CannotRedoException cr)
		{
			Log.log(Log.DEBUG,this,cr);
			Toolkit.getDefaultToolkit().beep();
			return;
		}
		finally
		{
			setFlag(UNDO_IN_PROGRESS,false);
		}
	}
	/**
	 * Adds an undoable edit to this document. This is non-trivial
	 * mainly because the text area adds undoable edits every time
	 * the caret is moved. First of all, undos are ignored while
	 * an undo is already in progress. This is no problem with Swing
	 * Document undos, but caret undos are fired all the time and
	 * this needs to be done. Also, insignificant undos are ignored
	 * if the redo queue is non-empty to stop something like a caret
	 * move from flushing all redos.
	 * @param edit The undoable edit
	 *
	 * @since jEdit 2.2pre1
	 */
	public void addUndoableEdit(UndoableEdit edit)
	{
		if(undo == null || getFlag(UNDO_IN_PROGRESS) || getFlag(LOADING))
			return;
		// Ignore insificant edits if the redo queue is non-empty.
		// This stops caret movement from killing redos.
		if(undo.canRedo() && !edit.isSignificant())
			return;
		if(compoundEdit != null)
		{
			compoundEditNonEmpty = true;
			compoundEdit.addEdit(edit);
		}
		else
			undo.addEdit(edit);
	}
	/**
	 * Starts a compound edit. All edits from now on until
	 * <code>endCompoundEdit()</code> are called will be merged
	 * into one. This can be used to make a complex operation
	 * undoable in one step. Nested calls to
	 * <code>beginCompoundEdit()</code> behave as expected,
	 * requiring the same number of <code>endCompoundEdit()</code>
	 * calls to end the edit.
	 * @see #endCompoundEdit()
	 * @see #undo()
	 */
	public void beginCompoundEdit()
	{
		if(getFlag(TEMPORARY))
			return;
		compoundEditCount++;
		if(compoundEdit == null)
		{
			compoundEditNonEmpty = false;
			compoundEdit = new CompoundEdit();
		}
	}
	/**
	 * Ends a compound edit. All edits performed since
	 * <code>beginCompoundEdit()</code> was called can now
	 * be undone in one step by calling <code>undo()</code>.
	 * @see #beginCompoundEdit()
	 * @see #undo()
	 */
	public void endCompoundEdit()
	{
		if(getFlag(TEMPORARY))
			return;
		if(compoundEditCount == 0)
			return;
		compoundEditCount--;
		if(compoundEditCount == 0)
		{
			compoundEdit.end();
			if(compoundEditNonEmpty && compoundEdit.canUndo())
				undo.addEdit(compoundEdit);
			compoundEdit = null;
		}
	}
	/**
	 * Returns if a compound edit is currently active.
	 * @since jEdit 3.1pre1
	 */
	public boolean insideCompoundEdit()
	{
		return compoundEdit != null;
	}
	/**
	 * Removes trailing whitespace from all lines in the specified list.
	 * @param list The line numbers
	 * @since jEdit 3.2pre1
	 */
	public void removeTrailingWhiteSpace(int[] lines)
	{
		Element map = getDefaultRootElement();
		try
		{
			beginCompoundEdit();
			for(int i = 0; i < lines.length; i++)
			{
				int pos, lineStart, lineEnd, tail;
				Element lineElement = map.getElement(lines[i]);
				getText(lineElement.getStartOffset(),
					lineElement.getEndOffset()
					- lineElement.getStartOffset() - 1,seg);
				// blank line
				if (seg.count == 0) continue;
				lineStart = seg.offset;
				lineEnd = seg.offset + seg.count - 1;
				for (pos = lineEnd; pos >= lineStart; pos--)
				{
					if (!Character.isWhitespace(seg.array[pos]))
						break;
				}
				tail = lineEnd - pos;
				// no whitespace
				if (tail == 0) continue;
				remove(lineElement.getEndOffset() - 1 - tail,tail);
			}
		}
		catch (BadLocationException ble)
		{
			Log.log(Log.ERROR, this, ble);
		}
		finally
		{
			endCompoundEdit();
		}
	}
	/**
	 * Shifts the indent of each line in the specified list to the left.
	 * @param lines The line numbers
	 * @since jEdit 3.2pre1
	 */
	public void shiftIndentLeft(int[] lines)
	{
		int tabSize = getTabSize();
		int indentSize = getIndentSize();
		boolean noTabs = getBooleanProperty(""noTabs"");
		Element map = getDefaultRootElement();
		try
		{
			beginCompoundEdit();
			for(int i = 0; i < lines.length; i++)
			{
				Element lineElement = map.getElement(lines[i]);
				int lineStart = lineElement.getStartOffset();
				String line = getText(lineStart,
					lineElement.getEndOffset() - lineStart - 1);
				int whiteSpace = MiscUtilities
					.getLeadingWhiteSpace(line);
				if(whiteSpace == 0)
					continue;
				int whiteSpaceWidth = Math.max(0,MiscUtilities
					.getLeadingWhiteSpaceWidth(line,tabSize)
					- indentSize);
				remove(lineStart,whiteSpace);
				insertString(lineStart,MiscUtilities
					.createWhiteSpace(whiteSpaceWidth,
					(noTabs ? 0 : tabSize)),null);
			}
		}
		catch (BadLocationException ble)
		{
			Log.log(Log.ERROR, this, ble);
		}
		finally
		{
			endCompoundEdit();
		}
	}
	/**
	 * Shifts the indent of each line in the specified list to the right.
	 * @param lines The line numbers
	 * @since jEdit 3.2pre1
	 */
	public void shiftIndentRight(int[] lines)
	{
		try
		{
			beginCompoundEdit();
			int tabSize = getTabSize();
			int indentSize = getIndentSize();
			boolean noTabs = getBooleanProperty(""noTabs"");
			Element map = getDefaultRootElement();
			for(int i = 0; i < lines.length; i++)
			{
				Element lineElement = map.getElement(lines[i]);
				int lineStart = lineElement.getStartOffset();
				String line = getText(lineStart,
					lineElement.getEndOffset() - lineStart - 1);
				int whiteSpace = MiscUtilities
					.getLeadingWhiteSpace(line);
				int whiteSpaceWidth = MiscUtilities
					.getLeadingWhiteSpaceWidth(
					line,tabSize) + indentSize;
				remove(lineStart,whiteSpace);
				insertString(lineStart,MiscUtilities
					.createWhiteSpace(whiteSpaceWidth,
					(noTabs ? 0 : tabSize)),null);
			}
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
		finally
		{
			endCompoundEdit();
		}
	}
	/**
	 * Returns the tab size used in this buffer. This is equivalent
	 * to calling getProperty(""tabSize"").
	 */
	public int getTabSize()
	{
		return ((Integer)getProperty(""tabSize"")).intValue();
	}
	/**
	 * Returns the indent size used in this buffer. This is equivalent
	 * to calling getProperty(""indentSize"").
	 * @since jEdit 2.7pre1
	 */
	public int getIndentSize()
	{
		return ((Integer)getProperty(""indentSize"")).intValue();
	}
	/**
	 * Returns the value of a boolean property.
	 * @param name The property name
	 */
	public boolean getBooleanProperty(String name)
	{
		Object obj = getProperty(name);
		if(obj instanceof Boolean)
			return ((Boolean)obj).booleanValue();
		else if(""true"".equals(obj) || ""on"".equals(obj) || ""yes"".equals(obj))
			return true;
		else
			return false;
	}
	/**
	 * Sets a boolean property.
	 * @param name The property name
	 * @param value The value
	 */
	public void putBooleanProperty(String name, boolean value)
	{
		putProperty(name,value ? Boolean.TRUE : Boolean.FALSE);
	}
	/**
	 * Returns this buffer's edit mode.
	 */
	public final Mode getMode()
	{
		return mode;
	}
	/**
	 * Sets this buffer's edit mode. Note that calling this before a buffer
	 * is loaded will have no effect; in that case, set the ""mode"" property
	 * to the name of the mode. A bit inelegant, I know...
	 * @param mode The mode
	 */
	public void setMode(Mode mode)
	{
		/* This protects against stupid people (like me)
		 * doing stuff like buffer.setMode(jEdit.getMode(...)); */
		if(mode == null)
			throw new NullPointerException(""Mode must be non-null"");
		if(this.mode == mode)
			return;
		Mode oldMode = this.mode;
		this.mode = mode;
		propertiesChanged(); // sets up token marker
		// don't fire it for initial mode set
		if(oldMode != null)
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.MODE_CHANGED));
		}
	}
	/**
	 * Sets this buffer's edit mode by calling the accept() method
	 * of each registered edit mode.
	 */
	public void setMode()
	{
		// don't do this while loading, otherwise we will
		// blow away caret location properties
		if(!getFlag(LOADING))
			clearProperties();
		parseBufferLocalProperties();
		String userMode = (String)getProperty(""mode"");
		if(userMode != null)
		{
			Mode m = jEdit.getMode(userMode);
			if(m != null)
			{
				setMode(m);
				return;
			}
		}
		String nogzName = name.substring(0,name.length() -
			(name.endsWith("".gz"") ? 3 : 0));
		Element lineElement = getDefaultRootElement().getElement(0);
		try
		{
			String line = getText(0,(lineElement == null
				? 0 : lineElement.getEndOffset()-1));
			Mode[] modes = jEdit.getModes();
			for(int i = 0; i < modes.length; i++)
			{
				if(modes[i].accept(nogzName,line))
				{
					setMode(modes[i]);
					return;
				}
			}
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
		Mode defaultMode = jEdit.getMode(jEdit.getProperty(""buffer.defaultMode""));
		if(defaultMode == null)
			defaultMode = jEdit.getMode(""text"");
		setMode(defaultMode);
	}
	/**
	 * If auto indent is enabled, this method is called when the `Tab'
	 * or `Enter' key is pressed to perform mode-specific indentation
	 * and return true, or return false if a normal tab is to be inserted.
	 * @param line The line number to indent
	 * @param canIncreaseIndent If false, nothing will be done if the
	 * calculated indent is greater than the current
	 * @param canDecreaseIndent If false, nothing will be done if the
	 * calculated indent is less than the current
	 * @return true if the tab key event should be swallowed (ignored)
	 * false if a real tab should be inserted
	 */
	public boolean indentLine(int lineIndex, boolean canIncreaseIndent,
		boolean canDecreaseIndent)
	{
		if(lineIndex == 0)
			return false;
		// Get properties
		String openBrackets = (String)getProperty(""indentOpenBrackets"");
		String closeBrackets = (String)getProperty(""indentCloseBrackets"");
		String _indentPrevLine = (String)getProperty(""indentPrevLine"");
		boolean doubleBracketIndent = getBooleanProperty(""doubleBracketIndent"");
		RE indentPrevLineRE = null;
		if(openBrackets == null)
			openBrackets = """";
		if(closeBrackets == null)
			closeBrackets = """";
		if(_indentPrevLine != null)
		{
			try
			{
				indentPrevLineRE = new RE(_indentPrevLine,
					RE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);
			}
			catch(REException re)
			{
				Log.log(Log.ERROR,this,""Invalid 'indentPrevLine'""
					+ "" regexp: "" + _indentPrevLine);
				Log.log(Log.ERROR,this,re);
			}
		}
		int tabSize = getTabSize();
		int indentSize = getIndentSize();
		boolean noTabs = getBooleanProperty(""noTabs"");
		Element map = getDefaultRootElement();
		String prevLine = null;
		String line = null;
		Element lineElement = map.getElement(lineIndex);
		int start = lineElement.getStartOffset();
		// Get line text
		try
		{
			line = getText(start,lineElement.getEndOffset() - start - 1);
			for(int i = lineIndex - 1; i >= 0; i--)
			{
				lineElement = map.getElement(i);
				int lineStart = lineElement.getStartOffset();
				int len = lineElement.getEndOffset() - lineStart - 1;
				if(len != 0)
				{
					prevLine = getText(lineStart,len);
					break;
				}
			}
			if(prevLine == null)
				return false;
		}
		catch(BadLocationException e)
		{
			Log.log(Log.ERROR,this,e);
			return false;
		}
		/*
		 * If 'prevLineIndent' matches a line --> +1
		 */
		boolean prevLineMatches = (indentPrevLineRE == null ? false
			: indentPrevLineRE.isMatch(prevLine));
		/*
		 * On the previous line,
		 * if(bob) { --> +1
		 * if(bob) { } --> 0
		 * } else if(bob) { --> +1
		 */
		boolean prevLineStart = true; // False after initial indent
		int prevLineIndent = 0; // Indent width (tab expanded)
		int prevLineBrackets = 0; // Additional bracket indent
		for(int i = 0; i < prevLine.length(); i++)
		{
			char c = prevLine.charAt(i);
			switch(c)
			{
			case ' ':
				if(prevLineStart)
					prevLineIndent++;
				break;
			case '\t':
				if(prevLineStart)
				{
					prevLineIndent += (tabSize
						- (prevLineIndent
						% tabSize));
				}
				break;
			default:
				prevLineStart = false;
				if(closeBrackets.indexOf(c) != -1)
					prevLineBrackets = Math.max(
						prevLineBrackets-1,0);
				else if(openBrackets.indexOf(c) != -1)
				{
					/*
					 * If supressBracketAfterIndent is true
					 * and we have something that looks like:
					 * if(bob)
					 * {
					 * then the 'if' will not shift the indent,
					 * because of the {.
					 *
					 * If supressBracketAfterIndent is false,
					 * the above would be indented like:
					 * if(bob)
					 *         {
					 */
					if(!doubleBracketIndent)
						prevLineMatches = false;
					prevLineBrackets++;
				}
				break;
			}
		}
		/*
		 * On the current line,
		 * } --> -1
		 * } else if(bob) { --> -1
		 * if(bob) { } --> 0
		 */
		boolean lineStart = true; // False after initial indent
		int lineIndent = 0; // Indent width (tab expanded)
		int lineWidth = 0; // White space count
		int lineBrackets = 0; // Additional bracket indent
		int closeBracketIndex = -1; // For lining up closing
			// and opening brackets
		for(int i = 0; i < line.length(); i++)
		{
			char c = line.charAt(i);
			switch(c)
			{
			case ' ':
				if(lineStart)
				{
					lineIndent++;
					lineWidth++;
				}
				break;
			case '\t':
				if(lineStart)
				{
					lineIndent += (tabSize
						- (lineIndent
						% tabSize));
					lineWidth++;
				}
				break;
			default:
				lineStart = false;
				if(closeBrackets.indexOf(c) != -1)
				{
					if(lineBrackets == 0)
						closeBracketIndex = i;
					else
						lineBrackets--;
				}
				else if(openBrackets.indexOf(c) != -1)
				{
					if(!doubleBracketIndent)
						prevLineMatches = false;
					lineBrackets++;
				}
				break;
			}
		}
		try
		{
			if(closeBracketIndex != -1)
			{
				int offset = TextUtilities.findMatchingBracket(
					this,lineIndex,closeBracketIndex);
				if(offset != -1)
				{
					lineElement = map.getElement(map.getElementIndex(
						offset));
					int startOffset = lineElement.getStartOffset();
					String closeLine = getText(startOffset,
						lineElement.getEndOffset() - startOffset - 1);
					prevLineIndent = MiscUtilities
						.getLeadingWhiteSpaceWidth(
						closeLine,tabSize);
				}
				else
					return false;
			}
			else
			{
				prevLineIndent += (prevLineBrackets * indentSize);
			}
			if(prevLineMatches)
				prevLineIndent += indentSize;
			if(!canDecreaseIndent && prevLineIndent <= lineIndent)
				return false;
			if(!canIncreaseIndent && prevLineIndent >= lineIndent)
				return false;
			// Do it
			remove(start,lineWidth);
			insertString(start,MiscUtilities.createWhiteSpace(
				prevLineIndent,(noTabs ? 0 : tabSize)),null);
			return true;
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
		return false;
	}
	/**
	 * Indents all specified lines.
	 * @param start The first line to indent
	 * @param end The last line to indent
	 * @since jEdit 3.1pre3
	 */
	public void indentLines(int start, int end)
	{
		beginCompoundEdit();
		for(int i = start; i <= end; i++)
			indentLine(i,true,true);
		endCompoundEdit();
	}
	/**
	 * Indents all specified lines.
	 * @param lines The line numbers
	 * @since jEdit 3.2pre1
	 */
	public void indentLines(int[] lines)
	{
		beginCompoundEdit();
		for(int i = 0; i < lines.length; i++)
			indentLine(lines[i],true,true);
		endCompoundEdit();
	}
	/**
	 * @deprecated Don't call this method.
	 */
	public void tokenizeLines() {}
	/**
	 * Reparses the document, by passing the specified lines to the
	 * token marker. This should be called after a large quantity of
	 * text is first inserted.
	 * @param start The first line to parse
	 * @param len The number of lines, after the first one to parse
	 */
	public void tokenizeLines(int start, int len)
	{
		linesChanged(start,len);
		for(int i = 0; i < len; i++)
			markTokens(start + i);
	}
	/**
	 * Paints the specified line onto the graphics context.
	 * @since jEdit 3.2pre6
	 */
	public int paintSyntaxLine(int lineIndex, Graphics gfx, int _x, int _y,
		TabExpander expander, boolean style, boolean color,
		Font defaultFont, Color foreground, Color background,
		SyntaxStyle[] styles, TextRenderer renderer)
	{
		float x = (float)_x;
		float y = (float)_y;
		LineInfo info = lineInfo[lineIndex];
		if(info.tokensValid)
		{
			// have to do this 'manually'
			Element lineElement = getDefaultRootElement()
				.getElement(lineIndex);
			int lineStart = lineElement.getStartOffset();
			try
			{
				getText(lineStart,lineElement.getEndOffset()
					- lineStart - 1,seg);
			}
			catch(BadLocationException e)
			{
				Log.log(Log.ERROR,this,e);
			}
		}
		else
			markTokens(lineIndex);
		Token tokens = info.firstToken;
		// the above should leave the text in the 'seg' segment
		char[] text = seg.array;
		int off = seg.offset;
		for(;;)
		{
			byte id = tokens.id;
			if(id == Token.END)
				break;
			Color tokenForeground;
			Color tokenBackground = null;
			if(id == Token.NULL)
			{
				gfx.setFont(defaultFont);
				tokenForeground = foreground;
			}
			else
			{
				if(style)
					gfx.setFont(styles[id].getFont());
				else
					gfx.setFont(defaultFont);
				if(color)
				{
					tokenBackground = styles[id].getBackgroundColor();
					tokenForeground = styles[id].getForegroundColor();
				}
				else
					tokenForeground = foreground;
			}
			int len = tokens.length;
			x = renderer.drawChars(text,off,len,gfx,x,y,expander,
				tokenForeground,tokenBackground,background);
			off += len;
			tokens = tokens.next;
		}
		return (int)x;
	}
	/**
	 * Returns the syntax tokens for the specified line.
	 * @param lineIndex The line number
	 * @since jEdit 3.1pre1
	 */
	public LineInfo markTokens(int lineIndex)
	{
		LineInfo info = lineInfo[lineIndex];
		/* If cached tokens are valid, return 'em */
		if(info.tokensValid)
			return info;
		//long _start = System.currentTimeMillis();
		/*
		 * Else, go up to 100 lines back, looking for a line with
		 * cached tokens. Tokenize from that line to this line.
		 */
		int start = Math.max(0,lineIndex - 100) - 1;
		int end = Math.max(0,lineIndex - 100);
		for(int i = lineIndex - 1; i > end; i--)
		{
			if(lineInfo[i].tokensValid)
			{
				start = i;
				break;
			}
		}
		LineInfo prev;
		if(start == -1)
			prev = null;
		else
			prev = lineInfo[start];
		//System.err.println(""i="" + lineIndex + "",start="" + start);
		Element map = getDefaultRootElement();
		for(int i = start + 1; i <= lineIndex; i++)
		{
			info = lineInfo[i];
			if(info.tokensValid)
			{
				prev = info;
				continue;
			}
			Element lineElement = map.getElement(i);
			int lineStart = lineElement.getStartOffset();
			try
			{
				getText(lineStart,lineElement.getEndOffset()
					- lineStart - 1,seg);
			}
			catch(BadLocationException e)
			{
				Log.log(Log.ERROR,this,e);
			}
			/* Prepare for tokenization */
			info.lastToken = null;
			ParserRule oldRule = info.context.inRule;
			TokenMarker.LineContext oldParent = info.context.parent;
			tokenMarker.markTokens(prev,info,seg);
			ParserRule newRule = info.context.inRule;
			TokenMarker.LineContext newParent = info.context.parent;
			info.tokensValid = true;
			if(i != lastTokenizedLine)
			{
				nextLineRequested = false;
				lastTokenizedLine = i;
			}
			nextLineRequested |= (oldRule != newRule || oldParent != newParent);
			info.addToken(0,Token.END);
			prev = info;
		}
		if(nextLineRequested && lineCount - lineIndex > 1)
		{
			linesChanged(lineIndex + 1,lineCount - lineIndex - 1);
		}
		//System.err.println(System.currentTimeMillis() - _start);
		return info;
	}
	/**
	 * Store the width of a line, in pixels.
	 * @param lineIndex The line number
	 * @param width The width
	 * @since jEdit 3.1pre1
	 */
	public boolean setLineWidth(int lineIndex, int width)
	{
		LineInfo info = lineInfo[lineIndex];
		int oldWidth = info.width;
		info.width = width;
		return width != oldWidth;
	}
	/**
	 * Returns the maximum line width in the specified line range.
	 * The strange mix of physical/virtual line numbers is due to
	 * the way the text area paints lines.
	 * @param start The first physical line
	 * @param len The number of virtual lines from the first line
	 * @since jEdit 3.1pre1
	 */
	public int getMaxLineWidth(int start, int len)
	{
		int retVal = 0;
		int lines = 0;
		for(int i = start; ; i++)
		{
			if(i >= lineCount || lines >= len)
				break;
			LineInfo info = lineInfo[i];
			if(info.visible)
			{
				retVal = Math.max(lineInfo[i].width,retVal);
				lines++;
			}
		}
		return retVal;
	}
	/*
	 * Returns true if the next line should be repainted. This
	 * will return true after a line has been tokenized that starts
	 * a multiline token that continues onto the next line.
	 */
	public boolean isNextLineRequested()
	{
		return nextLineRequested;
	}
	/**
	 * Returns the line info object for the specified line.
	 * @since jEdit 3.1pre1
	 */
	public LineInfo getLineInfo(int line)
	{
		return lineInfo[line];
	}
	/**
	 * Returns if the specified line is visible.
	 * @since jEdit 3.1pre1
	 */
	public boolean isLineVisible(int line)
	{
		return lineInfo[line].visible;
	}
	/**
	 * Returns if the specified line begins a fold.
	 * @since jEdit 3.1pre1
	 */
	public boolean isFoldStart(int line)
	{
		if(line == lineCount - 1)
			return false;
		// how it works:
		// - if a line has a greater fold level than the next,
		//   it is a fold
		// - if a line is invisible, it is also a fold, even
		//   if the fold level is the same (rationale: changing
		//   indent levels while folds are collapsed shouldn't
		//   create pernamently inaccessable sections)
		// - exception to the above: if the line is the last
		//   virtual line, don't report it as a fold if the
		//   fold levels are the same and the next is invisible,
		//   otherwise the last narrowed line will always be
		//   a fold start which is silly
		// note that the last two cases are temporarily disabled
		// in 3.1pre3 because expandFoldAt() doesn't handle them
		// properly.
		return getFoldLevel(line) < getFoldLevel(line + 1);
			/*|| (line != virtualLines[virtualLineCount - 1]
			&& !lineInfo[line + 1].visible);*/
	}
	/**
	 * Returns the fold level of the specified line.
	 * @since jEdit 3.1pre1
	 */
	public int getFoldLevel(int line)
	{
		LineInfo info = lineInfo[line];
		if(info.foldLevelValid)
			return info.foldLevel;
		else
		{
			boolean changed = false;
			// make this configurable!
			int tabSize = getTabSize();
			Element lineElement = getDefaultRootElement()
				.getElement(line);
			int start = lineElement.getStartOffset();
			try
			{
				getText(start,lineElement.getEndOffset() - start - 1,seg);
			}
			catch(BadLocationException bl)
			{
				Log.log(Log.ERROR,this,bl);
			}
			int offset = seg.offset;
			int count = seg.count;
			int whitespace = 0;
			if(count == 0)
			{
				// empty line. inherit previous line's fold level
				if(line != 0)
					whitespace = getFoldLevel(line - 1);
				else
					whitespace = 0;
			}
			else
			{
				// this is so that lines consisting of only
				// whitespace don't cause disruptions
				boolean seenNonWhitespace = false;
loop:				for(int i = 0; i < count; i++)
				{
					switch(seg.array[offset + i])
					{
					case ' ':
						whitespace++;
						break;
					case '\t':
						whitespace += (tabSize - whitespace % tabSize);
						break;
					default:
						seenNonWhitespace = true;
						break loop;
					}
				}
				if(!seenNonWhitespace)
				{
					if(line != 0)
						whitespace = getFoldLevel(line - 1);
					else
						whitespace = 0;
				}
			}
			if(info.foldLevel != whitespace)
			{
				info.foldLevel = whitespace;
				fireFoldLevelsChanged(line - 1,line - 1);
			}
			info.foldLevelValid = true;
			return whitespace;
		}
	}
	/**
	 * Returns the previous visible line before the specified index, or
	 * -1 if no previous lines are visible.
	 * @param lineNo The line
	 * @since jEdit 3.1pre1
	 */
	public int getPrevVisibleLine(int lineNo)
	{
		for(int i = lineNo - 1; i >= 0; i--)
		{
			if(lineInfo[i].visible)
				return i;
		}
		return -1;
	}
	/**
	 * Returns the next visible line after the specified index, or
	 * -1 if no subsequent lines are visible.
	 * @param lineNo The line
	 * @since jEdit 3.1pre1
	 */
	public int getNextVisibleLine(int lineNo)
	{
		for(int i = lineNo + 1; i < lineCount; i++)
		{
			if(lineInfo[i].visible)
				return i;
		}
		return -1;
	}
	/**
	 * Maps a virtual line number to a physical line number. To simplify
	 * matters for text area highlighters, this method maps out-of-bounds
	 * line numbers as well.
	 * @since jEdit 3.1pre1
	 */
	public int virtualToPhysical(int lineNo)
	{
		// debugging code
		if((lineNo < virtualLineCount && lineNo >= virtualLines.length)
			|| lineNo < 0)
			throw new RuntimeException(""lineNo = "" + lineNo);
		if(lineNo >= virtualLineCount)
			return lineCount + (lineNo - virtualLineCount);
		return virtualLines[lineNo];
	}
	/**
	 * Maps a physical line number to a virtual line number.
	 * @since jEdit 3.1pre1
	 */
	public int physicalToVirtual(int lineNo)
	{
		int start = 0;
		int end = virtualLineCount - 1;
		if(lineNo < virtualLines[start])
			return start;
		else if(lineNo > virtualLines[end])
			return end;
		// funky binary search
		for(;;)
		{
			switch(end - start)
			{
			case 0:
				if(virtualLines[start] < lineNo)
					return start + 1;
				else
					return start;
			case 1:
				if(virtualLines[start] < lineNo)
				{
					if(virtualLines[end] < lineNo)
						return end + 1;
					else
						return end;
				}
				else
					return start;
			default:
				int pivot = start + (end - start) / 2;
				int value = virtualLines[pivot];
				if(value == lineNo)
					return pivot;
				else if(value < lineNo)
					start = pivot + 1;
				else
					end = pivot - 1;
				break;
			}
		}
	}
	/**
	 * Collapse the fold that contains the specified line number.
	 * @param line The first line number of the fold
	 * @return False if there are no folds in the buffer
	 * @since jEdit 3.1pre1
	 */
	public boolean collapseFoldAt(int line)
	{
		int initialFoldLevel = getFoldLevel(line);
		int start = 0;
		int end = lineCount - 1;
		if(line != lineCount - 1
			&& getFoldLevel(line + 1) > initialFoldLevel)
		{
			// this line is the start of a fold
			start = line + 1;
			for(int i = line + 1; i < lineCount; i++)
			{
				if(getFoldLevel(i) <= initialFoldLevel)
				{
					end = i - 1;
					break;
				}
			}
		}
		else
		{
			boolean ok = false;
			// scan backwards looking for the start
			for(int i = line - 1; i >= 0; i--)
			{
				if(getFoldLevel(i) < initialFoldLevel)
				{
					start = i + 1;
					ok = true;
					break;
				}
			}
			if(!ok)
			{
				// no folds in buffer
				return false;
			}
			for(int i = line + 1; i < lineCount; i++)
			{
				if(getFoldLevel(i) < initialFoldLevel)
				{
					end = i - 1;
					break;
				}
			}
		}
		int delta = (end - start + 1);
		for(int i = start; i <= end; i++)
		{
			LineInfo info = lineInfo[i];
			if(info.visible)
				info.visible = false;
			else
				delta--;
		}
		if(delta == 0)
		{
			// user probably pressed A+BACK_SPACE twice
			return false;
		}
		//System.err.println(""collapse from "" + start + "" to "" + end);
		// I forgot to do this at first and it took me ages to
		// figure out
		start = physicalToVirtual(start);
		//System.err.println(""virtualized start is "" + start);
		// update virtual -> physical map
		virtualLineCount -= delta;
		//System.err.println(""new virtual line count is "" + virtualLineCount);
		System.arraycopy(virtualLines,start + delta,virtualLines,start,
			virtualLines.length - start - delta);
		//System.err.println(""copy from "" + (start + delta)
		//	+ "" to "" + start);
		fireFoldStructureChanged();
		return true;
	}
	/**
	 * Expand the fold that begins at the specified line number.
	 * @param line The first line number of the fold
	 * @param fully If true, fold will be expanded fully, otherwise
	 * only one level will be expanded
	 * @param textArea Text area for scrolling purposes
	 * @return False if there are no folds in the buffer
	 * @since jEdit 3.3pre3
	 */
	public boolean expandFoldAt(int line, boolean fully, JEditTextArea textArea)
	{
		int initialFoldLevel = getFoldLevel(line);
		int start = 0;
		int end = lineCount - 1;
		if(line != lineCount - 1
			&& lineInfo[line].visible
			&& !lineInfo[line + 1].visible
			&& getFoldLevel(line + 1) > initialFoldLevel)
		{
			// this line is the start of a fold
			start = line + 1;
			for(int i = line + 1; i < lineCount; i++)
			{
				if(lineInfo[i].visible && getFoldLevel(i) <= initialFoldLevel)
				{
					end = i - 1;
					break;
				}
			}
		}
		else
		{
			/* if(lineInfo[line].visible)
			{
				// the user probably pressed A+ENTER twice
				return false;
			} */
			boolean ok = false;
			// scan backwards looking for the start
			for(int i = line - 1; i >= 0; i--)
			{
				if(lineInfo[i].visible && getFoldLevel(i) < initialFoldLevel)
				{
					start = i + 1;
					ok = true;
					break;
				}
			}
			if(!ok)
			{
				// no folds in buffer
				return false;
			}
			for(int i = line + 1; i < lineCount; i++)
			{
				if(lineInfo[i].visible && getFoldLevel(i) < initialFoldLevel)
				{
					end = i - 1;
					break;
				}
			}
		}
		int delta = 0;
		int tmpMapLen = 0;
		int[] tmpVirtualMap = new int[end - start + 1];
		// we need a different value of initialFoldLevel here!
		initialFoldLevel = getFoldLevel(start);
		for(int i = start; i <= end; i++)
		{
			LineInfo info = lineInfo[i];
			if(info.visible)
			{
				// user will be confused if 'expand fold'
				// hides lines
				tmpVirtualMap[tmpMapLen++] = i;
			}
			else if(!fully && getFoldLevel(i) > initialFoldLevel)
			{
				// don't expand lines with higher fold
				// levels
			}
			else
			{
				// System.err.println(""adding to map: "" + i);
				tmpVirtualMap[tmpMapLen++] = i;
				delta++;
				info.visible = true;
			}
		}
		// I forgot to do this at first and it took me ages to
		// figure out
		int virtualLine;
		if(start > virtualLines[virtualLineCount - 1])
			virtualLine = virtualLineCount;
		else
			virtualLine = physicalToVirtual(start);
		//System.err.println(""virtual start is "" + virtualLine
		//	+ "", physical start is "" + start);
		//System.err.println(""end="" + end + "",delta="" + delta);
		// update virtual -> physical map
		virtualLineCount += delta;
		//System.err.println(""virtual line count is "" + virtualLineCount);
		if(virtualLines.length <= virtualLineCount)
		{
			int[] virtualLinesN = new int[(virtualLineCount + 1) * 2];
			System.arraycopy(virtualLines,0,
				virtualLinesN,0,virtualLines.length);
			virtualLines = virtualLinesN;
		}
		//System.err.println(""copy from "" + (virtualLine)
		//	+ "" to "" + (virtualLine + delta));
		//System.err.println(""foo: "" + virtualLines[virtualLine]);
		System.arraycopy(virtualLines,virtualLine,virtualLines,
			virtualLine + delta,virtualLines.length
			- virtualLine - delta);
		for(int j = 0; j < tmpMapLen; j++)
		{
			//System.err.println((virtualLine + j) + "" maps to "" + tmpVirtualMap[j]);
			virtualLines[virtualLine + j] = tmpVirtualMap[j];
		}
		fireFoldStructureChanged();
		if(textArea != null)
		{
			int firstLine = textArea.getFirstLine();
			int visibleLines = textArea.getVisibleLines();
			if(virtualLine + delta >= firstLine + visibleLines
				&& delta < visibleLines - 1)
			{
				textArea.setFirstLine(virtualLine + delta - visibleLines + 1);
			}
		}
		return true;
	}
	/**
	 * This is intended to be called from actions.xml.
	 * @since jEdit 3.1pre1
	 */
	public void expandFolds(char digit)
	{
		if(digit < '1' || digit > '9')
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}
		else
			expandFolds((int)(digit - '1') + 1);
	}
	/**
	 * Expand all folds in the buffer up to a specified level.
	 * @param level All folds less than this level will be expanded,
	 * others will be collapsed. This is not the actual fold level;
	 * it is multiplied by the indent size first
	 * @since jEdit 3.1pre1
	 */
	public void expandFolds(int level)
	{
		if(virtualLines.length <= lineCount)
		{
			int[] virtualLinesN = new int[(lineCount + 1) * 2];
			System.arraycopy(virtualLines,0,
				virtualLinesN,0,virtualLines.length);
			virtualLines = virtualLinesN;
		}
		level = (level - 1) * getIndentSize() + 1;
		/* this ensures that the first line is always visible */
		boolean seenVisibleLine = false;
		virtualLineCount = 0;
		for(int i = 0; i < lineCount; i++)
		{
			if(!seenVisibleLine || getFoldLevel(i) < level)
			{
				seenVisibleLine = true;
				lineInfo[i].visible = true;
				virtualLines[virtualLineCount++] = i;
			}
			else
				lineInfo[i].visible = false;
		}
		fireFoldStructureChanged();
	}
	/**
	 * Expand all folds in the specified document.
	 * @since jEdit 3.1pre1
	 */
	public void expandAllFolds()
	{
		if(virtualLines.length <= lineCount)
		{
			int[] virtualLinesN = new int[(lineCount + 1) * 2];
			System.arraycopy(virtualLines,0,
				virtualLinesN,0,virtualLines.length);
			virtualLines = virtualLinesN;
		}
		virtualLineCount = lineCount;
		for(int i = 0; i < lineCount; i++)
		{
			virtualLines[i] = i;
			lineInfo[i].visible = true;
		}
		fireFoldStructureChanged();
	}
	/**
	 * Narrows the visible portion of the buffer to the specified
	 * line range.
	 * @param start The first line
	 * @param end The last line
	 * @since jEdit 3.1pre3
	 */
	public void narrow(int start, int end)
	{
		virtualLineCount = end - start + 1;
		virtualLines = new int[virtualLineCount];
		for(int i = 0; i < start; i++)
			lineInfo[i].visible = false;
		for(int i = start; i <= end; i++)
		{
			LineInfo info = lineInfo[i];
			info.visible = true;
			virtualLines[i - start] = i;
		}
		for(int i = end + 1; i < lineCount; i++)
			lineInfo[i].visible = false;
		fireFoldStructureChanged();
	}
	/**
	 * Adds a fold listener.
	 * @param listener The listener
	 * @since jEdit 3.1pre1
	 */
	public void addFoldListener(FoldListener l)
	{
		foldListeners.addElement(l);
	}
	/**
	 * Removes a fold listener.
	 * @param listener The listener
	 * @since jEdit 3.1pre1
	 */
	public void removeFoldListener(FoldListener l)
	{
		foldListeners.removeElement(l);
	}
	/**
	 * Returns the number of physical lines in the buffer.
	 * @since jEdit 3.1pre1
	 */
	public int getLineCount()
	{
		return lineCount;
	}
	/**
	 * Returns the number of virtual lines in the buffer.
	 * @since jEdit 3.1pre1
	 */
	public int getVirtualLineCount()
	{
		return virtualLineCount;
	}
	/**
	 * Returns a vector of markers.
	 * @since jEdit 3.2pre1
	 */
	public final Vector getMarkers()
	{
		return markers;
	}
	/**
	 * If a marker is set on the line of the position, it is removed. Otherwise
	 * a new marker with the specified shortcut is added.
	 * @param pos The position of the marker
	 * @param shortcut The shortcut ('\0' if none)
	 * @since jEdit 3.2pre5
	 */
	public void addOrRemoveMarker(char shortcut, int pos)
	{
		Element map = getDefaultRootElement();
		int line = map.getElementIndex(pos);
		if(getMarkerAtLine(line) != null)
			removeMarker(line);
		else
			addMarker(shortcut,pos);
	}
	/**
	 * Adds a marker to this buffer.
	 * @param pos The position of the marker
	 * @param shortcut The shortcut ('\0' if none)
	 * @since jEdit 3.2pre1
	 */
	public void addMarker(char shortcut, int pos)
	{
		if(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(""persistentMarkers""))
			setDirty(true);
		Marker markerN = new Marker(this,shortcut,pos);
		boolean added = false;
		Element map = getDefaultRootElement();
		int line = map.getElementIndex(pos);
		// don't sort markers while buffer is being loaded
		if(!getFlag(LOADING))
		{
			markerN.createPosition();
			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = (Marker)markers.elementAt(i);
				if(shortcut != '\0' && marker.getShortcut() == shortcut)
					marker.setShortcut('\0');
				if(map.getElementIndex(marker.getPosition()) == line)
				{
					markers.removeElementAt(i);
					i--;
				}
			}
			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = (Marker)markers.elementAt(i);
				if(marker.getPosition() > pos)
				{
					markers.insertElementAt(markerN,i);
					added = true;
					break;
				}
			}
		}
		if(!added)
			markers.addElement(markerN);
		if(!getFlag(LOADING))
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.MARKERS_CHANGED));
		}
	}
	/**
	 * Returns the first marker at the specified line.
	 * @param line The line number
	 * @since jEdit 3.2pre2
	 */
	public Marker getMarkerAtLine(int line)
	{
		Element map = getDefaultRootElement();
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			if(map.getElementIndex(marker.getPosition()) == line)
				return marker;
		}
		return null;
	}
	/**
	 * Removes all markers at the specified line.
	 * @param line The line number
	 * @since jEdit 3.2pre2
	 */
	public void removeMarker(int line)
	{
		Element map = getDefaultRootElement();
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			if(map.getElementIndex(marker.getPosition()) == line)
			{
				if(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(""persistentMarkers""))
					setDirty(true);
				marker.removePosition();
				markers.removeElementAt(i);
				i--;
			}
		}
		EditBus.send(new BufferUpdate(this,null,
			BufferUpdate.MARKERS_CHANGED));
	}
	/**
	 * Removes all defined markers.
	 * @since jEdit 2.6pre1
	 */
	public void removeAllMarkers()
	{
		if(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(""persistentMarkers""))
			setDirty(true);
		for(int i = 0; i < markers.size(); i++)
			((Marker)markers.elementAt(i)).removePosition();
		markers.removeAllElements();
		EditBus.send(new BufferUpdate(this,null,
			BufferUpdate.MARKERS_CHANGED));
	}
	/**
	 * Returns the marker with the specified shortcut.
	 * @param shortcut The shortcut
	 * @since jEdit 3.2pre2
	 */
	public Marker getMarker(char shortcut)
	{
		Enumeration enum = markers.elements();
		while(enum.hasMoreElements())
		{
			Marker marker = (Marker)enum.nextElement();
			if(marker.getShortcut() == shortcut)
				return marker;
		}
		return null;
	}
	/**
	 * Returns the next buffer in the list.
	 */
	public final Buffer getNext()
	{
		return next;
	}
	/**
	 * Returns the previous buffer in the list.
	 */
	public final Buffer getPrev()
	{
		return prev;
	}
	/**
	 * Returns the position of this buffer in the buffer list.
	 */
	public final int getIndex()
	{
		int count = 0;
		Buffer buffer = prev;
		for(;;)
		{
			if(buffer == null)
				break;
			count++;
			buffer = buffer.prev;
		}
		return count;
	}
	/**
	 * Returns a string representation of this buffer.
	 * This simply returns the path name.
	 */
	public String toString()
	{
		return name + "" ("" + vfs.getParentOfPath(path) + "")"";
	}
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
	}
	// package-private members
	Buffer prev;
	Buffer next;
	Buffer(View view, String path, boolean newFile, boolean temp,
		Hashtable props)
	{
		lineCount = 1;
		lineInfo = new LineInfo[1];
		lineInfo[0] = new LineInfo();
		lineInfo[0].visible = true;
		virtualLineCount = 1;
		virtualLines = new int[1];
		foldListeners = new Vector();
		seg = new Segment();
		lastTokenizedLine = -1;
		setDocumentProperties(new BufferProps());
		clearProperties();
		setFlag(TEMPORARY,temp);
		markers = new Vector();
		addUndoableEditListener(new UndoHandler());
		Enumeration keys = props.keys();
		Enumeration values = props.elements();
		while(keys.hasMoreElements())
		{
			putProperty(keys.nextElement(),values.nextElement());
		}
		Mode defaultMode = jEdit.getMode(jEdit.getProperty(""buffer.defaultMode""));
		if(defaultMode == null)
			defaultMode = jEdit.getMode(""text"");
		setMode(defaultMode);
		setPath(path);
		/* Magic: UNTITLED is only set if newFile param to
		 * constructor is set, NEW_FILE is also set if file
		 * doesn't exist on disk.
		 *
		 * This is so that we can tell apart files created
		 * with jEdit.newFile(), and those that just don't
		 * exist on disk.
		 *
		 * Why do we need to tell the difference between the
		 * two? jEdit.addBufferToList() checks if the only
		 * opened buffer is an untitled buffer, and if so,
		 * replaces it with the buffer to add. We don't want
		 * this behavior to occur with files that don't
		 * exist on disk; only untitled ones.
		 */
		setFlag(UNTITLED,newFile);
		if(file != null)
			newFile |= !file.exists();
		if(!temp)
			EditBus.addToBus(Buffer.this);
		setFlag(NEW_FILE,newFile);
	}
	void commitTemporary()
	{
		setFlag(TEMPORARY,false);
		EditBus.addToBus(this);
	}
	void close()
	{
		setFlag(CLOSED,true);
		if(autosaveFile != null)
			autosaveFile.delete();
		EditBus.removeFromBus(this);
	}
	// protected members
	/**
	 * We overwrite this method to update the line info array
	 * state immediately so that any event listeners get a
	 * consistent token marker.
	 */
	protected void fireInsertUpdate(DocumentEvent evt)
	{
		DocumentEvent.ElementChange ch = evt.getChange(
			getDefaultRootElement());
		if(ch != null)
		{
			int index = ch.getIndex();
			int len = ch.getChildrenAdded().length -
				ch.getChildrenRemoved().length;
			addLinesToMap(ch.getIndex() + 1,len);
			linesChanged(index,lineCount - index);
			index += (len + 1);
		}
		else
		{
			linesChanged(getDefaultRootElement()
				.getElementIndex(evt.getOffset()),1);
		}
		super.fireInsertUpdate(evt);
		setDirty(true);
	}
	/**
	 * We overwrite this method to update the line info array
	 * state immediately so that any event listeners get a
	 * consistent token marker.
	 */
	protected void fireRemoveUpdate(DocumentEvent evt)
	{
		DocumentEvent.ElementChange ch = evt.getChange(
			getDefaultRootElement());
		if(ch != null)
		{
			int index = ch.getIndex();
			int len = ch.getChildrenRemoved().length -
				ch.getChildrenAdded().length;
			removeLinesFromMap(index,len);
			linesChanged(index,lineCount - index);
		}
		else
		{
			linesChanged(getDefaultRootElement()
				.getElementIndex(evt.getOffset()),1);
		}
		super.fireRemoveUpdate(evt);
		setDirty(true);
	}
	// private members
	private void setFlag(int flag, boolean value)
	{
		if(value)
			flags |= (1 << flag);
		else
			flags &= ~(1 << flag);
	}
	private boolean getFlag(int flag)
	{
		int mask = (1 << flag);
		return (flags & mask) == mask;
	}
	private static final int CLOSED = 0;
	private static final int LOADING = 1;
	private static final int IO = 2;
	private static final int NEW_FILE = 3;
	private static final int UNTITLED = 4;
	private static final int AUTOSAVE_DIRTY = 5;
	private static final int DIRTY = 6;
	private static final int READ_ONLY = 7;
	private static final int UNDO_IN_PROGRESS = 8;
	private static final int TEMPORARY = 9;
	private int flags;
	private long modTime;
	private File file;
	private VFS vfs;
	private File autosaveFile;
	private String path;
	private String name;
	private Mode mode;
	private MyUndoManager undo;
	private CompoundEdit compoundEdit;
	private boolean compoundEditNonEmpty;
	private int compoundEditCount;
	private Vector markers;
	private int savedSelStart;
	private int savedSelEnd;
	// Syntax highlighting
	private TokenMarker tokenMarker;
	private Segment seg;
	private LineInfo[] lineInfo;
	private int lineCount;
	private int lastTokenizedLine;
	private boolean nextLineRequested;
	// Folding
	private int[] virtualLines;
	private int virtualLineCount;
	private Vector foldListeners;
	private void setPath(String path)
	{
		this.path = path;
		vfs = VFSManager.getVFSForPath(path);
		if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)
			setReadOnly(true);
		name = vfs.getFileName(path);
		if(vfs instanceof FileVFS)
		{
			file = new File(path);
			// if we don't do this, the autosave file won't be
			// deleted after a save as
			if(autosaveFile != null)
				autosaveFile.delete();
			autosaveFile = new File(file.getParent(),'#' + name + '#');
		}
	}
	private boolean recoverAutosave(final View view)
	{
		if(!autosaveFile.canRead())
			return false;
		// this method might get called at startup
		GUIUtilities.hideSplashScreen();
		final Object[] args = { autosaveFile.getPath() };
		int result = GUIUtilities.confirm(view,""autosave-found"",args,
			JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
		if(result == JOptionPane.YES_OPTION)
		{
			vfs.load(view,this,autosaveFile.getPath());
			// show this message when all I/O requests are
			// complete
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					GUIUtilities.message(view,""autosave-loaded"",args);
				}
			});
			return true;
		}
		else
			return false;
	}
	private void clearProperties()
	{
		Object lineSeparator = getProperty(LINESEP);
		Object encoding = getProperty(ENCODING);
		((BufferProps)getDocumentProperties()).clear();
		putProperty(""i18n"",Boolean.FALSE);
		if(lineSeparator != null)
			putProperty(LINESEP,lineSeparator);
		if(encoding != null)
			putProperty(ENCODING,encoding);
		else
			putProperty(ENCODING,System.getProperty(""file.encoding""));
	}
	private void parseBufferLocalProperties()
	{
		try
		{
			Element map = getDefaultRootElement();
			for(int i = 0; i < Math.min(10,map.getElementCount()); i++)
			{
				Element line = map.getElement(i);
				String text = getText(line.getStartOffset(),
					line.getEndOffset() - line.getStartOffset() - 1);
				parseBufferLocalProperty(text);
			}
			// Create marker positions
			for(int i = 0; i < markers.size(); i++)
			{
				((Marker)markers.elementAt(i))
					.createPosition();
			}
		}
		catch(BadLocationException bl)
		{
			bl.printStackTrace();
		}
	}
	private void parseBufferLocalProperty(String prop)
	{
		StringBuffer buf = new StringBuffer();
		String name = null;
		boolean escape = false;
		for(int i = 0; i < prop.length(); i++)
		{
			char c = prop.charAt(i);
			switch(c)
			{
			case ':':
				if(escape)
				{
					escape = false;
					buf.append(':');
					break;
				}
				if(name != null)
				{
					String value = buf.toString();
					try
					{
						putProperty(name,new Integer(value));
					}
					catch(NumberFormatException nf)
					{
						putProperty(name,value);
					}
				}
				buf.setLength(0);
				break;
			case '=':
				if(escape)
				{
					escape = false;
					buf.append('=');
					break;
				}
				name = buf.toString();
				buf.setLength(0);
				break;
			case '\\':
				if(escape)
					buf.append('\\');
				escape = !escape;
				break;
			case 'n':
				if(escape)
				{	buf.append('\n');
					escape = false;
					break;
				}
			case 't':
				if(escape)
				{
					buf.append('\t');
					escape = false;
					break;
				}
			default:
				buf.append(c);
				break;
			}
		}
	}
	private void setTokenMarker(TokenMarker tokenMarker)
	{
		this.tokenMarker = tokenMarker;
		ParserRuleSet mainSet = tokenMarker.getMainRuleSet();
		for(int i = 0; i < lineCount; i++)
		{
			LineInfo info = lineInfo[i];
			info.context = new TokenMarker.LineContext(null,mainSet);
			info.tokensValid = false;
		}
	}
	/**
	 * Inserts the specified line range into the virtual to physical
	 * mapping and line info array.
	 * @param index The first line number
	 * @param lines The number of lines
	 */
	private void addLinesToMap(int index, int lines)
	{
		//System.err.println(""adding "" + index + "":"" + lines + "" to map"");
		if(lines <= 0)
			return;
		LineInfo prev = lineInfo[index - 1];
		int virtualLine;
		// special case
		if(index == lineCount)
			virtualLine = virtualLineCount;
		else
			virtualLine = physicalToVirtual(index);
		int virtualLength;
		/* update the virtual -> physical mapping if the newly
		 * inserted lines are actually visible */
		if(prev.visible)
		{
			virtualLineCount += lines;
			if(virtualLines.length <= virtualLineCount)
			{
				int[] virtualLinesN = new int[
					(virtualLineCount + 1) * 2];
				System.arraycopy(virtualLines,0,
					virtualLinesN,0,
					virtualLines.length);
				virtualLines = virtualLinesN;
			}
			virtualLength = virtualLine + lines;
			System.arraycopy(virtualLines,virtualLine,
				virtualLines,virtualLength,
				virtualLines.length - virtualLength);
			for(int i = 0; i < lines; i++)
				virtualLines[virtualLine + i] = index + i;
		}
		else
			virtualLength = virtualLine /* + 1 */;
		for(int i = virtualLength; i < virtualLineCount; i++)
			virtualLines[i] += lines;
		lineCount += lines;
		if(lineInfo.length <= lineCount)
		{
			LineInfo[] lineInfoN = new LineInfo[(lineCount + 1) * 2];
			System.arraycopy(lineInfo,0,lineInfoN,0,
					 lineInfo.length);
			lineInfo = lineInfoN;
		}
		int length = index + lines;
		System.arraycopy(lineInfo,index,lineInfo,length,
			lineInfo.length - length);
		ParserRuleSet mainSet = tokenMarker.getMainRuleSet();
		for(int i = 0; i < lines; i++)
		{
			LineInfo info = new LineInfo();
			info.context = new TokenMarker.LineContext(null,mainSet);
			info.visible = prev.visible;
			lineInfo[index + i] = info;
		}
	}
	/**
	 * Deletes the specified line range from the virtual to physical
	 * mapping and line info array.
	 * @param index The first line number
	 * @param lines The number of lines
	 */
	private void removeLinesFromMap(int index, int lines)
	{
		if (lines <= 0)
			return;
		int length = index + lines;
		int virtualLine = physicalToVirtual(index);
		int virtualLength = physicalToVirtual(length);
		if(length <= virtualLines[virtualLineCount - 1])
		{
			System.arraycopy(virtualLines,virtualLength,
				virtualLines,virtualLine,
				virtualLines.length - virtualLength);
			for(int i = virtualLine;
				i < virtualLineCount
				- (virtualLength - virtualLine);
				i++)
				virtualLines[i] -= lines;
		}
		virtualLineCount -= (virtualLength - virtualLine);
		lineCount -= lines;
		System.arraycopy(lineInfo,length,lineInfo,
			index,lineInfo.length - length);
	}
	/**
	 * Called when the specified lines change. This invalidates
	 * cached syntax tokens and fold level.
	 * @param index The first line number
	 * @param lines The number of lines
	 */
	private void linesChanged(int index, int lines)
	{
		for(int i = 0; i < lines; i++)
		{
			LineInfo info = lineInfo[index + i];
			info.tokensValid = false;
			info.foldLevelValid = false;
		}
	}
	static class PrintTabExpander implements TabExpander
	{
		private int leftMargin;
		private int tabSize;
		public PrintTabExpander(int leftMargin, int tabSize)
		{
			this.leftMargin = leftMargin;
			this.tabSize = tabSize;
		}
		public float nextTabStop(float x, int tabOffset)
		{
			int ntabs = ((int)x - leftMargin) / tabSize;
			return (ntabs + 1) * tabSize + leftMargin;
		}
	}
	private void fireFoldLevelsChanged(int firstLine, int lastLine)
	{
		for(int i = 0; i < foldListeners.size(); i++)
		{
			((FoldListener)foldListeners.elementAt(i))
				.foldLevelsChanged(firstLine,lastLine);
		}
	}
	private void fireFoldStructureChanged()
	{
		for(int i = 0; i < foldListeners.size(); i++)
		{
			((FoldListener)foldListeners.elementAt(i))
				.foldStructureChanged();
		}
	}
	/**
	 * Only useful for the text area.
	 */
	public static interface FoldListener
	{
		void foldLevelsChanged(int firstLine, int lastLine);
		void foldStructureChanged();
	}
	/**
	 * Inner class for storing information about tokenized lines.
	 */
	public static class LineInfo
	{
		/**
		 * Do not use this variable. The only reason it is public
		 * is so that classes in the 'syntax' package can use it.
		 */
		public TokenMarker.LineContext context;
		/**
		 * Returns the first syntax token.
		 * @since jEdit 3.1pre1
		 */
		public Token getFirstToken()
		{
			return firstToken;
		}
		/**
		 * Returns the last syntax token.
		 * @since jEdit 3.1pre1
		 */
		public Token getLastToken()
		{
			return lastToken;
		}
		/**
		 * Do not call this method. The only reason it is public
		 * is so that classes in the 'syntax' package can call it.
		 */
		public void addToken(int length, byte id)
		{
			if(length == 0 && id != Token.END)
				return;
			if(firstToken == null)
			{
				firstToken = new Token(length,id);
				lastToken = firstToken;
			}
			else if(lastToken == null)
			{
				lastToken = firstToken;
				firstToken.length = length;
				firstToken.id = id;
			}
			else if(lastToken.id == id)
			{
				lastToken.length += length;
			}
			else if(lastToken.next == null)
			{
				lastToken.next = new Token(length,id);
				lastToken.next.prev = lastToken;
				lastToken = lastToken.next;
			}
			else
			{
				lastToken = lastToken.next;
				lastToken.length = length;
				lastToken.id = id;
			}
		}
		// package-private members
		Token firstToken;
		Token lastToken;
		boolean tokensValid;
		int width;
		int foldLevel;
		boolean foldLevelValid;
		boolean visible;
	}
	// A dictionary that looks in the mode and editor properties
	// for default values
	class BufferProps extends Hashtable
	{
		public Object get(Object key)
		{
			// First try the buffer-local properties
			Object o = super.get(key);
			if(o != null)
				return o;
			// JDK 1.3 likes to use non-string objects
			// as keys
			if(!(key instanceof String))
				return null;
			// Now try mode.<mode>.<property>
			if(mode != null)
				return mode.getProperty((String)key);
			else
			{
				// Now try buffer.<property>
				String value = jEdit.getProperty(""buffer."" + key);
				if(value == null)
					return null;
				// Try returning it as an integer first
				try
				{
					return new Integer(value);
				}
				catch(NumberFormatException nf)
				{
					return value;
				}
			}
		}
	}
	// we need to call some protected methods, so override this class
	// to make them public
	class MyUndoManager extends UndoManager
	{
		public UndoableEdit editToBeUndone()
		{
			return super.editToBeUndone();
		}
		public UndoableEdit editToBeRedone()
		{
			return super.editToBeRedone();
		}
	}
	// event handlers
	class UndoHandler
	implements UndoableEditListener
	{
		public void undoableEditHappened(UndoableEditEvent evt)
		{
			addUndoableEdit(evt.getEdit());
		}
	}
}
"
org.gjt.sp.jedit.BufferHistory,"/*
 * BufferHistory.java - Remembers caret positions 
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import com.microstar.xml.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
public class BufferHistory
{
	public static Entry getEntry(String path)
	{
		Enumeration enum = history.elements();
		while(enum.hasMoreElements())
		{
			Entry entry = (Entry)enum.nextElement();
			if(pathsCaseInsensitive)
			{
				if(entry.path.equalsIgnoreCase(path))
					return entry;
			}
			else
			{
				if(entry.path.equals(path))
					return entry;
			}
		}
		return null;
	}
	public static void setEntry(String path, int caret, Selection[] selection,
		String encoding)
	{
		removeEntry(path);
		addEntry(new Entry(path,caret,selectionToString(selection),encoding));
	}
	public static Vector getBufferHistory()
	{
		return history;
	}
	public static void load(File file)
	{
		try
		{
			max = Integer.parseInt(jEdit.getProperty(""recentFiles""));
		}
		catch(NumberFormatException e)
		{
			max = 50;
		}
		Log.log(Log.MESSAGE,jEdit.class,""Loading recent file list "" + file);
		RecentHandler handler = new RecentHandler();
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		try
		{
			BufferedReader in = new BufferedReader(new FileReader(file));
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,BufferHistory.class,file + "":"" + line
				+ "": "" + message);
		}
		catch(FileNotFoundException fnf)
		{
			Log.log(Log.DEBUG,BufferHistory.class,fnf);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,BufferHistory.class,e);
		}
	}
	public static void save(File file)
	{
		String lineSep = System.getProperty(""line.separator"");
		try
		{
			BufferedWriter out = new BufferedWriter(
				new FileWriter(file));
			out.write(""<?xml version=\""1.0\""?>"");
			out.write(lineSep);
			out.write(""<!DOCTYPE RECENT SYSTEM \""recent.dtd\"">"");
			out.write(lineSep);
			out.write(""<RECENT>"");
			out.write(lineSep);
			Enumeration enum = history.elements();
			while(enum.hasMoreElements())
			{
				out.write(""<ENTRY>"");
				out.write(lineSep);
				Entry entry = (Entry)enum.nextElement();
				out.write(""<PATH><![CDATA["");
				out.write(entry.path);
				out.write(""]]></PATH>"");
				out.write(lineSep);
				out.write(""<CARET>"");
				out.write(String.valueOf(entry.caret));
				out.write(""</CARET>"");
				out.write(lineSep);
				if(entry.selection != null
					&& entry.selection.length() > 0)
				{
					out.write(""<SELECTION>"");
					out.write(entry.selection);
					out.write(""</SELECTION>"");
					out.write(lineSep);
				}
				if(entry.encoding != null)
				{
					out.write(""<ENCODING>"");
					out.write(entry.encoding);
					out.write(""</ENCODING>"");
					out.write(lineSep);
				}
				out.write(""</ENTRY>"");
				out.write(lineSep);
			}
			out.write(""</RECENT>"");
			out.write(lineSep);
			out.close();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,BufferHistory.class,e);
		}
	}
	// private members
	private static Vector history;
	private static boolean pathsCaseInsensitive;
	private static int max;
	static
	{
		history = new Vector();
		pathsCaseInsensitive = (File.separatorChar == '\\'
			|| File.separatorChar == ':');
	}
	/* private */ static void addEntry(Entry entry)
	{
		history.addElement(entry);
		while(history.size() > max)
			history.removeElementAt(0);
	}
	/* private */ static void removeEntry(String path)
	{
		Enumeration enum = history.elements();
		for(int i = 0; i < history.size(); i++)
		{
			Entry entry = (Entry)history.elementAt(i);
			if(entry.path.equals(path))
			{
				history.removeElementAt(i);
				return;
			}
		}
	}
	private static String selectionToString(Selection[] s)
	{
		if(s == null)
			return null;
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < s.length; i++)
		{
			if(i != 0)
				buf.append(' ');
			Selection sel = s[i];
			if(sel instanceof Selection.Range)
				buf.append(""range "");
			else //if(sel instanceof Selection.Rect)
				buf.append(""rect "");
			buf.append(sel.getStart());
			buf.append(' ');
			buf.append(sel.getEnd());
		}
		return buf.toString();
	}
	private static Selection[] stringToSelection(String s)
	{
		if(s == null)
			return null;
		Vector selection = new Vector();
		StringTokenizer st = new StringTokenizer(s);
		while(st.hasMoreTokens())
		{
			String type = st.nextToken();
			int start = Integer.parseInt(st.nextToken());
			int end = Integer.parseInt(st.nextToken());
			Selection sel;
			if(type.equals(""range""))
				sel = new Selection.Range(start,end);
			else //if(type.equals(""rect""))
				sel = new Selection.Rect(start,end);
			selection.addElement(sel);
		}
		Selection[] returnValue = new Selection[selection.size()];
		selection.copyInto(returnValue);
		return returnValue;
	}
	public static class Entry
	{
		public String path;
		public int caret;
		public String selection;
		public String encoding;
		public Selection[] getSelection()
		{
			return stringToSelection(selection);
		}
		public Entry(String path, int caret, String selection, String encoding)
		{
			this.path = path;
			this.caret = caret;
			this.selection = selection;
			this.encoding = encoding;
		}
	}
	static class RecentHandler extends HandlerBase
	{
		public Object resolveEntity(String publicId, String systemId)
		{
			if(""recent.dtd"".equals(systemId))
			{
				try
				{
					return new BufferedReader(new InputStreamReader(
						getClass().getResourceAsStream(""recent.dtd"")));
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,this,""Error while opening""
						+ "" recent.dtd:"");
					Log.log(Log.ERROR,this,e);
				}
			}
			return null;
		}
		public void doctypeDecl(String name, String publicId,
			String systemId) throws Exception
		{
			if(""RECENT"".equals(name))
				return;
			Log.log(Log.ERROR,this,""recent.xml: DOCTYPE must be RECENT"");
		}
		public void endElement(String name)
		{
			if(name.equals(""ENTRY""))
			{
				addEntry(new Entry(path,caret,selection,encoding));
				path = null;
				caret = 0;
				selection = null;
				encoding = null;
			}
			else if(name.equals(""PATH""))
				path = charData;
			else if(name.equals(""CARET""))
				caret = Integer.parseInt(charData);
			else if(name.equals(""SELECTION""))
				selection = charData;
			else if(name.equals(""ENCODING""))
				encoding = charData;
		}
		public void charData(char[] ch, int start, int length)
		{
			charData = new String(ch,start,length);
		}
		// end HandlerBase implementation
		// private members
		private String path;
		private int caret;
		private String selection;
		private String encoding;
		private String charData;
	}
}
"
org.gjt.sp.jedit.EBComponent,"/*
 * EBComponent.java - An EditBus component
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
/**
 * A component on the EditBus. Messages sent on the EditBus are forwarded
 * to all components in turn.
 * @author Slava Pestov
 * @version $Id: EBComponent.java,v 1.2 1999/11/21 01:20:30 sp Exp $
 *
 * @since jEdit 2.2pre6
 */
public interface EBComponent
{
	/**
	 * Handles a message sent on the EditBus.
	 * @param message The message
	 */
	void handleMessage(EBMessage message);
}
"
org.gjt.sp.jedit.EBMessage,"/*
 * EBMessage.java - An EditBus message
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.util.Enumeration;
import java.util.Vector;
/**
 * The base class of all EditBus messages.
 * @author Slava Pestov
 * @version $Id: EBMessage.java,v 1.2 1999/11/26 07:37:11 sp Exp $
 *
 * @since jEdit 2.2pre6
 */
public abstract class EBMessage
{
	/**
	 * Creates a new message.
	 * @param source The message source
	 */
	public EBMessage(EBComponent source)
	{
		this.source = source;
	}
	/**
	 * Returns the sender of this message.
	 */
	public EBComponent getSource()
	{
		return source;
	}
	/**
	 * Vetoes this message. It will not be passed on further
	 * on the bus, and instead will be returned directly to
	 * the sender with the vetoed flag on.
	 */
	public void veto()
	{
		vetoed = true;
	}
	/**
	 * Returns if this message has been vetoed by another
	 * bus component.
	 */
	public boolean isVetoed()
	{
		return vetoed;
	}
	/**
	 * Returns a string representation of this message.
	 */
	public String toString()
	{
		return getClass().getName() + ""["" + paramString() + ""]"";
	}
	/**
	 * Returns a string representation of this message's parameters.
	 */
	public String paramString()
	{
		return ""source="" + source;
	}
	// private members
	private EBComponent source;
	private boolean vetoed;
	/**
	 * A message implementation that cannot be vetoed.
	 */
	public static abstract class NonVetoable extends EBMessage
	{
		/**
		 * Creates a new non-vetoable message.
		 * @param source The message source
		 */
		public NonVetoable(EBComponent source)
		{
			super(source);
		}
		/**
		 * Disallows this message from being vetoed.
		 */
		public void veto()
		{
			throw new InternalError(""Can't veto this message"");
		}
	}
	/**
	 * A message implementation that allows components to attach return
	 * values to the message, thus allowing information to be collected
	 * from others on the bus. Because this type of message is indended
	 * to collect information from all other members of the bus, it is
	 * non-vetoable.
	 */
// 	public static abstract class ReturnValue extends NonVetoable
// 	{
// 		/**
// 		 * Creates a new return value message.
// 		 * @param source The message source
// 		 */
// 		public ReturnValue(EBComponent source)
// 		{
// 			super(source);
// 		}
// 
// 		/**
// 		 * Adds data to the return value list. Subclasses should
// 		 * check that the object is of the correct type.
// 		 * @param obj The object
// 		 */
// 		public void addReturn(Object obj)
// 		{
// 			if(returnValues == null)
// 				returnValues = new Vector();
// 			returnValues.addElement(obj);
// 		}
// 
// 		/**
// 		 * Returns the values added to the return list by other
// 		 * handlers of this message. Returns null if no values were
// 		 * present.
// 		 */
// 		public Object[] getReturnValues()
// 		{
// 			if(returnValues == null)
// 				return null;
// 			Object[] array = new Object[returnValues.size()];
// 			returnValues.copyInto(array);
// 			return array;
// 		}
// 
// 		/**
// 		 * Returns a string representation of this message's parameters.
// 		 */
// 		public String paramString()
// 		{
// 			return super.paramString() + "",returnValues="" + returnValues;
// 		}
// 
// 		// private members
// 		private Vector returnValues;
// 	}
}
"
org.gjt.sp.jedit.EBPlugin,"/*
 * EBPlugin.java - An EditBus plugin
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.util.Vector;
import org.gjt.sp.jedit.gui.OptionsDialog;
/**
 * An EditBus plugin
 * @author Slava Pestov
 * @version $Id: EBPlugin.java,v 1.4 2000/01/29 10:12:43 sp Exp $
 */
public abstract class EBPlugin extends EditPlugin implements EBComponent
{
	/**
	 * Handles a message sent on the EditBus. The default
	 * implementation ignores the message.
	 */
	public void handleMessage(EBMessage message) {}
	// protected members
	protected EBPlugin()
	{
		EditBus.addToBus(this);
	}
}
"
org.gjt.sp.jedit.EditAction,"/*
 * EditAction.java - jEdit action listener
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.JPopupMenu;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.Component;
import java.util.EventObject;
import org.gjt.sp.util.Log;
/**
 * Instead of subclassing EditAction directly, you should now write an
 * actions.xml file.
 *
 * @author Slava Pestov
 * @version $Id: EditAction.java,v 1.37 2001/07/11 06:59:20 sp Exp $
 */
public abstract class EditAction
// no longer implements ActionListener
{
	/**
	 * @deprecated Create an actions.xml file instead of writing
	 * EditAction implementations!
	 */
	public EditAction(String name)
	{
		// The only people who use this constructor are
		// plugins written for the old action API, so
		// we can safely assume that 'plugin' should be
		// true.
		this(name,true);
	}
	/**
	 * Creates a new <code>EditAction</code>.
	 * @param name The name of the action
	 * @param plugin True if this is a plugin action
	 * @since jEdit 3.1pre1
	 */
	/* package-private */ EditAction(String name, boolean plugin)
	{
		this.name = name;
		this.plugin = plugin;
	}
	/**
	 * Returns the internal name of this action.
	 */
	public final String getName()
	{
		return name;
	}
	/**
	 * Returns true if this action was loaded from a plugin, false
	 * if it was loaded from the core.
	 * @since jEdit 3.1pre1
	 */
	public boolean isPluginAction()
	{
		return plugin;
	}
	/**
	 * Invokes the action.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public void invoke(View view)
	{
		// default implementation
		ActionEvent evt = new ActionEvent(view,
			ActionEvent.ACTION_PERFORMED,
			null);
		actionPerformed(evt);
	}
	/**
	 * @deprecated Create an actions.xml file instead of writing
	 * EditAction implementations!
	 */
	public void actionPerformed(ActionEvent evt) {}
	/**
	 * @deprecated No longer necessary.
	 */
	public static View getView(EventObject evt)
	{
		if(evt != null)
		{
			Object o = evt.getSource();
			if(o instanceof Component)
				return getView((Component)o);
		}
		// this shouldn't happen
		return null;
	}
	/**
	 * @deprecated No longer necessary.
	 */
	public static Buffer getBuffer(EventObject evt)
	{
		View view = getView(evt);
		if(view != null)
			return view.getBuffer();
		return null;
	}
	/**
	 * Finds the view parent of the specified component.
	 * @since jEdit 2.2pre4
	 */
	public static View getView(Component comp)
	{
		for(;;)
		{
			if(comp instanceof View)
				return (View)comp;
			else if(comp instanceof JPopupMenu)
				comp = ((JPopupMenu)comp).getInvoker();
			else if(comp != null)
				comp = comp.getParent();
			else
				break;
		}
		return null;
	}
	/**
	 * Returns if this edit action should be displayed as a check box
	 * in menus.
	 * @since jEdit 2.2pre4
	 */
	public boolean isToggle()
	{
		return false;
	}
	/**
	 * If this edit action is a toggle, returns if it is selected or not.
	 * @param view The view
	 * @since jEdit 3.2pre5
	 */
	public boolean isSelected(View view)
	{
		return isSelected((Component)view);
	}
	/**
	 * @deprecated Override the form that accepts a view instead
	 */
	public boolean isSelected(Component comp)
	{
		return false;
	}
	/**
	 * Returns if this edit action should not be repeated. Returns false
	 * by default.
	 * @since jEdit 2.7pre2
	 */
	public boolean noRepeat()
	{
		return false;
	}
	/**
	 * Returns if this edit action should not be recorded. Returns false
	 * by default.
	 * @since jEdit 2.7pre2
	 */
	public boolean noRecord()
	{
		return false;
	}
	/**
	 * Returns the BeanShell code that will replay this action.
	 * @since jEdit 2.7pre2
	 */
	public String getCode()
	{
		return ""view.getInputHandler().invokeAction(""
			+ ""jEdit.getAction(\"""" + name + ""\""))"";
	}
	public String toString()
	{
		return name;
	}
	// private members
	private String name;
	private boolean plugin;
	/**
	 * 'Wrap' EditActions in this class to turn them into AWT
	 * ActionListeners, that can be attached to buttons, menu items, etc.
	 */
	public static class Wrapper implements ActionListener
	{
		public Wrapper(EditAction action)
		{
			this.action = action;
		}
		/**
		 * Called when the user selects this action from a menu.
		 * It passes the action through the
		 * <code>InputHandler.executeAction()</code> method,
		 * which performs any recording or repeating. It also
		 * loads the action if necessary.
		 *
		 * @param evt The action event
		 */
		public void actionPerformed(ActionEvent evt)
		{
			// Let input handler do recording, repeating, etc
			EditAction.getView(evt).getInputHandler()
				.invokeAction(action);
		}
		// private members
		private EditAction action;
	}
}
"
org.gjt.sp.jedit.EditBus,"/*
 * EditBus.java - The EditBus
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.util.*;
import org.gjt.sp.util.Log;
/**
 * The EditBus provides a way for plugins to communicate without knowing
 * too much about each other's internals.<p>
 *
 * The EditBus is similar to the data bus inside a computer; there are
 * a number of components connected, and all components can send messages
 * to the bus. When a message is sent, all other components receive it,
 * and do something appropriate (or simply ignore it).
 *
 * @author Slava Pestov
 * @version $Id: EditBus.java,v 1.5 2000/11/29 06:53:00 sp Exp $
 *
 * @since jEdit 2.2pre6
 */
public class EditBus
{
	/**
	 * Adds a component to the bus. It will receive all messages sent
	 * on the bus.
	 * @param comp The component to add
	 */
	public static void addToBus(EBComponent comp)
	{
		synchronized(components)
		{
			components.addElement(comp);
			copyComponents = null;
		}
	}
	/**
	 * Removes a component from the bus.
	 * @param comp The component to remove
	 */
	public static void removeFromBus(EBComponent comp)
	{
		synchronized(components)
		{
			components.removeElement(comp);
			copyComponents = null;
		}
	}
	/**
	 * Returns an array of all components connected to the bus.
	 */
	public static EBComponent[] getComponents()
	{
		synchronized(components)
		{
			if (copyComponents == null)
			{
				copyComponents = new EBComponent[components.size()];
				components.copyInto(copyComponents);
			}
			return copyComponents;
		}
	}
	/**
	 * Sends a message to all components on the bus.
	 * The message will be sent to all components in turn, with the
	 * original sender receiving it last.
	 * @param message The message
	 */
	public static void send(EBMessage message)
	{
		Log.log(Log.DEBUG,EditBus.class,message.toString());
		// To avoid any problems if components are added or removed
		// while the message is being sent
		EBComponent[] comps = getComponents();
		for(int i = 0; i < comps.length; i++)
		{
			try
			{
				comps[i].handleMessage(message);
				if(message.isVetoed())
					break;
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,EditBus.class,""Exception""
					+ "" while sending message on EditBus:"");
				Log.log(Log.ERROR,EditBus.class,t);
			}
		}
	}
	/**
	 * Returns a named list.
	 * @param tag The list name
	 */
	public static Object[] getNamedList(Object tag)
	{
		Object[] list = (Object[])listArrays.get(tag);
		if(list != null)
			return list;
		Vector listVector = (Vector)listVectors.get(tag);
		if(listVector != null)
		{
			list = new Object[listVector.size()];
			listVector.copyInto(list);
			listArrays.put(tag,list);
			return list;
		}
		return null;
	}
	/**
	 * Returns an enumeration of all named lists.
	 * @param tag The list name
	 */
	public static Enumeration getNamedLists()
	{
		return listVectors.keys();
	}
	/**
	 * Adds an entry to a named list.
	 * @param tag The list name
	 * @param entry The entry
	 */
	public static void addToNamedList(Object tag, Object entry)
	{
		Vector listVector = (Vector)listVectors.get(tag);
		if(listVector == null)
		{
			listVector = new Vector();
			listVectors.put(tag,listVector);
		}
		listVector.addElement(entry);
		listArrays.remove(tag);
	}
	/**
	 * Removes an entry from a named list.
	 * @param tag The list name
	 * @param entry The entry
	 */
	public static void removeFromNamedList(Object tag, Object entry)
	{
		Vector listVector = (Vector)listVectors.get(tag);
		if(listVector == null)
			return;
		listVector.removeElement(entry);
		listArrays.remove(tag);
	}
	// private members
	private static Vector components = new Vector();
	private static EBComponent[] copyComponents;
	private static Hashtable listVectors = new Hashtable();
	private static Hashtable listArrays = new Hashtable();
	// can't create new instances
	private EditBus() {}
}
"
org.gjt.sp.jedit.EditPane,"/*
 * EditPane.java - Text area and buffer switcher
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
/**
 * A panel containing a text area. Each edit pane can edit one buffer at
 * a time.
 * @author Slava Pestov
 * @version $Id: EditPane.java,v 1.47 2001/08/23 07:39:09 sp Exp $
 */
public class EditPane extends JPanel implements EBComponent
{
	/**
	 * Returns the view containing this edit pane.
	 * @since jEdit 2.5pre2
	 */
	public View getView()
	{
		return view;
	}
	/**
	 * Returns the current buffer.
	 * @since jEdit 2.5pre2
	 */
	public Buffer getBuffer()
	{
		return buffer;
	}
	/**
	 * Sets the current buffer.
	 * @param buffer The buffer to edit.
	 * @since jEdit 2.5pre2
	 */
	public void setBuffer(final Buffer buffer)
	{
		if(this.buffer == buffer)
			return;
		if(buffer.isClosed())
			throw new InternalError(buffer + "" has been closed"");
		buffer.endCompoundEdit();
		recentBuffer = this.buffer;
		if(recentBuffer != null)
			saveCaretInfo();
		this.buffer = buffer;
		textArea.setBuffer(buffer);
		if(!init)
		{
			view.updateTitle();
			if(bufferSwitcher != null)
			{
				if(bufferSwitcher.getSelectedItem() != buffer)
					bufferSwitcher.setSelectedItem(buffer);
			}
			EditBus.send(new EditPaneUpdate(this,EditPaneUpdate
				.BUFFER_CHANGED));
		}
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				// only do this if we are the current edit pane
				if(view.getEditPane() == EditPane.this
					&& (bufferSwitcher == null
					|| !bufferSwitcher.isPopupVisible()))
				{
					focusOnTextArea();
				}
			}
		});
		// Only do this after all I/O requests are complete
		Runnable runnable = new Runnable()
		{
			public void run()
			{
				loadCaretInfo();
				buffer.checkModTime(view);
			}
		};
		if(buffer.isPerformingIO())
			VFSManager.runInAWTThread(runnable);
		else
			runnable.run();
	}
	/**
	 * Selects the previous buffer.
	 * @since jEdit 2.7pre2
	 */
	public void prevBuffer()
	{
		Buffer buffer = this.buffer.getPrev();
		if(buffer == null)
			setBuffer(jEdit.getLastBuffer());
		else
			setBuffer(buffer);
	}
	/**
	 * Selects the next buffer.
	 * @since jEdit 2.7pre2
	 */
	public void nextBuffer()
	{
		Buffer buffer = this.buffer.getNext();
		if(buffer == null)
			setBuffer(jEdit.getFirstBuffer());
		else
			setBuffer(buffer);
	}
	/**
	 * Selects the most recently edited buffer.
	 * @since jEdit 2.7pre2
	 */
	public void recentBuffer()
	{
		if(recentBuffer != null)
			setBuffer(recentBuffer);
		else
			getToolkit().beep();
	}
	/**
	 * Sets the focus onto the text area.
	 * @since jEdit 2.5pre2
	 */
	public void focusOnTextArea()
	{
		textArea.grabFocus();
		// trying to work around buggy focus handling in some
		// Java versions
//		if(!textArea.hasFocus())
//		{
//			textArea.processFocusEvent(new FocusEvent(textArea,
//				FocusEvent.FOCUS_GAINED));
//		}
	}
	/**
	 * Returns the view's text area.
	 * @since jEdit 2.5pre2
	 */
	public JEditTextArea getTextArea()
	{
		return textArea;
	}
	/**
	 * Saves the caret information to the current buffer.
	 * @since jEdit 2.5pre2
	 */
	public void saveCaretInfo()
	{
		buffer.putProperty(Buffer.CARET,new Integer(
			textArea.getCaretPosition()));
		Selection[] selection = textArea.getSelection();
		if(selection != null)
			buffer.putProperty(Buffer.SELECTION,selection);
		buffer.putProperty(Buffer.SCROLL_VERT,new Integer(
			textArea.getFirstLine()));
		buffer.putProperty(Buffer.SCROLL_HORIZ,new Integer(
			textArea.getHorizontalOffset()));
	}
	/**
	 * Loads the caret information from the curret buffer.
	 * @since jEdit 2.5pre2
	 */
	public void loadCaretInfo()
	{
		Integer caret = (Integer)buffer.getProperty(Buffer.CARET);
		Selection[] selection = (Selection[])buffer.getProperty(Buffer.SELECTION);
		Integer firstLine = (Integer)buffer.getProperty(Buffer.SCROLL_VERT);
		Integer horizontalOffset = (Integer)buffer.getProperty(Buffer.SCROLL_HORIZ);
		if(caret != null)
		{
			textArea.setCaretPosition(Math.min(caret.intValue(),
				buffer.getLength()));
		}
		if(selection != null)
			textArea.setSelection(selection);
		if(firstLine != null)
			textArea.setFirstLine(firstLine.intValue());
		if(horizontalOffset != null)
			textArea.setHorizontalOffset(horizontalOffset.intValue());
	}
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
		{
			propertiesChanged();
			loadBufferSwitcher();
		}
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
	}
	/**
	 * Returns 0,0 for split pane compatibility.
	 */
	public final Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	}
	// package-private members
	EditPane(View view, Buffer buffer)
	{
		super(new BorderLayout());
		init = true;
		this.view = view;
		EditBus.addToBus(this);
		textArea = new JEditTextArea(view);
		add(BorderLayout.CENTER,textArea);
		markerHighlight = new MarkerHighlight();
		textArea.getGutter().addCustomHighlight(markerHighlight);
		propertiesChanged();
		if(buffer == null)
			setBuffer(jEdit.getFirstBuffer());
		else
			setBuffer(buffer);
		loadBufferSwitcher();
		init = false;
	}
	void close()
	{
		saveCaretInfo();
		EditBus.send(new EditPaneUpdate(this,EditPaneUpdate.DESTROYED));
		EditBus.removeFromBus(this);
	}
	// private members
	private boolean init;
	private View view;
	private Buffer buffer;
	private Buffer recentBuffer;
	private BufferSwitcher bufferSwitcher;
	private JEditTextArea textArea;
	private MarkerHighlight markerHighlight;
	private void propertiesChanged()
	{
		TextAreaPainter painter = textArea.getPainter();
		painter.setFont(UIManager.getFont(""TextArea.font""));
		painter.setBracketHighlightEnabled(jEdit.getBooleanProperty(
			""view.bracketHighlight""));
		painter.setBracketHighlightColor(GUIUtilities.parseColor(
			jEdit.getProperty(""view.bracketHighlightColor"")));
		painter.setEOLMarkersPainted(jEdit.getBooleanProperty(
			""view.eolMarkers""));
		painter.setEOLMarkerColor(GUIUtilities.parseColor(
			jEdit.getProperty(""view.eolMarkerColor"")));
		painter.setWrapGuidePainted(jEdit.getBooleanProperty(
			""view.wrapGuide""));
		painter.setWrapGuideColor(GUIUtilities.parseColor(
			jEdit.getProperty(""view.wrapGuideColor"")));
		painter.setCaretColor(GUIUtilities.parseColor(
			jEdit.getProperty(""view.caretColor"")));
		painter.setSelectionColor(GUIUtilities.parseColor(
			jEdit.getProperty(""view.selectionColor"")));
		painter.setBackground(GUIUtilities.parseColor(
			jEdit.getProperty(""view.bgColor"")));
		painter.setForeground(GUIUtilities.parseColor(
			jEdit.getProperty(""view.fgColor"")));
		painter.setBlockCaretEnabled(jEdit.getBooleanProperty(
			""view.blockCaret""));
		painter.setLineHighlightEnabled(jEdit.getBooleanProperty(
			""view.lineHighlight""));
		painter.setLineHighlightColor(GUIUtilities.parseColor(
			jEdit.getProperty(""view.lineHighlightColor"")));
		painter.setAntiAliasEnabled(jEdit.getBooleanProperty(
			""view.antiAlias""));
		painter.setFractionalFontMetricsEnabled(jEdit.getBooleanProperty(
			""view.fracFontMetrics""));
		painter.setStyles(GUIUtilities.loadStyles(jEdit.getProperty(""view.font""),
			Integer.parseInt(jEdit.getProperty(""view.fontsize""))));
		Gutter gutter = textArea.getGutter();
		gutter.setExpanded(jEdit.getBooleanProperty(
			""view.gutter.lineNumbers""));
		try
		{
			int interval = Integer.parseInt(jEdit.getProperty(
				""view.gutter.highlightInterval""));
			gutter.setHighlightInterval(interval);
		}
		catch(NumberFormatException nf)
		{
			// retain the default highlight interval
		}
		gutter.setCurrentLineHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.highlightCurrentLine""));
		gutter.setBackground(GUIUtilities.parseColor(
			jEdit.getProperty(""view.gutter.bgColor"")));
		gutter.setForeground(GUIUtilities.parseColor(
			jEdit.getProperty(""view.gutter.fgColor"")));
		gutter.setHighlightedForeground(GUIUtilities.parseColor(
			jEdit.getProperty(""view.gutter.highlightColor"")));
		gutter.setFoldColor(GUIUtilities.parseColor(
			jEdit.getProperty(""view.gutter.foldColor"")));
		markerHighlight.setMarkerHighlightColor(GUIUtilities.parseColor(
			jEdit.getProperty(""view.gutter.markerColor"")));
		markerHighlight.setHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.markerHighlight""));
		gutter.setCurrentLineForeground(GUIUtilities.parseColor(
			jEdit.getProperty(""view.gutter.currentLineColor"")));
		String alignment = jEdit.getProperty(
			""view.gutter.numberAlignment"");
		if (""right"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.RIGHT);
		}
		else if (""center"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.CENTER);
		}
		else // left == default case
		{
			gutter.setLineNumberAlignment(Gutter.LEFT);
		}
		try
		{
			String fontname = jEdit.getProperty(""view.gutter.font"");
			int fontsize = Integer.parseInt(jEdit.getProperty(
				""view.gutter.fontsize""));
			int fontstyle = Integer.parseInt(jEdit.getProperty(
				""view.gutter.fontstyle""));
			gutter.setFont(new Font(fontname,fontstyle,fontsize));
		}
		catch(NumberFormatException nf)
		{
			// retain the default font
		}
		try
		{
			int width = Integer.parseInt(jEdit.getProperty(
				""view.gutter.borderWidth""));
			gutter.setBorder(width, GUIUtilities.parseColor(
				jEdit.getProperty(""view.gutter.focusBorderColor"")),
				GUIUtilities.parseColor(jEdit.getProperty(
				""view.gutter.noFocusBorderColor"")),
				textArea.getPainter().getBackground());
		}
		catch(NumberFormatException nf)
		{
			// retain the default border
		}
		textArea.setCaretBlinkEnabled(jEdit.getBooleanProperty(
			""view.caretBlink""));
		try
		{
			textArea.setElectricScroll(Integer.parseInt(jEdit
				.getProperty(""view.electricBorders"")));
		}
		catch(NumberFormatException nf)
		{
			textArea.setElectricScroll(0);
		}
		// Set up the right-click popup menu
		textArea.setRightClickPopup(GUIUtilities
			.loadPopupMenu(""view.context""));
		textArea.setMiddleMousePasteEnabled(jEdit.getBooleanProperty(
			""view.middleMousePaste""));
	}
	private void loadBufferSwitcher()
	{
		if(jEdit.getBooleanProperty(""view.showBufferSwitcher""))
		{
			if(bufferSwitcher == null)
			{
				bufferSwitcher = new BufferSwitcher(this);
				add(BorderLayout.NORTH,bufferSwitcher);
				bufferSwitcher.updateBufferList();
				revalidate();
			}
		}
		else if(bufferSwitcher != null)
		{
			remove(bufferSwitcher);
			revalidate();
			bufferSwitcher = null;
		}
	}
	private void handleBufferUpdate(BufferUpdate msg)
	{
		Buffer _buffer = msg.getBuffer();
		if(msg.getWhat() == BufferUpdate.CREATED)
		{
			if(bufferSwitcher != null)
				bufferSwitcher.updateBufferList();
			/* When closing the last buffer, the BufferUpdate.CLOSED
			 * handler doesn't call setBuffer(), because null buffers
			 * are not supported. Instead, it waits for the subsequent
			 * 'Untitled' file creation. */
			if(buffer.isClosed())
				setBuffer(jEdit.getFirstBuffer());
		}
		else if(msg.getWhat() == BufferUpdate.CLOSED)
		{
			if(bufferSwitcher != null)
				bufferSwitcher.updateBufferList();
			if(_buffer == buffer)
			{
				Buffer newBuffer = (recentBuffer != null ?
					recentBuffer : _buffer.getPrev());
				if(newBuffer != null && !newBuffer.isClosed())
					setBuffer(newBuffer);
				else if(jEdit.getBufferCount() != 0)
					setBuffer(jEdit.getFirstBuffer());
				recentBuffer = null;
			}
			else if(_buffer == recentBuffer)
				recentBuffer = null;
		}
		else if(msg.getWhat() == BufferUpdate.LOAD_STARTED)
		{
			if(_buffer == buffer)
			{
				textArea.setCaretPosition(0);
				textArea.getPainter().repaint();
			}
		}
		else if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED)
		{
			if(_buffer == buffer)
			{
				if(bufferSwitcher != null)
				{
					if(buffer.isDirty())
						bufferSwitcher.repaint();
					else
						bufferSwitcher.updateBufferList();
				}
			}
		}
		else if(msg.getWhat() == BufferUpdate.LOADED)
		{
			if(_buffer == buffer)
			{
				textArea.repaint();
				textArea.updateScrollBars();
				if(bufferSwitcher != null)
					bufferSwitcher.updateBufferList();
				if(view.getEditPane() == this)
				{
					StatusBar status = view.getStatus();
					status.repaintCaretStatus();
					status.updateBufferStatus();
					status.updateMiscStatus();
				}
				loadCaretInfo();
			}
		}
		else if(msg.getWhat() == BufferUpdate.MARKERS_CHANGED)
		{
			if(_buffer == buffer)
				textArea.getGutter().repaint();
		}
		else if(msg.getWhat() == BufferUpdate.MODE_CHANGED)
		{
			if(_buffer == buffer)
			{
				textArea.getPainter().repaint();
				if(view.getEditPane() == this)
					view.getStatus().updateBufferStatus();
			}
		}
		else if(msg.getWhat() == BufferUpdate.ENCODING_CHANGED)
		{
			if(_buffer == buffer)
			{
				if(view.getEditPane() == this)
					view.getStatus().updateBufferStatus();
			}
		}
	}
}
"
org.gjt.sp.jedit.EditPlugin,"/*
 * EditPlugin.java - Interface all plugins must implement
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.util.Vector;
import org.gjt.sp.jedit.gui.OptionsDialog;
/**
 * The interface between jEdit and a plugin.<p>
 *
 * This class obsoletes the <code>Plugin</code> interface from jEdit 2.0
 * and earlier. Its main advantage over the old system is the more flexible
 * menu bar setup code, and the fact that it is a class, rather than an
 * interface, which means methods can be added without breaking existing
 * plugins.
 *
 * @author Slava Pestov
 * @version $Id: EditPlugin.java,v 1.11 2001/08/27 07:03:58 sp Exp $
 * @since jEdit 2.1pre1
 */
public abstract class EditPlugin
{
	/**
	 * Returns the plugin's class name.
	 *
	 * @since jEdit 2.5pre3
	 */
	public String getClassName()
	{
		return getClass().getName();
	}
	/**
	 * Method called by jEdit to initialize the plugin.
	 * Actions and edit modes should be registered here, along
	 * with any EditBus paraphinalia.
	 * @since jEdit 2.1pre1
	 */
	public void start() {}
	/**
	 * Method called by jEdit before exiting. Usually, nothing
	 * needs to be done here.
	 * @since jEdit 2.1pre1
	 */
	public void stop() {}
	/**
	 * Method called every time a view is created to set up the
	 * Plugins menu. Menus and menu items should be loaded using the
	 * methods in the GUIUtilities class, and added to the vector.
	 * @param menuItems Add menus and menu items here
	 *
	 * @see GUIUtilities#loadMenu(String)
	 * @see GUIUtilities#loadMenuItem(String)
	 *
	 * @since jEdit 2.6pre5
	 */
	public void createMenuItems(Vector menuItems) {}
	/**
	 * @deprecated Override createMenuItems(Vector) instead
	 *
	 * @since jEdit 2.1pre1
	 */
	public void createMenuItems(View view, Vector menus, Vector menuItems) {}
	/**
	 * Method called every time the plugin options dialog box is
	 * displayed. Any option panes created by the plugin should be
	 * added here.
	 * @param optionsDialog The plugin options dialog box
	 *
	 * @see OptionPane
	 * @see OptionsDialog#addOptionPane(OptionPane)
	 *
	 * @since jEdit 2.1pre1
	 */
	public void createOptionPanes(OptionsDialog optionsDialog) {}
	/**
	 * Returns the JAR file containing this plugin.
	 * @since jEdit 3.1pre5
	 */
	public EditPlugin.JAR getJAR()
	{
		return jar;
	}
	/**
	 * A placeholder for a plugin that didn't load.
	 */
	public static class Broken extends EditPlugin
	{
		public String getClassName()
		{
			return clazz;
		}
		// package-private members
		Broken(String clazz)
		{
			this.clazz = clazz;
		}
		// private members
		private String clazz;
	}
	/**
	 * A JAR file.
	 */
	public static class JAR
	{
		public String getPath()
		{
			return path;
		}
		public JARClassLoader getClassLoader()
		{
			return classLoader;
		}
		public void addPlugin(EditPlugin plugin)
		{
			plugin.jar = JAR.this;
			plugins.addElement(plugin);
			plugin.start();
		}
		public EditPlugin[] getPlugins()
		{
			EditPlugin[] array = new EditPlugin[plugins.size()];
			plugins.copyInto(array);
			return array;
		}
		public JAR(String path, JARClassLoader classLoader)
		{
			this.path = path;
			this.classLoader = classLoader;
			plugins = new Vector();
		}
		// package-private members
		void getPlugins(Vector vector)
		{
			for(int i = 0; i < plugins.size(); i++)
			{
				vector.addElement(plugins.elementAt(i));
			}
		}
		// private members
		private String path;
		private JARClassLoader classLoader;
		private Vector plugins;
	}
	// private members
	private EditPlugin.JAR jar;
}
"
org.gjt.sp.jedit.EditServer,"/*
 * EditServer.java - jEdit server
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.SwingUtilities;
import java.io.*;
import java.net.*;
import java.util.Random;
import org.gjt.sp.util.Log;
/**
 * The edit server protocol is very simple. <code>$HOME/.jedit/server</code>
 * is an ASCII file containing two lines, the first being the port number,
 * the second being the authorization key.<p>
 *
 * You connect to that port on the local machine, sending the authorization
 * key as ASCII, followed by a newline, followed by a BeanShell script.
 * Then close the socket and the BeanShell script will be executed by the
 * server instance of jEdit.<p>
 *
 * The snippet is executed in the AWT thread. None of the usual BeanShell
 * variables (view, buffer, textArea, editPane) are set so the script has to
 * figure things out by itself.<p>
 *
 * In most cases, the script will call the static
 * <code>EditServer.handleClient()</code> method, but of course more
 * complicated stuff can be done too.
 *
 * @author Slava Pestov
 * @version $Id: EditServer.java,v 1.31 2001/08/01 07:37:11 sp Exp $
 */
public class EditServer extends Thread
{
	EditServer(String portFile)
	{
		super(""jEdit server daemon ["" + portFile + ""]"");
		setDaemon(true);
		this.portFile = portFile;
		try
		{
			// Bind to any port on localhost; accept 2 simultaneous
			// connection attempts before rejecting connections
			socket = new ServerSocket(0, 2,
				InetAddress.getByName(""127.0.0.1""));
			authKey = Math.abs(new Random().nextInt());
			int port = socket.getLocalPort();
			FileWriter out = new FileWriter(portFile);
			out.write(String.valueOf(port));
			out.write(""\n"");
			out.write(String.valueOf(authKey));
			out.write(""\n"");
			out.close();
			Log.log(Log.DEBUG,this,""jEdit server started on port ""
				+ socket.getLocalPort());
			Log.log(Log.DEBUG,this,""Authorization key is ""
				+ authKey);
			ok = true;
		}
		catch(IOException io)
		{
			/* on some Windows versions, connections to localhost
			 * fail if the network is not running. To avoid
			 * confusing newbies with weird error messages, log
			 * errors that occur while starting the server
			 * as NOTICE, not ERROR */
			Log.log(Log.NOTICE,this,io);
		}
	}
	public boolean isOK()
	{
		return ok;
	}
	public void run()
	{
		try
		{
			for(;;)
			{
				Socket client = socket.accept();
				Log.log(Log.MESSAGE,this,client + "": connected"");
				BufferedReader in = new BufferedReader(
					new InputStreamReader(
					client.getInputStream(),
					""UTF8""));
				try
				{
					int key = Integer.parseInt(in.readLine());
					if(key != authKey)
					{
						Log.log(Log.ERROR,this,
							client + "": wrong""
							+ "" authorization key"");
						in.close();
						client.close();
						return;
					}
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,this,
							client + "": invalid""
							+ "" authorization key"");
					in.close();
					client.close();
					return;
				}
				Log.log(Log.DEBUG,this,client + "": authenticated""
					+ "" successfully"");
				handleClient(client,in);
				client.close();
			}
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
		}
	}
	/**
	 * @param restore Ignored unless no views are open
	 * @param parent The client's parent directory
	 * @param args A list of files. Null entries are ignored, for convinience
	 * @since jEdit 3.2pre7
	 */
	public static void handleClient(boolean restore, String parent,
		String[] args)
	{
		String splitConfig = null;
		boolean newView = jEdit.getBooleanProperty(""client.newView"");
		// we have to deal with a huge range of possible border cases here.
		if(jEdit.getFirstView() == null || newView)
		{
			// coming out of background mode.
			// no views open.
			// no buffers open if args empty.
			Buffer buffer = jEdit.openFiles(null,parent,args);
			if(restore)
			{
				if(jEdit.getFirstBuffer() == null)
					splitConfig = jEdit.restoreOpenFiles();
				else if(jEdit.getBooleanProperty(""restore.cli""))
				{
					// no initial split config
					jEdit.restoreOpenFiles();
				}
			}
			// if session file is empty or -norestore specified,
			// we need an initial buffer
			if(jEdit.getFirstBuffer() == null)
				buffer = jEdit.newFile(null);
			if(splitConfig != null)
				jEdit.newView(null,splitConfig);
			else
				jEdit.newView(null,buffer);
		}
		else
		{
			// no background mode, and reusing existing view
			View view = jEdit.getFirstView();
			jEdit.openFiles(view,parent,args);
			view.requestFocus();
			view.toFront();
			// do not create a new view
			return;
		}
	}
	// package-private members
	void stopServer()
	{
		stop();
		new File(portFile).delete();
	}
	// private members
	private String portFile;
	private ServerSocket socket;
	private int authKey;
	private boolean ok;
	private void handleClient(Socket client, Reader in)
		throws IOException
	{
		final StringBuffer script = new StringBuffer();
		char[] buf = new char[1024];
		int count;
		while((count = in.read(buf,0,buf.length)) != -1)
		{
			script.append(buf,0,count);
		}
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				String scriptString = script.toString();
				Log.log(Log.DEBUG,this,scriptString);
				BeanShell.eval(null,scriptString,false);
			}
		});
	}
}
"
org.gjt.sp.jedit.GUIUtilities,"/*
 * GUIUtilities.java - Various GUI utility functions
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import gnu.regexp.REException;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.net.*;
import java.util.Hashtable;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.syntax.Token;
import org.gjt.sp.util.Log;
/**
 * Class with several useful GUI functions.<p>
 *
 * It provides methods for:
 * <ul>
 * <li>Loading menu bars, menus and menu items from the properties
 * <li>Loading popup menus from the properties
 * <li>Loading tool bars and tool bar buttons from the properties
 * <li>Displaying various common dialog boxes
 * <li>Converting string representations of colors to color objects
 * <li>Loading and saving window geometry from the properties
 * <li>Displaying file open and save dialog boxes
 * <li>Loading images and caching them
 * </ul>
 *
 * @author Slava Pestov
 * @version $Id: GUIUtilities.java,v 1.91 2001/08/04 02:18:20 sp Exp $
 */
public class GUIUtilities
{
	// some icons
	public static final Icon NEW_BUFFER_ICON;
	public static final Icon DIRTY_BUFFER_ICON;
	public static final Icon READ_ONLY_BUFFER_ICON;
	public static final Icon NORMAL_BUFFER_ICON;
	public static final Icon EDITOR_WINDOW_ICON;
	public static final Icon PLUGIN_WINDOW_ICON;
	/**
	 * Creates a menubar. Plugins should not need to call this method.
	 * @param name The menu bar name
	 * @since jEdit 3.2pre5
	 */
	public static JMenuBar loadMenuBar(String name)
	{
		String menus = jEdit.getProperty(name);
		StringTokenizer st = new StringTokenizer(menus);
		JMenuBar mbar = new JMenuBar();
		while(st.hasMoreTokens())
			mbar.add(GUIUtilities.loadMenu(st.nextToken()));
		return mbar;
	}
	/**
	 * Creates a menu. This form of loadMenu() does not need to be used
	 * by plugins; use the other form instead.
	 * @param view The view to load the menu for
	 * @param name The menu name
	 * @since jEdit 2.6pre2
	 */
	public static JMenu loadMenu(String name)
	{
		if(name.equals(""open-encoding""))
			return new OpenWithEncodingMenu();
		else if(name.equals(""recent-files""))
			return new RecentFilesMenu();
		else if(name.equals(""current-directory""))
			return new CurrentDirectoryMenu();
		else if(name.equals(""markers""))
			return new MarkersMenu();
		else if(name.equals(""macros""))
			return new MacrosMenu();
		else if(name.equals(""plugins""))
			return new PluginsMenu();
		else
			return new EnhancedMenu(name);
	}
	/**
	 * Creates a popup menu.
	 * @param name The menu name
	 * @since jEdit 2.6pre2
	 */
	public static JPopupMenu loadPopupMenu(String name)
	{
		JPopupMenu menu = new JPopupMenu();
		String menuItems = jEdit.getProperty(name);
		if(menuItems != null)
		{
			StringTokenizer st = new StringTokenizer(menuItems);
			while(st.hasMoreTokens())
			{
				String menuItemName = st.nextToken();
				if(menuItemName.equals(""-""))
					menu.addSeparator();
				else
				{
					if(menuItemName.startsWith(""%""))
						menu.add(loadMenu(menuItemName.substring(1)));
					else
						menu.add(loadMenuItem(menuItemName,false));
				}
			}
		}
		return menu;
	}
	/**
	 * Creates a menu item.
	 * @param name The menu item name
	 * @since jEdit 2.6pre1
	 */
	public static JMenuItem loadMenuItem(String name)
	{
		return loadMenuItem(name,true);
	}
	/**
	 * Creates a menu item.
	 * @param name The menu item name
	 * @param setMnemonic True if the menu item should have a mnemonic
	 * @since jEdit 3.1pre1
	 */
	public static JMenuItem loadMenuItem(String name, boolean setMnemonic)
	{
		String label;
		EditAction action;
		// HACK
		if(name.startsWith(""play-macro@""))
		{
			Macros.Macro macro = Macros.getMacro(name.substring(11));
			if(macro != null)
			{
				label = macro.name;
				int index = label.lastIndexOf('/');
				label = label.substring(index + 1)
					.replace('_',' ');
				action = macro.action;
			}
			else
			{
				label = name.substring(11);
				action = null;
			}
		}
		else
		{
			action = jEdit.getAction(name);
			label = jEdit.getProperty(name.concat("".label""));
			if(label == null)
				label = name;
		}
		char mnemonic;
		int index = label.indexOf('$');
		if(index != -1 && label.length() - index > 1)
		{
			mnemonic = Character.toLowerCase(label.charAt(index + 1));
			label = label.substring(0,index).concat(label.substring(++index));
		}
		else
			mnemonic = '\0';
		JMenuItem mi;
		if(action != null && action.isToggle())
			mi = new EnhancedCheckBoxMenuItem(label,action);
		else
			mi = new EnhancedMenuItem(label,action);
		if(setMnemonic && mnemonic != '\0')
			mi.setMnemonic(mnemonic);
		return mi;
	}
	/**
	 * Creates a toolbar.
	 * @param name The toolbar name
	 */
	public static JToolBar loadToolBar(String name)
	{
		JToolBar toolBar = new JToolBar();
		toolBar.setFloatable(false);
		toolBar.putClientProperty(""JToolBar.isRollover"",Boolean.TRUE);
		String buttons = jEdit.getProperty(name);
		if(buttons != null)
		{
			StringTokenizer st = new StringTokenizer(buttons);
			while(st.hasMoreTokens())
			{
				String button = st.nextToken();
				if(button.equals(""-""))
					toolBar.addSeparator();
				else
				{
					JButton b = loadToolButton(button);
					if(b != null)
						toolBar.add(b);
				}
			}
		}
		return toolBar;
	}
	/**
	 * Loads a tool bar button. The tooltip is constructed from
	 * the <code><i>name</i>.label</code> and
	 * <code><i>name</i>.shortcut</code> properties and the icon is loaded
	 * from the resource named '/org/gjt/sp/jedit/icons/' suffixed
	 * with the value of the <code><i>name</i>.icon</code> property.
	 * @param name The name of the button
	 */
	public static EnhancedButton loadToolButton(String name)
	{
		String label;
		EditAction action;
		// HACK
		if(name.startsWith(""play-macro@""))
		{
			Macros.Macro macro = Macros.getMacro(name.substring(11));
			if(macro != null)
			{
				label = macro.name;
				int index = label.lastIndexOf('/');
				label = label.substring(index + 1)
					.replace('_',' ');
				action = macro.action;
			}
			else
			{
				label = name.substring(11);
				action = null;
			}
		}
		else
		{
			action = jEdit.getAction(name);
			label = jEdit.getProperty(name.concat("".label""));
			if(label == null)
				label = name;
			else
				label = prettifyMenuLabel(label);
		}
		Icon icon;
		String iconName = jEdit.getProperty(name + "".icon"");
		if(iconName != null)
		{
			icon = loadIcon(iconName);
			if(icon == null)
				return null;
		}
		else
			return null;
		String toolTip = label;
		String shortcut = jEdit.getProperty(name + "".shortcut"");
		if(shortcut != null)
			toolTip = toolTip + "" ("" + shortcut + "")"";
		return new EnhancedButton(icon,toolTip,action);
	}
	/**
	 * Loads a tool bar icon.
	 * @param iconName The icon name
	 * @since jEdit 2.6pre7
	 */
	public static Icon loadIcon(String iconName)
	{
		// check if there is a cached version first
		Icon icon = (Icon)icons.get(iconName);
		if(icon != null)
			return icon;
		// get the icon
		if(iconName.startsWith(""file:""))
		{
			icon = new ImageIcon(iconName.substring(5));
		}
		else
		{
			URL url = GUIUtilities.class.getResource(
				""/org/gjt/sp/jedit/icons/"" + iconName);
			if(url == null)
			{
				Log.log(Log.ERROR,GUIUtilities.class,
					""Icon not found: "" + iconName);
				return null;
			}
			icon = new ImageIcon(url);
		}
		icons.put(iconName,icon);
		return icon;
	}
	/**
	 * `Prettifies' a menu item label by removing the `$' sign. This
	 * can be used to process the contents of an <i>action</i>.label
	 * property.
	 */
	public static String prettifyMenuLabel(String label)
	{
		int index = label.indexOf('$');
		if(index != -1)
		{
			label = label.substring(0,index)
				.concat(label.substring(index + 1));
		}
		return label;
	}
	/**
	 * Displays a dialog box.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property. The message
	 * is formatted by the property manager with <code>args</code> as
	 * positional parameters.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param args Positional parameters to be substituted into the
	 * message text
	 */
	public static void message(Component comp, String name, Object[] args)
	{
		hideSplashScreen();
		JOptionPane.showMessageDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title""),args),
			JOptionPane.INFORMATION_MESSAGE);
	}
	/**
	 * Displays an error dialog box.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property. The message
	 * is formatted by the property manager with <code>args</code> as
	 * positional parameters.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param args Positional parameters to be substituted into the
	 * message text
	 */
	public static void error(Component comp, String name, Object[] args)
	{
		hideSplashScreen();
		JOptionPane.showMessageDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title""),args),
			JOptionPane.ERROR_MESSAGE);
	}
	/**
	 * Displays an input dialog box and returns any text the user entered.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param def The text to display by default in the input field
	 */
	public static String input(Component comp, String name, Object def)
	{
		return input(comp,name,null,def);
	}
	/**
	 * Displays an input dialog box and returns any text the user entered.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param def The property whose text to display in the input field
	 */
	public static String inputProperty(Component comp, String name,
		String def)
	{
		return inputProperty(comp,name,null,def);
	}
	/**
	 * Displays an input dialog box and returns any text the user entered.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param def The text to display by default in the input field
	 * @param args Positional parameters to be substituted into the
	 * message text
	 * @since jEdit 3.1pre3
	 */
	public static String input(Component comp, String name,
		Object[] args, Object def)
	{
		hideSplashScreen();
		String retVal = (String)JOptionPane.showInputDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title"")),
			JOptionPane.QUESTION_MESSAGE,null,null,def);
		return retVal;
	}
	/**
	 * Displays an input dialog box and returns any text the user entered.
	 * The title of the dialog is fetched from
	 * the <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param args Positional parameters to be substituted into the
	 * message text
	 * @param def The property whose text to display in the input field
	 * @since jEdit 3.1pre3
	 */
	public static String inputProperty(Component comp, String name,
		Object[] args, String def)
	{
		hideSplashScreen();
		String retVal = (String)JOptionPane.showInputDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title"")),
			JOptionPane.QUESTION_MESSAGE,
			null,null,jEdit.getProperty(def));
		if(retVal != null)
			jEdit.setProperty(def,retVal);
		return retVal;
	}
	/**
	 * Displays a confirm dialog box and returns the button pushed by the
	 * user. The title of the dialog is fetched from the
	 * <code><i>name</i>.title</code> property. The message is fetched
	 * from the <code><i>name</i>.message</code> property.
	 * @param comp The component to display the dialog for
	 * @param name The name of the dialog
	 * @param args Positional parameters to be substituted into the
	 * message text
	 * @param buttons The buttons to display - for example,
	 * JOptionPane.YES_NO_CANCEL_OPTION
	 * @param type The dialog type - for example,
	 * JOptionPane.WARNING_MESSAGE
	 * @since jEdit 3.1pre3
	 */
	public static int confirm(Component comp, String name,
		Object[] args, int buttons, int type)
	{
		hideSplashScreen();
		return JOptionPane.showConfirmDialog(comp,
			jEdit.getProperty(name + "".message"",args),
			jEdit.getProperty(name + "".title""),buttons,type);
	}
	/**
	 * Displays a VFS file selection dialog box.
	 * @param view The view
	 * @param path The initial directory to display. May be null
	 * @param type The dialog type
	 * @param multipleSelection True if multiple selection should be allowed
	 * @return The selected file(s)
	 * @since jEdit 2.6pre2
	 */
	public static String[] showVFSFileDialog(View view, String path,
		int type, boolean multipleSelection)
	{
		VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(
			view,path,type,multipleSelection);
		String[] selectedFiles = fileChooser.getSelectedFiles();
		if(selectedFiles == null)
			return null;
		return selectedFiles;
	}
	/**
	 * Converts a color name to a color object. The name must either be
	 * a known string, such as `red', `green', etc (complete list is in
	 * the <code>java.awt.Color</code> class) or a hex color value
	 * prefixed with `#', for example `#ff0088'.
	 * @param name The color name
	 */
	public static Color parseColor(String name)
	{
		return parseColor(name, Color.black);
	}
	public static Color parseColor(String name, Color defaultColor)
	{
		if(name == null)
			return defaultColor;
		else if(name.startsWith(""#""))
		{
			try
			{
				return Color.decode(name);
			}
			catch(NumberFormatException nf)
			{
				return defaultColor;
			}
		}
		else if(""red"".equals(name))
			return Color.red;
		else if(""green"".equals(name))
			return Color.green;
		else if(""blue"".equals(name))
			return Color.blue;
		else if(""yellow"".equals(name))
			return Color.yellow;
		else if(""orange"".equals(name))
			return Color.orange;
		else if(""white"".equals(name))
			return Color.white;
		else if(""lightGray"".equals(name))
			return Color.lightGray;
		else if(""gray"".equals(name))
			return Color.gray;
		else if(""darkGray"".equals(name))
			return Color.darkGray;
		else if(""black"".equals(name))
			return Color.black;
		else if(""cyan"".equals(name))
			return Color.cyan;
		else if(""magenta"".equals(name))
			return Color.magenta;
		else if(""pink"".equals(name))
			return Color.pink;
		else
			return defaultColor;
	}
	/**
	 * Converts a color object to its hex value. The hex value
	 * prefixed is with `#', for example `#ff0088'.
	 * @param c The color object
	 */
	public static String getColorHexString(Color c)
	{
		String colString = Integer.toHexString(c.getRGB() & 0xffffff);
		return ""#000000"".substring(0,7 - colString.length()).concat(colString);
	}
	/**
	 * Converts a style string to a style object.
	 * @param str The style string
	 * @param family Style strings only specify font style, not font family
	 * @param size Style strings only specify font style, not font family
	 * @exception IllegalArgumentException if the style is invalid
	 * @since jEdit 3.2pre6
	 */
	public static SyntaxStyle parseStyle(String str, String family, int size)
		throws IllegalArgumentException
	{
		Color fgColor = Color.black;
		Color bgColor = null;
		boolean italic = false;
		boolean bold = false;
		StringTokenizer st = new StringTokenizer(str);
		while(st.hasMoreTokens())
		{
			String s = st.nextToken();
			if(s.startsWith(""color:""))
			{
				fgColor = GUIUtilities.parseColor(s.substring(6), Color.black);
			}
			else if(s.startsWith(""bgColor:""))
			{
				bgColor = GUIUtilities.parseColor(s.substring(8), null);
			}
			else if(s.startsWith(""style:""))
			{
				for(int i = 6; i < s.length(); i++)
				{
					if(s.charAt(i) == 'i')
						italic = true;
					else if(s.charAt(i) == 'b')
						bold = true;
					else
						throw new IllegalArgumentException(
							""Invalid style: "" + s);
				}
			}
			else
				throw new IllegalArgumentException(
					""Invalid directive: "" + s);
		}
		return new SyntaxStyle(fgColor,bgColor,
			new Font(family,
			(italic ? Font.ITALIC : 0) | (bold ? Font.BOLD : 0),
			size));
	}
	/**
	 * Converts a style into it's string representation.
	 * @param style The style
	 */
	public static String getStyleString(SyntaxStyle style)
	{
		StringBuffer buf = new StringBuffer();
		buf.append(""color:"" + getColorHexString(style.getForegroundColor()));
		if(style.getBackgroundColor() != null) 
		{
			buf.append("" bgColor:"" + getColorHexString(style.getBackgroundColor()));
		}
		if(!style.getFont().isPlain())
		{
			buf.append("" style:"" + (style.getFont().isItalic() ? ""i"" : """")
				+ (style.getFont().isBold() ? ""b"" : """"));
		}
		return buf.toString();
	}
	/**
	 * Loads the syntax styles from the properties, giving them the specified
	 * base font family and size.
	 * @param family The font family
	 * @param size The font size
	 * @since jEdit 3.2pre6
	 */
	public static SyntaxStyle[] loadStyles(String family, int size)
	{
		SyntaxStyle[] styles = new SyntaxStyle[Token.ID_COUNT];
		try
		{
			styles[Token.COMMENT1] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.comment1""),
				family,size);
			styles[Token.COMMENT2] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.comment2""),
				family, size);
			styles[Token.LITERAL1] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.literal1""),
				family,size);
			styles[Token.LITERAL2] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.literal2""),
				family,size);
			styles[Token.LABEL] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.label""),
				family,size);
			styles[Token.KEYWORD1] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.keyword1""),
				family,size);
			styles[Token.KEYWORD2] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.keyword2""),
				family,size);
			styles[Token.KEYWORD3] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.keyword3""),
				family,size);
			styles[Token.FUNCTION] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.function""),
				family,size);
			styles[Token.MARKUP] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.markup""),
				family,size);
			styles[Token.OPERATOR] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.operator""),
				family,size);
			styles[Token.DIGIT] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.digit""),
				family,size);
			styles[Token.INVALID] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.invalid""),
				family,size);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,GUIUtilities.class,e);
		}
		return styles;
	}
	/**
	 * Loads a windows's geometry from the properties.
	 * The geometry is loaded from the <code><i>name</i>.x</code>,
	 * <code><i>name</i>.y</code>, <code><i>name</i>.width</code> and
	 * <code><i>name</i>.height</code> properties.
	 *
	 * @param win The window
	 * @param name The window name
	 */
	public static void loadGeometry(Window win, String name)
	{
		// all this adjust_* crap is there to work around buggy
		// Unix Java versions which don't put windows where you
		// tell them to
		int x, y, width, height, adjust_x, adjust_y, adjust_width,
			adjust_height;
		try
		{
			width = Integer.parseInt(jEdit.getProperty(name + "".width""));
			height = Integer.parseInt(jEdit.getProperty(name + "".height""));
		}
		catch(NumberFormatException nf)
		{
			Dimension size = win.getSize();
			width = size.width;
			height = size.height;
		}
		try
		{
			x = Integer.parseInt(jEdit.getProperty(name + "".x""));
			y = Integer.parseInt(jEdit.getProperty(name + "".y""));
		}
		catch(NumberFormatException nf)
		{
			Component parent = win.getParent();
			if(parent == null)
			{
				Dimension screen = win.getToolkit().getScreenSize();
				x = (screen.width - width) / 2;
				y = (screen.height - height) / 2;
			}
			else
			{
				Rectangle bounds = parent.getBounds();
				x = bounds.x + (bounds.width - width) / 2;
				y = bounds.y + (bounds.height - height) / 2;
			}
		}
		try
		{
			adjust_x = Integer.parseInt(jEdit.getProperty(name + "".dx""));
			adjust_y = Integer.parseInt(jEdit.getProperty(name + "".dy""));
			adjust_width = Integer.parseInt(jEdit.getProperty(name + "".d-width""));
			adjust_height = Integer.parseInt(jEdit.getProperty(name + "".d-height""));
		}
		catch(NumberFormatException nf)
		{
			adjust_x = adjust_y = 0;
			adjust_width = adjust_height = 0;
		}
		Rectangle desired = new Rectangle(x,y,width,height);
		Rectangle required = new Rectangle(x - adjust_x,
			y - adjust_y,width - adjust_width,
			height - adjust_height);
// 		Log.log(Log.DEBUG,GUIUtilities.class,""Window "" + name
// 			+ "": desired geometry is "" + desired);
// 		Log.log(Log.DEBUG,GUIUtilities.class,""Window "" + name
// 			+ "": setting geometry to "" + required);
		win.setBounds(required);
		if(File.separatorChar == '/'
			&& System.getProperty(""java.version"").compareTo(""1.2"") < 0)
		{
			win.setBounds(required);
			new UnixWorkaround(win,name,desired,required);
		}
		else
			win.setBounds(desired);
	}
	static class UnixWorkaround
	{
		Window win;
		String name;
		Rectangle desired;
		Rectangle required;
		long start;
		boolean windowOpened;
		UnixWorkaround(Window win, String name, Rectangle desired,
			Rectangle required)
		{
			this.win = win;
			this.name = name;
			this.desired = desired;
			this.required = required;
			start = System.currentTimeMillis();
			win.addComponentListener(new ComponentHandler());
			win.addWindowListener(new WindowHandler());
		}
		class ComponentHandler extends ComponentAdapter
		{
			public void componentMoved(ComponentEvent evt)
			{
				if(System.currentTimeMillis() - start < 1000)
				{
					Rectangle r = win.getBounds();
					if(!windowOpened && r.equals(required))
						return;
					if(!r.equals(desired))
					{
//						Log.log(Log.DEBUG,GUIUtilities.class,
//							""Window resize blocked: "" + win.getBounds());
						win.setBounds(desired);
					}
				}
				else
					win.removeComponentListener(this);
			}
			public void componentResized(ComponentEvent evt)
			{
				if(System.currentTimeMillis() - start < 1000)
				{
					Rectangle r = win.getBounds();
					if(!windowOpened && r.equals(required))
						return;
					if(!r.equals(desired))
					{
// 						Log.log(Log.DEBUG,GUIUtilities.class,
// 							""Window resize blocked: "" + win.getBounds());
						win.setBounds(desired);
					}
				}
				else
					win.removeComponentListener(this);
			}
		}
		class WindowHandler extends WindowAdapter
		{
			public void windowOpened(WindowEvent evt)
			{
				windowOpened = true;
				Rectangle r = win.getBounds();
// 				Log.log(Log.DEBUG,GUIUtilities.class,""Window ""
// 					+ name + "": bounds after opening: "" + r);
				if(r.x != desired.x || r.y != desired.y
					|| r.width != desired.width
					|| r.height != desired.height)
				{
					jEdit.setProperty(name + "".dx"",String.valueOf(
						r.x - required.x));
					jEdit.setProperty(name + "".dy"",String.valueOf(
						r.y - required.y));
					jEdit.setProperty(name + "".d-width"",String.valueOf(
						r.width - required.width));
					jEdit.setProperty(name + "".d-height"",String.valueOf(
						r.height - required.height));
				}
				win.removeWindowListener(this);
			}
		}
	}
	/**
	 * Saves a window's geometry to the properties.
	 * The geometry is saved to the <code><i>name</i>.x</code>,
	 * <code><i>name</i>.y</code>, <code><i>name</i>.width</code> and
	 * <code><i>name</i>.height</code> properties.
	 * @param win The window
	 * @param name The window name
	 */
	public static void saveGeometry(Window win, String name)
	{
		Rectangle bounds = win.getBounds();
		jEdit.setProperty(name + "".x"",String.valueOf(bounds.x));
		jEdit.setProperty(name + "".y"",String.valueOf(bounds.y));
		jEdit.setProperty(name + "".width"",String.valueOf(bounds.width));
		jEdit.setProperty(name + "".height"",String.valueOf(bounds.height));
	}
	/**
	 * Ensures that the splash screen is not visible. This should be
	 * called before displaying any dialog boxes or windows at
	 * startup.
	 */
	public static void hideSplashScreen()
	{
		if(splash != null)
		{
			splash.dispose();
			splash = null;
		}
	}
	/**
	 * Returns the default editor window image.
	 */
	public static Image getEditorIcon()
	{
		return ((ImageIcon)EDITOR_WINDOW_ICON).getImage();
	}
	/**
	 * Returns the default plugin window image.
	 */
	public static Image getPluginIcon()
	{
		return ((ImageIcon)PLUGIN_WINDOW_ICON).getImage();
	}
	/**
	 * Focuses on the specified component as soon as the window becomes
	 * active.
	 * @param win The window
	 * @param comp The component
	 */
	public static void requestFocus(final Window win, final Component comp)
	{
		win.addWindowListener(new WindowAdapter()
		{
			public void windowActivated(WindowEvent evt)
			{
				comp.requestFocus();
				win.removeWindowListener(this);
			}
		});
	}
	/**
	 * Returns if the specified event is the popup trigger event.
	 * This implements precisely defined behavior, as opposed to
	 * MouseEvent.isPopupTrigger().
	 * @param evt The event
	 * @since jEdit 3.2pre8
	 */
	public static boolean isPopupTrigger(MouseEvent evt)
	{
		if(macOS)
			return evt.isControlDown();
		else
			return ((evt.getModifiers() & InputEvent.BUTTON3_MASK) != 0);
	}
	// deprecated APIs
	/**
	 * @deprecated Use loadMenu(name) instead
	 */
	public static JMenu loadMenu(View view, String name)
	{
		return loadMenu(name);
	}
	/**
	 * @deprecated Use loadMenuItem(name) instead
	 * @param view Unused
	 * @param name The menu item name
	 */
	public static JMenuItem loadMenuItem(View view, String name)
	{
		return loadMenuItem(name,true);
	}
	/**
	 * @deprecated Use loadToolBarIcon() instead
	 */
	public static Icon loadToolBarIcon(String iconName)
	{
		return loadIcon(iconName);
	}
	/**
	 * @deprecated Use showVFSFileDialog()
	 */
	public static String showFileDialog(View view, String file, int type)
	{
		if(file == null)
			file = System.getProperty(""user.dir"");
		File _file = new File(file);
		JFileChooser chooser = new JFileChooser();
		chooser.setCurrentDirectory(_file);
		if(_file.isDirectory())
			chooser.setSelectedFile(null);
		else
			chooser.setSelectedFile(_file);
		chooser.setDialogType(type);
		chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
		int retVal = chooser.showDialog(view,null);
		if(retVal == JFileChooser.APPROVE_OPTION)
		{
			File selectedFile = chooser.getSelectedFile();
			if(selectedFile != null)
				return selectedFile.getAbsolutePath();
		}
		return null;
	}
	// package-private members
	static void showSplashScreen()
	{
		splash = new SplashScreen();
	}
	static void advanceSplashProgress()
	{
		if(splash != null)
			splash.advance();
	}
	// private members
	private static SplashScreen splash;
	private static boolean macOS;
	private static Hashtable icons;
	private GUIUtilities() {}
	static
	{
		macOS = (System.getProperty(""os.name"").indexOf(""MacOS"") != -1);
		icons = new Hashtable();
		NEW_BUFFER_ICON = loadIcon(""new.gif"");
		DIRTY_BUFFER_ICON = loadIcon(""dirty.gif"");
		READ_ONLY_BUFFER_ICON = loadIcon(""readonly.gif"");
		NORMAL_BUFFER_ICON = loadIcon(""normal.gif"");
		EDITOR_WINDOW_ICON = loadIcon(""jedit_icon1.gif"");
		PLUGIN_WINDOW_ICON = loadIcon(""jedit_icon2.gif"");
	}
}
"
org.gjt.sp.jedit.JARClassLoader,"/*
 * JARClassLoader.java - Loads classes from JAR files
 * Copyright (C) 1999, 2000 Slava Pestov
 * Portions copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.io.*;
import java.lang.reflect.Modifier;
import java.net.*;
import java.util.*;
import java.util.zip.*;
import org.gjt.sp.util.Log;
/**
 * A class loader implementation that loads classes from JAR files.
 * @author Slava Pestov
 * @version $Id: JARClassLoader.java,v 1.51 2001/08/27 10:27:45 sp Exp $
 */
public class JARClassLoader extends ClassLoader
{
	// no-args constructor is for loading classes from all plugins
	// eg BeanShell uses one of these so that scripts can use
	// plugin classes
	public JARClassLoader()
	{
	}
	public JARClassLoader(String path)
		throws IOException
	{
		zipFile = new ZipFile(path);
		Enumeration entires = zipFile.entries();
		while(entires.hasMoreElements())
		{
			ZipEntry entry = (ZipEntry)entires.nextElement();
			String name = entry.getName();
			String lname = name.toLowerCase();
			if(lname.equals(""actions.xml""))
			{
				jEdit.loadActions(path + ""!actions.xml"",
					new BufferedReader(new InputStreamReader(
					zipFile.getInputStream(entry))),true);
			}
			else if(lname.endsWith("".props""))
				jEdit.loadProps(zipFile.getInputStream(entry),true);
			else if(name.endsWith(""Plugin.class""))
				pluginClasses.addElement(name);
		}
		jar = new EditPlugin.JAR(path,this);
		jEdit.addPluginJAR(jar);
	}
	/**
	 * @exception ClassNotFoundException if the class could not be found
	 */
	public Class loadClass(String clazz, boolean resolveIt)
		throws ClassNotFoundException
	{
		return loadClass(clazz,resolveIt,true);
	}
	public InputStream getResourceAsStream(String name)
	{
		if(zipFile == null)
			return null;
		try
		{
			ZipEntry entry = zipFile.getEntry(name);
			if(entry == null)
				return getSystemResourceAsStream(name);
			else
				return zipFile.getInputStream(entry);
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			return null;
		}
	}
	public URL getResource(String name)
	{
		if(zipFile == null)
			return null;
		ZipEntry entry = zipFile.getEntry(name);
		if(entry == null)
			return getSystemResource(name);
		try
		{
			return new URL(getResourceAsPath(name));
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			return null;
		}
	}
	public String getResourceAsPath(String name)
	{
		if(zipFile == null)
			return null;
		if(!name.startsWith(""/""))
			name = ""/"" + name;
		return ""jeditresource:/"" + MiscUtilities.getFileName(
			jar.getPath()) + ""!"" + name;
	}
	/**
	 * Closes the ZIP file. This plugin will no longer be usable
	 * after this.
	 * @since jEdit 2.6pre1
	 */
	public void closeZipFile()
	{
		if(zipFile == null)
			return;
		try
		{
			zipFile.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
		}
		zipFile = null;
	}
	/**
	 * Returns the ZIP file associated with this class loader.
	 * @since jEdit 3.0final
	 */
	public ZipFile getZipFile()
	{
		return zipFile;
	}
	// package-private members
	void startAllPlugins()
	{
		for(int i = 0; i < pluginClasses.size(); i++)
		{
			String name = (String)pluginClasses.elementAt(i);
			name = MiscUtilities.fileToClass(name);
			try
			{
				loadPluginClass(name);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Error while starting plugin "" + name);
				Log.log(Log.ERROR,this,t);
				jar.addPlugin(new EditPlugin.Broken(name));
				String[] args = { name, t.toString() };
				GUIUtilities.error(null,""plugin.start-error"",args);
			}
		}
	}
	// private members
	private EditPlugin.JAR jar;
	private Vector pluginClasses = new Vector();
	private ZipFile zipFile;
	private void loadPluginClass(String name)
		throws Exception
	{
		// Check if a plugin with the same name is already loaded
		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			if(plugins[i].getClass().getName().equals(name))
			{
				String[] args = { name };
				GUIUtilities.error(null,""plugin.already-loaded"",args);
				return;
			}
		}
		// Check dependencies
		if(!checkDependencies(name))
		{
			jar.addPlugin(new EditPlugin.Broken(name));
			return;
		}
		// JDK 1.1.8 throws a GPF when we do an isAssignableFrom()
		// on an unresolved class
		Class clazz = loadClass(name,true);
		int modifiers = clazz.getModifiers();
		if(!Modifier.isInterface(modifiers)
			&& !Modifier.isAbstract(modifiers)
			&& EditPlugin.class.isAssignableFrom(clazz))
		{
			String version = jEdit.getProperty(""plugin.""
				+ name + "".version"");
			if(version == null)
			{
				Log.log(Log.WARNING,this,""Plugin "" +
					name + "" doesn't""
					+ "" have a 'version' property."");
				version = """";
			}
			else
				version = "" (version "" + version + "")"";
			Log.log(Log.NOTICE,this,""Starting plugin "" + name
					+ version);
			jar.addPlugin((EditPlugin)clazz.newInstance());
		}
	}
	private boolean checkDependencies(String name)
	{
		int i = 0;
		String dep;
		while((dep = jEdit.getProperty(""plugin."" + name + "".depend."" + i++)) != null)
		{
			int index = dep.indexOf(' ');
			if(index == -1)
			{
				Log.log(Log.ERROR,this,name + "" has an invalid""
					+ "" dependency: "" + dep);
				return false;
			}
			String what = dep.substring(0,index);
			String arg = dep.substring(index + 1);
			if(what.equals(""jdk""))
			{
				if(System.getProperty(""java.version"").compareTo(arg) < 0)
				{
					String[] args = { name, arg,
						System.getProperty(""java.version"") };
					GUIUtilities.error(null,""plugin.dep-jdk"",args);
					return false;
				}
			}
			else if(what.equals(""jedit""))
			{
				if(jEdit.getBuild().compareTo(arg) < 0)
				{
					String needs = MiscUtilities.buildToVersion(arg);
					String[] args = { name, needs,
						jEdit.getVersion() };
					GUIUtilities.error(null,""plugin.dep-jedit"",args);
					return false;
				}
			}
			else if(what.equals(""plugin""))
			{
				int index2 = arg.indexOf(' ');
				if(index2 == -1)
				{
					Log.log(Log.ERROR,this,name 
						+ "" has an invalid dependency: ""
						+ dep + "" (version is missing)"");
					return false;
				}
				String plugin = arg.substring(0,index2);
				String needVersion = arg.substring(index2 + 1);
				String currVersion = jEdit.getProperty(""plugin."" 
					+ plugin + "".version"");
				if(currVersion == null)
				{
					String[] args = { name, needVersion, plugin };
					GUIUtilities.error(null,""plugin.dep-plugin.no-version"",args);
					return false;
				}
				if(MiscUtilities.compareVersions(currVersion,
					needVersion) < 0)
				{
					String[] args = { name, needVersion, plugin, currVersion };
					GUIUtilities.error(null,""plugin.dep-plugin"",args);
					return false;
				}
				if(jEdit.getPlugin(plugin) instanceof EditPlugin.Broken)
				{
					String[] args = { name, plugin };
					GUIUtilities.error(null,""plugin.dep-plugin.broken"",args);
					return false;
				}
			}
			else if(what.equals(""class""))
			{
				try
				{
					loadClass(arg,false);
				}
				catch(Exception e)
				{
					String[] args = { name, arg };
					GUIUtilities.error(null,""plugin.dep-class"",args);
					return false;
				}
			}
			else
			{
				Log.log(Log.ERROR,this,name + "" has unknown""
					+ "" dependency: "" + dep);
				return false;
			}
		}
		return true;
	}
	private Class findOtherClass(String clazz, boolean resolveIt)
		throws ClassNotFoundException
	{
		EditPlugin.JAR[] jars = jEdit.getPluginJARs();
		for(int i = 0; i < jars.length; i++)
		{
			JARClassLoader loader = jars[i].getClassLoader();
			Class cls = loader.loadClass(clazz,resolveIt,
				false);
			if(cls != null)
				return cls;
		}
		/* Defer to whoever loaded us (such as JShell, Echidna, etc) */
                ClassLoader loader = getClass().getClassLoader();
		if (loader != null)
			return loader.loadClass(clazz);
		/* Doesn't exist in any other plugin, look in system classes */
		return findSystemClass(clazz);
	}
	private Class loadClass(String clazz, boolean resolveIt, boolean doDepencies)
		throws ClassNotFoundException
	{
		Class cls = findLoadedClass(clazz);
		if(cls != null)
		{
			if(resolveIt)
				resolveClass(cls);
			return cls;
		}
		if(zipFile == null)
		{
			if(doDepencies)
				return findOtherClass(clazz,resolveIt);
			else
				return null;
		}
		String name = MiscUtilities.classToFile(clazz);
		try
		{
			ZipEntry entry = zipFile.getEntry(name);
			if(entry == null)
			{
				if(doDepencies)
					return findOtherClass(clazz,resolveIt);
				else
					return null;
			}
			InputStream in = zipFile.getInputStream(entry);
			int len = (int)entry.getSize();
			byte[] data = new byte[len];
			int success = 0;
			int offset = 0;
			while(success < len)
			{
				len -= success;
				offset += success;
				success = in.read(data,offset,len);
				if(success == -1)
				{
					Log.log(Log.ERROR,this,""Failed to load class ""
						+ clazz + "" from "" + zipFile.getName());
					throw new ClassNotFoundException(clazz);
				}
			}
			cls = defineClass(clazz,data,0,data.length);
			if(resolveIt)
				resolveClass(cls);
			return cls;
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			throw new ClassNotFoundException(clazz);
		}
	}
}
"
org.gjt.sp.jedit.jEdit,"/*
 * jEdit.java - Main class of the jEdit editor
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import com.microstar.xml.*;
import javax.swing.plaf.metal.*;
import javax.swing.plaf.FontUIResource;
import javax.swing.text.Element;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import java.text.MessageFormat;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.search.SearchAndReplace;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
/**
 * The main class of the jEdit text editor.
 * @author Slava Pestov
 * @version $Id: jEdit.java,v 1.370 2001/08/27 07:03:58 sp Exp $
 */
public class jEdit
{
	/**
	 * Returns the jEdit version as a human-readable string.
	 */
	public static String getVersion()
	{
		return MiscUtilities.buildToVersion(getBuild());
	}
	/**
	 * Returns the internal version. String.compareTo() can be used
	 * to compare different internal versions.
	 */
	public static String getBuild()
	{
		// (major).(minor).(<99 = preX, 99 = final).(bug fix)
		return ""03.02.99.00"";
	}
	/**
	 * The main method of the jEdit application.
	 * <p>
	 * This should never be invoked directly.
	 * @param args The command line arguments
	 */
	public static void main(String[] args)
	{
		// for developers: run 'jedit 0' to get extensive logging
		int level = Log.WARNING;
		if(args.length >= 1)
		{
			String levelStr = args[0];
			if(levelStr.length() == 1 && Character.isDigit(
				levelStr.charAt(0)))
			{
				level = Integer.parseInt(levelStr);
				args[0] = null;
			}
		}
		// Parse command line
		boolean endOpts = false;
		settingsDirectory = MiscUtilities.constructPath(
			System.getProperty(""user.home""),"".jedit"");
		String portFile = ""server"";
		boolean restore = true;
		boolean noStartupScripts = false;
		String userDir = System.getProperty(""user.dir"");
		// script to run
		String scriptFile = null;
		for(int i = 0; i < args.length; i++)
		{
			String arg = args[i];
			if(arg == null)
				continue;
			else if(arg.length() == 0)
				args[i] = null;
			else if(arg.startsWith(""-"") && !endOpts)
			{
				if(arg.equals(""--""))
					endOpts = true;
				else if(arg.equals(""-usage""))
				{
					version();
					System.err.println();
					usage();
					System.exit(1);
				}
				else if(arg.equals(""-version""))
				{
					version();
					System.exit(1);
				}
				else if(arg.equals(""-nosettings""))
					settingsDirectory = null;
				else if(arg.startsWith(""-settings=""))
					settingsDirectory = arg.substring(10);
				else if(arg.startsWith(""-noserver""))
					portFile = null;
				else if(arg.equals(""-server""))
					portFile = ""server"";
				else if(arg.startsWith(""-server=""))
					portFile = arg.substring(8);
				else if(arg.startsWith(""-background""))
					background = true;
				else if(arg.equals(""-norestore""))
					restore = false;
				else if(arg.equals(""-nostartupscripts""))
					noStartupScripts = true;
				else if(arg.startsWith(""-run=""))
					scriptFile = arg.substring(5);
				else
				{
					System.err.println(""Unknown option: ""
						+ arg);
					usage();
					System.exit(1);
				}
				args[i] = null;
			}
		}
		if(settingsDirectory != null && portFile != null)
			portFile = MiscUtilities.constructPath(settingsDirectory,portFile);
		else
			portFile = null;
		Log.init(true,level);
		// Try connecting to another running jEdit instance
		if(portFile != null && new File(portFile).exists())
		{
			int port, key;
			try
			{
				BufferedReader in = new BufferedReader(new FileReader(portFile));
				port = Integer.parseInt(in.readLine());
				key = Integer.parseInt(in.readLine());
				in.close();
				Socket socket = new Socket(InetAddress.getByName(""127.0.0.1""),port);
				Writer out = new OutputStreamWriter(socket.getOutputStream(),""UTF8"");
				out.write(String.valueOf(key));
				out.write('\n');
				String script = makeServerScript(restore,args,scriptFile);
				out.write(script);
				out.close();
				System.exit(0);
			}
			catch(Exception e)
			{
				// ok, this one seems to confuse newbies
				// endlessly, so log it as NOTICE, not
				// ERROR
				Log.log(Log.NOTICE,jEdit.class,""An error occurred""
					+ "" while connecting to the jEdit server instance."");
				Log.log(Log.NOTICE,jEdit.class,""This probably means that""
					+ "" jEdit crashed and/or exited abnormally"");
				Log.log(Log.NOTICE,jEdit.class,""the last time it was run."");
				Log.log(Log.NOTICE,jEdit.class,""If you don't""
					+ "" know what this means, don't worry."");
				Log.log(Log.NOTICE,jEdit.class,e);
			}
		}
		// MacOS X GUI hacks
		if(System.getProperty(""os.name"").indexOf(""MacOS X"") != -1)
		{
			// put the menu bar at the top of the screen, as opposed to
			// inside the jEdit window
			System.getProperties().put(""com.apple.macos.useScreenMenuBar"",""true"");
		}
		// Initialize activity log and settings directory
		boolean showSplash = true;
		Writer stream;
		if(settingsDirectory != null)
		{
			File _settingsDirectory = new File(settingsDirectory);
			if(!_settingsDirectory.exists())
				_settingsDirectory.mkdirs();
			File _macrosDirectory = new File(settingsDirectory,""macros"");
			if(!_macrosDirectory.exists())
				_macrosDirectory.mkdir();
			String logPath = MiscUtilities.constructPath(
				settingsDirectory,""activity.log"");
			try
			{
				stream = new BufferedWriter(new FileWriter(logPath));
			}
			catch(Exception e)
			{
				e.printStackTrace();
				stream = null;
			}
			// don't show splash screen if there is a file named
			// 'nosplash' in the settings directory
			if(new File(settingsDirectory,""nosplash"").exists())
				showSplash = false;
		}
		else
		{
			stream = null;
		}
		// Show the kool splash screen
		if(showSplash)
			GUIUtilities.showSplashScreen();
		Log.setLogWriter(stream);
		Log.log(Log.NOTICE,jEdit.class,""jEdit version "" + getVersion());
		Log.log(Log.MESSAGE,jEdit.class,""Settings directory is ""
			+ settingsDirectory);
		// Initialize server
		if(portFile != null)
		{
			server = new EditServer(portFile);
			if(!server.isOK())
				server = null;
		}
		else
		{
			if(background)
			{
				background = false;
				System.err.println(""You cannot specify both the""
					+ "" -background and -noserver switches"");
			}
		}
		// Get things rolling
		initMisc();
		initSystemProperties();
		BeanShell.init();
		GUIUtilities.advanceSplashProgress();
		if(jEditHome != null)
			initSiteProperties();
		initUserProperties();
		initActions();
		initPlugins();
		if(settingsDirectory != null)
		{
			File history = new File(MiscUtilities.constructPath(
				settingsDirectory,""history""));
			if(history.exists())
				historyModTime = history.lastModified();
			HistoryModel.loadHistory(history);
			File recent = new File(MiscUtilities.constructPath(
				settingsDirectory,""recent.xml""));
			if(recent.exists())
				recentModTime = recent.lastModified();
			BufferHistory.load(recent);
		}
		Abbrevs.load();
		GUIUtilities.advanceSplashProgress();
		// Buffer sort
		sortBuffers = getBooleanProperty(""sortBuffers"");
		sortByName = getBooleanProperty(""sortByName"");
		initPLAF();
		reloadModes();
		GUIUtilities.advanceSplashProgress();
		SearchAndReplace.load();
		FavoritesVFS.loadFavorites();
		Macros.loadMacros();
		GUIUtilities.advanceSplashProgress();
		// Start plugins
		for(int i = 0; i < jars.size(); i++)
		{
			((EditPlugin.JAR)jars.elementAt(i)).getClassLoader()
				.startAllPlugins();
		}
		// Run startup scripts, after plugins, proeprties, etc
		// are loaded
		if(!noStartupScripts && jEditHome != null)
		{
			String path = MiscUtilities.constructPath(jEditHome,""startup"");
			File file = new File(path);
			if(file.exists())
				runStartupScripts(file);
		}
		if(!noStartupScripts && settingsDirectory != null)
		{
			String path = MiscUtilities.constructPath(settingsDirectory,""startup"");
			File file = new File(path);
			if(!file.exists())
				file.mkdirs();
			else
				runStartupScripts(file);
		}
		// Run script specified with -run= parameter
		if(scriptFile != null)
		{
			scriptFile = MiscUtilities.constructPath(userDir,scriptFile);
			BeanShell.runScript(null,scriptFile,false,false);
		}
		// Must be after plugins are started!!!
		propertiesChanged();
		GUIUtilities.advanceSplashProgress();
		Buffer buffer = openFiles(null,userDir,args);
		String splitConfig = null;
		if(restore && settingsDirectory != null
			&& jEdit.getBooleanProperty(""restore"")
			&& (bufferCount == 0 || jEdit.getBooleanProperty(""restore.cli"")))
		{
			splitConfig = restoreOpenFiles();
		}
		// Create the view and hide the splash screen.
		final Buffer _buffer = buffer;
		final String _splitConfig = splitConfig;
		GUIUtilities.advanceSplashProgress();
		SwingUtilities.invokeLater(new Runnable() {
			public void run()
			{
				if(bufferCount == 0)
					newFile(null);
				EditBus.send(new EditorStarted(null));
				View view;
				if(_buffer != null)
					view = newView(null,_buffer);
				else
					view = newView(null,_splitConfig);
				// show tip of the day
				if(jEdit.getBooleanProperty(""firstTime""))
					new HelpViewer(""welcome.html"");
				else if(jEdit.getBooleanProperty(""tip.show""))
					new TipOfTheDay(view);
				setBooleanProperty(""firstTime"",false);
				// Start I/O threads
				VFSManager.start();
				// Start edit server
				if(server != null)
					server.start();
				GUIUtilities.hideSplashScreen();
				Log.log(Log.MESSAGE,jEdit.class,""Startup ""
					+ ""complete"");
			}
		});
	}
	/**
	 * Returns the properties object which contains all known
	 * jEdit properties.
	 * @since jEdit 3.1pre4
	 */
	public static final Properties getProperties()
	{
		return props;
	}
	/**
	 * Fetches a property, returning null if it's not defined.
	 * @param name The property
	 */
	public static final String getProperty(String name)
	{
		return props.getProperty(name);
	}
	/**
	 * Fetches a property, returning the default value if it's not
	 * defined.
	 * @param name The property
	 * @param def The default value
	 */
	public static final String getProperty(String name, String def)
	{
		return props.getProperty(name,def);
	}
	/**
	 * Returns the property with the specified name, formatting it with
	 * the <code>java.text.MessageFormat.format()</code> method.
	 * @param name The property
	 * @param args The positional parameters
	 */
	public static final String getProperty(String name, Object[] args)
	{
		if(name == null)
			return null;
		if(args == null)
			return props.getProperty(name,name);
		else
			return MessageFormat.format(props.getProperty(name,
				name),args);
	}
	/**
	 * Returns the value of a boolean property.
	 * @param name The property
	 */
	public static final boolean getBooleanProperty(String name)
	{
		return getBooleanProperty(name,false);
	}
	/**
	 * Returns the value of a boolean property.
	 * @param name The property
	 * @param def The default value
	 */
	public static final boolean getBooleanProperty(String name, boolean def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else if(value.equals(""true"") || value.equals(""yes"")
			|| value.equals(""on""))
			return true;
		else if(value.equals(""false"") || value.equals(""no"")
			|| value.equals(""off""))
			return false;
		else
			return def;
	}
	/**
	 * Sets a property to a new value.
	 * @param name The property
	 * @param value The new value
	 */
	public static final void setProperty(String name, String value)
	{
		/* if value is null:
		 * - if default is null, unset user prop
		 * - else set user prop to """"
		 * else
		 * - if default equals value, ignore
		 * - if default doesn't equal value, set user
		 */
		if(value == null || value.length() == 0)
		{
			String prop = (String)defaultProps.get(name);
			if(prop == null || prop.length() == 0)
				props.remove(name);
			else
				props.put(name,"""");
		}
		else
		{
			String prop = (String)defaultProps.get(name);
			if(value.equals(prop))
				props.remove(name);
			else
				props.put(name,value);
		}
	}
	/**
	 * Sets a property to a new value. Properties set using this
	 * method are not saved to the user properties list.
	 * @param name The property
	 * @param value The new value
	 * @since jEdit 2.3final
	 */
	public static final void setTemporaryProperty(String name, String value)
	{
		props.remove(name);
		defaultProps.put(name,value);
	}
	/**
	 * @deprecated As of jEdit 2.3final. Use setTemporaryProperty()
	 * instead.
	 */
	public static final void setDefaultProperty(String name, String value)
	{
		setTemporaryProperty(name,value);
	}
	/**
	 * Sets a boolean property.
	 * @param name The property
	 * @param value The value
	 */
	public static final void setBooleanProperty(String name, boolean value)
	{
		setProperty(name,value ? ""true"" : ""false"");
	}
	/**
	 * Unsets (clears) a property.
	 * @param name The property
	 */
	public static final void unsetProperty(String name)
	{
		if(defaultProps.get(name) != null)
			props.put(name,"""");
		else
			props.remove(name);
	}
	/**
	 * Resets a property to its default value.
	 * @param name The property
	 *
	 * @since jEdit 2.5pre3
	 */
	public static final void resetProperty(String name)
	{
		props.remove(name);
	}
	/**
	 * Reloads various settings from the properties.
	 */
	public static void propertiesChanged()
	{
		initKeyBindings();
		int interval;
		try
		{
			interval = Integer.parseInt(getProperty(""autosave""));
		}
		catch(NumberFormatException nf)
		{
			//Log.log(Log.ERROR,jEdit.class,nf);
			interval = 30;
		}
		Autosave.setInterval(interval);
		saveCaret = getBooleanProperty(""saveCaret"");
		UIDefaults defaults = UIManager.getDefaults();
		// give all Swing components our colors
		if(jEdit.getBooleanProperty(""globalColors""))
		{
			Color background = new javax.swing.plaf.ColorUIResource(
				GUIUtilities.parseColor(
				jEdit.getProperty(""view.bgColor"")));
			Color foreground = new javax.swing.plaf.ColorUIResource(
				GUIUtilities.parseColor(
				jEdit.getProperty(""view.fgColor"")));
			Color caretColor = new javax.swing.plaf.ColorUIResource(
				GUIUtilities.parseColor(
				jEdit.getProperty(""view.caretColor"")));
			Color selectionColor = new javax.swing.plaf.ColorUIResource(
				GUIUtilities.parseColor(
				jEdit.getProperty(""view.selectionColor"")));
			String[] prefixes = { ""TextField"", ""TextArea"", ""List"", ""Table"" };
			for(int i = 0; i < prefixes.length; i++)
			{
				String prefix = prefixes[i];
				defaults.put(prefix + "".disabledBackground"",background);
				defaults.put(prefix + "".background"",background);
				defaults.put(prefix + "".disabledForeground"",foreground);
				defaults.put(prefix + "".foreground"",foreground);
				defaults.put(prefix + "".caretForeground"",caretColor);
				defaults.put(prefix + "".selectionForeground"",foreground);
				defaults.put(prefix + "".selectionBackground"",selectionColor);
				//defaults.put(prefix + "".inactiveForeground"",foreground);
			}
			defaults.put(""Tree.background"",background);
			defaults.put(""Tree.foreground"",foreground);
			defaults.put(""Tree.textBackground"",background);
			defaults.put(""Tree.textForeground"",foreground);
			defaults.put(""Tree.selectionForeground"",foreground);
			defaults.put(""Tree.selectionBackground"",selectionColor);
		}
		// give all text fields and text areas the same font
		String family = jEdit.getProperty(""view.font"");
		int size;
		try
		{
			size = Integer.parseInt(jEdit.getProperty(
				""view.fontsize""));
		}
		catch(NumberFormatException nf)
		{
			size = 14;
		}
		int style;
		try
		{
			style = Integer.parseInt(jEdit.getProperty(
				""view.fontstyle""));
		}
		catch(NumberFormatException nf)
		{
			style = Font.PLAIN;
		}
		Font font = new Font(family,style,size);
		//defaults.put(""TextField.font"",font);
		defaults.put(""TextArea.font"",font);
		defaults.put(""TextPane.font"",font);
		EditBus.send(new PropertiesChanged(null));
	}
	/**
	 * Returns a list of plugin JARs that are not currently loaded
	 * by examining the user and system plugin directories.
	 * @since jEdit 3.2pre1
	 */
	public static String[] getNotLoadedPluginJARs()
	{
		Vector returnValue = new Vector();
		if(jEditHome != null)
		{
			String systemPluginDir = MiscUtilities
				.constructPath(jEditHome,""jars"");
			String[] list = new File(systemPluginDir).list();
			if(list != null)
				getNotLoadedPluginJARs(returnValue,systemPluginDir,list);
		}
		if(settingsDirectory != null)
		{
			String userPluginDir = MiscUtilities
				.constructPath(settingsDirectory,""jars"");
			String[] list = new File(userPluginDir).list();
			if(list != null)
			{
				getNotLoadedPluginJARs(returnValue,
					userPluginDir,list);
			}
		}
		String[] _returnValue = new String[returnValue.size()];
		returnValue.copyInto(_returnValue);
		return _returnValue;
	}
	/**
	 * Returns the plugin with the specified class name.
	 */
	public static EditPlugin getPlugin(String name)
	{
		EditPlugin[] plugins = getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			if(plugins[i].getClassName().equals(name))
				return plugins[i];
		}
		return null;
	}
	/**
	 * Returns an array of installed plugins.
	 */
	public static EditPlugin[] getPlugins()
	{
		Vector vector = new Vector();
		for(int i = 0; i < jars.size(); i++)
		{
			((EditPlugin.JAR)jars.elementAt(i)).getPlugins(vector);
		}
		plugins.getPlugins(vector);
		EditPlugin[] array = new EditPlugin[vector.size()];
		vector.copyInto(array);
		return array;
	}
	/**
	 * Returns an array of installed plugins.
	 * @since jEdit 2.5pre3
	 */
	public static EditPlugin.JAR[] getPluginJARs()
	{
		EditPlugin.JAR[] array = new EditPlugin.JAR[jars.size()];
		jars.copyInto(array);
		return array;
	}
	/**
	 * Returns the JAR with the specified path name.
	 * @param path The path name
	 * @since jEdit 2.6pre1
	 */
	public static EditPlugin.JAR getPluginJAR(String path)
	{
		for(int i = 0; i < jars.size(); i++)
		{
			EditPlugin.JAR jar = (EditPlugin.JAR)jars.elementAt(i);
			if(jar.getPath().equals(path))
				return jar;
		}
		return null;
	}
	/**
	 * Adds a plugin JAR to the editor.
	 * @param plugin The plugin
	 * @since jEdit 3.2pre10
	 */
	public static void addPluginJAR(EditPlugin.JAR plugin)
	{
		jars.addElement(plugin);
	}
	/**
	 * Plugins should not be calling this method.
	 */
	public static void addAction(EditAction action)
	{
		actionHash.put(action.getName(),action);
	}
	/**
	 * Returns a named action.
	 * @param action The action
	 */
	public static EditAction getAction(String action)
	{
		return (EditAction)actionHash.get(action);
	}
	/**
	 * Returns the list of actions registered with the editor.
	 */
	public static EditAction[] getActions()
	{
		EditAction[] actions = new EditAction[actionHash.size()];
		Enumeration enum = actionHash.elements();
		int i = 0;
		while(enum.hasMoreElements())
		{
			actions[i++] = (EditAction)enum.nextElement();
		}
		return actions;
	}
	/**
	 * Reloads all edit modes.
	 * @since jEdit 3.2pre2
	 */
	public static void reloadModes()
	{
		/* Try to guess the eventual size to avoid unnecessary
		 * copying */
		modes = new Vector(50);
		// load the global catalog
		if(jEditHome == null)
			loadModeCatalog(""/modes/catalog"",true);
		else
		{
			loadModeCatalog(MiscUtilities.constructPath(jEditHome,
				""modes"",""catalog""),false);
		}
		// load user catalog
		if(settingsDirectory != null)
		{
			File userModeDir = new File(MiscUtilities.constructPath(
				settingsDirectory,""modes""));
			if(!userModeDir.exists())
				userModeDir.mkdirs();
			File userCatalog = new File(MiscUtilities.constructPath(
				settingsDirectory,""modes"",""catalog""));
			if(!userCatalog.exists())
			{
				// create dummy catalog
				try
				{
					FileWriter out = new FileWriter(userCatalog);
					out.write(jEdit.getProperty(""defaultCatalog""));
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,jEdit.class,io);
				}
			}
			loadModeCatalog(userCatalog.getPath(),false);
		}
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			// This reloads the token marker and sends a message
			// which causes edit panes to repaint their text areas
			buffer.setMode();
			buffer = buffer.next;
		}
	}
	/**
	 * Returns the edit mode with the specified name.
	 * @param name The edit mode
	 */
	public static Mode getMode(String name)
	{
		for(int i = 0; i < modes.size(); i++)
		{
			Mode mode = (Mode)modes.elementAt(i);
			if(mode.getName().equals(name))
				return mode;
		}
		return null;
	}
	/**
	 * Returns an array of installed edit modes.
	 */
	public static Mode[] getModes()
	{
		Mode[] array = new Mode[modes.size()];
		modes.copyInto(array);
		return array;
	}
	/**
	 * Displays the open file dialog box, and opens any selected files.
	 *
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void showOpenFileDialog(View view)
	{
		showOpenFileDialog(view,null);
	}
	/**
	 * Displays the open file dialog box, and opens any selected files,
	 * but first prompts for a character encoding to use.
	 *
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void showOpenFileWithOtherEncodingDialog(View view)
	{
		String encoding = GUIUtilities.input(view,""encoding-prompt"",null,
			jEdit.getProperty(""buffer.encoding"",
			System.getProperty(""file.encoding"")));
		if(encoding == null)
			return;
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
		{
			recorder.record(""props = new Hashtable();"");
			recorder.record(""props.put(\""encoding\"",\"""" + encoding + ""\"");"");
			recorder.record(""jEdit.showOpenFileDialog(view,props);"");
		}
		Hashtable props = new Hashtable();
		props.put(Buffer.ENCODING,encoding);
		showOpenFileDialog(view,props);
	}
	/**
	 * Displays the open file dialog box, and opens any selected files,
	 * setting the properties specified in the hash table in the buffers.
	 *
	 * @param view The view
	 * @param props The properties to set in the buffer
	 * @since jEdit 3.2pre2
	 */
	public static void showOpenFileDialog(View view, Hashtable props)
	{
		String[] files = GUIUtilities.showVFSFileDialog(view,null,
			VFSBrowser.OPEN_DIALOG,true);
		Buffer buffer = null;
		if(files != null)
		{
			for(int i = 0; i < files.length; i++)
			{
				Buffer newBuffer = openFile(null,null,files[i],
					false,props);
				if(newBuffer != null)
					buffer = newBuffer;
			}
		}
		if(buffer != null)
			view.setBuffer(buffer);
	}
	/**
	 * Opens files that were open last time.
	 * @since jEdit 3.2pre2
	 */
	public static String restoreOpenFiles()
	{
		if(settingsDirectory == null)
			return null;
		File session = new File(MiscUtilities.constructPath(
			settingsDirectory,""session""));
		if(!session.exists())
			return null;
		String splitConfig = null;
		try
		{
			BufferedReader in = new BufferedReader(new FileReader(
				session));
			String line;
			while((line = in.readLine()) != null)
			{
				if(line.startsWith(""splits\t""))
					splitConfig = line.substring(7);
				else
					openFile(null,line);
			}
			in.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,jEdit.class,""Error while loading "" + session);
			Log.log(Log.ERROR,jEdit.class,io);
		}
		return splitConfig;
	}
	/**
	 * Saves the list of open files.
	 * @since jEdit 3.1pre5
	 */
	public static void saveOpenFiles(View view)
	{
		if(settingsDirectory == null)
			return;
		view.getEditPane().saveCaretInfo();
		Buffer current = view.getBuffer();
		File session = new File(MiscUtilities.constructPath(
			settingsDirectory,""session""));
		try
		{
			String lineSep = System.getProperty(""line.separator"");
			BufferedWriter out = new BufferedWriter(new FileWriter(
				session));
			Buffer buffer = buffersFirst;
			while(buffer != null)
			{
				out.write(buffer.getPath());
				out.write(lineSep);
				buffer = buffer.next;
			}
			out.write(""splits\t"");
			out.write(view.getSplitConfig());
			out.write(lineSep);
			out.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,jEdit.class,""Error while saving "" + session);
			Log.log(Log.ERROR,jEdit.class,io);
		}
	}
	/**
	 * Opens the file names specified in the argument array. This
	 * handles +line and +marker arguments just like the command
	 * line parser.
	 * @param parent The parent directory
	 * @param args The file names to open
	 * @since jEdit 3.2pre4
	 */
	public static Buffer openFiles(View view, String parent, String[] args)
	{
		Buffer retVal = null;
		Buffer lastBuffer = null;
		for(int i = 0; i < args.length; i++)
		{
			String arg = args[i];
			if(arg == null)
				continue;
			else if(arg.startsWith(""+line:"") || arg.startsWith(""+marker:""))
			{
				if(lastBuffer != null)
					gotoMarker(view,lastBuffer,arg);
				continue;
			}
			lastBuffer = openFile(null,parent,arg,false,null);
			if(retVal == null && lastBuffer != null)
				retVal = lastBuffer;
		}
		if(view != null && retVal != null)
			view.setBuffer(retVal);
		return retVal;
	}
	/**
	 * Opens a file. Note that as of jEdit 2.5pre1, this may return
	 * null if the buffer could not be opened.
	 * @param view The view to open the file in
	 * @param path The file path
	 *
	 * @since jEdit 2.4pre1
	 */
	public static Buffer openFile(View view, String path)
	{
		return openFile(view,null,path,false,new Hashtable());
	}
	/**
	 * @deprecated The openFile() forms with the readOnly parameter
	 * should not be used. The readOnly prameter is no longer supported.
	 */
	public static Buffer openFile(View view, String parent,
		String path, boolean readOnly, boolean newFile)
	{
		return openFile(view,parent,path,newFile,new Hashtable());
	}
	/**
	 * @deprecated The openFile() forms with the readOnly parameter
	 * should not be used. The readOnly prameter is no longer supported.
	 */
	public static Buffer openFile(View view, String parent,
		String path, boolean readOnly, boolean newFile,
		Hashtable props)
	{
		return openFile(view,parent,path,newFile,props);
	}
	/**
	 * Opens a file. Note that as of jEdit 2.5pre1, this may return
	 * null if the buffer could not be opened.
	 * @param view The view to open the file in
	 * @param parent The parent directory of the file
	 * @param path The path name of the file
	 * @param newFile True if the file should not be loaded from disk
	 * be prompted if it should be reloaded
	 * @param props Buffer-local properties to set in the buffer
	 *
	 * @since jEdit 3.2pre10
	 */
	public static Buffer openFile(final View view, String parent,
		String path, boolean newFile, Hashtable props)
	{
		if(view != null && parent == null)
		{
			File file = view.getBuffer().getFile();
			if(file != null)
				parent = file.getParent();
		}
		String protocol;
		if(MiscUtilities.isURL(path))
		{
			protocol = MiscUtilities.getProtocolOfURL(path);
			if(protocol.equals(""file""))
				path = path.substring(5);
		}
		else
			protocol = ""file"";
		if(protocol.equals(""file""))
			path = MiscUtilities.constructPath(parent,path);
		Buffer buffer = getBuffer(path);
		if(buffer != null)
		{
			if(view != null)
				view.setBuffer(buffer);
			return buffer;
		}
		if(props == null)
			props = new Hashtable();
		BufferHistory.Entry entry = BufferHistory.getEntry(path);
		if(entry != null && saveCaret && props.get(Buffer.CARET) == null)
		{
			int caret = entry.caret;
			props.put(Buffer.CARET,new Integer(entry.caret));
			if(entry.selection != null)
			{
				// getSelection() converts from string to
				// Selection[]
				props.put(Buffer.SELECTION,entry.getSelection());
			}
		}
		if(entry != null && props.get(Buffer.ENCODING) == null)
		{
			if(entry.encoding != null)
				props.put(Buffer.ENCODING,entry.encoding);
		}
		final Buffer newBuffer = new Buffer(view,path,newFile,false,props);
		if(!newBuffer.load(view,false))
			return null;
		addBufferToList(newBuffer);
		EditBus.send(new BufferUpdate(newBuffer,view,BufferUpdate.CREATED));
		if(view != null)
			view.setBuffer(newBuffer);
		return newBuffer;
	}
	/**
	 * Opens a temporary buffer. A temporary buffer is like a normal
	 * buffer, except that an event is not fired, the the buffer is
	 * not added to the buffers list.
	 *
	 * @param view The view to open the file in
	 * @param parent The parent directory of the file
	 * @param path The path name of the file
	 * @param readOnly True if the file should be read only
	 * @param newFile True if the file should not be loaded from disk
	 *
	 * @since jEdit 3.2pre10
	 */
	public static Buffer openTemporary(View view, String parent,
		String path, boolean newFile)
	{
		if(view != null && parent == null)
		{
			File file = view.getBuffer().getFile();
			if(file != null)
				parent = file.getParent();
		}
		String protocol;
		if(MiscUtilities.isURL(path))
		{
			protocol = MiscUtilities.getProtocolOfURL(path);
			if(protocol.equals(""file""))
				path = path.substring(5);
		}
		else
			protocol = ""file"";
		if(protocol.equals(""file""))
			path = MiscUtilities.constructPath(parent,path);
		Buffer buffer = getBuffer(path);
		if(buffer != null)
			return buffer;
		buffer = new Buffer(null,path,newFile,true,new Hashtable());
		if(!buffer.load(view,false))
			return null;
		else
			return buffer;
	}
	/**
	 * Adds a temporary buffer to the buffer list. This must be done
	 * before allowing the user to interact with the buffer in any
	 * way.
	 * @param buffer The buffer
	 */
	public static void commitTemporary(Buffer buffer)
	{
		if(!buffer.isTemporary())
			return;
		buffer.setMode();
		buffer.propertiesChanged();
		addBufferToList(buffer);
		buffer.commitTemporary();
		EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.CREATED));
	}
	/**
	 * Creates a new `untitled' file.
	 * @param view The view to create the file in
	 */
	public static Buffer newFile(View view)
	{
		return newFile(view,null);
	}
	/**
	 * Creates a new `untitled' file.
	 * @param view The view to create the file in
	 * @param dir The directory to create the file in
	 * @since jEdit 3.1pre2
	 */
	public static Buffer newFile(View view, String dir)
	{
		// If only one new file is open which is clean, just close
		// it, which will create an 'Untitled-1'
		if(dir != null
			&& buffersFirst != null
			&& buffersFirst == buffersLast
			&& buffersFirst.isUntitled()
			&& !buffersFirst.isDirty())
		{
			closeBuffer(view,buffersFirst);
			// return the newly created 'untitled-1'
			return buffersFirst;
		}
		// Find the highest Untitled-n file
		int untitledCount = 0;
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.getName().startsWith(""Untitled-""))
			{
				try
				{
					untitledCount = Math.max(untitledCount,
						Integer.parseInt(buffer.getName()
						.substring(9)));
				}
				catch(NumberFormatException nf)
				{
				}
			}
			buffer = buffer.next;
		}
		return openFile(view,dir,""Untitled-"" + (untitledCount+1),true,null);
	}
	/**
	 * Closes a buffer. If there are unsaved changes, the user is
	 * prompted if they should be saved first.
	 * @param view The view
	 * @param buffer The buffer
	 * @return True if the buffer was really closed, false otherwise
	 */
	public static boolean closeBuffer(View view, Buffer buffer)
	{
		// Wait for pending I/O requests
		if(buffer.isPerformingIO())
		{
			VFSManager.waitForRequests();
			if(VFSManager.errorOccurred())
				return false;
		}
		if(buffer.isDirty())
		{
			Object[] args = { buffer.getName() };
			int result = GUIUtilities.confirm(view,""notsaved"",args,
				JOptionPane.YES_NO_CANCEL_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result == JOptionPane.YES_OPTION)
			{
				if(!buffer.save(view,null,true))
					return false;
			}
			else if(result != JOptionPane.NO_OPTION)
				return false;
		}
		_closeBuffer(view,buffer);
		return true;
	}
	/**
	 * Closes the buffer, even if it has unsaved changes.
	 * @param view The view
	 * @param buffer The buffer
	 *
	 * @since jEdit 2.2pre1
	 */
	public static void _closeBuffer(View view, Buffer buffer)
	{
		if(buffer.isClosed())
		{
			// can happen if the user presses C+w twice real
			// quick and the buffer has unsaved changes
			return;
		}
		if(!buffer.isNewFile())
		{
			view.getEditPane().saveCaretInfo();
			Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);
			int caret = (_caret == null ? 0 : _caret.intValue());
			BufferHistory.setEntry(buffer.getPath(),caret,
				(Selection[])buffer.getProperty(Buffer.SELECTION),
				(String)buffer.getProperty(Buffer.ENCODING));
		}
		removeBufferFromList(buffer);
		buffer.close();
		EditBus.send(new BufferUpdate(buffer,view,BufferUpdate.CLOSED));
		// Create a new file when the last is closed
		if(buffersFirst == null && buffersLast == null)
			newFile(view);
	}
	/**
	 * Closes all open buffers.
	 * @param view The view
	 */
	public static boolean closeAllBuffers(View view)
	{
		return closeAllBuffers(view,false);
	}
	/**
	 * Closes all open buffers.
	 * @param view The view
	 * @param isExiting This must be false unless this method is
	 * being called by the exit() method
	 */
	public static boolean closeAllBuffers(View view, boolean isExiting)
	{
		boolean dirty = false;
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.isDirty())
			{
				dirty = true;
				break;
			}
			buffer = buffer.next;
		}
		if(dirty)
		{
			boolean ok = new CloseDialog(view).isOK();
			if(!ok)
				return false;
		}
		// Wait for pending I/O requests
		VFSManager.waitForRequests();
		if(VFSManager.errorOccurred())
			return false;
		// close remaining buffers (the close dialog only deals with
		// dirty ones)
		buffer = buffersFirst;
		// zero it here so that BufferTabs doesn't have any problems
		buffersFirst = buffersLast = null;
		bufferCount = 0;
		while(buffer != null)
		{
			if(!buffer.isNewFile())
			{
				Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);
				int caret = (_caret == null ? 0 : _caret.intValue());
				BufferHistory.setEntry(buffer.getPath(),caret,
					(Selection[])buffer.getProperty(Buffer.SELECTION),
					(String)buffer.getProperty(Buffer.ENCODING));
			}
			buffer.close();
			if(!isExiting)
			{
				EditBus.send(new BufferUpdate(buffer,view,
					BufferUpdate.CLOSED));
			}
			buffer = buffer.next;
		}
		if(!isExiting)
			newFile(view);
		return true;
	}
	/**
	 * Saves all open buffers.
	 * @param view The view
	 * @param confirm If true, a confirmation dialog will be shown first
	 * @since jEdit 2.7pre2
	 */
	public static void saveAllBuffers(View view, boolean confirm)
	{
		if(confirm)
		{
			int result = GUIUtilities.confirm(view,""saveall"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.isDirty())
				buffer.save(view,null,true);
			buffer = buffer.next;
		}
	}
	/**
	 * Reloads all open buffers.
	 * @param view The view
	 * @param confirm If true, a confirmation dialog will be shown first
	 * @since jEdit 2.7pre2
	 */
	public static void reloadAllBuffers(final View view, boolean confirm)
	{
		if(confirm)
		{
			int result = GUIUtilities.confirm(view,""reload-all"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}
		// save caret info. Buffer.load() will load it.
		View _view = viewsFirst;
		while(_view != null)
		{
			EditPane[] panes = _view.getEditPanes();
			for(int i = 0; i < panes.length; i++)
			{
				panes[i].saveCaretInfo();
			}
			_view = _view.next;
		}
		Buffer[] buffers = jEdit.getBuffers();
		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			buffer.load(view,true);
		}
	}
	/**
	 * Returns the buffer with the specified path name. The path name
	 * must be an absolute, canonical, path.
	 * @param path The path name
	 * @see MiscUtilities#constructPath(String,String)
	 */
	public static Buffer getBuffer(String path)
	{
		boolean caseInsensitiveFilesystem = (File.separatorChar == '\\'
			|| File.separatorChar == ':' /* Windows or MacOS */);
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			String _path = buffer.getPath();
			if(caseInsensitiveFilesystem)
			{
				if(_path.equalsIgnoreCase(path))
					return buffer;
			}
			else
			{
				if(_path.equals(path))
					return buffer;
			}
			buffer = buffer.next;
		}
		return null;
	}
	/**
	 * Returns an array of open buffers.
	 */
	public static Buffer[] getBuffers()
	{
		Buffer[] buffers = new Buffer[bufferCount];
		Buffer buffer = buffersFirst;
		for(int i = 0; i < bufferCount; i++)
		{
			buffers[i] = buffer;
			buffer = buffer.next;
		}
		return buffers;
	}
	/**
	 * Returns the number of open buffers.
	 */
	public static int getBufferCount()
	{
		return bufferCount;
	}
	/**
	 * Returns the first buffer.
	 */
	public static Buffer getFirstBuffer()
	{
		return buffersFirst;
	}
	/**
	 * Returns the last buffer.
	 */
	public static Buffer getLastBuffer()
	{
		return buffersLast;
	}
	/**
	 * Returns the current input handler (key binding to action mapping)
	 * @see org.gjt.sp.jedit.gui.InputHandler
	 */
	public static InputHandler getInputHandler()
	{
		return inputHandler;
	}
	/**
	 * Creates a new view of a buffer.
	 * @param view An existing view
	 * @param buffer The buffer
	 */
	public static View newView(View view, Buffer buffer)
	{
		if(view != null)
		{
			view.showWaitCursor();
			view.getEditPane().saveCaretInfo();
		}
		View newView = new View(buffer,null);
		// Do this crap here so that the view is created
		// and added to the list before it is shown
		// (for the sake of plugins that add stuff to views)
		newView.pack();
		// newView.setSize(view.getSize()) creates incorrectly
		// sized views, for some reason...
		if(view != null)
		{
			GUIUtilities.saveGeometry(view,""view"");
			view.hideWaitCursor();
		}
		GUIUtilities.loadGeometry(newView,""view"");
		addViewToList(newView);
		EditBus.send(new ViewUpdate(newView,ViewUpdate.CREATED));
		newView.show();
		return newView;
	}
	/**
	 * Creates a new view.
	 * @param view An existing view
	 * @since jEdit 3.2pre2
	 */
	public static View newView(View view)
	{
		return newView(view,view.getSplitConfig());
	}
	/**
	 * Creates a new view.
	 * @param view An existing view
	 * @param splitConfig The split configuration
	 * @since jEdit 3.2pre2
	 */
	public static View newView(View view, String splitConfig)
	{
		if(view != null)
		{
			view.showWaitCursor();
			view.getEditPane().saveCaretInfo();
		}
		View newView = new View(null,splitConfig);
		// Do this crap here so that the view is created
		// and added to the list before it is shown
		// (for the sake of plugins that add stuff to views)
		newView.pack();
		// newView.setSize(view.getSize()) creates incorrectly
		// sized views, for some reason...
		if(view != null)
		{
			GUIUtilities.saveGeometry(view,""view"");
			view.hideWaitCursor();
		}
		GUIUtilities.loadGeometry(newView,""view"");
		addViewToList(newView);
		EditBus.send(new ViewUpdate(newView,ViewUpdate.CREATED));
		newView.show();
		return newView;
	}
	/**
	 * Closes a view. jEdit will exit if this was the last open view.
	 */
	public static void closeView(View view)
	{
		closeView(view,true);
	}
	/**
	 * Returns an array of all open views.
	 */
	public static View[] getViews()
	{
		View[] views = new View[viewCount];
		View view = viewsFirst;
		for(int i = 0; i < viewCount; i++)
		{
			views[i] = view;
			view = view.next;
		}
		return views;
	}
	/**
	 * Returns the number of open views.
	 */
	public static int getViewCount()
	{
		return viewCount;
	}
	/**
	 * Returns the first view.
	 */
	public static View getFirstView()
	{
		return viewsFirst;
	}
	/**
	 * Returns the last view.
	 */
	public static View getLastView()
	{
		return viewsLast;
	}
	/**
	 * Returns the jEdit install directory.
	 */
	public static String getJEditHome()
	{
		return jEditHome;
	}
	/**
	 * Returns the user settings directory.
	 */
	public static String getSettingsDirectory()
	{
		return settingsDirectory;
	}
	/**
	 * Saves all user preferences to disk.
	 */
	public static void saveSettings()
	{
		if(settingsDirectory != null)
		{
			// Save the recent file list
			File file = new File(MiscUtilities.constructPath(
				settingsDirectory, ""recent.xml""));
			if(file.exists() && file.lastModified() != recentModTime)
			{
				Log.log(Log.WARNING,jEdit.class,file + "" changed""
					+ "" on disk; will not save recent files"");
			}
			else
			{
				BufferHistory.save(file);
			}
			recentModTime = file.lastModified();
			file = new File(MiscUtilities.constructPath(
				settingsDirectory, ""history""));
			if(file.exists() && file.lastModified() != historyModTime)
			{
				Log.log(Log.WARNING,jEdit.class,file + "" changed""
					+ "" on disk; will not save history"");
			}
			else
			{
				HistoryModel.saveHistory(file);
			}
			historyModTime = file.lastModified();
			SearchAndReplace.save();
			Abbrevs.save();
			FavoritesVFS.saveFavorites();
			file = new File(MiscUtilities.constructPath(
				settingsDirectory,""properties""));
			if(file.exists() && file.lastModified() != propsModTime)
			{
				Log.log(Log.WARNING,jEdit.class,file + "" changed""
					+ "" on disk; will not save user properties"");
			}
			else
			{
				try
				{
					OutputStream out = new FileOutputStream(file);
					props.save(out,""jEdit properties"");
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,jEdit.class,io);
				}
				propsModTime = file.lastModified();
			}
		}
	}
	/**
	 * Exits cleanly from jEdit, prompting the user if any unsaved files
	 * should be saved first.
	 * @param view The view from which this exit was called
	 * @param reallyExit If background mode is enabled and this parameter
	 * is true, then jEdit will close all open views instead of exiting
	 * entirely.
	 */
	public static void exit(View view, boolean reallyExit)
	{
		// Wait for pending I/O requests
		VFSManager.waitForRequests();
		// Send EditorExitRequested
		EditBus.send(new EditorExitRequested(view));
		// Even if reallyExit is false, we still exit properly
		// if background mode is off
		reallyExit |= !background;
		saveOpenFiles(view);
		// Close all buffers
		if(!closeAllBuffers(view,reallyExit))
			return;
		// If we are running in background mode and
		// reallyExit was not specified, then return here.
		if(!reallyExit)
		{
			// in this case, we can't directly call
			// view.close(); we have to call closeView()
			// for all open views
			view = viewsFirst;
			while(view != null)
			{
				closeView(view,false);
				view = view.next;
			}
			// Save settings in case user kills the backgrounded
			// jEdit process
			saveSettings();
			return;
		}
		// Save view properties here - it unregisters
		// listeners, and we would have problems if the user
		// closed a view but cancelled an unsaved buffer close
		view.close();
		// Stop autosave timer
		Autosave.stop();
		// Stop server
		if(server != null)
			server.stopServer();
		// Stop all plugins
		EditPlugin[] plugins = getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			plugins[i].stop();
		}
		// Send EditorExiting
		EditBus.send(new EditorExiting(null));
		// Save settings
		saveSettings();
		// Close activity log stream
		Log.closeStream();
		// Byebye...
		System.exit(0);
	}
	// package-private members
	/**
	 * If buffer sorting is enabled, this repositions the buffer.
	 */
	static void updatePosition(Buffer buffer)
	{
		if(sortBuffers)
		{
			removeBufferFromList(buffer);
			addBufferToList(buffer);
		}
	}
	/**
	 * Do not call this method. It is only public so that classes
	 * in the org.gjt.sp.jedit.syntax package can access it.
	 * @param mode The edit mode
	 */
	public static void addMode(Mode mode)
	{
		Log.log(Log.DEBUG,jEdit.class,""Adding edit mode ""
			+ mode.getName());
		modes.addElement(mode);
	}
	/**
	 * Loads an XML-defined edit mode from the specified reader.
	 * @param mode The edit mode
	 */
	/* package-private */ static void loadMode(Mode mode)
	{
		Object fileName = mode.getProperty(""file"");
		Log.log(Log.NOTICE,jEdit.class,""Loading edit mode "" + fileName);
		XmlParser parser = new XmlParser();
		XModeHandler xmh = new XModeHandler(parser,mode.getName(),fileName.toString());
		parser.setHandler(xmh);
		try
		{
			Reader grammar;
			if(fileName instanceof URL)
			{
				grammar = new BufferedReader(
					new InputStreamReader(
					((URL)fileName).openStream()));
			}
			else
			{
				grammar = new BufferedReader(new FileReader(
					(String)fileName));
			}
			parser.parse(null, null, grammar);
		}
		catch (Exception e)
		{
			Log.log(Log.ERROR, jEdit.class, e);
			if (e instanceof XmlException)
			{
				XmlException xe = (XmlException) e;
				int line = xe.getLine();
				String message = xe.getMessage();
				Object[] args = { fileName, new Integer(line), message };
				GUIUtilities.error(null,""xmode-parse"",args);
			}
			// give it an empty token marker to avoid problems
			TokenMarker marker = new TokenMarker();
			marker.addRuleSet(""MAIN"",new ParserRuleSet());
			mode.setTokenMarker(marker);
		}
	}
	/**
	 * Loads the properties from the specified input stream. This
	 * calls the <code>load()</code> method of the properties object
	 * and closes the stream.
	 * @param in The input stream
	 * @param def If true, the properties will be loaded into the
	 * default table
	 * @exception IOException if an I/O error occured
	 */
	/* package-private */ static void loadProps(InputStream in, boolean def)
		throws IOException
	{
		in = new BufferedInputStream(in);
		if(def)
			defaultProps.load(in);
		else
			props.load(in);
		in.close();
	}
	/**
	 * Adds a plugin to the editor.
	 * @param plugin The plugin
	 */
	/* package-private */ static void addPlugin(EditPlugin plugin)
	{
		plugins.addPlugin(plugin);
	}
	/**
	 * Loads the specified action list.
	 * @since jEdit 3.1pre1
	 */
	/* package-private */ static boolean loadActions(String path, Reader in,
		boolean plugin)
	{
		Log.log(Log.DEBUG,jEdit.class,""Loading actions from "" + path);
		ActionListHandler ah = new ActionListHandler(path,plugin);
		XmlParser parser = new XmlParser();
		parser.setHandler(ah);
		try
		{
			parser.parse(null, null, in);
			return true;
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,jEdit.class,path + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}
		return false;
	}
	// private members
	private static String jEditHome;
	private static String settingsDirectory;
	private static long propsModTime, historyModTime, recentModTime;
	private static Properties defaultProps;
	private static Properties props;
	private static EditServer server;
	private static boolean background;
	private static Hashtable actionHash;
	private static Vector jars;
	private static EditPlugin.JAR plugins; /* plugins without a JAR */
	private static Vector modes;
	private static Vector recent;
	private static boolean saveCaret;
	private static InputHandler inputHandler;
	// buffer link list
	private static boolean sortBuffers;
	private static boolean sortByName;
	private static int bufferCount;
	private static Buffer buffersFirst;
	private static Buffer buffersLast;
	// view link list
	private static int viewCount;
	private static View viewsFirst;
	private static View viewsLast;
	private jEdit() {}
	private static void usage()
	{
		System.out.println(""Usage: jedit [<options>] [<files>]"");
		System.out.println(""	<file> +marker:<marker>: Positions caret""
			+ "" at marker <marker>"");
		System.out.println(""	<file> +line:<line>: Positions caret""
			+ "" at line number <line>"");
		System.out.println(""	--: End of options"");
		System.out.println(""	-background: Run in background mode"");
		System.out.println(""	-norestore: Don't restore previously open files"");
		System.out.println(""	-run=<script>: Run the specified BeanShell script"");
		System.out.println(""	-server: Read/write server""
			+ "" info from/to $HOME/.jedit/server"");
		System.out.println(""	-server=<name>: Read/write server""
			+ "" info from/to $HOME/.jedit/<name>"");
		System.out.println(""	-noserver: Don't start edit server"");
		System.out.println(""	-settings=<path>: Load user-specific""
			+ "" settings from <path>"");
		System.out.println(""	-nosettings: Don't load user-specific""
			+ "" settings"");
		System.out.println(""	-nostartupscripts: Don't run startup scripts"");
		System.out.println(""	-version: Print jEdit version and exit"");
		System.out.println(""	-usage: Print this message and exit"");
		System.out.println();
		System.out.println(""To set minimum activity log level,""
			+ "" specify a number as the first"");
		System.out.println(""command line parameter""
			+ "" (1-9, 1 = print everything, 9 = fatal errors only)"");
		System.out.println();
		System.out.println(""Report bugs to Slava Pestov <slava@jedit.org>."");
	}
	private static void version()
	{
		System.out.println(""jEdit "" + getVersion());
	}
	/**
	 * Creates a BeanShell script that can be sent to a running edit server.
	 */
	private static String makeServerScript(boolean restore,
		String[] args, String scriptFile)
	{
		StringBuffer script = new StringBuffer();
		String userDir = System.getProperty(""user.dir"");
		script.append(""parent = \"""");
		script.append(MiscUtilities.charsToEscapes(userDir));
		script.append(""\"";\n"");
		script.append(""args = new String["");
		script.append(args.length);
		script.append(""];\n"");
		for(int i = 0; i < args.length; i++)
		{
			script.append(""args["");
			script.append(i);
			script.append(""] = "");
			if(args[i] == null)
				script.append(""null"");
			else
			{
				script.append('""');
				script.append(MiscUtilities.charsToEscapes(args[i]));
				script.append('""');
			}
			script.append("";\n"");
		}
		script.append(""EditServer.handleClient("" + restore + "",parent,args);\n"");
		if(scriptFile != null)
		{
			scriptFile = MiscUtilities.constructPath(userDir,scriptFile);
			script.append(""BeanShell.runScript(null,\""""
				+ MiscUtilities.charsToEscapes(scriptFile)
				+ ""\"",false,false);\n"");
		}
		return script.toString();
	}
	/**
	 * Initialise various objects, register protocol handlers.
	 */
	private static void initMisc()
	{
		// Add our protocols to java.net.URL's list
		System.getProperties().put(""java.protocol.handler.pkgs"",
			""org.gjt.sp.jedit.proto|"" +
			System.getProperty(""java.protocol.handler.pkgs"",""""));
		inputHandler = new DefaultInputHandler(null);
		/* Determine installation directory.
		 * If the jedit.home property is set, use that.
		 * Then, look for jedit.jar in the classpath.
		 * If that fails, assume this is the web start version. */
		jEditHome = System.getProperty(""jedit.home"");
		if(jEditHome == null)
		{
			String classpath = System
				.getProperty(""java.class.path"");
			int index = classpath.toLowerCase()
				.indexOf(""jedit.jar"");
			int start = classpath.lastIndexOf(File
				.pathSeparator,index) + 1;
			// if started with java -jar jedit.jar
			/* if(classpath.equalsIgnoreCase(""jedit.jar""))
			{
				jEditHome = System.getProperty(""user.dir"");
			}
			else */ if(index > start)
			{
				jEditHome = classpath.substring(start,
					index - 1);
			}
			else
			{
				// check if web start
				/* if(jEdit.class.getResource(""/modes/catalog"") != null)
				{
					// modes bundled in; hence web start
					jEditHome = null;
				}
				else */
				{
					// use user.dir as last resort
					jEditHome = System.getProperty(""user.dir"");
				}
			}
		}
		Log.log(Log.MESSAGE,jEdit.class,""jEdit home directory is "" + jEditHome);
		//if(jEditHome == null)
		//	Log.log(Log.DEBUG,jEdit.class,""Web start mode"");
		actionHash = new Hashtable();
		plugins = new EditPlugin.JAR(null,null);
		jars = new Vector();
	}
	/**
	 * Load system properties.
	 */
	private static void initSystemProperties()
	{
		defaultProps = props = new Properties();
		try
		{
			loadProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit.props""),true);
			loadProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit_gui.props""),true);
			loadProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit_keys.props""),true);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,
				""Error while loading system properties!"");
			Log.log(Log.ERROR,jEdit.class,
				""One of the following property files could not be loaded:\n""
				+ ""- jedit.props\n""
				+ ""- jedit_gui.props\n""
				+ ""- jedit_keys.props\n""
				+ ""jedit.jar is probably corrupt."");
			Log.log(Log.ERROR,jEdit.class,e);
			System.exit(1);
		}
	}
	/**
	 * Load site properties.
	 */
	private static void initSiteProperties()
	{
		// site properties are loaded as default properties, overwriting
		// jEdit's system properties
		String siteSettingsDirectory = MiscUtilities.constructPath(
			jEditHome, ""properties"");
		File siteSettings = new File(siteSettingsDirectory);
		if (!(siteSettings.exists() && siteSettings.isDirectory()))
			return;
		String[] snippets = siteSettings.list();
		if (snippets == null)
			return;
		MiscUtilities.quicksort(snippets,
			new MiscUtilities.StringICaseCompare());
		for (int i = 0; i < snippets.length; ++i)
		{
			String snippet = snippets[i];
			if(!snippet.toLowerCase().endsWith("".props""))
				continue;
			try
			{
				String path = MiscUtilities.constructPath(
					siteSettingsDirectory,snippet);
				Log.log(Log.DEBUG,jEdit.class,
					""Loading site snippet: "" + path);
				loadProps(new FileInputStream(new File(path)),true);
			}
			catch(FileNotFoundException fnf)
			{
				Log.log(Log.DEBUG,jEdit.class,fnf);
			}
			catch(IOException e)
			{
				Log.log(Log.ERROR,jEdit.class,""Cannot load site snippet ""
					+ snippet);
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	}
	/**
	 * Load actions.
	 */
	private static void initActions()
	{
		Reader in = new BufferedReader(new InputStreamReader(
			jEdit.class.getResourceAsStream(""actions.xml"")));
		if(!loadActions(""actions.xml"",in,false))
			System.exit(1);
	}
	/**
	 * Loads plugins.
	 */
	private static void initPlugins()
	{
		if(jEditHome != null)
			loadPlugins(MiscUtilities.constructPath(jEditHome,""jars""));
		else
		{
			// load firewall plugin 'manually' in web start version
			// this is really bad, but we have to do it because
			// we need firewall functionality in order for the
			// user to be able to download and install plugins.
			try
			{
				InputStream in = jEdit.class.getResourceAsStream(""Firewall.props"");
				if(in != null)
				{
					loadProps(in,true);
					Class clazz;
					ClassLoader loader = jEdit.class.getClassLoader();
					if(loader != null)
						clazz = loader.loadClass(""FirewallPlugin"");
					else
						clazz = Class.forName(""FirewallPlugin"");
					EditPlugin plugin = (EditPlugin)clazz.newInstance();
					addPlugin(plugin);
				}
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,jEdit.class,""Could not load firewall plugin:"");
				Log.log(Log.ERROR,jEdit.class,t);
			}
		}
		if(settingsDirectory != null)
		{
			File jarsDirectory = new File(settingsDirectory,""jars"");
			if(!jarsDirectory.exists())
				jarsDirectory.mkdir();
			loadPlugins(jarsDirectory.getPath());
		}
	}
	/**
	 * Loads user properties.
	 */
	private static void initUserProperties()
	{
		props = new Properties(defaultProps);
		if(settingsDirectory != null)
		{
			File file = new File(MiscUtilities.constructPath(
				settingsDirectory,""properties""));
			propsModTime = file.lastModified();
			try
			{
				loadProps(new FileInputStream(file),false);
			}
			catch(FileNotFoundException fnf)
			{
				Log.log(Log.DEBUG,jEdit.class,fnf);
			}
			catch(IOException e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	}
	/**
	 * Sets the Swing look and feel.
	 */
	private static void initPLAF()
	{
		/* // People seem to hate the default Metal fonts because they are bold
		MetalLookAndFeel.setCurrentTheme(new DefaultMetalTheme()
		{
			FontUIResource plain12 = new FontUIResource(new Font(
				""Dialog"",Font.PLAIN,12));
			FontUIResource mono12 = new FontUIResource(new Font(
				""Monospaced"",Font.PLAIN,12));
			public String getName()
			{
				return ""jEdit"";
			}
			public FontUIResource getControlTextFont()
			{
				return plain12;
			}
			public FontUIResource getSystemTextFont()
			{
				return mono12;
			}
			public FontUIResource getUserTextFont()
			{
				return plain12;
			}
			public FontUIResource getMenuTextFont()
			{
				return plain12;
			}
		}); */
		String lf = getProperty(""lookAndFeel"");
		try
		{
			if(lf != null && lf.length() != 0)
				UIManager.setLookAndFeel(lf);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}
	}
	/**
	 * Runs scripts in the site startup directory, and user startup directory.
	 */
	private static void runStartupScripts(File directory)
	{
		if (!directory.isDirectory())
			return;
		String[] snippets = directory.list();
		if (snippets == null)
			return;
		MiscUtilities.quicksort(snippets,
			new MiscUtilities.StringICaseCompare());
		for(int i = 0; i < snippets.length; ++i)
		{
			String snippet = snippets[i];
			if(!snippet.toLowerCase().endsWith("".bsh""))
				continue;
			String path = new File(directory,snippet).getPath();
			BeanShell.runScript(null,path,false,false);
		}
	}
	private static void getNotLoadedPluginJARs(Vector returnValue,
		String dir, String[] list)
	{
loop:		for(int i = 0; i < list.length; i++)
		{
			String name = list[i];
			if(!name.toLowerCase().endsWith("".jar""))
				continue loop;
			String path = MiscUtilities.constructPath(dir,name);
			for(int j = 0; j < jars.size(); j++)
			{
				EditPlugin.JAR jar = (EditPlugin.JAR)
					jars.elementAt(j);
				String jarPath = jar.getPath();
				String jarName = MiscUtilities.getFileName(jarPath);
				if(path.equals(jarPath))
					continue loop;
				else if(!new File(jarPath).exists()
					&& name.equals(jarName))
					continue loop;
			}
			returnValue.addElement(path);
		}
	}
	private static void gotoMarker(final View view, final Buffer buffer,
		final String marker)
	{
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				int pos;
				// Handle line number
				if(marker.startsWith(""+line:""))
				{
					try
					{
						int line = Integer.parseInt(marker.substring(6));
						Element lineElement = buffer.getDefaultRootElement()
							.getElement(line - 1);
						pos = lineElement.getStartOffset();
					}
					catch(Exception e)
					{
						return;
					}
				}
				// Handle marker
				else if(marker.startsWith(""+marker:""))
				{
					if(marker.length() != 9)
						return;
					Marker m = buffer.getMarker(marker.charAt(8));
					if(m == null)
						return;
					pos = m.getPosition();
				}
				// Can't happen
				else
					throw new InternalError();
				if(view != null && view.getBuffer() == buffer)
					view.getTextArea().setCaretPosition(pos);
				else
					buffer.putProperty(Buffer.CARET,new Integer(pos));
			}
		});
	}
	private static void addBufferToList(Buffer buffer)
	{
		// if only one, clean, 'untitled' buffer is open, we
		// replace it
		if(viewCount <= 1 && buffersFirst != null
			&& buffersFirst == buffersLast
			&& buffersFirst.isUntitled()
			&& !buffersFirst.isDirty())
		{
			Buffer oldBuffersFirst = buffersFirst;
			buffersFirst = buffersLast = buffer;
			EditBus.send(new BufferUpdate(oldBuffersFirst,null,
				BufferUpdate.CLOSED));
			return;
		}
		bufferCount++;
		if(buffersFirst == null)
		{
			buffersFirst = buffersLast = buffer;
			return;
		}
		else if(sortBuffers)
		{
			String name1 = (sortByName ? buffer.getName()
				: buffer.getPath()).toLowerCase();
			Buffer _buffer = buffersFirst;
			while(_buffer != null)
			{
				String name2 = (sortByName ? _buffer.getName()
					: _buffer.getPath()).toLowerCase();
				if(name1.compareTo(name2) <= 0)
				{
					buffer.next = _buffer;
					buffer.prev = _buffer.prev;
					_buffer.prev = buffer;
					if(_buffer != buffersFirst)
						buffer.prev.next = buffer;
					else
						buffersFirst = buffer;
					return;
				}
				_buffer = _buffer.next;
			}
		}
		buffer.prev = buffersLast;
		buffersLast.next = buffer;
		buffersLast = buffer;
	}
	private static void removeBufferFromList(Buffer buffer)
	{
		bufferCount--;
		if(buffer == buffersFirst && buffer == buffersLast)
		{
			buffersFirst = buffersLast = null;
			return;
		}
		if(buffer == buffersFirst)
		{
			buffersFirst = buffer.next;
			buffer.next.prev = null;
		}
		else
		{
			buffer.prev.next = buffer.next;
		}
		if(buffer == buffersLast)
		{
			buffersLast = buffersLast.prev;
			buffer.prev.next = null;
		}
		else
		{
			buffer.next.prev = buffer.prev;
		}
		// fixes the hang that can occur if we 'save as' to a new
		// filename which requires re-sorting
		buffer.next = buffer.prev = null;
	}
	private static void addViewToList(View view)
	{
		viewCount++;
		if(viewsFirst == null)
			viewsFirst = viewsLast = view;
		else
		{
			view.prev = viewsLast;
			viewsLast.next = view;
			viewsLast = view;
		}
	}
	private static void removeViewFromList(View view)
	{
		viewCount--;
		if(viewsFirst == viewsLast)
		{
			viewsFirst = viewsLast = null;
			return;
		}
		if(view == viewsFirst)
		{
			viewsFirst = view.next;
			view.next.prev = null;
		}
		else
		{
			view.prev.next = view.next;
		}
		if(view == viewsLast)
		{
			viewsLast = viewsLast.prev;
			view.prev.next = null;
		}
		else
		{
			view.next.prev = view.prev;
		}
	}
	/**
	 * closeView() used by exit().
	 */
	private static void closeView(View view, boolean callExit)
	{
		if(viewsFirst == viewsLast && callExit)
			exit(view,false); /* exit does editor event & save */
		else
		{
			EditBus.send(new ViewUpdate(view,ViewUpdate.CLOSED));
			view.close();
			removeViewFromList(view);
		}
	}
	/**
	 * Loads a mode catalog file.
	 * @since jEdit 3.2pre2
	 */
	private static void loadModeCatalog(String path, boolean resource)
	{
		Log.log(Log.MESSAGE,jEdit.class,""Loading mode catalog file "" + path);
		ModeCatalogHandler handler = new ModeCatalogHandler(
			MiscUtilities.getParentOfPath(path),resource);
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		try
		{
			InputStream _in;
			if(resource)
				_in = jEdit.class.getResourceAsStream(path);
			else
				_in = new FileInputStream(path);
			BufferedReader in = new BufferedReader(
				new InputStreamReader(_in));
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,jEdit.class,path + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}
	}
	/**
	 * Loads all plugins in a directory.
	 * @param directory The directory
	 */
	private static void loadPlugins(String directory)
	{
		Log.log(Log.NOTICE,jEdit.class,""Loading plugins from ""
			+ directory);
		File file = new File(directory);
		if(!(file.exists() && file.isDirectory()))
			return;
		String[] plugins = file.list();
		if(plugins == null)
			return;
		MiscUtilities.quicksort(plugins,new MiscUtilities.StringICaseCompare());
		for(int i = 0; i < plugins.length; i++)
		{
			String plugin = plugins[i];
			if(!plugin.toLowerCase().endsWith("".jar""))
				continue;
			String path = MiscUtilities.constructPath(directory,plugin);
			if(plugin.equals(""EditBuddy.jar"")
				|| plugin.equals(""PluginManager.jar"")
				|| plugin.equals(""jaxp.jar"")
				|| plugin.equals(""crimson.jar""))
			{
				String[] args = { plugin };
				GUIUtilities.error(null,""plugin.obsolete"",args);
				continue;
			}
			try
			{
				Log.log(Log.DEBUG,jEdit.class,
					""Scanning JAR file: "" + path);
				new JARClassLoader(path);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,jEdit.class,""Cannot load""
					+ "" plugin "" + plugin);
				Log.log(Log.ERROR,jEdit.class,io);
				String[] args = { plugin, io.toString() };
				GUIUtilities.error(null,""plugin.load-error"",args);
			}
		}
	}
	/**
	 * Loads all key bindings from the properties.
	 * @since 3.1pre1
	 */
	private static void initKeyBindings()
	{
		inputHandler.removeAllKeyBindings();
		EditAction[] actions = getActions();
		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];
			String shortcut1 = jEdit.getProperty(action.getName()
				+ "".shortcut"");
			if(shortcut1 != null)
				inputHandler.addKeyBinding(shortcut1,action);
			String shortcut2 = jEdit.getProperty(action.getName()
				+ "".shortcut2"");
			if(shortcut2 != null)
				inputHandler.addKeyBinding(shortcut2,action);
		}
		Vector macros = Macros.getMacroList();
		for(int i = 0; i < macros.size(); i++)
		{
			Macros.Macro macro = (Macros.Macro)macros.elementAt(i);
			String shortcut1 = jEdit.getProperty(macro.name + "".shortcut"");
			if(shortcut1 != null)
				jEdit.getInputHandler().addKeyBinding(shortcut1,macro.action);
			String shortcut2 = jEdit.getProperty(macro.name + "".shortcut2"");
			if(shortcut2 != null)
				jEdit.getInputHandler().addKeyBinding(shortcut2,macro.action);
		}
	}
}
"
org.gjt.sp.jedit.Macros,"/*
 * Macros.java - Macro manager
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.text.BadLocationException;
import javax.swing.text.Element;
import javax.swing.JOptionPane;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.File;
import java.io.IOException;
import java.util.*;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.util.Log;
/**
 * This class records and runs macros.
 *
 * @author Slava Pestov
 * @version $Id: Macros.java,v 1.64 2001/08/20 06:35:02 sp Exp $
 */
public class Macros
{
	/**
	 * Utility method that can be used to display a message dialog in a macro.
	 * @param view The view
	 * @param message The message
	 * @since jEdit 2.7pre2
	 */
	public static void message(View view, String message)
	{
		JOptionPane.showMessageDialog(view,message,
			jEdit.getProperty(""macro-message.title""),
			JOptionPane.INFORMATION_MESSAGE);
	}
	/**
	 * Utility method that can be used to display an error dialog in a macro.
	 * @param view The view
	 * @param message The message
	 * @since jEdit 2.7pre2
	 */
	public static void error(View view, String message)
	{
		JOptionPane.showMessageDialog(view,message,
			jEdit.getProperty(""macro-message.title""),
			JOptionPane.ERROR_MESSAGE);
	}
	/**
	 * Utility method that can be used to prompt for input in a macro.
	 * @param view The view
	 * @param prompt The prompt string
	 * @since jEdit 2.7pre2
	 */
	public static String input(View view, String prompt)
	{
		return input(view,prompt,null);
	}
	/**
	 * Utility method that can be used to prompt for input in a macro.
	 * @param view The view
	 * @param prompt The prompt string
	 * @since jEdit 3.1final
	 */
	public static String input(View view, String prompt, String defaultValue)
	{
		return (String)JOptionPane.showInputDialog(view,prompt,
			jEdit.getProperty(""macro-input.title""),
			JOptionPane.QUESTION_MESSAGE,null,null,defaultValue);
	}
	/**
	 * Opens the system macro directory in a VFS browser.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void browseSystemMacros(View view)
	{
		if(userMacroPath == null)
		{
			GUIUtilities.error(view,""no-webstart"",null);
			return;
		}
		DockableWindowManager dockableWindowManager
			= view.getDockableWindowManager();
		dockableWindowManager.addDockableWindow(VFSBrowser.NAME);
		final VFSBrowser browser = (VFSBrowser)dockableWindowManager
			.getDockableWindow(VFSBrowser.NAME);
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				browser.setDirectory(systemMacroPath);
			}
		});
	}
	/**
	 * Opens the user macro directory in a VFS browser.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void browseUserMacros(View view)
	{
		if(userMacroPath == null)
		{
			GUIUtilities.error(view,""no-settings"",null);
			return;
		}
		DockableWindowManager dockableWindowManager
			= view.getDockableWindowManager();
		dockableWindowManager.addDockableWindow(VFSBrowser.NAME);
		final VFSBrowser browser = (VFSBrowser)dockableWindowManager
			.getDockableWindow(VFSBrowser.NAME);
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				browser.setDirectory(userMacroPath);
			}
		});
	}
	/**
	 * Rebuilds the macros list, and sends a MacrosChanged message
	 * (views update their Macros menu upon receiving it)
	 * @since jEdit 2.2pre4
	 */
	public static void loadMacros()
	{
		macroList = new Vector();
		macroHierarchy = new Vector();
		macroHash = new Hashtable();
		if(jEdit.getJEditHome() != null)
		{
			systemMacroPath = MiscUtilities.constructPath(
				jEdit.getJEditHome(),""macros"");
			loadMacros(macroHierarchy,"""",new File(systemMacroPath));
		}
		String settings = jEdit.getSettingsDirectory();
		if(settings != null)
		{
			userMacroPath = MiscUtilities.constructPath(
				settings,""macros"");
			loadMacros(macroHierarchy,"""",new File(userMacroPath));
		}
		// sort macro list
		MiscUtilities.quicksort(macroList,new MiscUtilities.StringICaseCompare());
		EditBus.send(new MacrosChanged(null));
	}
	/**
	 * Returns a vector hierarchy with all known macros in it.
	 * Each element of this vector is either a macro name string,
	 * or another vector. If it is a vector, the first element is a
	 * string label, the rest are again, either macro name strings
	 * or vectors.
	 * @since jEdit 2.6pre1
	 */
	public static Vector getMacroHierarchy()
	{
		return macroHierarchy;
	}
	/**
	 * Returns a single vector with all known macros in it.
	 * @since jEdit 3.1pre3
	 */
	public static Vector getMacroList()
	{
		return macroList;
	}
	/**
	 * Returns the macro with the specified name.
	 * @param macro The macro's name
	 * @since jEdit 2.6pre1
	 */
	public static Macro getMacro(String macro)
	{
		return (Macro)macroHash.get(macro);
	}
	/**
	 * Encapsulates the macro's label, name and path.
	 * @since jEdit 2.2pre4
	 */
	public static class Macro
	{
		public String name;
		public String path;
		public EditAction action;
		public Macro(String name, final String path)
		{
			this.name = name;
			this.path = path;
			action = new EditAction(name,false)
			{
				public void invoke(View view)
				{
					lastMacro = path;
					Buffer buffer = view.getBuffer();
					try
					{
						buffer.beginCompoundEdit();
						BeanShell.runScript(view,path,
							true,false);
					}
					finally
					{
						buffer.endCompoundEdit();
					}
				}
			};
		}
		public String toString()
		{
			return name;
		}
	}
	/**
	 * Starts recording a temporary macro.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void recordTemporaryMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();
		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}
		if(view.getMacroRecorder() != null)
		{
			GUIUtilities.error(view,""already-recording"",new String[0]);
			return;
		}
		Buffer buffer = jEdit.openFile(null,settings + File.separator
			+ ""macros"",""Temporary_Macro.bsh"",true,null);
		if(buffer == null)
			return;
		try
		{
			buffer.remove(0,buffer.getLength());
			buffer.insertString(0,jEdit.getProperty(""macro.temp.header""),null);
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,Macros.class,bl);
		}
		recordMacro(view,buffer,true);
	}
	/**
	 * Starts recording a macro.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void recordMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();
		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}
		if(view.getMacroRecorder() != null)
		{
			GUIUtilities.error(view,""already-recording"",new String[0]);
			return;
		}
		String name = GUIUtilities.input(view,""record"",null);
		if(name == null)
			return;
		name = name.replace(' ','_');
		Buffer buffer = jEdit.openFile(null,null,
			MiscUtilities.constructPath(settings,""macros"",
			name + "".bsh""),true,null);
		if(buffer == null)
			return;
		try
		{
			buffer.remove(0,buffer.getLength());
			buffer.insertString(0,jEdit.getProperty(""macro.header""),null);
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,Macros.class,bl);
		}
		recordMacro(view,buffer,false);
	}
	/**
	 * Stops a recording currently in progress.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void stopRecording(View view)
	{
		InputHandler inputHandler = view.getInputHandler();
		Recorder recorder = view.getMacroRecorder();
		if(recorder == null)
			GUIUtilities.error(view,""macro-not-recording"",null);
		else
		{
			view.setMacroRecorder(null);
			if(!recorder.temporary)
				view.setBuffer(recorder.buffer);
			recorder.dispose();
		}
	}
	/**
	 * Runs the temporary macro.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void runTemporaryMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();
		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}
		lastMacro = MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(),""macros"",
			""Temporary_Macro.bsh"");
		Buffer buffer = view.getBuffer();
		try
		{
			buffer.beginCompoundEdit();
			BeanShell.runScript(view,lastMacro,true,false);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	}
	/**
	 * Runs the most recently run or recorded macro.
	 * @param view The view
	 * @since jEdit 2.7pre2
	 */
	public static void runLastMacro(View view)
	{
		if(lastMacro == null)
			view.getToolkit().beep();
		else
			BeanShell.runScript(view,lastMacro,true,false);
	}
	// private members
	private static String systemMacroPath;
	private static String userMacroPath;
	private static Vector macroList;
	private static Vector macroHierarchy;
	private static Hashtable macroHash;
	private static String lastMacro;
	static
	{
		EditBus.addToBus(new MacrosEBComponent());
	}
	private static void loadMacros(Vector vector, String path, File directory)
	{
		String[] macroFiles = directory.list();
		if(macroFiles == null)
			return;
		MiscUtilities.quicksort(macroFiles,new MiscUtilities.StringICaseCompare());
		for(int i = 0; i < macroFiles.length; i++)
		{
			String fileName = macroFiles[i];
			File file = new File(directory,fileName);
			if(fileName.toLowerCase().endsWith("".bsh""))
			{
				String label = fileName.substring(0,fileName.length() - 4);
				String name = path + label;
				Macro newMacro = new Macro(name,file.getPath());
				vector.addElement(newMacro);
				macroList.addElement(newMacro);
				macroHash.put(name,newMacro);
			}
			else if(file.isDirectory())
			{
				Vector submenu = new Vector();
				submenu.addElement(fileName.replace('_',' '));
				loadMacros(submenu,path + fileName + '/',file);
				vector.addElement(submenu);
			}
		}
	}
	/**
	 * Starts recording a macro.
	 * @param view The view
	 * @param buffer The buffer to record to
	 * @param temporary True if this is a temporary macro
	 * @since jEdit 3.0pre5
	 */
	private static void recordMacro(View view, Buffer buffer, boolean temporary)
	{
		lastMacro = buffer.getPath();
		view.setMacroRecorder(new Recorder(view,buffer,temporary));
		// setting the message to 'null' causes the status bar to check
		// if a recording is in progress
		view.getStatus().setMessage(null);
	}
	static class MacrosEBComponent implements EBComponent
	{
		public void handleMessage(EBMessage msg)
		{
			if(msg instanceof BufferUpdate)
			{
				BufferUpdate bmsg = (BufferUpdate)msg;
				if(bmsg.getWhat() == BufferUpdate.DIRTY_CHANGED
					&& !bmsg.getBuffer().isDirty())
					maybeReloadMacros(bmsg.getBuffer().getPath());
			}
			else if(msg instanceof VFSUpdate)
			{
				maybeReloadMacros(((VFSUpdate)msg).getPath());
			}
		}
		private void maybeReloadMacros(String path)
		{
			// On Windows and MacOS, path names are case insensitive
			if(File.separatorChar == '\\' || File.separatorChar == ':')
			{
				path = path.toLowerCase();
				if(systemMacroPath != null && path.startsWith(
					systemMacroPath.toLowerCase()))
					loadMacros();
				if(userMacroPath != null && path.startsWith(
					userMacroPath.toLowerCase()))
					loadMacros();
			}
			else
			{
				if(systemMacroPath != null && path.startsWith(systemMacroPath))
					loadMacros();
				if(userMacroPath != null && path.startsWith(userMacroPath))
					loadMacros();
			}
		}
	}
	public static class Recorder implements EBComponent
	{
		View view;
		Buffer buffer;
		boolean temporary;
		boolean lastWasInput;
		public Recorder(View view, Buffer buffer, boolean temporary)
		{
			this.view = view;
			this.buffer = buffer;
			this.temporary = temporary;
			EditBus.addToBus(this);
		}
		public void record(String code)
		{
			if(lastWasInput)
			{
				lastWasInput = false;
				append(""\"");"");
			}
			append(""\n"");
			append(code);
		}
		public void record(int repeat, String code)
		{
			if(repeat == 1)
				record(code);
			else
			{
				record(""for(int i = 1; i <= "" + repeat + ""; i++)\n""
					+ ""{\n""
					+ code + ""\n""
					+ ""}"");
			}
		}
		public void record(int repeat, char ch)
		{
			// record \n and \t on lines specially so that auto indent
			// can take place
			if(ch == '\n')
				record(repeat,""textArea.userInput(\'\\n\');"");
			else if(ch == '\t')
				record(repeat,""textArea.userInput(\'\\t\');"");
			else
			{
				StringBuffer buf = new StringBuffer();
				for(int i = 0; i < repeat; i++)
					buf.append(ch);
				String charStr = MiscUtilities.charsToEscapes(buf.toString());
				if(lastWasInput)
					append(charStr);
				else
				{
					append(""\ntextArea.setSelectedText(\"""" + charStr);
					lastWasInput = true;
				}
			}
		}
		public void handleMessage(EBMessage msg)
		{
			if(msg instanceof BufferUpdate)
			{
				BufferUpdate bmsg = (BufferUpdate)msg;
				if(bmsg.getWhat() == BufferUpdate.CLOSED)
				{
					if(bmsg.getBuffer() == buffer)
						stopRecording(view);
				}
			}
		}
		private void append(String str)
		{
			try
			{
				buffer.insertString(buffer.getLength(),str,null);
			}
			catch(BadLocationException bl)
			{
				Log.log(Log.ERROR,this,bl);
			}
		}
		private void dispose()
		{
			if(lastWasInput)
			{
				lastWasInput = false;
				append(""\"");"");
			}
			int lineCount = buffer.getDefaultRootElement()
				.getElementCount();
			for(int i = 0; i < lineCount; i++)
			{
				buffer.indentLine(i,true,true);
			}
			EditBus.removeFromBus(this);
			// setting the message to 'null' causes the status bar to
			// check if a recording is in progress
			view.getStatus().setMessage(null);
		}
	}
}
"
org.gjt.sp.jedit.Marker,"/*
 * Marker.java - Named location in a buffer
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.text.BadLocationException;
import javax.swing.text.Position;
import org.gjt.sp.util.Log;
/**
 * A named location in a buffer.
 *
 * @author Slava Pestov
 * @version $Id: Marker.java,v 1.8 2001/08/11 11:44:01 sp Exp $
 */
public class Marker
{
	/**
	 * Returns the marker's shortcut.
	 * @since jEdit 3.2pre1
	 */
	public char getShortcut()
	{
		return shortcut;
	}
	/**
	 * Sets the marker's shortcut.
	 * @param shortcut The new shortcut
	 * @since jEdit 3.2pre1
	 */
	public void setShortcut(char shortcut)
	{
		this.shortcut = shortcut;
	}
	/**
	 * Returns the position of this marker.
	 * @since jEdit 3.2pre1
	 */
	public int getPosition()
	{
		return (position == null ? pos : position.getOffset());
	}
	// package-private members
	Marker(Buffer buffer, char shortcut, int position)
	{
		this.buffer = buffer;
		this.shortcut = shortcut;
		this.pos = position;
	}
	void createPosition()
	{
		try
		{
			position = buffer.createPosition(pos);
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
	}
	void removePosition()
	{
		// forget the cached Position instance
		position = null;
	}
	// private members
	private Buffer buffer;
	private char shortcut;
	private int pos;
	private Position position;
}
"
org.gjt.sp.jedit.MiscUtilities,"/*
 * MiscUtilities.java - Various miscallaneous utility functions
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 * Portions copyright (C) 2000 Richard S. Hall
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.JMenuItem;
import java.io.*;
import java.util.Vector;
import java.util.StringTokenizer;
/**
 * Class with several useful miscellaneous functions.<p>
 *
 * It provides methods for converting file names to class names, for
 * constructing path names, and for various indentation calculations.
 * A quicksort implementation is also available.
 *
 * @author Slava Pestov
 * @version $Id: MiscUtilities.java,v 1.47 2001/05/17 05:00:14 sp Exp $
 */
public class MiscUtilities
{
	/**
	 * Converts a file name to a class name. All slash characters are
	 * replaced with periods and the trailing '.class' is removed.
	 * @param name The file name
	 */
	public static String fileToClass(String name)
	{
		char[] clsName = name.toCharArray();
		for(int i = clsName.length - 6; i >= 0; i--)
			if(clsName[i] == '/')
				clsName[i] = '.';
		return new String(clsName,0,clsName.length - 6);
	}
	/**
	 * Converts a class name to a file name. All periods are replaced
	 * with slashes and the '.class' extension is added.
	 * @param name The class name
	 */
	public static String classToFile(String name)
	{
		return name.replace('.','/').concat("".class"");
	}
	/**
	 * Constructs an absolute path name from a directory and another
	 * path name.
	 * @param parent The directory
	 * @param path The path name
	 */
	public static String constructPath(String parent, String path)
	{
		if(new File(path).isAbsolute())
			return canonPath(path);
		if(parent == null)
			parent = System.getProperty(""user.dir"");
		// have to handle these cases specially on windows.
		if(File.separatorChar == '\\')
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				return path;
			if(path.startsWith(""/"") || path.startsWith(""\\""))
				parent = parent.substring(0,2);
		}
		if(parent.endsWith(File.separator) || path.endsWith(""/""))
			return canonPath(parent + path);
		else
			return canonPath(parent + File.separator + path);
	}
	/**
	 * Constructs an absolute path name from three path components.
	 * @param parent The parent directory
	 * @param path1 The first path
	 * @param path2 The second path
	 */
	public static String constructPath(String parent,
		String path1, String path2)
	{
		return constructPath(constructPath(parent,path1),path2);
	}
	/**
	 * Like constructPath(), except <code>path</code> will be
	 * appended to <code>parent</code> even if it is absolute.
	 * @param path
	 * @param parent
	 */
	public static String concatPath(String parent, String path)
	{
		// Make all child paths relative.
		if (path.startsWith(File.separator))
			path = path.substring(1);
		else if ((path.length() >= 3) && (path.charAt(1) == ':'))
			path = path.replace(':', File.separatorChar);
		if (parent == null)
			parent = System.getProperty(""user.dir"");
		if (parent.endsWith(File.separator))
			return parent + path;
		else
			return parent + File.separator + path;
	}
	/**
	 * Returns the extension of the specified filename, or an empty
	 * string if there is none.
	 * @param name The file name
	 */
	public static String getFileExtension(String name)
	{
		int index = name.indexOf('.');
		if(index == -1)
			return """";
		else
			return name.substring(index);
	}
	/**
	 * For use with local files only - returns the last component
	 * of the specified path.
	 * @param path The path name
	 */
	public static String getFileName(String path)
	{
		int count = Math.max(0,path.length() - 2);
		int index1 = path.lastIndexOf(File.separatorChar,count);
		int index2 = path.lastIndexOf('/',count);
		return path.substring(Math.max(index1,index2) + 1);
	}
	/**
	 * @deprecated Call getParentOfPath() instead
	 */
	public static String getFileParent(String path)
	{
		return getParentOfPath(path);
	}
	/**
	 * For use with local files only - returns the parent of the
	 * specified path.
	 * @param path The path name
	 * @since jEdit 2.6pre5
	 */
	public static String getParentOfPath(String path)
	{
		// ignore last character of path to properly handle
		// paths like /foo/bar/
		int count = Math.max(0,path.length() - 2);
		int index = path.lastIndexOf(File.separatorChar,count);
		if(index == -1)
			index = path.lastIndexOf('/',count);
		if(index == -1)
		{
			// this ensures that getFileParent(""protocol:""), for
			// example, is ""protocol:"" and not """".
			index = path.lastIndexOf(':');
		}
		return path.substring(0,index + 1);
	}
	/**
	 * @deprecated Call getProtocolOfURL() instead
	 */
	public static String getFileProtocol(String url)
	{
		return getProtocolOfURL(url);
	}
	/**
	 * Returns the protocol specified by a URL.
	 * @param url The URL
	 * @since jEdit 2.6pre5
	 */
	public static String getProtocolOfURL(String url)
	{
		return url.substring(0,url.indexOf(':'));
	}
	/**
	 * Checks if the specified string is a URL.
	 * @param str The string to check
	 * @return True if the string is a URL, false otherwise
	 */
	public static boolean isURL(String str)
	{
		int fsIndex = Math.max(str.indexOf(File.separatorChar),
			str.indexOf('/'));
		if(fsIndex == 0) // /etc/passwd
			return false;
		else if(fsIndex == 2) // C:\AUTOEXEC.BAT
			return false;
		int cIndex = str.indexOf(':');
		if(cIndex <= 1) // D:\WINDOWS
			return false;
		else if(fsIndex != -1 && cIndex > fsIndex) // /tmp/RTF::read.pm
			return false;
		return true;
	}
	/**
	 * Returns the number of leading white space characters in the
	 * specified string.
	 * @param str The string
	 */
	public static int getLeadingWhiteSpace(String str)
	{
		int whitespace = 0;
loop:		for(;whitespace < str.length();)
		{
			switch(str.charAt(whitespace))
			{
			case ' ': case '\t':
				whitespace++;
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	}
	/**
	 * Returns the number of trailing whitespace characters in the
	 * specified string.
	 * @param str The string
	 * @since jEdit 2.5pre5
	 */
	public static int getTrailingWhiteSpace(String str)
	{
		int whitespace = 0;
loop:		for(int i = str.length() - 1; i >= 0; i--)
		{
			switch(str.charAt(i))
			{
			case ' ': case '\t':
				whitespace++;
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	}
	/**
	 * Returns the width of the leading white space in the specified
	 * string.
	 * @param str The string
	 * @param tabSize The tab size
	 */
	public static int getLeadingWhiteSpaceWidth(String str, int tabSize)
	{
		int whitespace = 0;
loop:		for(int i = 0; i < str.length(); i++)
		{
			switch(str.charAt(i))
			{
			case ' ':
				whitespace++;
				break;
			case '\t':
				whitespace += (tabSize - whitespace % tabSize);
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	}
	/**
	 * Creates a string of white space with the specified length.
	 * @param len The length
	 * @param tabSize The tab size, or 0 if tabs are not to be used
	 */
	public static String createWhiteSpace(int len, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		if(tabSize == 0)
		{
			while(len-- > 0)
				buf.append(' ');
		}
		else		
		{
			int count = len / tabSize;
			while(count-- > 0)
				buf.append('\t');
			count = len % tabSize;
			while(count-- > 0)
				buf.append(' ');
		}
		return buf.toString();
	}
	/**
	 * Converts a Unix-style glob to a regular expression.
	 * ? becomes ., * becomes .*, {aa,bb} becomes (aa|bb).
	 * @param glob The glob pattern
	 */
	public static String globToRE(String glob)
	{
		StringBuffer buf = new StringBuffer();
		boolean backslash = false;
		boolean insideGroup = false;
		for(int i = 0; i < glob.length(); i++)
		{
			char c = glob.charAt(i);
			if(backslash)
			{
				buf.append('\\');
				buf.append(c);
				backslash = false;
				continue;
			}
			switch(c)
			{
			case '\\':
				backslash = true;
				break;
			case '?':
				buf.append('.');
				break;
			case '.':
				buf.append(""\\."");
				break;
			case '*':
				buf.append("".*"");
				break;
			case '{':
				buf.append('(');
				insideGroup = true;
				break;
			case ',':
				if(insideGroup)
					buf.append('|');
				else
					buf.append(',');
				break;
			case '}':
				buf.append(')');
				insideGroup = false;
				break;
			default:
				buf.append(c);
			}
		}
		return buf.toString();
	}
	/**
	 * Converts ""\n"" and ""\t"" escapes in the specified string to
	 * newlines and tabs.
	 * @param str The string
	 * @since jEdit 2.3pre1
	 */
	public static String escapesToChars(String str)
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < str.length(); i++)
		{
			char c = str.charAt(i);
			switch(c)
			{
			case '\\':
				if(i == str.length() - 1)
				{
					buf.append('\\');
					break;
				}
				c = str.charAt(++i);
				switch(c)
				{
				case 'n':
					buf.append('\n');
					break;
				case 't':
					buf.append('\t');
					break;
				default:
					buf.append(c);
					break;
				}
				break;
			default:
				buf.append(c);
			}
		}
		return buf.toString();
	}
	/**
	 * Escapes newlines, tabs, backslashes, quotes in the specified
	 * string.
	 * @param str The string
	 * @since jEdit 2.3pre1
	 */
	public static String charsToEscapes(String str)
	{
		return charsToEscapes(str,false);
	}
	/**
	 * Escapes newlines, tabs, backslashes, quotes in the specified
	 * string.
	 * @param str The string
	 * @param history jEdit history files require additional escaping
	 * @since jEdit 2.7pre2
	 */
	public static String charsToEscapes(String str, boolean history)
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < str.length(); i++)
		{
			char c = str.charAt(i);
			switch(c)
			{
			case '\n':
				buf.append(""\\n"");
				break;
			case '\t':
				buf.append(""\\t"");
				break;
			case '[':
				if(history)
					buf.append(""\\["");
				else
					buf.append(c);
				break;
			case ']':
				if(history)
					buf.append(""\\]"");
				else
					buf.append(c);
				break;
			case '""':
				if(history)
					buf.append(c);
				else
					buf.append(""\\\"""");
				break;
			case '\'':
				if(history)
					buf.append(c);
				else
					buf.append(""\\\'"");
				break;
			case '\\':
				buf.append(""\\\\"");
				break;
			default:
				buf.append(c);
				break;
			}
		}
		return buf.toString();
	}
	/**
	 * Sorts the specified array.
	 * @param obj The array
	 * @param compare Compares the objects
	 */
	public static void quicksort(Object[] obj, Compare compare)
	{
		if(obj.length == 0)
			return;
		quicksort(obj,0,obj.length - 1,compare);
	}
	/**
	 * Sorts the specified vector.
	 * @param vector The vector
	 * @param compare Compares the objects
	 */
	public static void quicksort(Vector vector, Compare compare)
	{
		if(vector.size() == 0)
			return;
		quicksort(vector,0,vector.size() - 1,compare);
	}
	/**
	 * An interface for comparing objects.
	 */
	public interface Compare
	{
		int compare(Object obj1, Object obj2);
	}
	/**
	 * Compares strings.
	 */
	public static class StringCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return obj1.toString().compareTo(obj2.toString());
		}
	}
	/**
	 * Compares strings ignoring case.
	 */
	public static class StringICaseCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return obj1.toString().toLowerCase()
				.compareTo(obj2.toString()
				.toLowerCase());
		}
	}
	public static class MenuItemCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return ((JMenuItem)obj1).getText().compareTo(
				((JMenuItem)obj2).getText());
		}
	}
	/**
	 * Compares two version strings formatted like 'xxx.xx.xxx'.
	 * The version string are tokenized at '.' and the substrings
	 * of both strings are compared with one after another.
	 * For each substring at first they are compared as Integers
	 * and if that fails, as Strings. The comparison ends with
	 * the first difference.
	 * Note, that ""1.2.0"" < ""1.2.0pre1"", because ""0"" < ""0pre1"".
	 * Therefore you should avoid mixing numbers and text.
	 * Case is <i>not</i> ignored.
	 */
	public static class VersionCompare implements Compare
	{
		/**
		 * compare two version strings 
		 * @param obj1 first version. Should be a String.
		 * @param obj2 secons version. Should be a String.
		 * @return a negative value, if <code>obj1 < obj2</code>, 
		 *         a positive value, if <code>obj1 > obj2</code>,
		 *         0, if <code>obj1.equals(obj2)</code>.
		 */
		public int compare(Object obj1, Object obj2)
		{
			String v1 = obj1.toString();
			String v2 = obj2.toString();
			StringTokenizer vt1 = new StringTokenizer(v1,""."");
			StringTokenizer vt2 = new StringTokenizer(v2,""."");
			int comp = 0;
			while(vt1.hasMoreTokens() && vt2.hasMoreTokens()) {
				String vt1tok = vt1.nextToken();
				String vt2tok = vt2.nextToken();
				try
				{
					int i1 = Integer.parseInt(vt1tok);
					int i2 = Integer.parseInt(vt2tok);
					comp = i1 < i2 ? -1 : i1 > i2 ? 1 : 0;
				}
				catch(NumberFormatException e)
				{	
					comp = vt1tok.compareTo(vt2tok);
				}
				if(comp != 0)
					return comp;
			}
			return vt1.hasMoreTokens() ? 1 
				: vt2.hasMoreTokens() ? -1 : 0;
		}
	}
	/**
	 * Helper function to compare two version strings, using the 
	 * VersionCompare class.
	 * @param version1 the first version string
	 * @param version2 the second version string
	 * @return a negative value, if <code>version1 &lt; version2</code>, 
	 *         a positive value, if <code>version1 &gt; version2</code>,
	 *         0, if <code>version1.equals(version2)</code>.
	 */
	public static int compareVersions(String version1, String version2)
	{
		VersionCompare comparator = new VersionCompare();
		return comparator.compare(version1,version2);
	}
	/**
	 * Converts an internal version number (build) into a
	 * `human-readable' form.
	 * @param build The build
	 */
	public static String buildToVersion(String build)
	{
		if(build.length() != 11)
			return ""<unknown version: "" + build + "">"";
		// First 2 chars are the major version number
		int major = Integer.parseInt(build.substring(0,2));
		// Second 2 are the minor number
		int minor = Integer.parseInt(build.substring(3,5));
		// Then the pre-release status
		int beta = Integer.parseInt(build.substring(6,8));
		// Finally the bug fix release
		int bugfix = Integer.parseInt(build.substring(9,11));
		return """" + major + ""."" + minor
			+ (beta != 99 ? ""pre"" + beta :
			(bugfix != 0 ? ""."" + bugfix : ""final""));
	}
	// private members
	private MiscUtilities() {}
	private static String canonPath(String path)
	{
		if(File.separatorChar == '\\')
		{
			// get rid of mixed paths on Windows
			path = path.replace('/','\\');
		}
		try
		{
			return new File(path).getCanonicalPath();
		}
		catch(Exception e)
		{
			return path;
		}
	}
	private static void quicksort(Object[] obj, int _start, int _end,
		Compare compare)
	{
		int start = _start;
		int end = _end;
		Object mid = obj[(_start + _end) / 2];
		if(_start > _end)
			return;
		while(start <= end)
		{
			while((start < _end) && (compare.compare(obj[start],mid) < 0))
				start++;
			while((end > _start) && (compare.compare(obj[end],mid) > 0))
				end--;
			if(start <= end)
			{
				Object o = obj[start];
				obj[start] = obj[end];
				obj[end] = o;
				start++;
				end--;
			}
		}
		if(_start < end)
			quicksort(obj,_start,end,compare);
		if(start < _end)
			quicksort(obj,start,_end,compare);
	}
	private static void quicksort(Vector obj, int _start, int _end,
		Compare compare)
	{
		int start = _start;
		int end = _end;
		Object mid = obj.elementAt((_start + _end) / 2);
		if(_start > _end)
			return;
		while(start <= end)
		{
			while((start < _end) && (compare.compare(obj.elementAt(start),mid) < 0))
				start++;
			while((end > _start) && (compare.compare(obj.elementAt(end),mid) > 0))
				end--;
			if(start <= end)
			{
				Object o = obj.elementAt(start);
				obj.setElementAt(obj.elementAt(end),start);
				obj.setElementAt(o,end);
				start++;
				end--;
			}
		}
		if(_start < end)
			quicksort(obj,_start,end,compare);
		if(start < _end)
			quicksort(obj,start,_end,compare);
	}
}
"
org.gjt.sp.jedit.Mode,"/*
 * Mode.java - jEdit editing mode
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 * Copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import gnu.regexp.*;
import java.util.Hashtable;
import org.gjt.sp.jedit.syntax.TokenMarker;
import org.gjt.sp.util.Log;
/**
 * An edit mode defines specific settings for editing some type of file.
 * One instance of this class is created for each supported edit mode.
 * In most cases, instances of this class can be created directly, however
 * if the edit mode needs to define custom indentation behaviour,
 * subclassing is required.
 *
 * @author Slava Pestov
 * @version $Id: Mode.java,v 1.37 2001/06/09 08:45:02 sp Exp $
 */
public class Mode
{
	/**
	 * Creates a new edit mode.
	 *
	 * @param name The name used in mode listings and to query mode
	 * properties
	 * @see #getProperty(String)
	 */
	public Mode(String name)
	{
		this.name = name;
		props = new Hashtable();
	}
	/**
	 * Initializes the edit mode. Should be called after all properties
	 * are loaded and set.
	 */
	public void init()
	{
		try
		{
			String filenameGlob = (String)getProperty(""filenameGlob"");
			if(filenameGlob != null && filenameGlob.length() != 0)
			{
				filenameRE = new RE(MiscUtilities.globToRE(
					filenameGlob),RE.REG_ICASE);
			}
			String firstlineGlob = (String)getProperty(""firstlineGlob"");
			if(firstlineGlob != null && firstlineGlob.length() != 0)
			{
				firstlineRE = new RE(MiscUtilities.globToRE(
					firstlineGlob),RE.REG_ICASE);
			}
		}
		catch(REException re)
		{
			Log.log(Log.ERROR,this,""Invalid filename/firstline""
				+ "" globs in mode "" + name);
			Log.log(Log.ERROR,this,re);
		}
	}
	/**
	 * Returns the token marker specified with
	 * <code>setTokenMarker()</code>. Should only be called by
	 * <code>TokenMarker.getExternalRuleSet()</code>.
	 */
	public TokenMarker getTokenMarker()
	{
		loadIfNecessary();
		return marker;
	}
	/**
	 * Sets the token marker for this mode. This token marker will be
	 * cloned to obtain new instances.
	 * @param marker The new token marker
	 */
	public void setTokenMarker(TokenMarker marker)
	{
		this.marker = marker;
	}
	/**
	 * Loads the mode from disk if it hasn't been loaded already.
	 * @since jEdit 2.5pre3
	 */
	public void loadIfNecessary()
	{
		if(marker == null)
			jEdit.loadMode(this);
	}
	/**
	 * Returns a mode property.
	 * @param key The property name
	 *
	 * @since jEdit 2.2pre1
	 */
	public Object getProperty(String key)
	{
		String prefix = ""mode."" + name + ""."";
		//if(jEdit.getBooleanProperty(prefix + ""customSettings""))
		//{
			String property = jEdit.getProperty(prefix + key);
			if(property != null)
			{
				Object value;
				try
				{
					value = new Integer(property);
				}
				catch(NumberFormatException nf)
				{
					value = property;
				}
				return value;
			}
		//}
		Object value = props.get(key);
		if(value != null)
			return value;
		String global = jEdit.getProperty(""buffer."" + key);
		if(global != null)
		{
			try
			{
				return new Integer(global);
			}
			catch(NumberFormatException nf)
			{
				return global;
			}
		}
		else
			return null;
	}
	/**
	 * Returns the value of a boolean property.
	 * @param key The property name
	 *
	 * @since jEdit 2.5pre3
	 */
	public boolean getBooleanProperty(String key)
	{
		Object value = getProperty(key);
		if(""true"".equals(value) || ""on"".equals(value) || ""yes"".equals(value))
			return true;
		else
			return false;
	}
	/**
	 * Sets a mode property.
	 * @param key The property name
	 * @param value The property value
	 */
	public void setProperty(String key, Object value)
	{
		props.put(key,value);
	}
	/**
	 * Unsets a mode property.
	 * @param key The property name
	 * @since jEdit 3.2pre3
	 */
	public void unsetProperty(String key)
	{
		props.remove(key);
	}
	/**
	 * Returns if the edit mode is suitable for editing the specified
	 * file. The buffer name and first line is checked against the
	 * file name and first line globs, respectively.
	 * @param fileName The buffer's name
	 * @param firstLine The first line of the buffer
	 *
	 * @since jEdit 3.2pre3
	 */
	public boolean accept(String fileName, String firstLine)
	{
		if(filenameRE != null && filenameRE.isMatch(fileName))
			return true;
		if(firstlineRE != null && firstlineRE.isMatch(firstLine))
			return true;
		return false;
	}
	/**
	 * Returns the internal name of this edit mode.
	 */
	public String getName()
	{
		return name;
	}
	/**
	 * Returns a string representation of this edit mode.
	 */
	public String toString()
	{
		return getClass().getName() + ""["" + getName() + ""]"";
	}
	// private members
	private String name;
	private Hashtable props;
	private RE firstlineRE;
	private RE filenameRE;
	private TokenMarker marker;
}
"
org.gjt.sp.jedit.ModeCatalogHandler,"/*
 * ModeCatalogHandler.java - XML handler for mode catalog files
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import com.microstar.xml.*;
import java.io.*;
import java.util.Stack;
import org.gjt.sp.util.Log;
class ModeCatalogHandler extends HandlerBase
{
	ModeCatalogHandler(String directory, boolean resource)
	{
		this.directory = directory;
		this.resource = resource;
	}
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""catalog.dtd"".equals(systemId))
		{
			try
			{
				return new BufferedReader(new InputStreamReader(
					getClass().getResourceAsStream(""catalog.dtd"")));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,""Error while opening""
					+ "" catalog.dtd:"");
				Log.log(Log.ERROR,this,e);
			}
		}
		return null;
	}
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		if(aname == ""NAME"")
			modeName = value;
		else if(aname == ""FILE"")
		{
			if(value == null)
			{
				Log.log(Log.ERROR,this,directory + ""catalog:""
					+ "" mode "" + modeName + "" doesn't have""
					+ "" a FILE attribute"");
			}
			else
				file = value;
		}
		else if(aname == ""FILE_NAME_GLOB"")
			filenameGlob = value;
		else if(aname == ""FIRST_LINE_GLOB"")
			firstlineGlob = value;
	}
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		// older jEdit versions used a DOCTYPE of CATALOG, which
		// is incorrect since the DOCTYPE must be the name of the
		// root element, which is MODES.
		// so you the avid code reader should use MODES as the
		// DOCTYPE instead, but we still let old catalogs through
		// to avoid annoying users.
		if(""CATALOG"".equals(name) || ""MODES"".equals(name))
			return;
		Log.log(Log.ERROR,this,directory + ""catalog: DOCTYPE must be CATALOG"");
	}
	public void endElement(String name)
	{
		if(name.equals(""MODE""))
		{
			Mode mode = jEdit.getMode(modeName);
			if(mode == null)
			{
				mode = new Mode(modeName);
				jEdit.addMode(mode);
			}
			Object path;
			if(resource)
				path = jEdit.class.getResource(directory + file);
			else
				path = MiscUtilities.constructPath(directory,file);
			mode.setProperty(""file"",path);
			if(filenameGlob != null)
				mode.setProperty(""filenameGlob"",filenameGlob);
			else
				mode.unsetProperty(""filenameGlob"");
			if(firstlineGlob != null)
				mode.setProperty(""firstlineGlob"",firstlineGlob);
			else
				mode.unsetProperty(""firstlineGlob"");
			mode.init();
			modeName = file = filenameGlob = firstlineGlob = null;
		}
	}
	// end HandlerBase implementation
	// private members
	private String directory;
	private boolean resource;
	private String modeName;
	private String file;
	private String filenameGlob;
	private String firstlineGlob;
}
"
org.gjt.sp.jedit.OptionGroup,"/*
 * OptionGroup.java - Option pane group
 * Copyright (C) 2000 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.util.Enumeration;
import java.util.Vector;
import org.gjt.sp.util.Log;
public class OptionGroup
{
	public OptionGroup(String name)
	{
		this.name = name;
		members = new Vector();
	}
	public String getName()
	{
		return name;
	}
	public void addOptionGroup(OptionGroup group)
	{
		if (members.indexOf(group) != -1) return;
		members.addElement(group);
	}
	public void addOptionPane(OptionPane pane)
	{
		if (members.indexOf(pane) != -1) return;
		members.addElement(pane);
	}
	public Enumeration getMembers()
	{
		return members.elements();
	}
	public Object getMember(int index)
	{
		return (index >= 0 && index < members.size())
			? members.elementAt(index) : null;
	}
	public int getMemberIndex(Object member)
	{
		return members.indexOf(member);
	}
	public int getMemberCount()
	{
		return members.size();
	}
	public void save()
	{
		Enumeration enum = members.elements();
		while (enum.hasMoreElements())
		{
			Object elem = enum.nextElement();
			try
			{
				if (elem instanceof OptionPane)
				{
					((OptionPane)elem).save();
				}
				else if (elem instanceof OptionGroup)
				{
					((OptionGroup)elem).save();
				}
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR, elem,
					""Error saving option pane"");
				Log.log(Log.ERROR, elem, t);
			}
		}
	}
	private String name;
	private Vector members;
}
"
org.gjt.sp.jedit.OptionPane,"/*
 * OptionPane.java - Option pane interface
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import java.awt.Component;
/**
 * The interface all option panes must implement.  Internally, jEdit uses
 * option panes to implement the tabs in the ""Global Options"" dialog box.
 * Plugins can also create option panes for the ""Plugin Options"" dialog
 * box.<p>
 *
 * The <i>name</i> of an option pane is returned by the <code>getName()</code>
 * method. The label displayed in the option pane's tab is obtained from the
 * <code>options.<i>name</i>.label</code> property.
 *
 * @see org.gjt.sp.jedit.AbstractOptionPane
 */
public interface OptionPane
{
	/**
	 * Returns the internal name of this option pane.
	 */
	String getName();
	/**
	 * Returns the component that should be displayed for this option pane.
	 */
	Component getComponent();
	/**
	 * This method should create the option pane's GUI.
	 */
	void init();
	/**
	 * Called when the options dialog's ""ok"" button is clicked.
	 * This should save any properties being edited in this option
	 * pane.
	 */
	void save();
}
/*
 * ChangeLog:
 * $Log: OptionPane.java,v $
 * Revision 1.8  2000/04/28 09:29:11  sp
 * Key binding handling improved, VFS updates, some other stuff
 *
 * Revision 1.7  2000/04/23 03:58:00  sp
 * ContextOptionPane didn't compile, hack to let JBrowse and QuickFile work
 *
 * Revision 1.6  2000/04/16 08:56:24  sp
 * Option pane updates
 *
 * Revision 1.5  1999/11/21 01:20:30  sp
 * Bug fixes, EditBus updates, fixed some warnings generated by jikes +P
 *
 * Revision 1.4  1999/10/04 03:20:51  sp
 * Option pane change, minor tweaks and bug fixes
 *
 * Revision 1.3  1999/10/02 01:12:36  sp
 * Search and replace updates (doesn't work yet), some actions moved to TextTools
 *
 * Revision 1.2  1999/05/01 00:55:11  sp
 * Option pane updates (new, easier API), syntax colorizing updates
 *
 * Revision 1.1  1999/04/21 07:39:18  sp
 * FAQ added, plugins can now add panels to the options dialog
 *
 */
"
org.gjt.sp.jedit.Registers,"/*
 * Registers.java - Register manager
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.text.*;
import java.lang.reflect.*;
import java.awt.datatransfer.*;
import java.awt.Toolkit;
import java.io.*;
import java.util.Vector;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.util.Log;
/**
 * jEdit's registers are an extension of the clipboard metaphor.
 *
 * @author Slava Pestov
 * @version $Id: Registers.java,v 1.27 2001/08/01 07:37:11 sp Exp $
 */
public class Registers
{
	/**
	 * Convinience method that copies the text selected in the specified
	 * text area into the specified register.
	 * @param textArea The text area
	 * @param register The register
	 * @since jEdit 2.7pre2
	 */
	public static void copy(JEditTextArea textArea, char register)
	{
		String selection = textArea.getSelectedText();
		if(selection == null)
			return;
		setRegister(register,selection);
		HistoryModel.getModel(""clipboard"").addItem(selection);
	}
	/**
	 * Convinience method that appends the text selected in the specified
	 * text area to the specified register, with a newline between the old
	 * and new text.
	 * @param textArea The text area
	 * @param register The register
	 */
	public static void append(JEditTextArea textArea, char register)
	{
		append(textArea,register,""\n"",false);
	}
	/**
	 * Convinience method that appends the text selected in the specified
	 * text area to the specified register.
	 * @param textArea The text area
	 * @param register The register
	 * @param separator The text to insert between the old and new text
	 */
	public static void append(JEditTextArea textArea, char register,
		String separator)
	{
		append(textArea,register,separator,false);
	}
	/**
	 * Convinience method that appends the text selected in the specified
	 * text area to the specified register.
	 * @param textArea The text area
	 * @param register The register
	 * @param separator The text to insert between the old and new text
	 * @param cut Should the current selection be removed?
	 * @since jEdit 3.2pre1
	 */
	public static void append(JEditTextArea textArea, char register,
		String separator, boolean cut)
	{
		if(cut && !textArea.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}
		String selection = textArea.getSelectedText();
		if(selection == null)
			return;
		Register reg = getRegister(register);
		String registerContents = reg.toString();
		if(reg != null && registerContents != null)
		{
			if(registerContents.endsWith(separator))
				selection = registerContents + selection;
			else
				selection = registerContents + separator + selection;
		}
		setRegister(register,selection);
		HistoryModel.getModel(""clipboard"").addItem(selection);
		if(cut)
			textArea.setSelectedText("""");
	}
	/**
	 * Convinience method that copies the text selected in the specified
	 * text area into the specified register, and then removes it from the
	 * text area.
	 * @param textArea The text area
	 * @param register The register
	 * @since jEdit 2.7pre2
	 */
	public static void cut(JEditTextArea textArea, char register)
	{
		if(textArea.isEditable())
		{
			String selection = textArea.getSelectedText();
			if(selection == null)
				return;
			setRegister(register,selection);
			HistoryModel.getModel(""clipboard"").addItem(selection);
			textArea.setSelectedText("""");
		}
		else
			textArea.getToolkit().beep();
	}
	/**
	 * Convinience method that pastes the contents of the specified
	 * register into the text area.
	 * @param textArea The text area
	 * @param register The register
	 * @since jEdit 2.7pre2
	 */
	public static void paste(JEditTextArea textArea, char register)
	{
		if(!textArea.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}
		Register reg = getRegister(register);
		if(reg == null)
		{
			textArea.getToolkit().beep();
			return;
		}
		else
		{
			String selection = reg.toString();
			if(selection == null)
			{
				textArea.getToolkit().beep();
				return;
			}
			// preserve magic pos for easy insertion of the
			// same string at the start of multiple lines
			int magic = textArea.getMagicCaretPosition();
			textArea.setSelectedText(selection);
			if(textArea.getCaretPosition()
				!= textArea.getLineEndOffset(textArea.getCaretLine()) - 1)
			{
				textArea.setMagicCaretPosition(magic);
			}
			else
			{
				// if user is pasting at end of line, chances are
				// they want the caret to go the the end of the
				// line again when they move it up or down
			}
			HistoryModel.getModel(""clipboard"").addItem(selection);
		}
	}
	/**
	 * Returns the specified register.
	 * @param name The name
	 */
	public static Register getRegister(char name)
	{
		if(registers == null || name >= registers.length)
			return null;
		else
			return registers[name];
	}
	/**
	 * Sets the specified register.
	 * @param name The name
	 * @param newRegister The new value
	 */
	public static void setRegister(char name, Register newRegister)
	{
		if(name >= registers.length)
		{
			Register[] newRegisters = new Register[
				Math.min(1<<16,name * 2)];
			System.arraycopy(registers,0,newRegisters,0,
				registers.length);
			registers = newRegisters;
		}
		registers[name] = newRegister;
	}
	/**
	 * Sets the specified register.
	 * @param name The name
	 * @param value The new value
	 */
	public static void setRegister(char name, String value)
	{
		if(name >= registers.length)
		{
			Register[] newRegisters = new Register[
				Math.min(1<<16,name * 2)];
			System.arraycopy(registers,0,newRegisters,0,
				registers.length);
			registers = newRegisters;
			registers[name] = new StringRegister(value);
		}
		else
		{
			Register register = registers[name];
			if(register != null)
				register.setValue(value);
			else
				registers[name] = new StringRegister(value);
		}
	}
	/**
	 * Clears (i.e. it's value to null) the specified register.
	 * @param name The register name
	 */
	public static void clearRegister(char name)
	{
		if(name >= registers.length)
			return;
		Register register = registers[name];
		if(name == '$' || name == '%')
			register.setValue("""");
		else
			registers[name] = null;
	}
	/**
	 * Returns an array of all available registers. Some of the elements
	 * of this array might be null.
	 */
	public static Register[] getRegisters()
	{
		return registers;
	}
	/**
	 * A register.
	 */
	public interface Register
	{
		/**
		 * Converts to a string.
		 */
		String toString();
		/**
		 * Sets the register contents.
		 */
		void setValue(String value);
	}
	/**
	 * A clipboard register. Register ""$"" should always be an
	 * instance of this.
	 */
	public static class ClipboardRegister implements Register
	{
		Clipboard clipboard;
		public ClipboardRegister(Clipboard clipboard)
		{
			this.clipboard = clipboard;
		}
		/**
		 * Sets the clipboard contents.
		 */
		public void setValue(String value)
		{
			StringSelection selection = new StringSelection(value);
			clipboard.setContents(selection,null);
		}
		/**
		 * Returns the clipboard contents.
		 */
		public String toString()
		{
			try
			{
				String selection = (String)(clipboard
					.getContents(this).getTransferData(
					DataFlavor.stringFlavor));
				boolean trailingEOL = (selection.endsWith(""\n"")
					|| selection.endsWith(System.getProperty(
					""line.separator"")));
				// Some Java versions return the clipboard
				// contents using the native line separator,
				// so have to convert it here
				BufferedReader in = new BufferedReader(
					new StringReader(selection));
				StringBuffer buf = new StringBuffer();
				String line;
				while((line = in.readLine()) != null)
				{
					buf.append(line);
					buf.append('\n');
				}
				// remove trailing \n
				if(!trailingEOL)
					buf.setLength(buf.length() - 1);
				return buf.toString();
			}
			catch(Exception e)
			{
				Log.log(Log.NOTICE,this,e);
				return null;
			}
		}
	}
	/**
	 * Register that stores a string.
	 */
	public static class StringRegister implements Register
	{
		private String value;
		/**
		 * Creates a new string register.
		 * @param value The contents
		 */
		public StringRegister(String value)
		{
			this.value = value;
		}
		/**
		 * Sets the register contents.
		 */
		public void setValue(String value)
		{
			this.value = value;
		}
		/**
		 * Converts to a string.
		 */
		public String toString()
		{
			return value;
		}
		/**
		 * Called when this register is no longer available. This
		 * implementation does nothing.
		 */
		public void dispose() {}
	}
	// private members
	private static Register[] registers;
	private Registers() {}
	static
	{
		registers = new Register[256];
		registers['$'] = new ClipboardRegister(Toolkit
			.getDefaultToolkit().getSystemClipboard());
		// Check for Java 1.4 method that returns PRIMARY selection
		// on X Windows
		try
		{
			Method method = Toolkit.class.getMethod(
				""getSystemSelection"",new Class[0]);
			Clipboard selection = (Clipboard)method.invoke(
				Toolkit.getDefaultToolkit(),new Object[0]);
			if(selection != null)
			{
				Log.log(Log.DEBUG,Registers.class,
					""Toolkit.getSystemSelection() detected"");
				Log.log(Log.DEBUG,Registers.class,""% register is system selection"");
				registers['%'] = new ClipboardRegister(selection);
			}
			else
			{
				Log.log(Log.DEBUG,Registers.class,
					""Toolkit.getSystemSelection() ""
					+ ""detected, but returns null"");
				Log.log(Log.DEBUG,Registers.class,""% register is jEdit-specific"");
				registers['%'] = new StringRegister("""");
			}
		}
		catch(Exception e)
		{
			Log.log(Log.DEBUG,Registers.class,
				""Toolkit.getSystemSelection() not detected"");
			Log.log(Log.DEBUG,Registers.class,""% register is jEdit-specific"");
			registers['%'] = new StringRegister("""");
		}
	}
}
"
org.gjt.sp.jedit.TextUtilities,"/*
 * TextUtilities.java - Various text functions
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.text.*;
import org.gjt.sp.jedit.syntax.*;
/**
 * Class with several text utility functions.
 * @author Slava Pestov
 * @version $Id: TextUtilities.java,v 1.7 2001/01/25 02:03:37 sp Exp $
 */
public class TextUtilities
{
	/**
	 * Returns the offset of the bracket matching the one at the
	 * specified offset of the buffer, or -1 if the bracket is
	 * unmatched (or if the character is not a bracket).
	 * @param buffer The buffer
	 * @param line The line
	 * @param offset The offset within that line
	 * @exception BadLocationException If an out-of-bounds access
	 * was attempted on the buffer's text
	 * @since jEdit 2.6pre1
	 */
	public static int findMatchingBracket(Buffer buffer, int line, int offset)
		throws BadLocationException
	{
		return findMatchingBracket(buffer,line,offset,0,
			buffer.getDefaultRootElement().getElementCount());
	}
	/**
	 * Returns the offset of the bracket matching the one at the
	 * specified offset of the buffer, or -1 if the bracket is
	 * unmatched (or if the character is not a bracket).
	 * @param buffer The buffer
	 * @param line The line
	 * @param offset The offset within that line
	 * @param startLine The first line to scan. This is used to speed up
	 * on-screen bracket matching because only visible lines need to be
	 * scanned
	 * @param endLine The last line to scan. This is used to speed up
	 * on-screen bracket matching because only visible lines need to be
	 * scanned
	 * @exception BadLocationException If an out-of-bounds access
	 * was attempted on the buffer's text
	 * @since jEdit 2.7pre3
	 */
	public static int findMatchingBracket(Buffer buffer, int line, int offset,
		int startLine, int endLine) throws BadLocationException
	{
		if(buffer.getLength() == 0)
			return -1;
		Element map = buffer.getDefaultRootElement();
		Element lineElement = map.getElement(line);
		Segment lineText = new Segment();
		int lineStart = lineElement.getStartOffset();
		buffer.getText(lineStart,lineElement.getEndOffset() - lineStart - 1,
			lineText);
		char c = lineText.array[lineText.offset + offset];
		char cprime; // c` - corresponding character
		boolean direction; // true = back, false = forward
		switch(c)
		{
		case '(': cprime = ')'; direction = false; break;
		case ')': cprime = '('; direction = true; break;
		case '[': cprime = ']'; direction = false; break;
		case ']': cprime = '['; direction = true; break;
		case '{': cprime = '}'; direction = false; break;
		case '}': cprime = '{'; direction = true; break;
		default: return -1;
		}
		int count;
		// Get the syntax token at 'offset'
		// only tokens with the same type will be checked for
		// the corresponding bracket
		byte idOfBracket = Token.NULL;
		Buffer.LineInfo lineInfo = buffer.markTokens(line);
		Token lineTokens = lineInfo.getFirstToken();
		int tokenListOffset = 0;
		for(;;)
		{
			if(lineTokens.id == Token.END)
				throw new InternalError(""offset > line length"");
			if(tokenListOffset + lineTokens.length > offset)
			{
				idOfBracket = lineTokens.id;
				break;
			}
			else
			{
				tokenListOffset += lineTokens.length;
				lineTokens = lineTokens.next;
			}
		}
		if(direction)
		{
			// scan backwards
			count = 0;
			for(int i = line; i >= startLine; i--)
			{
				// get text
				lineElement = map.getElement(i);
				lineStart = lineElement.getStartOffset();
				int lineLength = lineElement.getEndOffset()
					- lineStart - 1;
				buffer.getText(lineStart,lineLength,lineText);
				int scanStartOffset;
				if(i != line)
				{
					lineTokens = buffer.markTokens(i).getLastToken();
					tokenListOffset = scanStartOffset = lineLength - 1;
				}
				else
				{
 					if(tokenListOffset != lineLength)
 						tokenListOffset += lineTokens.length;
					//lineTokens = lineInfo.lastToken;
					scanStartOffset = offset;
					/*System.err.println(""sso="" + scanStartOffset + "",tlo="" + tokenListOffset);
					Token __ = lineTokens;
					 for(;;)
					{
						if(__ == null)
							break;
						System.err.println(__);
						__ = __.prev;
					} */
				}
				// only check tokens with id 'idOfBracket'
				while(lineTokens != null)
				{
					byte id = lineTokens.id;
					if(id == Token.END)
					{
						lineTokens = lineTokens.prev;
						continue;
					}
					//System.err.println(lineTokens);
					int len = lineTokens.length;
					if(id == idOfBracket)
					{
						for(int j = scanStartOffset; j >= Math.max(0,tokenListOffset - len); j--)
						{
							if(j >= lineText.count)
								System.err.println(""WARNING: "" + j + "" >= "" + lineText.count);
							else if(j < 0)
							{
								System.err.println(""sso="" + scanStartOffset + "", tlo="" + tokenListOffset + "",len="" + len);
								System.err.println(""WARNING: "" + j + "" < 0"");
							}
							char ch = lineText.array[lineText.offset + j];
							//System.err.print(ch);
							if(ch == c)
								count++;
							else if(ch == cprime)
							{
								if(--count == 0)
									return lineStart + j;
							}
						}
						//System.err.println();
					}
					scanStartOffset = tokenListOffset = tokenListOffset - len;
					lineTokens = lineTokens.prev;
				}
			}
		}
		else
		{
			// scan forwards
			count = 0;
			for(int i = line; i < endLine; i++)
			{
				// get text
				lineElement = map.getElement(i);
				lineStart = lineElement.getStartOffset();
				buffer.getText(lineStart,lineElement.getEndOffset()
					- lineStart - 1,lineText);
				int scanStartOffset;
				if(i != line)
				{
					lineTokens = buffer.markTokens(i).getFirstToken();
					tokenListOffset = 0;
					scanStartOffset = 0;
				}
				else
					scanStartOffset = offset + 1;
				// only check tokens with id 'idOfBracket'
				for(;;)
				{
					byte id = lineTokens.id;
					if(id == Token.END)
						break;
					int len = lineTokens.length;
					if(id == idOfBracket)
					{
						for(int j = scanStartOffset; j < tokenListOffset + len; j++)
						{
							char ch = lineText.array[lineText.offset + j];
							if(ch == c)
								count++;
							else if(ch == cprime)
							{
								if(count-- == 0)
									return lineStart + j;
							}
						}
					}
					scanStartOffset = tokenListOffset = tokenListOffset + len;
					lineTokens = lineTokens.next;
				}
			}
		}
		// Nothing found
		return -1;
	}
	/**
	 * Locates the start of the word at the specified position.
	 * @param line The text
	 * @param pos The position
	 * @param noWordSep Characters that are non-alphanumeric, but
	 * should be treated as word characters anyway
	 */
	public static int findWordStart(String line, int pos, String noWordSep)
	{
		char ch = line.charAt(pos);
		if(noWordSep == null)
			noWordSep = """";
		boolean selectNoLetter = (!Character.isLetterOrDigit(ch)
			&& noWordSep.indexOf(ch) == -1);
		int wordStart = 0;
		for(int i = pos; i >= 0; i--)
		{
			ch = line.charAt(i);
			if(selectNoLetter ^ (!Character.isLetterOrDigit(ch) &&
				noWordSep.indexOf(ch) == -1))
			{
				wordStart = i + 1;
				break;
			}
		}
		return wordStart;
	}
	/**
	 * Locates the end of the word at the specified position.
	 * @param line The text
	 * @param pos The position
	 * @param noWordSep Characters that are non-alphanumeric, but
	 * should be treated as word characters anyway
	 */
	public static int findWordEnd(String line, int pos, String noWordSep)
	{
		if(pos != 0)
			pos--;
		char ch = line.charAt(pos);
		if(noWordSep == null)
			noWordSep = """";
		boolean selectNoLetter = (!Character.isLetterOrDigit(ch)
			&& noWordSep.indexOf(ch) == -1);
		int wordEnd = line.length();
		for(int i = pos; i < line.length(); i++)
		{
			ch = line.charAt(i);
			if(selectNoLetter ^ (!Character.isLetterOrDigit(ch) &&
				noWordSep.indexOf(ch) == -1))
			{
				wordEnd = i;
				break;
			}
		}
		return wordEnd;
	}
	/**
	 * Checks if a subregion of a <code>Segment</code> is equal to a
	 * character array.
	 * @param ignoreCase True if case should be ignored, false otherwise
	 * @param text The segment
	 * @param offset The offset into the segment
	 * @param match The character array to match
	 * @since jEdit 2.7pre1
	 */
	public static boolean regionMatches(boolean ignoreCase, Segment text,
					    int offset, char[] match)
	{
		int length = offset + match.length;
		char[] textArray = text.array;
		if(length > text.offset + text.count)
			return false;
		for(int i = offset, j = 0; i < length; i++, j++)
		{
			char c1 = textArray[i];
			char c2 = match[j];
			if(ignoreCase)
			{
				c1 = Character.toUpperCase(c1);
				c2 = Character.toUpperCase(c2);
			}
			if(c1 != c2)
				return false;
		}
		return true;
	}
	/**
	 * Converts consecutive spaces to tabs in the specified string.
	 * @param in The string
	 * @param tabSize The tab size
	 */
	public static String spacesToTabs(String in, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		int width = 0;
		int whitespace = 0;
		for(int i = 0; i < in.length(); i++)
		{
			switch(in.charAt(i))
			{
			case ' ':
				whitespace++;
				width++;
				break;
			case '\t':
				int tab = tabSize - (width % tabSize);
				width += tab;
				whitespace += tab;
				break;
			case '\n':
				if(whitespace != 0)
				{
					buf.append(MiscUtilities
						.createWhiteSpace(whitespace,tabSize));
				}
				whitespace = 0;
				width = 0;
				buf.append('\n');
				break;
			default:
				if(whitespace != 0)
				{
					buf.append(MiscUtilities
						.createWhiteSpace(whitespace,tabSize));
					whitespace = 0;
				}
				buf.append(in.charAt(i));
				width++;
				break;
			}
		}
		if(whitespace != 0)
		{
			buf.append(MiscUtilities.createWhiteSpace(whitespace,tabSize));
		}
                return buf.toString();
	}
	/**
	 * Converts tabs to consecutive spaces in the specified string.
	 * @param in The string
	 * @param tabSize The tab size
	 */
	public static String tabsToSpaces(String in, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		int width = 0;
		for(int i = 0; i < in.length(); i++)
		{
			switch(in.charAt(i))
			{
			case '\t':
				int count = tabSize - (width % tabSize);
				width += count;
				while(--count >= 0)
					buf.append(' ');
				break;
			case '\n':
				width = 0;
				buf.append(in.charAt(i));
				break;
			default:
				width++;
				buf.append(in.charAt(i));
				break;
                        }
                }
                return buf.toString();
	}
	/**
	 * Formats the specified text by merging and breaking lines to the
	 * specified width.
	 * @param text The text
	 * @param maxLineLen The maximum line length
	 */
	public static String format(String text, int maxLineLength)
	{
		StringBuffer buf = new StringBuffer();
		StringBuffer word = new StringBuffer();
		int lineLength = 0;
		boolean newline = true;
		boolean space = false;
		char[] chars = text.toCharArray();
		for(int i = 0; i < chars.length; i++)
		{
			char c = chars[i];
			switch(c)
			{
			case '\n':
				if(i == 0 || chars.length - i <= 2)
				{
					if(lineLength + word.length() >= maxLineLength)
						buf.append('\n');
					else if(space && word.length() != 0)
						buf.append(' ');
					buf.append(word);
					word.setLength(0);
					buf.append('\n');
					newline = true;
					space = false;
					break;
				}
				else if(newline)
				{
					if(lineLength + word.length() >= maxLineLength)
						buf.append('\n');
					else if(space && word.length() != 0)
						buf.append(' ');
					buf.append(word);
					word.setLength(0);
					buf.append(""\n\n"");
					newline = space = false;
					lineLength = 0;
					break;
				}
				else
					newline = true;
			case ' ':
				if(lineLength + word.length() >= maxLineLength)
				{
					buf.append('\n');
					lineLength = 0;
					newline = true;
				}
				else if(space && lineLength != 0 && word.length() != 0)
				{
					buf.append(' ');
					lineLength++;
					space = false;
				}
				else
					space = true;
				buf.append(word);
				lineLength += word.length();
				word.setLength(0);
				break;
			default:
				newline = false;
				// without this test, we would have spaces
				// at the start of lines
				if(lineLength != 0)
					space = true;
				word.append(c);
				break;
			}
		}
		if(lineLength + word.length() >= maxLineLength)
			buf.append('\n');
		else if(space && word.length() != 0)
			buf.append(' ');
		buf.append(word);
		return buf.toString();
	}
}
/*
 * ChangeLog:
 * $Log: TextUtilities.java,v $
 * Revision 1.7  2001/01/25 02:03:37  sp
 * Started folding, messed up some code, added a few bugs
 *
 * Revision 1.6  2000/11/23 08:34:10  sp
 * Search and replace UI improvements
 *
 * Revision 1.5  2000/11/13 11:19:26  sp
 * Search bar reintroduced, more BeanShell stuff
 *
 * Revision 1.4  2000/11/07 10:08:31  sp
 * Options dialog improvements, documentation changes, bug fixes
 *
 * Revision 1.13  2000/09/06 04:39:47  sp
 * bug fixes
 *
 * Revision 1.12  2000/09/04 06:34:54  sp
 * bug fixes
 *
 * Revision 1.11  2000/09/03 03:16:53  sp
 * Search bar integrated with command line, enhancements throughout
 *
 * Revision 1.10  2000/07/26 07:48:45  sp
 * stuff
 *
 * Revision 1.9  2000/07/22 03:27:04  sp
 * threaded I/O improved, autosave rewrite started
 *
 * Revision 1.8  2000/07/15 06:56:29  sp
 * bracket matching debugged
 *
 * Revision 1.7  2000/07/14 06:00:45  sp
 * bracket matching now takes syntax info into account
 *
 * Revision 1.6  2000/01/28 00:20:58  sp
 * Lots of stuff
 *
 * Revision 1.5  1999/12/19 11:14:29  sp
 * Static abbrev expansion started
 *
 * Revision 1.4  1999/12/13 03:40:30  sp
 * Bug fixes, syntax is now mostly GPL'd
 *
 * Revision 1.3  1999/11/21 03:40:18  sp
 * Parts of EditBus not used by core moved to EditBus.jar
 *
 * Revision 1.2  1999/07/16 23:45:49  sp
 * 1.7pre6 BugFree version
 *
 * Revision 1.1  1999/06/29 09:03:18  sp
 * oops, forgot to add TextUtilities.java
 *
 */
"
org.gjt.sp.jedit.View,"/*
 * View.java - jEdit view
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.search.SearchBar;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
/**
 * A window that edits buffers. There is no public constructor in the
 * View class. Views are created and destroyed by the <code>jEdit</code>
 * class.
 *
 * @author Slava Pestov
 * @version $Id: View.java,v 1.240 2001/08/18 08:37:02 sp Exp $
 */
public class View extends JFrame implements EBComponent
{
	/**
	 * Returns the dockable window manager associated with this view.
	 * @since jEdit 2.6pre3
	 */
	public DockableWindowManager getDockableWindowManager()
	{
		return dockableWindowManager;
	}
	/**
	 * Quick search.
	 * @since jEdit 2.7pre2
	 */
	public void quickIncrementalSearch()
	{
		if(searchBar == null)
		{
			getToolkit().beep();
			return;
		}
		String text = getTextArea().getSelectedText();
		if(text != null && text.indexOf('\n') != -1)
			text = null;
		searchBar.setHyperSearch(false);
		searchBar.getField().setText(text);
		searchBar.getField().selectAll();
		searchBar.getField().requestFocus();
	}
	/**
	 * Quick HyperSearch.
	 * @since jEdit 2.7pre2
	 */
	public void quickHyperSearch()
	{
		if(searchBar == null)
		{
			getToolkit().beep();
			return;
		}
		String text = getTextArea().getSelectedText();
		if(text != null && text.indexOf('\n') != -1)
			text = null;
		searchBar.setHyperSearch(true);
		searchBar.getField().setText(text);
		searchBar.getField().selectAll();
		searchBar.getField().requestFocus();
	}
	/**
	 * Returns the search bar.
	 * @since jEdit 2.4pre4
	 */
	public final SearchBar getSearchBar()
	{
		return searchBar;
	}
	/**
	 * Returns the listener that will handle all key events in this
	 * view, if any.
	 */
	public KeyListener getKeyEventInterceptor()
	{
		return keyEventInterceptor;
	}
	/**
	 * Sets the listener that will handle all key events in this
	 * view. For example, the complete word command uses this so
	 * that all key events are passed to the word list popup while
	 * it is visible.
	 * @param comp The component
	 */
	public void setKeyEventInterceptor(KeyListener listener)
	{
		this.keyEventInterceptor = listener;
	}
	/**
	 * Returns the input handler.
	 */
	public InputHandler getInputHandler()
	{
		return inputHandler;
	}
	/**
	 * Sets the input handler.
	 * @param inputHandler The new input handler
	 */
	public void setInputHandler(InputHandler inputHandler)
	{
		this.inputHandler = inputHandler;
	}
	/**
	 * Returns the macro recorder.
	 */
	public Macros.Recorder getMacroRecorder()
	{
		return recorder;
	}
	/**
	 * Sets the macro recorder.
	 * @param recorder The macro recorder
	 */
	public void setMacroRecorder(Macros.Recorder recorder)
	{
		this.recorder = recorder;
	}
	/**
	 * Returns the status bar.
	 * @since jEdit 3.2pre2
	 */
	public StatusBar getStatus()
	{
		return status;
	}
	/**
	 * Splits the view horizontally.
	 * @since jEdit 2.7pre2
	 */
	public void splitHorizontally()
	{
		split(JSplitPane.VERTICAL_SPLIT);
	}
	/**
	 * Splits the view vertically.
	 * @since jEdit 2.7pre2
	 */
	public void splitVertically()
	{
		split(JSplitPane.HORIZONTAL_SPLIT);
	}
	/**
	 * Splits the view.
	 * @since jEdit 2.3pre2
	 */
	public void split(int orientation)
	{
		editPane.saveCaretInfo();
		EditPane oldEditPane = editPane;
		setEditPane(createEditPane(oldEditPane.getBuffer()));
		editPane.loadCaretInfo();
		JComponent oldParent = (JComponent)oldEditPane.getParent();
		if(oldParent instanceof JSplitPane)
		{
			JSplitPane oldSplitPane = (JSplitPane)oldParent;
			int dividerPos = oldSplitPane.getDividerLocation();
			Component left = oldSplitPane.getLeftComponent();
			final JSplitPane newSplitPane = new JSplitPane(orientation,
				oldEditPane,editPane);
			newSplitPane.setBorder(null);
			if(left == oldEditPane)
				oldSplitPane.setLeftComponent(newSplitPane);
			else
				oldSplitPane.setRightComponent(newSplitPane);
			oldSplitPane.setDividerLocation(dividerPos);
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					newSplitPane.setDividerLocation(0.5);
					editPane.focusOnTextArea();
				}
			});
		}
		else
		{
			JSplitPane newSplitPane = splitPane = new JSplitPane(orientation,
				oldEditPane,editPane);
			newSplitPane.setBorder(null);
			oldParent.add(splitPane);
			oldParent.revalidate();
			Dimension size;
			if(oldParent instanceof JSplitPane)
				size = oldParent.getSize();
			else
				size = oldEditPane.getSize();
			newSplitPane.setDividerLocation(((orientation
				== JSplitPane.VERTICAL_SPLIT) ? size.height
				: size.width) / 2);
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					editPane.focusOnTextArea();
				}
			});
		}
	}
	/**
	 * Unsplits the view.
	 * @since jEdit 2.3pre2
	 */
	public void unsplit()
	{
		if(splitPane != null)
		{
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane _editPane = editPanes[i];
				if(editPane != _editPane)
					_editPane.close();
			}
			JComponent parent = (JComponent)splitPane.getParent();
			parent.remove(splitPane);
			parent.add(editPane);
			parent.revalidate();
			splitPane = null;
			updateTitle();
		}
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				editPane.focusOnTextArea();
			}
		});
	}
	/**
	 * Moves keyboard focus to the next text area.
	 * @since jEdit 2.7pre4
	 */
	public void nextTextArea()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPane == editPanes[i])
			{
				if(i == editPanes.length - 1)
					editPanes[0].focusOnTextArea();
				else
					editPanes[i+1].focusOnTextArea();
				break;
			}
		}
	}
	/**
	 * Moves keyboard focus to the previous text area.
	 * @since jEdit 2.7pre4
	 */
	public void prevTextArea()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPane == editPanes[i])
			{
				if(i == 0)
					editPanes[editPanes.length - 1].focusOnTextArea();
				else
					editPanes[i-1].focusOnTextArea();
				break;
			}
		}
	}
	/**
	 * Returns the top-level split pane, if any.
	 * @since jEdit 2.3pre2
	 */
	public JSplitPane getSplitPane()
	{
		return splitPane;
	}
	/**
	 * Returns the current edit pane's buffer.
	 */
	public Buffer getBuffer()
	{
		return editPane.getBuffer();
	}
	/**
	 * Sets the current edit pane's buffer.
	 */
	public void setBuffer(Buffer buffer)
	{
		editPane.setBuffer(buffer);
	}
	/**
	 * Returns the current edit pane's text area.
	 */
	public JEditTextArea getTextArea()
	{
		return editPane.getTextArea();
	}
	/**
	 * Returns the current edit pane.
	 * @since jEdit 2.5pre2
	 */
	public EditPane getEditPane()
	{
		return editPane;
	}
	/**
	 * Returns all edit panes.
	 * @since jEdit 2.5pre2
	 */
	public EditPane[] getEditPanes()
	{
		if(splitPane == null)
		{
			EditPane[] ep = { editPane };
			return ep;
		}
		else
		{
			Vector vec = new Vector();
			getEditPanes(vec,splitPane);
			EditPane[] ep = new EditPane[vec.size()];
			vec.copyInto(ep);
			return ep;
		}
	}
	/**
	 * Returns a string that can be passed to the view constructor to
	 * recreate the current split configuration in a new view.
	 * @since jEdit 3.2pre2
	 */
	public String getSplitConfig()
	{
		// this code isn't finished yet
		StringBuffer splitConfig = new StringBuffer();
		//if(splitPane != null)
		//	getSplitConfig(splitPane,splitConfig);
		//else
			splitConfig.append(getBuffer().getPath());
		return splitConfig.toString();
	}
	/**
	 * Updates the borders of all gutters in this view to reflect the
	 * currently focused text area.
	 * @since jEdit 2.6final
	 */
	public void updateGutterBorders()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
			editPanes[i].getTextArea().getGutter().updateBorder();
	}
	/**
	 * Adds a tool bar to this view.
	 * @param toolBar The tool bar
	 */
	public void addToolBar(Component toolBar)
	{
		toolBars.add(toolBar);
		getRootPane().revalidate();
	}
	/**
	 * Removes a tool bar from this view.
	 * @param toolBar The tool bar
	 */
	public void removeToolBar(Component toolBar)
	{
		toolBars.remove(toolBar);
		getRootPane().revalidate();
	}
	/**
	 * Returns true if this view has been closed with
	 * <code>jEdit.closeView()</code>.
	 */
	public boolean isClosed()
	{
		return closed;
	}
	/**
	 * Shows the wait cursor and glass pane.
	 */
	public synchronized void showWaitCursor()
	{
		if(waitCount++ == 0)
		{
			// still needed even though glass pane
			// has a wait cursor
			Cursor cursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);
			setCursor(cursor);
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane editPane = editPanes[i];
				editPane.getTextArea().getPainter()
					.setCursor(cursor);
			}
		}
	}
	/**
	 * Hides the wait cursor and glass pane.
	 */
	public synchronized void hideWaitCursor()
	{
		if(waitCount > 0)
			waitCount--;
		if(waitCount == 0)
		{
			// still needed even though glass pane
			// has a wait cursor
			Cursor cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
			setCursor(cursor);
			cursor = Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR);
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane editPane = editPanes[i];
				editPane.getTextArea().getPainter()
					.setCursor(cursor);
			}
		}
	}
	/**
	 * Returns if synchronized scrolling is enabled.
	 * @since jEdit 2.7pre1
	 */
	public boolean isSynchroScrollEnabled()
	{
		return synchroScroll;
	}
	/**
	 * Toggles synchronized scrolling.
	 * @since jEdit 2.7pre2
	 */
	public void toggleSynchroScrollEnabled()
	{
		setSynchroScrollEnabled(!synchroScroll);
	}
	/**
	 * Sets synchronized scrolling.
	 * @since jEdit 2.7pre1
	 */
	public void setSynchroScrollEnabled(boolean synchroScroll)
	{
		this.synchroScroll = synchroScroll;
		JEditTextArea textArea = getTextArea();
		int firstLine = textArea.getFirstLine();
		int horizontalOffset = textArea.getHorizontalOffset();
		synchroScrollVertical(textArea,firstLine);
		synchroScrollHorizontal(textArea,horizontalOffset);
	}
	/**
	 * Sets the first line of all text areas.
	 * @param textArea The text area that is propagating this change
	 * @param firstLine The first line
	 * @since jEdit 2.7pre1
	 */
	public void synchroScrollVertical(JEditTextArea textArea, int firstLine)
	{
		if(!synchroScroll)
			return;
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPanes[i].getTextArea() != textArea)
				editPanes[i].getTextArea()._setFirstLine(firstLine);
		}
	}
	/**
	 * Sets the horizontal offset of all text areas.
	 * @param textArea The text area that is propagating this change
	 * @param horizontalOffset The horizontal offset
	 * @since jEdit 2.7pre1
	 */
	public void synchroScrollHorizontal(JEditTextArea textArea, int horizontalOffset)
	{
		if(!synchroScroll)
			return;
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPanes[i].getTextArea() != textArea)
				editPanes[i].getTextArea()._setHorizontalOffset(horizontalOffset);
		}
	}
	/**
	 * Returns the next view in the list.
	 */
	public View getNext()
	{
		return next;
	}
	/**
	 * Returns the previous view in the list.
	 */
	public View getPrev()
	{
		return prev;
	}
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof SearchSettingsChanged)
		{
			if(searchBar != null)
				searchBar.update();
		}
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
		else if(msg instanceof EditPaneUpdate)
			handleEditPaneUpdate((EditPaneUpdate)msg);
	}
	/**
	 * Forwards key events directly to the input handler.
	 * This is slightly faster than using a KeyListener
	 * because some Swing overhead is avoided.
	 */
	public void processKeyEvent(KeyEvent evt)
	{
		if(isClosed())
			return;
		// JTextComponents don't consume events...
		if(getFocusOwner() instanceof JTextComponent)
		{
			// fix for the bug where key events in JTextComponents
			// inside views are also handled by the input handler
			if(evt.getID() == KeyEvent.KEY_PRESSED)
			{
				switch(evt.getKeyCode())
				{
				case KeyEvent.VK_BACK_SPACE:
				case KeyEvent.VK_TAB:
				case KeyEvent.VK_ENTER:
					return;
				}
			}
			Keymap keymap = ((JTextComponent)getFocusOwner())
				.getKeymap();
			if(keymap.getAction(KeyStroke.getKeyStrokeForEvent(evt)) != null)
				return;
		}
		if(evt.isConsumed())
			return;
		evt = KeyEventWorkaround.processKeyEvent(evt);
		if(evt == null)
			return;
		switch(evt.getID())
		{
		case KeyEvent.KEY_TYPED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyTyped(evt);
			else if(inputHandler.isPrefixActive())
				inputHandler.keyTyped(evt);
			break;
		case KeyEvent.KEY_PRESSED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyPressed(evt);
			else
				inputHandler.keyPressed(evt);
			break;
		case KeyEvent.KEY_RELEASED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyReleased(evt);
			else
				inputHandler.keyReleased(evt);
			break;
		}
		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	}
	// package-private members
	View prev;
	View next;
	View(Buffer buffer, String splitConfig)
	{
		setIconImage(GUIUtilities.getEditorIcon());
		dockableWindowManager = new DockableWindowManager(this);
		Component comp = restoreSplitConfig(buffer,splitConfig);
		dockableWindowManager.add(comp);
		EditBus.addToBus(this);
		setJMenuBar(GUIUtilities.loadMenuBar(""view.mbar""));
		toolBars = new Box(BoxLayout.Y_AXIS);
		inputHandler = new DefaultInputHandler(this,(DefaultInputHandler)
			jEdit.getInputHandler());
		propertiesChanged();
		getContentPane().add(BorderLayout.NORTH,toolBars);
		getContentPane().add(BorderLayout.CENTER,dockableWindowManager);
		getContentPane().add(BorderLayout.SOUTH,status = new StatusBar(this));
		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowHandler());
		dockableWindowManager.init();
	}
	void close()
	{
		closed = true;
		// save dockable window geometry, and close 'em
		dockableWindowManager.close();
		GUIUtilities.saveGeometry(this,""view"");
		EditBus.removeFromBus(this);
		dispose();
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
			editPanes[i].close();
		// null some variables so that retaining references
		// to closed views won't hurt as much.
		toolBars = null;
		toolBar = null;
		searchBar = null;
		splitPane = null;
		inputHandler = null;
		recorder = null;
		setContentPane(new JPanel());
	}
	/**
	 * Updates the title bar.
	 */
	void updateTitle()
	{
		Vector buffers = new Vector();
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			Buffer buffer = editPanes[i].getBuffer();
			if(buffers.indexOf(buffer) == -1)
				buffers.addElement(buffer);
		}
		StringBuffer title = new StringBuffer(jEdit.getProperty(""view.title""));
		for(int i = 0; i < buffers.size(); i++)
		{
			if(i != 0)
				title.append("", "");
			Buffer buffer = (Buffer)buffers.elementAt(i);
			title.append((showFullPath && !buffer.isNewFile())
				? buffer.getPath() : buffer.getName());
		}
		setTitle(title.toString());
	}
	// private members
	private boolean closed;
	private DockableWindowManager dockableWindowManager;
	private Box toolBars;
	private JToolBar toolBar;
	private SearchBar searchBar;
	private boolean synchroScroll;
	private EditPane editPane;
	private JSplitPane splitPane;
	private StatusBar status;
	private KeyListener keyEventInterceptor;
	private InputHandler inputHandler;
	private Macros.Recorder recorder;
	private int waitCount;
	private boolean showFullPath;
	private void getEditPanes(Vector vec, Component comp)
	{
		if(comp instanceof EditPane)
			vec.addElement(comp);
		else if(comp instanceof JSplitPane)
		{
			JSplitPane split = (JSplitPane)comp;
			getEditPanes(vec,split.getLeftComponent());
			getEditPanes(vec,split.getRightComponent());
		}
	}
	/*
	 * The split config is recorded in a simple RPN ""language"":
	 * ""vertical"" pops the two topmost elements off the stack, creates a
	 * vertical split
	 * ""horizontal"" pops the two topmost elements off the stack, creates a
	 * horizontal split
	 * A path name creates an edit pane editing that buffer
	 */
	private void getSplitConfig(JSplitPane splitPane,
		StringBuffer splitConfig)
	{
		Component left = splitPane.getLeftComponent();
		if(left instanceof JSplitPane)
			getSplitConfig((JSplitPane)left,splitConfig);
		else
		{
			splitConfig.append('\t');
			splitConfig.append(((EditPane)left).getBuffer().getPath());
		}
		Component right = splitPane.getRightComponent();
		if(right instanceof JSplitPane)
			getSplitConfig((JSplitPane)right,splitConfig);
		else
		{
			splitConfig.append('\t');
			splitConfig.append(((EditPane)right).getBuffer().getPath());
		}
		splitConfig.append(splitPane.getOrientation()
			== JSplitPane.VERTICAL_SPLIT ? ""\tvertical"" : ""\thorizontal"");
	}
	private Component restoreSplitConfig(Buffer buffer, String splitConfig)
	{
		if(buffer != null)
			return (editPane = createEditPane(buffer));
		else if(splitConfig == null)
			return (editPane = createEditPane(jEdit.getFirstBuffer()));
		Stack stack = new Stack();
		StringTokenizer st = new StringTokenizer(splitConfig,""\t"");
		while(st.hasMoreTokens())
		{
			String token = st.nextToken();
			if(token.equals(""vertical""))
			{
				stack.push(splitPane = new JSplitPane(
					JSplitPane.VERTICAL_SPLIT,
					(Component)stack.pop(),
					(Component)stack.pop()));
				splitPane.setBorder(null);
				splitPane.setDividerLocation(0.5);
			}
			else if(token.equals(""horizontal""))
			{
				stack.push(splitPane = new JSplitPane(
					JSplitPane.HORIZONTAL_SPLIT,
					(Component)stack.pop(),
					(Component)stack.pop()));
				splitPane.setBorder(null);
				splitPane.setDividerLocation(0.5);
			}
			else
			{
				buffer = jEdit.getBuffer(token);
				if(buffer == null)
					buffer = jEdit.getFirstBuffer();
				stack.push(editPane = createEditPane(buffer));
			}
		}
		return (Component)stack.peek();
	}
	/**
	 * Reloads various settings from the properties.
	 */
	private void propertiesChanged()
	{
		loadToolBars();
		showFullPath = jEdit.getBooleanProperty(""view.showFullPath"");
		updateTitle();
		dockableWindowManager.propertiesChanged();
		SwingUtilities.updateComponentTreeUI(getRootPane());
	}
	private void loadToolBars()
	{
		if(jEdit.getBooleanProperty(""view.showToolbar""))
		{
			if(toolBar != null)
				toolBars.remove(toolBar);
			toolBar = GUIUtilities.loadToolBar(""view.toolbar"");
			toolBar.add(Box.createGlue());
			toolBars.add(toolBar,0);
			getRootPane().revalidate();
		}
		else if(toolBar != null)
		{
			removeToolBar(toolBar);
			toolBar = null;
		}
		if(jEdit.getBooleanProperty(""view.showSearchbar""))
		{
			if(searchBar == null)
			{
				searchBar = new SearchBar(this);
				addToolBar(searchBar);
			}
		}
		else if(searchBar != null)
		{
			removeToolBar(searchBar);
			searchBar = null;
		}
	}
	private EditPane createEditPane(Buffer buffer)
	{
		EditPane editPane = new EditPane(this,buffer);
		JEditTextArea textArea = editPane.getTextArea();
		textArea.addFocusListener(new FocusHandler());
		textArea.addCaretListener(new CaretHandler());
		textArea.addScrollListener(new ScrollHandler());
		EditBus.send(new EditPaneUpdate(editPane,EditPaneUpdate.CREATED));
		return editPane;
	}
	private void setEditPane(EditPane editPane)
	{
		this.editPane = editPane;
		status.repaintCaretStatus();
		status.updateBufferStatus();
		status.updateMiscStatus();
	}
	private void handleBufferUpdate(BufferUpdate msg)
	{
		Buffer buffer = msg.getBuffer();
		if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED)
		{
			if(!buffer.isDirty())
			{
				// have to update title after each save
				// in case it was a 'save as'
				EditPane[] editPanes = getEditPanes();
				for(int i = 0; i < editPanes.length; i++)
				{
					if(editPanes[i].getBuffer() == buffer)
					{
						updateTitle();
						break;
					}
				}
			}
		}
	}
	private void handleEditPaneUpdate(EditPaneUpdate msg)
	{
		if(msg.getEditPane().getView() == this
			&& msg.getWhat() == EditPaneUpdate.BUFFER_CHANGED)
		{
			status.repaintCaretStatus();
			status.updateBufferStatus();
			status.updateMiscStatus();
			status.updateFoldStatus();
		}
	}
	class CaretHandler implements CaretListener
	{
		public void caretUpdate(CaretEvent evt)
		{
			status.repaintCaretStatus();
			status.updateMiscStatus();
		}
	}
	class FocusHandler extends FocusAdapter
	{
		public void focusGained(FocusEvent evt)
		{
			// walk up hierarchy, looking for an EditPane
			Component comp = (Component)evt.getSource();
			while(!(comp instanceof EditPane))
			{
				if(comp == null)
					return;
				comp = comp.getParent();
			}
			setEditPane((EditPane)comp);
		}
	}
	class ScrollHandler implements ScrollListener
	{
		public void scrolledVertically(JEditTextArea textArea)
		{
			if(getTextArea() == textArea)
				status.repaintCaretStatus();
		}
		public void scrolledHorizontally(JEditTextArea textArea) {}
	}
	class WindowHandler extends WindowAdapter
	{
		boolean gotFocus;
		public void windowActivated(WindowEvent evt)
		{
			if(!gotFocus)
			{
				editPane.focusOnTextArea();
				gotFocus = true;
			}
			final Vector buffers = new Vector();
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				Buffer buffer = ((EditPane)editPanes[i])
					.getBuffer();
				if(buffers.contains(buffer))
					continue;
				else
					buffers.addElement(buffer);
			}
			// People have reported hangs with JDK 1.4; might be
			// caused by modal dialogs being displayed from
			// windowActivated()
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					for(int i = 0; i < buffers.size(); i++)
					{
						((Buffer)buffers.elementAt(i))
							.checkModTime(View.this);
					}
				}
			});
		}
		public void windowClosing(WindowEvent evt)
		{
			jEdit.closeView(View.this);
		}
	}
}
"
org.gjt.sp.jedit.browser.BrowserIORequest,"/*
 * BrowserIORequest.java - VFS browser I/O request
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.util.WorkRequest;
import org.gjt.sp.util.WorkThread;
/**
 * A browser I/O request.
 * @author Slava Pestov
 * @version $Id: BrowserIORequest.java,v 1.8 2001/06/24 10:12:14 sp Exp $
 */
public class BrowserIORequest extends WorkRequest
{
	/**
	 * Directory listing I/O request.
	 */
	public static final int LIST_DIRECTORY = 0;
	/**
	 * Delete file I/O request.
	 */
	public static final int DELETE = 1;
	/**
	 * Rename file I/O request.
	 */
	public static final int RENAME = 2;
	/**
	 * Make directory I/O request.
	 */
	public static final int MKDIR = 3;
	/**
	 * Creates a new browser I/O request.
	 * @param type The request type
	 * @param browser The VFS browser instance
	 * @param path1 The first path name to operate on
	 * @param path2 The second path name to operate on
	 */
	public BrowserIORequest(int type, VFSBrowser browser,
		Object session, VFS vfs, String path1, String path2)
	{
		this.type = type;
		this.browser = browser;
		this.session = session;
		this.vfs = vfs;
		this.path1 = path1;
		this.path2 = path2;
	}
	public void run()
	{
		switch(type)
		{
		case LIST_DIRECTORY:
			listDirectory();
			break;
		case DELETE:
			delete();
			break;
		case RENAME:
			rename();
			break;
		case MKDIR:
			mkdir();
			break;
		}
		browser.endRequest();
	}
	public String toString()
	{
		String typeString;
		switch(type)
		{
		case LIST_DIRECTORY:
			typeString = ""LIST_DIRECTORY"";
			break;
		case DELETE:
			typeString = ""DELETE"";
			break;
		case RENAME:
			typeString = ""RENAME"";
			break;
		case MKDIR:
			typeString = ""MKDIR"";
			break;
		default:
			typeString = ""UNKNOWN!!!"";
			break;
		}
		return getClass().getName() + ""[type="" + typeString
			+ "",vfs="" + vfs + "",path1="" + path1
			+ "",path2="" + path2 + ""]"";
	}
	// private members
	private int type;
	private VFSBrowser browser;
	private Object session;
	private VFS vfs;
	private String path1;
	private String path2;
	private void listDirectory()
	{
		VFS.DirectoryEntry[] directory = null;
		String[] args = { path1 };
		setStatus(jEdit.getProperty(""vfs.status.listing-directory"",args));
		try
		{
			setAbortable(true);
			directory = vfs._listDirectory(session,path1,browser);
		}
		catch(IOException io)
		{
			setAbortable(false);
			String[] pp = { path1, io.toString() };
			VFSManager.error(browser,""directory-error"",pp);
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				String[] pp = { path1, io.toString() };
				VFSManager.error(browser,""directory-error"",pp);
			}
		}
		setAbortable(false);
		browser.directoryLoaded(directory);
	}
	private void delete()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1 };
			setStatus(jEdit.getProperty(""vfs.status.deleting"",args));
			try
			{
				if(!vfs._delete(session,path1,browser))
					VFSManager.error(browser,""vfs.browser.delete-error"",args);
			}
			catch(IOException io)
			{
				String[] pp = { path1, io.toString() };
				VFSManager.error(browser,""directory-error"",pp);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				String[] pp = { path1, io.toString() };
				VFSManager.error(browser,""directory-error"",pp);
			}
		}
	}
	private void rename()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1, path2 };
			setStatus(jEdit.getProperty(""vfs.status.renaming"",args));
			try
			{
				VFS.DirectoryEntry file = vfs._getDirectoryEntry(
					session,path2,browser);
				if(file != null)
					VFSManager.error(browser,""vfs.browser.rename-exists"",
						new String[] { path2 });
				else
				{
					if(!vfs._rename(session,path1,path2,browser))
						VFSManager.error(browser,""vfs.browser.rename-error"",
							new String[] { path1 });
				}
			}
			catch(IOException io)
			{
				String[] pp = { path1, io.toString() };
				VFSManager.error(browser,""directory-error"",pp);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				String[] pp = { path1, io.toString() };
				VFSManager.error(browser,""directory-error"",pp);
			}
		}
	}
	private void mkdir()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1 };
			setStatus(jEdit.getProperty(""vfs.status.mkdir"",args));
			try
			{
				if(!vfs._mkdir(session,path1,browser))
					VFSManager.error(browser,""vfs.browser.mkdir-error"",args);
			}
			catch(IOException io)
			{
				args[0] = io.toString();
				VFSManager.error(browser,""ioerror"",args);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				String[] args = { io.toString() };
				VFSManager.error(browser,""ioerror"",args);
			}
		}
	}
}
"
org.gjt.sp.jedit.browser.BrowserListener,"/*
 * BrowserListener.java - VFS browser listener
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
import java.util.EventListener;
import org.gjt.sp.jedit.io.VFS;
/**
 * A browser event listener.
 * @author Slava Pestov
 * @version $Id: BrowserListener.java,v 1.1 2000/07/30 09:04:19 sp Exp $
 */
public interface BrowserListener extends EventListener
{
	/**
	 * The user has selected a set of files.
	 * @param browser The VFS browser
	 * @param files The selected files
	 */
	void filesSelected(VFSBrowser browser, VFS.DirectoryEntry[] files);
	/**
	 * The user has double-clicked a set of files.
	 * @param browser The VFS browser
	 * @param files The selected files
	 */
	void filesActivated(VFSBrowser browser, VFS.DirectoryEntry[] files);
}
/*
 * Change Log:
 * $Log: BrowserListener.java,v $
 * Revision 1.1  2000/07/30 09:04:19  sp
 * More VFS browser hacking
 *
 */
"
org.gjt.sp.jedit.browser.BrowserPopupMenu,"/*
 * BrowserPopupMenu.java - provides popup actions for rename, del, etc.
 * Copyright (C) 1999 Jason Ginchereau
 * Portions copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA	02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.event.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.search.*;
import org.gjt.sp.jedit.*;
/**
 * @version $Id: BrowserPopupMenu.java,v 1.17 2001/08/20 06:35:02 sp Exp $
 * @author Slava Pestov and Jason Ginchereau
 */
public class BrowserPopupMenu extends JPopupMenu
{
	public BrowserPopupMenu(VFSBrowser browser, VFS.DirectoryEntry file)
	{
		this.browser = browser;
		if(file != null)
		{
			this.file = file;
			this.vfs = VFSManager.getVFSForPath(file.path);
			boolean delete = (vfs.getCapabilities() & VFS.DELETE_CAP) != 0;
			boolean rename = (vfs.getCapabilities() & VFS.RENAME_CAP) != 0;
			if(jEdit.getBuffer(file.path) != null)
			{
				if(browser.getMode() == VFSBrowser.BROWSER)
				{
					add(createMenuItem(""open""));
					add(createMenuItem(""insert""));
					add(createMenuItem(""close""));
				}
				else
					add(createMenuItem(""choose""));
			}
			else
			{
				if(file.type == VFS.DirectoryEntry.DIRECTORY
					|| file.type == VFS.DirectoryEntry.FILESYSTEM)
				{
					add(createMenuItem(""browse""));
				}
				else if(browser.getMode() != VFSBrowser.BROWSER)
				{
					add(createMenuItem(""choose""));
				}
				// else if in browser mode
				else
				{
					add(createMenuItem(""open""));
					add(createOpenEncodingMenu());
					add(createMenuItem(""insert""));
				}
				if(rename)
					add(createMenuItem(""rename""));
				if(delete)
					add(createMenuItem(""delete""));
			}
			addSeparator();
		}
		else
			vfs = VFSManager.getVFSForPath(browser.getDirectory());
		JCheckBoxMenuItem showHiddenFiles = new JCheckBoxMenuItem(
			jEdit.getProperty(""vfs.browser.menu.show-hidden-files.label""));
		showHiddenFiles.setActionCommand(""show-hidden-files"");
		showHiddenFiles.setSelected(browser.getShowHiddenFiles());
		showHiddenFiles.addActionListener(new ActionHandler());
		add(showHiddenFiles);
		addSeparator();
		add(createMenuItem(""new-file""));
		add(createMenuItem(""new-directory""));
		addSeparator();
		// note that we don't display the search in directory command
		// in open and save dialog boxes
		if(browser.getMode() == VFSBrowser.BROWSER
			&& vfs instanceof FileVFS)
		{
			add(createMenuItem(""search-in-directory""));
			addSeparator();
		}
		add(createMenuItem(""add-to-favorites""));
		add(createMenuItem(""go-to-favorites""));
		// put them in a vector for sorting
		Vector vec = new Vector();
		Enumeration enum = VFSManager.getFilesystems();
		while(enum.hasMoreElements())
		{
			VFS vfs = (VFS)enum.nextElement();
			if((vfs.getCapabilities() & VFS.BROWSE_CAP) == 0)
				continue;
			JMenuItem menuItem = new JMenuItem(jEdit.getProperty(
				""vfs."" + vfs.getName() + "".label""));
			menuItem.setActionCommand(""vfs."" + vfs.getName());
			menuItem.addActionListener(new ActionHandler());
			vec.addElement(menuItem);
		}
		if(vec.size() != 0)
		{
			addSeparator();
			MiscUtilities.quicksort(vec,new MiscUtilities.MenuItemCompare());
			for(int i = 0; i < vec.size(); i++)
				add((JMenuItem)vec.elementAt(i));
		}
	}
	// private members
	private VFSBrowser browser;
	private VFS.DirectoryEntry file;
	private VFS vfs;
	private JMenuItem createMenuItem(String name)
	{
		String label = jEdit.getProperty(""vfs.browser.menu."" + name + "".label"");
		JMenuItem mi = new JMenuItem(label);
		mi.setActionCommand(name);
		mi.addActionListener(new ActionHandler());
		return mi;
	}
	private JMenu createOpenEncodingMenu()
	{
		ActionListener listener = new ActionHandler();
		JMenu openEncoding = new JMenu(jEdit.getProperty(""open-encoding.label""));
		// used twice...
		String systemEncoding = System.getProperty(""file.encoding"");
		JMenuItem mi = new JMenuItem(jEdit.getProperty(""os-encoding""));
		mi.setActionCommand(""open@"" + systemEncoding);
		mi.addActionListener(listener);
		openEncoding.add(mi);
		mi = new JMenuItem(jEdit.getProperty(""jedit-encoding""));
		mi.setActionCommand(""open@"" + jEdit.getProperty(""buffer.encoding"",systemEncoding));
		mi.addActionListener(listener);
		openEncoding.add(mi);
		openEncoding.addSeparator();
		StringTokenizer st = new StringTokenizer(jEdit.getProperty(""encodings""));
		while(st.hasMoreTokens())
		{
			String encoding = st.nextToken();
			mi = new JMenuItem(encoding);
			mi.setActionCommand(""open@"" + encoding);
			mi.addActionListener(listener);
			openEncoding.add(mi);
		}
		openEncoding.addSeparator();
		mi = new JMenuItem(jEdit.getProperty(""other-encoding.label""));
		mi.setActionCommand(""other-encoding"");
		mi.addActionListener(listener);
		openEncoding.add(mi);
		return openEncoding;
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			View view = browser.getView();
			String actionCommand = evt.getActionCommand();
			if(actionCommand.startsWith(""open@""))
			{
				// a bit of a hack to support 'Open With Encoding' menu
				Hashtable props = new Hashtable();
				props.put(Buffer.ENCODING,actionCommand.substring(5));
				jEdit.openFile(view,null,file.path,false,props);
			}
			else if(actionCommand.equals(""other-encoding""))
			{
				String encoding = GUIUtilities.input(browser,
					""encoding-prompt"",null,
					jEdit.getProperty(""buffer.encoding"",
					System.getProperty(""file.encoding"")));
				if(encoding == null)
					return;
				Hashtable props = new Hashtable();
				props.put(Buffer.ENCODING,encoding);
				jEdit.openFile(view,null,file.path,false,props);
			}
			else if(actionCommand.equals(""open""))
				jEdit.openFile(view,file.path);
			else if(actionCommand.equals(""insert""))
				view.getBuffer().insert(view,file.path);
			else if(actionCommand.equals(""choose""))
				browser.filesActivated();
			else if(actionCommand.equals(""close""))
			{
				Buffer buffer = jEdit.getBuffer(file.path);
				if(buffer != null)
					jEdit.closeBuffer(view,buffer);
			}
			else if(actionCommand.equals(""browse""))
				browser.setDirectory(file.path);
			else if(evt.getActionCommand().equals(""rename""))
				browser.rename(file.path);
			else if(evt.getActionCommand().equals(""delete""))
				browser.delete(file.deletePath);
			else if(actionCommand.equals(""show-hidden-files""))
			{
				browser.setShowHiddenFiles(!browser.getShowHiddenFiles());
				browser.reloadDirectory();
			}
			else if(actionCommand.equals(""new-file""))
			{
				VFS.DirectoryEntry[] selected = browser.getSelectedFiles();
				if(selected.length >= 1)
				{
					VFS.DirectoryEntry file = selected[0];
					if(file.type == VFS.DirectoryEntry.DIRECTORY)
						jEdit.newFile(view,file.path);
					else
					{
						VFS vfs = VFSManager.getVFSForPath(file.path);
						jEdit.newFile(view,vfs.getParentOfPath(file.path));
					}
				}
				else
					jEdit.newFile(view,browser.getDirectory());
			}
			else if(actionCommand.equals(""new-directory""))
				browser.mkdir();
			else if(actionCommand.equals(""search-in-directory""))
			{
				String path;
				VFS.DirectoryEntry[] selected = browser.getSelectedFiles();
				if(selected.length >= 1)
				{
					VFS.DirectoryEntry file = selected[0];
					if(file.type == VFS.DirectoryEntry.DIRECTORY)
						path = file.path;
					else
					{
						VFS vfs = VFSManager.getVFSForPath(file.path);
						path = vfs.getParentOfPath(file.path);
					}
				}
				else
					path = browser.getDirectory();
				SearchAndReplace.setSearchFileSet(new DirectoryListSet(
					path,browser.getFilenameFilter(),true));
				new SearchDialog(browser.getView(),null,SearchDialog.DIRECTORY);
			}
			else if(actionCommand.equals(""add-to-favorites""))
			{
				// if any directories are selected, add
				// them, otherwise add current directory
				Vector toAdd = new Vector();
				VFS.DirectoryEntry[] selected = browser.getSelectedFiles();
				for(int i = 0; i < selected.length; i++)
				{
					VFS.DirectoryEntry file = selected[i];
					if(file.type == VFS.DirectoryEntry.FILE)
					{
						GUIUtilities.error(browser,
							""vfs.browser.files-favorites"",
							null);
						return;
					}
					else
						toAdd.addElement(file.path);
				}
				if(toAdd.size() != 0)
				{
					for(int i = 0; i < toAdd.size(); i++)
					{
						FavoritesVFS.addToFavorites((String)toAdd.elementAt(i));
					}
				}
				else
				{
					String directory = browser.getDirectory();
					if(directory.equals(FavoritesVFS.PROTOCOL + "":""))
					{
						GUIUtilities.error(browser,
							""vfs.browser.recurse-favorites"",
							null);
					}
					else
					{
						FavoritesVFS.addToFavorites(directory);
					}
				}
			}
			else if(actionCommand.equals(""go-to-favorites""))
				browser.setDirectory(FavoritesVFS.PROTOCOL + "":"");
			else if(actionCommand.startsWith(""vfs.""))
			{
				String vfsName = actionCommand.substring(4);
				VFS vfs = VFSManager.getVFSByName(vfsName);
				String directory = vfs.showBrowseDialog(null,browser);
				if(directory != null)
					browser.setDirectory(directory);
			}
		}
	}
}
"
org.gjt.sp.jedit.browser.BrowserView,"/*
 * BrowserView.java
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Enumeration;
import java.util.Vector;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
/**
 * VFS browser tree view.
 * @author Slava Pestov
 * @version $Id: BrowserView.java,v 1.20 2001/08/04 02:18:20 sp Exp $
 */
public class BrowserView extends JPanel
{
	public BrowserView(VFSBrowser browser)
	{
		this.browser = browser;
		currentlyLoadingTreeNode = rootNode = new DefaultMutableTreeNode(null,true);
		model = new DefaultTreeModel(rootNode,true);
		tree = new BrowserJTree(model);
		tree.setCellRenderer(renderer);
		tree.setEditable(false);
		tree.addTreeExpansionListener(new TreeHandler());
		tree.putClientProperty(""JTree.lineStyle"", ""Angled"");
		if(browser.isMultipleSelectionEnabled())
			tree.getSelectionModel().setSelectionMode(
				TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);
		else
			tree.getSelectionModel().setSelectionMode(
				TreeSelectionModel.SINGLE_TREE_SELECTION);
		setLayout(new BorderLayout());
		scroller = new JScrollPane(tree);
		scroller.setPreferredSize(new Dimension(0,200));
		add(BorderLayout.CENTER,scroller);
		propertiesChanged();
	}
	public VFS.DirectoryEntry[] getSelectedFiles()
	{
		Vector selected = new Vector(tree.getSelectionCount());
		TreePath[] paths = tree.getSelectionPaths();
		if(paths == null)
			return new VFS.DirectoryEntry[0];
		for(int i = 0; i < paths.length; i++)
		{
			DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
				paths[i].getLastPathComponent();
			Object obj = treeNode.getUserObject();
			if(obj instanceof VFS.DirectoryEntry)
				selected.addElement(obj);
		}
		VFS.DirectoryEntry[] retVal = new VFS.DirectoryEntry[selected.size()];
		selected.copyInto(retVal);
		return retVal;
	}
	public void selectNone()
	{
		tree.setSelectionPaths(new TreePath[0]);
	}
	public void directoryLoaded(Vector directory)
	{
		if(currentlyLoadingTreeNode == rootNode)
			rootNode.setUserObject(browser.getDirectory());
		currentlyLoadingTreeNode.removeAllChildren();
		if(directory != null)
		{
			for(int i = 0; i < directory.size(); i++)
			{
				VFS.DirectoryEntry file = (VFS.DirectoryEntry)
					directory.elementAt(i);
				boolean allowsChildren = (file.type != VFS.DirectoryEntry.FILE);
				currentlyLoadingTreeNode.add(new DefaultMutableTreeNode(file,allowsChildren));
			}
		}
		// fire events
		model.reload(currentlyLoadingTreeNode);
		tree.expandPath(new TreePath(currentlyLoadingTreeNode.getPath()));
		/* If the user expands a tree node manually, the tree
		 * listener sets currentlyLoadingTreeNode to that.
		 * But if VFSBrowser.setDirectory() is called, we want
		 * the root node to be updated.
		 *
		 * Since the browser view receives no prior notification
		 * to a setDirectory(), we set the currentlyLoadingTreeNode
		 * to null here. */
		currentlyLoadingTreeNode = rootNode;
		timer.stop();
		typeSelectBuffer.setLength(0);
	}
	public void updateFileView()
	{
		tree.repaint();
	}
	public void reloadDirectory(String path)
	{
		// because this method is called for *every* VFS update,
		// we don't want to scan the tree all the time. So we
		// use the following algorithm to determine if the path
		// might be part of the tree:
		// - if the path starts with the browser's current directory,
		//   we do the tree scan
		// - if the browser's directory is 'favorites:' -- we have to
		//   do the tree scan, as every path can appear under the
		//   favorites list
		// - if the browser's directory is 'roots:' and path is on
		//   the local filesystem, do a tree scan
		String browserDir = browser.getDirectory();
		if(browserDir.startsWith(FavoritesVFS.PROTOCOL))
			reloadDirectory(rootNode,path);
		else if(browserDir.startsWith(FileRootsVFS.PROTOCOL))
		{
			if(!MiscUtilities.isURL(path) || MiscUtilities.getProtocolOfURL(path)
				.equals(""file""))
				reloadDirectory(rootNode,path);
		}
		else if(path.startsWith(browserDir))
			reloadDirectory(rootNode,path);
	}
	public Component getDefaultFocusComponent()
	{
		return tree;
	}
	public void propertiesChanged()
	{
		showIcons = jEdit.getBooleanProperty(""vfs.browser.showIcons"");
		renderer.propertiesChanged();
	}
	// private members
	private VFSBrowser browser;
	private JTree tree;
	private JScrollPane scroller;
	private DefaultTreeModel model;
	private DefaultMutableTreeNode rootNode;
	private DefaultMutableTreeNode currentlyLoadingTreeNode;
	private BrowserPopupMenu popup;
	// used for tool tips
	private boolean showIcons;
	private FileCellRenderer renderer = new FileCellRenderer();
	private StringBuffer typeSelectBuffer = new StringBuffer();
	private Timer timer = new Timer(0,new ClearTypeSelect());
	class ClearTypeSelect implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			typeSelectBuffer.setLength(0);
			browser.filesSelected();
		}
	}
	private boolean reloadDirectory(DefaultMutableTreeNode node, String path)
	{
		// nodes which are not expanded need not be checked
		if(!tree.isExpanded(new TreePath(node.getPath())))
			return false;
		Object userObject = node.getUserObject();
		if(userObject instanceof String)
		{
			if(path.equals(userObject))
			{
				loadDirectoryNode(node,path,false);
				return true;
			}
		}
		else if(userObject instanceof VFS.DirectoryEntry)
		{
			VFS.DirectoryEntry file = (VFS.DirectoryEntry)userObject;
			// we don't need to do anything with files!
			if(file.type == VFS.DirectoryEntry.FILE)
				return false;
			if(path.equals(file.path))
			{
				loadDirectoryNode(node,path,false);
				return true;
			}
		}
		if(node.getChildCount() != 0)
		{
			Enumeration children = node.children();
			while(children.hasMoreElements())
			{
				DefaultMutableTreeNode child = (DefaultMutableTreeNode)
					children.nextElement();
				if(reloadDirectory(child,path))
					return true;
			}
		}
		return false;
	}
	private void loadDirectoryNode(DefaultMutableTreeNode node, String path,
		boolean showLoading)
	{
		currentlyLoadingTreeNode = node;
		if(showLoading)
		{
			node.removeAllChildren();
			node.add(new DefaultMutableTreeNode(new LoadingPlaceholder(),false));
		}
		// fire events
		model.reload(currentlyLoadingTreeNode);
		browser.loadDirectory(path);
	}
	private void showFilePopup(VFS.DirectoryEntry file, Point point)
	{
		popup = new BrowserPopupMenu(browser,file);
		popup.show(tree,point.x+1,point.y+1);
	}
	class BrowserJTree extends JTree
	{
		BrowserJTree(TreeModel model)
		{
			super(model);
			ToolTipManager.sharedInstance().registerComponent(this);
		}
		public final String getToolTipText(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
					return path.getLastPathComponent().toString();
			}
			return null;
		}
		public final Point getToolTipLocation(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
				{
					return new Point(cellRect.x + (showIcons ? 20 : 1),
						cellRect.y + (showIcons ? 1 : -1));
				}
			}
			return null;
		}
		protected void processKeyEvent(KeyEvent evt)
		{
			if(evt.getID() == KeyEvent.KEY_PRESSED)
			{
				switch(evt.getKeyCode())
				{
				case KeyEvent.VK_ENTER:
					browser.filesActivated();
					evt.consume();
					break;
				case KeyEvent.VK_LEFT:
					if(getMinSelectionRow() == -1
						|| getMinSelectionRow() == 0)
					{
						String directory = browser.getDirectory();
						browser.setDirectory(VFSManager.getVFSForPath(
							directory).getParentOfPath(directory));
						evt.consume();
					}
					break;
				}
			}
			else if(evt.getID() == KeyEvent.KEY_TYPED)
			{
				typeSelectBuffer.append(evt.getKeyChar());
				doTypeSelect(typeSelectBuffer.toString());
				timer.stop();
				timer.setInitialDelay(500);
				timer.setRepeats(false);
				timer.start();
			}
			if(!evt.isConsumed())
				super.processKeyEvent(evt);
		}
		protected void processMouseEvent(MouseEvent evt)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			switch(evt.getID())
			{
			case MouseEvent.MOUSE_ENTERED:
				toolTipInitialDelay = ttm.getInitialDelay();
				toolTipReshowDelay = ttm.getReshowDelay();
				ttm.setInitialDelay(200);
				ttm.setReshowDelay(0);
				super.processMouseEvent(evt);
				break;
			case MouseEvent.MOUSE_EXITED:
				ttm.setInitialDelay(toolTipInitialDelay);
				ttm.setReshowDelay(toolTipReshowDelay);
				super.processMouseEvent(evt);
				break;
			case MouseEvent.MOUSE_CLICKED:
				if((evt.getModifiers() & MouseEvent.BUTTON1_MASK) != 0)
				{
					TreePath path = getPathForLocation(evt.getX(),evt.getY());
					if(path == null)
					{
						super.processMouseEvent(evt);
						break;
					}
					if(!isPathSelected(path))
						setSelectionPath(path);
					if(evt.getClickCount() == 1)
					{
						browser.filesSelected();
						super.processMouseEvent(evt);
					}
					if(evt.getClickCount() == 2)
					{
						// don't pass double-clicks to tree, otherwise
						// directory nodes will be expanded and we don't
						// want that
						browser.filesActivated();
						break;
					}
				}
				else if(GUIUtilities.isPopupTrigger(evt))
					; // do nothing
				super.processMouseEvent(evt);
				break;
			case MouseEvent.MOUSE_PRESSED:
				if((evt.getModifiers() & MouseEvent.BUTTON1_MASK) != 0)
				{
					if(popup != null && popup.isVisible())
						popup.setVisible(false);
					if(evt.getClickCount() == 2)
						break;
				}
				else if(GUIUtilities.isPopupTrigger(evt))
				{
					if(popup != null && popup.isVisible())
					{
						popup.setVisible(false);
						break;
					}
					TreePath path = getPathForLocation(evt.getX(),evt.getY());
					if(path == null)
						showFilePopup(null,evt.getPoint());
					else
					{
						setSelectionPath(path);
						browser.filesSelected();
						Object userObject = ((DefaultMutableTreeNode)path
							.getLastPathComponent()).getUserObject();
						if(userObject instanceof VFS.DirectoryEntry)
						{
							VFS.DirectoryEntry file = (VFS.DirectoryEntry)
								userObject;
							showFilePopup(file,evt.getPoint());
						}
						else
							showFilePopup(null,evt.getPoint());
					}
					break;
				}
				super.processMouseEvent(evt);
				break;
			default:
				super.processMouseEvent(evt);
				break;
			}
		}
		// private members
		private int toolTipInitialDelay = -1;
		private int toolTipReshowDelay = -1;
		private boolean cellRectIsVisible(Rectangle cellRect)
		{
			Rectangle vr = BrowserJTree.this.getVisibleRect();
			return vr.contains(cellRect.x,cellRect.y) &&
				vr.contains(cellRect.x + cellRect.width,
				cellRect.y + cellRect.height);
		}
		private void doTypeSelect(String str)
		{
			if(getSelectionCount() == 0)
				doTypeSelect(str,0,getRowCount());
			else
			{
				int start = getMaxSelectionRow();
				boolean retVal = doTypeSelect(str,start,getRowCount());
				if(!retVal)
				{
					// scan from selection to end failed, so
					// scan from start to selection
					doTypeSelect(str,0,start);
				}
			}
		}
		private boolean doTypeSelect(String str, int start, int end)
		{
			for(int i = start; i < end; i++)
			{
				DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
					getPathForRow(i).getLastPathComponent();
				Object obj = treeNode.getUserObject();
				if(obj instanceof VFS.DirectoryEntry)
				{
					VFS.DirectoryEntry file = (VFS.DirectoryEntry)obj;
					if(file.name.regionMatches(true,0,str,0,str.length()))
					{
						clearSelection();
						setSelectionRow(i);
						scrollRowToVisible(i);
						return true;
					}
				}
			}
			return false;
		}
	}
	class TreeHandler implements TreeExpansionListener
	{
		public void treeExpanded(TreeExpansionEvent evt)
		{
			TreePath path = evt.getPath();
			DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
				path.getLastPathComponent();
			Object userObject = treeNode.getUserObject();
			if(userObject instanceof VFS.DirectoryEntry)
			{
				loadDirectoryNode(treeNode,((VFS.DirectoryEntry)
					userObject).path,true);
			}
		}
		public void treeCollapsed(TreeExpansionEvent evt)
		{
			TreePath path = evt.getPath();
			DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
				path.getLastPathComponent();
			if(treeNode.getUserObject() instanceof VFS.DirectoryEntry)
			{
				// we add the placeholder so that the node has
				// 1 child (otherwise the user won't be able to
				// expand it again)
				treeNode.removeAllChildren();
				treeNode.add(new DefaultMutableTreeNode(new LoadingPlaceholder(),false));
				model.reload(treeNode);
			}
		}
	}
	class LoadingPlaceholder {}
}
"
org.gjt.sp.jedit.browser.FileCellRenderer,"/*
 * FileCellRenderer.java - renders list and tree cells for the VFS browser
 * Copyright (C) 1999 Jason Ginchereau
 * Portions copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
import java.awt.*;
import javax.swing.*;
import javax.swing.tree.*;
import javax.swing.border.*;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.*;
public final class FileCellRenderer extends JLabel implements TreeCellRenderer
{
	public FileCellRenderer()
	{
		Font font = UIManager.getFont(""Tree.font"");
		// make a non-UIResource copy so that updateUI() doesn't
		// reset it
		setFont(new Font(font.getFamily(),font.getStyle(),font.getSize()));
		// use metal icons because not all looks and feels define these.
		// note that metal is guaranteed to exist, so this shouldn't
		// cause problems in the future.
		UIDefaults metalDefaults = new javax.swing.plaf.metal.MetalLookAndFeel()
			.getDefaults();
		fileIcon = metalDefaults.getIcon(""FileView.fileIcon"");
		dirIcon = metalDefaults.getIcon(""FileView.directoryIcon"");
		filesystemIcon = metalDefaults.getIcon(""FileView.hardDriveIcon"");
		loadingIcon = metalDefaults.getIcon(""FileView.hardDriveIcon"");
		setOpaque(true);
	}
	public Component getTreeCellRendererComponent(JTree tree, Object value,
		boolean sel, boolean expanded, boolean leaf, int row,
		boolean focus)
	{
		if(sel)
		{
			setBackground(treeSelectionBackground);
			setForeground(treeSelectionForeground);
		}
		else
		{
			setBackground(treeNoSelectionBackground);
			setForeground(treeNoSelectionForeground);
		}
		DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)value;
		Object userObject = treeNode.getUserObject();
		if(userObject instanceof VFS.DirectoryEntry)
		{
			VFS.DirectoryEntry file = (VFS.DirectoryEntry)userObject;
			boolean opened = (jEdit.getBuffer(file.path) != null);
			setBorder(opened ? openBorder : closedBorder);
			if(showIcons)
			{
				setIcon(getIconForFile(file));
				setText(file.name);
			}
			else
			{
				setIcon(null);
				setText(file.type == VFS.DirectoryEntry.DIRECTORY
					? file.name + ""/"" : file.name);
			}
		}
		else if(userObject instanceof BrowserView.LoadingPlaceholder)
		{
			if(showIcons)
				setIcon(loadingIcon);
			else
				setIcon(null);
			setText(jEdit.getProperty(""vfs.browser.tree.loading""));
			setBorder(closedBorder);
		}
		else if(userObject instanceof String)
		{
			if(showIcons)
			{
				setIcon(dirIcon);
				setText((String)userObject);
			}
			else
			{
				setIcon(null);
				setText(userObject + ""/"");
			}
			setBorder(closedBorder);
		}
		else
		{
			// userObject is null?
			setIcon(null);
			setText(null);
		}
		return this;
	}
	// protected members
	protected Icon getIconForFile(VFS.DirectoryEntry file)
	{
		if(file.type == VFS.DirectoryEntry.DIRECTORY)
			return dirIcon;
		else if(file.type == VFS.DirectoryEntry.FILESYSTEM)
			return filesystemIcon;
		else
			return fileIcon;
	}
	// package-private members
	boolean showIcons;
	void propertiesChanged()
	{
		// bug in DefaultTreeCellRenderer?
		setBackground(UIManager.getColor(""Tree.textBackground""));
		showIcons = jEdit.getBooleanProperty(""vfs.browser.showIcons"");
		if(showIcons)
		{
			closedBorder = new EmptyBorder(0,3,0,0);
			openBorder = new CompoundBorder(new MatteBorder(0,2,0,0,
				UIManager.getColor(""Tree.textForeground"")),
				new EmptyBorder(0,1,0,0));
		}
		else
		{
			closedBorder = new EmptyBorder(1,4,1,1);
			openBorder = new CompoundBorder(new MatteBorder(0,2,0,0,
				UIManager.getColor(""Tree.textForeground"")),
				new EmptyBorder(1,2,1,1));
		}
		treeSelectionForeground = UIManager.getColor(""Tree.selectionForeground"");
		treeNoSelectionForeground = UIManager.getColor(""Tree.textForeground"");
		treeSelectionBackground = UIManager.getColor(""Tree.selectionBackground"");
		treeNoSelectionBackground = UIManager.getColor(""Tree.textBackground"");
	}
	// private members
	private Icon fileIcon;
	private Icon dirIcon;
	private Icon filesystemIcon;
	private Icon loadingIcon;
	private Border closedBorder;
	private Border openBorder;
	private Color treeSelectionForeground;
	private Color treeNoSelectionForeground;
	private Color treeSelectionBackground;
	private Color treeNoSelectionBackground;
}
"
org.gjt.sp.jedit.browser.VFSBrowser,"/*
 * VFSBrowser.java - VFS browser
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
import gnu.regexp.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.EventListenerList;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * The main class of the VFS browser.
 * @author Slava Pestov
 * @version $Id: VFSBrowser.java,v 1.46 2001/07/12 05:06:52 sp Exp $
 */
public class VFSBrowser extends JPanel implements EBComponent, DockableWindow
{
	public static final String NAME = ""vfs.browser"";
	/**
	 * Open file dialog mode. Equals JFileChooser.OPEN_DIALOG for
	 * backwards compatibility.
	 */
	public static final int OPEN_DIALOG = 0;
	/**
	 * Save file dialog mode. Equals JFileChooser.SAVE_DIALOG for
	 * backwards compatibility.
	 */
	public static final int SAVE_DIALOG = 1;
	/**
	 * Stand-alone browser mode.
	 */
	public static final int BROWSER = 2;
	/**
	 * Creates a new VFS browser.
	 * @param view The view to open buffers in by default
	 * @param path The path to display
	 */
	public VFSBrowser(View view, String path)
	{
		this(view,path,BROWSER,false);
	}
	/**
	 * Creates a new VFS browser.
	 * @param view The view to open buffers in by default
	 * @param path The path to display
	 * @param mode The browser mode
	 * @param multipleSelection True if multiple selection should be allowed
	 */
	public VFSBrowser(View view, String path, int mode, boolean multipleSelection)
	{
		super(new BorderLayout());
		listenerList = new EventListenerList();
		this.mode = mode;
		this.multipleSelection = multipleSelection;
		this.view = view;
		ActionHandler actionHandler = new ActionHandler();
		Box topBox = new Box(BoxLayout.Y_AXIS);
		topBox.add(createToolBar());
		GridBagLayout layout = new GridBagLayout();
		JPanel pathAndFilterPanel = new JPanel(layout);
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridwidth = cons.gridheight = 1;
		cons.gridx = cons.gridy = 0;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.EAST;
		JLabel label = new JLabel(jEdit.getProperty(""vfs.browser.path""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(label,cons);
		pathAndFilterPanel.add(label);
		pathField = new HistoryTextField(""vfs.browser.path"",true,false);
		// because its preferred size can be quite wide, we
		// don't want it to make the browser way too big,
		// so set the preferred width to 0.
		Dimension prefSize = pathField.getPreferredSize();
		prefSize.width = 0;
		pathField.setPreferredSize(prefSize);
		pathField.addActionListener(actionHandler);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(pathField,cons);
		pathAndFilterPanel.add(pathField);
		filterCheckbox = new JCheckBox(jEdit.getProperty(""vfs.browser.filter""));
		filterCheckbox.setMargin(new Insets(0,0,0,0));
		filterCheckbox.setRequestFocusEnabled(false);
		filterCheckbox.setBorder(new EmptyBorder(0,0,0,12));
		filterCheckbox.setSelected(mode != BROWSER ||
			jEdit.getBooleanProperty(""vfs.browser.filter-enabled""));
		// we ensure that the foreground color is not an UIResource
		// so that updateUI() does not reset the color back to the
		// default...
		filterCheckbox.setForeground(new Color(
			UIManager.getColor(""Label.foreground"").getRGB()));
		filterCheckbox.addActionListener(actionHandler);
		cons.gridx = 0;
		cons.weightx = 0.0f;
		cons.gridy = 1;
		layout.setConstraints(filterCheckbox,cons);
		pathAndFilterPanel.add(filterCheckbox);
		filterField = new HistoryTextField(""vfs.browser.filter"",true);
		filterField.addActionListener(actionHandler);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(filterField,cons);
		pathAndFilterPanel.add(filterField);
		topBox.add(pathAndFilterPanel);
		add(BorderLayout.NORTH,topBox);
		add(BorderLayout.CENTER,browserView = new BrowserView(this));
		propertiesChanged();
		HistoryModel filterModel = HistoryModel.getModel(""vfs.browser.filter"");
		String filter;
		if(mode == BROWSER || view == null || !jEdit.getBooleanProperty(
			""vfs.browser.currentBufferFilter""))
		{
			filter = jEdit.getProperty(""vfs.browser.last-filter"");
			if(filter == null)
				filter = jEdit.getProperty(""vfs.browser.default-filter"");
		}
		else
		{
			String name = view.getBuffer().getName();
			int index = name.lastIndexOf('.');
			if(index == -1)
				filter = jEdit.getProperty(""vfs.browser.default-filter"");
			else
			{
				String ext = name.substring(index);
				filter = ""*"" + ext;
			}
		}
		filterField.setText(filter);
		filterField.addCurrentToHistory();
		updateFilterEnabled();
		if(path == null)
		{
			String defaultPath = jEdit.getProperty(""vfs.browser.defaultPath"");
			String userHome = System.getProperty(""user.home"");
			if(defaultPath.equals(""home""))
				path = userHome;
			else if(defaultPath.equals(""buffer""))
			{
				if(view != null)
				{
					Buffer buffer = view.getBuffer();
					path = buffer.getVFS().getParentOfPath(
						buffer.getPath());
				}
				else
					path = userHome;
			}
			else if(defaultPath.equals(""last""))
			{
				HistoryModel pathModel = HistoryModel.getModel(""vfs.browser.path"");
				if(pathModel.getSize() == 0)
					path = userHome;
				else
					path = pathModel.getItem(0);
			}
			else if(defaultPath.equals(""favorites""))
				path = ""favorites:"";
			else
			{
				// unknown value??!!!
				path = userHome;
			}
		}
		setDirectory(path);
	}
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	}
	public void removeNotify()
	{
		super.removeNotify();
		jEdit.setBooleanProperty(""vfs.browser.filter-enabled"",
			filterCheckbox.isSelected());
		if(mode == BROWSER || !jEdit.getBooleanProperty(
			""vfs.browser.currentBufferFilter""))
		{
			jEdit.setProperty(""vfs.browser.last-filter"",
				filterField.getText());
		}
		EditBus.removeFromBus(this);
	}
	// DockableWindow implementation
	public String getName()
	{
		return NAME;
	}
	public Component getComponent()
	{
		return this;
	}
	// end DockableWindow implementation
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof ViewUpdate)
			handleViewUpdate((ViewUpdate)msg);
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
		else if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof VFSUpdate)
		{
			// this is a dirty hack and it relies on the fact
			// that updates for parents are sent before updates
			// for the changed nodes themselves (if this was not
			// the case, the browser wouldn't be updated properly
			// on delete, etc).
			//
			// to avoid causing '> 1 request' errors, don't reload
			// directory if request already active
			if(requestRunning)
				return;
			browserView.reloadDirectory(((VFSUpdate)msg).getPath());
		}
	}
	public String getDirectory()
	{
		return path;
	}
	public void setDirectory(String path)
	{
		// have to do this hack until VFSPath class is written
		if(path.length() != 1 && (path.endsWith(""/"")
			|| path.endsWith(java.io.File.separator)))
			path = path.substring(0,path.length() - 1);
		if(path.startsWith(""file:""))
			path = path.substring(5);
		this.path = path;
		pathField.setText(path);
		pathField.addCurrentToHistory();
		reloadDirectory();
	}
	public void reloadDirectory()
	{
		try
		{
			String filter = filterField.getText();
			if(filter.length() == 0)
				filter = ""*"";
			filenameFilter = new RE(MiscUtilities.globToRE(filter),RE.REG_ICASE);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,VFSBrowser.this,e);
			String[] args = { filterField.getText(),
				e.getMessage() };
			GUIUtilities.error(VFSBrowser.this,""vfs.browser.bad-filter"",args);
		}
		loadDirectory(path);
	}
	public void loadDirectory(String path)
	{
		VFS vfs = VFSManager.getVFSForPath(path);
		Object session = vfs.createVFSSession(path,this);
		if(session == null)
			return;
		if(!startRequest())
			return;
		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.LIST_DIRECTORY,this,
			session,vfs,path,null));
	}
	public void delete(String path)
	{
		if(MiscUtilities.isURL(path) && FavoritesVFS.PROTOCOL.equals(
			MiscUtilities.getProtocolOfURL(path)))
		{
			Object[] args = { path.substring(FavoritesVFS.PROTOCOL.length() + 1) };
			int result = GUIUtilities.confirm(this,
				""vfs.browser.delete-favorites"",args,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}
		else
		{
			Object[] args = { path };
			int result = GUIUtilities.confirm(this,
				""vfs.browser.delete-confirm"",args,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}
		VFS vfs = VFSManager.getVFSForPath(path);
		Object session = vfs.createVFSSession(path,this);
		if(session == null)
			return;
		if(!startRequest())
			return;
		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.DELETE,this,
			session,vfs,path,null));
	}
	public void rename(String from)
	{
		VFS vfs = VFSManager.getVFSForPath(from);
		String filename = vfs.getFileName(from);
		String[] args = { filename };
		String to = GUIUtilities.input(this,""vfs.browser.rename"",
			args,filename);
		if(to == null)
			return;
		to = vfs.constructPath(vfs.getParentOfPath(from),to);
		Object session = vfs.createVFSSession(from,this);
		if(session == null)
			return;
		if(!startRequest())
			return;
		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.RENAME,this,
			session,vfs,from,to));
	}
	public void mkdir()
	{
		String newDirectory = GUIUtilities.input(this,""vfs.browser.mkdir"",null);
		if(newDirectory == null)
			return;
		// if a directory is selected, create new dir in there.
		// if a file is selected, create new dir inside its parent.
		VFS.DirectoryEntry[] selected = getSelectedFiles();
		String parent;
		if(selected.length == 0)
			parent = path;
		else if(selected[0].type == VFS.DirectoryEntry.FILE)
		{
			parent = selected[0].path;
			parent = VFSManager.getVFSForPath(parent)
				.getParentOfPath(parent);
		}
		else
			parent = selected[0].path;
		VFS vfs = VFSManager.getVFSForPath(parent);
		// path is the currently viewed directory in the browser
		newDirectory = vfs.constructPath(parent,newDirectory);
		Object session = vfs.createVFSSession(newDirectory,this);
		if(session == null)
			return;
		if(!startRequest())
			return;
		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.MKDIR,this,
			session,vfs,newDirectory,null));
	}
	public View getView()
	{
		return view;
	}
	public int getMode()
	{
		return mode;
	}
	public boolean isMultipleSelectionEnabled()
	{
		return multipleSelection;
	}
	public boolean getShowHiddenFiles()
	{
		return showHiddenFiles;
	}
	public void setShowHiddenFiles(boolean showHiddenFiles)
	{
		this.showHiddenFiles = showHiddenFiles;
	}
	/**
	 * Returns the file name filter glob.
	 * @since jEdit 3.2pre2
	 */
	public String getFilenameFilter()
	{
		if(filterCheckbox.isSelected())
		{
			String filter = filterField.getText();
			if(filter.length() == 0)
				return ""*"";
			else
				return filter;
		}
		else
			return ""*"";
	}
	public void setFilenameFilter(String filter)
	{
		if(filter == null || filter.length() == 0 || filter.equals(""*""))
			filterCheckbox.setSelected(false);
		else
		{
			filterCheckbox.setSelected(true);
			filterField.setText(filter);
		}
	}
	public BrowserView getBrowserView()
	{
		return browserView;
	}
	public VFS.DirectoryEntry[] getSelectedFiles()
	{
		return browserView.getSelectedFiles();
	}
	public void addBrowserListener(BrowserListener l)
	{
		listenerList.add(BrowserListener.class,l);
	}
	public void removeBrowserListener(BrowserListener l)
	{
		listenerList.remove(BrowserListener.class,l);
	}
	// package-private members
	void directoryLoaded(final VFS.DirectoryEntry[] list)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				boolean filterEnabled = filterCheckbox.isSelected();
				Vector directoryVector = new Vector();
				if(list == null)
				{
					browserView.directoryLoaded(directoryVector);
					return;
				}
				for(int i = 0; i < list.length; i++)
				{
					VFS.DirectoryEntry file = list[i];
					if(file.hidden && !showHiddenFiles)
						continue;
					if(file.type == VFS.DirectoryEntry.FILE
						&& filterEnabled
						&& filenameFilter != null
						&& !filenameFilter.isMatch(file.name))
						continue;
					directoryVector.addElement(file);
				}
				if(sortFiles)
				{
					MiscUtilities.quicksort(directoryVector,
						new FileCompare());
				}
				browserView.directoryLoaded(directoryVector);
			}
		});
	}
	class FileCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			VFS.DirectoryEntry file1 = (VFS.DirectoryEntry)obj1;
			VFS.DirectoryEntry file2 = (VFS.DirectoryEntry)obj2;
			if(!sortMixFilesAndDirs)
			{
				if(file1.type != file2.type)
					return file2.type - file1.type;
			}
			if(sortIgnoreCase)
			{
				return file1.name.toLowerCase().compareTo(
					file2.name.toLowerCase());
			}
			else
			{
				return file1.name.compareTo(file2.name);
			}
		}
	}
	void filesSelected()
	{
		VFS.DirectoryEntry[] selectedFiles = browserView.getSelectedFiles();
		if(mode == BROWSER)
		{
			for(int i = 0; i < selectedFiles.length; i++)
			{
				VFS.DirectoryEntry file = selectedFiles[i];
				Buffer buffer = jEdit.getBuffer(file.path);
				if(buffer != null && view != null)
					view.setBuffer(buffer);
			}
		}
		Object[] listeners = listenerList.getListenerList();
		for(int i = 0; i < listeners.length; i++)
		{
			if(listeners[i] == BrowserListener.class)
			{
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesSelected(this,selectedFiles);
			}
		}
	}
	void filesActivated()
	{
		VFS.DirectoryEntry[] selectedFiles = browserView.getSelectedFiles();
		for(int i = 0; i < selectedFiles.length; i++)
		{
			VFS.DirectoryEntry file = selectedFiles[i];
			if(file.type == VFS.DirectoryEntry.DIRECTORY
				|| file.type == VFS.DirectoryEntry.FILESYSTEM)
				setDirectory(file.path);
			else if(mode == BROWSER)
			{
				Buffer buffer = jEdit.getBuffer(file.path);
				if(buffer == null)
					buffer = jEdit.openFile(null,file.path);
				else if(doubleClickClose)
				{
					jEdit.closeBuffer(view,buffer);
					break;
				}
				if(buffer != null)
				{
					if(view == null)
						view = jEdit.newView(null,buffer);
					else
						view.setBuffer(buffer);
				}
			}
			else
			{
				// if a file is selected in OPEN_DIALOG or
				// SAVE_DIALOG mode, just let the listener(s)
				// handle it
			}
		}
		Object[] listeners = listenerList.getListenerList();
		for(int i = 0; i < listeners.length; i++)
		{
			if(listeners[i] == BrowserListener.class)
			{
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesActivated(this,selectedFiles);
			}
		}
	}
	// has to be package-private so that BrowserIORequest can call it
	void endRequest()
	{
		requestRunning = false;
	}
	// private members
	private EventListenerList listenerList;
	private View view;
	private String path;
	private HistoryTextField pathField;
	private JCheckBox filterCheckbox;
	private HistoryTextField filterField;
	private JButton up, reload, roots, home, synchronize;
	private BrowserView browserView;
	private RE filenameFilter;
	private int mode;
	private boolean multipleSelection;
	private boolean showHiddenFiles;
	private boolean sortFiles;
	private boolean sortMixFilesAndDirs;
	private boolean sortIgnoreCase;
	private boolean doubleClickClose;
	private boolean requestRunning;
	private JToolBar createToolBar()
	{
		JToolBar toolBar = new JToolBar();
		toolBar.setFloatable(false);
		toolBar.putClientProperty(""JToolBar.isRollover"",Boolean.TRUE);
		toolBar.add(up = createToolButton(""up""));
		// see comment in UpMenuButton class to find out why we
		// pass it the up button
		toolBar.add(new UpMenuButton(up));
		toolBar.add(reload = createToolButton(""reload""));
		toolBar.addSeparator();
		toolBar.add(roots = createToolButton(""roots""));
		toolBar.add(home = createToolButton(""home""));
		toolBar.add(synchronize = createToolButton(""synchronize""));
		toolBar.addSeparator();
		toolBar.add(new MoreMenuButton());
		toolBar.add(Box.createGlue());
		return toolBar;
	}
	private JButton createToolButton(String name)
	{
		JButton button = new JButton();
		String prefix = ""vfs.browser."";
		button.setIcon(GUIUtilities.loadIcon(jEdit.getProperty(
			prefix + name + "".icon"")));
		button.setToolTipText(jEdit.getProperty(prefix + name + "".label""));
		button.setRequestFocusEnabled(false);
		button.setMargin(new Insets(0,0,0,0));
		button.addActionListener(new ActionHandler());
		return button;
	}
	private void handleViewUpdate(ViewUpdate vmsg)
	{
		if(vmsg.getWhat() == ViewUpdate.CLOSED
			&& vmsg.getView() == view)
			view = null;
	}
	private void handleBufferUpdate(BufferUpdate bmsg)
	{
		if(bmsg.getWhat() == BufferUpdate.CREATED
			|| bmsg.getWhat() == BufferUpdate.CLOSED)
			browserView.updateFileView();
		else if(bmsg.getWhat() == BufferUpdate.DIRTY_CHANGED)
		{
			// if a buffer becomes clean, it means it was
			// saved. So we repaint the browser view, in
			// case it was a 'save as'
			if(!bmsg.getBuffer().isDirty())
				browserView.updateFileView();
		}
	}
	private void propertiesChanged()
	{
		showHiddenFiles = jEdit.getBooleanProperty(""vfs.browser.showHiddenFiles"");
		sortFiles = jEdit.getBooleanProperty(""vfs.browser.sortFiles"");
		sortMixFilesAndDirs = jEdit.getBooleanProperty(""vfs.browser.sortMixFilesAndDirs"");
		sortIgnoreCase = jEdit.getBooleanProperty(""vfs.browser.sortIgnoreCase"");
		doubleClickClose = jEdit.getBooleanProperty(""vfs.browser.doubleClickClose"");
		browserView.propertiesChanged();
		if(path != null)
			reloadDirectory();
	}
	/* We do this stuff because the browser is not able to handle
	 * more than one request yet */
	private boolean startRequest()
	{
		if(requestRunning)
		{
			// dump stack trace for debugging purposes
			Log.log(Log.DEBUG,this,new Throwable(""For debugging purposes""));
			GUIUtilities.error(this,""browser-multiple-io"",null);
			return false;
		}
		else
		{
			requestRunning = true;
			return true;
		}
	}
	private void updateFilterEnabled()
	{
		filterField.setEnabled(filterCheckbox.isSelected());
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == pathField || source == filterField
				|| source == filterCheckbox)
			{
				updateFilterEnabled();
				String path = pathField.getText();
				if(path != null)
					setDirectory(path);
			}
			else if(source == up)
			{
				VFS vfs = VFSManager.getVFSForPath(path);
				setDirectory(vfs.getParentOfPath(path));
			}
			else if(source == reload)
				reloadDirectory();
			else if(source == roots)
				setDirectory(FileRootsVFS.PROTOCOL + "":"");
			else if(source == home)
				setDirectory(System.getProperty(""user.home""));
			else if(source == synchronize)
			{
				if(view != null)
				{
					Buffer buffer = view.getBuffer();
					setDirectory(buffer.getVFS().getParentOfPath(
						buffer.getPath()));
				}
				else
					getToolkit().beep();
			}
		}
	}
	class UpMenuButton extends JButton
	{
		UpMenuButton(JButton upButton)
		{
			// for a better-looking GUI, we display the popup
			// as if it is from the 'up' button, not the arrow
			// to the right of it
			this.upButton = upButton;
			setIcon(GUIUtilities.loadIcon(
				jEdit.getProperty(""vfs.browser.up-menu.icon"")));
			UpMenuButton.this.setToolTipText(jEdit.getProperty(
				""vfs.browser.up-menu.label""));
			UpMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(0,0,0,0));
			UpMenuButton.this.addMouseListener(new MouseHandler());
		}
		// private members
		private JButton upButton;
		private JPopupMenu popup;
		private void createPopup()
		{
			popup = new JPopupMenu();
			ActionHandler actionHandler = new ActionHandler();
			VFS vfs = VFSManager.getVFSForPath(path);
			String dir = vfs.getParentOfPath(path);
			for(;;)
			{
				JMenuItem menuItem = new JMenuItem(dir);
				menuItem.addActionListener(actionHandler);
				popup.add(menuItem);
				String parentDir = vfs.getParentOfPath(dir);
				if(parentDir.equals(dir))
					break;
				else
					dir = parentDir;
			}
		}
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				setDirectory(evt.getActionCommand());
			}
		}
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				if(popup == null || !popup.isVisible())
				{
					createPopup();
					popup.show(upButton,0,upButton.getHeight());
				}
				else
				{
					popup.setVisible(false);
					popup = null;
				}
			}
		}
	}
	class MoreMenuButton extends JButton
	{
		MoreMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.more.label""));
			setIcon(GUIUtilities.loadIcon(jEdit.getProperty(
				""vfs.browser.more.icon"")));
			setHorizontalTextPosition(SwingConstants.LEFT);
			MoreMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(0,0,0,0));
			MoreMenuButton.this.addMouseListener(new MouseHandler());
		}
		// private members
		JPopupMenu popup;
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				if(popup == null || !popup.isVisible())
				{
					popup = new BrowserPopupMenu(VFSBrowser.this,null);
					popup.show(MoreMenuButton.this,0,MoreMenuButton.this.getHeight());
				}
				else
				{
					popup.setVisible(false);
					popup = null;
				}
			}
		}
	}
}
"
org.gjt.sp.jedit.browser.VFSFileChooserDialog,"/*
 * VFSFileChooserDialog.java - VFS file chooser
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.browser;
import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.Vector;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
/**
 * Wraps the VFS browser in a modal dialog.
 * @author Slava Pestov
 * @version $Id: VFSFileChooserDialog.java,v 1.24 2001/08/04 02:18:20 sp Exp $
 */
public class VFSFileChooserDialog extends EnhancedDialog
{
	public VFSFileChooserDialog(View view, String path,
		int mode, boolean multipleSelection)
	{
		super(view,jEdit.getProperty(""vfs.browser.title""),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		String name;
		if(path == null || path.endsWith(File.separator) || path.endsWith(""/""))
			name = null;
		else
		{
			VFS vfs = VFSManager.getVFSForPath(path);
			name = vfs.getFileName(path);
			path = vfs.getParentOfPath(path);
		}
		browser = new VFSBrowser(view,path,mode,multipleSelection);
		browser.addBrowserListener(new BrowserHandler());
		content.add(BorderLayout.CENTER,browser);
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		panel.add(new JLabel(jEdit.getProperty(""vfs.browser.dialog.filename"")));
		panel.add(Box.createHorizontalStrut(12));
		filenameField = new JTextField(20);
		filenameField.setText(name);
		filenameField.addKeyListener(new KeyHandler());
		filenameField.selectAll();
		Dimension dim = filenameField.getPreferredSize();
		dim.width = Integer.MAX_VALUE;
		filenameField.setMaximumSize(dim);
		Box box = new Box(BoxLayout.Y_AXIS);
		box.add(Box.createGlue());
		box.add(filenameField);
		box.add(Box.createGlue());
		panel.add(box);
		panel.add(Box.createHorizontalStrut(12));
		if(mode == VFSBrowser.SAVE_DIALOG)
		{
			GUIUtilities.requestFocus(this,filenameField);
		}
		else
		{
			GUIUtilities.requestFocus(this,browser.getBrowserView()
				.getDefaultFocusComponent());
		}
		ok = new JButton(jEdit.getProperty(""vfs.browser.dialog.""
			+ (mode == VFSBrowser.OPEN_DIALOG ? ""open"" : ""save"")));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		panel.add(ok);
		panel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		panel.add(cancel);
		if(mode != VFSBrowser.SAVE_DIALOG)
			panel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,panel);
		pack();
		GUIUtilities.loadGeometry(this,""vfs.browser.dialog"");
		show();
	}
	public void dispose()
	{
		GUIUtilities.saveGeometry(this,""vfs.browser.dialog"");
		super.dispose();
	}
	public void ok()
	{
		VFS.DirectoryEntry[] files = browser.getSelectedFiles();
		String directory = browser.getDirectory();
		if(files.length == 0)
		{
			filename = filenameField.getText();
			if(filename.length() == 0)
			{
				getToolkit().beep();
				return;
			}
		}
		else
		{
			for(int i = 0; i < files.length; i++)
			{
				VFS.DirectoryEntry file = files[i];
				if(file.type == VFS.DirectoryEntry.FILESYSTEM
					|| file.type == VFS.DirectoryEntry.DIRECTORY)
				{
					browser.setDirectory(file.path);
					return;
				}
				else if(browser.getMode() == VFSBrowser.SAVE_DIALOG)
					filename = file.path;
			}
		}
		if(browser.getMode() == VFSBrowser.SAVE_DIALOG)
		{
			VFS vfs = VFSManager.getVFSForPath(directory);
			filename = vfs.constructPath(directory,filename);
			if(vfs instanceof FileVFS && doFileExistsWarning(filename))
				return;
		}
		isOK = true;
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	public String[] getSelectedFiles()
	{
		if(!isOK)
			return null;
		if(filename != null)
			return new String[] { filename };
		else
		{
			Vector vector = new Vector();
			VFS.DirectoryEntry[] selectedFiles = browser.getSelectedFiles();
			for(int i = 0; i < selectedFiles.length; i++)
			{
				VFS.DirectoryEntry file =  selectedFiles[i];
				if(file.type == VFS.DirectoryEntry.FILE)
					vector.addElement(file.path);
			}
			String[] retVal = new String[vector.size()];
			vector.copyInto(retVal);
			return retVal;
		}
	}
	// private members
	private VFSBrowser browser;
	private JTextField filenameField;
	private String filename;
	private JButton ok;
	private JButton cancel;
	private boolean isOK;
	private boolean doFileExistsWarning(String filename)
	{
		if(new File(filename).exists())
		{
			String[] args = { MiscUtilities.getFileName(filename) };
			int result = GUIUtilities.confirm(browser,
				""fileexists"",args,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return true;
		}
		return false;
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				ok();
			else if(evt.getSource() == cancel)
				cancel();
		}
	}
	class BrowserHandler implements BrowserListener
	{
		public void filesSelected(VFSBrowser browser, VFS.DirectoryEntry[] files)
		{
			if(files.length == 0)
				return;
			else if(files.length == 1)
			{
				VFS.DirectoryEntry file = files[0];
				if(file.type == VFS.DirectoryEntry.FILE)
				{
					String path = file.path;
					String directory = browser.getDirectory();
					VFS vfs = VFSManager.getVFSForPath(directory);
					String parent = vfs.getParentOfPath(path);
					if(parent.endsWith(""/"") || parent.endsWith(File.separator))
						parent = parent.substring(0,parent.length() - 1);
					if(parent.equals(directory))
						path = file.name;
					filenameField.setText(path);
				}
			}
			else
			{
				filenameField.setText(null);
			}
		}
		public void filesActivated(VFSBrowser browser, VFS.DirectoryEntry[] files)
		{
			for(int i = 0; i < files.length; i++)
			{
				VFS.DirectoryEntry file = files[i];
				if(file.type == VFS.DirectoryEntry.FILESYSTEM
					|| file.type == VFS.DirectoryEntry.DIRECTORY)
				{
					// the browser will list the directory
					// in question, so just return
					return;
				}
			}
			ok();
		}
	}
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			browser.getBrowserView().selectNone();
		}
	}
}
"
org.gjt.sp.jedit.gui.AbbrevEditor,"/*
 * AbbrevEditor.java - Panel for editing abbreviations
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
public class AbbrevEditor extends JPanel
{
	public AbbrevEditor()
	{
		GridBagLayout layout = new GridBagLayout();
		setLayout(layout);
		GridBagConstraints cons = new GridBagConstraints();
		cons.anchor = cons.WEST;
		cons.fill = cons.BOTH;
		cons.weightx = 1.0f;
		cons.gridx = 1;
		cons.gridy = 1;
		JLabel label = new JLabel(jEdit.getProperty(""abbrev-editor.before""));
		label.setBorder(new EmptyBorder(6,0,3,0));
		layout.setConstraints(label,cons);
		add(label);
		cons.gridy++;
		cons.weighty = 1.0f;
		beforeCaret = new JTextArea(4,40);
		JScrollPane scroller = new JScrollPane(beforeCaret);
		layout.setConstraints(scroller,cons);
		add(scroller);
		cons.gridy++;
		cons.weighty = 0.0f;
		label = new JLabel(jEdit.getProperty(""abbrev-editor.after""));
		label.setBorder(new EmptyBorder(6,0,3,0));
		layout.setConstraints(label,cons);
		add(label);
		cons.gridy++;
		cons.weighty = 1.0f;
		afterCaret = new JTextArea(4,40);
		scroller = new JScrollPane(afterCaret);
		layout.setConstraints(scroller,cons);
		add(scroller);
	}
	public String getExpansion()
	{
		StringBuffer buf = new StringBuffer();
		String beforeCaretText = beforeCaret.getText();
		String afterCaretText = afterCaret.getText();
		for(int i = 0; i < beforeCaretText.length(); i++)
		{
			char ch = beforeCaretText.charAt(i);
			switch(ch)
			{
			case '\n':
				buf.append(""\\n"");
				break;
			case '\t':
				buf.append(""\\t"");
				break;
			case '\\':
				buf.append(""\\\\"");
				break;
			default:
				buf.append(ch);
				break;
			}
		}
		if(afterCaretText.length() != 0)
		{
			buf.append(""\\|"");
			for(int i = 0; i < afterCaretText.length(); i++)
			{
				char ch = afterCaretText.charAt(i);
				switch(ch)
				{
				case '\n':
					buf.append(""\\n"");
					break;
				case '\t':
					buf.append(""\\t"");
					break;
				case '\\':
					buf.append(""\\\\"");
					break;
				default:
					buf.append(ch);
					break;
				}
			}
		}
		return buf.toString();
	}
	public void setExpansion(String expansion)
	{
		if(expansion == null)
		{
			beforeCaret.setText(null);
			afterCaret.setText(null);
			return;
		}
		String beforeCaretText = null;
		String afterCaretText = null;
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < expansion.length(); i++)
		{
			char ch = expansion.charAt(i);
			if(ch == '\\' && i != expansion.length() - 1)
			{
				ch = expansion.charAt(++i);
				switch(ch)
				{
				case 't':
					buf.append('\t');
					break;
				case 'n':
					buf.append('\n');
					break;
				case '|':
					beforeCaretText = buf.toString();
					buf.setLength(0);
					break;
				default:
					buf.append(ch);
					break;
				}
			}
			else
				buf.append(ch);
		}
		if(beforeCaretText == null)
			beforeCaretText = buf.toString();
		else
			afterCaretText = buf.toString();
		beforeCaret.setText(beforeCaretText);
		afterCaret.setText(afterCaretText);
	}
	public JTextArea getBeforeCaretTextArea()
	{
		return beforeCaret;
	}
	public JTextArea getAfterCaretTextArea()
	{
		return afterCaret;
	}
	// private members
	private JTextArea beforeCaret, afterCaret;
}
"
org.gjt.sp.jedit.gui.AboutDialog,"/*
 * AboutDialog.java - About jEdit dialog box
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
public class AboutDialog extends EnhancedDialog
{
	public AboutDialog(View view)
	{
		super(view,jEdit.getProperty(""about.title""),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBackground(Color.white);
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JPanel panel = new JPanel(new BorderLayout());
		panel.setBackground(Color.white);
		String[] args = { jEdit.getVersion() };
		JLabel label = new JLabel(jEdit.getProperty(""about.version"",args),
			SwingConstants.CENTER);
		label.setBorder(new EmptyBorder(0,0,12,0));
		panel.add(BorderLayout.NORTH,label);
		JLabel splash = new JLabel(new ImageIcon(getClass().getResource(
			""/org/gjt/sp/jedit/jedit_logo.gif"")));
		//splash.setBorder(new MatteBorder(1,1,1,1,Color.black));
		panel.add(BorderLayout.CENTER,splash);
		label = new JLabel(jEdit.getProperty(""about.caption""),
			SwingConstants.CENTER);
		label.setBorder(new EmptyBorder(12,0,12,0));
		panel.add(BorderLayout.SOUTH,label);
		content.add(BorderLayout.CENTER,panel);
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(close);
		box.add(close);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);
		pack();
		setResizable(false);
		setLocationRelativeTo(view);
		show();
	}
	public void ok()
	{
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	// private members
	private JButton close;
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			dispose();
		}
	}
}
"
org.gjt.sp.jedit.gui.AddAbbrevDialog,"/*
 * AddAbbrevDialog.java - Displayed when expanding unknown abbrev
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
public class AddAbbrevDialog extends JDialog
{
	public AddAbbrevDialog(View view, String abbrev)
	{
		super(view,jEdit.getProperty(""add-abbrev.title""),true);
		this.view = view;
		this.abbrev = abbrev;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		content.add(BorderLayout.NORTH,new JLabel(jEdit.getProperty(
			""add-abbrev.caption"", new String[] { abbrev })));
		editor = new AbbrevEditor();
		editor.setBorder(new EmptyBorder(0,0,12,0));
		content.add(BorderLayout.CENTER,editor);
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		global = new JButton(jEdit.getProperty(""add-abbrev.global""));
		global.addActionListener(new ActionHandler());
		box.add(global);
		box.add(Box.createHorizontalStrut(6));
		modeSpecific = new JButton(jEdit.getProperty(""add-abbrev.mode""));
		modeSpecific.addActionListener(new ActionHandler());
		box.add(modeSpecific);
		box.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);
		KeyListener listener = new KeyHandler();
		addKeyListener(listener);
		editor.getBeforeCaretTextArea().addKeyListener(listener);
		editor.getAfterCaretTextArea().addKeyListener(listener);
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		GUIUtilities.requestFocus(this,editor.getBeforeCaretTextArea());
		pack();
		setLocationRelativeTo(view);
		show();
	}
	// private members
	private View view;
	private String abbrev;
	private AbbrevEditor editor;
	private JButton global;
	private JButton modeSpecific;
	private JButton cancel;
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == global)
			{
				Abbrevs.addGlobalAbbrev(abbrev,editor.getExpansion());
				Abbrevs.expandAbbrev(view,false);
			}
			else if(source == modeSpecific)
			{
				Abbrevs.addModeAbbrev(view.getBuffer().getMode().getName(),
					abbrev,editor.getExpansion());
				Abbrevs.expandAbbrev(view,false);
			}
			dispose();
		}
	}
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
				dispose();
		}
	}
}
"
org.gjt.sp.jedit.gui.BeanShellErrorDialog,"/*
 * BeanShellErrorDialog.java - BeanShell execution error dialog box
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;
public class BeanShellErrorDialog extends EnhancedDialog
{
	public BeanShellErrorDialog(View view, String message)
	{
		super(view,jEdit.getProperty(""beanshell-error.title""),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JPanel caption = new JPanel(new GridLayout(2,1,3,3));
		caption.setBorder(new EmptyBorder(0,0,3,0));
		caption.add(new JLabel(jEdit.getProperty(""beanshell-error.message.1"")));
		caption.add(new JLabel(jEdit.getProperty(""beanshell-error.message.2"")));
		content.add(BorderLayout.NORTH,caption);
		JTextArea textArea = new JTextArea(10,60);
		textArea.setText(message);
		textArea.setLineWrap(true);
		textArea.setWrapStyleWord(true);
		content.add(BorderLayout.CENTER,new JScrollPane(textArea));
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		panel.add(Box.createGlue());
		JButton ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		panel.add(ok);
		panel.add(Box.createGlue());
		content.add(panel, BorderLayout.SOUTH);
		getRootPane().setDefaultButton(ok);
		pack();
		setLocationRelativeTo(view);
		show();
	}
	// EnhancedDialog implementation
	public void ok()
	{
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	// end EnhancedDialog implementation
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			dispose();
		}
	}
}
"
org.gjt.sp.jedit.gui.BufferOptions,"/*
 * BufferOptions.java - Buffer-specific options dialog
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.msg.BufferUpdate;
import org.gjt.sp.jedit.*;
/**
 * Buffer-specific options dialog.
 * @author Slava Pestov
 * @version $Id: BufferOptions.java,v 1.25 2001/06/26 08:50:00 sp Exp $
 */
public class BufferOptions extends EnhancedDialog
{
	public BufferOptions(View view, Buffer buffer)
	{
		super(view,jEdit.getProperty(""buffer-options.title""),true);
		this.view = view;
		this.buffer = buffer;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		ActionHandler actionListener = new ActionHandler();
		JPanel panel = new JPanel();
		GridBagLayout layout = new GridBagLayout();
		panel.setLayout(layout);
		Insets nullInsets = new Insets(0,0,0,0);
		Insets labelInsets = new Insets(0,0,0,12);
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridx = cons.gridy = 0;
		cons.gridwidth = cons.gridheight = 1;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = 0.0f;
		cons.insets = labelInsets;
		// Edit mode
		cons.gridx = 0;
		cons.weightx = 0.0f;
		cons.insets = labelInsets;
		JLabel label = new JLabel(jEdit.getProperty(
			""buffer-options.mode""),SwingConstants.RIGHT);
		layout.setConstraints(label,cons);
		panel.add(label);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		cons.insets = nullInsets;
		modes = jEdit.getModes();
		String bufferMode = buffer.getMode().getName();
		int index = 0;
		String[] modeNames = new String[modes.length];
		for(int i = 0; i < modes.length; i++)
		{
			Mode mode = modes[i];
			modeNames[i] = mode.getName();
			if(bufferMode.equals(mode.getName()))
				index = i;
		}
		mode = new JComboBox(modeNames);
		mode.setSelectedIndex(index);
		mode.addActionListener(actionListener);
		layout.setConstraints(mode,cons);
		panel.add(mode);
		// Tab size
		cons.gridx = 0;
		cons.gridy = 1;
		cons.weightx = 0.0f;
		cons.insets = labelInsets;
		label = new JLabel(jEdit.getProperty(
			""options.editing.tabSize""),SwingConstants.RIGHT);
		layout.setConstraints(label,cons);
		panel.add(label);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		cons.insets = nullInsets;
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		tabSize = new JComboBox(tabSizes);
		tabSize.setEditable(true);
		tabSize.setSelectedItem(buffer.getProperty(""tabSize""));
		tabSize.addActionListener(actionListener);
		layout.setConstraints(tabSize,cons);
		panel.add(tabSize);
		// Indent size
		cons.gridx = 0;
		cons.gridy = 2;
		cons.weightx = 0.0f;
		cons.insets = labelInsets;
		label = new JLabel(jEdit.getProperty(
			""options.editing.indentSize""),SwingConstants.RIGHT);
		layout.setConstraints(label,cons);
		panel.add(label);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		cons.insets = nullInsets;
		indentSize = new JComboBox(tabSizes);
		indentSize.setEditable(true);
		indentSize.setSelectedItem(buffer.getProperty(""indentSize""));
		indentSize.addActionListener(actionListener);
		layout.setConstraints(indentSize,cons);
		panel.add(indentSize);
		// Max line length
		cons.gridx = 0;
		cons.gridy = 3;
		cons.weightx = 0.0f;
		cons.insets = labelInsets;
		label = new JLabel(jEdit.getProperty(
			""options.editing.maxLineLen""),SwingConstants.RIGHT);
		layout.setConstraints(label,cons);
		panel.add(label);
		String[] lineLengths = { ""0"", ""72"", ""76"", ""80"" };
		cons.gridx = 1;
		cons.weightx = 1.0f;
		cons.insets = nullInsets;
		maxLineLen = new JComboBox(lineLengths);
		maxLineLen.setEditable(true);
		maxLineLen.setSelectedItem(buffer.getProperty(""maxLineLen""));
		maxLineLen.addActionListener(actionListener);
		layout.setConstraints(maxLineLen,cons);
		panel.add(maxLineLen);
		// Line separator
		cons.gridx = 0;
		cons.gridy = 4;
		cons.weightx = 0.0f;
		cons.insets = labelInsets;
		label = new JLabel(jEdit.getProperty(""buffer-options.lineSeparator""),
			SwingConstants.RIGHT);
		layout.setConstraints(label,cons);
		panel.add(label);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		cons.insets = nullInsets;
		String[] lineSeps = { jEdit.getProperty(""lineSep.unix""),
			jEdit.getProperty(""lineSep.windows""),
			jEdit.getProperty(""lineSep.mac"") };
		lineSeparator = new JComboBox(lineSeps);
		String lineSep = (String)buffer.getProperty(Buffer.LINESEP);
		if(lineSep == null)
			lineSep = System.getProperty(""line.separator"");
		if(""\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(0);
		else if(""\r\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(1);
		else if(""\r"".equals(lineSep))
			lineSeparator.setSelectedIndex(2);
		lineSeparator.addActionListener(actionListener);
		layout.setConstraints(lineSeparator,cons);
		panel.add(lineSeparator);
		// Encoding
		cons.gridx = 0;
		cons.gridy = 5;
		cons.weightx = 0.0f;
		cons.insets = labelInsets;
		label = new JLabel(jEdit.getProperty(""buffer-options.encoding""),
			SwingConstants.RIGHT);
		layout.setConstraints(label,cons);
		panel.add(label);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		cons.insets = nullInsets;
		DefaultComboBoxModel encodings = new DefaultComboBoxModel();
		StringTokenizer st = new StringTokenizer(jEdit.getProperty(""encodings""));
		while(st.hasMoreTokens())
		{
			encodings.addElement(st.nextToken());
		}
		encoding = new JComboBox(encodings);
		encoding.setEditable(true);
		encoding.setSelectedItem(buffer.getProperty(Buffer.ENCODING));
		layout.setConstraints(encoding,cons);
		panel.add(encoding);
		// Syntax highlighting
		cons.gridx = 0;
		cons.gridy = 6;
		cons.weightx = 0.0f;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = GridBagConstraints.NONE;
		cons.anchor = GridBagConstraints.WEST;
		syntax = new JCheckBox(jEdit.getProperty(
			""options.editing.syntax""));
		syntax.setSelected(buffer.getBooleanProperty(""syntax""));
		syntax.addActionListener(actionListener);
		layout.setConstraints(syntax,cons);
		panel.add(syntax);
		// Indent on tab
		cons.gridy = 7;
		indentOnTab = new JCheckBox(jEdit.getProperty(
			""options.editing.indentOnTab""));
		indentOnTab.setSelected(buffer.getBooleanProperty(""indentOnTab""));
		indentOnTab.addActionListener(actionListener);
		layout.setConstraints(indentOnTab,cons);
		panel.add(indentOnTab);
		// Indent on enter
		cons.gridy = 8;
		indentOnEnter = new JCheckBox(jEdit.getProperty(
			""options.editing.indentOnEnter""));
		indentOnEnter.setSelected(buffer.getBooleanProperty(""indentOnEnter""));
		indentOnEnter.addActionListener(actionListener);
		layout.setConstraints(indentOnEnter,cons);
		panel.add(indentOnEnter);
		// Soft tabs
		cons.gridy = 9;
		noTabs = new JCheckBox(jEdit.getProperty(
			""options.editing.noTabs""));
		noTabs.setSelected(buffer.getBooleanProperty(""noTabs""));
		noTabs.addActionListener(actionListener);
		layout.setConstraints(noTabs,cons);
		panel.add(noTabs);
		// Props label
		cons.gridy = 10;
		cons.insets = new Insets(6,0,6,0);
		label = new JLabel(jEdit.getProperty(""buffer-options.props""));
		layout.setConstraints(label,cons);
		panel.add(label);
		content.add(BorderLayout.NORTH,panel);
		props = new JTextArea(4,4);
		props.setLineWrap(true);
		props.setWrapStyleWord(false);
		content.add(BorderLayout.CENTER,new JScrollPane(props));
		updatePropsField();
		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		panel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionListener);
		getRootPane().setDefaultButton(ok);
		panel.add(ok);
		panel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionListener);
		panel.add(cancel);
		panel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,panel);
		pack();
		setLocationRelativeTo(view);
		show();
	}
	// EnhancedDialog implementation
	public void ok()
	{
		try
		{
			buffer.putProperty(""tabSize"",new Integer(
				tabSize.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}
		try
		{
			buffer.putProperty(""indentSize"",new Integer(
				indentSize.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}
		try
		{
			buffer.putProperty(""maxLineLen"",new Integer(
				maxLineLen.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}
		int index = mode.getSelectedIndex();
		buffer.setMode(modes[index]);
		index = lineSeparator.getSelectedIndex();
		String lineSep;
		if(index == 0)
			lineSep = ""\n"";
		else if(index == 1)
			lineSep = ""\r\n"";
		else if(index == 2)
			lineSep = ""\r"";
		else
			throw new InternalError();
		String oldLineSep = (String)buffer.getProperty(Buffer.LINESEP);
		if(oldLineSep == null)
			oldLineSep = System.getProperty(""line.separator"");
		if(!oldLineSep.equals(lineSep))
		{
			buffer.putProperty(""lineSeparator"",lineSep);
			buffer.setDirty(true);
		}
		String encoding = (String)this.encoding.getSelectedItem();
		String oldEncoding = (String)buffer.getProperty(Buffer.ENCODING);
		if(!oldEncoding.equals(encoding))
		{
			buffer.putProperty(Buffer.ENCODING,encoding);
			buffer.setDirty(true);
			// XXX this should be moved elsewhere!!!
			EditBus.send(new BufferUpdate(buffer,view,BufferUpdate.ENCODING_CHANGED));
		}
		buffer.putBooleanProperty(""syntax"",syntax.isSelected());
		buffer.putBooleanProperty(""indentOnTab"",indentOnTab.isSelected());
		buffer.putBooleanProperty(""indentOnEnter"",indentOnEnter.isSelected());
		buffer.putBooleanProperty(""noTabs"",noTabs.isSelected());
		buffer.propertiesChanged();
		dispose();
		// Update text area
		view.getTextArea().getPainter().repaint();
	}
	public void cancel()
	{
		dispose();
	}
	// end EnhancedDialog implementation
        // private members
	private View view;
	private Buffer buffer;
	private JComboBox tabSize;
	private JComboBox indentSize;
	private JComboBox maxLineLen;
	private Mode[] modes;
	private JComboBox mode;
	private JComboBox lineSeparator;
	private JComboBox encoding;
	private JCheckBox indentOnTab;
	private JCheckBox indentOnEnter;
	private JCheckBox syntax;
	private JCheckBox noTabs;
	private JTextArea props;
	private JButton ok;
	private JButton cancel;
	private void updatePropsField()
	{
		props.setText("":mode="" + modes[mode.getSelectedIndex()].getName()
			+ "":tabSize="" + tabSize.getSelectedItem()
			+ "":indentSize="" + indentSize.getSelectedItem()
			+ "":noTabs="" + noTabs.isSelected()
			+ "":indentOnTab="" + indentOnTab.isSelected()
			+ "":indentOnEnter="" + indentOnEnter.isSelected()
			+ "":syntax="" + syntax.isSelected()
			+ "":maxLineLen="" + maxLineLen.getSelectedItem()
			+ "":"");
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == mode)
			{
				Mode _mode = jEdit.getMode((String)
					mode.getSelectedItem());
				tabSize.setSelectedItem(_mode.getProperty(
					""tabSize""));
				indentSize.setSelectedItem(_mode.getProperty(
					""indentSize""));
				maxLineLen.setSelectedItem(_mode.getProperty(
					""maxLineLen""));
				indentOnTab.setSelected(_mode.getBooleanProperty(
					""indentOnTab""));
				indentOnEnter.setSelected(_mode.getBooleanProperty(
					""indentOnEnter""));
				syntax.setSelected(_mode.getBooleanProperty(
					""syntax""));
				noTabs.setSelected(_mode.getBooleanProperty(
					""noTabs""));
				updatePropsField();
			}
			else
				updatePropsField();
		}
	}
}
"
org.gjt.sp.jedit.gui.BufferSwitcher,"/*
 * BufferSwitcher.java - Status bar
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;
public class BufferSwitcher extends JComboBox
{
	public BufferSwitcher(EditPane editPane)
	{
		this.editPane = editPane;
		//setFont(new Font(""Dialog"",Font.BOLD,10));
		setRenderer(new BufferCellRenderer());
		setMaximumRowCount(10);
		addActionListener(new ActionHandler());
	}
	public void updateBufferList()
	{
		// if the buffer count becomes 0, then it is guaranteed to
		// become 1 very soon, so don't do anything in that case.
		if(jEdit.getBufferCount() == 0)
			return;
		updating = true;
		setModel(new DefaultComboBoxModel(jEdit.getBuffers()));
		setSelectedItem(editPane.getBuffer());
		updating = false;
	}
	// private members
	private EditPane editPane;
	private boolean updating;
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(!updating)
			{
				Buffer buffer = (Buffer)getSelectedItem();
				if(buffer != null)
					editPane.setBuffer(buffer);
			}
		}
	}
	class BufferCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);
			Buffer buffer = (Buffer)value;
			if(buffer == null)
				setIcon(null);
			else
				setIcon(buffer.getIcon());
			return this;
		}
	}
}
"
org.gjt.sp.jedit.gui.CloseDialog,"/*
 * CloseDialog.java - Close all buffers dialog
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
public class CloseDialog extends EnhancedDialog
{
	public CloseDialog(View view)
	{
		super(view,jEdit.getProperty(""close.title""),true);
		this.view = view;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JLabel label = new JLabel(jEdit.getProperty(""close.caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		content.add(BorderLayout.NORTH,label);
		bufferList = new JList(bufferModel = new DefaultListModel());
		bufferList.setVisibleRowCount(10);
		bufferList.addListSelectionListener(new ListHandler());
		Buffer[] buffers = jEdit.getBuffers();
		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			if(buffer.isDirty())
			{
				bufferModel.addElement(buffer.getPath());
			}
		}
		content.add(BorderLayout.CENTER,new JScrollPane(bufferList));
		ActionHandler actionListener = new ActionHandler();
		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons, BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.add(Box.createGlue());
		buttons.add(save = new JButton(jEdit.getProperty(""close.save"")));
		save.setMnemonic(jEdit.getProperty(""close.save.mnemonic"").charAt(0));
		save.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(discard = new JButton(jEdit.getProperty(""close.discard"")));
		discard.setMnemonic(jEdit.getProperty(""close.discard.mnemonic"").charAt(0));
		discard.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(cancel = new JButton(jEdit.getProperty(""common.cancel"")));
		cancel.addActionListener(actionListener);
		buttons.add(Box.createGlue());
		bufferList.setSelectedIndex(0);
		content.add(BorderLayout.SOUTH,buttons);
		GUIUtilities.requestFocus(this,bufferList);
		pack();
		setLocationRelativeTo(view);
		show();
	}
	public boolean isOK()
	{
		return ok;
	}
	// EnhancedDialog implementation
	public void ok()
	{
		// do nothing
	}
	public void cancel()
	{
		dispose();
	}
	// end EnhancedDialog implementation
	// private members
	private View view;
	private JList bufferList;
	private DefaultListModel bufferModel;
	private JButton save;
	private JButton discard;
	private JButton cancel;
	private boolean ok; // only set if all buffers saved/closed
	private void updateButtons()
	{
		int index = bufferList.getSelectedIndex();
		save.getModel().setEnabled(index != -1);
		discard.getModel().setEnabled(index != -1);
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == save)
			{
				Object[] paths = bufferList.getSelectedValues();
				for(int i = 0; i < paths.length; i++)
				{
					String path = (String)paths[i];
					Buffer buffer = jEdit.getBuffer(path);
					if(!buffer.save(view,null,true))
						return;
					VFSManager.waitForRequests();
					jEdit._closeBuffer(view,buffer);
					bufferModel.removeElement(path);
				}
				updateButtons();
				if(bufferModel.getSize() == 0)
				{
					ok = true;
					dispose();
				}
			}
			else if(source == discard)
			{
				Object[] paths = bufferList.getSelectedValues();
				for(int i = 0; i < paths.length; i++)
				{
					String path = (String)paths[i];
					Buffer buffer = jEdit.getBuffer(path);
					jEdit._closeBuffer(view,buffer);
					bufferModel.removeElement(path);
				}
				updateButtons();
				if(bufferModel.getSize() == 0)
				{
					ok = true;
					dispose();
				}
			}
			else if(source == cancel)
				cancel();
		}
	}
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			int index = bufferList.getSelectedIndex();
			if(index != -1)
				view.setBuffer(jEdit.getBuffer((String)
					bufferModel.getElementAt(index)));
			updateButtons();
		}
	}
}
"
org.gjt.sp.jedit.gui.CompleteWord,"/*
 * CompleteWord.java - Complete word dialog
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
public class CompleteWord extends JWindow
{
	public CompleteWord(View view, String word, Vector completions,
		Point location)
	{
		super(view);
		this.view = view;
		this.word = word;
		words = new JList(completions);
		words.setVisibleRowCount(Math.min(completions.size(),8));
		words.addMouseListener(new MouseHandler());
		words.setSelectedIndex(0);
		words.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		// stupid scrollbar policy is an attempt to work around
		// bugs people have been seeing with IBM's JDK -- 7 Sep 2000
		JScrollPane scroller = new JScrollPane(words,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		getContentPane().add(scroller, BorderLayout.CENTER);
		GUIUtilities.requestFocus(this,words);
		pack();
		setLocation(location);
		show();
		KeyHandler keyHandler = new KeyHandler();
		addKeyListener(keyHandler);
		getRootPane().addKeyListener(keyHandler);
		words.addKeyListener(keyHandler);
		view.setKeyEventInterceptor(keyHandler);
	}
	public void dispose()
	{
		view.setKeyEventInterceptor(null);
		super.dispose();
	}
	// private members
	private View view;
	private String word;
	private JList words;
	private void insertSelected()
	{
		view.getTextArea().setSelectedText(((String)words
			.getSelectedValue()).substring(word.length()));
		dispose();
	}
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_TAB:
			case KeyEvent.VK_ENTER:
				insertSelected();
				evt.consume();
				break;
			case KeyEvent.VK_ESCAPE:
				dispose();
				evt.consume();
				break;
			case KeyEvent.VK_UP:
				if(getFocusOwner() == words)
					return;
				int selected = words.getSelectedIndex();
				if(selected == 0)
					return;
				selected = selected - 1;
				words.setSelectedIndex(selected);
				words.ensureIndexIsVisible(selected);
				evt.consume();
				break;
			case KeyEvent.VK_DOWN:
				if(getFocusOwner() == words)
					return;
				selected = words.getSelectedIndex();
				if(selected == words.getModel().getSize() - 1)
					return;
				selected = selected + 1;
				words.setSelectedIndex(selected);
				words.ensureIndexIsVisible(selected);
				evt.consume();
				break;
			default:
				dispose();
				view.processKeyEvent(evt);
				break;
			}
		}
		public void keyTyped(KeyEvent evt)
		{
			evt = KeyEventWorkaround.processKeyEvent(evt);
			if(evt == null)
				return;
			else
			{
				dispose();
				view.processKeyEvent(evt);
			}
		}
	}
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			insertSelected();
		}
	}
}
"
org.gjt.sp.jedit.gui.CurrentDirectoryMenu,"/*
 * CurrentDirectoryMenu.java - File list menu
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.io.File;
import org.gjt.sp.jedit.*;
public class CurrentDirectoryMenu extends EnhancedMenu
{
	public CurrentDirectoryMenu()
	{
		super(""current-directory"");
	}
	public void setPopupMenuVisible(boolean b)
	{
		if(b)
		{
			final View view = EditAction.getView(this);
			if(getMenuComponentCount() != 0)
				removeAll();
			File file = view.getBuffer().getFile();
			if(file == null)
			{
				JMenuItem mi = new JMenuItem(jEdit.getProperty(
					""current-directory.not-local""));
				mi.setEnabled(false);
				add(mi);
				super.setPopupMenuVisible(b);
				return;
			}
			File dir = new File(file.getParent());
			JMenuItem mi = new JMenuItem(dir.getPath());
			mi.setEnabled(false);
			add(mi);
			addSeparator();
			JMenu current = this;
			ActionListener listener = new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					jEdit.openFile(view,evt.getActionCommand());
				}
			};
			// for filtering out backups
			String backupPrefix = jEdit.getProperty(""backup.prefix"");
			String backupSuffix = jEdit.getProperty(""backup.suffix"");
			String[] list = dir.list();
			if(list != null)
			{
				MiscUtilities.quicksort(list,
					new MiscUtilities.StringICaseCompare());
				for(int i = 0; i < list.length; i++)
				{
					String name = list[i];
					// skip marker files
					if(name.endsWith("".marks""))
						continue;
					// skip autosave files
					if(name.startsWith(""#"") && name.endsWith(""#""))
						continue;
					// skip backup files
					if((backupPrefix.length() != 0
						&& name.startsWith(backupPrefix))
						|| (backupSuffix.length() != 0
						&& name.endsWith(backupSuffix)))
						continue;
					// skip directories
					file = new File(dir,name);
					if(file.isDirectory())
						continue;
					mi = new JMenuItem(name);
					mi.setActionCommand(file.getPath());
					mi.addActionListener(listener);
					if(current.getItemCount() >= 20)
					{
						//current.addSeparator();
						JMenu newCurrent = new JMenu(
							jEdit.getProperty(
							""common.more""));
						current.add(newCurrent);
						current = newCurrent;
					}
					current.add(mi);
				}
			}
		}
		super.setPopupMenuVisible(b);
	}
}
"
org.gjt.sp.jedit.gui.DefaultInputHandler,"/*
 * DefaultInputHandler.java - Default implementation of an input handler
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.KeyStroke;
import java.awt.event.*;
import java.awt.Toolkit;
import java.util.Hashtable;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * The default input handler. It maps sequences of keystrokes into actions
 * and inserts key typed events into the text area.
 * @author Slava Pestov
 * @version $Id: DefaultInputHandler.java,v 1.19 2001/08/10 10:35:11 sp Exp $
 */
public class DefaultInputHandler extends InputHandler
{
	/**
	 * Creates a new input handler with no key bindings defined.
	 * @param view The view
	 */
	public DefaultInputHandler(View view)
	{
		super(view);
		bindings = currentBindings = new Hashtable();
	}
	/**
	 * Creates a new input handler with the same set of key bindings
	 * as the one specified. Note that both input handlers share
	 * a pointer to exactly the same key binding table; so adding
	 * a key binding in one will also add it to the other.
	 * @param copy The input handler to copy key bindings from
	 * @param view The view
	 */
	public DefaultInputHandler(View view, DefaultInputHandler copy)
	{
		super(view);
		bindings = currentBindings = copy.bindings;
	}
	/**
	 * Adds a key binding to this input handler. The key binding is
	 * a list of white space separated key strokes of the form
	 * <i>[modifiers+]key</i> where modifier is C for Control, A for Alt,
	 * or S for Shift, and key is either a character (a-z) or a field
	 * name in the KeyEvent class prefixed with VK_ (e.g., BACK_SPACE)
	 * @param keyBinding The key binding
	 * @param action The action
	 */
	public void addKeyBinding(String keyBinding, EditAction action)
	{
	        Hashtable current = bindings;
		StringTokenizer st = new StringTokenizer(keyBinding);
		while(st.hasMoreTokens())
		{
			KeyStroke keyStroke = parseKeyStroke(st.nextToken());
			if(keyStroke == null)
				return;
			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
					current = (Hashtable)o;
				else
				{
					o = new Hashtable();
					current.put(keyStroke,o);
					current = (Hashtable)o;
				}
			}
			else
				current.put(keyStroke,action);
		}
	}
	/**
	 * Removes a key binding from this input handler. This is not yet
	 * implemented.
	 * @param keyBinding The key binding
	 */
	public void removeKeyBinding(String keyBinding)
	{
		throw new InternalError(""Not yet implemented"");
	}
	/**
	 * Removes all key bindings from this input handler.
	 */
	public void removeAllKeyBindings()
	{
		bindings.clear();
	}
	/**
	 * Returns either an edit action, or a hashtable if the specified key
	 * is a prefix.
	 * @param keyBinding The key binding
	 * @since jEdit 3.2pre5
	 */
	public Object getKeyBinding(String keyBinding)
	{
		Hashtable current = bindings;
		StringTokenizer st = new StringTokenizer(keyBinding);
		while(st.hasMoreTokens())
		{
			KeyStroke keyStroke = parseKeyStroke(st.nextToken());
			if(keyStroke == null)
				return null;
			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
					current = (Hashtable)o;
				else
					return o;
			}
			else
			{
				return current.get(keyStroke);
			}
		}
		return null;
	}
	/**
	 * Returns if a prefix key has been pressed.
	 */
	public boolean isPrefixActive()
	{
		return bindings != currentBindings;
	}
	/**
	 * Handle a key pressed event. This will look up the binding for
	 * the key stroke and execute it.
	 */
	public void keyPressed(KeyEvent evt)
	{
		int keyCode = evt.getKeyCode();
		int modifiers = evt.getModifiers();
		if(modifiers == 0
			&& bindings == currentBindings
			&& (keyCode == KeyEvent.VK_ENTER
			|| keyCode == KeyEvent.VK_TAB))
		{
			userInput((char)keyCode);
			evt.consume();
			return;
		}
		if((modifiers & ~KeyEvent.SHIFT_MASK) == 0)
		{
			// if modifier active, handle all keys, otherwise
			// only some
			switch(keyCode)
			{
			case KeyEvent.VK_BACK_SPACE:
			case KeyEvent.VK_DELETE:
			case KeyEvent.VK_ESCAPE:
			case KeyEvent.VK_ENTER:
			case KeyEvent.VK_TAB:
				break;
			default:
				if(!evt.isActionKey())
					return;
				else
					break;
			}
		}
		if(readNextChar != null)
		{
			readNextChar = null;
			view.getStatus().setMessage(null);
		}
		KeyStroke keyStroke = KeyStroke.getKeyStroke(keyCode,
			modifiers);
		Object o = currentBindings.get(keyStroke);
		if(o == null)
		{
			// Don't beep if the user presses some
			// key we don't know about unless a
			// prefix is active. Otherwise it will
			// beep when caps lock is pressed, etc.
			if(currentBindings != bindings)
			{
				Toolkit.getDefaultToolkit().beep();
				// F10 should be passed on, but C+e F10
				// shouldn't
				repeatCount = 0;
				repeat = false;
				evt.consume();
			}
			currentBindings = bindings;
			return;
		}
		else if(o instanceof EditAction)
		{
			currentBindings = bindings;
			invokeAction((EditAction)o);
			evt.consume();
			return;
		}
		else if(o instanceof Hashtable)
		{
			currentBindings = (Hashtable)o;
			evt.consume();
			return;
		}
	}
	/**
	 * Handle a key typed event. This inserts the key into the text area.
	 */
	public void keyTyped(KeyEvent evt)
	{
		char c = evt.getKeyChar();
		// ignore
		if(c == '\b')
			return;
		KeyStroke keyStroke;
		// this is a hack. a literal space is impossible to
		// insert in a key binding string, but you can write
		// SPACE.
		if(c == ' ')
			keyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_SPACE,0);
		else
			keyStroke = KeyStroke.getKeyStroke(c);
		Object o = currentBindings.get(keyStroke);
		if(o instanceof Hashtable)
		{
			currentBindings = (Hashtable)o;
			return;
		}
		else if(o instanceof EditAction)
		{
			currentBindings = bindings;
			invokeAction((EditAction)o);
			return;
		}
		// otherwise, reset to default map and do user input
		currentBindings = bindings;
		if(repeat && Character.isDigit(c))
		{
			repeatCount *= 10;
			repeatCount += (c - '0');
			view.getStatus().setMessage(null);
		}
		else
			userInput(c);
	}
	/**
	 * Converts a string to a keystroke. The string should be of the
	 * form <i>modifiers</i>+<i>shortcut</i> where <i>modifiers</i>
	 * is any combination of A for Alt, C for Control, S for Shift
	 * or M for Meta, and <i>shortcut</i> is either a single character,
	 * or a keycode name from the <code>KeyEvent</code> class, without
	 * the <code>VK_</code> prefix.
	 * @param keyStroke A string description of the key stroke
	 */
	public static KeyStroke parseKeyStroke(String keyStroke)
	{
		if(keyStroke == null)
			return null;
		int modifiers = 0;
		int index = keyStroke.indexOf('+');
		if(index != -1)
		{
			for(int i = 0; i < index; i++)
			{
				switch(Character.toUpperCase(keyStroke
					.charAt(i)))
				{
				case 'A':
					modifiers |= InputEvent.ALT_MASK;
					break;
				case 'C':
					if(macOS)
						modifiers |= InputEvent.META_MASK;
					else
						modifiers |= InputEvent.CTRL_MASK;
					break;
				case 'M':
					if(macOS)
						modifiers |= InputEvent.CTRL_MASK;
					else
						modifiers |= InputEvent.META_MASK;
					break;
				case 'S':
					modifiers |= InputEvent.SHIFT_MASK;
					break;
				}
			}
		}
		String key = keyStroke.substring(index + 1);
		if(key.length() == 1)
		{
			char ch = key.charAt(0);
			if(modifiers == 0)
				return KeyStroke.getKeyStroke(ch);
			else
			{
				return KeyStroke.getKeyStroke(Character.toUpperCase(ch),
					modifiers);
			}
		}
		else if(key.length() == 0)
		{
			Log.log(Log.ERROR,DefaultInputHandler.class,
				""Invalid key stroke: "" + keyStroke);
			return null;
		}
		else
		{
			int ch;
			try
			{
				ch = KeyEvent.class.getField(""VK_"".concat(key))
					.getInt(null);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,DefaultInputHandler.class,
					""Invalid key stroke: ""
					+ keyStroke);
				return null;
			}
			return KeyStroke.getKeyStroke(ch,modifiers);
		}
	}
	// private members
	private Hashtable bindings;
	private Hashtable currentBindings;
	private static boolean macOS;
	static
	{
		macOS = (System.getProperty(""os.name"").indexOf(""MacOS"") != -1);
	}
}
"
org.gjt.sp.jedit.gui.DockableWindow,"/*
 * DockableWindow.java - a window that can either float, or be inside a view
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import java.awt.Component;
/**
 * A window that can either be docked inside a view, or float outside it.
 * @author Slava Pestov
 * @version $Id: DockableWindow.java,v 1.1 2000/08/13 07:35:24 sp Exp $
 * @since jEdit 2.6pre3
 */
public interface DockableWindow
{
	/**
	 * Named list storing the names of all known dockable windows.
	 * @since jEdit 2.6pre3
	 */
	String DOCKABLE_WINDOW_LIST = ""DOCKABLE_WINDOWS"";
	/**
	 * Returns the name of this dockable window. This is used to load/save
	 * geometry, and obtain the <code>dockable.<i>name</i>.label</code>
	 * property.
	 * @since jEdit 2.6pre3
	 */
	String getName();
	/**
	 * Returns the actual component.
	 * @since jEdit 2.6pre3
	 */
	Component getComponent();
}
/*
 * Change Log:
 * $Log: DockableWindow.java,v $
 * Revision 1.1  2000/08/13 07:35:24  sp
 * Dockable window API
 *
 */
"
org.gjt.sp.jedit.gui.DockableWindowContainer,"/*
 * DockableWindowContainer.java - holds dockable windows
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.plaf.metal.MetalLookAndFeel;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
/**
 * A container for dockable windows. This class should never be used
 * directly.
 * @author Slava Pestov
 * @version $Id: DockableWindowContainer.java,v 1.21 2001/04/18 03:09:45 sp Exp $
 * @since jEdit 2.6pre3
 */
public interface DockableWindowContainer
{
	void addDockableWindow(DockableWindow win);
	void saveDockableWindow(DockableWindow win);
	void removeDockableWindow(DockableWindow win);
	void showDockableWindow(DockableWindow win);
	boolean isDockableWindowVisible(DockableWindow win);
	/**
	 * Tabbed pane container.
	 */
	public class TabbedPane extends JTabbedPane implements DockableWindowContainer
	{
		public static final int SPLITTER_WIDTH = 10;
		String position;
		int dimension;
		boolean collapsed;
		public TabbedPane(String position)
		{
			this.position = position;
			try
			{
				dimension = Integer.parseInt(jEdit.getProperty(
					""view.dock."" + position + "".dimension""));
			}
			catch(NumberFormatException nf)
			{
				dimension = -1;
			}
			if(dimension <= SPLITTER_WIDTH)
				collapsed = true;
			collapsed = jEdit.getBooleanProperty(""view.dock.""
				+ position + "".collapsed"");
			MouseHandler mouseHandler = new MouseHandler();
			addMouseListener(mouseHandler);
			addMouseMotionListener(mouseHandler);
			propertiesChanged();
		}
		public boolean isCollapsed()
		{
			return getComponentCount() == 0 || collapsed;
		}
		public void setCollapsed(boolean collapsed)
		{
			if(getComponentCount() == 0)
				return;
			if(dimension <= SPLITTER_WIDTH)
				dimension = -1;
			this.collapsed = collapsed;
			revalidate();
		}
		public void toggleCollapsed()
		{
			setCollapsed(!collapsed);
		}
		public void saveDimension()
		{
			jEdit.setProperty(""view.dock."" + position + "".dimension"",
				String.valueOf(dimension));
			jEdit.setBooleanProperty(""view.dock."" + position
				+ "".collapsed"",collapsed);
		}
		public void propertiesChanged()
		{
			setBorder(new DockBorder(position));
			int tabsPos = Integer.parseInt(jEdit.getProperty(
				""view.docking.tabsPos""));
			if(tabsPos == 0)
				setTabPlacement(JTabbedPane.TOP);
			else if(tabsPos == 1)
				setTabPlacement(JTabbedPane.BOTTOM);
		}
		public Dimension getMinimumSize()
		{
			return new Dimension(0,0);
		}
		public Dimension getPreferredSize()
		{
			if(getComponentCount() == 0)
				return new Dimension(0,0);
			Dimension prefSize = super.getPreferredSize();
			if(collapsed)
			{
				if(position.equals(DockableWindowManager.LEFT)
					|| position.equals(DockableWindowManager.RIGHT))
					prefSize.width = SPLITTER_WIDTH;
				else if(position.equals(DockableWindowManager.TOP)
					|| position.equals(DockableWindowManager.BOTTOM))
					prefSize.height = SPLITTER_WIDTH;
			}
			else if(dimension <= SPLITTER_WIDTH)
			{
				if(position.equals(DockableWindowManager.LEFT)
					|| position.equals(DockableWindowManager.RIGHT))
					dimension = prefSize.width;
				else if(position.equals(DockableWindowManager.TOP)
					|| position.equals(DockableWindowManager.BOTTOM))
					 dimension = prefSize.height;
			}
			else
			{
				if(position.equals(DockableWindowManager.LEFT)
					|| position.equals(DockableWindowManager.RIGHT))
					prefSize.width = dimension;
				else if(position.equals(DockableWindowManager.TOP)
					|| position.equals(DockableWindowManager.BOTTOM))
					prefSize.height = dimension;
			}
			return prefSize;
		}
		public void addDockableWindow(DockableWindow win)
		{
			addTab(jEdit.getProperty(win.getName()
				+ "".title""),win.getComponent());
			setSelectedComponent(win.getComponent());
			collapsed = false;
			revalidate();
		}
		public void saveDockableWindow(DockableWindow win) {}
		public void removeDockableWindow(DockableWindow win)
		{
			remove(win.getComponent());
			revalidate();
		}
		public void showDockableWindow(DockableWindow win)
		{
			setSelectedComponent(win.getComponent());
			if(collapsed)
			{
				collapsed = false;
				revalidate();
			}
			win.getComponent().requestFocus();
		}
		public boolean isDockableWindowVisible(DockableWindow win)
		{
			return !collapsed;
		}
		class MouseHandler extends MouseAdapter implements MouseMotionListener
		{
			boolean canDrag;
			int dragStartDimension;
			Point dragStart;
			public void mousePressed(MouseEvent evt)
			{
				dragStartDimension = dimension;
				dragStart = evt.getPoint();
				dragStart.x = (getWidth() - dragStart.x);
				dragStart.y = (getHeight() - dragStart.y);
			}
			public void mouseClicked(MouseEvent evt)
			{
				if(evt.getClickCount() == 2)
					setCollapsed(!isCollapsed());
			}
			public void mouseMoved(MouseEvent evt)
			{
				Border border = getBorder();
				Insets insets = border.getBorderInsets(TabbedPane.this);
				int cursor = Cursor.DEFAULT_CURSOR;
				canDrag = false;
				if(position.equals(DockableWindowManager.TOP))
				{
					if(evt.getY() >= getHeight() - insets.bottom)
					{
						cursor = Cursor.N_RESIZE_CURSOR;
						canDrag = true;
					}
				}
				else if(position.equals(DockableWindowManager.LEFT))
				{
					if(evt.getX() >= getWidth() - insets.right)
					{
						cursor = Cursor.W_RESIZE_CURSOR;
						canDrag = true;
					}
				}
				else if(position.equals(DockableWindowManager.BOTTOM))
				{
					if(evt.getY() <= insets.top)
					{
						cursor = Cursor.S_RESIZE_CURSOR;
						canDrag = true;
					}
				}
				else if(position.equals(DockableWindowManager.RIGHT))
				{
					if(evt.getX() <= insets.left)
					{
						cursor = Cursor.E_RESIZE_CURSOR;
						canDrag = true;
					}
				}
				setCursor(Cursor.getPredefinedCursor(cursor));
			}
			public void mouseDragged(MouseEvent evt)
			{
				if(!canDrag)
					return;
				if(dragStart == null) // can't happen?
					return;
				if(position.equals(DockableWindowManager.TOP))
					dimension = evt.getY() + dragStart.y;
				else if(position.equals(DockableWindowManager.LEFT))
					dimension = evt.getX() + dragStart.x;
				else if(position.equals(DockableWindowManager.BOTTOM))
				{
					dimension = getHeight() - (/* dragStart.y
						- */ evt.getY());
				}
				else if(position.equals(DockableWindowManager.RIGHT))
				{
					dimension = getWidth() - (/* dragStart.x
						- */ evt.getX());
				}
				dimension = Math.max(SPLITTER_WIDTH,dimension);
				if(dimension == SPLITTER_WIDTH)
				{
					dimension = dragStartDimension;
					collapsed = true;
				}
				else
					collapsed = false;
				revalidate();
			}
			public void mouseExited(MouseEvent evt)
			{
				setCursor(Cursor.getPredefinedCursor(
					Cursor.DEFAULT_CURSOR));
			}
		}
		static class DockBorder implements Border
		{
			String position;
			Insets insets;
			Color color1;
			Color color2;
			Color color3;
			DockBorder(String position)
			{
				if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)
				{
					color1 = MetalLookAndFeel.getControlHighlight();
					color2 = MetalLookAndFeel.getControlDarkShadow();
					color3 = MetalLookAndFeel.getControl();
				}
				else
				{
					color1 = color2 = null;
					color3 = GUIUtilities.parseColor(
						jEdit.getProperty(
						""view.docking.borderColor""));
				}
				this.position = position;
				insets = new Insets(
					position.equals(DockableWindowManager.BOTTOM)
						? SPLITTER_WIDTH : 0,
					position.equals(DockableWindowManager.RIGHT)
						? SPLITTER_WIDTH : 0,
					position.equals(DockableWindowManager.TOP)
						? SPLITTER_WIDTH : 0,
					position.equals(DockableWindowManager.LEFT)
						? SPLITTER_WIDTH : 0);
			}
			public void paintBorder(Component c, Graphics g,
				int x, int y, int width, int height)
			{
				if(position.equals(DockableWindowManager.BOTTOM))
					paintHorizBorder(g,x,y,width);
				else if(position.equals(DockableWindowManager.RIGHT))
					paintVertBorder(g,x,y,height);
				else if(position.equals(DockableWindowManager.TOP))
				{
					paintHorizBorder(g,x,y + height
						- SPLITTER_WIDTH,width);
				}
				else if(position.equals(DockableWindowManager.LEFT))
				{
					paintVertBorder(g,x + width
						- SPLITTER_WIDTH,y,height);
				}
			}
			public Insets getBorderInsets(Component c)
			{
				return insets;
			}
			public boolean isBorderOpaque()
			{
				return false;
			}
			private void paintHorizBorder(Graphics g, int x, int y, int width)
			{
				g.setColor(color3);
				g.fillRect(x,y,width,SPLITTER_WIDTH);
				if(color1 == null || color2 == null)
					return;
				for(int i = 0; i < width / 4 - 1; i++)
				{
					g.setColor(color1);
					g.drawLine(x + i * 4 + 2,y + 3,
						x + i * 4 + 2,y + 3);
					g.setColor(color2);
					g.drawLine(x + i * 4 + 3,y + 4,
						x + i * 4 + 3,y + 4);
					g.setColor(color1);
					g.drawLine(x + i * 4 + 4,y + 5,
						x + i * 4 + 4,y + 5);
					g.setColor(color2);
					g.drawLine(x + i * 4 + 5,y + 6,
						x + i * 4 + 5,y + 6);
				}
			}
			private void paintVertBorder(Graphics g, int x, int y, int height)
			{
				g.setColor(color3);
				g.fillRect(x,y,SPLITTER_WIDTH,height);
				if(color1 == null || color2 == null)
					return;
				for(int i = 0; i < height / 4 - 1; i++)
				{
					g.setColor(color1);
					g.drawLine(x + 3,y + i * 4 + 2,
						x + 3,y + i * 4 + 2);
					g.setColor(color2);
					g.drawLine(x + 4,y + i * 4 + 3,
						x + 4,y + i * 4 + 3);
					g.setColor(color1);
					g.drawLine(x + 5,y + i * 4 + 4,
						x + 5,y + i * 4 + 4);
					g.setColor(color2);
					g.drawLine(x + 6,y + i * 4 + 5,
						x + 6,y + i * 4 + 5);
				}
			}
		}
	}
	/**
	 * Floating container.
	 */
	public class Floating extends JFrame implements DockableWindowContainer
	{
		public Floating(DockableWindowManager dockableWindowManager)
		{
			this.dockableWindowManager = dockableWindowManager;
			setIconImage(GUIUtilities.getPluginIcon());
			setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		}
		public void addDockableWindow(DockableWindow window)
		{
			this.window = window;
			name = window.getName();
			setTitle(jEdit.getProperty(name + "".title""));
			getContentPane().add(BorderLayout.CENTER,window.getComponent());
			pack();
			GUIUtilities.loadGeometry(this,name);
			show();
		}
		public void saveDockableWindow(DockableWindow window)
		{
			GUIUtilities.saveGeometry(this,name);
		}
		public void removeDockableWindow(DockableWindow window)
		{
			super.dispose();
		}
		public void showDockableWindow(DockableWindow window)
		{
			toFront();
			requestFocus();
		}
		public boolean isDockableWindowVisible(DockableWindow win)
		{
			return true;
		}
		public void dispose()
		{
			dockableWindowManager.removeDockableWindow(name);
		}
		// private members
		private DockableWindowManager dockableWindowManager;
		private DockableWindow window;
		private String name;
	}
}
"
org.gjt.sp.jedit.gui.DockableWindowManager,"/*
 * DockableWindowManager.java - manages dockable windows
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.msg.CreateDockableWindow;
import org.gjt.sp.jedit.search.HyperSearchResults;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
/**
 * Manages dockable windows.
 * @author Slava Pestov
 * @version $Id: DockableWindowManager.java,v 1.16 2001/06/18 10:32:19 sp Exp $
 * @since jEdit 2.6pre3
 */
public class DockableWindowManager extends JPanel
{
	/**
	 * Floating position.
	 * @since jEdit 2.6pre3
	 */
	public static final String FLOATING = ""floating"";
	/**
	 * Top position.
	 * @since jEdit 2.6pre3
	 */
	public static final String TOP = ""top"";
	/**
	 * Left position.
	 * @since jEdit 2.6pre3
	 */
	public static final String LEFT = ""left"";
	/**
	 * Bottom position.
	 * @since jEdit 2.6pre3
	 */
	public static final String BOTTOM = ""bottom"";
	/**
	 * Right position.
	 * @since jEdit 2.6pre3
	 */
	public static final String RIGHT = ""right"";
	/**
	 * Creates a new dockable window manager.
	 * @param view The view
	 * @since jEdit 2.6pre3
	 */
	public DockableWindowManager(View view)
	{
		setLayout(new DockableLayout());
		this.view = view;
		windows = new Hashtable();
		top = new DockableWindowContainer.TabbedPane(TOP);
		left = new DockableWindowContainer.TabbedPane(LEFT);
		bottom = new DockableWindowContainer.TabbedPane(BOTTOM);
		right = new DockableWindowContainer.TabbedPane(RIGHT);
		add(BorderLayout.NORTH,top);
		add(BorderLayout.WEST,left);
		add(BorderLayout.SOUTH,bottom);
		add(BorderLayout.EAST,right);
	}
	/**
	 * Adds any dockables set to auto-open.
	 * @since jEdit 2.6pre3
	 */
	public void init()
	{
		Object[] dockables = EditBus.getNamedList(DockableWindow
			.DOCKABLE_WINDOW_LIST);
		if(dockables != null)
		{
			for(int i = 0; i < dockables.length; i++)
			{
				String name = (String)dockables[i];
				if(jEdit.getBooleanProperty(name + "".auto-open""))
					addDockableWindow(name);
			}
		}
		// do this after adding dockables because addDockableWindow()
		// sets 'collapsed' to false
		top.setCollapsed(jEdit.getBooleanProperty(""view.dock.top.collapsed""));
		left.setCollapsed(jEdit.getBooleanProperty(""view.dock.left.collapsed""));
		bottom.setCollapsed(jEdit.getBooleanProperty(""view.dock.bottom.collapsed""));
		right.setCollapsed(jEdit.getBooleanProperty(""view.dock.right.collapsed""));
	}
	/**
	 * Focuses the specified dockable window.
	 * @param name The dockable window name
	 * @since jEdit 2.6pre3
	 */
	public void showDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return;
		}
		entry.container.showDockableWindow(entry.win);
	}
	/**
	 * Adds the dockable window with the specified name to this dockable
	 * window manager.
	 * @param name The dockable window name
	 * @since jEdit 2.6pre3
	 */
	public void addDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry != null)
		{
			entry.container.showDockableWindow(entry.win);
			return;
		}
		String position = jEdit.getProperty(name + "".dock-position"",
			FLOATING);
		CreateDockableWindow msg = new CreateDockableWindow(view,name,
			position);
		EditBus.send(msg);
		DockableWindow win = msg.getDockableWindow();
		if(win == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return;
		}
		addDockableWindow(win,position);
	}
	/**
	 * Adds the specified dockable window to this dockable window manager.
	 * The position will be loaded from the properties.
	 * @param win The dockable window
	 * @since jEdit 2.6pre3
	 */
	public void addDockableWindow(DockableWindow win)
	{
		String name = win.getName();
		String position = jEdit.getProperty(name + "".dock-position"",
			FLOATING);
		addDockableWindow(win,position);
	}
	/**
	 * Adds the specified dockable window to this dockable window manager.
	 * @param win The dockable window
	 * @param pos The window position
	 * @since jEdit 2.6pre3
	 */
	public void addDockableWindow(DockableWindow win, String position)
	{
		String name = win.getName();
		if(windows.get(name) != null)
		{
			throw new IllegalArgumentException(""This DockableWindowManager""
				+ "" already has a window named "" + name);
		}
		DockableWindowContainer container;
		if(position.equals(FLOATING))
			container = new DockableWindowContainer.Floating(this);
		else
		{
			if(position.equals(TOP))
				container = top;
			else if(position.equals(LEFT))
				container = left;
			else if(position.equals(BOTTOM))
				container = bottom;
			else if(position.equals(RIGHT))
				container = right;
			else
				throw new InternalError(""Unknown position: "" + position);
		}
		Log.log(Log.DEBUG,this,""Adding "" + name + "" with position "" + position);
		container.addDockableWindow(win);
		Entry entry = new Entry(win,position,container);
		windows.put(name,entry);
	}
	/**
	 * Removes the specified dockable window from this dockable window manager.
	 * @param name The dockable window name
	 * @since jEdit 2.6pre3
	 */
	public void removeDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""This DockableWindowManager""
				+ "" does not have a window named "" + name);
			return;
		}
		Log.log(Log.DEBUG,this,""Removing "" + name + "" from ""
			+ entry.container);
		entry.container.saveDockableWindow(entry.win);
		entry.container.removeDockableWindow(entry.win);
		windows.remove(name);
	}
	/**
	 * Toggles the visibility of the specified dockable window.
	 * @param name The dockable window name
	 */
	public void toggleDockableWindow(String name)
	{
		if(isDockableWindowVisible(name))
			removeDockableWindow(name);
		else
			addDockableWindow(name);
	}
	/**
	 * Returns the specified dockable window.
	 * @param name The dockable window name.
	 */
	public DockableWindow getDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
			return null;
		else
			return entry.win;
	}
	/**
	 * Returns if the specified dockable window is visible.
	 * @param name The dockable window name
	 */
	public boolean isDockableWindowVisible(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
			return false;
		else
			return entry.container.isDockableWindowVisible(entry.win);
	}
	/**
	 * Called when the view is being closed.
	 * @since jEdit 2.6pre3
	 */
	public void close()
	{
		Enumeration enum = windows.elements();
		while(enum.hasMoreElements())
		{
			Entry entry = (Entry)enum.nextElement();
			entry.container.saveDockableWindow(entry.win);
			entry.container.removeDockableWindow(entry.win);
		}
		top.saveDimension();
		left.saveDimension();
		bottom.saveDimension();
		right.saveDimension();
	}
	public DockableWindowContainer.TabbedPane getTopDockingArea()
	{
		return top;
	}
	public DockableWindowContainer.TabbedPane getLeftDockingArea()
	{
		return left;
	}
	public DockableWindowContainer.TabbedPane getBottomDockingArea()
	{
		return bottom;
	}
	public DockableWindowContainer.TabbedPane getRightDockingArea()
	{
		return right;
	}
	/**
	 * Called by the view when properties change.
	 * @since jEdit 2.6pre3
	 */
	public void propertiesChanged()
	{
		alternateLayout = jEdit.getBooleanProperty(""view.docking.alternateLayout"");
		left.propertiesChanged();
		right.propertiesChanged();
		top.propertiesChanged();
		bottom.propertiesChanged();
		Enumeration enum = windows.elements();
		while(enum.hasMoreElements())
		{
			Entry entry = (Entry)enum.nextElement();
			if(entry.container instanceof DockableWindowContainer.Floating)
			{
				SwingUtilities.updateComponentTreeUI(((JFrame)entry.container)
					.getRootPane());
			}
		}
		revalidate();
	}
	// private members
	private View view;
	private Hashtable windows;
	private boolean alternateLayout;
	private DockableWindowContainer.TabbedPane left;
	private DockableWindowContainer.TabbedPane right;
	private DockableWindowContainer.TabbedPane top;
	private DockableWindowContainer.TabbedPane bottom;
	static
	{
		EditBus.addToBus(new DefaultFactory());
		EditBus.addToNamedList(DockableWindow.DOCKABLE_WINDOW_LIST,""vfs.browser"");
		EditBus.addToNamedList(DockableWindow.DOCKABLE_WINDOW_LIST,""hypersearch-results"");
		EditBus.addToNamedList(DockableWindow.DOCKABLE_WINDOW_LIST,""log-viewer"");
	}
	class DockableLayout implements LayoutManager2
	{
		// these are Containers so that we can call getComponentCount()
		Container top, left, bottom, right;
		Component center;
		public void addLayoutComponent(String name, Component comp)
		{
			addLayoutComponent(comp,name);
		}
		public void addLayoutComponent(Component comp, Object cons)
		{
			if(BorderLayout.NORTH.equals(cons))
				top = (Container)comp;
			else if(BorderLayout.WEST.equals(cons))
				left = (Container)comp;
			else if(BorderLayout.SOUTH.equals(cons))
				bottom = (Container)comp;
			else if(BorderLayout.EAST.equals(cons))
				right = (Container)comp;
			else
				center = comp;
		}
		public void removeLayoutComponent(Component comp)
		{
			if(top == comp)
				top = null;
			else if(left == comp)
				left = null;
			else if(bottom == comp)
				bottom = null;
			else if(right == comp)
				right = null;
			else if(center == comp)
				center = null;
		}
		public Dimension preferredLayoutSize(Container parent)
		{
			Dimension prefSize = new Dimension(0,0);
			Dimension _top = top.getPreferredSize();
			Dimension _left = left.getPreferredSize();
			Dimension _bottom = bottom.getPreferredSize();
			Dimension _right = right.getPreferredSize();
			Dimension _center = (center == null
				? new Dimension(0,0)
				: center.getPreferredSize());
			prefSize.height = _top.height + _bottom.height + _center.height;
			prefSize.width = _left.width + _right.width + _center.width;
			return prefSize;
		}
		public Dimension minimumLayoutSize(Container parent)
		{
			return preferredLayoutSize(parent);
		}
		public Dimension maximumLayoutSize(Container parent)
		{
			return new Dimension(Integer.MAX_VALUE,Integer.MAX_VALUE);
		}
		public void layoutContainer(Container parent)
		{
			Dimension size = parent.getSize();
			Dimension prefSize = new Dimension(0,0);
			Dimension _top = top.getPreferredSize();
			Dimension _left = left.getPreferredSize();
			Dimension _bottom = bottom.getPreferredSize();
			Dimension _right = right.getPreferredSize();
			Dimension _center = (center == null
				? new Dimension(0,0)
				: center.getPreferredSize());
			if(_left.width + _right.width > size.width)
			{
				if(left.getComponentCount() == 0)
					_left.width = 0;
				else
				{
					_left.width = DockableWindowContainer
						.TabbedPane.SPLITTER_WIDTH;
				}
				if(right.getComponentCount() == 0)
					_right.width = 0;
				else
				{
					_right.width = DockableWindowContainer
						.TabbedPane.SPLITTER_WIDTH;
				}
			}
			if(_top.height + _bottom.height > size.height)
			{
				if(top.getComponentCount() == 0)
					_top.height = 0;
				else
				{
					_top.height = DockableWindowContainer
						.TabbedPane.SPLITTER_WIDTH;
				}
				if(bottom.getComponentCount() == 0)
					_bottom.height = 0;
				else
				{
					_bottom.height = DockableWindowContainer
						.TabbedPane.SPLITTER_WIDTH;
				}
			}
			int _width = size.width - _left.width - _right.width;
			int _height = size.height - _top.height - _bottom.height;
			if(alternateLayout)
			{
				top.setBounds(0,0,size.width,_top.height);
				bottom.setBounds(0,size.height - _bottom.height,
					size.width,_bottom.height);
				left.setBounds(0,_top.height,_left.width,_height);
				right.setBounds(size.width - _right.width,
					_top.height,_right.width,_height);
			}
			else
			{
				left.setBounds(0,0,_left.width,size.height);
				right.setBounds(size.width - _right.width,0,
					_right.width,size.height);
				top.setBounds(_left.width,0,_width,_top.height);
				bottom.setBounds(_left.width,size.height - _bottom.height,
					_width,_bottom.height);
			}
			if(center != null)
				center.setBounds(_left.width,_top.height,_width,_height);
		}
		public float getLayoutAlignmentX(Container target)
		{
			return 0.5f;
		}
		public float getLayoutAlignmentY(Container target)
		{
			return 0.5f;
		}
		public void invalidateLayout(Container target) {}
	}
	static class Entry
	{
		DockableWindow win;
		String position;
		DockableWindowContainer container;
		Entry(DockableWindow win, String position,
			DockableWindowContainer container)
		{
			this.win = win;
			this.position = position;
			this.container = container;
		}
	}
	// factory for creating the dockables built into the jEdit core
	// (VFS browser, HyperSearch results)
	static class DefaultFactory implements EBComponent
	{
		public void handleMessage(EBMessage msg)
		{
			if(msg instanceof CreateDockableWindow)
			{
				CreateDockableWindow cmsg = (CreateDockableWindow)msg;
				String name = cmsg.getDockableWindowName();
				if(name.equals(""vfs.browser""))
				{
					cmsg.setDockableWindow(new VFSBrowser(
						cmsg.getView(),null));
				}
				else if(name.equals(""hypersearch-results""))
				{
					cmsg.setDockableWindow(new HyperSearchResults(
						cmsg.getView()));
				}
				else if(name.equals(""log-viewer""))
				{
					cmsg.setDockableWindow(new LogViewer());
				}
			}
		}
	}
}
"
org.gjt.sp.jedit.gui.EditAbbrevDialog,"/*
 * EditAbbrevDialog.java - Displayed when editing abbrevs
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
public class EditAbbrevDialog extends JDialog
{
	public EditAbbrevDialog(Component comp, String abbrev, String expansion)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""edit-abbrev.title""),true);
		this.comp = comp;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		content.add(BorderLayout.NORTH,new JLabel(jEdit.getProperty(
			""edit-abbrev.caption"", new String[] { abbrev })));
		editor = new AbbrevEditor();
		editor.setExpansion(expansion);
		editor.setBorder(new EmptyBorder(0,0,12,0));
		content.add(BorderLayout.CENTER,editor);
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		box.add(ok);
		box.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);
		KeyListener listener = new KeyHandler();
		addKeyListener(listener);
		editor.getBeforeCaretTextArea().addKeyListener(listener);
		editor.getAfterCaretTextArea().addKeyListener(listener);
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		GUIUtilities.requestFocus(this,editor.getBeforeCaretTextArea());
		pack();
		setLocationRelativeTo(comp);
		show();
	}
	public String getExpansion()
	{
		if(!isOK)
			return null;
		return editor.getExpansion();
	}
	// private members
	private Component comp;
	private AbbrevEditor editor;
	private JButton ok;
	private JButton cancel;
	private boolean isOK;
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				isOK = true;
			dispose();
		}
	}
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
				dispose();
		}
	}
}
"
org.gjt.sp.jedit.gui.EnhancedButton,"/*
 * EnhancedButton.java - Check box button
 * Copyright (C) 1999, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.EditAction;
import org.gjt.sp.jedit.GUIUtilities;
public class EnhancedButton extends JButton
{
	public EnhancedButton(Icon icon, String toolTip, EditAction action)
	{
		super(icon);
		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(action));
		}
		else
			setEnabled(false);
		setToolTipText(toolTip);
		Insets zeroInsets = new Insets(0,0,0,0);
		setMargin(zeroInsets);
		setRequestFocusEnabled(false);
	}
	public boolean isFocusTraversable()
	{
		return false;
	}
	public String getActionCommand()
	{
		return getModel().getActionCommand();
	}
}
"
org.gjt.sp.jedit.gui.EnhancedCheckBoxMenuItem,"/*
 * EnhancedCheckBoxMenuItem.java - Check box menu item
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * jEdit's custom menu item. It adds support for multi-key shortcuts.
 */
public class EnhancedCheckBoxMenuItem extends JCheckBoxMenuItem
{
	public EnhancedCheckBoxMenuItem(String label, EditAction action)
	{
		super(label);
		this.action = action;
		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(action));
			shortcutProp1 = action.getName() + "".shortcut"";
			shortcutProp2 = action.getName() + "".shortcut2"";
		}
		else
			setEnabled(false);
		setModel(new Model());
	}
	public Dimension getPreferredSize()
	{
		Dimension d = super.getPreferredSize();
		String shortcut = getShortcut();
		if(shortcut != null)
		{
			d.width += (getFontMetrics(acceleratorFont)
				.stringWidth(shortcut) + 10);
		}
		return d;
	}
	public void paint(Graphics g)
	{
		super.paint(g);
		String shortcut = getShortcut();
		if(shortcut != null)
		{
			g.setFont(acceleratorFont);
			g.setColor(getModel().isArmed() ?
				acceleratorSelectionForeground :
				acceleratorForeground);
			FontMetrics fm = g.getFontMetrics();
			Insets insets = getInsets();
			g.drawString(shortcut,getWidth() - (fm.stringWidth(
				shortcut) + insets.right + insets.left),
				getFont().getSize() + (insets.top - 1)
				/* XXX magic number */);
		}
	}
	public String getActionCommand()
	{
		return getModel().getActionCommand();
	}
	// private members
	private String shortcutProp1;
	private String shortcutProp2;
	private EditAction action;
	private static Font acceleratorFont;
	private static Color acceleratorForeground;
	private static Color acceleratorSelectionForeground;
	private String getShortcut()
	{
		if(action == null)
			return null;
		else
		{
			String shortcut1 = jEdit.getProperty(shortcutProp1);
			String shortcut2 = jEdit.getProperty(shortcutProp2);
			if(shortcut1 == null || shortcut1.length() == 0)
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return null;
				else
					return shortcut2;
			}
			else
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return shortcut1;
				else
					return shortcut1 + "" or "" + shortcut2;
			}
		}
	}
	static
	{
		acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
		acceleratorFont = new Font(""Monospaced"",
			acceleratorFont.getStyle(),
			acceleratorFont.getSize());
		acceleratorForeground = UIManager
			.getColor(""MenuItem.acceleratorForeground"");
		acceleratorSelectionForeground = UIManager
			.getColor(""MenuItem.acceleratorSelectionForeground"");
	}
	class Model extends DefaultButtonModel
	{
		public boolean isSelected()
		{
			if(!isShowing())
				return false;
			try
			{
				return action.isSelected(EditAction.getView(
					EnhancedCheckBoxMenuItem.this));
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,t);
				return false;
			}
		}
		public void setSelected(boolean b) {}
	}
}
"
org.gjt.sp.jedit.gui.EnhancedDialog,"/*
 * EnhancedDialog.java - Handles OK/Cancel for you
 * Copyright (C) 1998, 1999, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
/**
 * A dialog box that handles window closing, the ENTER key and the ESCAPE
 * key for you. All you have to do is implement ok() (called when
 * Enter is pressed) and cancel() (called when Escape is pressed, or window
 * is closed).
 * @author Slava Pestov
 * @version $Id: EnhancedDialog.java,v 1.7 2001/02/05 09:15:30 sp Exp $
 */
public abstract class EnhancedDialog extends JDialog
{
	public EnhancedDialog(Frame parent, String title, boolean modal)
	{
		super(parent,title,modal);
		((Container)getLayeredPane()).addContainerListener(
			new ContainerHandler());
		getContentPane().addContainerListener(new ContainerHandler());
		keyHandler = new KeyHandler();
		addKeyListener(keyHandler);
		addWindowListener(new WindowHandler());
		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
	}
	public abstract void ok();
	public abstract void cancel();
	// protected members
	protected KeyHandler keyHandler;
	// Recursively adds our key listener to sub-components
	class ContainerHandler extends ContainerAdapter
	{
		public void componentAdded(ContainerEvent evt)
		{
			componentAdded(evt.getChild());
		}
		public void componentRemoved(ContainerEvent evt)
		{
			componentRemoved(evt.getChild());
		}
		private void componentAdded(Component comp)
		{
			comp.addKeyListener(keyHandler);
			if(comp instanceof Container)
			{
				Container cont = (Container)comp;
				cont.addContainerListener(this);
				Component[] comps = cont.getComponents();
				for(int i = 0; i < comps.length; i++)
				{
					componentAdded(comps[i]);
				}
			}
		}
		private void componentRemoved(Component comp)
		{
			comp.removeKeyListener(keyHandler);
			if(comp instanceof Container)
			{
				Container cont = (Container)comp;
				cont.removeContainerListener(this);
				Component[] comps = cont.getComponents();
				for(int i = 0; i < comps.length; i++)
				{
					componentRemoved(comps[i]);
				}
			}
		}
	}
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.isConsumed())
				return;
			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
			{
				// crusty workaround
				Component comp = getFocusOwner();
				while(comp != null)
				{
					if(comp instanceof JComboBox)
					{
						JComboBox combo = (JComboBox)comp;
						if(combo.isEditable())
						{
							Object selected = combo.getEditor().getItem();
							if(selected != null)
								combo.setSelectedItem(selected);
						}
						break;
					}
					comp = comp.getParent();
				}
				ok();
				evt.consume();
			}
			else if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
			{
				cancel();
				evt.consume();
			}
		}
	}
	class WindowHandler extends WindowAdapter
	{
		public void windowClosing(WindowEvent evt)
		{
			cancel();
		}
	}
}
"
org.gjt.sp.jedit.gui.EnhancedMenu,"/*
 * EnhancedMenu.java - jEdit menu
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;
public class EnhancedMenu extends JMenu
{
	public EnhancedMenu(String name)
	{
		String label = jEdit.getProperty(name.concat("".label""));
		if(label == null)
			label = name;
		char mnemonic;
		int index = label.indexOf('$');
		if(index != -1 && label.length() - index > 1)
		{
			mnemonic = Character.toLowerCase(label.charAt(index + 1));
			label = label.substring(0,index).concat(label.substring(++index));
		}
		else
			mnemonic = '\0';
		setText(label);
		setMnemonic(mnemonic);
		String menuItems = jEdit.getProperty(name);
		if(menuItems != null)
		{
			StringTokenizer st = new StringTokenizer(menuItems);
			while(st.hasMoreTokens())
			{
				String menuItemName = st.nextToken();
				if(menuItemName.equals(""-""))
					addSeparator();
				else
				{
					if(menuItemName.startsWith(""%""))
						add(GUIUtilities.loadMenu(menuItemName.substring(1)));
					else
						add(GUIUtilities.loadMenuItem(menuItemName));
				}
			}
		}
	}
}
"
org.gjt.sp.jedit.gui.EnhancedMenuItem,"/*
 * EnhancedMenuItem.java - Menu item with user-specified accelerator string
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;
/**
 * jEdit's custom menu item. It adds support for multi-key shortcuts.
 */
public class EnhancedMenuItem extends JMenuItem
{
	/**
	 * Creates a new menu item. Most plugins should call
	 * GUIUtilities.loadMenuItem() instead.
	 * @param label The menu item label
	 * @param action The edit action
	 * @param actionCommand The action command
	 */
	public EnhancedMenuItem(String label, EditAction action)
	{
		super(label);
		this.action = action;
		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(action));
			shortcutProp1 = action.getName() + "".shortcut"";
			shortcutProp2 = action.getName() + "".shortcut2"";
		}
		else
			setEnabled(false);
	}
	public Dimension getPreferredSize()
	{
		Dimension d = super.getPreferredSize();
		String shortcut = getShortcut();
		if(shortcut != null)
		{
			d.width += (getFontMetrics(acceleratorFont)
				.stringWidth(shortcut) + 10);
		}
		return d;
	}
	public void paint(Graphics g)
	{
		super.paint(g);
		String shortcut = getShortcut();
		if(shortcut != null)
		{
			g.setFont(acceleratorFont);
			g.setColor(getModel().isArmed() ?
				acceleratorSelectionForeground :
				acceleratorForeground);
			FontMetrics fm = g.getFontMetrics();
			Insets insets = getInsets();
			g.drawString(shortcut,getWidth() - (fm.stringWidth(
				shortcut) + insets.right + insets.left),
				getFont().getSize() + (insets.top - 1)
				/* XXX magic number */);
		}
	}
	// private members
	private String shortcutProp1;
	private String shortcutProp2;
	private EditAction action;
	private static Font acceleratorFont;
	private static Color acceleratorForeground;
	private static Color acceleratorSelectionForeground;
	private String getShortcut()
	{
		if(action == null)
			return null;
		else
		{
			String shortcut1 = jEdit.getProperty(shortcutProp1);
			String shortcut2 = jEdit.getProperty(shortcutProp2);
			if(shortcut1 == null || shortcut1.length() == 0)
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return null;
				else
					return shortcut2;
			}
			else
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return shortcut1;
				else
					return shortcut1 + "" or "" + shortcut2;
			}
		}
	}
	static
	{
		acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
		acceleratorFont = new Font(""Monospaced"",
			acceleratorFont.getStyle(),
			acceleratorFont.getSize());
		acceleratorForeground = UIManager
			.getColor(""MenuItem.acceleratorForeground"");
		acceleratorSelectionForeground = UIManager
			.getColor(""MenuItem.acceleratorSelectionForeground"");
	}
}
"
org.gjt.sp.jedit.gui.FontSelector,"/*
 * FontSelector.java - Font selector
 * Copyright (C) 2000, 2001 Slava Pestov
 * Portions copyright (C) 1999 Jason Ginchereau
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.jEdit;
/**
 * A font chooser widget.
 * @author Slava Pestov
 * @version $Id: FontSelector.java,v 1.4 2001/03/14 05:37:27 sp Exp $
 */
public class FontSelector extends JButton
{
	public FontSelector(Font font)
	{
		setFont(font);
		updateText();
		setRequestFocusEnabled(false);
		addActionListener(new ActionHandler());
	}
	// private members
	private void updateText()
	{
		Font font = getFont();
		String styleString;
		switch(font.getStyle())
		{
		case Font.PLAIN:
			styleString = jEdit.getProperty(""font-selector.plain"");
			break;
		case Font.BOLD:
			styleString = jEdit.getProperty(""font-selector.bold"");
			break;
		case Font.ITALIC:
			styleString = jEdit.getProperty(""font-selector.italic"");
			break;
		case Font.BOLD | Font.ITALIC:
			styleString = jEdit.getProperty(""font-selector.bolditalic"");
			break;
		default:
			styleString = ""UNKNOWN!!!???"";
			break;
		}
		setText(font.getFamily() + "" "" + font.getSize() + "" "" + styleString);
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Font font = new FontSelectorDialog(FontSelector.this,getFont())
				.getSelectedFont();
			if(font != null)
			{
				setFont(font);
				updateText();
			}
		}
	}
}
class FontSelectorDialog extends EnhancedDialog
{
	public FontSelectorDialog(Component comp, Font font)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""font-selector.title""),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JPanel listPanel = new JPanel(new GridLayout(1,3,6,6));
		JPanel familyPanel = createTextFieldAndListPanel(
			""font-selector.family"",
			familyField = new JTextField(),
			familyList = new JList(getFontList()));
		listPanel.add(familyPanel);
		String[] sizes = { ""9"", ""10"", ""12"", ""14"", ""16"", ""18"", ""24"" };
		JPanel sizePanel = createTextFieldAndListPanel(
			""font-selector.size"",
			sizeField = new JTextField(),
			sizeList = new JList(sizes));
		listPanel.add(sizePanel);
		String[] styles = {
			jEdit.getProperty(""font-selector.plain""),
			jEdit.getProperty(""font-selector.bold""),
			jEdit.getProperty(""font-selector.italic""),
			jEdit.getProperty(""font-selector.bolditalic"")
		};
		JPanel stylePanel = createTextFieldAndListPanel(
			""font-selector.style"",
			styleField = new JTextField(),
			styleList = new JList(styles));
		styleField.setEditable(false);
		listPanel.add(stylePanel);
		familyList.setSelectedValue(font.getFamily(),true);
		familyField.setText(font.getFamily());
		sizeList.setSelectedValue(String.valueOf(font.getSize()),true);
		sizeField.setText(String.valueOf(font.getSize()));
		styleList.setSelectedIndex(font.getStyle());
		styleField.setText((String)styleList.getSelectedValue());
		ListHandler listHandler = new ListHandler();
		familyList.addListSelectionListener(listHandler);
		sizeList.addListSelectionListener(listHandler);
		styleList.addListSelectionListener(listHandler);
		content.add(BorderLayout.NORTH,listPanel);
		preview = new JLabel(jEdit.getProperty(""font-selector.long-text""));
		preview.setBorder(new TitledBorder(jEdit.getProperty(
			""font-selector.preview"")));
		updatePreview();
		Dimension prefSize = preview.getPreferredSize();
		prefSize.height = 50;
		preview.setPreferredSize(prefSize);
		content.add(BorderLayout.CENTER,preview);
		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		buttons.add(ok);
		buttons.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		buttons.add(cancel);
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);
		pack();
		setLocationRelativeTo(JOptionPane.getFrameForComponent(comp));
		show();
	}
	public void ok()
	{
		isOK = true;
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	public Font getSelectedFont()
	{
		if(!isOK)
			return null;
		int size;
		try
		{
			size = Integer.parseInt(sizeField.getText());
		}
		catch(Exception e)
		{
			size = 14;
		}
		return new Font(familyField.getText(),styleList
			.getSelectedIndex(),size);
	}
	// private members
	private boolean isOK;
	private JTextField familyField;
	private JList familyList;
	private JTextField sizeField;
	private JList sizeList;
	private JTextField styleField;
	private JList styleList;
	private JLabel preview;
	private JButton ok;
	private JButton cancel;
	/**
	 * For some reason the default Java fonts show up in the
	 * list with .bold, .bolditalic, and .italic extensions.
	 */
	private static final String[] HIDEFONTS = {
		"".bold"",
		"".italic""
	};
	private String[] getFontList()
	{
		try
		{
			Class GEClass = Class.forName(""java.awt.GraphicsEnvironment"");
			Object GEInstance = GEClass.getMethod(""getLocalGraphicsEnvironment"", null).invoke(null, null);
			String[] nameArray = (String[])
			GEClass.getMethod(""getAvailableFontFamilyNames"", null).invoke(GEInstance, null);
			Vector nameVector = new Vector(nameArray.length);
			for(int i = 0, j; i < nameArray.length; i++)
			{
				for(j = 0; j < HIDEFONTS.length; j++)
				{
					if(nameArray[i].indexOf(HIDEFONTS[j]) >= 0)
						break;
				}
				if(j == HIDEFONTS.length)
					nameVector.addElement(nameArray[i]);
			}
			String[] _array = new String[nameVector.size()];
			nameVector.copyInto(_array);
			return _array;
		}
		catch(Exception ex)
		{
			return Toolkit.getDefaultToolkit().getFontList();
		}
	}
	private JPanel createTextFieldAndListPanel(String label,
		JTextField textField, JList list)
	{
		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridx = cons.gridy = 0;
		cons.gridwidth = cons.gridheight = 1;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = 1.0f;
		JLabel _label = new JLabel(jEdit.getProperty(label));
		layout.setConstraints(_label,cons);
		panel.add(_label);
		cons.gridy = 1;
		Component vs = Box.createVerticalStrut(6);
		layout.setConstraints(vs,cons);
		panel.add(vs);
		cons.gridy = 2;
		layout.setConstraints(textField,cons);
		panel.add(textField);
		cons.gridy = 3;
		vs = Box.createVerticalStrut(6);
		layout.setConstraints(vs,cons);
		panel.add(vs);
		cons.gridy = 4;
		cons.gridheight = GridBagConstraints.REMAINDER;
		cons.weighty = 1.0f;
		JScrollPane scroller = new JScrollPane(list);
		layout.setConstraints(scroller,cons);
		panel.add(scroller);
		return panel;
	}
	private void updatePreview()
	{
		String family = familyField.getText();
		int size;
		try
		{
			size = Integer.parseInt(sizeField.getText());
		}
		catch(Exception e)
		{
			size = 14;
		}
		int style = styleList.getSelectedIndex();
		preview.setFont(new Font(family,style,size));
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				ok();
			else if(evt.getSource() == cancel)
				cancel();
		}
	}
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			Object source = evt.getSource();
			if(source == familyList)
			{
				String family = (String)familyList.getSelectedValue();
				if(family != null)
					familyField.setText(family);
			}
			else if(source == sizeList)
			{
				String size = (String)sizeList.getSelectedValue();
				if(size != null)
					sizeField.setText(size);
			}
			else if(source == styleList)
			{
				String style = (String)styleList.getSelectedValue();
				if(style != null)
					styleField.setText(style);
			}
			updatePreview();
		}
	}
}
"
org.gjt.sp.jedit.gui.GrabKeyDialog,"/*
 * GrabKeyDialog.java - Grabs keys from the keyboard
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.lang.reflect.Field;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * A dialog for getting shortcut keys.
 */
public class GrabKeyDialog extends JDialog
{
	/**
	 * Create and show a new modal dialog.
	 *
	 * @param  comp  center dialog on this component.
	 * @param  binding  the action/macro that should get a binding.
	 * @param  allBindings  all other key bindings.
	 * @since jEdit 3.2pre9
	 */
	public GrabKeyDialog(Component comp, KeyBinding binding,
		Vector allBindings)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""grab-key.title""),true);
		this.binding = binding;
		this.allBindings = allBindings;
		enableEvents(AWTEvent.KEY_EVENT_MASK);
		// create a panel with a BoxLayout. Can't use Box here
		// because Box doesn't have setBorder().
		JPanel content = new JPanel(new GridLayout(0,1,0,6))
		{
			/**
			 * Returns if this component can be traversed by pressing the
			 * Tab key. This returns false.
			 */
			public boolean isManagingFocus()
			{
				return false;
			}
			/**
			 * Makes the tab key work in Java 1.4.
			 * @since jEdit 3.2pre4
			 */
			public boolean getFocusTraversalKeysEnabled()
			{
				return false;
			}
		};
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JLabel label = new JLabel(jEdit.getProperty(
			""grab-key.caption"",new String[] { binding.label }));
		Box input = Box.createHorizontalBox();
		shortcut = new InputPane();
		input.add(shortcut);
		input.add(Box.createHorizontalStrut(12));
		clear = new JButton(jEdit.getProperty(""grab-key.clear""));
		clear.addActionListener(new ActionHandler());
		input.add(clear);
		assignedTo = new JLabel();
		updateAssignedTo(null);
		Box buttons = Box.createHorizontalBox();
		buttons.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		buttons.add(ok);
		buttons.add(Box.createHorizontalStrut(12));
		if(binding.isAssigned()) {
			// show ""remove"" button
			remove = new JButton(jEdit.getProperty(""grab-key.remove""));
			remove.addActionListener(new ActionHandler());
			buttons.add(remove);
			buttons.add(Box.createHorizontalStrut(12));
		}
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		buttons.add(cancel);
		buttons.add(Box.createGlue());
		content.add(label);
		content.add(input);
		content.add(assignedTo);
		content.add(buttons);
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(comp);
		setResizable(false);
		show();
	}
	/**
	 * Returns the shortcut, or null if the current shortcut should be
	 * removed or the dialog either has been cancelled. Use isOK()
	 * to determine if the latter is true.
	 */
	public String getShortcut()
	{
		if(isOK)
			return shortcut.getText();
		else
			return null;
	}
	/**
	 * Returns true, if the dialog has not been cancelled.
	 * @since jEdit 3.2pre9
	 */
	public boolean isOK()
	{
		return isOK;
	}
	/**
	 * Returns if this component can be traversed by pressing the
	 * Tab key. This returns false.
	 */
	public boolean isManagingFocus()
	{
		return false;
	}
	/**
	 * Makes the tab key work in Java 1.4.
	 * @since jEdit 3.2pre4
	 */
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	}
	// protected members
	protected void processKeyEvent(KeyEvent evt)
	{
		shortcut.processKeyEvent(evt);
	}
	// private members
	private InputPane shortcut; // this is a bad hack
	private JLabel assignedTo;
	private JButton ok;
	private JButton remove;
	private JButton cancel;
	private JButton clear;
	private boolean isOK;
	private KeyBinding binding;
	private Vector allBindings;
	private String getSymbolicName(int keyCode)
	{
		if(keyCode == KeyEvent.VK_UNDEFINED)
			return null;
		/* else if(keyCode == KeyEvent.VK_OPEN_BRACKET)
			return ""["";
		else if(keyCode == KeyEvent.VK_CLOSE_BRACKET)
			return ""]""; */
		if(keyCode >= KeyEvent.VK_A && keyCode <= KeyEvent.VK_Z)
			return String.valueOf(Character.toLowerCase((char)keyCode));
		try
		{
			Field[] fields = KeyEvent.class.getFields();
			for(int i = 0; i < fields.length; i++)
			{
				Field field = fields[i];
				String name = field.getName();
				if(name.startsWith(""VK_"")
					&& field.getInt(null) == keyCode)
				{
					return name.substring(3);
				}
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
		return null;
	}
	private void updateAssignedTo(String shortcut)
	{
		String text = jEdit.getProperty(""grab-key.assigned-to.none"");
		KeyBinding kb = getKeyBinding(shortcut);
		if(kb != null)
			if(kb.isPrefix)
				text = jEdit.getProperty(
					""grab-key.assigned-to.prefix"",
					new String[] { shortcut });
			else
				text = kb.label;
		if(ok != null)
			ok.setEnabled(kb == null || !kb.isPrefix);
		assignedTo.setText(
			jEdit.getProperty(""grab-key.assigned-to"",
				new String[] { text }));
	}
	private KeyBinding getKeyBinding(String shortcut)
	{
		if(shortcut == null || shortcut.length() == 0)
			return null;
		String spacedShortcut = shortcut + "" "";
		Enumeration enum = allBindings.elements();
		while(enum.hasMoreElements())
		{
			KeyBinding kb = (KeyBinding)enum.nextElement();
			if(!kb.isAssigned())
				continue;
			String spacedKbShortcut = kb.shortcut + "" "";
			// eg, trying to bind C+n C+p if C+n already bound
			if(spacedShortcut.startsWith(spacedKbShortcut))
				return kb;
			// eg, trying to bind C+e if C+e is a prefix
			if(spacedKbShortcut.startsWith(spacedShortcut))
			{
				// create a temporary (synthetic) prefix
				// KeyBinding, that won't be saved
				return new KeyBinding(kb.name,kb.label,
					shortcut,true);
			}
		}
		return null;
	}
	/**
	 * A jEdit action or macro with its two possible shortcuts.
	 * @since jEdit 3.2pre8
	 */
	public static class KeyBinding
	{
		public KeyBinding(String name, String label,
			String shortcut, boolean isPrefix)
		{
			this.name = name;
			this.label = label;
			this.shortcut = shortcut;
			this.isPrefix = isPrefix;
		}
		public String name;
		public String label;
		public String shortcut;
		public boolean isPrefix;
		public boolean isAssigned()
		{
			return shortcut != null && shortcut.length() > 0;
		}
	}
	class InputPane extends JTextField
	{
		/**
		 * Makes the tab key work in Java 1.4.
		 * @since jEdit 3.2pre4
		 */
		public boolean getFocusTraversalKeysEnabled()
		{
			return false;
		}
		protected void processKeyEvent(KeyEvent _evt)
		{
			if(_evt.getID() != KeyEvent.KEY_PRESSED)
				return;
			KeyEvent evt = KeyEventWorkaround.processKeyEvent(_evt);
			if(evt == null)
			{
				Log.log(Log.DEBUG,this,""Event "" + _evt + "" filtered"");
				return;
			}
			else
				Log.log(Log.DEBUG,this,""Event "" + _evt + "" passed"");
			evt.consume();
			StringBuffer keyString = new StringBuffer(getText());
			if(getDocument().getLength() != 0)
				keyString.append(' ');
			boolean appendPlus = false;
			// On MacOS, C+ is command, M+ is control
			// so that jEdit's default shortcuts are
			// mapped to the Command
			if(evt.isControlDown())
			{
				keyString.append(macOS ? 'M' : 'C');
				appendPlus = true;
			}
			if(evt.isAltDown())
			{
				keyString.append('A');
				appendPlus = true;
			}
			if(evt.isMetaDown())
			{
				keyString.append(macOS ? 'C' : 'M');
				appendPlus = true;
			}
			// don't want Shift+'d' recorded as S+D
			if(evt.getID() != KeyEvent.KEY_TYPED && evt.isShiftDown())
			{
				keyString.append('S');
				appendPlus = true;
			}
			if(appendPlus)
				keyString.append('+');
			int keyCode = evt.getKeyCode();
			String symbolicName = getSymbolicName(keyCode);
			if(symbolicName == null)
				return;
			keyString.append(symbolicName);
			setText(keyString.toString());
			updateAssignedTo(keyString.toString());
		}
		private boolean macOS = (System.getProperty(""os.name"")
			.indexOf(""MacOS"") != -1);
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(canClose())
					dispose();
			}
			else if(evt.getSource() == remove)
			{
				shortcut.setText(null);
				isOK = true;
				dispose();
			}
			else if(evt.getSource() == cancel)
				dispose();
			else if(evt.getSource() == clear)
			{
				shortcut.setText(null);
				updateAssignedTo(null);
			}
		}
		private boolean canClose()
		{
			String shortcutString = shortcut.getText();
			if(shortcutString.length() == 0
				&& binding.isAssigned())
			{
				// ask whether to remove the old shortcut
				int answer = GUIUtilities.confirm(
					GrabKeyDialog.this,
					""grab-key.remove-ask"",
					null,
					JOptionPane.YES_NO_CANCEL_OPTION,
					JOptionPane.QUESTION_MESSAGE);
				if(answer == JOptionPane.YES_OPTION)
				{
					shortcut.setText(null);
					isOK = true;
				}
				else if(answer == JOptionPane.CANCEL_OPTION)
					return false;
				return true;
			}
			// check whether this shortcut already exists
			KeyBinding other = getKeyBinding(shortcutString);
			if(other == null || other == binding)
			{
				isOK = true;
				return true;
			}
			// check whether the other shortcut is the alt. shortcut
			if(other.name == binding.name)
			{
				// we don't need two identical shortcuts
				GUIUtilities.error(GrabKeyDialog.this,
					""grab-key.duplicate-alt-shortcut"",
					null);
				return false;
			}
			// check whether shortcut is a prefix to others
			if(other.isPrefix)
			{
				// can't override prefix shortcuts
				GUIUtilities.error(GrabKeyDialog.this,
					""grab-key.prefix-shortcut"",
					null);
				return false;
			}
			// ask whether to override that other shortcut
			int answer = GUIUtilities.confirm(GrabKeyDialog.this,
				""grab-key.duplicate-shortcut"",
				new Object[] { other.label },
				JOptionPane.YES_NO_CANCEL_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(answer == JOptionPane.YES_OPTION)
			{
				if(other.shortcut != null
					&& shortcutString.startsWith(other.shortcut))
				{
					other.shortcut = null;
				}
				isOK = true;
				return true;
			}
			else if(answer == JOptionPane.CANCEL_OPTION)
				return false;
			return true;
		}
	}
}
"
org.gjt.sp.jedit.gui.HelpViewer,"/*
 * HelpViewer.java - HTML Help viewer
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import com.microstar.xml.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.text.html.*;
import javax.swing.text.Document;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * jEdit's HTML viewer. It uses a Swing JEditorPane to display the HTML,
 * and implements a URL history.
 * @author Slava Pestov
 * @version $Id: HelpViewer.java,v 1.43 2001/08/27 07:03:58 sp Exp $
 */
public class HelpViewer extends JFrame implements EBComponent
{
	/**
	 * @deprecated Create a new HelpViewer instance instead
	 */
	public static void gotoURL(URL url)
	{
		new HelpViewer(url.toString());
	}
	/**
	 * @deprecated Pass a String instead of a URL
	 */
	public HelpViewer(URL url)
	{
		// XXX
		this(url.toString());
	}
	/**
	 * Creates a new help viewer for the specified URL.
	 * @param url The URL
	 */
	public HelpViewer(String url)
	{
		super(jEdit.getProperty(""helpviewer.title""));
		setIconImage(GUIUtilities.getEditorIcon());
		history = new String[25];
		nodes = new Hashtable();
		ActionHandler actionListener = new ActionHandler();
		JToolBar toolBar = new JToolBar();
		toolBar.setFloatable(false);
		toolBar.putClientProperty(""JToolBar.isRollover"",Boolean.TRUE);
		JLabel label = new JLabel(jEdit.getProperty(""helpviewer.url""));
		label.setBorder(new EmptyBorder(0,12,0,12));
		toolBar.add(label);
		Box box = new Box(BoxLayout.Y_AXIS);
		box.add(Box.createGlue());
		urlField = new JTextField();
		urlField.addKeyListener(new KeyHandler());
		Dimension dim = urlField.getPreferredSize();
		dim.width = Integer.MAX_VALUE;
		urlField.setMaximumSize(dim);
		box.add(urlField);
		box.add(Box.createGlue());
		toolBar.add(box);
		toolBar.add(Box.createHorizontalStrut(6));
		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(0,12,0,0));
		back = new JButton(GUIUtilities.loadIcon(""Back24.gif""));
		back.setToolTipText(jEdit.getProperty(""helpviewer.back""));
		back.addActionListener(actionListener);
		back.setRequestFocusEnabled(false);
		toolBar.add(back);
		forward = new JButton(GUIUtilities.loadIcon(""Forward24.gif""));
		forward.addActionListener(actionListener);
		forward.setToolTipText(jEdit.getProperty(""helpviewer.forward""));
		forward.setRequestFocusEnabled(false);
		toolBar.add(forward);
		back.setPreferredSize(forward.getPreferredSize());
		getContentPane().add(BorderLayout.NORTH,toolBar);
		createTOC();
		toc = new TOCTree(tocModel);
		toc.putClientProperty(""JTree.lineStyle"", ""Angled"");
		toc.setCellRenderer(new TOCCellRenderer());
		toc.setEditable(false);
		toc.setRootVisible(false);
		toc.setShowsRootHandles(true);
		viewer = new JEditorPane();
		viewer.setEditable(false);
		viewer.addHyperlinkListener(new LinkHandler());
		viewer.setFont(new Font(""Monospaced"",Font.PLAIN,12));
		JSplitPane splitter = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
			new JScrollPane(toc),new JScrollPane(viewer));
		splitter.setBorder(null);
		getContentPane().add(BorderLayout.CENTER,splitter);
		gotoURL(url,true);
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		setSize(800,400);
		GUIUtilities.loadGeometry(this,""helpviewer"");
		EditBus.addToBus(this);
		show();
	}
	/**
	 * Displays the specified URL in the HTML component.
	 * @param url The URL
	 * @param addToHistory Should the URL be added to the back/forward
	 * history?
	 */
	public void gotoURL(String url, boolean addToHistory)
	{
		// reset default cursor so that the hand cursor doesn't
		// stick around
		viewer.setCursor(Cursor.getDefaultCursor());
		int index = url.indexOf('#');
		URL _url = null;
		try
		{
			_url = new URL(url);
			urlField.setText(_url.toString());
			viewer.setPage(_url);
			if(addToHistory)
			{
				history[historyPos] = url;
				if(historyPos + 1 == history.length)
				{
					System.arraycopy(history,1,history,
						0,history.length - 1);
					history[historyPos] = null;
				}
				else
					historyPos++;
			}
		}
		catch(MalformedURLException mf)
		{
			Log.log(Log.ERROR,this,mf);
			String[] args = { url, mf.getMessage() };
			GUIUtilities.error(this,""badurl"",args);
			return;
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			String[] args = { url, io.toString() };
			GUIUtilities.error(this,""read-error"",args);
			return;
		}
		// select the appropriate tree node.
		index = url.lastIndexOf(""/doc/"");
		if(index != -1)
			url = url.substring(index + 5);
		DefaultMutableTreeNode node = (DefaultMutableTreeNode)nodes.get(url);
		if(node == null)
			return;
		TreePath path = new TreePath(tocModel.getPathToRoot(node));
		toc.expandPath(path);
		toc.setSelectionPath(path);
		toc.scrollPathToVisible(path);
	}
	public void dispose()
	{
		EditBus.removeFromBus(this);
		GUIUtilities.saveGeometry(this,""helpviewer"");
		super.dispose();
	}
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			SwingUtilities.updateComponentTreeUI(getRootPane());
	}
	// private members
	private JButton back;
	private JButton forward;
	private DefaultTreeModel tocModel;
	private JTree toc;
	// this makes gotoURL()'s tree updating simpler
	private Hashtable nodes;
	private JEditorPane viewer;
	private JTextField urlField;
	private String[] history;
	private int historyPos;
	private void createTOC()
	{
		DefaultMutableTreeNode root = new DefaultMutableTreeNode();
		root.add(createNode(""welcome.html"",
			jEdit.getProperty(""helpviewer.toc.welcome"")));
		root.add(createNode(""jeditresource:/doc/README.txt"",
			jEdit.getProperty(""helpviewer.toc.readme"")));
		root.add(createNode(""jeditresource:/doc/NEWS.txt"",
			jEdit.getProperty(""helpviewer.toc.news"")));
		root.add(createNode(""jeditresource:/doc/TODO.txt"",
			jEdit.getProperty(""helpviewer.toc.todo"")));
		root.add(createNode(""jeditresource:/doc/CHANGES.txt"",
			jEdit.getProperty(""helpviewer.toc.changes"")));
		root.add(createNode(""jeditresource:/doc/COPYING.txt"",
			jEdit.getProperty(""helpviewer.toc.copying"")));
		root.add(createNode(""jeditresource:/doc/COPYING.DOC.txt"",
			jEdit.getProperty(""helpviewer.toc.copying-doc"")));
		loadUserGuideTOC(root);
		DefaultMutableTreeNode pluginDocs = new DefaultMutableTreeNode(
			jEdit.getProperty(""helpviewer.toc.plugins""),true);
		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin plugin = plugins[i];
			EditPlugin.JAR jar = plugin.getJAR();
			if(jar == null)
				continue;
			String name = plugin.getClassName();
			String docs = jEdit.getProperty(""plugin."" + name + "".docs"");
			String label = jEdit.getProperty(""plugin."" + name + "".name"");
			if(docs != null)
			{
				if(label != null && docs != null)
				{
					URL url = jar.getClassLoader()
						.getResource(docs);
					if(url != null)
					{
						pluginDocs.add(createNode(
							url.toString(),label));
					}
				}
			}
		}
		root.add(pluginDocs);
		tocModel = new DefaultTreeModel(root);
	}
	private void loadUserGuideTOC(DefaultMutableTreeNode root)
	{
		URL resource = getClass().getResource(""/doc/users-guide/toc.xml"");
		if(resource == null)
			return;
		TOCHandler h = new TOCHandler(root);
		XmlParser parser = new XmlParser();
		parser.setHandler(h);
		try
		{
			// use a URL here because with Web Start version,
			// toc.xml is not a local file
			parser.parse(null, null, new InputStreamReader(
				resource.openStream()));
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,this,""toc.xml:"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
	}
	private DefaultMutableTreeNode createNode(String href, String title)
	{
		DefaultMutableTreeNode node = new DefaultMutableTreeNode(
			new HelpNode(href,title),true);
		nodes.put(href,node);
		return node;
	}
	static class HelpNode
	{
		String href, title;
		HelpNode(String href, String title)
		{
			this.href = href;
			this.title = title;
		}
		public String toString()
		{
			return title;
		}
	}
	class TOCHandler extends HandlerBase
	{
		TOCHandler(DefaultMutableTreeNode root)
		{
			nodes = new Stack();
			node = root;
		}
		public void attribute(String aname, String value, boolean isSpecified)
		{
			if(aname.equals(""HREF""))
				href = value;
		}
		public void charData(char[] c, int off, int len)
		{
			if(tag.equals(""TITLE""))
				title = new String(c, off, len);
		}
		public void startElement(String name)
		{
			tag = name;
		}
		public void endElement(String name)
		{
			if(name == null)
				return;
			if(name.equals(""TITLE""))
			{
				DefaultMutableTreeNode newNode = createNode(
					""users-guide/"" + href,title);
				node.add(newNode);
				nodes.push(node);
				node = newNode;
			}
			else if(name.equals(""ENTRY""))
				node = (DefaultMutableTreeNode)nodes.pop();
		}
		// end HandlerBase implementation
		// private members
		private String tag;
		private String title;
		private String href;
		private DefaultMutableTreeNode node;
		private Stack nodes;
	}
	class TOCTree extends JTree
	{
		TOCTree(TreeModel model)
		{
			super(model);
			ToolTipManager.sharedInstance().registerComponent(this);
		}
		public final String getToolTipText(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
					return path.getLastPathComponent().toString();
			}
			return null;
		}
		public final Point getToolTipLocation(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
				{
					return new Point(cellRect.x, cellRect.y - 1);
				}
			}
			return null;
		}
		protected void processMouseEvent(MouseEvent evt)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			switch(evt.getID())
			{
			case MouseEvent.MOUSE_ENTERED:
				toolTipInitialDelay = ttm.getInitialDelay();
				toolTipReshowDelay = ttm.getReshowDelay();
				ttm.setInitialDelay(200);
				ttm.setReshowDelay(0);
				super.processMouseEvent(evt);
				break;
			case MouseEvent.MOUSE_EXITED:
				ttm.setInitialDelay(toolTipInitialDelay);
				ttm.setReshowDelay(toolTipReshowDelay);
				super.processMouseEvent(evt);
				break;
			case MouseEvent.MOUSE_CLICKED:
				TreePath path = getPathForLocation(evt.getX(),evt.getY());
				if(path != null)
				{
					if(!isPathSelected(path))
						setSelectionPath(path);
					Object obj = ((DefaultMutableTreeNode)
						path.getLastPathComponent())
						.getUserObject();
					if(!(obj instanceof HelpNode))
					{
						toc.expandPath(path);
						return;
					}
					HelpNode node = (HelpNode)obj;
					gotoURL(node.href,true);
				}
				super.processMouseEvent(evt);
				break;
			default:
				super.processMouseEvent(evt);
				break;
			}
		}
		// private members
		private int toolTipInitialDelay = -1;
		private int toolTipReshowDelay = -1;
		private boolean cellRectIsVisible(Rectangle cellRect)
		{
			Rectangle vr = TOCTree.this.getVisibleRect();
			return vr.contains(cellRect.x,cellRect.y) &&
				vr.contains(cellRect.x + cellRect.width,
				cellRect.y + cellRect.height);
		}
	}
	class TOCCellRenderer extends DefaultTreeCellRenderer
	{
		EmptyBorder border = new EmptyBorder(1,0,1,1);
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean sel, boolean expanded,
			boolean leaf, int row, boolean focus)
		{
			super.getTreeCellRendererComponent(tree,value,sel,
				expanded,leaf,row,focus);
			setIcon(null);
			setBorder(border);
			return this;
		}
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == back)
			{
				if(historyPos <= 1)
					getToolkit().beep();
				else
				{
					String url = history[--historyPos - 1];
					gotoURL(url,false);
				}
			}
			else if(source == forward)
			{
				if(history.length - historyPos <= 1)
					getToolkit().beep();
				else
				{
					String url = history[historyPos];
					if(url == null)
						getToolkit().beep();
					else
					{
						historyPos++;
						gotoURL(url,false);
					}
				}
			}
		}
	}
	class LinkHandler implements HyperlinkListener
	{
		public void hyperlinkUpdate(HyperlinkEvent evt)
		{
			if(evt.getEventType() == HyperlinkEvent.EventType.ACTIVATED)
			{
				if(evt instanceof HTMLFrameHyperlinkEvent)
				{
					((HTMLDocument)viewer.getDocument())
						.processHTMLFrameHyperlinkEvent(
						(HTMLFrameHyperlinkEvent)evt);
				}
				else
				{
					URL url = evt.getURL();
					if(url != null)
						gotoURL(url.toString(),true);
				}
			}
			else if (evt.getEventType() == HyperlinkEvent.EventType.ENTERED) {
				viewer.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
			}
			else if (evt.getEventType() == HyperlinkEvent.EventType.EXITED) {
				viewer.setCursor(Cursor.getDefaultCursor());
			}
		}
	}
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
			{
				gotoURL(urlField.getText(),true);
			}
		}
	}
}
"
org.gjt.sp.jedit.gui.HistoryModel,"/*
 * HistoryModel.java - History list model
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.util.Log;
/**
 * A history list. One history list can be used by several history text
 * fields.
 * @author Slava Pestov
 * @version $Id: HistoryModel.java,v 1.13 2000/11/16 10:25:17 sp Exp $
 */
public class HistoryModel
{
	/**
	 * Creates a new history list. Calling this is normally not
	 * necessary.
	 */
	public HistoryModel(String name)
	{
		this.name = name;
		try
		{
			max = Integer.parseInt(jEdit.getProperty(""history""));
		}
		catch(NumberFormatException nf)
		{
			max = 25;
		}
		data = new Vector(max);
	}
	/**
	 * Adds an item to the end of this history list, trimming the list
	 * to the maximum number of items if necessary.
	 * @param text The item
	 */
	public void addItem(String text)
	{
		if(text == null || text.length() == 0)
			return;
		int index = data.indexOf(text);
		if(index != -1)
			data.removeElementAt(index);
		data.insertElementAt(text,0);
		if(getSize() > max)
			data.removeElementAt(getSize() - 1);
	}
	/**
	 * Returns an item from the history list.
	 * @param index The index
	 */
	public String getItem(int index)
	{
		return (String)data.elementAt(index);
	}
	/**
	 * Returns the number of elements in this history list.
	 */
	public int getSize()
	{
		return data.size();
	}
	/**
	 * Returns the name of this history list. This can be passed
	 * to the HistoryTextField constructor.
	 */
	public String getName()
	{
		return name;
	}
	/**
	 * Returns a named model. If the specified model does not
	 * already exist, it will be created.
	 * @param name The model name
	 */
	public static HistoryModel getModel(String name)
	{
		if(models == null)
			models = new Hashtable();
		HistoryModel model = (HistoryModel)models.get(name);
		if(model == null)
		{
			model = new HistoryModel(name);
			models.put(name,model);
		}
		return model;
	}
	/**
	 * Loads the history from the specified file. jEdit calls this
	 * on startup.
	 * @param The file
	 */
	public static void loadHistory(File file)
	{
		if(models == null)
			models = new Hashtable();
		try
		{
			BufferedReader in = new BufferedReader(new FileReader(file));
			HistoryModel currentModel = null;
			String line;
			while((line = in.readLine()) != null)
			{
				if(line.startsWith(""["") && line.endsWith(""]""))
				{
					if(currentModel != null)
					{
						models.put(currentModel.getName(),
							currentModel);
					}
					currentModel = new HistoryModel(line
						.substring(1,line.length() - 1));
				}
				else if(currentModel == null)
				{
					throw new IOException(""History data starts""
						+ "" before model name"");
				}
				else
				{
					currentModel.addItemToEnd(MiscUtilities
						.escapesToChars(line));
				}
			}
			if(currentModel != null)
			{
				models.put(currentModel.getName(),currentModel);
			}
			in.close();
		}
		catch(FileNotFoundException fnf)
		{
			Log.log(Log.DEBUG,HistoryModel.class,fnf);
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,HistoryModel.class,io);
		}
	}
	/**
	 * Saves the history to the specified file. jEdit calls this when
	 * it is exiting.
	 * @param file The file
	 */
	public static void saveHistory(File file)
	{
		String lineSep = System.getProperty(""line.separator"");
		try
		{
			BufferedWriter out = new BufferedWriter(
				new FileWriter(file));
			if(models == null)
			{
				out.close();
				return;
			}
			Enumeration modelEnum = models.elements();
			while(modelEnum.hasMoreElements())
			{
				HistoryModel model = (HistoryModel)modelEnum
					.nextElement();
				out.write('[');
				out.write(model.getName());
				out.write(']');
				out.write(lineSep);
				for(int i = 0; i < model.getSize(); i++)
				{
					out.write(MiscUtilities.charsToEscapes(
						model.getItem(i),true));
					out.write(lineSep);
				}
			}
			out.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,HistoryModel.class,io);
		}
	}
	// private members
	private String name;
	private int max;
	private Vector data;
	private static Hashtable models;
	private void addItemToEnd(String item)
	{
		data.addElement(item);
	}
}
/*
 * ChangeLog:
 * $Log: HistoryModel.java,v $
 * Revision 1.13  2000/11/16 10:25:17  sp
 * More macro work
 *
 * Revision 1.12  2000/07/19 08:35:59  sp
 * plugin devel docs updated, minor other changes
 *
 * Revision 1.11  1999/12/21 06:50:51  sp
 * Documentation updates, abbrevs option pane finished, bug fixes
 *
 * Revision 1.10  1999/12/19 11:14:29  sp
 * Static abbrev expansion started
 *
 * Revision 1.9  1999/11/21 07:59:30  sp
 * JavaDoc updates
 *
 * Revision 1.8  1999/10/31 07:15:34  sp
 * New logging API, splash screen updates, bug fixes
 *
 * Revision 1.7  1999/10/26 07:43:59  sp
 * Session loading and saving, directory list search started
 *
 * Revision 1.6  1999/05/12 05:23:41  sp
 * Fixed compile % -vs- $ bug, also HistoryModel \ bug
 *
 * Revision 1.5  1999/05/09 03:50:17  sp
 * HistoryTextField is now a text field again
 *
 * Revision 1.4  1999/05/08 00:13:00  sp
 * Splash screen change, minor documentation update, toolbar API fix
 *
 */
"
org.gjt.sp.jedit.gui.HistoryTextField,"/*
 * HistoryTextField.java - Text field with a history
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.AbstractBorder;
import javax.swing.border.CompoundBorder;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;
/**
 * Text field with an arrow-key accessable history.
 * @author Slava Pestov
 * @version $Id: HistoryTextField.java,v 1.45 2001/08/27 07:03:58 sp Exp $
 */
public class HistoryTextField extends JTextField
{
	/**
	 * Creates a new history text field.
	 * @since jEdit 3.2pre5
	 */
	public HistoryTextField()
	{
		this(null);
	}
	/**
	 * Creates a new history text field.
	 * @param name The history model name
	 */
	public HistoryTextField(String name)
	{
		this(name,false,true);
	}
	/**
	 * Creates a new history text field.
	 * @param name The history model name
	 * @param instantPopup If true, selecting a value from the history
	 * popup will immediately fire an ActionEvent. If false, the user
	 * will have to press 'Enter' first
	 *
	 * @since jEdit 2.2pre5
	 */
	public HistoryTextField(String name, boolean instantPopups)
	{
		this(name,instantPopups,true);
	}
	/**
	 * Creates a new history text field.
	 * @param name The history model name
	 * @param instantPopup If true, selecting a value from the history
	 * popup will immediately fire an ActionEvent. If false, the user
	 * will have to press 'Enter' first
	 * @param enterAddsToHistory If true, pressing the Enter key will
	 * automatically add the currently entered text to the history.
	 *
	 * @since jEdit 2.6pre5
	 */
	public HistoryTextField(String name, boolean instantPopups,
		boolean enterAddsToHistory)
	{
		setBorder(new CompoundBorder(getBorder(),new HistoryBorder()));
		if(name != null)
			historyModel = HistoryModel.getModel(name);
		addMouseMotionListener(new MouseHandler());
		this.instantPopups = instantPopups;
		this.enterAddsToHistory = enterAddsToHistory;
		index = -1;
	}
	/**
	 * Sets the history list model.
	 * @param name The model name
	 * @since jEdit 2.3pre3
	 */
	public void setModel(String name)
	{
		if(name == null)
			historyModel = null;
		else
			historyModel = HistoryModel.getModel(name);
		index = -1;
	}
	/**
	 * Adds the currently entered item to the history.
	 */
	public void addCurrentToHistory()
	{
		if(historyModel != null)
			historyModel.addItem(getText());
		index = 0;
	}
	/**
	 * Sets the displayed text.
	 */
	public void setText(String text)
	{
		super.setText(text);
		index = -1;
	}
	/**
	 * Returns the underlying history model.
	 */
	public HistoryModel getModel()
	{
		return historyModel;
	}
	/**
	 * Fires an action event to all listeners. This is public so
	 * that inner classes can access it.
	 */
	public void fireActionPerformed()
	{
		super.fireActionPerformed();
	}
	// protected members
	protected void processKeyEvent(KeyEvent evt)
	{
		if(!isEnabled())
			return;
		evt = KeyEventWorkaround.processKeyEvent(evt);
		if(evt == null)
			return;
		if(evt.getID() == KeyEvent.KEY_PRESSED)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
			{
				if(enterAddsToHistory)
					addCurrentToHistory();
				if(evt.getModifiers() == 0)
				{
					fireActionPerformed();
					evt.consume();
				}
			}
			else if(evt.getKeyCode() == KeyEvent.VK_UP)
			{
				if(evt.isShiftDown())
					doBackwardSearch();
				else
					historyPrevious();
				evt.consume();
			}
			else if(evt.getKeyCode() == KeyEvent.VK_DOWN)
			{
				if(evt.isShiftDown())
					doForwardSearch();
				else
					historyNext();
				evt.consume();
			}
			else if(evt.getKeyCode() == KeyEvent.VK_TAB
				&& evt.isControlDown())
			{
				doBackwardSearch();
				evt.consume();
			}
		}
		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	}
	protected void processMouseEvent(MouseEvent evt)
	{
		if(!isEnabled())
			return;
		switch(evt.getID())
		{
		case MouseEvent.MOUSE_PRESSED:
			Border border = getBorder();
			Insets insets = border.getBorderInsets(HistoryTextField.this);
			if(evt.getX() >= getWidth() - insets.right
				|| GUIUtilities.isPopupTrigger(evt))
			{
				if(evt.isShiftDown())
					showPopupMenu(getText().substring(0,
						getSelectionStart()),0,getHeight());
				else
					showPopupMenu("""",0,getHeight());
			}
			else
				super.processMouseEvent(evt);
			break;
		case MouseEvent.MOUSE_EXITED:
			setCursor(Cursor.getDefaultCursor());
			super.processMouseEvent(evt);
			break;
		default:
			super.processMouseEvent(evt);
			break;
		}
	}
	// private members
	private HistoryModel historyModel;
	private JPopupMenu popup;
	private boolean instantPopups;
	private boolean enterAddsToHistory;
	private String current;
	private int index;
	private void doBackwardSearch()
	{
		if(historyModel == null)
			return;
		if(getSelectionEnd() != getDocument().getLength())
		{
			setCaretPosition(getDocument().getLength());
		}
		String text = getText().substring(0,getSelectionStart());
		if(text == null)
		{
			historyPrevious();
			return;
		}
		for(int i = index + 1; i < historyModel.getSize(); i++)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				replaceSelection(item.substring(text.length()));
				select(text.length(),getDocument().getLength());
				index = i;
				return;
			}
		}
		getToolkit().beep();
	}
	private void doForwardSearch()
	{
		if(historyModel == null)
			return;
		if(getSelectionEnd() != getDocument().getLength())
		{
			setCaretPosition(getDocument().getLength());
		}
		String text = getText().substring(0,getSelectionStart());
		if(text == null)
		{
			historyNext();
			return;
		}
		for(int i = index - 1; i >= 0; i--)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				replaceSelection(item.substring(text.length()));
				select(text.length(),getDocument().getLength());
				index = i;
				return;
			}
		}
		getToolkit().beep();
	}
	private void historyPrevious()
	{
		if(historyModel == null)
			return;
		if(index == historyModel.getSize() - 1)
			getToolkit().beep();
		else if(index == -1)
		{
			current = getText();
			setText(historyModel.getItem(0));
			index = 0;
		}
		else
		{
			// have to do this because setText() sets index to -1
			int newIndex = index + 1;
			setText(historyModel.getItem(newIndex));
			index = newIndex;
		}
	}
	private void historyNext()
	{
		if(historyModel == null)
			return;
		if(index == -1)
			getToolkit().beep();
		else if(index == 0)
			setText(current);
		else
		{
			// have to do this because setText() sets index to -1
			int newIndex = index - 1;
			setText(historyModel.getItem(newIndex));
			index = newIndex;
		}
	}
	private void showPopupMenu(String text, int x, int y)
	{
		if(historyModel == null)
			return;
		requestFocus();
		if(popup != null && popup.isVisible())
		{
			popup.setVisible(false);
			return;
		}
		ActionHandler actionListener = new ActionHandler();
		popup = new JPopupMenu();
		//JMenuItem caption = new JMenuItem(historyModel.getName()
		//	+ (text.length() == 0 ? """" : ""/"" + text));
		JMenuItem caption = new JMenuItem(jEdit.getProperty(
			""history.caption""));
		caption.getModel().setEnabled(false);
		popup.add(caption);
		popup.addSeparator();
		for(int i = 0; i < historyModel.getSize(); i++)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				JMenuItem menuItem = new JMenuItem(item);
				menuItem.setActionCommand(String.valueOf(i));
				menuItem.addActionListener(actionListener);
				popup.add(menuItem);
			}
		}
		popup.show(this,x,y);
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			int ind = Integer.parseInt(evt.getActionCommand());
			if(ind == -1)
			{
				if(index != -1)
					setText(current);
			}
			else
			{
				setText(historyModel.getItem(ind));
				index = ind;
			}
			if(instantPopups)
			{
				addCurrentToHistory();
				fireActionPerformed();
			}
		}
	}
	class MouseHandler extends MouseMotionAdapter
	{
		public void mouseMoved(MouseEvent evt)
		{
			Border border = getBorder();
			Insets insets = border.getBorderInsets(HistoryTextField.this);
			if(evt.getX() >= getWidth() - insets.right)
				setCursor(Cursor.getDefaultCursor());
			else
				setCursor(Cursor.getPredefinedCursor(
					Cursor.TEXT_CURSOR));
		}
	}
	static class HistoryBorder extends AbstractBorder
	{
		static final int WIDTH = 16;
		public void paintBorder(Component c, Graphics g,
			int x, int y, int w, int h)
		{
			g.translate(x+w-WIDTH,y-1);
			//if(c.isEnabled())
			//{
			//	// vertical separation line
			//	g.setColor(UIManager.getColor(""controlDkShadow""));
			//	g.drawLine(0,0,0,h);
			//}
			// down arrow
			int w2 = WIDTH/2;
			int h2 = h/2;
			g.setColor(UIManager.getColor(c.isEnabled()
				&& ((HistoryTextField)c).getModel() != null
				? ""Menu.foreground"" : ""Menu.disabledForeground""));
			g.drawLine(w2-5,h2-2,w2+4,h2-2);
			g.drawLine(w2-4,h2-1,w2+3,h2-1);
			g.drawLine(w2-3,h2  ,w2+2,h2  );
			g.drawLine(w2-2,h2+1,w2+1,h2+1);
			g.drawLine(w2-1,h2+2,w2  ,h2+2);
			g.translate(-(x+w-WIDTH),-(y-1));
		}
		public Insets getBorderInsets(Component c)
		{
			return new Insets(0,0,0,WIDTH);
		}
	}
}
"
org.gjt.sp.jedit.gui.InputHandler,"/*
 * InputHandler.java - Manages key bindings and executes actions
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import java.awt.event.*;
import java.awt.Component;
import java.util.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * An input handler converts the user's key strokes into concrete actions.
 * It also takes care of macro recording and action repetition.<p>
 *
 * This class provides all the necessary support code for an input
 * handler, but doesn't actually do any key binding logic. It is up
 * to the implementations of this class to do so.
 *
 * @author Slava Pestov
 * @version $Id: InputHandler.java,v 1.31 2001/07/28 12:34:43 sp Exp $
 * @see org.gjt.sp.jedit.gui.DefaultInputHandler
 */
public abstract class InputHandler extends KeyAdapter
{
	/**
	 * Creates a new input handler.
	 * @param view The view
	 */
	public InputHandler(View view)
	{
		this.view = view;
	}
	/**
	 * Adds a key binding to this input handler.
	 * @param keyBinding The key binding (the format of this is
	 * input-handler specific)
	 * @param action The action
	 */
	public abstract void addKeyBinding(String keyBinding, EditAction action);
	/**
	 * Removes a key binding from this input handler.
	 * @param keyBinding The key binding
	 */
	public abstract void removeKeyBinding(String keyBinding);
	/**
	 * Removes all key bindings from this input handler.
	 */
	public abstract void removeAllKeyBindings();
	/**
	 * Returns if a prefix key has been pressed.
	 */
	public boolean isPrefixActive()
	{
		return false;
	}
	/**
	 * Returns if repeating is enabled. When repeating is enabled,
	 * actions will be executed multiple times. This is usually
	 * invoked with a special key stroke in the input handler.
	 */
	public boolean isRepeatEnabled()
	{
		return repeat;
	}
	/**
	 * Enables repeating. When repeating is enabled, actions will be
	 * executed multiple times. Once repeating is enabled, the input
	 * handler should read a number from the keyboard.
	 */
	public void setRepeatEnabled(boolean repeat)
	{
		this.repeat = repeat;
		repeatCount = 0;
		view.getStatus().setMessage(null);
	}
	/**
	 * Returns the number of times the next action will be repeated.
	 */
	public int getRepeatCount()
	{
		return (repeat && repeatCount > 0 ? repeatCount : 1);
	}
	/**
	 * Sets the number of times the next action will be repeated.
	 * @param repeatCount The repeat count
	 */
	public void setRepeatCount(int repeatCount)
	{
		repeat = true;
		this.repeatCount = repeatCount;
		view.getStatus().setMessage(null);
	}
	/**
	 * Returns the last executed action.
	 * @since jEdit 2.5pre5
	 */
	public EditAction getLastAction()
	{
		return lastAction;
	}
	/**
	 * Returns the number of times the last action was executed.
	 * @since jEdit 2.5pre5
	 */
	public int getLastActionCount()
	{
		return lastActionCount;
	}
	/**
	 * Invokes the specified BeanShell code, replacing __char__ in the
	 * code with the next input character.
	 * @param msg The prompt to display in the status bar
	 * @param code The code
	 * @since jEdit 3.2pre2
	 */
	public void readNextChar(String msg, String code)
	{
		view.getStatus().setMessage(msg);
		readNextChar(code);
	}
	/**
	 * @deprecated Use the other form of this method instead
	 */
	public void readNextChar(String code)
	{
		readNextChar = code;
	}
	/**
	 * Invokes the specified action, repeating and recording it as
	 * necessary.
	 * @param action The action
	 * @param source The event source
	 */
	public void invokeAction(EditAction action)
	{
		Buffer buffer = view.getBuffer();
		buffer.endCompoundEdit();
		// remember the last executed action
		if(lastAction == action)
			lastActionCount++;
		else
		{
			lastAction = action;
			lastActionCount = 1;
		}
		// remember old values, in case action changes them
		boolean _repeat = repeat;
		int _repeatCount = getRepeatCount();
		// execute the action
		if(action.noRepeat() || _repeatCount == 1)
			action.invoke(view);
		else
		{
			// stop people doing dumb stuff like C+ENTER 100 C+n
			if(_repeatCount > REPEAT_COUNT_THRESHOLD)
			{
				String label = jEdit.getProperty(action.getName() + "".label"");
				if(label == null)
					label = action.getName();
				else
					label = GUIUtilities.prettifyMenuLabel(label);
				Object[] pp = { label, new Integer(_repeatCount) };
				if(GUIUtilities.confirm(view,""large-repeat-count"",pp,
					JOptionPane.WARNING_MESSAGE,
					JOptionPane.YES_NO_OPTION)
					!= JOptionPane.YES_OPTION)
				{
					repeat = false;
					repeatCount = 0;
					view.getStatus().setMessage(null);
					return;
				}
			}
			try
			{
				buffer.beginCompoundEdit();
				for(int i = 0; i < _repeatCount; i++)
					action.invoke(view);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null && !action.noRecord())
			recorder.record(_repeatCount,action.getCode());
		// If repeat was true originally, clear it
		// Otherwise it might have been set by the action, etc
		if(_repeat)
		{
			// first of all, if this action set a
			// readNextChar, do not clear the repeat
			if(readNextChar != null)
				return;
			repeat = false;
			repeatCount = 0;
			view.getStatus().setMessage(null);
		}
	}
	// protected members
	private static final int REPEAT_COUNT_THRESHOLD = 20;
	protected View view;
	protected boolean repeat;
	protected int repeatCount;
	protected EditAction lastAction;
	protected int lastActionCount;
	protected String readNextChar;
	protected void userInput(char ch)
	{
		lastAction = null;
		if(readNextChar != null)
			invokeReadNextChar(ch);
		else
		{
			Buffer buffer = view.getBuffer();
			if(!buffer.insideCompoundEdit())
				buffer.beginCompoundEdit();
			JEditTextArea textArea = view.getTextArea();
			int _repeatCount = getRepeatCount();
			if(_repeatCount == 1)
				textArea.userInput(ch);
			else
			{
				// stop people doing dumb stuff like C+ENTER 100 C+n
				if(_repeatCount > REPEAT_COUNT_THRESHOLD)
				{
					Object[] pp = { String.valueOf(ch),
						new Integer(_repeatCount) };
					if(GUIUtilities.confirm(view,
						""large-repeat-count.user-input"",pp,
						JOptionPane.WARNING_MESSAGE,
						JOptionPane.YES_NO_OPTION)
						!= JOptionPane.YES_OPTION)
					{
						repeat = false;
						repeatCount = 0;
						view.getStatus().setMessage(null);
						return;
					}
				}
				for(int i = 0; i < _repeatCount; i++)
					textArea.userInput(ch);
			}
			Macros.Recorder recorder = view.getMacroRecorder();
			if(recorder != null)
				recorder.record(_repeatCount,ch);
		}
		setRepeatEnabled(false);
	}
	protected void invokeReadNextChar(char ch)
	{
		String charStr = MiscUtilities.charsToEscapes(String.valueOf(ch));
		// this might be a bit slow if __char__ occurs a lot
		int index;
		while((index = readNextChar.indexOf(""__char__"")) != -1)
		{
			readNextChar = readNextChar.substring(0,index)
				+ '\'' + charStr + '\''
				+ readNextChar.substring(index + 8);
		}
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(getRepeatCount(),readNextChar);
		if(getRepeatCount() != 1)
		{
			Buffer buffer = view.getBuffer();
			try
			{
				buffer.beginCompoundEdit();
				BeanShell.eval(view,""for(int i = 1; i < ""
					+ getRepeatCount() + ""; i++)\n{\n""
					+ readNextChar + ""\n}"",false);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
		else
			BeanShell.eval(view,readNextChar,false);
		readNextChar = null;
		view.getStatus().setMessage(null);
	}
}
"
org.gjt.sp.jedit.gui.IOProgressMonitor,"/*
 * IOProgressMonitor.java - I/O progress monitor
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;
public class IOProgressMonitor extends JDialog
{
	public IOProgressMonitor(View view)
	{
		super(view,jEdit.getProperty(""io-progress-monitor.title""),false);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		caption = new JLabel();
		updateCaption();
		content.add(BorderLayout.NORTH,caption);
		Box threadBox = new Box(BoxLayout.Y_AXIS);
		threads = new ThreadProgress[VFSManager.getIOThreadPool()
			.getThreadCount()];
		for(int i = 0; i < threads.length; i++)
		{
			threadBox.add(Box.createVerticalStrut(6));
			threads[i] = new ThreadProgress(i);
			threadBox.add(threads[i]);
		}
		content.add(BorderLayout.CENTER,threadBox);
		workThreadHandler = new WorkThreadHandler();
		VFSManager.getIOThreadPool().addProgressListener(workThreadHandler);
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		GUIUtilities.loadGeometry(this,""io-progress-monitor"");
		show();
	}
	public void dispose()
	{
		GUIUtilities.saveGeometry(this,""io-progress-monitor"");
		VFSManager.getIOThreadPool().removeProgressListener(workThreadHandler);
		super.dispose();
	}
	// private members
	private JLabel caption;
	private ThreadProgress[] threads;
	private WorkThreadHandler workThreadHandler;
	private void updateCaption()
	{
		String[] args = { String.valueOf(VFSManager.getIOThreadPool()
			.getRequestCount()) };
		caption.setText(jEdit.getProperty(""io-progress-monitor.caption"",args));
	}
	class WorkThreadHandler implements WorkThreadProgressListener
	{
		public void progressUpdate(WorkThreadPool pool, int index)
		{
			updateCaption();
			threads[index].update();
		}
	}
	class ThreadProgress extends JPanel
	{
		public ThreadProgress(int index)
		{
			super(new BorderLayout());
			this.index = index;
			JPanel box = new JPanel();
			box.setBorder(new EmptyBorder(0,0,0,12));
			box.setLayout(new BoxLayout(box,BoxLayout.Y_AXIS));
			box.add(Box.createGlue());
			box.add(progress = new JProgressBar());
			progress.setStringPainted(true);
			box.add(Box.createGlue());
			ThreadProgress.this.add(BorderLayout.CENTER,box);
			abort = new JButton(jEdit.getProperty(""io-progress-monitor.abort""));
			abort.addActionListener(new ActionHandler());
			ThreadProgress.this.add(BorderLayout.EAST,abort);
			update();
		}
		public void update()
		{
			WorkThread thread = VFSManager.getIOThreadPool().getThread(index);
			if(thread.isRequestRunning())
			{
				abort.setEnabled(true);
				progress.setString(thread.getStatus());
				progress.setMaximum(thread.getProgressMaximum());
				progress.setValue(thread.getProgressValue());
			}
			else
			{
				abort.setEnabled(false);
				progress.setString(jEdit.getProperty(""io-progress-monitor""
					+ "".idle""));
				progress.setValue(0);
			}
		}
		// private members
		private int index;
		private JProgressBar progress;
		private JButton abort;
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(evt.getSource() == abort)
				{
					int result = GUIUtilities.confirm(
						IOProgressMonitor.this,""abort"",null,
						JOptionPane.YES_NO_OPTION,
						JOptionPane.QUESTION_MESSAGE);
					if(result == JOptionPane.YES_OPTION)
					{
						VFSManager.getIOThreadPool().getThread(index)
							.abortCurrentRequest();
					}
				}
			}
		}
	}
}
"
org.gjt.sp.jedit.gui.JCheckBoxList,"/*
 * JCheckBoxList.java - A list, each item can be checked or unchecked
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.table.*;
import javax.swing.*;
import java.util.Vector;
/**
 * @since jEdit 3.2pre9
 */
public class JCheckBoxList extends JTable
{
	/**
	 * Creates a checkbox list with the given list of objects. The elements
	 * of this array can either be Entry instances, or other objects (if the
	 * latter, they will default to being unchecked).
	 */
	public JCheckBoxList(Object[] items)
	{
		setModel(items);
	}
	/**
	 * Creates a checkbox list with the given list of objects. The elements
	 * of this vector can either be Entry instances, or other objects (if the
	 * latter, they will default to being unchecked).
	 */
	public JCheckBoxList(Vector items)
	{
		setModel(items);
	}
	/**
	 * Sets the model to the given list of objects. The elements of this
	 * array can either be Entry instances, or other objects (if the
	 * latter, they will default to being unchecked).
	 */
	public void setModel(Object[] items)
	{
		setModel(new CheckBoxListModel(items));
		init();
	}
	/**
	 * Sets the model to the given list of objects. The elements of this
	 * vector can either be Entry instances, or other objects (if the
	 * latter, they will default to being unchecked).
	 */
	public void setModel(Vector items)
	{
		setModel(new CheckBoxListModel(items));
		init();
	}
	public Object[] getCheckedValues()
	{
		Vector values = new Vector();
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		for(int i = 0; i < model.items.size(); i++)
		{
			Entry entry = (Entry)model.items.elementAt(i);
			if(entry.checked)
				values.addElement(entry.value);
		}
		Object[] retVal = new Object[values.size()];
		values.copyInto(retVal);
		return retVal;
	}
	public Entry[] getValues()
	{
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		Entry[] retVal = new Entry[model.items.size()];
		model.items.copyInto(retVal);
		return retVal;
	}
	public Object getSelectedValue()
	{
		int row = getSelectedRow();
		if(row == -1)
			return null;
		else
			return getModel().getValueAt(row,1);
	}
	// private members
	private void init()
	{
		getSelectionModel().setSelectionMode(ListSelectionModel
			.SINGLE_SELECTION);
		setShowGrid(false);
		setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
		TableColumn column = getColumnModel().getColumn(0);
		int checkBoxWidth = new JCheckBox().getPreferredSize().width;
		column.setPreferredWidth(checkBoxWidth);
		column.setMinWidth(checkBoxWidth);
		column.setWidth(checkBoxWidth);
		column.setMaxWidth(checkBoxWidth);
		column.setResizable(false);
	}
	public static class Entry
	{
		boolean checked;
		Object value;
		public Entry(boolean checked, Object value)
		{
			this.checked = checked;
			this.value = value;
		}
		public boolean isChecked()
		{
			return checked;
		}
		public Object getValue()
		{
			return value;
		}
	}
}
class CheckBoxListModel extends AbstractTableModel
{
	Vector items;
	CheckBoxListModel(Vector _items)
	{
		items = new Vector(_items.size());
		for(int i = 0; i < _items.size(); i++)
		{
			items.addElement(createEntry(_items.elementAt(i)));
		}
	}
	CheckBoxListModel(Object[] _items)
	{
		items = new Vector(_items.length);
		for(int i = 0; i < _items.length; i++)
		{
			items.addElement(createEntry(_items[i]));
		}
	}
	private JCheckBoxList.Entry createEntry(Object obj)
	{
		if(obj instanceof JCheckBoxList.Entry)
			return (JCheckBoxList.Entry)obj;
		else
			return new JCheckBoxList.Entry(false,obj);
	}
	public int getRowCount()
	{
		return items.size();
	}
	public int getColumnCount()
	{
		return 2;
	}
	public String getColumnName(int col)
	{
		return null;
	}
	public Object getValueAt(int row, int col)
	{
		JCheckBoxList.Entry entry = (JCheckBoxList.Entry)items.elementAt(row);
		switch(col)
		{
		case 0:
			return new Boolean(entry.checked);
		case 1:
			return entry.value;
		default:
			throw new InternalError();
		}
	}
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
			return Boolean.class;
		case 1:
			return String.class;
		default:
			throw new InternalError();
		}
	}
	public boolean isCellEditable(int row, int col)
	{
		return (col == 0 && !(((JCheckBoxList.Entry)items.elementAt(row)).value
			instanceof String));
	}
	public void setValueAt(Object value, int row, int col)
	{
		if(col == 0)
		{
			((JCheckBoxList.Entry)items.elementAt(row)).checked =
				(value.equals(Boolean.TRUE));
		}
	}
}
"
org.gjt.sp.jedit.gui.KeyEventWorkaround,"/*
 * KeyEventWorkaround.java - Works around bugs in Java event handling
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import java.awt.event.*;
import java.awt.*;
public class KeyEventWorkaround
{
	// from JDK 1.2 InputEvent.java
	public static final int ALT_GRAPH_MASK = 1 << 5;
	public static KeyEvent processKeyEvent(KeyEvent evt)
	{
		int keyCode = evt.getKeyCode();
		char ch = evt.getKeyChar();
		switch(evt.getID())
		{
		case KeyEvent.KEY_PRESSED:
			// get rid of keys we never need to handle
			if(keyCode == KeyEvent.VK_CONTROL ||
				keyCode == KeyEvent.VK_SHIFT ||
				keyCode == KeyEvent.VK_ALT ||
				keyCode == KeyEvent.VK_META ||
				keyCode == '\0')
				return null;
			if(!java14)
				handleBrokenKeys(evt.getModifiers(),keyCode);
			return evt;
		case KeyEvent.KEY_TYPED:
			// need to let \b through so that backspace will work
			// in HistoryTextFields
			if((ch < 0x20 || ch == 0x7f || ch == 0xff) && ch != '\b')
				return null;
			if((evt.isControlDown() ^ evt.isAltDown())
				|| evt.isMetaDown())
				return null;
			if(!java14)
			{
				// if the last key was a broken key, filter
				// out all except 'a'-'z' that occur 750 ms after.
				if(last == LAST_BROKEN && System.currentTimeMillis()
					- lastKeyTime < 750 && !Character.isLetter(ch))
				{
					last = LAST_NOTHING;
					return null;
				}
				// otherwise, if it was ALT, filter out everything.
				else if(last == LAST_ALT && System.currentTimeMillis()
					- lastKeyTime < 750)
				{
					last = LAST_NOTHING;
					return null;
				}
			}
			return evt;
		default:
			return evt;
		}
	}
	// private members
	private static boolean java14;
	private static long lastKeyTime;
	private static int last;
	private static final int LAST_NOTHING = 0;
	private static final int LAST_ALTGR = 1;
	private static final int LAST_ALT = 2;
	private static final int LAST_BROKEN = 3;
	static
	{
		java14 = (System.getProperty(""java.version"").compareTo(""1.4"") >= 0);
	}
	private static void handleBrokenKeys(int modifiers, int keyCode)
	{
		// If you have any keys you would like to add to this list,
		// e-mail me
		if(modifiers == (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK)
			|| modifiers == (KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK
			| KeyEvent.SHIFT_MASK))
		{
			last = LAST_ALTGR;
			return;
		}
		else if((modifiers & (~ (ALT_GRAPH_MASK | KeyEvent.SHIFT_MASK))) == 0)
		{
			last = LAST_NOTHING;
			return;
		}
		if((modifiers & KeyEvent.ALT_MASK) != 0)
			last = LAST_ALT;
		else if((keyCode < KeyEvent.VK_A || keyCode > KeyEvent.VK_Z)
			&& keyCode != KeyEvent.VK_LEFT && keyCode != KeyEvent.VK_RIGHT
			&& keyCode != KeyEvent.VK_UP && keyCode != KeyEvent.VK_DOWN
			&& keyCode != KeyEvent.VK_DELETE && keyCode != KeyEvent.VK_BACK_SPACE
			 && keyCode != KeyEvent.VK_TAB && keyCode != KeyEvent.VK_ENTER)
			last = LAST_BROKEN;
		else
			last = LAST_NOTHING;
		lastKeyTime = System.currentTimeMillis();
	}
}
"
org.gjt.sp.jedit.gui.LogViewer,"/*
 * LogViewer.java
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
public class LogViewer extends JPanel implements DockableWindow
{
	public LogViewer()
	{
		super(new BorderLayout());
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			String[] args = { MiscUtilities.constructPath(
				settingsDirectory, ""activity.log"") };
			JLabel label = new JLabel(jEdit.getProperty(
				""log-viewer.caption"",args));
			add(BorderLayout.NORTH,label);
		}
		JTextArea textArea = new JTextArea(24,80);
		textArea.setDocument(Log.getLogDocument());
		//textArea.setEditable(false);
		add(BorderLayout.CENTER,new JScrollPane(textArea));
	}
	public String getName()
	{
		return ""log-viewer"";
	}
	public Component getComponent()
	{
		return this;
	}
}
"
org.gjt.sp.jedit.gui.MacrosMenu,"/*
 * MacrosMenu.java - Macros menu
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.msg.MacrosChanged;
import org.gjt.sp.jedit.*;
public class MacrosMenu extends EnhancedMenu implements EBComponent
{
	public MacrosMenu()
	{
		super(""macros"");
		updateMacrosMenu();
	}
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	}
	public void removeNotify()
	{
		super.removeNotify();
		EditBus.removeFromBus(this);
	}
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof MacrosChanged)
			updateMacrosMenu();
	}
	private void updateMacrosMenu()
	{
		// Because the macros menu contains normal items as
		// well as dynamically-generated stuff, we are careful
		// to only remove the dynamic crap here...
		for(int i = getMenuComponentCount() - 1; i >= 0; i--)
		{
			if(getMenuComponent(i) instanceof JSeparator)
				break;
			else
				remove(i);
		}
		int count = getMenuComponentCount();
		Vector macroVector = Macros.getMacroHierarchy();
		createMacrosMenu(this,macroVector,0);
		if(count == getMenuComponentCount())
			add(GUIUtilities.loadMenuItem(""no-macros""));
	}
	private void createMacrosMenu(JMenu menu, Vector vector, int start)
	{
		for(int i = start; i < vector.size(); i++)
		{
			Object obj = vector.elementAt(i);
			if(obj instanceof Macros.Macro)
			{
				Macros.Macro macro = (Macros.Macro)obj;
				String label = macro.name;
				int index = label.lastIndexOf('/');
				label = label.substring(index + 1)
					.replace('_',' ');
				menu.add(new EnhancedMenuItem(label,
					macro.action));
			}
			else if(obj instanceof Vector)
			{
				Vector subvector = (Vector)obj;
				String name = (String)subvector.elementAt(0);
				JMenu submenu = new JMenu(name);
				createMacrosMenu(submenu,subvector,1);
				if(submenu.getMenuComponentCount() == 0)
				{
					submenu.add(GUIUtilities.loadMenuItem(
						""no-macros""));
				}
				menu.add(submenu);
			}
		}
	}
}
"
org.gjt.sp.jedit.gui.MarkersMenu,"/*
 * MarkersMenu.java - Markers menu
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.text.BadLocationException;
import javax.swing.text.Element;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
public class MarkersMenu extends EnhancedMenu
{
	public MarkersMenu()
	{
		super(""markers"");
	}
	public void setPopupMenuVisible(boolean b)
	{
		if(b)
		{
			final View view = EditAction.getView(this);
			if(getMenuComponentCount() != 0)
			{
				for(int i = getMenuComponentCount() - 1;
					i >= 0;
					i--)
				{
					Component comp = getMenuComponent(i);
					if(comp instanceof JSeparator)
						break;
					else
						remove(comp);
				}
			}
			Buffer buffer = view.getBuffer();
			Element map = buffer.getDefaultRootElement();
			Vector markers = buffer.getMarkers();
			if(markers.size() == 0)
			{
				JMenuItem mi = new JMenuItem(jEdit.getProperty(
					""no-markers.label""));
				mi.setEnabled(false);
				add(mi);
				super.setPopupMenuVisible(b);
				return;
			}
			JMenu current = this;
			for(int i = 0; i < markers.size(); i++)
			{
				final Marker marker = (Marker)markers.elementAt(i);
				int lineNo = map.getElementIndex(
					marker.getPosition());
				if(current.getItemCount() >= 20)
				{
					//current.addSeparator();
					JMenu newCurrent = new JMenu(
						jEdit.getProperty(
						""common.more""));
					current.add(newCurrent);
					current = newCurrent;
				}
				JMenuItem mi = new MarkersMenuItem(buffer,
					lineNo,marker.getShortcut());
				mi.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent evt)
					{
						view.getTextArea().setCaretPosition(
							marker.getPosition());
					}
				});
				current.add(mi);
			}
		}
		super.setPopupMenuVisible(b);
	}
	static class MarkersMenuItem extends JMenuItem
	{
		MarkersMenuItem(Buffer buffer, int lineNo, char shortcut)
		{
			Element line = buffer.getDefaultRootElement()
				.getElement(lineNo);
			try
			{
				int start = line.getStartOffset();
				String text = buffer.getText(start,
					line.getEndOffset() - start - 1);
				text = text.trim();
				if(text.length() == 0)
					text = jEdit.getProperty(""markers.blank-line"");
				setText(lineNo + "": "" + text);
			}
			catch(BadLocationException ble)
			{
				Log.log(Log.ERROR,this,ble);
			}
			shortcutProp = ""goto-marker.shortcut"";
			MarkersMenuItem.this.shortcut = shortcut;
		}
		public Dimension getPreferredSize()
		{
			Dimension d = super.getPreferredSize();
			String shortcut = getShortcut();
			if(shortcut != null)
			{
				d.width += (getFontMetrics(acceleratorFont)
					.stringWidth(shortcut) + 10);
			}
			return d;
		}
		public void paint(Graphics g)
		{
			super.paint(g);
			String shortcut = getShortcut();
			if(shortcut != null)
			{
				g.setFont(acceleratorFont);
				g.setColor(getModel().isArmed() ?
					acceleratorSelectionForeground :
					acceleratorForeground);
				FontMetrics fm = g.getFontMetrics();
				Insets insets = getInsets();
				g.drawString(shortcut,getWidth() - (fm.stringWidth(
					shortcut) + insets.right + insets.left),
					getFont().getSize() + (insets.top - 1)
					/* XXX magic number */);
			}
		}
		// private members
		private String shortcutProp;
		private char shortcut;
		private static Font acceleratorFont;
		private static Color acceleratorForeground;
		private static Color acceleratorSelectionForeground;
		private String getShortcut()
		{
			if(shortcut == '\0')
				return null;
			else
			{
				String shortcutPrefix = jEdit.getProperty(shortcutProp);
				if(shortcutPrefix == null)
					return null;
				else
				{
					return shortcutPrefix + "" "" + shortcut;
				}
			}
		}
		static
		{
			acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
			acceleratorFont = new Font(""Monospaced"",
				acceleratorFont.getStyle(),
				acceleratorFont.getSize());
			acceleratorForeground = UIManager
				.getColor(""MenuItem.acceleratorForeground"");
			acceleratorSelectionForeground = UIManager
				.getColor(""MenuItem.acceleratorSelectionForeground"");
		}
	}
}
"
org.gjt.sp.jedit.gui.OpenWithEncodingMenu,"/*
 * OpenWithEncodingMenu.java - 'Open With Encoding' menu
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.awt.Component;
import java.util.Hashtable;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;
public class OpenWithEncodingMenu extends EnhancedMenu
{
	public OpenWithEncodingMenu()
	{
		super(""open-encoding"");
		ActionListener listener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				Hashtable props = new Hashtable();
				props.put(""encoding"",evt.getActionCommand());
				jEdit.showOpenFileDialog(EditAction.getView(
					(Component)evt.getSource()),props);
			}
		};
		// used twice...
		String systemEncoding = System.getProperty(""file.encoding"");
		JMenuItem mi = new JMenuItem(jEdit.getProperty(""os-encoding""));
		mi.setActionCommand(systemEncoding);
		mi.addActionListener(listener);
		add(mi);
		mi = new JMenuItem(jEdit.getProperty(""jedit-encoding""));
		mi.setActionCommand(jEdit.getProperty(""buffer.encoding"",systemEncoding));
		mi.addActionListener(listener);
		add(mi);
		addSeparator();
		StringTokenizer st = new StringTokenizer(jEdit.getProperty(""encodings""));
		while(st.hasMoreTokens())
		{
			mi = new JMenuItem(st.nextToken());
			mi.addActionListener(listener);
			add(mi);
		}
		addSeparator();
		add(GUIUtilities.loadMenuItem(""other-encoding""));
	}
}
"
org.gjt.sp.jedit.gui.OptionsDialog,"/*
 * OptionsDialog.java - Global options dialog
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 * Portions copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.options.*;
import org.gjt.sp.util.Log;
/**
 * An abstract tabbed options dialog box.
 * @author Slava Pestov
 * @version $Id: OptionsDialog.java,v 1.38 2001/08/07 07:24:48 sp Exp $
 */
public class OptionsDialog extends EnhancedDialog
	implements ActionListener, TreeSelectionListener
{
	public OptionsDialog(View view)
	{
		super(view, jEdit.getProperty(""options.title""), true);
		view.showWaitCursor();
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		content.setLayout(new BorderLayout());
		JPanel stage = new JPanel(new BorderLayout());
		stage.setBorder(new EmptyBorder(0,6,0,0));
		content.add(stage, BorderLayout.CENTER);
		// currentLabel displays the path of the currently selected
		// OptionPane at the top of the stage area
		currentLabel = new JLabel();
		currentLabel.setHorizontalAlignment(JLabel.LEFT);
		currentLabel.setBorder(BorderFactory.createMatteBorder(0, 0, 1,
			0, Color.black));
		stage.add(currentLabel, BorderLayout.NORTH);
		cardPanel = new JPanel(new CardLayout());
		cardPanel.setBorder(new EmptyBorder(5,0,0,0));
		stage.add(cardPanel, BorderLayout.CENTER);
		paneTree = new JTree(createOptionTreeModel());
		paneTree.setCellRenderer(new PaneNameRenderer());
		paneTree.putClientProperty(""JTree.lineStyle"", ""Angled"");
		paneTree.setShowsRootHandles(true);
		paneTree.setRootVisible(false);
		content.add(new JScrollPane(paneTree,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED),
			BorderLayout.WEST);
		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(this);
		buttons.add(ok);
		buttons.add(Box.createHorizontalStrut(6));
		getRootPane().setDefaultButton(ok);
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(this);
		buttons.add(cancel);
		buttons.add(Box.createHorizontalStrut(6));
		apply = new JButton(jEdit.getProperty(""common.apply""));
		apply.addActionListener(this);
		buttons.add(apply);
		buttons.add(Box.createGlue());
		content.add(buttons, BorderLayout.SOUTH);
		// compute the jEdit branch
		TreePath jEditPath = new TreePath(new Object[]{ paneTree
			.getModel().getRoot(), jEditGroup });
		// register the Options dialog as a TreeSelectionListener.
		// this is done before the initial selection to ensure that the
		// first selected OptionPane is displayed on startup.
		paneTree.getSelectionModel().addTreeSelectionListener(this);
		// select the first member of the jEdit group
		paneTree.setSelectionPath(jEditPath.pathByAddingChild(
			jEditGroup.getMember(0)));
		view.hideWaitCursor();
		pack();
		setLocationRelativeTo(view);
		show();
	}
	public void addOptionGroup(OptionGroup group)
	{
		addOptionGroup(group, pluginsGroup);
	}
	public void addOptionPane(OptionPane pane)
	{
		addOptionPane(pane, pluginsGroup);
	}
	// EnhancedDialog implementation
	public void ok()
	{
		ok(true);
	}
	public void cancel()
	{
		dispose();
	}
	// end EnhancedDialog implementation
	public void ok(boolean dispose)
	{
		OptionTreeModel m = (OptionTreeModel) paneTree
			.getModel();
		((OptionGroup) m.getRoot()).save();
		/* This will fire the PROPERTIES_CHANGED event */
		jEdit.propertiesChanged();
		// Save settings to disk
		jEdit.saveSettings();
		// get rid of this dialog if necessary
		if(dispose)
			dispose();
	}
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
		{
			ok();
		}
		else if(source == cancel)
		{
			cancel();
		}
		else if(source == apply)
		{
			ok(false);
		}
	}
	public void valueChanged(TreeSelectionEvent evt)
	{
		TreePath path = evt.getPath();
		if (path == null || !(path.getLastPathComponent() instanceof
			OptionPane)) return;
		Object[] nodes = path.getPath();
		StringBuffer buf = new StringBuffer();
		OptionPane optionPane = null;
		String name = null;
		int lastIdx = nodes.length - 1;
		for (int i = paneTree.isRootVisible() ? 0 : 1;
			i <= lastIdx; i++)
		{
			if (nodes[i] instanceof OptionPane)
			{
				optionPane = (OptionPane)nodes[i];
				name = optionPane.getName();
			}
			else if (nodes[i] instanceof OptionGroup)
			{
				name = ((OptionGroup)nodes[i]).getName();
			}
			else
			{
				continue;
			}
			if (name != null)
			{
				String label = jEdit.getProperty(""options."" +
					name + "".label"");
				if (label == null)
				{
					buf.append(name);
				}
				else
				{
					buf.append(label);
				}
			}
			if (i != lastIdx) buf.append("": "");
		}
		currentLabel.setText(buf.toString());
		optionPane.init();
		pack();
		((CardLayout)cardPanel.getLayout()).show(cardPanel, name);
	}
	// private members
	private Hashtable panes;
	private JTree paneTree;
	private JPanel cardPanel;
	private JLabel currentLabel;
	private JButton ok;
	private JButton cancel;
	private JButton apply;
	private OptionGroup jEditGroup;
	private OptionGroup pluginsGroup;
	private OptionTreeModel createOptionTreeModel()
	{
		OptionTreeModel paneTreeModel = new OptionTreeModel();
		OptionGroup rootGroup = (OptionGroup) paneTreeModel.getRoot();
		// initialize the jEdit branch of the options tree
		jEditGroup = new OptionGroup(""jedit"");
		addOptionPane(new GeneralOptionPane(), jEditGroup);
		addOptionPane(new LoadSaveOptionPane(), jEditGroup);
		addOptionPane(new EditingOptionPane(), jEditGroup);
		addOptionPane(new ModeOptionPane(), jEditGroup);
		addOptionPane(new TextAreaOptionPane(), jEditGroup);
		addOptionPane(new GutterOptionPane(), jEditGroup);
		addOptionPane(new ColorOptionPane(), jEditGroup);
		addOptionPane(new StyleOptionPane(), jEditGroup);
		addOptionPane(new ShortcutsOptionPane(), jEditGroup);
		addOptionPane(new DockingOptionPane(), jEditGroup);
		addOptionPane(new ContextOptionPane(), jEditGroup);
		addOptionPane(new ToolBarOptionPane(), jEditGroup);
		addOptionPane(new AbbrevsOptionPane(), jEditGroup);
		addOptionPane(new PrintOptionPane(), jEditGroup);
		addOptionPane(new BrowserOptionPane(), jEditGroup);
		addOptionGroup(jEditGroup, rootGroup);
		// initialize the Plugins branch of the options tree
		pluginsGroup = new OptionGroup(""plugins"");
		// Query plugins for option panes
		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin ep = plugins[i];
			try
			{
				ep.createOptionPanes(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR, ep,
					""Error creating option pane"");
				Log.log(Log.ERROR, ep, t);
			}
		}
		// only add the Plugins branch if there are OptionPanes
		if (pluginsGroup.getMemberCount() > 0)
		{
			addOptionGroup(pluginsGroup, rootGroup);
		}
		return paneTreeModel;
	}
	private void addOptionGroup(OptionGroup child, OptionGroup parent)
	{
		Enumeration enum = child.getMembers();
		while (enum.hasMoreElements())
		{
			Object elem = enum.nextElement();
			if (elem instanceof OptionPane)
			{
				addOptionPane((OptionPane) elem, child);
			}
			else if (elem instanceof OptionGroup)
			{
				addOptionGroup((OptionGroup) elem, child);
			}
		}
		parent.addOptionGroup(child);
	}
	private void addOptionPane(OptionPane pane, OptionGroup parent)
	{
		String name = pane.getName();
		cardPanel.add(pane.getComponent(), name);
		parent.addOptionPane(pane);
	}
	class PaneNameRenderer extends JLabel implements TreeCellRenderer
	{
		public PaneNameRenderer()
		{
			setOpaque(true);
			paneFont = UIManager.getFont(""Tree.font"");
			groupFont = new Font(paneFont.getName(),
				paneFont.getStyle() | Font.BOLD,
				paneFont.getSize());
		}
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean selected, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			if (selected)
			{
				this.setBackground(UIManager.getColor(
					""Tree.selectionBackground""));
				this.setForeground(UIManager.getColor(
					""Tree.selectionForeground""));
			}
			else
			{
				this.setBackground(UIManager.getColor(
					""Tree.background""));
				this.setForeground(UIManager.getColor(
					""Tree.foreground""));
			}
			String name = null;
			if (value instanceof OptionGroup)
			{
				name = ((OptionGroup)value).getName();
				this.setFont(groupFont);
			}
			else if (value instanceof OptionPane)
			{
				name = ((OptionPane)value).getName();
				this.setFont(paneFont);
			}
			if (name == null)
			{
				setText(null);
			}
			else
			{
				String label = jEdit.getProperty(""options."" +
					name + "".label"");
				if (label == null)
				{
					setText(name);
				}
				else
				{
					setText(label);
				}
			}
			setIcon(null);
			return this;
		}
		private Border noFocusBorder = BorderFactory.createEmptyBorder(
			1, 1, 1, 1);
		private Border focusBorder = BorderFactory.createLineBorder(
			UIManager.getColor(""Tree.selectionBorderColor""));
		private Font paneFont;
		private Font groupFont;
	}
	class OptionTreeModel implements TreeModel
	{
		public void addTreeModelListener(TreeModelListener l)
		{
			listenerList.add(TreeModelListener.class, l);
		}
		public void removeTreeModelListener(TreeModelListener l)
		{
			listenerList.remove(TreeModelListener.class, l);
		}
		public Object getChild(Object parent, int index)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent).getMember(index);
			}
			else
			{
				return null;
			}
		}
		public int getChildCount(Object parent)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent).getMemberCount();
			}
			else
			{
				return 0;
			}
		}
		public int getIndexOfChild(Object parent, Object child)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent)
					.getMemberIndex(child);
			}
			else
			{
				return -1;
			}
		}
		public Object getRoot()
		{
			return root;
		}
		public boolean isLeaf(Object node)
		{
			return node instanceof OptionPane;
		}
		public void valueForPathChanged(TreePath path, Object newValue)
		{
			// this model may not be changed by the TableCellEditor
		}
		protected void fireNodesChanged(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();
			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;
				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}
				((TreeModelListener)listeners[i + 1])
					.treeNodesChanged(modelEvent);
			}
		}
		protected void fireNodesInserted(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();
			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;
				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}
				((TreeModelListener)listeners[i + 1])
					.treeNodesInserted(modelEvent);
			}
		}
		protected void fireNodesRemoved(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();
			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;
				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}
				((TreeModelListener)listeners[i + 1])
					.treeNodesRemoved(modelEvent);
			}
		}
		protected void fireTreeStructureChanged(Object source,
			Object[] path, int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();
			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;
				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}
				((TreeModelListener)listeners[i + 1])
					.treeStructureChanged(modelEvent);
			}
		}
		private OptionGroup root = new OptionGroup(""root"");
		private EventListenerList listenerList = new EventListenerList();
	}
}
"
org.gjt.sp.jedit.gui.PastePrevious,"/*
 * PastePrevious.java - Paste previous dialog
 * Copyright (C) 1998, 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
public class PastePrevious extends EnhancedDialog
implements ActionListener, ListSelectionListener, MouseListener
{
	public PastePrevious(View view)
	{
		super(view,jEdit.getProperty(""pasteprev.title""),true);
		this.view = view;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		clipHistory = HistoryModel.getModel(""clipboard"");
		clips = new JList(new AbstractListModel() {
			public int getSize()
			{
				return clipHistory.getSize();
			}
			public Object getElementAt(int index)
			{
				return clipHistory.getItem(index);
			}
		});
		clips.setVisibleRowCount(16);
		clips.addMouseListener(this);
		clips.addListSelectionListener(this);
		insert = new JButton(jEdit.getProperty(""pasteprev.insert""));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		JLabel label = new JLabel(jEdit.getProperty(""pasteprev.caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		content.add(BorderLayout.NORTH,label);
		JScrollPane scroller = new JScrollPane(clips);
		Dimension dim = scroller.getPreferredSize();
		scroller.setPreferredSize(new Dimension(640,dim.height));
		content.add(scroller, BorderLayout.CENTER);
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		panel.add(Box.createGlue());
		panel.add(insert);
		panel.add(Box.createHorizontalStrut(6));
		panel.add(cancel);
		panel.add(Box.createGlue());
		content.add(panel, BorderLayout.SOUTH);
		updateButtons();
		getRootPane().setDefaultButton(insert);
		insert.addActionListener(this);
		cancel.addActionListener(this);
		GUIUtilities.requestFocus(this,clips);
		pack();
		setLocationRelativeTo(view);
		show();
	}
	// EnhancedDialog implementation
	public void ok()
	{
		int selected = clips.getSelectedIndex();
		if(selected == -1)
		{
			view.getToolkit().beep();
			return;
		}
		String clip = clipHistory.getItem(selected);
		view.getTextArea().setSelectedText(clip);
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	// end EnhancedDialog implementation
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == insert)
			ok();
		else if(source == cancel)
			cancel();
	}
	public void mouseClicked(MouseEvent evt)
	{
		if(evt.getClickCount() == 2)
			ok();
	}
	public void mouseEntered(MouseEvent evt) {}
	public void mouseExited(MouseEvent evt) {}
	public void mousePressed(MouseEvent evt) {}
	public void mouseReleased(MouseEvent evt) {}
	public void valueChanged(ListSelectionEvent evt)
	{
		updateButtons();
	}
	// private members
	private View view;
	private JList clips;
	private HistoryModel clipHistory;
	private JButton insert;
	private JButton cancel;
	private void updateButtons()
	{
		int selected = clips.getSelectedIndex();
		insert.setEnabled(selected != -1);
	}
}
"
org.gjt.sp.jedit.gui.PluginsMenu,"/*
 * PluginsMenu.java - Plugins menu
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
public class PluginsMenu extends EnhancedMenu
{
	public PluginsMenu()
	{
		super(""plugins"");
		// Query plugins for menu items
		Vector pluginMenuItems = new Vector();
		EditPlugin[] pluginArray = jEdit.getPlugins();
		for(int i = 0; i < pluginArray.length; i++)
		{
			try
			{
				EditPlugin plugin = pluginArray[i];
				// call old API
				int count = pluginMenuItems.size();
				plugin.createMenuItems(null,pluginMenuItems,
					pluginMenuItems);
				if(count != pluginMenuItems.size())
				{
					Log.log(Log.WARNING,this,plugin.getClassName()
						+ "" is using the obsolete""
						+ "" createMenuItems() API."");
				}
				// call new API
				plugin.createMenuItems(pluginMenuItems);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Error creating menu items""
					+ "" for plugin"");
				Log.log(Log.ERROR,this,t);
			}
		}
		if(pluginMenuItems.isEmpty())
		{
			add(GUIUtilities.loadMenuItem(""no-plugins""));
			return;
		}
		// Sort them
		MiscUtilities.quicksort(pluginMenuItems,
			new MiscUtilities.MenuItemCompare());
		JMenu menu = this;
		for(int i = 0; i < pluginMenuItems.size(); i++)
		{
			if(menu.getItemCount() >= 20)
			{
				menu.addSeparator();
				JMenu newMenu = new JMenu(jEdit.getProperty(
					""common.more""));
				menu.add(newMenu);
				menu = newMenu;
			}
			menu.add((JMenuItem)pluginMenuItems.elementAt(i));
		}
	}
}
"
org.gjt.sp.jedit.gui.RecentFilesMenu,"/*
 * RecentFilesMenu.java - Recent file list menu
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.*;
public class RecentFilesMenu extends EnhancedMenu
{
	public RecentFilesMenu()
	{
		super(""recent-files"");
	}
	public void setPopupMenuVisible(boolean b)
	{
		if(b)
		{
			final View view = EditAction.getView(this);
			if(getMenuComponentCount() != 0)
				removeAll();
			ActionListener actionListener = new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					jEdit.openFile(view,evt.getActionCommand());
					view.getStatus().setMessage(null);
				}
			};
			MouseListener mouseListener = new MouseAdapter()
			{
				public void mouseEntered(MouseEvent evt)
				{
					view.getStatus().setMessage(
						((JMenuItem)evt.getSource())
						.getActionCommand());
				}
				public void mouseExited(MouseEvent evt)
				{
					view.getStatus().setMessage(null);
				}
			};
			Vector recentVector = BufferHistory.getBufferHistory();
			if(recentVector.size() == 0)
			{
				add(GUIUtilities.loadMenuItem(""no-recent""));
				return;
			}
			/*
			 * While recentVector has 50 entries or so, we only display
			 * a few of those in the menu (otherwise it will be way too
			 * long)
			 */
			int recentFileCount = Math.min(recentVector.size(),
				Integer.parseInt(jEdit.getProperty(""history"")));
			for(int i = recentVector.size() - 1;
				i >= recentVector.size() - recentFileCount;
				i--)
			{
				String path = ((BufferHistory.Entry)recentVector
					.elementAt(i)).path;
				VFS vfs = VFSManager.getVFSForPath(path);
				JMenuItem menuItem = new JMenuItem(vfs.getFileName(path));
				menuItem.setActionCommand(path);
				menuItem.addActionListener(actionListener);
				menuItem.addMouseListener(mouseListener);
				add(menuItem);
			}
		}
		super.setPopupMenuVisible(b);
	}
}
"
org.gjt.sp.jedit.gui.SelectLineRange,"/*
 * SelectLineRange.java - Selects a range of lines
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.text.Element;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
public class SelectLineRange extends EnhancedDialog implements ActionListener
{
	public SelectLineRange(View view)
	{
		super(view,jEdit.getProperty(""selectlinerange.title""),true);
		this.view = view;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,0));
		setContentPane(content);
		JLabel label = new JLabel(jEdit.getProperty(
			""selectlinerange.caption""));
		label.setBorder(new EmptyBorder(0,0,6,12));
		content.add(BorderLayout.NORTH,label);
		JPanel panel = createFieldPanel();
		content.add(BorderLayout.CENTER,panel);
		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(6,0,0,12));
		panel.add(Box.createGlue());
		panel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(this);
		getRootPane().setDefaultButton(ok);
		panel.add(ok);
		panel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(this);
		panel.add(cancel);
		panel.add(Box.createGlue());
		content.add(panel,BorderLayout.SOUTH);
		GUIUtilities.requestFocus(this,startField);
		pack();
		setLocationRelativeTo(view);
		show();
	}
	// EnhancedDialog implementation
	public void ok()
	{
		int startLine;
		int endLine;
		try
		{
			startLine = Integer.parseInt(startField.getText()) - 1;
			endLine = Integer.parseInt(endField.getText()) - 1;
		}
		catch(NumberFormatException nf)
		{
			getToolkit().beep();
			return;
		}
		Buffer buffer = view.getBuffer();
		Element map = buffer.getDefaultRootElement();
		if(startLine < 0 || endLine >= map.getElementCount())
		{
			getToolkit().beep();
			return;
		}
		int startOffset = map.getElement(startLine).getStartOffset();
		int endOffset = map.getElement(endLine).getEndOffset() - 1;
		JEditTextArea textArea = view.getTextArea();
		textArea.setSelection(new Selection.Range(startOffset,endOffset));
		textArea.moveCaretPosition(endOffset);
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	// end EnhancedDialog implementation
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
			ok();
		else if(source == cancel)
			cancel();
	}
	// private members
	private View view;
	private JTextField startField;
	private JTextField endField;
	private JButton ok;
	private JButton cancel;
	private JPanel createFieldPanel()
	{
		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);
		GridBagConstraints cons = new GridBagConstraints();
		cons.insets = new Insets(0,0,6,12);
		cons.gridwidth = cons.gridheight = 1;
		cons.gridx = cons.gridy = 0;
		cons.fill = GridBagConstraints.BOTH;
		JLabel label = new JLabel(jEdit.getProperty(""selectlinerange.start""),
			SwingConstants.RIGHT);
		layout.setConstraints(label,cons);
		panel.add(label);
		startField = new JTextField(10);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(startField,cons);
		panel.add(startField);
		label = new JLabel(jEdit.getProperty(""selectlinerange.end""),
			SwingConstants.RIGHT);
		cons.gridx = 0;
		cons.weightx = 0.0f;
		cons.gridy = 1;
		layout.setConstraints(label,cons);
		panel.add(label);
		endField = new JTextField(10);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(endField,cons);
		panel.add(endField);
		return panel;
	}
}
"
org.gjt.sp.jedit.gui.SplashScreen,"/*
 * SplashScreen.java - Splash screen
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.*;
import java.net.URL;
import java.util.Random;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.util.Log;
public class SplashScreen extends JWindow
{
	public SplashScreen()
	{
		setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
		JPanel splash = new JPanel(new BorderLayout(12,12));
		splash.setBorder(new CompoundBorder(
			new MatteBorder(1,1,1,1,Color.black),
			new EmptyBorder(12,12,12,12)));
		splash.setBackground(Color.white);
		URL url = getClass().getResource(""/org/gjt/sp/jedit/jedit_logo.gif"");
		if(url != null)
		{
			JLabel label = new JLabel(new ImageIcon(url));
			//label.setBorder(new MatteBorder(1,1,1,1,Color.black));
			splash.add(label,BorderLayout.CENTER);
		}
		progress = new JProgressBar(0,6);
		progress.setStringPainted(true);
		//progress.setBorderPainted(false);
		progress.setString(""jEdit version: "" + jEdit.getVersion());
		//progress.setBackground(Color.white);
		splash.add(BorderLayout.SOUTH,progress);
		setContentPane(splash);
		Dimension screen = getToolkit().getScreenSize();
		pack();
		setLocation((screen.width - getSize().width) / 2,
			(screen.height - getSize().height) / 2);
		show();
	}
	public void advance()
	{
		try
		{
			SwingUtilities.invokeAndWait(new Runnable() {
				public void run()
				{
					progress.setValue(progress.getValue() + 1);
				}
			});
			Thread.yield();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
	}
	// private members
	private JProgressBar progress;
}
"
org.gjt.sp.jedit.gui.StatusBar,"/*
 * StatusBar.java - The status bar displayed at the bottom of views
 * Copyright (C) 2001 Slava Pestov
 * Portions copyright (C) 2001 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.*;
import javax.swing.text.Segment;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;
/**
 * The status bar, used for the following:
 * <ul>
 * <li>Displaying caret position information
 * <li>Displaying readNextChar() prompts
 * <li>Displaying the 'macro recording' message
 * <li>Displaying the status of the overwrite, multi select flags
 * <li>I/O progress
 * <li>And so on
 * </ul>
 *
 * @version $Id: StatusBar.java,v 1.26 2001/07/28 12:34:43 sp Exp $
 * @author Slava Pestov
 * @since jEdit 3.2pre2
 */
public class StatusBar extends JPanel
{
	public StatusBar(View view)
	{
		super(new BorderLayout(3,3));
		setBorder(new EmptyBorder(3,0,0,0));
		this.view = view;
		Border border = new BevelBorder(BevelBorder.LOWERED);
		caretStatus = new VICaretStatus();
		caretStatus.setBorder(border);
		add(BorderLayout.WEST,caretStatus);
		message = new JLabel();
		message.setForeground(Color.black);
		message.setBorder(border);
		add(BorderLayout.CENTER,message);
		MouseHandler mouseHandler = new MouseHandler();
		Box box = new Box(BoxLayout.X_AXIS);
		mode = new JLabel();
		mode.setForeground(Color.black);
		mode.setBorder(border);
		mode.setToolTipText(jEdit.getProperty(""view.status.mode-tooltip""));
		mode.addMouseListener(mouseHandler);
		box.add(mode);
		box.add(Box.createHorizontalStrut(3));
		encoding = new JLabel();
		encoding.setForeground(Color.black);
		encoding.setBorder(border);
		encoding.setToolTipText(jEdit.getProperty(""view.status.encoding-tooltip""));
		encoding.addMouseListener(mouseHandler);
		box.add(encoding);
		box.add(Box.createHorizontalStrut(3));
		multiSelect = new JLabel(""multi"");
		multiSelect.setBorder(border);
		multiSelect.addMouseListener(mouseHandler);
		box.add(multiSelect);
		box.add(Box.createHorizontalStrut(3));
		overwrite = new JLabel(""over"");
		overwrite.setBorder(border);
		overwrite.addMouseListener(mouseHandler);
		box.add(overwrite);
		box.add(Box.createHorizontalStrut(3));
		fold = new JLabel(""fold"");
		fold.setBorder(border);
		box.add(fold);
		updateBufferStatus();
		updateMiscStatus();
		updateFoldStatus();
		box.add(Box.createHorizontalStrut(3));
		ioProgress = new MiniIOProgress();
		ioProgress.setBorder(border);
		ioProgress.addMouseListener(mouseHandler);
		box.add(ioProgress);
		// UI hack because BoxLayout does not give all components the
		// same height
		Dimension dim = multiSelect.getPreferredSize();
		dim.width = 40;
		// dim.height = <same as all other components>
		ioProgress.setPreferredSize(dim);
		add(BorderLayout.EAST,box);
	}
	/**
	 * Show a message for a short period of time.
	 * @param message The message
	 * @since jEdit 3.2pre5
	 */
	public void setMessageAndClear(String message)
	{
		setMessage(message);
		tempTimer = new Timer(0,new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				setMessage(null);
			}
		});
		tempTimer.setInitialDelay(10000);
		tempTimer.setRepeats(false);
		tempTimer.start();
	}
	public void setMessage(String message)
	{
		if(tempTimer != null)
		{
			tempTimer.stop();
			tempTimer = null;
		}
		if(message == null)
		{
			InputHandler inputHandler = view.getInputHandler();
			if(inputHandler.isRepeatEnabled())
			{
				int repeatCount = inputHandler.getRepeatCount();
				this.message.setText(jEdit.getProperty(""view.status.repeat"",
					new Object[] { repeatCount == 1 ? """" : String.valueOf(repeatCount) }));
			}
			else if(view.getMacroRecorder() != null)
				this.message.setText(jEdit.getProperty(""view.status.recording""));
			else
				this.message.setText(null);
		}
		else
			this.message.setText(message);
	}
	public void repaintCaretStatus()
	{
		caretStatus.repaint();
	}
	public void updateBufferStatus()
	{
		Buffer buffer = view.getBuffer();
		mode.setText(buffer.getMode().getName());
		encoding.setText(buffer.getProperty(""encoding"").toString());
	}
	public void updateMiscStatus()
	{
		JEditTextArea textArea = view.getTextArea();
		if(textArea.isMultipleSelectionEnabled())
			multiSelect.setForeground(Color.black);
		else
		{
			if(textArea.getSelectionCount() > 1)
			{
				multiSelect.setForeground(UIManager.getColor(
					""Label.foreground""));
			}
			else
				multiSelect.setForeground(gray);
		}
		if(textArea.isOverwriteEnabled())
			overwrite.setForeground(Color.black);
		else
			overwrite.setForeground(gray);
	}
	public void updateFoldStatus()
	{
		Buffer buffer = view.getBuffer();
		if(buffer.getLineCount() != buffer.getVirtualLineCount())
			fold.setForeground(Color.black);
		else
			fold.setForeground(gray);
	}
	// private members
	private View view;
	private VICaretStatus caretStatus;
	private JLabel message;
	private JLabel mode;
	private JLabel encoding;
	private JLabel multiSelect;
	private JLabel overwrite;
	private JLabel fold;
	private MiniIOProgress ioProgress;
	private Color gray = new Color(142,142,142);
	/* package-private for speed */ StringBuffer buf = new StringBuffer();
	private Timer tempTimer;
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			Object source = evt.getSource();
			if(source == mode || source == encoding)
				new BufferOptions(view,view.getBuffer());
			else if(source == multiSelect)
				view.getTextArea().toggleMultipleSelectionEnabled();
			else if(source == overwrite)
				view.getTextArea().toggleOverwriteEnabled();
			else if(source == ioProgress)
				new IOProgressMonitor(view);
		}
	}
	class VICaretStatus extends JComponent
	{
		public VICaretStatus()
		{
			VICaretStatus.this.setForeground(UIManager.getColor(""Button.foreground""));
			VICaretStatus.this.setBackground(UIManager.getColor(""Label.background""));
			VICaretStatus.this.setFont(UIManager.getFont(""Label.font""));
			Dimension size = new Dimension(
				VICaretStatus.this.getFontMetrics(
				VICaretStatus.this.getFont())
				.stringWidth(testStr),0);
			VICaretStatus.this.setPreferredSize(size);
		}
		public void paintComponent(Graphics g)
		{
			Buffer buffer = view.getBuffer();
			if(!buffer.isLoaded())
				return;
			FontMetrics fm = g.getFontMetrics();
			JEditTextArea textArea = view.getTextArea();
			int currLine = textArea.getCaretLine();
			int dot = textArea.getCaretPosition()
				- textArea.getLineStartOffset(currLine);
			int virtualPosition = getVirtualPosition(dot,buffer,textArea);
			buf.setLength(0);
			buf.append(Integer.toString(currLine + 1));
			buf.append(',');
			buf.append(Integer.toString(dot + 1));
			if (virtualPosition != dot)
			{
				buf.append('-');
				buf.append(Integer.toString(virtualPosition + 1));
			}
			buf.append(' ');
			int firstLine = textArea.getFirstLine();
			int visible = textArea.getVisibleLines();
			int lineCount = textArea.getVirtualLineCount();
			if (visible >= lineCount)
			{
				buf.append(""All"");
			}
			else if (firstLine == 0)
			{
				buf.append(""Top"");
			}
			else if (firstLine + visible >= lineCount)
			{
				buf.append(""Bot"");
			}
			else
			{
				float percent = (float)firstLine / (float)lineCount
					* 100.0f;
				buf.append(Integer.toString((int)percent));
				buf.append('%');
			}
			g.drawString(buf.toString(),
				VICaretStatus.this.getBorder().getBorderInsets(this).left + 1,
				(VICaretStatus.this.getHeight() + fm.getAscent()) / 2 - 1);
		}
		// private members
		private static final String testStr = ""9999,999-999 99%"";
		private Segment seg = new Segment();
		private int getVirtualPosition(int dot, Buffer buffer, JEditTextArea textArea)
		{
			int line = textArea.getCaretLine();
			textArea.getLineText(line, seg);
			int virtualPosition = 0;
			int tabSize = buffer.getTabSize();
			for (int i = 0; i < seg.count && i < dot; ++i)
			{
				char ch = seg.array[seg.offset + i];
				if (ch == '\t')
				{
					virtualPosition += tabSize
						- (virtualPosition % tabSize);
				}
				else
				{
					++virtualPosition;
				}
			}
			return virtualPosition;
		}
	}
	class MiniIOProgress extends JComponent
		implements WorkThreadProgressListener
	{
		public MiniIOProgress()
		{
			MiniIOProgress.this.setDoubleBuffered(true);
			MiniIOProgress.this.setForeground(UIManager.getColor(""Button.foreground""));
			MiniIOProgress.this.setBackground(UIManager.getColor(""Button.background""));
			icon = GUIUtilities.loadIcon(""io.gif"");
		}
		public void addNotify()
		{
			super.addNotify();
			VFSManager.getIOThreadPool().addProgressListener(this);
		}
		public void removeNotify()
		{
			super.removeNotify();
			VFSManager.getIOThreadPool().removeProgressListener(this);
		}
		public void progressUpdate(WorkThreadPool threadPool, int threadIndex)
		{
			MiniIOProgress.this.repaint();
		}
		public void paintComponent(Graphics g)
		{
			WorkThreadPool ioThreadPool = VFSManager.getIOThreadPool();
			if(ioThreadPool.getThreadCount() == 0)
				return;
			FontMetrics fm = g.getFontMetrics();
			if(ioThreadPool.getRequestCount() == 0)
				return;
			else
			{
				icon.paintIcon(this,g,MiniIOProgress.this.getWidth()
					- icon.getIconWidth() - 3,
					(MiniIOProgress.this.getHeight()
					- icon.getIconHeight()) / 2);
			}
			Insets insets = MiniIOProgress.this.getBorder().getBorderInsets(this);
			int progressHeight = (MiniIOProgress.this.getHeight() - insets.top - insets.bottom)
				/ ioThreadPool.getThreadCount();
			int progressWidth = MiniIOProgress.this.getWidth()
				- icon.getIconWidth() - insets.left - insets.right - 2;
			for(int i = 0; i < ioThreadPool.getThreadCount(); i++)
			{
				WorkThread thread = ioThreadPool.getThread(i);
				int max = thread.getProgressMaximum();
				if(!thread.isRequestRunning() || max == 0)
					continue;
				int value = thread.getProgressValue();
				double progressRatio = ((double)value / max);
				// when loading gzip files, for example,
				// progressValue (data read) can be larger
				// than progressMaximum (file size)
				progressRatio = Math.min(progressRatio,1.0);
				g.fillRect(insets.left,insets.top + i * progressHeight,
					(int)(progressRatio * progressWidth),progressHeight);
			}
		}
		public Dimension getPreferredSize()
		{
			return new Dimension(40,icon.getIconHeight());
		}
		// private members
		private Icon icon;
	}
}
"
org.gjt.sp.jedit.gui.TipOfTheDay,"/*
 * TipOfTheDay.java - Tip of the day window
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.IOException;
import java.net.URL;
import java.util.Random;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
public class TipOfTheDay extends EnhancedDialog
{
	public TipOfTheDay(View view)
	{
		super(view,jEdit.getProperty(""tip.title""),false);
		setContentPane(new TipPanel());
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(view);
		show();
	}
	public void ok()
	{
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	class TipPanel extends JPanel
	{
		TipPanel()
		{
			super(new BorderLayout(12,12));
			setBorder(new EmptyBorder(12,12,12,12));
			JLabel label = new JLabel(jEdit.getProperty(""tip.caption""));
			label.setFont(new Font(""SansSerif"",Font.PLAIN,24));
			label.setForeground(UIManager.getColor(""Button.foreground""));
			TipPanel.this.add(BorderLayout.NORTH,label);
			tipText = new JEditorPane();
			tipText.setEditable(false);
			tipText.setContentType(""text/html"");
			nextTip();
			JScrollPane scroller = new JScrollPane(tipText);
			scroller.setPreferredSize(new Dimension(150,150));
			TipPanel.this.add(BorderLayout.CENTER,scroller);
			ActionHandler actionHandler = new ActionHandler();
			Box buttons = new Box(BoxLayout.X_AXIS);
			showNextTime = new JCheckBox(jEdit.getProperty(""tip.show-next-time""),
				jEdit.getBooleanProperty(""tip.show""));
			showNextTime.addActionListener(actionHandler);
			buttons.add(showNextTime);
			buttons.add(Box.createHorizontalStrut(6));
			buttons.add(Box.createGlue());
			nextTip = new JButton(jEdit.getProperty(""tip.next-tip""));
			nextTip.addActionListener(actionHandler);
			buttons.add(nextTip);
			buttons.add(Box.createHorizontalStrut(6));
			close = new JButton(jEdit.getProperty(""common.close""));
			close.addActionListener(actionHandler);
			buttons.add(close);
			TipOfTheDay.this.getRootPane().setDefaultButton(close);
			Dimension dim = nextTip.getPreferredSize();
			dim.width = Math.max(dim.width,close.getPreferredSize().width);
			nextTip.setPreferredSize(dim);
			close.setPreferredSize(dim);
			TipPanel.this.add(BorderLayout.SOUTH,buttons);
		}
		// private members
		private JCheckBox showNextTime;
		private JButton nextTip, close;
		private JEditorPane tipText;
		private int currentTip = -1;
		private void nextTip()
		{
			int count = Integer.parseInt(jEdit.getProperty(""tip.count""));
			// so that we don't see the same tip again if the user
			// clicks 'Next Tip'
			int tipToShow = currentTip;
			while(tipToShow == currentTip)
				tipToShow = Math.abs(new Random().nextInt()) % count;
			try
			{
				tipText.setPage(TipOfTheDay.class.getResource(
					""/org/gjt/sp/jedit/tips/tip""
					+ tipToShow + "".html""));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}
		}
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				Object source = evt.getSource();
				if(source == showNextTime)
				{
					jEdit.setBooleanProperty(""tip.show"",showNextTime
						.isSelected());
				}
				else if(source == nextTip)
					nextTip();
				else if(source == close)
					dispose();
			}
		}
	}
}
"
org.gjt.sp.jedit.gui.VariableGridLayout,"/*
 * VariableGridLayout.java - a grid layout manager with variable cell sizes
 * (c) 2001 - Dirk Moebius (dmoebius@gmx.net)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import java.awt.*;
/**
 * The <code>VariableGridLayout</code> class is a layout manager
 * that lays out a container's components in a rectangular grid
 * with variable cell sizes.<p>
 *
 * The container is divided into rectangles, and one component is placed
 * in each rectangle. Each row is as large as the largest component in
 * that row, and each column is as wide as the widest component in
 * that column.<p>
 *
 * This behavior is basically the same as in
 * <code>java.awt.GridLayout</code>, but with different row heights and
 * column widths for each row/column.<p>
 *
 * For example, the following is an applet that lays out six buttons
 * into three rows and two columns:<p>
 *
 * <blockquote><pre>
 * import java.awt.*;
 * import java.applet.Applet;
 * public class ButtonGrid extends Applet {
 *     public void init() {
 *         setLayout(new VariableGridLayout(VariableGridLayout.FIXED_NUM_COLUMNS, 2));
 *         add(new Button(""1""));
 *         add(new Button(""2""));
 *         add(new Button(""3""));
 *         add(new Button(""4""));
 *         add(new Button(""5""));
 *         add(new Button(""6""));
 *     }
 * }
 * </pre></blockquote><p>
 *
 * <b>Programmer's remark:</b> VariableGridLayout could be faster, if it would
 * reside in the package java.awt, because then it could access some
 * package private fields of <code>Container</code> or
 * <code>Component</code>. Instead, it has to call
 * <code>Component.getSize()</code>,
 * which allocates memory on the heap.<p>
 *
 * <b>Todo:</b>
 * <ul>
 * <li>Use alignmentX/Y property if the grid cell is larger than the preferred size of the component.
 * <li>Ability to span components over more than one cell horizontally
 * </ul>
 *
 * @author Dirk Moebius
 * @version 1.0
 * @see java.awt.GridLayout
 */
public class VariableGridLayout implements LayoutManager2, java.io.Serializable
{
	public static final int FIXED_NUM_ROWS = 1;
	public static final int FIXED_NUM_COLUMNS = 2;
	public VariableGridLayout(int mode, int size, int hgap, int vgap) {
		if (mode != FIXED_NUM_ROWS && mode != FIXED_NUM_COLUMNS) {
			throw new IllegalArgumentException(""illegal mode; value is "" + mode);
		}
		if (size <= 0) {
			throw new IllegalArgumentException(""size cannot be zero or less; value is "" + size);
		}
		if (hgap < 0) {
			throw new IllegalArgumentException(""hgap cannot be negative; value is "" + hgap);
		}
		if (vgap < 0) {
			throw new IllegalArgumentException(""vgap cannot be negative; value is "" + vgap);
		}
		this.mode = mode;
		this.size = size;
		this.hgap = hgap;
		this.vgap = vgap;
	}
	/**
	 * Creates a variable grid layout manager with the specified mode
	 * and zero horizontal and vertical gap.
	 */
	public VariableGridLayout(int mode, int size) {
		this(mode, size, 0, 0);
	}
	/**
	 * Creates a variable grid layout manager with mode FIXED_NUM_ROWS,
	 * number of rows == 1 and zero horizontal and vertical gap.
	 */
	public VariableGridLayout() {
		this(FIXED_NUM_ROWS, 1, 0, 0);
	}
	/**
	 * Not used in this class.
	 */
	public void addLayoutComponent(String name, Component component) { }
	/**
	 * Not used in this class.
	 */
	public void addLayoutComponent(Component component, Object constraints) { }
	/**
	 * Not used in this class.
	 */
	public void removeLayoutComponent(Component component) { }
	/**
	 * Always returns 0.5.
	 */
	public float getLayoutAlignmentX(Container container) {
		return 0.5f;
	}
	/**
	 * Always returns 0.5.
	 */
	public float getLayoutAlignmentY(Container container) {
		return 0.5f;
	}
	public Dimension preferredLayoutSize(Container parent) {
		return getLayoutSize(parent, 2);
	}
	public Dimension minimumLayoutSize(Container parent) {
		return getLayoutSize(parent, 0);
	}
	public Dimension maximumLayoutSize(Container parent) {
		return getLayoutSize(parent, 1);
	}
	public void layoutContainer(Container parent) {
		synchronized (parent.getTreeLock()) {
			int ncomponents = parent.getComponentCount();
			if (ncomponents == 0) {
				return;
			}
			// Pass 1: compute preferred row heights / column widths
			int total_height = 0;
			for (int r = 0, i = 0; r < nrows; r++) {
				for (int c = 0; c < ncols; c++, i++) {
					if (i < ncomponents) {
						Dimension d = parent.getComponent(i).getPreferredSize();
						row_heights[r] = Math.max(row_heights[r], d.height);
						col_widths[c] = Math.max(col_widths[c], d.width);
					} else {
						break;
					}
				}
				total_height += row_heights[r];
			}
			int total_width = 0;
			for (int c = 0; c < ncols; c++) {
				total_width += col_widths[c];
			}
			// Pass 2: redistribute free space
			Dimension parent_size = parent.getSize();
			Insets insets = parent.getInsets();
			int free_height = parent_size.height - insets.top - insets.bottom - (nrows - 1) * vgap;
			int free_width = parent_size.width - insets.left - insets.right - (ncols - 1) * hgap;
			if (total_height != free_height) {
				double dy = (double)free_height / (double)total_height;
				for (int r = 0; r < nrows; r++) {
					row_heights[r] = (int) ((double)row_heights[r] * dy);
				}
			}
			if (total_width != free_width) {
				double dx = ((double)free_width) / ((double)total_width);
				for (int c = 0; c < ncols; c++) {
					col_widths[c] = (int) ((double)col_widths[c] * dx);
				}
			}
			// Pass 3: layout components
			for (int r = 0, y = insets.top, i = 0; r < nrows; y += row_heights[r] + vgap, r++) {
				for (int c = 0, x = insets.left; c < ncols; x += col_widths[c] + hgap, c++, i++) {
					if (i < ncomponents) {
						parent.getComponent(i).setBounds(x, y, col_widths[c], row_heights[r]);
					}
				}
			}
		} // synchronized
	}
	public void invalidateLayout(Container container) {
		int ncomponents = container.getComponentCount();
		int old_nrows = nrows;
		int old_ncols = ncols;
		if (this.mode == FIXED_NUM_ROWS) {
			nrows = this.size;
			ncols = (ncomponents + nrows - 1) / nrows;
		} else {
			ncols = this.size;
			nrows = (ncomponents + ncols - 1) / ncols;
		}
		if (old_nrows != nrows) {
			row_heights = new int[nrows];
		}
		if (old_ncols != ncols) {
			col_widths = new int[ncols];
		}
	}
	public int getRows() {
		return nrows;
	}
	public int getColumns() {
		return ncols;
	}
	/**
	 * Returns the string representation of this variable grid layout's values.
	 * @return  a string representation of this variable grid layout.
	 */
	public String toString() {
		return getClass().getName() + ""[mode="" + mode + "",size="" + size
			   + "",hgap="" + hgap + "",vgap="" + vgap + ""]"";
	}
	/**
	 * @param  which  if 0 compute minimum layout size,
	 *				if 1 compute maximum layout size,
	 *				otherwise compute preferred layout size.
	 */
	private Dimension getLayoutSize(Container parent, int which) {
		synchronized (parent.getTreeLock()){
			int ncomponents = parent.getComponentCount();
			int h = 0;
			int w = 0;
			for (int r = 0, i = 0; r < nrows; r++) {
				int row_height = 0;
				for (int c = 0; c < ncols; c++, i++) {
					if (i < ncomponents) {
						switch (which) {
							case 0:
								row_height = Math.max(row_height, parent.getComponent(i).getMinimumSize().height);
								break;
							case 1:
								row_height = Math.max(row_height, parent.getComponent(i).getMaximumSize().height);
								break;
							default:
								row_height = Math.max(row_height, parent.getComponent(i).getPreferredSize().height);
								break;
						}
					} else {
						break;
					}
				}
				h += row_height;
			}
			for (int c = 0; c < ncols; c++) {
				int col_width = 0;
				for (int r = 0; r < nrows; r++) {
					int i = r * ncols + c;
					if (i < ncomponents) {
						switch (which) {
							case 0:
								col_width = Math.max(col_width, parent.getComponent(i).getMinimumSize().width);
								break;
							case 1:
								col_width = Math.max(col_width, parent.getComponent(i).getMaximumSize().width);
								break;
							default:
								col_width = Math.max(col_width, parent.getComponent(i).getPreferredSize().width);
								break;
						}
					} else {
						break;
					}
				}
				w += col_width;
			}
			Insets insets = parent.getInsets();
			return new Dimension(w + insets.left + insets.right + ((ncols - 1) * hgap),
								 h + insets.top + insets.bottom + ((nrows - 1) * vgap));
		}
	}
	private int mode;
	private int size;
	private int hgap;
	private int vgap;
	private transient int nrows = -1;
	private transient int ncols = -1;
	private transient int[] row_heights = null;
	private transient int[] col_widths = null;
}
"
org.gjt.sp.jedit.gui.ViewRegisters,"/*
 * ViewRegisters.java - View registers dialog
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.gui;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
public class ViewRegisters extends EnhancedDialog
{
	public ViewRegisters(View view)
	{
		super(view,jEdit.getProperty(""view-registers.title""),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JPanel panel = new JPanel(new BorderLayout());
		panel.setBorder(new EmptyBorder(0,12,0,0));
		JLabel label = new JLabel(jEdit.getProperty(""view-registers.register""));
		label.setBorder(new EmptyBorder(0,0,3,0));
		panel.add(BorderLayout.NORTH,label);
		DefaultListModel registerModel = new DefaultListModel();
		registerList = new JList(registerModel);
		registerList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		registerList.setCellRenderer(new Renderer());
		Registers.Register[] registers = Registers.getRegisters();
		int index = 0;
		for(int i = 0; i < registers.length; i++)
		{
			Registers.Register reg = registers[i];
			if(reg == null)
				continue;
			String value = reg.toString();
			if(value == null || value.length() == 0)
				continue;
			registerModel.addElement(new Character((char)i));
		}
		if(registerModel.getSize() == 0)
			registerModel.addElement(jEdit.getProperty(""view-registers.none""));
		panel.add(BorderLayout.CENTER,new JScrollPane(registerList));
		content.add(BorderLayout.WEST,panel);
		panel = new JPanel(new BorderLayout());
		panel.setBorder(new EmptyBorder(0,12,0,0));
		label = new JLabel(jEdit.getProperty(""view-registers.contents""));
		label.setBorder(new EmptyBorder(0,0,3,0));
		panel.add(BorderLayout.NORTH,label);
		contentTextArea = new JTextArea(10,80);
		contentTextArea.setEditable(false);
		panel.add(BorderLayout.CENTER,new JScrollPane(contentTextArea));
		content.add(BorderLayout.CENTER,panel);
		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(new ActionHandler());
		panel.add(Box.createGlue());
		panel.add(close);
		panel.add(Box.createGlue());
		getRootPane().setDefaultButton(close);
		content.add(BorderLayout.SOUTH,panel);
		registerList.addListSelectionListener(new ListHandler());
		registerList.setSelectedIndex(index);
		pack();
		setLocationRelativeTo(view);
		show();
	}
	// EnhancedDialog implementation
	public void ok()
	{
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	// end EnhancedDialog implementation
	// private members
	private JList registerList;
	private JTextArea contentTextArea;
	private JButton close;
	class Renderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,
				index,isSelected,cellHasFocus);
			if(value instanceof Character)
			{
				char name = ((Character)value).charValue();
				String label;
				if(name == '\n')
					label = ""\n"";
				else if(name == '\t')
					label = ""\t"";
				else if(name == '$')
					label = jEdit.getProperty(""view-registers.clipboard"");
				else if(name == '%')
					label = jEdit.getProperty(""view-registers.selection"");
				else
					label = String.valueOf((char)name);
				setText(label);
			}
			return this;
		}
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == close)
				cancel();
		}
	}
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			Object value = registerList.getSelectedValue();
			if(!(value instanceof Character))
				return;
			char name = ((Character)value).charValue();
			Registers.Register reg = Registers.getRegister(name);
			if(reg == null)
				return;
			contentTextArea.setText(reg.toString());
			contentTextArea.setCaretPosition(0);
		}
	}
}
"
org.gjt.sp.jedit.io.BufferIORequest,"/*
 * BufferIORequest.java - I/O request
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
import javax.swing.text.BadLocationException;
import javax.swing.text.Element;
import javax.swing.text.Segment;
import java.io.*;
import java.util.zip.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;
/**
 * A buffer I/O request.
 * @author Slava Pestov
 * @version $Id: BufferIORequest.java,v 1.17 2001/06/26 08:50:00 sp Exp $
 */
public class BufferIORequest extends WorkRequest
{
	/**
	 * Size of I/O buffers.
	 */
	public static final int IOBUFSIZE = 32768;
	/**
	 * Number of lines per progress increment.
	 */
	public static final int PROGRESS_INTERVAL = 300;
	/**
	 * Property loaded data is stored in.
	 */
	public static final String LOAD_DATA = ""IORequest__loadData"";
	/**
	 * A file load request.
	 */
	public static final int LOAD = 0;
	/**
	 * A file save request.
	 */
	public static final int SAVE = 1;
	/**
	 * An autosave request. Only supported for local files.
	 */
	public static final int AUTOSAVE = 2;
	/**
	 * An insert file request.
	 */
	public static final int INSERT = 3;
	/**
	 * Creates a new buffer I/O request.
	 * @param type The request type
	 * @param view The view
	 * @param buffer The buffer
	 * @param session The VFS session
	 * @param vfs The VFS
	 * @param path The path
	 */
	public BufferIORequest(int type, View view, Buffer buffer,
		Object session, VFS vfs, String path)
	{
		this.type = type;
		this.view = view;
		this.buffer = buffer;
		this.session = session;
		this.vfs = vfs;
		this.path = path;
		markersPath = vfs.getParentOfPath(path)
			+ '.' + vfs.getFileName(path)
			+ "".marks"";
	}
	public void run()
	{
		switch(type)
		{
		case LOAD:
			load();
			break;
		case SAVE:
			save();
			break;
		case AUTOSAVE:
			autosave();
			break;
		case INSERT:
			insert();
			break;
		}
	}
	public String toString()
	{
		String typeString;
		switch(type)
		{
		case LOAD:
			typeString = ""LOAD"";
			break;
		case SAVE:
			typeString = ""SAVE"";
			break;
		case AUTOSAVE:
			typeString = ""AUTOSAVE"";
			break;
		default:
			typeString = ""UNKNOWN!!!"";
		}
		return getClass().getName() + ""[type="" + typeString
			+ "",buffer="" + buffer + ""]"";
	}
	// private members
	private int type;
	private View view;
	private Buffer buffer;
	private Object session;
	private VFS vfs;
	private String path;
	private String markersPath;
	private void load()
	{
		InputStream in = null;
		try
		{
			try
			{
				String[] args = { vfs.getFileName(path) };
				setStatus(jEdit.getProperty(""vfs.status.load"",args));
				setAbortable(true);
				setProgressValue(0);
				VFS.DirectoryEntry entry = vfs._getDirectoryEntry(
					session,path,view);
				long length;
				if(entry != null)
					length = entry.length;
				else
					length = 0L;
				in = vfs._createInputStream(session,path,false,view);
				if(in == null)
					return;
				if(path.endsWith("".gz""))
					in = new GZIPInputStream(in);
				String lineSeparator = read(buffer,in,length);
				buffer.putProperty(Buffer.LINESEP,lineSeparator);
				buffer.setNewFile(false);
			}
			catch(CharConversionException ch)
			{
				Log.log(Log.ERROR,this,ch);
				Object[] pp = { path,
					buffer.getProperty(Buffer.ENCODING),
					ch.toString() };
				VFSManager.error(view,""encoding-error"",pp);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				Object[] pp = { path, io.toString() };
				VFSManager.error(view,""read-error"",pp);
			}
			if(jEdit.getBooleanProperty(""persistentMarkers""))
			{
				try
				{
					String[] args = { vfs.getFileName(path) };
					setStatus(jEdit.getProperty(""vfs.status.load-markers"",args));
					setAbortable(true);
					in = vfs._createInputStream(session,markersPath,true,view);
					if(in != null)
						readMarkers(buffer,in);
				}
				catch(IOException io)
				{
					// ignore
				}
			}
		}
		catch(WorkThread.Abort a)
		{
			if(in != null)
			{
				try
				{
					in.close();
				}
				catch(IOException io)
				{
				}
			}
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { path, io.toString() };
				VFSManager.error(view,""read-error"",pp);
			}
			catch(WorkThread.Abort a)
			{
			}
		}
	}
	/**
	 * Reads the buffer from the specified input stream. Read and
	 * understand all these notes if you want to snarf this code for
	 * your own app; it has a number of subtle behaviours which are
	 * not entirely obvious.<p>
	 *
	 * Some notes that will help future hackers:
	 * <ul>
	 * <li>
	 * We use a StringBuffer because there is no way to pre-allocate
	 * in the GapContent - and adding text each time to the GapContent
	 * would be slow because it would require array enlarging, etc.
	 * Better to do as few gap inserts as possible.
	 *
	 * <li>The StringBuffer is pre-allocated to the file's size (obtained
	 * from the VFS). If the file size is not known, we default to
	 * IOBUFSIZE.
	 *
	 * <li>We read the stream in IOBUFSIZE (= 32k) blocks, and loop over
	 * the read characters looking for line breaks.
	 * <ul>
	 * <li>a \r or \n causes a line to be added to the model, and appended
	 * to the string buffer
	 * <li>a \n immediately following an \r is ignored; so that Windows
	 * line endings are handled
	 * </ul>
	 *
	 * <li>This method remembers the line separator used in the file, and
	 * stores it in the lineSeparator buffer-local property. However,
	 * if the file contains, say, hello\rworld\n, lineSeparator will
	 * be set to \n, and the file will be saved as hello\nworld\n.
	 * Hence jEdit is not really appropriate for editing binary files.
	 *
	 * <li>To make reloading a bit easier, this method automatically
	 * removes all data from the model before inserting it. This
	 * shouldn't cause any problems, as most documents will be
	 * empty before being loaded into anyway.
	 *
	 * <li>If the last character read from the file is a line separator,
	 * it is not added to the model! There are two reasons:
	 * <ul>
	 * <li>On Unix, all text files have a line separator at the end,
	 * there is no point wasting an empty screen line on that
	 * <li>Because save() appends a line separator after *every* line,
	 * it prevents the blank line count at the end from growing
	 * </ul>
	 * 
	 * </ul>
	 */
	private String read(Buffer buffer, InputStream _in, long length)
		throws IOException
	{
		// only true if the file size is known
		boolean trackProgress = (length != 0);
		File file = buffer.getFile();
		setProgressValue(0);
		setProgressMaximum((int)length);
		// if the file size is not known, start with a resonable
		// default buffer size
		if(length == 0)
			length = IOBUFSIZE;
		StringBuffer sbuf = new StringBuffer((int)length);
		InputStreamReader in = new InputStreamReader(_in,
			(String)buffer.getProperty(Buffer.ENCODING));
		char[] buf = new char[IOBUFSIZE];
		// Number of characters in 'buf' array.
		// InputStream.read() doesn't always fill the
		// array (eg, the file size is not a multiple of
		// IOBUFSIZE, or it is a GZipped file, etc)
		int len;
		// True if a \n was read after a \r. Usually
		// means this is a DOS/Windows file
		boolean CRLF = false;
		// A \r was read, hence a MacOS file
		boolean CROnly = false;
		// Was the previous read character a \r?
		// If we read a \n and this is true, we assume
		// we have a DOS/Windows file
		boolean lastWasCR = false;
		// Number of lines read. Every 100 lines, we update the
		// progress bar
		int lineCount = 0;
		while((len = in.read(buf,0,buf.length)) != -1)
		{
			// Offset of previous line, relative to
			// the start of the I/O buffer (NOT
			// relative to the start of the document)
			int lastLine = 0;
			for(int i = 0; i < len; i++)
			{
				// Look for line endings.
				switch(buf[i])
				{
				case '\r':
					// If we read a \r and
					// lastWasCR is also true,
					// it is probably a Mac file
					// (\r\r in stream)
					if(lastWasCR)
					{
						CROnly = true;
						CRLF = false;
					}
					// Otherwise set a flag,
					// so that \n knows that last
					// was a \r
					else
					{
						lastWasCR = true;
					}
					// Insert a line
					sbuf.append(buf,lastLine,i -
						lastLine);
					sbuf.append('\n');
					if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)
						setProgressValue(sbuf.length());
					// This is i+1 to take the
					// trailing \n into account
					lastLine = i + 1;
					break;
				case '\n':
					// If lastWasCR is true,
					// we just read a \r followed
					// by a \n. We specify that
					// this is a Windows file,
					// but take no further
					// action and just ignore
					// the \r.
					if(lastWasCR)
					{
						CROnly = false;
						CRLF = true;
						lastWasCR = false;
						// Bump lastLine so
						// that the next line
						// doesn't erronously
						// pick up the \r
						lastLine = i + 1;
					}
					// Otherwise, we found a \n
					// that follows some other
					// character, hence we have
					// a Unix file
					else
					{
						CROnly = false;
						CRLF = false;
						sbuf.append(buf,lastLine,
							i - lastLine);
						sbuf.append('\n');
						if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)
							setProgressValue(sbuf.length());
						lastLine = i + 1;
					}
					break;
				default:
					// If we find some other
					// character that follows
					// a \r, so it is not a
					// Windows file, and probably
					// a Mac file
					if(lastWasCR)
					{
						CROnly = true;
						CRLF = false;
						lastWasCR = false;
					}
					break;
				}
			}
			if(trackProgress)
				setProgressValue(sbuf.length());
			// Add remaining stuff from buffer
			sbuf.append(buf,lastLine,len - lastLine);
		}
		setAbortable(false);
		String returnValue;
		if(CRLF)
			returnValue = ""\r\n"";
		else if(CROnly)
			returnValue = ""\r"";
		else
			returnValue = ""\n"";
		in.close();
		// Chop trailing newline and/or ^Z (if any)
		int bufferLength = sbuf.length();
		if(bufferLength != 0)
		{
			char ch = sbuf.charAt(bufferLength - 1);
			if(length >= 2 && ch == 0x1a /* DOS ^Z */
				&& sbuf.charAt(bufferLength - 2) == '\n')
				sbuf.setLength(bufferLength - 2);
			else if(ch == '\n')
				sbuf.setLength(bufferLength - 1);
		}
		// to avoid having to deal with read/write locks and such,
		// we insert the loaded data into the buffer in the
		// post-load cleanup runnable, which runs in the AWT thread.
		buffer.putProperty(LOAD_DATA,sbuf);
		return returnValue;
	}
	private void readMarkers(Buffer buffer, InputStream _in)
		throws IOException
	{
		// For `reload' command
		buffer.removeAllMarkers();
		BufferedReader in = new BufferedReader(new InputStreamReader(_in));
		String line;
		while((line = in.readLine()) != null)
		{
			// compatibility kludge for jEdit 3.1 and earlier
			if(!line.startsWith(""!""))
				continue;
			char shortcut = line.charAt(1);
			int start = line.indexOf(';');
			int end = line.indexOf(';',start + 1);
			int position = Integer.parseInt(line.substring(start + 1,end));
			buffer.addMarker(shortcut,position);
		}
		in.close();
	}
	private void save()
	{
		OutputStream out = null;
		try
		{
			String[] args = { vfs.getFileName(path) };
			setStatus(jEdit.getProperty(""vfs.status.save"",args));
			// the entire save operation can be aborted...
			setAbortable(true);
			try
			{
				buffer.readLock();
				/* if the VFS supports renaming files, we first
				 * save to #<filename>#save#, then rename that
				 * to <filename>, so that if the save fails,
				 * data will not be lost */
				String savePath;
				if((vfs.getCapabilities() & VFS.RENAME_CAP) != 0)
				{
					savePath = vfs.getParentOfPath(path)
						+ '#' + vfs.getFileName(path)
						+ ""#save#"";
				}
				else
					savePath = path;
				out = vfs._createOutputStream(session,savePath,view);
				if(out != null)
				{
					if(path.endsWith("".gz""))
						out = new GZIPOutputStream(out);
					write(buffer,out);
				}
				// Only backup once per session
				if(buffer.getProperty(Buffer.BACKED_UP) == null)
				{
					vfs._backup(session,path,view);
					buffer.putProperty(Buffer.BACKED_UP,Boolean.TRUE);
				}
				if((vfs.getCapabilities() & VFS.RENAME_CAP) != 0)
					vfs._rename(session,savePath,path,view);
				// We only save markers to VFS's that support deletion.
				// Otherwise, we will accumilate stale marks files.
				if((vfs.getCapabilities() & VFS.DELETE_CAP) != 0)
				{
					if(jEdit.getBooleanProperty(""persistentMarkers"")
						&& buffer.getMarkers().size() != 0)
					{
						setStatus(jEdit.getProperty(""vfs.status.save-markers"",args));
						setProgressValue(0);
						out = vfs._createOutputStream(session,markersPath,view);
						if(out != null)
							writeMarkers(buffer,out);
					}
					else
						vfs._delete(session,markersPath,view);
				}
			}
			catch(BadLocationException bl)
			{
				Log.log(Log.ERROR,this,bl);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { path, io.toString() };
				VFSManager.error(view,""write-error"",pp);
			}
			finally
			{
				buffer.readUnlock();
			}
		}
		catch(WorkThread.Abort a)
		{
			if(out != null)
			{
				try
				{
					out.close();
				}
				catch(IOException io)
				{
				}
			}
		}
		finally
		{
			try
			{
				vfs._saveComplete(session,buffer,view);
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { path, io.toString() };
				VFSManager.error(view,""write-error"",pp);
			}
			catch(WorkThread.Abort a)
			{
			}
		}
	}
	private void autosave()
	{
		OutputStream out = null;
		try
		{
			String[] args = { vfs.getFileName(path) };
			setStatus(jEdit.getProperty(""vfs.status.autosave"",args));
			// the entire save operation can be aborted...
			setAbortable(true);
			try
			{
				buffer.readLock();
				if(!buffer.isDirty())
				{
					// buffer has been saved while we
					// were waiting.
					return;
				}
				out = vfs._createOutputStream(session,path,view);
				if(out == null)
					return;
				write(buffer,out);
			}
			catch(BadLocationException bl)
			{
				Log.log(Log.ERROR,this,bl);
			}
			catch(IOException io)
			{
				/* Log.log(Log.ERROR,this,io);
				args[0] = io.toString();
				VFSManager.error(view,""ioerror"",args); */
			}
			finally
			{
				buffer.readUnlock();
			}
		}
		catch(WorkThread.Abort a)
		{
			if(out != null)
			{
				try
				{
					out.close();
				}
				catch(IOException io)
				{
				}
			}
		}
	}
	private void write(Buffer buffer, OutputStream _out)
		throws IOException, BadLocationException
	{
		BufferedWriter out = new BufferedWriter(
			new OutputStreamWriter(_out,
				(String)buffer.getProperty(Buffer.ENCODING)),
				IOBUFSIZE);
		Segment lineSegment = new Segment();
		String newline = (String)buffer.getProperty(Buffer.LINESEP);
		if(newline == null)
			newline = System.getProperty(""line.separator"");
		Element map = buffer.getDefaultRootElement();
		setProgressMaximum(map.getElementCount() / PROGRESS_INTERVAL);
		setProgressValue(0);
		int i = 0;
		while(i < map.getElementCount())
		{
			Element line = map.getElement(i);
			int start = line.getStartOffset();
			buffer.getText(start,line.getEndOffset() - start - 1,
				lineSegment);
			out.write(lineSegment.array,lineSegment.offset,
				lineSegment.count);
			out.write(newline);
			if(++i % PROGRESS_INTERVAL == 0)
				setProgressValue(i / PROGRESS_INTERVAL);
		}
		out.close();
	}
	private void writeMarkers(Buffer buffer, OutputStream out)
		throws IOException
	{
		Writer o = new BufferedWriter(new OutputStreamWriter(out));
		Vector markers = buffer.getMarkers();
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			o.write('!');
			o.write(marker.getShortcut());
			o.write(';');
			String pos = String.valueOf(marker.getPosition());
			o.write(pos);
			o.write(';');
			o.write(pos);
			o.write('\n');
		}
		o.close();
	}
	private void insert()
	{
		InputStream in = null;
		try
		{
			try
			{
				String[] args = { vfs.getFileName(path) };
				setStatus(jEdit.getProperty(""vfs.status.load"",args));
				setAbortable(true);
				VFS.DirectoryEntry entry = vfs._getDirectoryEntry(
					session,path,view);
				long length;
				if(entry != null)
					length = entry.length;
				else
					length = 0L;
				in = vfs._createInputStream(session,path,false,view);
				if(in == null)
					return;
				if(path.endsWith("".gz""))
					in = new GZIPInputStream(in);
				read(buffer,in,length);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { path, io.toString() };
				VFSManager.error(view,""read-error"",pp);
			}
		}
		catch(WorkThread.Abort a)
		{
			if(in != null)
			{
				try
				{
					in.close();
				}
				catch(IOException io)
				{
				}
			}
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { path, io.toString() };
				VFSManager.error(view,""read-error"",pp);
			}
			catch(WorkThread.Abort a)
			{
			}
		}
	}
}
"
org.gjt.sp.jedit.io.FavoritesVFS,"/*
 * FavoritesVFS.java - Stores frequently-visited directory locations
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
import java.awt.Component;
import java.util.Vector;
import org.gjt.sp.jedit.jEdit;
/**
 * A VFS used for remembering frequently-visited directories. Listing it
 * returns the favorites list. The deletePath of each entry is the
 * directory prefixed with ""favorites:"" so that right-clicking on a
 * favorite and clicking 'delete' in the browser just deletes the
 * favorite, and not the directory itself.
 * @author Slava Pestov
 * @version $Id: FavoritesVFS.java,v 1.7 2000/11/11 02:59:30 sp Exp $
 */
public class FavoritesVFS extends VFS
{
	public static final String PROTOCOL = ""favorites"";
	public FavoritesVFS()
	{
		super(""favorites"");
		/* addToFavorites(), which is a static method
		 * (for convinience) needs an instance of the
		 * VFS to pass to VFSManager.sendVFSUpdate(),
		 * hence this hack. */
		instance = this;
	}
	public int getCapabilities()
	{
		// BROWSE_CAP not set because we don't want the VFS browser
		// to create the default 'favorites' button on the tool bar
		return /* BROWSE_CAP | */ DELETE_CAP;
	}
	public String getParentOfPath(String path)
	{
		return PROTOCOL + "":"";
	}
	public VFS.DirectoryEntry[] _listDirectory(Object session, String url,
		Component comp)
	{
		synchronized(lock)
		{
			VFS.DirectoryEntry[] retVal = new VFS.DirectoryEntry[favorites.size()];
			for(int i = 0; i < retVal.length; i++)
			{
				String favorite = (String)favorites.elementAt(i);
				retVal[i] = _getDirectoryEntry(session,favorite,comp);
			}
			return retVal;
		}
	}
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		return new VFS.DirectoryEntry(path,path,""favorites:"" + path,
					VFS.DirectoryEntry.DIRECTORY,
					0L,false);
	}
	public boolean _delete(Object session, String path, Component comp)
	{
		synchronized(lock)
		{
			path = path.substring(PROTOCOL.length() + 1);
			favorites.removeElement(path);
			VFSManager.sendVFSUpdate(this,PROTOCOL + "":"",false);
		}
		return true;
	}
	public static void loadFavorites()
	{
		synchronized(lock)
		{
			String favorite;
			int i = 0;
			while((favorite = jEdit.getProperty(""vfs.favorite."" + i)) != null)
			{
				favorites.addElement(favorite);
				i++;
			}
		}
	}
	public static void addToFavorites(String path)
	{
		synchronized(lock)
		{
			favorites.addElement(path);
			VFSManager.sendVFSUpdate(instance,PROTOCOL + "":"",false);
		}
	}
	public static void saveFavorites()
	{
		synchronized(lock)
		{
			for(int i = 0; i < favorites.size(); i++)
			{
				jEdit.setProperty(""vfs.favorite."" + i,
					(String)favorites.elementAt(i));
			}
			jEdit.unsetProperty(""vfs.favorite."" + favorites.size());
		}
	}
	// private members
	private static FavoritesVFS instance;
	private static Object lock = new Object();
	private static Vector favorites = new Vector();
}
/*
 * Change Log:
 * $Log: FavoritesVFS.java,v $
 * Revision 1.7  2000/11/11 02:59:30  sp
 * FTP support moved out of the core into a plugin
 *
 * Revision 1.6  2000/08/29 07:47:13  sp
 * Improved complete word, type-select in VFS browser, bug fixes
 *
 * Revision 1.5  2000/08/27 02:06:52  sp
 * Filter combo box changed to a text field in VFS browser, passive mode FTP toggle
 *
 * Revision 1.4  2000/08/20 07:29:31  sp
 * I/O and VFS browser improvements
 *
 * Revision 1.3  2000/08/06 09:44:27  sp
 * VFS browser now has a tree view, rename command
 *
 * Revision 1.2  2000/08/05 07:16:12  sp
 * Global options dialog box updated, VFS browser now supports right-click menus
 *
 * Revision 1.1  2000/08/03 07:43:42  sp
 * Favorites added to browser, lots of other stuff too
 *
 */
"
org.gjt.sp.jedit.io.FileRootsVFS,"/*
 * FileRootsVFS.java - Local root filesystems VFS
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
import javax.swing.filechooser.FileSystemView;
import java.awt.Component;
import java.lang.reflect.*;
import java.io.File;
import org.gjt.sp.util.Log;
/**
 * A VFS that lists local root filesystems.
 * @author Slava Pestov
 * @version $Id: FileRootsVFS.java,v 1.5 2001/07/22 07:46:26 sp Exp $
 */
public class FileRootsVFS extends VFS
{
	public static final String PROTOCOL = ""roots"";
	public FileRootsVFS()
	{
		super(""roots"");
		// try using Java 2 method first
		try
		{
			method = File.class.getMethod(""listRoots"",new Class[0]);
			Log.log(Log.DEBUG,this,""File.listRoots() detected"");
		}
		catch(Exception e)
		{
			fsView = FileSystemView.getFileSystemView();
			Log.log(Log.DEBUG,this,""File.listRoots() not detected"");
		}
	}
	public int getCapabilities()
	{
		// BROWSE_CAP not set because we don't want the VFS browser
		// to create the default 'favorites' item in the 'More' menu
		return 0 /* BROWSE_CAP | */;
	}
	public String getParentOfPath(String path)
	{
		return PROTOCOL + "":"";
	}
	public VFS.DirectoryEntry[] _listDirectory(Object session, String url,
		Component comp)
	{
		File[] roots;
		if(method == null)
			roots = fsView.getRoots();
		else
		{
			try
			{
				roots = (File[])method.invoke(null,new Object[0]);
			}
			catch(Exception e)
			{
				roots = null;
				Log.log(Log.ERROR,this,e);
			}
		}
		if(roots == null)
			return null;
		VFS.DirectoryEntry[] rootDE = new VFS.DirectoryEntry[roots.length];
		for(int i = 0; i < roots.length; i++)
		{
			String name = roots[i].getPath();
			rootDE[i] = _getDirectoryEntry(session,name,comp);
		}
		return rootDE;
	}
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		return new VFS.DirectoryEntry(path,path,path,VFS.DirectoryEntry
			.FILESYSTEM,0L,false);
	}
	// private members
	private FileSystemView fsView;
	private Method method;
}
"
org.gjt.sp.jedit.io.FileVFS,"/*
 * FileVFS.java - Local filesystem VFS
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 * Portions copyright (C) 1998, 1999, 2000 Peter Graves
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
import javax.swing.filechooser.FileSystemView;
import java.awt.Component;
import java.io.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * Local filesystem VFS.
 * @author Slava Pestov
 * @version $Id: FileVFS.java,v 1.39 2001/08/12 11:26:42 sp Exp $
 */
public class FileVFS extends VFS
{
	public static final String BACKED_UP_PROPERTY = ""FileVFS__backedUp"";
	public static final String PERMISSIONS_PROPERTY = ""FileVFS__perms"";
	public FileVFS()
	{
		super(""file"");
		fsView = FileSystemView.getFileSystemView();
	}
	public int getCapabilities()
	{
		return READ_CAP | WRITE_CAP | BROWSE_CAP | DELETE_CAP
			| RENAME_CAP | MKDIR_CAP;
	}
	public String getParentOfPath(String path)
	{
		// handle Windows differently
		if(File.separatorChar == '\\')
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				return FileRootsVFS.PROTOCOL + "":"";
			else if(path.length() == 3 && path.endsWith("":\\""))
				return FileRootsVFS.PROTOCOL + "":"";
		}
		if(path.equals(""/""))
			return FileRootsVFS.PROTOCOL + "":"";
		/* File[] roots = fsView.getRoots();
		for(int i = 0; i < roots.length; i++)
		{
			if(roots[i].getPath().equals(path))
				return FileRootsVFS.PROTOCOL + "":"";
		} */
		return MiscUtilities.getParentOfPath(path);
	}
	public String constructPath(String parent, String path)
	{
		return MiscUtilities.constructPath(parent,path);
	}
	public char getFileSeparator()
	{
		return File.separatorChar;
	}
	public boolean load(View view, Buffer buffer, String path)
	{
		File file = buffer.getFile();
		if(!file.exists())
		{
			buffer.setNewFile(true);
			return false;
		}
		else
			buffer.setReadOnly(!file.canWrite());
		if(file.isDirectory())
		{
			String[] args = { file.getPath() };
			GUIUtilities.error(view,""open-directory"",args);
			buffer.setNewFile(false);
			return false;
		}
		if(!file.canRead())
		{
			String[] args = { file.getPath() };
			GUIUtilities.error(view,""no-read"",args);
			buffer.setNewFile(false);
			return false;
		}
		return super.load(view,buffer,path);
	}
	public boolean save(View view, Buffer buffer, String path)
	{
		// can't call buffer.getFile() here because this
		// method is called *before* setPath()
		File file = new File(path);
		// Apparently, certain broken OSes (like Micro$oft Windows)
		// can mess up directories if they are write()'n to
		if(file.isDirectory())
		{
			String[] args = { file.getPath() };
			GUIUtilities.error(view,""save-directory"",args);
			return false;
		}
		// Check that we can actually write to the file
		if((file.exists() && !file.canWrite())
			|| (!file.exists() && !new File(file.getParent()).canWrite()))
		{
			String[] args = { path };
			GUIUtilities.error(view,""no-write"",args);
			return false;
		}
		// On Unix, preserve permissions
		int permissions = getPermissions(buffer.getPath());
		Log.log(Log.DEBUG,this,buffer.getPath() + "" has permissions 0""
			+ Integer.toString(permissions,8));
		buffer.putProperty(PERMISSIONS_PROPERTY,new Integer(permissions));
		return super.save(view,buffer,path);
	}
	public boolean insert(View view, Buffer buffer, String path)
	{
		File file = new File(path);
		if(!file.exists())
			return false;
		if(file.isDirectory())
		{
			String[] args = { file.getPath() };
			GUIUtilities.error(view,""open-directory"",args);
			return false;
		}
		if(!file.canRead())
		{
			String[] args = { file.getPath() };
			GUIUtilities.error(view,""no-read"",args);
			return false;
		}
		return super.load(view,buffer,path);
	}
	public VFS.DirectoryEntry[] _listDirectory(Object session, String path,
		Component comp)
	{
		/* Fix for the bug where listing a drive letter on Windows
		 * doesn't work. On Windows, paths of the form X: list the
		 * last *working directory* on that drive. To list the root
		 * of the drive, you must use X:\.
		 *
		 * However, the VFS browser and friends strip off trailing
		 * path separators, for various reasons. So to work around
		 * that, we add a '\' to drive letter paths on Windows.
		 */
		if(File.separatorChar == '\\')
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				path = path.concat(File.separator);
		}
		File directory = new File(path);
		String[] list = directory.list();
		if(list == null)
		{
			String[] pp = { path };
			VFSManager.error(comp,""directory-error-nomsg"",pp);
			return null;
		}
		Vector list2 = new Vector();
		for(int i = 0; i < list.length; i++)
		{
			String name = list[i];
			String _path;
			if(path.endsWith(File.separator))
				_path = path + name;
			else
				_path = path + File.separatorChar + name;
			File file = new File(_path);
			int type;
			if(file.isDirectory())
				type = VFS.DirectoryEntry.DIRECTORY;
			else
				type = VFS.DirectoryEntry.FILE;
			VFS.DirectoryEntry entry = new VFS.DirectoryEntry(
				name,_path,_path,type,file.length(),
				fsView.isHiddenFile(file));
			list2.addElement(entry);
		}
		VFS.DirectoryEntry[] retVal = new VFS.DirectoryEntry[list2.size()];
		list2.copyInto(retVal);
		return retVal;
	}
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		// workaround for Java bug where paths with trailing / return
		// null getName()
		if(path.endsWith(""/"") || path.endsWith(File.separator))
			path = path.substring(0,path.length() - 1);
		File file = new File(path);
		if(!file.exists())
			return null;
		int type;
		if(file.isDirectory())
			type = VFS.DirectoryEntry.DIRECTORY;
		else
			type = VFS.DirectoryEntry.FILE;
		return new VFS.DirectoryEntry(file.getName(),path,path,type,
			file.length(),fsView.isHiddenFile(file));
	}
	public boolean _delete(Object session, String path, Component comp)
	{
		boolean retVal = new File(path).delete();
		if(retVal)
			VFSManager.sendVFSUpdate(this,path,true);
		return retVal;
	}
	public boolean _rename(Object session, String from, String to,
		Component comp)
	{
		File _to = new File(to);
		_to.delete();
		boolean retVal = new File(from).renameTo(_to);
		VFSManager.sendVFSUpdate(this,from,true);
		VFSManager.sendVFSUpdate(this,to,true);
		return retVal;
	}
	public boolean _mkdir(Object session, String directory, Component comp)
	{
		boolean retVal = new File(directory).mkdirs();
		VFSManager.sendVFSUpdate(this,directory,true);
		return retVal;
	}
	public void _backup(Object session, String path, Component comp)
		throws IOException
	{
		// Fetch properties
		int backups;
		try
		{
			backups = Integer.parseInt(jEdit.getProperty(
				""backups""));
		}
		catch(NumberFormatException nf)
		{
			Log.log(Log.ERROR,this,nf);
			backups = 1;
		}
		if(backups == 0)
			return;
		String backupPrefix = jEdit.getProperty(""backup.prefix"","""");
		String backupSuffix = jEdit.getProperty(""backup.suffix"",""~"");
		File file = new File(path);
		// Check for backup.directory property, and create that
		// directory if it doesn't exist
		String backupDirectory = jEdit.getProperty(""backup.directory"");
		if(backupDirectory == null || backupDirectory.length() == 0)
			backupDirectory = file.getParent();
		else
		{
			backupDirectory = MiscUtilities.constructPath(
				System.getProperty(""user.home""),backupDirectory);
			// Perhaps here we would want to guard with
			// a property for parallel backups or not.
			backupDirectory = MiscUtilities.concatPath(
				backupDirectory,file.getParent());
			File dir = new File(backupDirectory);
			if (!dir.exists())
				dir.mkdirs();
		}
		String name = file.getName();
		// If backups is 1, create ~ file
		if(backups == 1)
		{
			file.renameTo(new File(backupDirectory,
				backupPrefix + name + backupSuffix));
		}
		// If backups > 1, move old ~n~ files, create ~1~ file
		else
		{
			new File(backupDirectory,
				backupPrefix + name + backupSuffix
				+ backups + backupSuffix).delete();
			for(int i = backups - 1; i > 0; i--)
			{
				File backup = new File(backupDirectory,
					backupPrefix + name + backupSuffix
					+ i + backupSuffix);
				backup.renameTo(new File(backupDirectory,
					backupPrefix + name + backupSuffix
					+ (i+1) + backupSuffix));
			}
			file.renameTo(new File(backupDirectory,
				backupPrefix + name + backupSuffix
				+ ""1"" + backupSuffix));
		}
	}
	public InputStream _createInputStream(Object session, String path,
		boolean ignoreErrors, Component comp) throws IOException
	{
		try
		{
			return new FileInputStream(path);
		}
		catch(IOException io)
		{
			if(ignoreErrors)
				return null;
			else
				throw io;
		}
	}
	public OutputStream _createOutputStream(Object session, String path,
		Component comp) throws IOException
	{
		OutputStream retVal = new FileOutputStream(path);
		// commented out for now, because updating VFS browsers
		// every time file is saved gets annoying
		//VFSManager.sendVFSUpdate(this,path,true);
		return retVal;
	}
	public void _saveComplete(Object session, Buffer buffer, Component comp)
	{
		int permissions = ((Integer)buffer.getProperty(PERMISSIONS_PROPERTY))
			.intValue();
		setPermissions(buffer.getPath(),permissions);
	}
	/** Code borrowed from j text editor (http://www.armedbear.org) */
	/** I made some changes to make it support suid, sgid and sticky files */
	/**
	 * Returns numeric permissions of a file. On non-Unix systems, always
	 * returns zero.
	 * @since jEdit 3.2pre9
	 */
	public static int getPermissions(String path)
	{
		int permissions = 0;
		if(isUnix)
		{
			String[] cmdarray = { ""ls"", ""-ld"", path };
			try
			{
				Process process = Runtime.getRuntime().exec(cmdarray);
				BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
				String output = reader.readLine();
				if(output != null)
				{
					String s = output.substring(1, 10);
					if(s.length() == 9)
					{
						if(s.charAt(0) == 'r')
							permissions += 0400;
						if(s.charAt(1) == 'w')
							permissions += 0200;
						if(s.charAt(2) == 'x')
							permissions += 0100;
						else if(s.charAt(2) == 's')
							permissions += 04100;
						else if(s.charAt(2) == 'S')
							permissions += 04000;
						if(s.charAt(3) == 'r')
							permissions += 040;
						if(s.charAt(4) == 'w')
							permissions += 020;
						if(s.charAt(5) == 'x')
							permissions += 010;
						else if(s.charAt(5) == 's')
							permissions += 02010;
						else if(s.charAt(5) == 'S')
							permissions += 02000;
						if(s.charAt(6) == 'r')
							permissions += 04;
						if(s.charAt(7) == 'w')
							permissions += 02;
						if(s.charAt(8) == 'x')
							permissions += 01;
						else if(s.charAt(8) == 't')
							permissions += 01001;
						else if(s.charAt(8) == 'T')
							permissions += 01000;
					}
				}
			}
			// Feb 4 2000 5:30 PM
			// Catch Throwable here rather than Exception.
			// Kaffe's implementation of Runtime.exec throws java.lang.InternalError.
			catch (Throwable t)
			{
			}
		}
		return permissions;
	}
	/**
	 * Sets numeric permissions of a file. On non-Unix platforms,
	 * does nothing.
	 * @since jEdit 3.2pre9
	 */
	public static void setPermissions(String path, int permissions)
	{
		if(permissions != 0)
		{
			if(isUnix)
			{
				String[] cmdarray = { ""chmod"", Integer.toString(permissions, 8), path };
				try
				{
					Process process = Runtime.getRuntime().exec(cmdarray);
					process.getInputStream().close();
					process.getOutputStream().close();
					process.getErrorStream().close();
					int exitCode = process.waitFor();
					if(exitCode != 0)
						Log.log(Log.NOTICE,FileVFS.class,""chmod exited with code "" + exitCode);
				}
				// Feb 4 2000 5:30 PM
				// Catch Throwable here rather than Exception.
				// Kaffe's implementation of Runtime.exec throws java.lang.InternalError.
				catch (Throwable t)
				{
				}
			}
		}
	}
	// private members
	private FileSystemView fsView;
	private static boolean isUnix;
	static
	{
		// If the file separator is '/', the OS is either Unix,
		// MacOS X, or MacOS.
		if(File.separatorChar == '/')
		{
			String osName = System.getProperty(""os.name"");
			if(osName.indexOf(""MacOS"") != -1)
			{
				if(osName.indexOf(""X"") != -1)
				{
					// MacOS X is Unix.
					isUnix = true;
				}
				else
				{
					// Classic MacOS is definately not Unix.
					isUnix = false;
				}
			}
			else
			{
				// Unix.
				isUnix = true;
			}
		}
		Log.log(Log.DEBUG,FileVFS.class,""Unix operating system ""
			+ (isUnix ? ""detected; will"" : ""not detected; will not"")
			+ "" use permission-preserving code"");
	}
}
"
org.gjt.sp.jedit.io.UrlVFS,"/*
 * UrlVFS.java - Url VFS
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
import java.awt.Component;
import java.io.*;
import java.net.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * URL VFS.
 * @author Slava Pestov
 * @version $Id: UrlVFS.java,v 1.10 2001/04/18 03:09:45 sp Exp $
 */
public class UrlVFS extends VFS
{
	public UrlVFS()
	{
		super(""url"");
	}
	public int getCapabilities()
	{
		return READ_CAP | WRITE_CAP;
	}
	public String constructPath(String parent, String path)
	{
		if(parent.endsWith(""/""))
			return parent + path;
		else
			return parent + '/' + path;
	}
	public String getParentOfPath(String path)
	{
		return MiscUtilities.getParentOfPath(path);
	}
	public InputStream _createInputStream(Object session,
		String path, boolean ignoreErrors, Component comp)
		throws IOException
	{
		try
		{
			return new URL(path).openStream();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			String[] args = { path, mu.getMessage() };
			VFSManager.error(comp,""badurl"",args);
			return null;
		}
	}
	public OutputStream _createOutputStream(Object session, String path,
		Component comp) throws IOException
	{
		try
		{
			return new URL(path).openConnection()
				.getOutputStream();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			String[] args = { path };
			VFSManager.error(comp,""badurl"",args);
			return null;
		}
	}
}
"
org.gjt.sp.jedit.io.VFS,"/*
 * VFS.java - Virtual filesystem implementation
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
import java.awt.Component;
import java.io.*;
import org.gjt.sp.jedit.*;
/**
 * A virtual filesystem implementation. Note tha methods whose names are
 * prefixed with ""_"" are called from the I/O thread.
 * @param author Slava Pestov
 * @author $Id: VFS.java,v 1.28 2001/05/29 11:30:05 sp Exp $
 */
public abstract class VFS
{
	/**
	 * Read capability.
	 * @since jEdit 2.6pre2
	 */
	public static final int READ_CAP = 1 << 0;
	/**
	 * Write capability.
	 * @since jEdit 2.6pre2
	 */
	public static final int WRITE_CAP = 1 << 1;
	/**
	 * If set, a menu item for this VFS will appear in the browser's
	 * 'More' menu. If not set, it will still be possible to type in
	 * URLs in this VFS in the browser, but there won't be a user-visible
	 * way of doing this.
	 * @since jEdit 2.6pre2
	 */
	public static final int BROWSE_CAP = 1 << 2;
	/**
	 * Delete file capability.
	 * @since jEdit 2.6pre2
	 */
	public static final int DELETE_CAP = 1 << 3;
	/**
	 * Rename file capability.
	 * @since jEdit 2.6pre2
	 */
	public static final int RENAME_CAP = 1 << 4;
	/**
	 * Make directory file capability.
	 * @since jEdit 2.6pre2
	 */
	public static final int MKDIR_CAP = 1 << 5;
	/**
	 * Creates a new virtual filesystem.
	 * @param name The name
	 */
	public VFS(String name)
	{
		this.name = name;
	}
	/**
	 * Returns this VFS's name. The name is used to obtain the
	 * label stored in the <code>vfs.<i>name</i>.label</code>
	 * property.
	 */
	public String getName()
	{
		return name;
	}
	/**
	 * Returns the capabilities of this VFS.
	 * @since jEdit 2.6pre2
	 */
	public abstract int getCapabilities();
	/**
	 * Displays a dialog box that should set up a session and return
	 * the initial URL to browse.
	 * @param session Where the VFS session will be stored
	 * @param comp The component that will parent error dialog boxes
	 * @return The URL
	 * @since jEdit 2.7pre1
	 */
	public String showBrowseDialog(Object[] session, Component comp)
	{
		return null;
	}
	/**
	 * Returns the file name component of the specified path. The
	 * default implementation calls
	 * <code>MiscUtilities.getFileName()</code>
	 * @param path The path
	 * @since jEdit 3.1pre4
	 */
	public String getFileName(String path)
	{
		return MiscUtilities.getFileName(path);
	}
	/**
	 * Returns the parent of the specified path. This must be
	 * overridden to return a non-null value for browsing of this
	 * filesystem to work.
	 * @param path The path
	 * @since jEdit 2.6pre5
	 */
	public String getParentOfPath(String path)
	{
		return null;
	}
	/**
	 * Constructs a path from the specified directory and
	 * file name component. This must be overridden to return a
	 * non-null value, otherwise browsing this filesystem will
	 * not work.
	 * @param parent The parent directory
	 * @param path The path
	 * @since jEdit 2.6pre2
	 */
	public String constructPath(String parent, String path)
	{
		return parent + path;
	}
	/**
	 * Returns the file separator used by this VFS.
	 * @since jEdit 2.6pre9
	 */
	public char getFileSeparator()
	{
		return '/';
	}
	/**
	 * Creates a VFS session. This method is called from the AWT thread,
	 * so it should not do any I/O. It could, however, prompt for
	 * a login name and password, for example.
	 * @param path The path in question
	 * @param comp The component that will parent error dialog boxes
	 * @return The session
	 * @since jEdit 2.6pre3
	 */
	public Object createVFSSession(String path, Component comp)
	{
		return new Object();
	}
	/**
	 * Loads the specified buffer. The default implementation posts
	 * an I/O request to the I/O thread.
	 * @param view The view
	 * @param buffer The buffer
	 * @param path The path
	 */
	public boolean load(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & READ_CAP) == 0)
		{
			VFSManager.error(view,""vfs.not-supported.load"",new String[] { name });
			return false;
		}
		Object session = createVFSSession(path,view);
		if(session == null)
			return false;
		BufferIORequest request = new BufferIORequest(
			BufferIORequest.LOAD,view,buffer,session,this,path);
		if(buffer.isTemporary())
			// this makes HyperSearch much faster
			request.run();
		else
			VFSManager.runInWorkThread(request);
		return true;
	}
	/**
	 * Saves the specifies buffer. The default implementation posts
	 * an I/O request to the I/O thread.
	 * @param view The view
	 * @param buffer The buffer
	 * @param path The path
	 */
	public boolean save(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & WRITE_CAP) == 0)
		{
			VFSManager.error(view,""vfs.not-supported.save"",new String[] { name });
			return false;
		}
		Object session = createVFSSession(path,view);
		if(session == null)
			return false;
		/* When doing a 'save as', the path to save to (path)
		 * will not be the same as the buffer's previous path
		 * (buffer.getPath()). In that case, we want to create
		 * a backup of the new path, even if the old path was
		 * backed up as well (BACKED_UP property set) */
		if(!path.equals(buffer.getPath()))
			buffer.getDocumentProperties().remove(Buffer.BACKED_UP);
		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.SAVE,view,buffer,session,this,path));
		return true;
	}
	/**
	 * Inserts a file into the specified buffer. The default implementation
	 * posts an I/O request to the I/O thread.
	 * @param view The view
	 * @param buffer The buffer
	 * @param path The path
	 */
	public boolean insert(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & READ_CAP) == 0)
		{
			VFSManager.error(view,""vfs.not-supported.load"",new String[] { name });
			return false;
		}
		Object session = createVFSSession(path,view);
		if(session == null)
			return false;
		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.INSERT,view,buffer,session,this,path));
		return true;
	}
	// the remaining methods are only called from the I/O thread
	/**
	 * Lists the specified directory. Note that this must be a full
	 * URL, including the host name, path name, and so on. The
	 * username and password is obtained from the session.
	 * @param session The session
	 * @param directory The directory
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurred
	 * @since jEdit 2.7pre1
	 */
	public DirectoryEntry[] _listDirectory(Object session, String directory,
		Component comp)
		throws IOException
	{
		VFSManager.error(comp,""vfs.not-supported.list"",new String[] { name });
		return null;
	}
	/**
	 * Returns the specified directory entry.
	 * @param session The session
	 * @param path The path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurred
	 * @return The specified directory entry, or null if it doesn't exist.
	 * @since jEdit 2.7pre1
	 */
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
		throws IOException
	{
		return null;
	}
	/**
	 * A directory entry.
	 * @since jEdit 2.6pre2
	 */
	public static class DirectoryEntry implements Serializable
	{
		public static final int FILE = 0;
		public static final int DIRECTORY = 1;
		public static final int FILESYSTEM = 2;
		public String name;
		public String path;
		public String deletePath;
		public int type;
		public long length;
		public boolean hidden;
		public DirectoryEntry(String name, String path, String deletePath,
			int type, long length, boolean hidden)
		{
			this.name = name;
			this.path = path;
			this.deletePath = deletePath;
			this.type = type;
			this.length = length;
			this.hidden = hidden;
		}
		public String toString()
		{
			return name;
		}
	}
	/**
	 * Deletes the specified URL.
	 * @param session The VFS session
	 * @param path The path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurs
	 * @since jEdit 2.7pre1
	 */
	public boolean _delete(Object session, String path, Component comp)
		throws IOException
	{
		return false;
	}
	/**
	 * Renames the specified URL. Some filesystems might support moving
	 * URLs between directories, however others may not. Do not rely on
	 * this behavior.
	 * @param session The VFS session
	 * @param from The old path
	 * @param to The new path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurs
	 * @since jEdit 2.7pre1
	 */
	public boolean _rename(Object session, String from, String to,
		Component comp) throws IOException
	{
		return false;
	}
	/**
	 * Creates a new directory with the specified URL.
	 * @param session The VFS session
	 * @param directory The directory
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurs
	 * @since jEdit 2.7pre1
	 */
	public boolean _mkdir(Object session, String directory, Component comp)
		throws IOException
	{
		return false;
	}
	/**
	 * Backs up the specified file. This should only be overriden by
	 * the local filesystem VFS.
	 * @param session The VFS session
	 * @param path The path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurs
	 * @since jEdit 3.2pre2
	 */
	public void _backup(Object session, String path, Component comp)
		throws IOException
	{
	}
	/**
	 * Creates an input stream. This method is called from the I/O
	 * thread.
	 * @param session the VFS session
	 * @param path The path
	 * @param ignoreErrors If true, file not found errors should be
	 * ignored
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException If an I/O error occurs
	 * @since jEdit 2.7pre1
	 */
	public InputStream _createInputStream(Object session,
		String path, boolean ignoreErrors, Component comp)
		throws IOException
	{
		VFSManager.error(comp,""vfs.not-supported.load"",new String[] { name });
		return null;
	}
	/**
	 * Creates an output stream. This method is called from the I/O
	 * thread.
	 * @param session the VFS session
	 * @param path The path
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException If an I/O error occurs
	 * @since jEdit 2.7pre1
	 */
	public OutputStream _createOutputStream(Object session,
		String path, Component comp)
		throws IOException
	{
		VFSManager.error(comp,""vfs.not-supported.save"",new String[] { name });
		return null;
	}
	/**
	 * Called after a file has been saved.
	 * @param session The VFS session
	 * @param buffer The buffer
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException If an I/O error occurs
	 * @since jEdit 3.1pre1
	 */
	public void _saveComplete(Object session, Buffer buffer, Component comp)
		throws IOException {}
	/**
	 * Finishes the specified VFS session. This must be called
	 * after all I/O with this VFS is complete, to avoid leaving
	 * stale network connections and such.
	 * @param session The VFS session
	 * @param comp The component that will parent error dialog boxes
	 * @exception IOException if an I/O error occurred
	 * @since jEdit 2.7pre1
	 */
	public void _endVFSSession(Object session, Component comp)
		throws IOException
	{
	}
	// private members
	private String name;
}
/*
 * Change Log:
 * $Log: VFS.java,v $
 * Revision 1.28  2001/05/29 11:30:05  sp
 * foo
 *
 * Revision 1.27  2001/05/17 05:00:14  sp
 * Status bar, various minor tweaks
 *
 * Revision 1.26  2001/05/13 07:21:27  sp
 * more stuff
 *
 * Revision 1.25  2001/04/27 11:28:46  sp
 * new selection code started
 *
 * Revision 1.24  2001/04/18 03:09:45  sp
 * GJT was down for a long time
 *
 * Revision 1.23  2001/01/23 09:23:48  sp
 * code cleanups, misc tweaks
 *
 * Revision 1.22  2000/11/11 02:59:31  sp
 * FTP support moved out of the core into a plugin
 *
 * Revision 1.21  2000/11/05 00:44:14  sp
 * Improved HyperSearch, improved horizontal scroll, other stuff
 *
 * Revision 1.20  2000/11/02 09:19:33  sp
 * more features
 *
 * Revision 1.19  2000/10/15 04:10:35  sp
 * bug fixes
 *
 * Revision 1.18  2000/08/29 07:47:13  sp
 * Improved complete word, type-select in VFS browser, bug fixes
 *
 * Revision 1.17  2000/08/23 09:51:48  sp
 * Documentation updates, abbrev updates, bug fixes
 *
 * Revision 1.16  2000/08/16 12:14:29  sp
 * Passwords are now saved, bug fixes, documentation updates
 *
 * Revision 1.15  2000/08/10 11:55:58  sp
 * VFS browser toolbar improved a little bit, font selector tweaks
 *
 * Revision 1.14  2000/08/06 09:44:27  sp
 * VFS browser now has a tree view, rename command
 *
 * Revision 1.13  2000/08/05 07:16:12  sp
 * Global options dialog box updated, VFS browser now supports right-click menus
 *
 * Revision 1.12  2000/08/03 07:43:42  sp
 * Favorites added to browser, lots of other stuff too
 *
 */
"
org.gjt.sp.jedit.io.VFSManager,"/*
 * VFSManager.java - Main class of virtual filesystem
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.io;
import java.util.Enumeration;
import java.util.Hashtable;
import javax.swing.SwingUtilities;
import java.awt.Component;
import java.util.Vector;
import org.gjt.sp.jedit.msg.VFSUpdate;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.WorkThreadPool;
/**
 * jEdit's virtual filesystem allows it to transparently edit files
 * stored elsewhere than the local filesystem, for example on an FTP
 * site.
 * @author Slava Pestov
 * @version $Id: VFSManager.java,v 1.23 2001/03/01 11:03:27 sp Exp $
 */
public class VFSManager
{
	/**
	 * Do not call.
	 */
	public static void start()
	{
		ioThreadPool.start();
	}
	/**
	 * Returns the I/O thread pool.
	 */
	public static WorkThreadPool getIOThreadPool()
	{
		return ioThreadPool;
	}
	/**
	 * Returns the local filesystem VFS.
	 * @since jEdit 2.5pre1
	 */
	public static VFS getFileVFS()
	{
		return fileVFS;
	}
	/**
	 * Returns the URL VFS.
	 * @since jEdit 2.5pre1
	 */
	public static VFS getUrlVFS()
	{
		return urlVFS;
	}
	/**
	 * Returns the VFS for the specified name.
	 * @param name The VFS name
	 * @since jEdit 2.6pre4
	 */
	public static VFS getVFSByName(String name)
	{
		return (VFS)vfsHash.get(name);
	}
	/**
	 * Returns the VFS for the specified protocol.
	 * @param protocol The protocol
	 * @since jEdit 2.5pre1
	 */
	public static VFS getVFSForProtocol(String protocol)
	{
		if(protocol.equals(""file""))
			return fileVFS;
		else
		{
			VFS vfs = (VFS)protocolHash.get(protocol);
			if(vfs != null)
				return vfs;
			else
				return urlVFS;
		}
	}
	/**
	 * Returns the VFS for the specified path.
	 * @param path The path
	 * @since jEdit 2.6pre4
	 */
	public static VFS getVFSForPath(String path)
	{
		if(MiscUtilities.isURL(path))
			return getVFSForProtocol(MiscUtilities.getProtocolOfURL(path));
		else
			return fileVFS;
	}
	/**
	 * Registers a virtual filesystem.
	 * @param protocol The protocol
	 * @param vfs The VFS
	 * @since jEdit 2.5pre1
	 */
	public static void registerVFS(String protocol, VFS vfs)
	{
		Log.log(Log.DEBUG,VFSManager.class,""Registered ""
			+ vfs.getName() + "" filesystem for ""
			+ protocol + "" protocol"");
		vfsHash.put(vfs.getName(),vfs);
		protocolHash.put(protocol,vfs);
	}
	/**
	 * Returns an enumeration of all registered filesystems.
	 * @since jEdit 2.5pre1
	 */
	public static Enumeration getFilesystems()
	{
		return vfsHash.elements();
	}
	/**
	 * Returns when all pending requests are complete.
	 * @since jEdit 2.5pre1
	 */
	public static void waitForRequests()
	{
		ioThreadPool.waitForRequests();
	}
	/**
	 * Returns if the last request caused an error.
	 */
	public static boolean errorOccurred()
	{
		return error;
	}
	/**
	 * Returns the number of pending I/O requests.
	 */
	public static int getRequestCount()
	{
		return ioThreadPool.getRequestCount();
	}
	/**
	 * Executes the specified runnable in the AWT thread once all
	 * pending I/O requests are complete.
	 * @since jEdit 2.5pre1
	 */
	public static void runInAWTThread(Runnable run)
	{
		ioThreadPool.addWorkRequest(run,true);
	}
	/**
	 * Executes the specified runnable in one of the I/O threads.
	 * @since jEdit 2.6pre2
	 */
	public static void runInWorkThread(Runnable run)
	{
		ioThreadPool.addWorkRequest(run,false);
	}
	/**
	 * For use by VFS implementations and IO requests. Displays the
	 * specified error in the AWT thread.
	 * @since jEdit 2.6pre1
	 */
	public static void error(final Component comp, final String error, final Object[] args)
	{
		// if we are already in the AWT thread, take a shortcut
		if(SwingUtilities.isEventDispatchThread())
		{
			GUIUtilities.error(comp,error,args);
			return;
		}
		// the 'error' chicanery ensures that stuff like:
		// VFSManager.waitForRequests()
		// if(VFSManager.errorOccurred())
		//         ...
		// will work (because the below runnable will only be
		// executed in the next event)
		VFSManager.error = true;
		runInAWTThread(new Runnable()
		{
			public void run()
			{
				VFSManager.error = false;
				if(comp == null || !comp.isShowing())
					GUIUtilities.error(null,error,args);
				else
					GUIUtilities.error(comp,error,args);
			}
		});
	}
	/**
	 * Sends a VFS update message.
	 * @param vfs The VFS
	 * @param path The path that changed
	 * @param parent True if an update should be sent for the path's
	 * parent too
	 * @since jEdit 2.6pre4
	 */
	public static void sendVFSUpdate(VFS vfs, String path, boolean parent)
	{
		if(parent)
		{
			sendVFSUpdate(vfs,vfs.getParentOfPath(path),false);
			sendVFSUpdate(vfs,path,false);
		}
		else
		{
			// have to do this hack until VFSPath class is written
			if(path.length() != 1 && (path.endsWith(""/"")
				|| path.endsWith(java.io.File.separator)))
				path = path.substring(0,path.length() - 1);
			synchronized(vfsUpdateLock)
			{
				for(int i = 0; i < vfsUpdates.size(); i++)
				{
					VFSUpdate msg = (VFSUpdate)vfsUpdates
						.elementAt(i);
					if(msg.getPath().equals(path))
					{
						// don't send two updates
						// for the same path
						return;
					}
				}
				vfsUpdates.addElement(new VFSUpdate(path));
				if(vfsUpdates.size() == 1)
				{
					// we were the first to add an update;
					// add update sending runnable to AWT
					// thread
					VFSManager.runInAWTThread(new SendVFSUpdatesSafely());
				}
			}
		}
	}
	static class SendVFSUpdatesSafely implements Runnable
	{
		public void run()
		{
			synchronized(vfsUpdateLock)
			{
				for(int i = 0; i < vfsUpdates.size(); i++)
				{
					EditBus.send((VFSUpdate)vfsUpdates.elementAt(i));
				}
				vfsUpdates.removeAllElements();
			}
		}
	}
	// private members
	private static WorkThreadPool ioThreadPool;
	private static VFS fileVFS;
	private static VFS urlVFS;
	private static Hashtable vfsHash;
	private static Hashtable protocolHash;
	private static boolean error;
	private static Object vfsUpdateLock;
	private static Vector vfsUpdates;
	static
	{
		int count;
		try
		{
			count = Integer.parseInt(jEdit.getProperty(""ioThreadCount""));
		}
		catch(NumberFormatException nf)
		{
			count = 4;
		}
		ioThreadPool = new WorkThreadPool(""jEdit I/O"",count);
		fileVFS = new FileVFS();
		urlVFS = new UrlVFS();
		vfsHash = new Hashtable();
		protocolHash = new Hashtable();
		vfsUpdateLock = new Object();
		vfsUpdates = new Vector();
		registerVFS(FavoritesVFS.PROTOCOL,new FavoritesVFS());
		registerVFS(FileRootsVFS.PROTOCOL,new FileRootsVFS());
	}
	private VFSManager() {}
}
/*
 * Change Log:
 * $Log: VFSManager.java,v $
 * Revision 1.23  2001/03/01 11:03:27  sp
 * Improved folding, vfs bug fix
 *
 * Revision 1.22  2000/11/11 02:59:31  sp
 * FTP support moved out of the core into a plugin
 *
 * Revision 1.21  2000/08/31 02:54:00  sp
 * Improved activity log, bug fixes
 *
 * Revision 1.20  2000/08/29 07:47:13  sp
 * Improved complete word, type-select in VFS browser, bug fixes
 *
 * Revision 1.19  2000/08/27 02:06:52  sp
 * Filter combo box changed to a text field in VFS browser, passive mode FTP toggle
 *
 * Revision 1.18  2000/08/20 07:29:31  sp
 * I/O and VFS browser improvements
 *
 * Revision 1.17  2000/08/16 12:14:29  sp
 * Passwords are now saved, bug fixes, documentation updates
 *
 * Revision 1.16  2000/08/03 07:43:42  sp
 * Favorites added to browser, lots of other stuff too
 *
 * Revision 1.15  2000/07/29 12:24:08  sp
 * More VFS work, VFS browser started
 *
 * Revision 1.14  2000/07/26 07:48:45  sp
 * stuff
 *
 * Revision 1.13  2000/07/22 03:27:03  sp
 * threaded I/O improved, autosave rewrite started
 *
 * Revision 1.12  2000/07/21 10:23:49  sp
 * Multiple work threads
 *
 * Revision 1.11  2000/07/19 11:45:18  sp
 * I/O requests can be aborted now
 *
 */
"
org.gjt.sp.jedit.msg.BufferUpdate,"/*
 * BufferUpdate.java - Buffer update message
 * Copyright (C) 1999, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.*;
/**
 * Message sent when a buffer-related change occurs.
 * @author Slava Pestov
 * @version $Id: BufferUpdate.java,v 1.6 2001/06/26 08:50:00 sp Exp $
 *
 * @since jEdit 2.2pre6
 */
public class BufferUpdate extends EBMessage.NonVetoable
{
	/**
	 * Buffer created.
	 */
	public static final Object CREATED = ""CREATED"";
	/**
	 * Buffer load started.
	 * @since jEdit 2.6pre1
	 */
	public static final Object LOAD_STARTED = ""LOAD_STARTED"";
	/**
	 * Buffer loaded.
	 */
	public static final Object LOADED = ""LOADED"";
	/**
	 * Buffer closed.
	 */
	public static final Object CLOSED = ""CLOSED"";
	/**
	 * Buffer dirty changed.
	 */
	public static final Object DIRTY_CHANGED = ""DIRTY_CHANGED"";
	/**
	 * Buffer markers changed.
	 */
	public static final Object MARKERS_CHANGED = ""MARKERS_CHANGED"";
	/**
	 * Buffer mode changed.
	 */
	public static final Object MODE_CHANGED = ""MODE_CHANGED"";
	/**
	 * Character ncoding changed.
	 * @since jEdit 3.2pre4
	 */
	public static final Object ENCODING_CHANGED = ""ENCODING_CHANGED"";
	/**
	 * Buffer saving.
	 */
	public static final Object SAVING = ""SAVING"";
	/**
	 * Creates a new buffer update message.
	 * @param buffer The buffer
	 * @param what What happened
	 */
	public BufferUpdate(Buffer buffer, View view, Object what)
	{
		super(buffer);
		this.view = view;
		if(what == null)
			throw new NullPointerException(""What must be non-null"");
		this.what = what;
	}
	/**
	 * Returns what caused this buffer update.
	 */
	public Object getWhat()
	{
		return what;
	}
	/**
	 * Returns the buffer involved.
	 */
	public Buffer getBuffer()
	{
		return (Buffer)getSource();
	}
	/**
	 * Returns the view involved, which may be null.
	 */
	public View getView()
	{
		return view;
	}
	public String paramString()
	{
		return super.paramString() + "",what="" + what
			+ "",view="" + view;
	}
	// private members
	private Object what;
	private View view;
}
"
org.gjt.sp.jedit.msg.CreateDockableWindow,"/*
 * CreateDockableWindow.java - Message requesting a dockable window
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.gui.DockableWindow;
import org.gjt.sp.jedit.*;
/**
 * Message requesting a dockable window to be created.
 * @author Slava Pestov
 * @version $Id: CreateDockableWindow.java,v 1.1 2000/08/19 08:27:57 sp Exp $
 *
 * @since jEdit 2.6pre3
 */
public class CreateDockableWindow extends EBMessage
{
	/**
	 * Creates a dockable window request message.
	 * @param view The view
	 * @param name The dockable window name
	 * @param position The dockable window position
	 */
	public CreateDockableWindow(View view, String name, String position)
	{
		super(view);
		if(name == null)
			throw new NullPointerException(""Name must be non-null"");
		this.name = name;
		this.position = position;
	}
	/**
	 * Returns the view involved.
	 */
	public View getView()
	{
		return (View)getSource();
	}
	/**
	 * Returns the name of the dockable window to create.
	 */
	public String getDockableWindowName()
	{
		return name;
	}
	/**
	 * Sets the dockable window name.
	 */
	public void setDockableWindow(DockableWindow win)
	{
		this.win = win;
		veto();
	}
	/**
	 * Returns the dockable window, or null if nobody responded to the
	 * message.
	 */
	public DockableWindow getDockableWindow()
	{
		return win;
	}
	/**
	 * Returns the dockable window position.
	 */
	public String getPosition()
	{
		return position;
	}
	public String paramString()
	{
		return super.paramString() + "",name="" + name + "",position=""
			+ position;
	}
	// private members
	private String name;
	private String position;
	private DockableWindow win;
}
/*
 * Change Log:
 * $Log: CreateDockableWindow.java,v $
 * Revision 1.1  2000/08/19 08:27:57  sp
 * Forgot to add CreateDockableWindow message
 *
 */
"
org.gjt.sp.jedit.msg.EditorExiting,"/*
 * EditorExiting.java - Message sent before the editor exits
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
/**
 * Message sent just before jEdit exits.
 * @author Slava Pestov
 * @version $Id: EditorExiting.java,v 1.1 2000/01/28 00:20:58 sp Exp $
 *
 * @since jEdit 2.3pre2
 */
public class EditorExiting extends EBMessage.NonVetoable
{
	/**
	 * Creates a new editor exiting message.
	 * @param source The message source
	 */
	public EditorExiting(EBComponent source)
	{
		super(source);
	}
}
"
org.gjt.sp.jedit.msg.EditorExitRequested,"/*
 * EditorExitRequested.java - Message sent before jEdit starts exiting
 * Copyright (C) 2000 Dirk Moebius
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.View;
/**
 * Message sent when jEdit starts the exit process. It is send before
 * the settings are saved and the buffers are closed. Listeners of this
 * message should be aware that jEdit might not exit truely, maybe because
 * of errors, or the user cancelled the ""Save unsaved changed"" dialog, or
 * jEdit is in background mode.
 *
 * @author Dirk Moebius
 * @version $Id: EditorExitRequested.java,v 1.1 2001/03/17 07:07:40 sp Exp $
 *
 * @since jEdit 3.1pre4
 */
public class EditorExitRequested extends EBMessage.NonVetoable
{
	/**
	 * Creates a new editor exiting started message.
	 * @param view The view from which this exit was called
	 */
	public EditorExitRequested(View view)
	{
		super(view);
	}
	/**
	 * Returns the view involved.
	 */
	public View getView()
	{
		return (View)getSource();
	}
}
"
org.gjt.sp.jedit.msg.EditorStarted,"/*
 * EditorStarted.java - Message sent after editor is started, but before
 * initial view is created
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
/**
 * Message sent after jEdit has finished starting up, but before the initial
 * view is created.
 * @author Slava Pestov
 * @version $Id: EditorStarted.java,v 1.1 2000/01/28 00:20:58 sp Exp $
 *
 * @since jEdit 2.3pre2
 */
public class EditorStarted extends EBMessage.NonVetoable
{
	/**
	 * Creates a new editor started message.
	 * @param source The message source
	 */
	public EditorStarted(EBComponent source)
	{
		super(source);
	}
}
"
org.gjt.sp.jedit.msg.EditPaneUpdate,"/*
 * EditPaneUpdate.java - Edit pane update message
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;
/**
 * Message sent when an edit pane-related change occurs.
 * @author Slava Pestov
 * @version $Id: EditPaneUpdate.java,v 1.1 2000/05/10 08:24:05 sp Exp $
 *
 * @since jEdit 2.5pre1
 */
public class EditPaneUpdate extends EBMessage.NonVetoable
{
	/**
	 * Edit pane created.
	 */
	public static final Object CREATED = ""CREATED"";
	/**
	 * Edit pane destroyed.
	 */
	public static final Object DESTROYED = ""DESTROYED"";
	/**
	 * Edit pane buffer changed.
	 */
	public static final Object BUFFER_CHANGED = ""BUFFER_CHANGED"";
	/**
	 * Creates a new edit pane update message.
	 * @param editPane The edit pane
	 * @param what What happened
	 */
	public EditPaneUpdate(EditPane editPane, Object what)
	{
		super(editPane);
		if(what == null)
			throw new NullPointerException(""What must be non-null"");
		this.what = what;
	}
	/**
	 * Returns what caused this edit pane update.
	 */
	public Object getWhat()
	{
		return what;
	}
	/**
	 * Returns the edit pane involved.
	 */
	public EditPane getEditPane()
	{
		return (EditPane)getSource();
	}
	public String paramString()
	{
		return super.paramString() + "",what="" + what;
	}
	// private members
	private Object what;
}
"
org.gjt.sp.jedit.msg.MacrosChanged,"/*
 * MacrosChanged.java - Macros changed message
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
/**
 * Message sent when the list of available macros changes.
 * @author Slava Pestov
 * @version $Id: MacrosChanged.java,v 1.1 1999/11/19 08:54:52 sp Exp $
 *
 * @since jEdit 2.2pre6
 */
public class MacrosChanged extends EBMessage.NonVetoable
{
	/**
	 * Creates a new macros changed message.
	 * @param source The message source
	 */
	public MacrosChanged(EBComponent source)
	{
		super(source);
	}
}
"
org.gjt.sp.jedit.msg.PropertiesChanged,"/*
 * PropertiesChanged.java - Properties changed message
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
/**
 * Message sent when properties are changed using the global options or
 * plugin options dialog box.
 * @author Slava Pestov
 * @version $Id: PropertiesChanged.java,v 1.1 1999/11/19 08:54:52 sp Exp $
 *
 * @since jEdit 2.2pre6
 */
public class PropertiesChanged extends EBMessage.NonVetoable
{
	/**
	 * Creates a new properties changed message.
	 * @param source The message source
	 */
	public PropertiesChanged(EBComponent source)
	{
		super(source);
	}
}
"
org.gjt.sp.jedit.msg.SearchSettingsChanged,"/*
 * SearchSettingsChanged.java - Search and replace settings changed message
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
/**
 * Message sent when search and replace settings change.
 * @author Slava Pestov
 * @version $Id: SearchSettingsChanged.java,v 1.1 1999/12/20 06:14:57 sp Exp $
 *
 * @since jEdit 2.3pre1
 */
public class SearchSettingsChanged extends EBMessage.NonVetoable
{
	/**
	 * Creates a new search and replace settings changed message.
	 * @param source The message source
	 */
	public SearchSettingsChanged(EBComponent source)
	{
		super(source);
	}
}
"
org.gjt.sp.jedit.msg.VFSUpdate,"/*
 * VFSUpdate.java - A path has changed
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.*;
/**
 * Message sent when a file or directory changes.
 * @author Slava Pestov
 * @version $Id: VFSUpdate.java,v 1.1 2000/08/20 07:29:31 sp Exp $
 *
 * @since jEdit 2.6pre4
 */
public class VFSUpdate extends EBMessage
{
	/**
	 * Creates a VFS update message.
	 * @param path The path in question
	 */
	public VFSUpdate(String path)
	{
		super(null);
		if(path == null)
			throw new NullPointerException(""Path must be non-null"");
		this.path = path;
	}
	/**
	 * Returns the path that changed.
	 */
	public String getPath()
	{
		return path;
	}
	public String paramString()
	{
		return super.paramString() + "",path="" + path;
	}
	// private members
	private String path;
}
/*
 * Change Log:
 * $Log: VFSUpdate.java,v $
 * Revision 1.1  2000/08/20 07:29:31  sp
 * I/O and VFS browser improvements
 *
 */
"
org.gjt.sp.jedit.msg.ViewUpdate,"/*
 * ViewUpdate.java - View update message
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.msg;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;
/**
 * Message sent when a view-related change occurs.
 * @author Slava Pestov
 * @version $Id: ViewUpdate.java,v 1.4 2000/05/07 05:48:30 sp Exp $
 *
 * @since jEdit 2.2pre6
 */
public class ViewUpdate extends EBMessage.NonVetoable
{
	/**
	 * View created.
	 */
	public static final Object CREATED = ""CREATED"";
	/**
	 * View closed.
	 */
	public static final Object CLOSED = ""CLOSED"";
	/**
	 * Creates a new view update message.
	 * @param view The view
	 * @param what What happened
	 */
	public ViewUpdate(View view, Object what)
	{
		super(view);
		if(what == null)
			throw new NullPointerException(""What must be non-null"");
		this.what = what;
	}
	/**
	 * Returns what caused this view update.
	 */
	public Object getWhat()
	{
		return what;
	}
	/**
	 * Returns the view involved.
	 */
	public View getView()
	{
		return (View)getSource();
	}
	public String paramString()
	{
		return super.paramString() + "",what="" + what;
	}
	// private members
	private Object what;
}
"
org.gjt.sp.jedit.options.AbbrevsOptionPane,"/*
 * AbbrevsOptionPane.java - Abbrevs options panel
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.border.EmptyBorder;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.EditAbbrevDialog;
import org.gjt.sp.jedit.*;
/**
 * Abbrev editor.
 * @author Slava Pestov
 * @version $Id: AbbrevsOptionPane.java,v 1.10 2001/02/05 09:15:30 sp Exp $
 */
public class AbbrevsOptionPane extends AbstractOptionPane
{
	public AbbrevsOptionPane()
	{
		super(""abbrevs"");
	}
	// protected members
	protected void _init()
	{
		setLayout(new BorderLayout());
		JPanel panel = new JPanel(new BorderLayout());
		JPanel panel2 = new JPanel();
		panel2.setLayout(new BoxLayout(panel2,BoxLayout.X_AXIS));
		panel2.setBorder(new EmptyBorder(0,0,6,0));
		panel2.add(Box.createGlue());
		expandOnInput = new JCheckBox(jEdit.getProperty(""options.abbrevs""
			+ "".expandOnInput""),Abbrevs.getExpandOnInput());
		panel2.add(expandOnInput);
		panel2.add(Box.createGlue());
		panel.add(panel2,BorderLayout.NORTH);
		JPanel panel3 = new JPanel();
		JLabel label = new JLabel(jEdit.getProperty(""options.abbrevs.set""));
		label.setBorder(new EmptyBorder(0,0,0,12));
		panel3.add(label);
		Hashtable _modeAbbrevs = Abbrevs.getModeAbbrevs();
		modeAbbrevs = new Hashtable();
		Mode[] modes = jEdit.getModes();
		String[] sets = new String[modes.length + 1];
		sets[0] = ""global"";
		for(int i = 0; i < modes.length; i++)
		{
			String name = modes[i].getName();
			sets[i+1] = name;
			modeAbbrevs.put(name,new AbbrevsModel((Hashtable)_modeAbbrevs.get(name)));
		}
		setsComboBox = new JComboBox(sets);
		setsComboBox.addActionListener(new ActionHandler());
		panel3.add(setsComboBox);
		panel.add(panel3,BorderLayout.SOUTH);
		add(BorderLayout.NORTH,panel);
		globalAbbrevs = new AbbrevsModel(Abbrevs.getGlobalAbbrevs());
		abbrevsTable = new JTable(globalAbbrevs);
		abbrevsTable.getTableHeader().setReorderingAllowed(false);
		abbrevsTable.getTableHeader().addMouseListener(new HeaderMouseHandler());
		abbrevsTable.addMouseListener(new TableMouseHandler());
		Dimension d = abbrevsTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(abbrevsTable);
		scroller.setPreferredSize(d);
		add(BorderLayout.CENTER,scroller);
	}
	protected void _save()
	{
		if(abbrevsTable.getCellEditor() != null)
			abbrevsTable.getCellEditor().stopCellEditing();
		Abbrevs.setExpandOnInput(expandOnInput.isSelected());
		Abbrevs.setGlobalAbbrevs(globalAbbrevs.toHashtable());
		Hashtable modeHash = new Hashtable();
		Enumeration keys = modeAbbrevs.keys();
		Enumeration values = modeAbbrevs.elements();
		while(keys.hasMoreElements())
		{
			modeHash.put(keys.nextElement(),((AbbrevsModel)values.nextElement())
				.toHashtable());
		}
		Abbrevs.setModeAbbrevs(modeHash);
	}
	// private members
	private JComboBox setsComboBox;
	private JCheckBox expandOnInput;
	private JTable abbrevsTable;
	private AbbrevsModel globalAbbrevs;
	private Hashtable modeAbbrevs;
	class HeaderMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			switch(abbrevsTable.getTableHeader().columnAtPoint(evt.getPoint()))
			{
			case 0:
				((AbbrevsModel)abbrevsTable.getModel()).sort(0);
				break;
			case 1:
				((AbbrevsModel)abbrevsTable.getModel()).sort(1);
				break;
			}
		}
	}
	class TableMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			if(abbrevsTable.getSelectedColumn() == 1)
			{
				TableModel abbrevsModel = abbrevsTable.getModel();
				int row = abbrevsTable.getSelectedRow();
				String abbrev = (String)abbrevsModel.getValueAt(row,0);
				String expansion = (String)abbrevsModel.getValueAt(row,1);
				expansion = new EditAbbrevDialog(AbbrevsOptionPane.this,
					abbrev,expansion).getExpansion();
				if(expansion != null)
					abbrevsModel.setValueAt(expansion,row,1);
			}
		}
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == setsComboBox)
			{
				String selected = (String)setsComboBox.getSelectedItem();
				if(selected.equals(""global""))
				{
					abbrevsTable.setModel(globalAbbrevs);
				}
				else
				{
					abbrevsTable.setModel((AbbrevsModel)
						modeAbbrevs.get(selected));
				}
			}
		}
	}
}
class AbbrevsModel extends AbstractTableModel
{
	Vector abbrevs;
	AbbrevsModel()
	{
		abbrevs = new Vector();
	}
	AbbrevsModel(Hashtable abbrevHash)
	{
		this();
		if(abbrevHash != null)
		{
			Enumeration abbrevEnum = abbrevHash.keys();
			Enumeration expandEnum = abbrevHash.elements();
			while(abbrevEnum.hasMoreElements())
			{
				abbrevs.addElement(new Abbrev((String)abbrevEnum.nextElement(),
					(String)expandEnum.nextElement()));
			}
			sort(0);
		}
	}
	public void sort(int col)
	{
		MiscUtilities.quicksort(abbrevs,new AbbrevCompare(col));
		fireTableDataChanged();
	}
	public Hashtable toHashtable()
	{
		Hashtable hash = new Hashtable();
		for(int i = 0; i < abbrevs.size(); i++)
		{
			Abbrev abbrev = (Abbrev)abbrevs.elementAt(i);
			if(abbrev.abbrev.length() > 0
				&& abbrev.expand.length() > 0)
			{
				hash.put(abbrev.abbrev,abbrev.expand);
			}
		}
		return hash;
	}
	public int getColumnCount()
	{
		return 2;
	}
	public int getRowCount()
	{
		return abbrevs.size() + 1;
	}
	public Object getValueAt(int row, int col)
	{
		if(row == abbrevs.size())
			return null;
		Abbrev abbrev = (Abbrev)abbrevs.elementAt(row);
		switch(col)
		{
		case 0:
			return abbrev.abbrev;
		case 1:
			return abbrev.expand;
		default:
			return null;
		}
	}
	public boolean isCellEditable(int row, int col)
	{
		return (col == 0);
	}
	public void setValueAt(Object value, int row, int col)
	{
		if(value == null)
			value = """";
		Abbrev abbrev;
		if(row == abbrevs.size())
		{
			abbrev = new Abbrev();
			abbrevs.addElement(abbrev);
		}
		else
			abbrev = (Abbrev)abbrevs.elementAt(row);
		if(col == 0)
			abbrev.abbrev = (String)value;
		else
			abbrev.expand = (String)value;
		fireTableRowsUpdated(row,row + 1);
	}
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.abbrevs.abbrev"");
		case 1:
			return jEdit.getProperty(""options.abbrevs.expand"");
		default:
			return null;
		}
	}
	class AbbrevCompare implements MiscUtilities.Compare
	{
		int col;
		AbbrevCompare(int col)
		{
			this.col = col;
		}
		public int compare(Object obj1, Object obj2)
		{
			Abbrev a1 = (Abbrev)obj1;
			Abbrev a2 = (Abbrev)obj2;
			if(col == 0)
			{
				String abbrev1 = a1.abbrev.toLowerCase();
				String abbrev2 = a2.abbrev.toLowerCase();
				return abbrev1.compareTo(abbrev2);
			}
			else
			{
				String expand1 = a1.expand.toLowerCase();
				String expand2 = a2.expand.toLowerCase();
				return expand1.compareTo(expand2);
			}
		}
	}
}
class Abbrev
{
	Abbrev() {}
	Abbrev(String abbrev, String expand)
	{
		this.abbrev = abbrev;
		this.expand = expand;
	}
	String abbrev;
	String expand;
}
"
org.gjt.sp.jedit.options.BrowserOptionPane,"/*
 * BrowserOptionPane.java - Browser options panel
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
public class BrowserOptionPane extends AbstractOptionPane
{
	public BrowserOptionPane()
	{
		super(""browser"");
	}
	public void _init()
	{
		/* Default directory */
		String[] dirs = {
			jEdit.getProperty(""options.browser.defaultPath.buffer""),
			jEdit.getProperty(""options.browser.defaultPath.home""),
			jEdit.getProperty(""options.browser.defaultPath.favorites""),
			jEdit.getProperty(""options.browser.defaultPath.last"")
		};
		defaultDirectory = new JComboBox(dirs);
		String defaultDir = jEdit.getProperty(""vfs.browser.defaultPath"");
		if(""buffer"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(0);
		else if(""home"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(1);
		else if(""favorites"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(2);
		else if(""last"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(3);
		addComponent(jEdit.getProperty(""options.browser.defaultPath""),
			defaultDirectory);
		/* Show icons */
		showIcons = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".showIcons""));
		showIcons.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showIcons""));
		addComponent(showIcons);
		/* Show hidden files */
		showHiddenFiles = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".showHiddenFiles""));
		showHiddenFiles.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showHiddenFiles""));
		addComponent(showHiddenFiles);
		/* Sort file list */
		sortFiles = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".sortFiles""));
		sortFiles.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortFiles""));
		addComponent(sortFiles);
		/* Ignore case when sorting */
		sortIgnoreCase = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".sortIgnoreCase""));
		sortIgnoreCase.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortIgnoreCase""));
		addComponent(sortIgnoreCase);
		/* Mix files and directories */
		sortMixFilesAndDirs = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".sortMixFilesAndDirs""));
		sortMixFilesAndDirs.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortMixFilesAndDirs""));
		addComponent(sortMixFilesAndDirs);
		/* Double-click close */
		doubleClickClose = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".doubleClickClose""));
		doubleClickClose.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".doubleClickClose""));
		addComponent(doubleClickClose);
		/* Base filter in open/save dialogs on current buffer name */
		currentBufferFilter = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".currentBufferFilter""));
		currentBufferFilter.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".currentBufferFilter""));
		addComponent(currentBufferFilter);
	}
	public void _save()
	{
		String[] dirs = { ""buffer"", ""home"", ""favorites"", ""last"" };
		jEdit.setProperty(""vfs.browser.defaultPath"",dirs[defaultDirectory
			.getSelectedIndex()]);
		jEdit.setBooleanProperty(""vfs.browser.showIcons"",
			showIcons.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.showHiddenFiles"",
			showHiddenFiles.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortFiles"",
			sortFiles.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortIgnoreCase"",
			sortIgnoreCase.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortMixFilesAndDirs"",
			sortMixFilesAndDirs.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.doubleClickClose"",
			doubleClickClose.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.currentBufferFilter"",
			currentBufferFilter.isSelected());
	}
	// private members
	private JComboBox defaultDirectory;
	private JCheckBox showIcons;
	private JCheckBox showHiddenFiles;
	private JCheckBox sortFiles;
	private JCheckBox sortIgnoreCase;
	private JCheckBox sortMixFilesAndDirs;
	private JCheckBox doubleClickClose;
	private JCheckBox currentBufferFilter;
}
"
org.gjt.sp.jedit.options.ColorOptionPane,"/*
 * ColorOptionPane.java - Color option pane
 * Copyright (C) 1999, 2000 Slava Pestov
 * Portions copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.plaf.metal.MetalLookAndFeel;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.jedit.*;
/**
 * Color option pane.
 * @author Slava Pestov
 * @version $Id: ColorOptionPane.java,v 1.4 2001/04/24 06:52:13 sp Exp $
 */
public class ColorOptionPane extends AbstractOptionPane
{
	public static final EmptyBorder noFocusBorder = new EmptyBorder(1,1,1,1);
	public ColorOptionPane()
	{
		super(""color"");
	}
	// protected members
	protected void _init()
	{
		setLayout(new BorderLayout());
		add(BorderLayout.CENTER,createColorTableScroller());
	}
	protected void _save()
	{
		colorModel.save();
	}
	// private members
	private ColorTableModel colorModel;
	private JTable colorTable;
	private JScrollPane createColorTableScroller()
	{
		colorModel = createColorTableModel();
		colorTable = new JTable(colorModel);
		colorTable.setRowSelectionAllowed(false);
		colorTable.setColumnSelectionAllowed(false);
		colorTable.setCellSelectionEnabled(false);
		colorTable.getTableHeader().setReorderingAllowed(false);
		colorTable.addMouseListener(new MouseHandler());
		TableColumnModel tcm = colorTable.getColumnModel();
 		TableColumn colorColumn = tcm.getColumn(1);
		colorColumn.setCellRenderer(new ColorTableModel.ColorRenderer());
		Dimension d = colorTable.getPreferredSize();
		d.height = Math.min(d.height,100);
		JScrollPane scroller = new JScrollPane(colorTable);
		scroller.setPreferredSize(d);
		return scroller;
	}
	private ColorTableModel createColorTableModel()
	{
		return new ColorTableModel();
	}
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			int row = colorTable.rowAtPoint(evt.getPoint());
			if(row == -1)
				return;
			Color color = JColorChooser.showDialog(
				ColorOptionPane.this,
				jEdit.getProperty(""colorChooser.title""),
				(Color)colorModel.getValueAt(row,1));
			if(color != null)
				colorModel.setValueAt(color,row,1);
		}
	}
}
class ColorTableModel extends AbstractTableModel
{
	private Vector colorChoices;
	ColorTableModel()
	{
		colorChoices = new Vector(16);
		addColorChoice(""options.color.bgColor"",""view.bgColor"");
		addColorChoice(""options.color.fgColor"",""view.fgColor"");
		addColorChoice(""options.color.caretColor"",""view.caretColor"");
		addColorChoice(""options.color.selectionColor"",
			""view.selectionColor"");
		addColorChoice(""options.color.lineHighlightColor"",
			""view.lineHighlightColor"");
		addColorChoice(""options.color.bracketHighlightColor"",
			""view.bracketHighlightColor"");
		addColorChoice(""options.color.eolMarkerColor"",
			""view.eolMarkerColor"");
		addColorChoice(""options.color.wrapGuideColor"",
			""view.wrapGuideColor"");
		addColorChoice(""options.color.gutterBgColor"",
			""view.gutter.bgColor"");
		addColorChoice(""options.color.gutterFgColor"",
			""view.gutter.fgColor"");
		addColorChoice(""options.color.gutterHighlightColor"",
			""view.gutter.highlightColor"");
		addColorChoice(""options.color.gutterCurrentLineColor"",
			""view.gutter.currentLineColor"");
		addColorChoice(""options.color.gutterMarkerColor"",
			""view.gutter.markerColor"");
		addColorChoice(""options.color.gutterFoldColor"",
			""view.gutter.foldColor"");
		addColorChoice(""options.color.gutterFocusBorderColor"",
			""view.gutter.focusBorderColor"");
		addColorChoice(""options.color.gutterNoFocusBorderColor"",
			""view.gutter.noFocusBorderColor"");
		if(!(UIManager.getLookAndFeel() instanceof MetalLookAndFeel))
		{
			addColorChoice(""options.color.dockingBorderColor"",
				""view.docking.borderColor"");
		}
	}
	public int getColumnCount()
	{
		return 2;
	}
	public int getRowCount()
	{
		return colorChoices.size();
	}
	public Object getValueAt(int row, int col)
	{
		ColorChoice ch = (ColorChoice)colorChoices.elementAt(row);
		switch(col)
		{
		case 0:
			return ch.label;
		case 1:
			return ch.color;
		default:
			return null;
		}
	}
	public void setValueAt(Object value, int row, int col)
	{
		ColorChoice ch = (ColorChoice)colorChoices.elementAt(row);
		if(col == 1)
			ch.color = (Color)value;
		fireTableRowsUpdated(row,row);
	}
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.color.object"");
		case 1:
			return jEdit.getProperty(""options.color.color"");
		default:
			return null;
		}
	}
	public void save()
	{
		for(int i = 0; i < colorChoices.size(); i++)
		{
			ColorChoice ch = (ColorChoice)colorChoices
				.elementAt(i);
			jEdit.setProperty(ch.property,
				GUIUtilities.getColorHexString(ch.color));
		}
	}
	private void addColorChoice(String label, String property)
	{
		colorChoices.addElement(new ColorChoice(jEdit.getProperty(label),
			property,GUIUtilities.parseColor(jEdit.getProperty(property))));
	}
	static class ColorChoice
	{
		String label;
		String property;
		Color color;
		ColorChoice(String label, String property, Color color)
		{
			this.label = label;
			this.property = property;
			this.color = color;
		}
	}
	static class ColorRenderer extends JLabel
		implements TableCellRenderer
	{
		public ColorRenderer()
		{
			setOpaque(true);
			setBorder(StyleOptionPane.noFocusBorder);
		}
		// TableCellRenderer implementation
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			if (isSelected)
			{
				setBackground(table.getSelectionBackground());
				setForeground(table.getSelectionForeground());
			}
			else
			{
				setBackground(table.getBackground());
				setForeground(table.getForeground());
			}
			if (value != null)
				setBackground((Color)value);
			setBorder((cellHasFocus) ? UIManager.getBorder(
				""Table.focusCellHighlightBorder"")
				: StyleOptionPane.noFocusBorder);
			return this;
		}
		// end TableCellRenderer implementation
	}
}
"
org.gjt.sp.jedit.options.ContextOptionPane,"/*
 * ContextOptionPane.java - Context menu options panel
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
/**
 * Right-click context menu editor.
 * @author Slava Pestov
 * @version $Id: ContextOptionPane.java,v 1.13 2001/03/26 07:09:20 sp Exp $
 */
public class ContextOptionPane extends AbstractOptionPane
{
	public ContextOptionPane()
	{
		super(""context"");
	}
	// protected members
	protected void _init()
	{
		setLayout(new BorderLayout());
		JLabel caption = new JLabel(jEdit.getProperty(
			""options.context.caption""));
		add(BorderLayout.NORTH,caption);
		String contextMenu = jEdit.getProperty(""view.context"");
		StringTokenizer st = new StringTokenizer(contextMenu);
		listModel = new DefaultListModel();
		while(st.hasMoreTokens())
		{
			String actionName = (String)st.nextToken();
			String label = getActionLabel(actionName);
			if(label == null)
				continue;
			listModel.addElement(new MenuItem(actionName,label));
		}
		list = new JList(listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		list.addListSelectionListener(new ListHandler());
		add(BorderLayout.CENTER,new JScrollPane(list));
		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.add(Box.createGlue());
		ActionHandler actionHandler = new ActionHandler();
		add = new JButton(jEdit.getProperty(""options.context.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new JButton(jEdit.getProperty(""options.context.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new JButton(jEdit.getProperty(""options.context.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new JButton(jEdit.getProperty(""options.context.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createGlue());
		updateButtons();
		add(BorderLayout.SOUTH,buttons);
		// create actions list
		EditAction[] actions = jEdit.getActions();
		Vector vector = new Vector(actions.length);
		for(int i = 0; i < actions.length; i++)
		{
			String actionName = actions[i].getName();
			String label = jEdit.getProperty(actionName + "".label"");
			if(label == null)
				continue;
			vector.addElement(new MenuItem(actionName,label));
		}
		MiscUtilities.quicksort(vector,new MenuItemCompare());
		actionsList = new DefaultListModel();
		actionsList.ensureCapacity(vector.size());
		for(int i = 0; i < vector.size(); i++)
		{
			actionsList.addElement(vector.elementAt(i));
		}
	}
	class MenuItemCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return ((MenuItem)obj1).label.toLowerCase().compareTo(
				((MenuItem)obj2).label.toLowerCase());
		}
	}
	protected void _save()
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < listModel.getSize(); i++)
		{
			if(i != 0)
				buf.append(' ');
			buf.append(((MenuItem)listModel.elementAt(i)).actionName);
		}
		jEdit.setProperty(""view.context"",buf.toString());
	}
	// package-private members
	static String getActionLabel(String actionName)
	{
		if(actionName.equals(""-""))
			return ""-"";
		else
		{
			if(actionName.startsWith(""play-macro@""))
			{
				int index = Math.max(11,actionName
					.indexOf('/') + 1);
				return actionName.substring(index)
					.replace('_',' ');
			}
			else
				return jEdit.getProperty(actionName + "".label"");
		}
	}
	// private members
	private DefaultListModel listModel;
	private JList list;
	private JButton add;
	private JButton remove;
	private JButton moveUp, moveDown;
	private DefaultListModel actionsList;
	private void updateButtons()
	{
		int index = list.getSelectedIndex();
		remove.setEnabled(index != -1 && listModel.getSize() != 0);
		moveUp.setEnabled(index > 0);
		moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);
	}
	static class MenuItem
	{
		String actionName;
		String label;
		MenuItem(String actionName, String label)
		{
			this.actionName = actionName;
			if(label.equals(""-""))
				this.label = label;
			else
				this.label = GUIUtilities.prettifyMenuLabel(label);
		}
		public String toString()
		{
			return label;
		}
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == add)
			{
				ContextAddDialog dialog = new ContextAddDialog(
					ContextOptionPane.this,
					actionsList);
				MenuItem selection = dialog.getSelection();
				if(selection == null)
					return;
				int index = list.getSelectedIndex();
				if(index == -1)
					index = listModel.getSize();
				else
					index++;
				listModel.insertElementAt(selection,index);
				list.setSelectedIndex(index);
			}
			else if(source == remove)
			{
				int index = list.getSelectedIndex();
				listModel.removeElementAt(index);
				updateButtons();
			}
			else if(source == moveUp)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index-1);
				list.setSelectedIndex(index-1);
			}
			else if(source == moveDown)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index+1);
				list.setSelectedIndex(index+1);
			}
		}
	}
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateButtons();
		}
	}
}
class ContextAddDialog extends EnhancedDialog
{
	public ContextAddDialog(Component comp, ListModel actionsListModel)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""options.context.add.title""),
			true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		content.add(BorderLayout.NORTH,new JLabel(
			jEdit.getProperty(""options.context.add.caption"")));
		JPanel mainPanel = new JPanel(new BorderLayout(6,0));
		ActionHandler actionHandler = new ActionHandler();
		ButtonGroup grp = new ButtonGroup();
		// Add separator
		separator = new JRadioButton(jEdit.getProperty(""options.context""
			+ "".add.separator""));
		separator.setSelected(true);
		separator.addActionListener(actionHandler);
		grp.add(separator);
		mainPanel.add(BorderLayout.NORTH,separator);
		// Add action
		JPanel actionPanel = new JPanel(new BorderLayout(6,0));
		action = new JRadioButton(jEdit.getProperty(""options.context""
			+ "".add.action""));
		action.addActionListener(actionHandler);
		grp.add(action);
		actionPanel.add(BorderLayout.NORTH,action);
		actionsList = new JList(actionsListModel);
		actionsList.setVisibleRowCount(8);
		actionsList.setEnabled(false);
		actionPanel.add(BorderLayout.CENTER,new JScrollPane(actionsList));
		mainPanel.add(BorderLayout.CENTER,actionPanel);
		// Add macro
		JPanel macroPanel = new JPanel(new BorderLayout(6,0));
		macro = new JRadioButton(jEdit.getProperty(""options.context""
			+ "".add.macro""));
		macro.addActionListener(actionHandler);
		grp.add(macro);
		macroPanel.add(BorderLayout.NORTH,macro);
		macrosList = new JList(Macros.getMacroList());
		macrosList.setVisibleRowCount(8);
		macrosList.setEnabled(false);
		macroPanel.add(BorderLayout.CENTER,new JScrollPane(macrosList));
		mainPanel.add(BorderLayout.SOUTH,macroPanel);
		content.add(BorderLayout.CENTER,mainPanel);
		JPanel southPanel = new JPanel();
		southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));
		southPanel.setBorder(new EmptyBorder(12,0,0,0));
		southPanel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionHandler);
		getRootPane().setDefaultButton(ok);
		southPanel.add(ok);
		southPanel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionHandler);
		southPanel.add(cancel);
		southPanel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,southPanel);
		pack();
		setLocationRelativeTo(JOptionPane.getFrameForComponent(comp));
		show();
	}
	public void ok()
	{
		isOK = true;
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	public ContextOptionPane.MenuItem getSelection()
	{
		if(!isOK)
			return null;
		if(separator.isSelected())
			return new ContextOptionPane.MenuItem(""-"",""-"");
		else if(action.isSelected())
			return (ContextOptionPane.MenuItem)actionsList.getSelectedValue();
		else if(macro.isSelected())
		{
			String selectedMacro = macrosList.getSelectedValue().toString();
			selectedMacro = ""play-macro@"" + selectedMacro;
			return new ContextOptionPane.MenuItem(selectedMacro,
				ContextOptionPane.getActionLabel(selectedMacro));
		}
		else
			throw new InternalError();
	}
	// private members
	private boolean isOK;
	private JRadioButton separator, action, macro;
	private JList actionsList, macrosList;
	private JButton ok, cancel;
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source instanceof JRadioButton)
			{
				actionsList.setEnabled(action.isSelected());
				macrosList.setEnabled(macro.isSelected());
			}
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
		}
	}
}
"
org.gjt.sp.jedit.options.DockingOptionPane,"/*
 * DockingOptionPane.java - Dockable window options panel
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
public class DockingOptionPane extends AbstractOptionPane
{
	public DockingOptionPane()
	{
		super(""docking"");
	}
	public void _init()
	{
		Box box = new Box(BoxLayout.X_AXIS);
		ButtonGroup grp = new ButtonGroup();
		layout1 = new JToggleButton(GUIUtilities.loadIcon(""dock_layout1.gif""));
		grp.add(layout1);
		box.add(layout1);
		box.add(Box.createHorizontalStrut(6));
		layout2 = new JToggleButton(GUIUtilities.loadIcon(""dock_layout2.gif""));
		grp.add(layout2);
		box.add(layout2);
		if(jEdit.getBooleanProperty(""view.docking.alternateLayout""))
			layout2.setSelected(true);
		else
			layout1.setSelected(true);
		addComponent(jEdit.getProperty(""options.docking.layout""),box);
		// reuse properties defined by the general option pane
		String[] positions = {
			jEdit.getProperty(""options.docking.top""),
			jEdit.getProperty(""options.docking.bottom""),
		};
		tabsPos = new JComboBox(positions);
		tabsPos.setSelectedIndex(Integer.parseInt(jEdit.getProperty(
			""view.docking.tabsPos"")));
		addComponent(jEdit.getProperty(""options.docking.tabsPos""),tabsPos);
		addComponent(Box.createVerticalStrut(6));
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = 3;
		cons.gridwidth = cons.gridheight = GridBagConstraints.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = cons.weighty = 1.0f;
		JScrollPane windowScroller = createWindowTableScroller();
		gridBag.setConstraints(windowScroller,cons);
		add(windowScroller);
	}
	public void _save()
	{
		jEdit.setBooleanProperty(""view.docking.alternateLayout"",
			layout2.isSelected());
		jEdit.setProperty(""view.docking.tabsPos"",String.valueOf(
			tabsPos.getSelectedIndex()));
		windowModel.save();
	}
	// private members
	private JToggleButton layout1;
	private JToggleButton layout2;
	private JComboBox tabsPos;
	private JTable windowTable;
	private WindowTableModel windowModel;
	private JScrollPane createWindowTableScroller()
	{
		windowModel = createWindowModel();
		windowTable = new JTable(windowModel);
		windowTable.getTableHeader().setReorderingAllowed(false);
		windowTable.setColumnSelectionAllowed(false);
		windowTable.setRowSelectionAllowed(false);
		windowTable.setCellSelectionEnabled(false);
		DockPositionCellRenderer comboBox = new DockPositionCellRenderer();
		comboBox.setRequestFocusEnabled(false);
		windowTable.setRowHeight(comboBox.getPreferredSize().height);
		TableColumn column = windowTable.getColumnModel().getColumn(1);
		column.setCellRenderer(comboBox);
		comboBox = new DockPositionCellRenderer();
		comboBox.setRequestFocusEnabled(false);
		column.setCellEditor(new DefaultCellEditor(comboBox));
		Dimension d = windowTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(windowTable);
		scroller.setPreferredSize(d);
		return scroller;
	}
	private WindowTableModel createWindowModel()
	{
		return new WindowTableModel();
	}
	class DockPositionCellRenderer extends JComboBox
		implements TableCellRenderer
	{
		DockPositionCellRenderer()
		{
			super(new String[] {
				DockableWindowManager.FLOATING,
				DockableWindowManager.TOP,
				DockableWindowManager.LEFT,
				DockableWindowManager.BOTTOM,
				DockableWindowManager.RIGHT
			});
		}
		public Component getTableCellRendererComponent(JTable table,
			Object value, boolean isSelected, boolean hasFocus,
			int row, int column)
		{
			setSelectedItem(value);
			return this;
		}
	}
}
class WindowTableModel extends AbstractTableModel
{
	private Vector windows;
	WindowTableModel()
	{
		Object[] list = EditBus.getNamedList(DockableWindow.DOCKABLE_WINDOW_LIST);
		windows = new Vector(list.length);
		for(int i = 0; i < list.length; i++)
		{
			windows.addElement(new Entry((String)list[i]));
		}
		sort();
	}
	public void sort()
	{
		MiscUtilities.quicksort(windows,new WindowCompare());
		fireTableDataChanged();
	}
	public int getColumnCount()
	{
		return 3;
	}
	public int getRowCount()
	{
		return windows.size();
	}
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
		case 1:
			return String.class;
		case 2:
			return Boolean.class;
		default:
			throw new InternalError();
		}
	}
	public Object getValueAt(int row, int col)
	{
		Entry window = (Entry)windows.elementAt(row);
		switch(col)
		{
		case 0:
			return window.title;
		case 1:
			return window.dockPosition;
		case 2:
			return new Boolean(window.autoOpen);
		default:
			throw new InternalError();
		}
	}
	public boolean isCellEditable(int row, int col)
	{
		return (col != 0);
	}
	public void setValueAt(Object value, int row, int col)
	{
		if(col == 0)
			return;
		Entry window = (Entry)windows.elementAt(row);
		switch(col)
		{
		case 1:
			window.dockPosition = (String)value;
			break;
		case 2:
			window.autoOpen = ((Boolean)value).booleanValue();
			break;
		default:
			throw new InternalError();
		}
		fireTableRowsUpdated(row,row);
	}
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.docking.title"");
		case 1:
			return jEdit.getProperty(""options.docking.dockPosition"");
		case 2:
			return jEdit.getProperty(""options.docking.autoOpen"");
		default:
			throw new InternalError();
		}
	}
	public void save()
	{
		for(int i = 0; i < windows.size(); i++)
		{
			((Entry)windows.elementAt(i)).save();
		}
	}
	class Entry
	{
		String name;
		String title;
		String dockPosition;
		boolean autoOpen;
		Entry(String name)
		{
			this.name = name;
			title = jEdit.getProperty(name + "".title"");
			if(title == null)
				title = name;
			dockPosition = jEdit.getProperty(name + "".dock-position"");
			if(dockPosition == null)
				dockPosition = DockableWindowManager.FLOATING;
			autoOpen = jEdit.getBooleanProperty(name + "".auto-open"");
		}
		void save()
		{
			jEdit.setProperty(name + "".dock-position"",dockPosition);
			jEdit.setBooleanProperty(name + "".auto-open"",autoOpen);
		}
	}
	class WindowCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			Entry e1 = (Entry)obj1;
			Entry e2 = (Entry)obj2;
			return e1.title.compareTo(e2.title);
		}
	}
}
/*
 * Change Log:
 * $Log: DockingOptionPane.java,v $
 * Revision 1.4  2001/07/24 08:15:44  sp
 * plugin guide updated
 *
 * Revision 1.3  2000/10/30 07:14:04  sp
 * 2.7pre1 branched, GUI improvements
 *
 * Revision 1.2  2000/09/23 03:01:11  sp
 * pre7 yayayay
 *
 * Revision 1.1  2000/08/17 08:04:10  sp
 * Marker loading bug fixed, docking option pane
 *
 */
"
org.gjt.sp.jedit.options.EditingOptionPane,"/*
 * EditingOptionPane.java - Editing options panel
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
public class EditingOptionPane extends AbstractOptionPane
{
	public EditingOptionPane()
	{
		super(""editing"");
	}
	// protected members
	protected void _init()
	{
		/* Modes */
		Mode[] modes = jEdit.getModes();
		String defaultModeString = jEdit.getProperty(""buffer.defaultMode"");
		String[] modeNames = new String[modes.length];
		int index = 0;
		for(int i = 0; i < modes.length; i++)
		{
			Mode _mode = modes[i];
			modeNames[i] = _mode.getName();
			if(defaultModeString.equals(_mode.getName()))
				index = i;
		}
		defaultMode = new JComboBox(modeNames);
		defaultMode.setSelectedIndex(index);
		addComponent(jEdit.getProperty(""options.editing.defaultMode""),
			defaultMode);
		/* Tab size */
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		defaultTabSize = new JComboBox(tabSizes);
		defaultTabSize.setEditable(true);
		defaultTabSize.setSelectedItem(jEdit.getProperty(""buffer.tabSize""));
		addComponent(jEdit.getProperty(""options.editing.tabSize""),defaultTabSize);
		/* Indent size */
		defaultIndentSize = new JComboBox(tabSizes);
		defaultIndentSize.setEditable(true);
		defaultIndentSize.setSelectedItem(jEdit.getProperty(""buffer.indentSize""));
		addComponent(jEdit.getProperty(""options.editing.indentSize""),defaultIndentSize);
		/* Max line length */
		String[] lineLens = { ""0"", ""72"", ""76"", ""80"" };
		defaultMaxLineLen = new JComboBox(lineLens);
		defaultMaxLineLen.setEditable(true);
		defaultMaxLineLen.setSelectedItem(jEdit.getProperty(""buffer.maxLineLen""));
		addComponent(jEdit.getProperty(""options.editing.maxLineLen""),defaultMaxLineLen);
		/* Word break chars */
		defaultWordBreakChars = new JTextField(jEdit.getProperty(""buffer.wordBreakChars""));
		addComponent(jEdit.getProperty(""options.editing.wordBreakChars""),defaultWordBreakChars);
		/* Word break chars */
		defaultCollapseFolds = new JTextField(jEdit.getProperty(""buffer.collapseFolds""));
		addComponent(jEdit.getProperty(""options.editing.collapseFolds""),defaultCollapseFolds);
		/* Undo queue size */
		undoCount = new JTextField(jEdit.getProperty(""buffer.undoCount""));
		addComponent(jEdit.getProperty(""options.editing.undoCount""),undoCount);
		/* Syntax highlighting */
		defaultSyntax = new JCheckBox(jEdit.getProperty(""options.editing""
			+ "".syntax""));
		defaultSyntax.setSelected(jEdit.getBooleanProperty(""buffer.syntax""));
		addComponent(defaultSyntax);
		/* Indent on tab */
		defaultIndentOnTab = new JCheckBox(jEdit.getProperty(""options.editing""
			+ "".indentOnTab""));
		defaultIndentOnTab.setSelected(jEdit.getBooleanProperty(""buffer.indentOnTab""));
		addComponent(defaultIndentOnTab);
		/* Indent on enter */
		defaultIndentOnEnter = new JCheckBox(jEdit.getProperty(""options.editing""
			+ "".indentOnEnter""));
		defaultIndentOnEnter.setSelected(jEdit.getBooleanProperty(""buffer.indentOnEnter""));
		addComponent(defaultIndentOnEnter);
		/* Soft tabs */
		defaultNoTabs = new JCheckBox(jEdit.getProperty(""options.editing""
			+ "".noTabs""));
		defaultNoTabs.setSelected(jEdit.getBooleanProperty(""buffer.noTabs""));
		addComponent(defaultNoTabs);
	}
	protected void _save()
	{
		jEdit.setProperty(""buffer.defaultMode"",
			(String)defaultMode.getSelectedItem());
		jEdit.setProperty(""buffer.tabSize"",(String)defaultTabSize
			.getSelectedItem());
		jEdit.setProperty(""buffer.indentSize"",(String)defaultIndentSize
			.getSelectedItem());
		jEdit.setProperty(""buffer.maxLineLen"",(String)defaultMaxLineLen.getSelectedItem());
		jEdit.setProperty(""buffer.wordBreakChars"",defaultWordBreakChars.getText());
		jEdit.setProperty(""buffer.collapseFolds"",defaultCollapseFolds.getText());
		jEdit.setProperty(""buffer.undoCount"",undoCount.getText());
		jEdit.setBooleanProperty(""buffer.syntax"",defaultSyntax.isSelected());
		jEdit.setBooleanProperty(""buffer.indentOnTab"",defaultIndentOnTab
			.isSelected());
		jEdit.setBooleanProperty(""buffer.indentOnEnter"",defaultIndentOnEnter
			.isSelected());
		jEdit.setBooleanProperty(""buffer.noTabs"",defaultNoTabs.isSelected());
	}
	// private members
	private JComboBox defaultMode;
	private JComboBox defaultTabSize;
	private JComboBox defaultIndentSize;
	private JComboBox defaultMaxLineLen;
	private JTextField defaultWordBreakChars;
	private JTextField defaultCollapseFolds;
	private JTextField undoCount;
	private JCheckBox defaultSyntax;
	private JCheckBox defaultIndentOnTab;
	private JCheckBox defaultIndentOnEnter;
	private JCheckBox defaultNoTabs;
}
"
org.gjt.sp.jedit.options.GeneralOptionPane,"/*
 * GeneralOptionPane.java - General options panel
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.*;
import java.awt.*;
import java.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
public class GeneralOptionPane extends AbstractOptionPane
{
	public GeneralOptionPane()
	{
		super(""general"");
	}
	// protected members
	protected void _init()
	{
		/* Look and feel */
		addComponent(new JLabel(jEdit.getProperty(""options.general.lf.note"")));
		lfs = UIManager.getInstalledLookAndFeels();
		String[] names = new String[lfs.length];
		String lf = UIManager.getLookAndFeel().getClass().getName();
		int index = 0;
		for(int i = 0; i < names.length; i++)
		{
			names[i] = lfs[i].getName();
			if(lf.equals(lfs[i].getClassName()))
				index = i;
		}
		lookAndFeel = new JComboBox(names);
		lookAndFeel.setSelectedIndex(index);
		addComponent(jEdit.getProperty(""options.general.lf""),
			lookAndFeel);
		/* History count */
		history = new JTextField(jEdit.getProperty(""history""));
		addComponent(jEdit.getProperty(""options.general.history""),history);
		/* Save caret positions */
		saveCaret = new JCheckBox(jEdit.getProperty(
			""options.general.saveCaret""));
		saveCaret.setSelected(jEdit.getBooleanProperty(""saveCaret""));
		addComponent(saveCaret);
		/* Sort buffers */
		sortBuffers = new JCheckBox(jEdit.getProperty(
			""options.general.sortBuffers""));
		sortBuffers.setSelected(jEdit.getBooleanProperty(""sortBuffers""));
		addComponent(sortBuffers);
		/* Sort buffers by names */
		sortByName = new JCheckBox(jEdit.getProperty(
			""options.general.sortByName""));
		sortByName.setSelected(jEdit.getBooleanProperty(""sortByName""));
		addComponent(sortByName);
		/* Check mod status on focus */
		checkModStatus = new JCheckBox(jEdit.getProperty(
			""options.general.checkModStatus""));
		checkModStatus.setSelected(jEdit.getBooleanProperty(
			""view.checkModStatus""));
		addComponent(checkModStatus);
		/* Show full path */
		showFullPath = new JCheckBox(jEdit.getProperty(
			""options.general.showFullPath""));
		showFullPath.setSelected(jEdit.getBooleanProperty(
			""view.showFullPath""));
		addComponent(showFullPath);
		/* Show search bar */
		showSearchbar = new JCheckBox(jEdit.getProperty(
			""options.general.showSearchbar""));
		showSearchbar.setSelected(jEdit.getBooleanProperty(
			""view.showSearchbar""));
		addComponent(showSearchbar);
		/* Show buffer switcher */
		showBufferSwitcher = new JCheckBox(jEdit.getProperty(
			""options.general.showBufferSwitcher""));
		showBufferSwitcher.setSelected(jEdit.getBooleanProperty(
			""view.showBufferSwitcher""));
		addComponent(showBufferSwitcher);
		/* Show tip of the day */
		showTips = new JCheckBox(jEdit.getProperty(
			""options.general.showTips""));
		showTips.setSelected(jEdit.getBooleanProperty(""tip.show""));
		addComponent(showTips);
		/* Show splash screen */
		showSplash = new JCheckBox(jEdit.getProperty(
			""options.general.showSplash""));
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			showSplash.setSelected(true);
		else
			showSplash.setSelected(!new File(settingsDirectory,""nosplash"").exists());
		addComponent(showSplash);
		/* Global colors */
		globalColors = new JCheckBox(jEdit.getProperty(
			""options.general.globalColors""));
		globalColors.setSelected(jEdit.getBooleanProperty(""globalColors""));
		addComponent(globalColors);
	}
	protected void _save()
	{
		String lf = lfs[lookAndFeel.getSelectedIndex()].getClassName();
		jEdit.setProperty(""lookAndFeel"",lf);
		jEdit.setProperty(""history"",history.getText());
		jEdit.setBooleanProperty(""saveCaret"",saveCaret.isSelected());
		jEdit.setBooleanProperty(""sortBuffers"",sortBuffers.isSelected());
		jEdit.setBooleanProperty(""sortByName"",sortByName.isSelected());
		jEdit.setBooleanProperty(""view.checkModStatus"",checkModStatus
			.isSelected());
		jEdit.setBooleanProperty(""view.showFullPath"",showFullPath
			.isSelected());
		jEdit.setBooleanProperty(""view.showSearchbar"",showSearchbar
			.isSelected());
		jEdit.setBooleanProperty(""view.showBufferSwitcher"",
			showBufferSwitcher.isSelected());
		jEdit.setBooleanProperty(""tip.show"",showTips.isSelected());
		// this is handled a little differently from other jEdit settings
		// as the splash screen flag needs to be known very early in the
		// startup sequence, before the user properties have been loaded
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			File file = new File(settingsDirectory,""nosplash"");
			if(showSplash.isSelected())
				file.delete();
			else
			{
				try
				{
					FileOutputStream out = new FileOutputStream(file);
					out.write('\n');
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,this,io);
				}
			}
		}
		jEdit.setBooleanProperty(""globalColors"",globalColors.isSelected());
	}
	// private members
	private UIManager.LookAndFeelInfo[] lfs;
	private JComboBox lookAndFeel;
	private JTextField history;
	private JCheckBox saveCaret;
	private JCheckBox sortBuffers;
	private JCheckBox sortByName;
	private JCheckBox checkModStatus;
	private JCheckBox showFullPath;
	private JCheckBox showSearchbar;
	private JCheckBox showBufferSwitcher;
	private JCheckBox showTips;
	private JCheckBox showSplash;
	private JCheckBox globalColors;
}
"
org.gjt.sp.jedit.options.GutterOptionPane,"/*
 * GutterOptionPane.java - Gutter options panel
 * Copyright (C) 2000 mike dillon
 * Portions copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;
public class GutterOptionPane extends AbstractOptionPane
{
	public GutterOptionPane()
	{
		super(""gutter"");
	}
	public void _init()
	{
		lineNumbersEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.lineNumbers""));
		lineNumbersEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.lineNumbers""));
		addComponent(lineNumbersEnabled);
		/* Font */
		String _fontFamily = jEdit.getProperty(""view.gutter.font"");
		int _fontStyle;
		try
		{
			_fontStyle = Integer.parseInt(jEdit.getProperty(""view.gutter.fontstyle""));
		}
		catch(NumberFormatException nf)
		{
			_fontStyle = Font.PLAIN;
		}
		int _fontSize;
		try
		{
			_fontSize = Integer.parseInt(jEdit.getProperty(""view.gutter.fontsize""));
		}
		catch(NumberFormatException nf)
		{
			_fontSize = 14;
		}
		gutterFont = new FontSelector(new Font(_fontFamily,_fontStyle,_fontSize));
		addComponent(jEdit.getProperty(""options.gutter.font""),gutterFont);
		gutterBorderWidth = new JTextField(jEdit.getProperty(
			""view.gutter.borderWidth""));
		addComponent(jEdit.getProperty(""options.gutter.borderWidth""),
			gutterBorderWidth);
		gutterHighlightInterval = new JTextField(jEdit.getProperty(
			""view.gutter.highlightInterval""));
		addComponent(jEdit.getProperty(""options.gutter.interval""),
			gutterHighlightInterval);
		String[] alignments = new String[] {
			""Left"", ""Center"", ""Right""
		};
		gutterNumberAlignment = new JComboBox(alignments);
		String alignment = jEdit.getProperty(""view.gutter.numberAlignment"");
		if(""right"".equals(alignment))
			gutterNumberAlignment.setSelectedIndex(2);
		else if(""center"".equals(alignment))
			gutterNumberAlignment.setSelectedIndex(1);
		else
			gutterNumberAlignment.setSelectedIndex(0);
		addComponent(jEdit.getProperty(""options.gutter.numberAlignment""),
			gutterNumberAlignment);
		gutterCurrentLineHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.currentLineHighlight""));
		gutterCurrentLineHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.highlightCurrentLine""));
		addComponent(gutterCurrentLineHighlightEnabled);
		gutterMarkerHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.markerHighlight""));
		gutterMarkerHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.markerHighlight""));
		addComponent(gutterMarkerHighlightEnabled);
	}
	public void _save()
	{
		Font _font = gutterFont.getFont();
		jEdit.setProperty(""view.gutter.font"",_font.getFamily());
		jEdit.setProperty(""view.gutter.fontsize"",String.valueOf(_font.getSize()));
		jEdit.setProperty(""view.gutter.fontstyle"",String.valueOf(_font.getStyle()));
		jEdit.setProperty(""view.gutter.borderWidth"",
			gutterBorderWidth.getText());
		jEdit.setProperty(""view.gutter.highlightInterval"",
			gutterHighlightInterval.getText());
		String alignment = null;
		switch(gutterNumberAlignment.getSelectedIndex())
		{
		case 2:
			alignment = ""right"";
			break;
		case 1:
			alignment = ""center"";
			break;
		case 0: default:
			alignment = ""left"";
		}
		jEdit.setProperty(""view.gutter.numberAlignment"", alignment);
		jEdit.setBooleanProperty(""view.gutter.lineNumbers"", lineNumbersEnabled
			.isSelected());
		jEdit.setBooleanProperty(""view.gutter.highlightCurrentLine"",
			gutterCurrentLineHighlightEnabled.isSelected());
		jEdit.setBooleanProperty(""view.gutter.markerHighlight"",
			gutterMarkerHighlightEnabled.isSelected());
	}
	// private members
	private FontSelector gutterFont;
	private JTextField gutterBorderWidth;
	private JTextField gutterHighlightInterval;
	private JComboBox gutterNumberAlignment;
	private JCheckBox lineNumbersEnabled;
	private JCheckBox gutterCurrentLineHighlightEnabled;
	private JCheckBox gutterMarkerHighlightEnabled;
}
"
org.gjt.sp.jedit.options.LoadSaveOptionPane,"/*
 * LoadSaveOptionPane.java - Loading and saving options panel
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;
public class LoadSaveOptionPane extends AbstractOptionPane
{
	public LoadSaveOptionPane()
	{
		super(""loadsave"");
	}
	public void _init()
	{
		/* Autosave interval */
		autosave = new JTextField(jEdit.getProperty(""autosave""));
		addComponent(jEdit.getProperty(""options.loadsave.autosave""),autosave);
		/* Backup count */
		backups = new JTextField(jEdit.getProperty(""backups""));
		addComponent(jEdit.getProperty(""options.loadsave.backups""),backups);
		/* Backup directory */
		backupDirectory = new JTextField(jEdit.getProperty(
			""backup.directory""));
		addComponent(jEdit.getProperty(""options.loadsave.backupDirectory""),
			backupDirectory);
		/* Backup filename prefix */
		backupPrefix = new JTextField(jEdit.getProperty(""backup.prefix""));
		addComponent(jEdit.getProperty(""options.loadsave.backupPrefix""),
			backupPrefix);
		/* Backup suffix */
		backupSuffix = new JTextField(jEdit.getProperty(
			""backup.suffix""));
		addComponent(jEdit.getProperty(""options.loadsave.backupSuffix""),
			backupSuffix);
		/* Line separator */
		String[] lineSeps = { jEdit.getProperty(""lineSep.unix""),
			jEdit.getProperty(""lineSep.windows""),
			jEdit.getProperty(""lineSep.mac"") };
		lineSeparator = new JComboBox(lineSeps);
		String lineSep = jEdit.getProperty(""buffer.lineSeparator"",
			System.getProperty(""line.separator""));
		if(""\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(0);
		else if(""\r\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(1);
		else if(""\r"".equals(lineSep))
			lineSeparator.setSelectedIndex(2);
		addComponent(jEdit.getProperty(""options.loadsave.lineSeparator""),
			lineSeparator);
		/* Default file encoding */
		DefaultComboBoxModel encodings = new DefaultComboBoxModel();
		StringTokenizer st = new StringTokenizer(jEdit.getProperty(""encodings""));
		while(st.hasMoreTokens())
		{
			encodings.addElement(st.nextToken());
		}
		encoding = new JComboBox(encodings);
		encoding.setEditable(true);
		encoding.setSelectedItem(jEdit.getProperty(""buffer.encoding"",
			System.getProperty(""file.encoding"")));
		addComponent(jEdit.getProperty(""options.loadsave.encoding""),encoding);
		/* Number of I/O threads to start */
		ioThreadCount = new JTextField(jEdit.getProperty(""ioThreadCount""));
		addComponent(jEdit.getProperty(""options.loadsave.ioThreadCount""),
			ioThreadCount);
		/* Session management */
		restore = new JCheckBox(jEdit.getProperty(
			""options.loadsave.restore""));
		restore.setSelected(jEdit.getBooleanProperty(""restore""));
		restore.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				restoreCLI.setEnabled(restore.isSelected());
			}
		});
		addComponent(restore);
		restoreCLI = new JCheckBox(jEdit.getProperty(
			""options.loadsave.restore.cli""));
		restoreCLI.setSelected(jEdit.getBooleanProperty(""restore.cli""));
		restoreCLI.setEnabled(restore.isSelected());
		addComponent(restoreCLI);
		/* Clients open files in new view */
		newView = new JCheckBox(jEdit.getProperty(
			""options.loadsave.newView""));
		newView.setSelected(jEdit.getBooleanProperty(""client.newView""));
		addComponent(newView);
		/* Persistent markers */
		persistentMarkers = new JCheckBox(jEdit.getProperty(
			""options.loadsave.persistentMarkers""));
		persistentMarkers.setSelected(jEdit.getBooleanProperty(
			""persistentMarkers""));
		addComponent(persistentMarkers);
		/* Parse fully */
		parseFully = new JCheckBox(jEdit.getProperty(
			""options.loadsave.parseFully""));
		parseFully.setSelected(jEdit.getBooleanProperty(""parseFully""));
		addComponent(parseFully);
	}
	public void _save()
	{
		jEdit.setProperty(""autosave"",autosave.getText());
		jEdit.setProperty(""backups"",backups.getText());
		jEdit.setProperty(""backup.directory"",backupDirectory.getText());
		jEdit.setProperty(""backup.prefix"",backupPrefix.getText());
		jEdit.setProperty(""backup.suffix"",backupSuffix.getText());
		String lineSep = null;
		switch(lineSeparator.getSelectedIndex())
		{
		case 0:
			lineSep = ""\n"";
			break;
		case 1:
			lineSep = ""\r\n"";
			break;
		case 2:
			lineSep = ""\r"";
			break;
		}
		jEdit.setProperty(""buffer.lineSeparator"",lineSep);
		jEdit.setProperty(""buffer.encoding"",(String)
			encoding.getSelectedItem());
		jEdit.setProperty(""ioThreadCount"",ioThreadCount.getText());
		jEdit.setBooleanProperty(""restore"",restore.isSelected());
		jEdit.setBooleanProperty(""restore.cli"",restoreCLI.isSelected());
		jEdit.setBooleanProperty(""client.newView"",newView.isSelected());
		jEdit.setBooleanProperty(""persistentMarkers"",
			persistentMarkers.isSelected());
		jEdit.setBooleanProperty(""parseFully"",parseFully.isSelected());
	}
	// private members
	private JTextField autosave;
	private JTextField backups;
	private JTextField backupDirectory;
	private JTextField backupPrefix;
	private JTextField backupSuffix;
	private JComboBox lineSeparator;
	private JComboBox encoding;
	private JTextField ioThreadCount;
	private JCheckBox restore;
	private JCheckBox restoreCLI;
	private JCheckBox newView;
	private JCheckBox persistentMarkers;
	private JCheckBox parseFully;
}
"
org.gjt.sp.jedit.options.ModeOptionPane,"/*
 * ModeOptionPane.java - Mode-specific options panel
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
public class ModeOptionPane extends AbstractOptionPane
{
	public ModeOptionPane()
	{
		super(""mode"");
	}
	// protected members
	protected void _init()
	{
		Mode[] modes = jEdit.getModes();
		String[] modeNames = new String[modes.length];
		modeProps = new ModeProperties[modes.length];
		for(int i = 0; i < modes.length; i++)
		{
			modeProps[i] = new ModeProperties(modes[i]);
			modeNames[i] = modes[i].getName();
		}
		mode = new JComboBox(modeNames);
		mode.addActionListener(new ActionHandler());
		addComponent(jEdit.getProperty(""options.mode.mode""),mode);
		useDefaults = new JCheckBox(jEdit.getProperty(""options.mode.useDefaults""));
		useDefaults.addActionListener(new ActionHandler());
		addComponent(useDefaults);
		addComponent(jEdit.getProperty(""options.mode.filenameGlob""),
			filenameGlob = new JTextField());
		addComponent(jEdit.getProperty(""options.mode.firstlineGlob""),
			firstlineGlob = new JTextField());
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		addComponent(jEdit.getProperty(""options.editing.tabSize""),
			tabSize = new JComboBox(tabSizes));
		tabSize.setEditable(true);
		addComponent(jEdit.getProperty(""options.editing.indentSize""),
			indentSize = new JComboBox(tabSizes));
		indentSize.setEditable(true);
		String[] lineLens = { ""0"", ""72"", ""76"", ""80"" };
		addComponent(jEdit.getProperty(""options.editing.maxLineLen""),
			maxLineLen = new JComboBox(lineLens));
		maxLineLen.setEditable(true);
		addComponent(jEdit.getProperty(""options.editing.wordBreakChars""),
			wordBreakChars = new JTextField());
		addComponent(jEdit.getProperty(""options.mode.commentStart""),
			commentStart = new JTextField());
		addComponent(jEdit.getProperty(""options.mode.commentEnd""),
			commentEnd = new JTextField());
		addComponent(jEdit.getProperty(""options.mode.lineComment""),
			lineComment = new JTextField());
		addComponent(jEdit.getProperty(""options.mode.noWordSep""),
			noWordSep = new JTextField());
		addComponent(jEdit.getProperty(""options.editing.collapseFolds""),
			collapseFolds = new JTextField());
		addComponent(syntax = new JCheckBox(jEdit.getProperty(
			""options.editing.syntax"")));
		addComponent(indentOnTab = new JCheckBox(jEdit.getProperty(
			""options.editing.indentOnTab"")));
		addComponent(indentOnEnter = new JCheckBox(jEdit.getProperty(
			""options.editing.indentOnEnter"")));
		addComponent(noTabs = new JCheckBox(jEdit.getProperty(
			""options.editing.noTabs"")));
		selectMode();
	}
	protected void _save()
	{
		saveMode();
		for(int i = 0; i < modeProps.length; i++)
		{
			modeProps[i].save();
		}
	}
	// private members
	private ModeProperties[] modeProps;
	private ModeProperties current;
	private JComboBox mode;
	private JCheckBox useDefaults;
	private JTextField filenameGlob;
	private JTextField firstlineGlob;
	private JComboBox tabSize;
	private JComboBox indentSize;
	private JComboBox maxLineLen;
	private JTextField wordBreakChars;
	private JTextField commentStart;
	private JTextField commentEnd;
	private JTextField lineComment;
	private JTextField noWordSep;
	private JTextField collapseFolds;
	private JCheckBox noTabs;
	private JCheckBox indentOnTab;
	private JCheckBox indentOnEnter;
	private JCheckBox syntax;
	private void saveMode()
	{
		current.useDefaults = useDefaults.isSelected();
		current.filenameGlob = filenameGlob.getText();
		current.firstlineGlob = firstlineGlob.getText();
		current.tabSize = (String)tabSize.getSelectedItem();
		current.indentSize = (String)indentSize.getSelectedItem();
		current.maxLineLen = (String)maxLineLen.getSelectedItem();
		current.wordBreakChars = wordBreakChars.getText();
		current.commentStart = commentStart.getText();
		current.commentEnd = commentEnd.getText();
		current.lineComment = lineComment.getText();
		current.noWordSep = noWordSep.getText();
		current.collapseFolds = collapseFolds.getText();
		current.noTabs = noTabs.isSelected();
		current.indentOnEnter = indentOnEnter.isSelected();
		current.indentOnTab = indentOnTab.isSelected();
		current.syntax = syntax.isSelected();
	}
	private void selectMode()
	{
		current = modeProps[mode.getSelectedIndex()];
		current.edited = true;
		current.load();
		useDefaults.setSelected(current.useDefaults);
		filenameGlob.setText(current.filenameGlob);
		firstlineGlob.setText(current.firstlineGlob);
		tabSize.setSelectedItem(current.tabSize);
		indentSize.setSelectedItem(current.indentSize);
		maxLineLen.setSelectedItem(current.maxLineLen);
		wordBreakChars.setText(current.wordBreakChars);
		commentStart.setText(current.commentStart);
		commentEnd.setText(current.commentEnd);
		lineComment.setText(current.lineComment);
		noWordSep.setText(current.noWordSep);
		collapseFolds.setText(current.collapseFolds);
		noTabs.setSelected(current.noTabs);
		indentOnTab.setSelected(current.indentOnTab);
		indentOnEnter.setSelected(current.indentOnEnter);
		syntax.setSelected(current.syntax);
		updateEnabled();
	}
	private void updateEnabled()
	{
		boolean enabled = !modeProps[mode.getSelectedIndex()].useDefaults;
		filenameGlob.setEnabled(enabled);
		firstlineGlob.setEnabled(enabled);
		tabSize.setEnabled(enabled);
		indentSize.setEnabled(enabled);
		maxLineLen.setEnabled(enabled);
		wordBreakChars.setEnabled(enabled);
		commentStart.setEnabled(enabled);
		commentEnd.setEnabled(enabled);
		lineComment.setEnabled(enabled);
		noWordSep.setEnabled(enabled);
		collapseFolds.setEnabled(enabled);
		noTabs.setEnabled(enabled);
		indentOnTab.setEnabled(enabled);
		indentOnEnter.setEnabled(enabled);
		syntax.setEnabled(enabled);
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == mode)
			{
				saveMode();
				selectMode();
			}
			else if(evt.getSource() == useDefaults)
			{
				modeProps[mode.getSelectedIndex()].useDefaults =
					useDefaults.isSelected();
				updateEnabled();
			}
		}
	}
	class ModeProperties
	{
		Mode mode;
		boolean edited;
		boolean loaded;
		boolean useDefaults;
		String filenameGlob;
		String firstlineGlob;
		String tabSize;
		String indentSize;
		String maxLineLen;
		String wordBreakChars;
		String commentStart;
		String commentEnd;
		String lineComment;
		String noWordSep;
		String collapseFolds;
		boolean noTabs;
		boolean indentOnTab;
		boolean indentOnEnter;
		boolean syntax;
		ModeProperties(Mode mode)
		{
			this.mode = mode;
		}
		void load()
		{
			if(loaded)
				return;
			loaded = true;
			mode.loadIfNecessary();
			useDefaults = !jEdit.getBooleanProperty(""mode.""
				+ mode.getName() + "".customSettings"");
			filenameGlob = (String)mode.getProperty(""filenameGlob"");
			firstlineGlob = (String)mode.getProperty(""firstlineGlob"");
			tabSize = mode.getProperty(""tabSize"").toString();
			indentSize = mode.getProperty(""indentSize"").toString();
			maxLineLen = mode.getProperty(""maxLineLen"").toString();
			wordBreakChars = (String)mode.getProperty(""wordBreakChars"");
			commentStart = (String)mode.getProperty(""commentStart"");
			commentEnd = (String)mode.getProperty(""commentEnd"");
			lineComment = (String)mode.getProperty(""lineComment"");
			noWordSep = (String)mode.getProperty(""noWordSep"");
			collapseFolds = mode.getProperty(""collapseFolds"").toString();
			noTabs = mode.getBooleanProperty(""noTabs"");
			indentOnTab = mode.getBooleanProperty(""indentOnTab"");
			indentOnEnter = mode.getBooleanProperty(""indentOnEnter"");
			syntax = mode.getBooleanProperty(""syntax"");
		}
		void save()
		{
			// don't do anything if the user didn't change
			// any settings
			if(!edited)
				return;
			String prefix = ""mode."" + mode.getName() + ""."";
			jEdit.setBooleanProperty(prefix + ""customSettings"",!useDefaults);
			if(useDefaults)
			{
				jEdit.resetProperty(prefix + ""filenameGlob"");
				jEdit.resetProperty(prefix + ""firstlineGlob"");
				jEdit.resetProperty(prefix + ""tabSize"");
				jEdit.resetProperty(prefix + ""indentSize"");
				jEdit.resetProperty(prefix + ""maxLineLen"");
				jEdit.resetProperty(prefix + ""wordBreakChars"");
				jEdit.resetProperty(prefix + ""commentStart"");
				jEdit.resetProperty(prefix + ""commentEnd"");
				jEdit.resetProperty(prefix + ""lineComment"");
				jEdit.resetProperty(prefix + ""noWordSep"");
				jEdit.resetProperty(prefix + ""collapseFolds"");
				jEdit.resetProperty(prefix + ""noTabs"");
				jEdit.resetProperty(prefix + ""indentOnTab"");
				jEdit.resetProperty(prefix + ""indentOnEnter"");
				jEdit.resetProperty(prefix + ""syntax"");
			}
			else
			{
				jEdit.setProperty(prefix + ""filenameGlob"",filenameGlob);
				jEdit.setProperty(prefix + ""firstlineGlob"",firstlineGlob);
				jEdit.setProperty(prefix + ""tabSize"",tabSize);
				jEdit.setProperty(prefix + ""indentSize"",indentSize);
				jEdit.setProperty(prefix + ""maxLineLen"",maxLineLen);
				jEdit.setProperty(prefix + ""wordBreakChars"",wordBreakChars);
				jEdit.setProperty(prefix + ""commentStart"",commentStart);
				jEdit.setProperty(prefix + ""commentEnd"",commentEnd);
				jEdit.setProperty(prefix + ""lineComment"",lineComment);
				jEdit.setProperty(prefix + ""noWordSep"",noWordSep);
				jEdit.setProperty(prefix + ""collapseFolds"",collapseFolds);
				jEdit.setBooleanProperty(prefix + ""noTabs"",noTabs);
				jEdit.setBooleanProperty(prefix + ""indentOnTab"",indentOnTab);
				jEdit.setBooleanProperty(prefix + ""indentOnEnter"",indentOnEnter);
				jEdit.setBooleanProperty(prefix + ""syntax"",syntax);
			}
		}
	}
}
"
org.gjt.sp.jedit.options.PrintOptionPane,"/*
 * PrintOptionPane.java - Printing options panel
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;
public class PrintOptionPane extends AbstractOptionPane
{
	public PrintOptionPane()
	{
		super(""print"");
	}
	// protected members
	protected void _init()
	{
		/* Font */
		String _fontFamily = jEdit.getProperty(""print.font"");
		int _fontStyle;
		try
		{
			_fontStyle = Integer.parseInt(jEdit.getProperty(""print.fontstyle""));
		}
		catch(NumberFormatException nf)
		{
			_fontStyle = Font.PLAIN;
		}
		int _fontSize;
		try
		{
			_fontSize = Integer.parseInt(jEdit.getProperty(""print.fontsize""));
		}
		catch(NumberFormatException nf)
		{
			_fontSize = 14;
		}
		font = new FontSelector(new Font(_fontFamily,_fontStyle,_fontSize));
		addComponent(jEdit.getProperty(""options.print.font""),font);
		/* Header */
		printHeader = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".header""));
		printHeader.setSelected(jEdit.getBooleanProperty(""print.header""));
		addComponent(printHeader);
		/* Footer */
		printFooter = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".footer""));
		printFooter.setSelected(jEdit.getBooleanProperty(""print.footer""));
		addComponent(printFooter);
		/* Line numbering */
		printLineNumbers = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".lineNumbers""));
		printLineNumbers.setSelected(jEdit.getBooleanProperty(""print.lineNumbers""));
		addComponent(printLineNumbers);
		/* Syntax highlighting */
		style = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".style""));
		style.setSelected(jEdit.getBooleanProperty(""print.style""));
		addComponent(style);
		color = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".color""));
		color.setSelected(jEdit.getBooleanProperty(""print.color""));
		addComponent(color);
		addSeparator(""options.print.margins"");
		/* Margins */
		topMargin = new JTextField(jEdit.getProperty(""print.margin.top""));
		addComponent(jEdit.getProperty(""options.print.margin.top""),topMargin);
		leftMargin = new JTextField(jEdit.getProperty(""print.margin.left""));
		addComponent(jEdit.getProperty(""options.print.margin.left""),leftMargin);
		bottomMargin = new JTextField(jEdit.getProperty(""print.margin.bottom""));
		addComponent(jEdit.getProperty(""options.print.margin.bottom""),bottomMargin);
		rightMargin = new JTextField(jEdit.getProperty(""print.margin.right""));
		addComponent(jEdit.getProperty(""options.print.margin.right""),rightMargin);
	}
	protected void _save()
	{
		Font _font = font.getFont();
		jEdit.setProperty(""print.font"",_font.getFamily());
		jEdit.setProperty(""print.fontsize"",String.valueOf(_font.getSize()));
		jEdit.setProperty(""print.fontstyle"",String.valueOf(_font.getStyle()));
		jEdit.setBooleanProperty(""print.header"",printHeader.isSelected());
		jEdit.setBooleanProperty(""print.footer"",printFooter.isSelected());
		jEdit.setBooleanProperty(""print.lineNumbers"",printLineNumbers.isSelected());
		jEdit.setBooleanProperty(""print.style"",style.isSelected());
		jEdit.setBooleanProperty(""print.color"",color.isSelected());
		jEdit.setProperty(""print.margin.top"",topMargin.getText());
		jEdit.setProperty(""print.margin.left"",leftMargin.getText());
		jEdit.setProperty(""print.margin.bottom"",bottomMargin.getText());
		jEdit.setProperty(""print.margin.right"",rightMargin.getText());
	}
	// private members
	private FontSelector font;
	private JCheckBox printHeader;
	private JCheckBox printFooter;
	private JCheckBox printLineNumbers;
	private JCheckBox style;
	private JCheckBox color;
	private JTextField topMargin;
	private JTextField leftMargin;
	private JTextField bottomMargin;
	private JTextField rightMargin;
}
"
org.gjt.sp.jedit.options.ShortcutsOptionPane,"/*
 * ShortcutsOptionPane.java - Shortcuts options panel
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.GrabKeyDialog;
import org.gjt.sp.jedit.*;
/**
 * Key binding editor.
 * @author Slava Pestov
 * @version $Id: ShortcutsOptionPane.java,v 1.12 2001/08/10 10:35:11 sp Exp $
 */
public class ShortcutsOptionPane extends AbstractOptionPane
{
	public ShortcutsOptionPane()
	{
		super(""shortcuts"");
	}
	// protected members
	protected void _init()
	{
		allBindings = new Vector();
		setLayout(new BorderLayout(12,12));
		initModels();
		selectModel = new JComboBox(models);
		selectModel.addActionListener(new ActionHandler());
		Box north = Box.createHorizontalBox();
		north.add(new JLabel(jEdit.getProperty(
			""options.shortcuts.select.label"")));
		north.add(Box.createHorizontalStrut(12));
		north.add(selectModel);
		keyTable = new JTable(currentModel);
		keyTable.getTableHeader().setReorderingAllowed(false);
		keyTable.getTableHeader().addMouseListener(new HeaderMouseHandler());
		keyTable.addMouseListener(new TableMouseHandler());
		Dimension d = keyTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(keyTable);
		scroller.setPreferredSize(d);
		add(BorderLayout.NORTH,north);
		add(BorderLayout.CENTER,scroller);
	}
	protected void _save()
	{
		if(keyTable.getCellEditor() != null)
			keyTable.getCellEditor().stopCellEditing();
		Enumeration e = models.elements();
		while(e.hasMoreElements())
			((ShortcutsModel)e.nextElement()).save();
		Macros.loadMacros();
	}
	private void initModels()
	{
		models = new Vector();
		models.addElement(currentModel = createModel(""commands"",false));
		models.addElement(createModel(""plugins"",true));
		models.addElement(createMacrosModel());
	}
	private ShortcutsModel createModel(String id, boolean pluginActions)
	{
		EditAction[] actions = jEdit.getActions();
		Vector bindings = new Vector(actions.length);
		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];
			if(action.isPluginAction() != pluginActions)
				continue;
			String name = action.getName();
			String label = jEdit.getProperty(name + "".label"");
			// Skip certain actions this way (ENTER, TAB)
			if(label == null)
				continue;
			label = GUIUtilities.prettifyMenuLabel(label);
			addBindings(name,label,bindings);
		}
		return new ShortcutsModel(id,bindings);
	}
	private ShortcutsModel createMacrosModel()
	{
		Vector bindings = new Vector();
		Vector macroList = Macros.getMacroList();
		for(int i = 0; i < macroList.size(); i++)
		{
			String name = macroList.elementAt(i).toString();
			addBindings(name,name,bindings);
		}
		return new ShortcutsModel(""macros"",bindings);
	}
	private void addBindings(String name, String label, Vector bindings)
	{
		GrabKeyDialog.KeyBinding b[] = new GrabKeyDialog.KeyBinding[2];
		b[0] = createBinding(name,label,
			jEdit.getProperty(name + "".shortcut""));
		b[1] = createBinding(name,label,
			jEdit.getProperty(name + "".shortcut2""));
		bindings.addElement(b);
	}
	private GrabKeyDialog.KeyBinding createBinding(String name,
		String label, String shortcut)
	{
		if(shortcut != null && shortcut.length() == 0)
			shortcut = null;
		GrabKeyDialog.KeyBinding binding
			= new GrabKeyDialog.KeyBinding(name,label,shortcut,false);
		allBindings.addElement(binding);
		return binding;
	}
	// private members
	private JTable keyTable;
	private Vector models;
	private ShortcutsModel currentModel;
	private JComboBox selectModel;
	private Vector allBindings;
	class HeaderMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			switch(keyTable.getTableHeader().columnAtPoint(evt.getPoint()))
			{
			case 0:
				currentModel.sort(0);
				break;
			case 1:
				currentModel.sort(1);
				break;
			case 2:
				currentModel.sort(2);
				break;
			}
		}
	}
	class TableMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			int row = keyTable.getSelectedRow();
			int col = keyTable.getSelectedColumn();
			if(col != 0 && row != -1)
			{
				 GrabKeyDialog gkd = new GrabKeyDialog(
					ShortcutsOptionPane.this,
					currentModel.getBindingAt(row,col-1),
					allBindings);
				if(gkd.isOK())
					currentModel.setValueAt(
						gkd.getShortcut(),row,col);
			}
		}
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			ShortcutsModel newModel
				= (ShortcutsModel)selectModel.getSelectedItem();
			if(currentModel != newModel)
			{
				currentModel = newModel;
				keyTable.setModel(currentModel);
			}
		}
	}
	class ShortcutsModel extends AbstractTableModel
	{
		private Vector bindings;
		private String name;
		ShortcutsModel(String name, Vector bindings)
		{
			this.name = name;
			this.bindings = bindings;
			sort(0);
		}
		public void sort(int col)
		{
			MiscUtilities.quicksort(bindings,new KeyCompare(col));
			fireTableDataChanged();
		}
		public int getColumnCount()
		{
			return 3;
		}
		public int getRowCount()
		{
			return bindings.size();
		}
		public Object getValueAt(int row, int col)
		{
			switch(col)
			{
			case 0:
				return getBindingAt(row,0).label;
			case 1:
				return getBindingAt(row,0).shortcut;
			case 2:
				return getBindingAt(row,1).shortcut;
			default:
				return null;
			}
		}
		public void setValueAt(Object value, int row, int col)
		{
			if(col == 0)
				return;
			getBindingAt(row,col-1).shortcut = (String)value;
			// redraw the whole table because a second shortcut
			// might have changed, too
			fireTableDataChanged();
		}
		public String getColumnName(int index)
		{
			switch(index)
			{
			case 0:
				return jEdit.getProperty(""options.shortcuts.name"");
			case 1:
				return jEdit.getProperty(""options.shortcuts.shortcut1"");
			case 2:
				return jEdit.getProperty(""options.shortcuts.shortcut2"");
			default:
				return null;
			}
		}
		public void save()
		{
			Enumeration enum = bindings.elements();
			while(enum.hasMoreElements())
			{
				GrabKeyDialog.KeyBinding binding[]
					= (GrabKeyDialog.KeyBinding[])
						enum.nextElement();
				jEdit.setProperty(
					binding[0].name + "".shortcut"",
					binding[0].shortcut);
				jEdit.setProperty(
					binding[1].name + "".shortcut2"",
					binding[1].shortcut);
			}
		}
		public GrabKeyDialog.KeyBinding getBindingAt(int row, int nr)
		{
			GrabKeyDialog.KeyBinding binding[]
				= (GrabKeyDialog.KeyBinding[])
					bindings.elementAt(row);
			return binding[nr];
		}
		public String toString()
		{
			return jEdit.getProperty(
				""options.shortcuts.select."" + name);
		}
		class KeyCompare implements MiscUtilities.Compare
		{
			int col;
			KeyCompare(int col)
			{
				this.col = col;
			}
			public int compare(Object obj1, Object obj2)
			{
				GrabKeyDialog.KeyBinding[] k1
					= (GrabKeyDialog.KeyBinding[])obj1;
				GrabKeyDialog.KeyBinding[] k2
					= (GrabKeyDialog.KeyBinding[])obj2;
				String label1 = k1[0].label.toLowerCase();
				String label2 = k2[0].label.toLowerCase();
				if(col == 0)
					return label1.compareTo(label2);
				else
				{
					String shortcut1, shortcut2;
					if(col == 1)
					{
						shortcut1 = k1[0].shortcut;
						shortcut2 = k2[0].shortcut;
					}
					else
					{
						shortcut1 = k1[1].shortcut;
						shortcut2 = k2[1].shortcut;
					}
					if(shortcut1 == null && shortcut2 != null)
						return 1;
					else if(shortcut2 == null && shortcut1 != null)
						return -1;
					else if(shortcut1 == null && shortcut2 == null)
						return label1.compareTo(label2);
					else
						return shortcut1.compareTo(shortcut2);
				}
			}
		}
	}
}
"
org.gjt.sp.jedit.options.StyleOptionPane,"/*
 * StyleOptionPane.java - Style option pane
 * Copyright (C) 1999, 2000 Slava Pestov
 * Portions copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.jedit.*;
/**
 * Style option pane.
 * @author Slava Pestov
 * @version $Id: StyleOptionPane.java,v 1.28 2001/07/15 09:55:14 sp Exp $
 */
public class StyleOptionPane extends AbstractOptionPane
{
	public static final EmptyBorder noFocusBorder = new EmptyBorder(1,1,1,1);
	public StyleOptionPane()
	{
		super(""style"");
	}
	// protected members
	protected void _init()
	{
		setLayout(new BorderLayout());
		add(BorderLayout.CENTER,createStyleTableScroller());
	}
	protected void _save()
	{
		styleModel.save();
	}
	// private members
	private StyleTableModel styleModel;
	private JTable styleTable;
	private JScrollPane createStyleTableScroller()
	{
		styleModel = createStyleTableModel();
		styleTable = new JTable(styleModel);
		styleTable.setRowSelectionAllowed(false);
		styleTable.setColumnSelectionAllowed(false);
		styleTable.setCellSelectionEnabled(false);
		styleTable.getTableHeader().setReorderingAllowed(false);
		styleTable.addMouseListener(new MouseHandler());
		TableColumnModel tcm = styleTable.getColumnModel();
 		TableColumn styleColumn = tcm.getColumn(1);
		styleColumn.setCellRenderer(new StyleTableModel.StyleRenderer());
		Dimension d = styleTable.getPreferredSize();
		d.height = Math.min(d.height,100);
		JScrollPane scroller = new JScrollPane(styleTable);
		scroller.setPreferredSize(d);
		return scroller;
	}
	private StyleTableModel createStyleTableModel()
	{
		return new StyleTableModel();
	}
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			int row = styleTable.rowAtPoint(evt.getPoint());
			if(row == -1)
				return;
			SyntaxStyle style = new StyleEditor(
				StyleOptionPane.this,
				(SyntaxStyle)styleModel.getValueAt(
				row,1)).getStyle();
			if(style != null)
				styleModel.setValueAt(style,row,1);
		}
	}
}
class StyleTableModel extends AbstractTableModel
{
	private Vector styleChoices;
	StyleTableModel()
	{
		styleChoices = new Vector(13);
		addStyleChoice(""options.style.comment1Style"",""view.style.comment1"");
		addStyleChoice(""options.style.comment2Style"",""view.style.comment2"");
		addStyleChoice(""options.style.literal1Style"",""view.style.literal1"");
		addStyleChoice(""options.style.literal2Style"",""view.style.literal2"");
		addStyleChoice(""options.style.labelStyle"",""view.style.label"");
		addStyleChoice(""options.style.keyword1Style"",""view.style.keyword1"");
		addStyleChoice(""options.style.keyword2Style"",""view.style.keyword2"");
		addStyleChoice(""options.style.keyword3Style"",""view.style.keyword3"");
		addStyleChoice(""options.style.functionStyle"",""view.style.function"");
		addStyleChoice(""options.style.markupStyle"",""view.style.markup"");
		addStyleChoice(""options.style.operatorStyle"",""view.style.operator"");
		addStyleChoice(""options.style.digitStyle"",""view.style.digit"");
		addStyleChoice(""options.style.invalidStyle"",""view.style.invalid"");
	}
	public int getColumnCount()
	{
		return 2;
	}
	public int getRowCount()
	{
		return styleChoices.size();
	}
	public Object getValueAt(int row, int col)
	{
		StyleChoice ch = (StyleChoice)styleChoices.elementAt(row);
		switch(col)
		{
		case 0:
			return ch.label;
		case 1:
			return ch.style;
		default:
			return null;
		}
	}
	public void setValueAt(Object value, int row, int col)
	{
		StyleChoice ch = (StyleChoice)styleChoices.elementAt(row);
		if(col == 1)
			ch.style = (SyntaxStyle)value;
		fireTableRowsUpdated(row,row);
	}
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.style.object"");
		case 1:
			return jEdit.getProperty(""options.style.style"");
		default:
			return null;
		}
	}
	public void save()
	{
		for(int i = 0; i < styleChoices.size(); i++)
		{
			StyleChoice ch = (StyleChoice)styleChoices
				.elementAt(i);
			jEdit.setProperty(ch.property,
				GUIUtilities.getStyleString(ch.style));
		}
	}
	private void addStyleChoice(String label, String property)
	{
		styleChoices.addElement(new StyleChoice(jEdit.getProperty(label),
			property,
			GUIUtilities.parseStyle(jEdit.getProperty(property),
			""Dialog"",12)));
	}
	static class StyleChoice
	{
		String label;
		String property;
		SyntaxStyle style;
		StyleChoice(String label, String property, SyntaxStyle style)
		{
			this.label = label;
			this.property = property;
			this.style = style;
		}
	}
	static class StyleRenderer extends JLabel
		implements TableCellRenderer
	{
		public StyleRenderer()
		{
			setOpaque(true);
			setBorder(StyleOptionPane.noFocusBorder);
			setText(""Hello World"");
		}
		// TableCellRenderer implementation
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			if (value != null)
			{
				SyntaxStyle style = (SyntaxStyle)value;
				setForeground(style.getForegroundColor());
				if (style.getBackgroundColor() != null) 
					setBackground(style.getBackgroundColor());
				else
				{
					// this part sucks
					setBackground(GUIUtilities.parseColor(
						jEdit.getProperty(""view.bgColor"")));
				}
				setFont(style.getFont());
			}
			setBorder((cellHasFocus) ? UIManager.getBorder(
				""Table.focusCellHighlightBorder"")
				: StyleOptionPane.noFocusBorder);
			return this;
		}
		// end TableCellRenderer implementation
	}
}
class StyleEditor extends EnhancedDialog implements ActionListener
{
	StyleEditor(Component comp, SyntaxStyle style)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""style-editor.title""),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(0,0,12,0));
		panel.add(italics = new JCheckBox(
			jEdit.getProperty(""style-editor.italics"")));
		italics.setSelected(style.getFont().isItalic());
		panel.add(Box.createHorizontalStrut(2));
		panel.add(bold = new JCheckBox(
			jEdit.getProperty(""style-editor.bold"")));
		bold.setSelected(style.getFont().isBold());
		panel.add(Box.createHorizontalStrut(12));
		panel.add(new JLabel(jEdit.getProperty(""style-editor.fgColor"")));
		panel.add(Box.createHorizontalStrut(12));
		panel.add(fgColor = new JButton(""    ""));
		fgColor.setBackground(style.getForegroundColor());
		fgColor.setRequestFocusEnabled(false);
		fgColor.addActionListener(this);
		fgColor.setMargin(new Insets(0,0,0,0));
		panel.add(Box.createHorizontalStrut(12));
		panel.add(new JLabel(jEdit.getProperty(""style-editor.bgColor"")));
		panel.add(Box.createHorizontalStrut(12));
		panel.add(bgColor = new JButton(""    ""));
		if(style.getBackgroundColor() == null)
			bgColor.setBackground(GUIUtilities.parseColor(jEdit.getProperty(""view.bgColor"")));
		else
			bgColor.setBackground(style.getBackgroundColor());
		bgColor.setRequestFocusEnabled(false);
		bgColor.addActionListener(this);
		bgColor.setMargin(new Insets(0,0,0,0));
		content.add(BorderLayout.CENTER,panel);
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		box.add(ok = new JButton(jEdit.getProperty(""common.ok"")));
		getRootPane().setDefaultButton(ok);
		ok.addActionListener(this);
		box.add(Box.createHorizontalStrut(6));
		box.add(cancel = new JButton(jEdit.getProperty(""common.cancel"")));
		cancel.addActionListener(this);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);
		Dimension screen = getToolkit().getScreenSize();
		pack();
		setLocationRelativeTo(JOptionPane.getFrameForComponent(comp));
		show();
	}
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
			ok();
		else if(source == cancel)
			cancel();
		else if (source == fgColor || source == bgColor)
		{
			JButton b = (JButton)source;
			Color c = JColorChooser.showDialog(this,
				jEdit.getProperty(""colorChooser.title""),
				b.getBackground());
			if(c != null)
				b.setBackground(c);
		}
	}
	// EnhancedDialog implementation
	public void ok()
	{
		okClicked = true;
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	public SyntaxStyle getStyle()
	{
		if(!okClicked)
			return null;
		Color background = bgColor.getBackground();
		if (background.equals(GUIUtilities.parseColor(jEdit.getProperty(""view.bgColor""))))
			background = null;
		return new SyntaxStyle(fgColor.getBackground(),background,
				new Font(""Dialog"",
				(italics.isSelected() ? Font.ITALIC : 0)
				| (bold.isSelected() ? Font.BOLD : 0),
				12));
	}
	// private members
	private JCheckBox italics;
	private JCheckBox bold;
	private JButton fgColor;
	private JButton bgColor;
	private JButton ok;
	private JButton cancel;
	private boolean okClicked;
}
/*
 * Change Log:
 * $Log: StyleOptionPane.java,v $
 * Revision 1.28  2001/07/15 09:55:14  sp
 * AWT/2D text render code split almost finished
 *
 * Revision 1.27  2001/02/05 09:15:30  sp
 * Improved shortcut option pane, various other 31337 stuff
 *
 * Revision 1.26  2001/01/22 05:35:08  sp
 * bug fixes galore
 *
 * Revision 1.25  2000/11/07 10:08:32  sp
 * Options dialog improvements, documentation changes, bug fixes
 *
 * Revision 1.24  2000/11/05 05:25:46  sp
 * Word wrap, format and remove-trailing-ws commands from TextTools moved into core
 *
 * Revision 1.23  2000/10/30 07:14:04  sp
 * 2.7pre1 branched, GUI improvements
 *
 * Revision 1.22  2000/10/12 09:28:27  sp
 * debugging and polish
 *
 * Revision 1.21  2000/08/10 08:30:41  sp
 * VFS browser work, options dialog work, more random tweaks
 *
 * Revision 1.20  2000/08/05 07:16:12  sp
 * Global options dialog box updated, VFS browser now supports right-click menus
 *
 * Revision 1.19  2000/07/14 06:00:45  sp
 * bracket matching now takes syntax info into account
 *
 * Revision 1.18  2000/07/12 09:11:38  sp
 * macros can be added to context menu and tool bar, menu bar layout improved
 *
 * Revision 1.17  2000/06/03 07:28:26  sp
 * User interface updates, bug fixes
 *
 * Revision 1.16  2000/05/22 12:05:45  sp
 * Markers are highlighted in the gutter, bug fixes
 *
 * Revision 1.15  2000/05/21 03:00:51  sp
 * Code cleanups and bug fixes
 *
 */
"
org.gjt.sp.jedit.options.TextAreaOptionPane,"/*
 * TextAreaOptionPane.java - Text area options panel
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;
public class TextAreaOptionPane extends AbstractOptionPane
{
	public TextAreaOptionPane()
	{
		super(""textarea"");
	}
	public void _init()
	{
		/* Font */
		String _fontFamily = jEdit.getProperty(""view.font"");
		int _fontStyle;
		try
		{
			_fontStyle = Integer.parseInt(jEdit.getProperty(""view.fontstyle""));
		}
		catch(NumberFormatException nf)
		{
			_fontStyle = Font.PLAIN;
		}
		int _fontSize;
		try
		{
			_fontSize = Integer.parseInt(jEdit.getProperty(""view.fontsize""));
		}
		catch(NumberFormatException nf)
		{
			_fontSize = 14;
		}
		font = new FontSelector(new Font(_fontFamily,_fontStyle,_fontSize));
		addComponent(jEdit.getProperty(""options.textarea.font""),font);
		/* Line highlight */
		lineHighlight = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".lineHighlight""));
		lineHighlight.setSelected(jEdit.getBooleanProperty(""view.lineHighlight""));
		addComponent(lineHighlight);
		/* Bracket highlight */
		bracketHighlight = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".bracketHighlight""));
		bracketHighlight.setSelected(jEdit.getBooleanProperty(
			""view.bracketHighlight""));
		addComponent(bracketHighlight);
		/* EOL markers */
		eolMarkers = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".eolMarkers""));
		eolMarkers.setSelected(jEdit.getBooleanProperty(""view.eolMarkers""));
		addComponent(eolMarkers);
		/* Wrap guide */
		wrapGuide = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".wrapGuide""));
		wrapGuide.setSelected(jEdit.getBooleanProperty(""view.wrapGuide""));
		addComponent(wrapGuide);
		/* Blinking caret */
		blinkCaret = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".blinkCaret""));
		blinkCaret.setSelected(jEdit.getBooleanProperty(""view.caretBlink""));
		addComponent(blinkCaret);
		/* Block caret */
		blockCaret = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".blockCaret""));
		blockCaret.setSelected(jEdit.getBooleanProperty(""view.blockCaret""));
		addComponent(blockCaret);
		/* Electric borders */
		electricBorders = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".electricBorders""));
		electricBorders.setSelected(!""0"".equals(jEdit.getProperty(
			""view.electricBorders"")));
		addComponent(electricBorders);
		/* Smart home/end */
		homeEnd = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".homeEnd""));
		homeEnd.setSelected(jEdit.getBooleanProperty(""view.homeEnd""));
		addComponent(homeEnd);
		/* Middle mouse button click pastes % register */
		middleMousePaste = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".middleMousePaste""));
		middleMousePaste.setSelected(jEdit.getBooleanProperty(
			""view.middleMousePaste""));
		addComponent(middleMousePaste);
		/* Anti-aliasing */
		antiAlias = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".antiAlias""));
		antiAlias.setSelected(jEdit.getBooleanProperty(""view.antiAlias""));
		/* Fractional font metrics */
		fracFontMetrics = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".fracFontMetrics""));
		fracFontMetrics.setSelected(jEdit.getBooleanProperty(
			""view.fracFontMetrics""));
		if(System.getProperty(""java.version"").compareTo(""1.2"") >= 0)
		{
			addComponent(antiAlias);
			addComponent(fracFontMetrics);
		}
	}
	public void _save()
	{
		Font _font = font.getFont();
		jEdit.setProperty(""view.font"",_font.getFamily());
		jEdit.setProperty(""view.fontsize"",String.valueOf(_font.getSize()));
		jEdit.setProperty(""view.fontstyle"",String.valueOf(_font.getStyle()));
		jEdit.setBooleanProperty(""view.lineHighlight"",lineHighlight
			.isSelected());
		jEdit.setBooleanProperty(""view.bracketHighlight"",bracketHighlight
			.isSelected());
		jEdit.setBooleanProperty(""view.eolMarkers"",eolMarkers
			.isSelected());
		jEdit.setBooleanProperty(""view.wrapGuide"",wrapGuide
			.isSelected());
		jEdit.setBooleanProperty(""view.caretBlink"",blinkCaret.isSelected());
		jEdit.setBooleanProperty(""view.blockCaret"",blockCaret.isSelected());
		jEdit.setProperty(""view.electricBorders"",electricBorders
			.isSelected() ? ""3"" : ""0"");
		jEdit.setBooleanProperty(""view.homeEnd"",homeEnd.isSelected());
		jEdit.setBooleanProperty(""view.middleMousePaste"",
			middleMousePaste.isSelected());
		jEdit.setBooleanProperty(""view.antiAlias"",antiAlias.isSelected());
		jEdit.setBooleanProperty(""view.fracFontMetrics"",fracFontMetrics.isSelected());
	}
	// private members
	private FontSelector font;
	private JCheckBox lineHighlight;
	private JCheckBox bracketHighlight;
	private JCheckBox eolMarkers;
	private JCheckBox wrapGuide;
	private JCheckBox blinkCaret;
	private JCheckBox blockCaret;
	private JCheckBox electricBorders;
	private JCheckBox homeEnd;
	private JCheckBox middleMousePaste;
	private JCheckBox antiAlias;
	private JCheckBox fracFontMetrics;
}
"
org.gjt.sp.jedit.options.ToolBarOptionPane,"/*
 * ToolBarOptionPane.java - Tool bar options panel
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.options;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * Tool bar editor.
 * @author Slava Pestov
 * @version $Id: ToolBarOptionPane.java,v 1.14 2001/03/26 07:09:20 sp Exp $
 */
public class ToolBarOptionPane extends AbstractOptionPane
{
	public ToolBarOptionPane()
	{
		super(""toolbar"");
	}
	// protected members
	protected void _init()
	{
		setLayout(new BorderLayout());
		JPanel panel = new JPanel(new GridLayout(2,1));
		/* Show toolbar */
		showToolbar = new JCheckBox(jEdit.getProperty(
			""options.toolbar.showToolbar""));
		showToolbar.setSelected(jEdit.getBooleanProperty(""view.showToolbar""));
		panel.add(showToolbar);
		panel.add(new JLabel(jEdit.getProperty(
			""options.toolbar.caption"")));
		add(BorderLayout.NORTH,panel);
		String toolbar = jEdit.getProperty(""view.toolbar"");
		StringTokenizer st = new StringTokenizer(toolbar);
		listModel = new DefaultListModel();
		while(st.hasMoreTokens())
		{
			String actionName = (String)st.nextToken();
			String label = ContextOptionPane.getActionLabel(actionName);
			if(label == null)
				continue;
			Icon icon;
			String iconName;
			if(actionName.equals(""-""))
			{
				iconName = null;
				icon = null;
			}
			else
			{
				iconName = jEdit.getProperty(actionName + "".icon"");
				if(iconName == null)
					continue;
				icon = GUIUtilities.loadIcon(iconName);
			}
			listModel.addElement(new Button(actionName,iconName,icon,label));
		}
		list = new JList(listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		list.addListSelectionListener(new ListHandler());
		list.setCellRenderer(new ButtonCellRenderer());
		add(BorderLayout.CENTER,new JScrollPane(list));
		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.add(Box.createGlue());
		ActionHandler actionHandler = new ActionHandler();
		add = new JButton(jEdit.getProperty(""options.toolbar.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new JButton(jEdit.getProperty(""options.toolbar.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new JButton(jEdit.getProperty(""options.toolbar.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new JButton(jEdit.getProperty(""options.toolbar.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createGlue());
		updateButtons();
		add(BorderLayout.SOUTH,buttons);
		// create actions list
		EditAction[] actions = jEdit.getActions();
		Vector vector = new Vector(actions.length);
		for(int i = 0; i < actions.length; i++)
		{
			String actionName = actions[i].getName();
			String label = jEdit.getProperty(actionName + "".label"");
			if(label == null)
				continue;
			vector.addElement(new Button(actionName,null,null,label));
		}
		MiscUtilities.quicksort(vector,new ButtonCompare());
		actionsList = new DefaultListModel();
		actionsList.ensureCapacity(vector.size());
		for(int i = 0; i < vector.size(); i++)
		{
			actionsList.addElement(vector.elementAt(i));
		}
		// create icons list
		iconList = new DefaultComboBoxModel();
		st = new StringTokenizer(jEdit.getProperty(""icons""));
		while(st.hasMoreElements())
		{
			String icon = st.nextToken();
			iconList.addElement(new IconListEntry(
				GUIUtilities.loadIcon(icon),icon));
		}
	}
	class ButtonCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return ((Button)obj1).label.toLowerCase().compareTo(
				((Button)obj2).label.toLowerCase());
		}
	}
	protected void _save()
	{
		jEdit.setBooleanProperty(""view.showToolbar"",showToolbar
			.isSelected());
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < listModel.getSize(); i++)
		{
			if(i != 0)
				buf.append(' ');
			Button button = (Button)listModel.elementAt(i);
			buf.append(button.actionName);
			jEdit.setProperty(button.actionName + "".icon"",button.iconName);
		}
		jEdit.setProperty(""view.toolbar"",buf.toString());
	}
	// private members
	private JCheckBox showToolbar;
	private DefaultListModel listModel;
	private JList list;
	private JButton add;
	private JButton remove;
	private JButton moveUp, moveDown;
	private DefaultListModel actionsList;
	private DefaultComboBoxModel iconList;
	private void updateButtons()
	{
		int index = list.getSelectedIndex();
		remove.setEnabled(index != -1 && listModel.getSize() != 0);
		moveUp.setEnabled(index > 0);
		moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);
	}
	static class Button
	{
		String actionName;
		String iconName;
		Icon icon;
		String label;
		Button(String actionName, String iconName, Icon icon, String label)
		{
			this.actionName = actionName;
			this.iconName = iconName;
			this.icon = icon;
			if(label.equals(""-""))
				this.label = label;
			else
				this.label = GUIUtilities.prettifyMenuLabel(label);
		}
		public String toString()
		{
			return label;
		}
	}
	static class IconListEntry
	{
		Icon icon;
		String name;
		IconListEntry(Icon icon, String name)
		{
			this.icon = icon;
			this.name = name;
		}
	}
	static class ButtonCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list,
			Object value, int index, boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);
			Button button = (Button)value;
			setText(button.label);
			setIcon(button.icon);
			return this;
		}
	}
	static class IconCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list,
			Object value, int index, boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);
			IconListEntry icon = (IconListEntry)value;
			setText(icon.name);
			setIcon(icon.icon);
			return this;
		}
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == add)
			{
				ToolBarAddDialog dialog = new ToolBarAddDialog(
					ToolBarOptionPane.this,
					actionsList,iconList);
				Button selection = dialog.getSelection();
				if(selection == null)
					return;
				int index = list.getSelectedIndex();
				if(index == -1)
					index = listModel.getSize();
				else
					index++;
				listModel.insertElementAt(selection,index);
				list.setSelectedIndex(index);
			}
			else if(source == remove)
			{
				int index = list.getSelectedIndex();
				listModel.removeElementAt(index);
				updateButtons();
			}
			else if(source == moveUp)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index-1);
				list.setSelectedIndex(index-1);
			}
			else if(source == moveDown)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index+1);
				list.setSelectedIndex(index+1);
			}
		}
	}
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateButtons();
		}
	}
}
class ToolBarAddDialog extends EnhancedDialog
{
	public ToolBarAddDialog(Component comp, ListModel actionsListModel,
		ComboBoxModel iconListModel)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""options.toolbar.add.title""),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		content.add(BorderLayout.NORTH,new JLabel(
			jEdit.getProperty(""options.toolbar.add.caption"")));
		JPanel mainPanel = new JPanel(new BorderLayout(0,6));
		JPanel radioPanel = new JPanel(new GridLayout(2,1));
		ActionHandler actionHandler = new ActionHandler();
		ButtonGroup grp = new ButtonGroup();
		// Add separator
		separator = new JRadioButton(jEdit.getProperty(""options.toolbar""
			+ "".add.separator""));
		separator.setSelected(true);
		separator.addActionListener(actionHandler);
		grp.add(separator);
		radioPanel.add(separator);
		// Add action
		action = new JRadioButton(jEdit.getProperty(""options.toolbar""
			+ "".add.action""));
		action.addActionListener(actionHandler);
		grp.add(action);
		radioPanel.add(action);
		mainPanel.add(BorderLayout.NORTH,radioPanel);
		actionsList = new JList(actionsListModel);
		actionsList.setVisibleRowCount(8);
		JPanel centerPanel = new JPanel(new BorderLayout(0,3));
		centerPanel.add(BorderLayout.NORTH,new JScrollPane(actionsList));
		// Add macro
		macro = new JRadioButton(jEdit.getProperty(""options.toolbar""
			+ "".add.macro""));
		macro.addActionListener(actionHandler);
		grp.add(macro);
		centerPanel.add(BorderLayout.CENTER,macro);
		macrosList = new JList(Macros.getMacroList());
		macrosList.setVisibleRowCount(8);
		centerPanel.add(BorderLayout.SOUTH,new JScrollPane(macrosList));
		mainPanel.add(BorderLayout.CENTER,centerPanel);
		// Icon selection
		JPanel iconPanel = new JPanel(new BorderLayout(0,3));
		JPanel labelPanel = new JPanel(new GridLayout(2,1));
		labelPanel.setBorder(new EmptyBorder(0,0,0,12));
		JPanel compPanel = new JPanel(new GridLayout(2,1));
		grp = new ButtonGroup();
		labelPanel.add(builtin = new JRadioButton(jEdit.getProperty(
			""options.toolbar.add.builtin"")));
		builtin.addActionListener(actionHandler);
		builtin.setSelected(true);
		grp.add(builtin);
		labelPanel.add(file = new JRadioButton(jEdit.getProperty(
			""options.toolbar.add.file"")));
		grp.add(file);
		file.addActionListener(actionHandler);
		iconPanel.add(BorderLayout.WEST,labelPanel);
		builtinCombo = new JComboBox(iconListModel);
		builtinCombo.setRenderer(new ToolBarOptionPane.IconCellRenderer());
		compPanel.add(builtinCombo);
		fileButton = new JButton(jEdit.getProperty(""options.toolbar.add.no-icon""));
		fileButton.setMargin(new Insets(1,1,1,1));
		fileButton.setIcon(GUIUtilities.loadIcon(""Blank24.gif""));
		fileButton.setHorizontalAlignment(SwingConstants.LEFT);
		fileButton.addActionListener(actionHandler);
		compPanel.add(fileButton);
		iconPanel.add(BorderLayout.CENTER,compPanel);
		mainPanel.add(BorderLayout.SOUTH,iconPanel);
		content.add(BorderLayout.CENTER,mainPanel);
		JPanel southPanel = new JPanel();
		southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));
		southPanel.setBorder(new EmptyBorder(12,0,0,0));
		southPanel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionHandler);
		getRootPane().setDefaultButton(ok);
		southPanel.add(ok);
		southPanel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionHandler);
		southPanel.add(cancel);
		southPanel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,southPanel);
		updateEnabled();
		pack();
		setLocationRelativeTo(JOptionPane.getFrameForComponent(comp));
		show();
	}
	public void ok()
	{
		isOK = true;
		dispose();
	}
	public void cancel()
	{
		dispose();
	}
	public ToolBarOptionPane.Button getSelection()
	{
		if(!isOK)
			return null;
		if(separator.isSelected())
			return new ToolBarOptionPane.Button(""-"",null,null,""-"");
		else
		{
			Icon icon;
			String iconName;
			if(builtin.isSelected())
			{
				ToolBarOptionPane.IconListEntry selectedIcon =
					(ToolBarOptionPane.IconListEntry)
					builtinCombo.getSelectedItem();
				icon = selectedIcon.icon;
				iconName = selectedIcon.name;
			}
			else
			{
				icon = fileButton.getIcon();
				iconName = fileIcon;
				if(iconName == null)
					iconName = ""Blank24.gif"";
			}
			String label;
			String actionName;
			if(action.isSelected())
			{
				ToolBarOptionPane.Button button =
					(ToolBarOptionPane.Button)actionsList
					.getSelectedValue();
				label = button.label;
				actionName = button.actionName;
			}
			else if(macro.isSelected())
			{
				actionName = ""play-macro@"" + macrosList.getSelectedValue();
				label = ContextOptionPane.getActionLabel(actionName);
			}
			else
				throw new InternalError();
			return new ToolBarOptionPane.Button(actionName,
				iconName,icon,label);
		}
	}
	// private members
	private boolean isOK;
	private JRadioButton separator, action, macro;
	private JList actionsList, macrosList;
	private JRadioButton builtin;
	private JComboBox builtinCombo;
	private JRadioButton file;
	private JButton fileButton;
	private String fileIcon;
	private JButton ok, cancel;
	private void updateEnabled()
	{
		actionsList.setEnabled(action.isSelected());
		macrosList.setEnabled(macro.isSelected());
		boolean iconControlsEnabled = !separator.isSelected();
		builtin.setEnabled(iconControlsEnabled);
		file.setEnabled(iconControlsEnabled);
		builtinCombo.setEnabled(iconControlsEnabled && builtin.isSelected());
		fileButton.setEnabled(iconControlsEnabled && file.isSelected());
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source instanceof JRadioButton)
				updateEnabled();
			else if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == builtin || source == file)
				updateEnabled();
			else if(source == fileButton)
			{
				String directory;
				if(fileIcon == null)
					directory = null;
				else
					directory = MiscUtilities.getParentOfPath(fileIcon);
				String paths[] = GUIUtilities.showVFSFileDialog(null,directory,
					VFSBrowser.OPEN_DIALOG,false);
				if(paths == null)
					return;
				fileIcon = ""file:"" + paths[0];
				try
				{
					fileButton.setIcon(new ImageIcon(new URL(
						fileIcon)));
				}
				catch(MalformedURLException mf)
				{
					Log.log(Log.ERROR,this,mf);
				}
				fileButton.setText(MiscUtilities.getFileName(fileIcon));
			}
		}
	}
}
"
org.gjt.sp.jedit.pluginmgr.InstallPluginsDialog,"/*
 * InstallPluginsDialog.java - Plugin install dialog box
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
class InstallPluginsDialog extends EnhancedDialog
{
	static final int INSTALL = 0;
	static final int UPDATE = 1;
	InstallPluginsDialog(JDialog dialog, Vector model, int mode)
	{
		super(JOptionPane.getFrameForComponent(dialog),
			(mode == INSTALL
			? jEdit.getProperty(""install-plugins.title"")
			: jEdit.getProperty(""update-plugins.title"")),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JLabel label = new JLabel(jEdit.getProperty(""install-plugins.caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		content.add(BorderLayout.NORTH,label);
		JPanel panel = new JPanel(new BorderLayout());
		panel.setBorder(new EmptyBorder(0,0,12,0));
		plugins = new JCheckBoxList(model);
		plugins.getSelectionModel().addListSelectionListener(new ListHandler());
		JScrollPane scroller = new JScrollPane(plugins);
		Dimension dim = scroller.getPreferredSize();
		dim.height = 120;
		scroller.setPreferredSize(dim);
		panel.add(BorderLayout.CENTER,scroller);
		JPanel panel2 = new JPanel(new BorderLayout());
		panel2.setBorder(new EmptyBorder(6,0,0,0));
		JPanel labelBox = new JPanel(new GridLayout(
			(mode == UPDATE ? 6 : 5),1,0,3));
		labelBox.setBorder(new EmptyBorder(0,0,3,12));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.name""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.author""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.latest-version""),SwingConstants.RIGHT));
		if(mode == UPDATE)
		{
			labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
				+ "".info.installed-version""),SwingConstants.RIGHT));
		}
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.updated""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.description""),SwingConstants.RIGHT));
		panel2.add(BorderLayout.WEST,labelBox);
		JPanel valueBox = new JPanel(new GridLayout(
			(mode == UPDATE ? 6 : 5),1,0,3));
		valueBox.setBorder(new EmptyBorder(0,0,3,0));
		valueBox.add(name = new JLabel());
		valueBox.add(author = new JLabel());
		valueBox.add(latestVersion = new JLabel());
		if(mode == UPDATE)
		{
			valueBox.add(installedVersion = new JLabel());
		}
		valueBox.add(updated = new JLabel());
		valueBox.add(Box.createGlue());
		panel2.add(BorderLayout.CENTER,valueBox);
		JPanel panel3 = new JPanel(new BorderLayout(0,3));
		description = new JTextArea(6,30);
		description.setEditable(false);
		description.setLineWrap(true);
		description.setWrapStyleWord(true);
		panel3.add(BorderLayout.NORTH,new JScrollPane(description));
		if(mode == INSTALL)
		{
			JPanel panel4 = new JPanel(new BorderLayout(0,3));
			ButtonGroup grp = new ButtonGroup();
			installUser = new JRadioButton();
			String settings = jEdit.getSettingsDirectory();
			if(settings == null)
			{
				settings = jEdit.getProperty(""install-plugins.none"");
				installUser.setEnabled(false);
			}
			else
			{
				settings = MiscUtilities.constructPath(settings,""jars"");
				installUser.setEnabled(true);
			}
			String[] args = { settings };
			installUser.setText(jEdit.getProperty(""install-plugins.user"",args));
			grp.add(installUser);
			panel4.add(BorderLayout.CENTER,installUser);
			installSystem = new JRadioButton();
			String jEditHome = jEdit.getJEditHome();
			if(jEditHome == null)
			{
				jEditHome = jEdit.getProperty(""install-plugins.none"");
				installSystem.setEnabled(false);
			}
			else
			{
				jEditHome = MiscUtilities.constructPath(jEditHome,""jars"");
				installSystem.setEnabled(true);
			}
			args[0] = jEditHome;
			installSystem.setText(jEdit.getProperty(""install-plugins.system"",args));
			grp.add(installSystem);
			panel4.add(BorderLayout.SOUTH,installSystem);
			if(installUser.isEnabled())
				installUser.setSelected(true);
			else
				installSystem.setSelected(true);
			panel3.add(BorderLayout.CENTER,panel4);
		}
		panel3.add(BorderLayout.SOUTH,downloadSource = new JCheckBox(
			jEdit.getProperty(""install-plugins.downloadSource"")));
		downloadSource.setSelected(jEdit.getBooleanProperty(""install-plugins""
			+ "".downloadSource.value""));
		panel2.add(BorderLayout.SOUTH,panel3);
		panel.add(BorderLayout.SOUTH,panel2);
		content.add(BorderLayout.CENTER,panel);
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		install = new JButton(jEdit.getProperty(""install-plugins.install""));
		install.setEnabled(false);
		getRootPane().setDefaultButton(install);
		install.addActionListener(new ActionHandler());
		box.add(install);
		box.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createHorizontalStrut(6));
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);
		pack();
		setLocationRelativeTo(dialog);
		show();
	}
	public void ok()
	{
		jEdit.setBooleanProperty(""install-plugins.downloadSource.value"",
			downloadSource.isSelected());
		dispose();
	}
	public void cancel()
	{
		cancelled = true;
		dispose();
	}
	void installPlugins(Roster roster)
	{
		if(cancelled)
			return;
		String installDirectory;
		if(installUser == null || installUser.isSelected())
		{
			installDirectory = MiscUtilities.constructPath(
				jEdit.getSettingsDirectory(),""jars"");
		}
		else
		{
			installDirectory = MiscUtilities.constructPath(
				jEdit.getJEditHome(),""jars"");
		}
		Object[] selected = plugins.getCheckedValues();
		for(int i = 0; i < selected.length; i++)
		{
			PluginList.Plugin plugin = (PluginList.Plugin)selected[i];
			plugin.install(roster,installDirectory,downloadSource.isSelected());
		}
	}
	// private members
	private JCheckBoxList plugins;
	private JLabel name;
	private JLabel author;
	private JLabel latestVersion;
	private JLabel installedVersion;
	private JLabel updated;
	private JTextArea description;
	private JRadioButton installUser;
	private JRadioButton installSystem;
	private JCheckBox downloadSource;
	private JButton install;
	private JButton cancel;
	private boolean cancelled;
	private Thread thread;
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == install)
				ok();
			else
				cancel();
		}
	}
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			Object selected = plugins.getSelectedValue();
			if(selected instanceof PluginList.Plugin)
			{
				install.setEnabled(true);
				PluginList.Plugin plugin = (PluginList.Plugin)selected;
				PluginList.Branch branch = plugin.getCompatibleBranch();
				name.setText(plugin.name);
				author.setText(plugin.author);
				if(branch.obsolete)
					latestVersion.setText(jEdit.getProperty(
						""install-plugins.info.obsolete""));
				else
					latestVersion.setText(branch.version);
				if(installedVersion != null)
					installedVersion.setText(plugin.installedVersion);
				updated.setText(branch.date);
				StringBuffer buf = new StringBuffer();
				for(int i = 0; i < branch.deps.size(); i++)
				{
					PluginList.Dependency dep = (PluginList.Dependency)
						branch.deps.elementAt(i);
					if(dep.what.equals(""plugin"")
						&& !dep.isSatisfied())
					{
						if(buf.length() != 0)
							buf.append("", "");
						buf.append(dep.plugin);
					}
				}
				description.setText(plugin.description
					+ (buf.length() == 0 ? """"
					: jEdit.getProperty(""install-plugins.info""
					+ "".also-install"") + buf.toString()
					+ (branch.obsolete ? jEdit.getProperty(
					""install-plugins.info.obsolete-text"") : """")));
			}
			else
			{
				install.setEnabled(false);
				name.setText(null);
				author.setText(null);
				latestVersion.setText(null);
				if(installedVersion != null)
					installedVersion.setText(null);
				updated.setText(null);
				description.setText(null);
			}
		}
	}
}
"
org.gjt.sp.jedit.pluginmgr.PluginList,"/*
 * PluginList.java - Plugin list
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
import com.microstar.xml.*;
import java.io.*;
import java.net.URL;
import java.util.Hashtable;
import java.util.Vector;
import org.gjt.sp.util.Log;
import org.gjt.sp.jedit.*;
/**
 * Plugin list downloaded from server.
 * @since jEdit 3.2pre2
 */
class PluginList
{
	Vector plugins;
	Hashtable pluginHash;
	Vector pluginSets;
	PluginList() throws Exception
	{
		plugins = new Vector();
		pluginHash = new Hashtable();
		pluginSets = new Vector();
		String path = jEdit.getProperty(""plugin-manager.url"");
		PluginListHandler handler = new PluginListHandler(this,path);
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		parser.parse(null,null,new BufferedReader(new InputStreamReader(
			new URL(path).openStream(),""UTF8"")));
	}
	void addPlugin(Plugin plugin)
	{
		plugin.checkIfInstalled();
		plugins.addElement(plugin);
		pluginHash.put(plugin.name,plugin);
	}
	void addPluginSet(PluginSet set)
	{
		pluginSets.addElement(set);
	}
	void finished()
	{
		// after the entire list is loaded, fill out plugin field
		// in dependencies
		for(int i = 0; i < plugins.size(); i++)
		{
			Plugin plugin = (Plugin)plugins.elementAt(i);
			for(int j = 0; j < plugin.branches.size(); j++)
			{
				Branch branch = (Branch)plugin.branches.elementAt(j);
				for(int k = 0; k < branch.deps.size(); k++)
				{
					Dependency dep = (Dependency)branch.deps.elementAt(k);
					if(dep.what.equals(""plugin""))
						dep.plugin = (Plugin)pluginHash.get(dep.pluginName);
				}
			}
		}
	}
	void dump()
	{
		for(int i = 0; i < plugins.size(); i++)
		{
			System.err.println((Plugin)plugins.elementAt(i));
			System.err.println();
		}
	}
	static class PluginSet
	{
		String name;
		String description;
		Vector plugins = new Vector();
		void install(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			for(int i = 0; i < plugins.size(); i++)
			{
				Plugin plugin = (Plugin)plugins.elementAt(i);
				if(plugin.canBeInstalled())
				{
					plugin.install(roster,installDirectory,
						downloadSource);
				}
			}
		}
		public String toString()
		{
			return plugins.toString();
		}
	}
	static class Plugin
	{
		String jar;
		String name;
		String description;
		String author;
		Vector branches = new Vector();
		String installed;
		String installedVersion;
		void checkIfInstalled()
		{
			// check if the plugin is already installed.
			// this is a bit of hack
			EditPlugin.JAR[] jars = jEdit.getPluginJARs();
			for(int i = 0; i < jars.length; i++)
			{
				String path = jars[i].getPath();
				if(!new File(path).exists())
					continue;
				if(MiscUtilities.getFileName(path).equals(jar))
				{
					installed = path;
					EditPlugin[] plugins = jars[i].getPlugins();
					if(plugins.length >= 1)
					{
						installedVersion = jEdit.getProperty(
							""plugin."" + plugins[0].getClassName()
							+ "".version"");
					}
					break;
				}
			}
			String[] notLoaded = jEdit.getNotLoadedPluginJARs();
			for(int i = 0; i < notLoaded.length; i++)
			{
				String path = notLoaded[i];
				if(MiscUtilities.getFileName(path).equals(jar))
				{
					installed = path;
					break;
				}
			}
		}
		/**
		 * Find the first branch compatible with the running jEdit release.
		 */
		Branch getCompatibleBranch()
		{
			for(int i = 0; i < branches.size(); i++)
			{
				Branch branch = (Branch)branches.elementAt(i);
				if(branch.canSatisfyDependencies())
					return branch;
			}
			return null;
		}
		boolean canBeInstalled()
		{
			Branch branch = getCompatibleBranch();
			return branch != null && !branch.obsolete;
		}
		void install(Roster roster, String installDirectory, boolean downloadSource)
		{
			if(installed != null)
				roster.addOperation(new Roster.Remove(installed));
			Branch branch = getCompatibleBranch();
			if(branch.obsolete)
				return;
			branch.satisfyDependencies(roster,installDirectory,
				downloadSource);
			if(installed != null)
			{
				installDirectory = MiscUtilities.getParentOfPath(
					installed);
			}
			roster.addOperation(new Roster.Install((downloadSource
				? branch.downloadSource : branch.download),
				installDirectory));
		}
		public String toString()
		{
			return name;
		}
	}
	static class Branch
	{
		String version;
		String date;
		String download;
		String downloadSource;
		boolean obsolete;
		Vector deps = new Vector();
		boolean canSatisfyDependencies()
		{
			for(int i = 0; i < deps.size(); i++)
			{
				Dependency dep = (Dependency)deps.elementAt(i);
				if(!dep.canSatisfy())
					return false;
			}
			return true;
		}
		void satisfyDependencies(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			for(int i = 0; i < deps.size(); i++)
			{
				Dependency dep = (Dependency)deps.elementAt(i);
				dep.satisfy(roster,installDirectory,downloadSource);
			}
		}
		public String toString()
		{
			return ""[version="" + version + "",download="" + download
				+ "",obsolete="" + obsolete + "",deps="" + deps + ""]"";
		}
	}
	static class Dependency
	{
		String what;
		String from;
		String to;
		// only used if what is ""plugin""
		String pluginName;
		Plugin plugin;
		Dependency(String what, String from, String to, String pluginName)
		{
			this.what = what;
			this.from = from;
			this.to = to;
			this.pluginName = pluginName;
		}
		boolean isSatisfied()
		{
			if(what.equals(""plugin""))
			{
				for(int i = 0; i < plugin.branches.size(); i++)
				{
					Branch branch = (Branch)plugin.branches
						.elementAt(i);
					if(plugin.installedVersion != null
						&&
					(from == null || MiscUtilities.compareVersions(
						plugin.installedVersion,from) >= 0)
						&&
					   (to == null || MiscUtilities.compareVersions(
					   	plugin.installedVersion,to) <= 0))
					{
						return true;
					}
				}
				return false;
			}
			else if(what.equals(""jdk""))
			{
				String javaVersion = System.getProperty(""java.version"").substring(0,3);
				if((from == null || MiscUtilities.compareVersions(
					javaVersion,from) >= 0)
					&&
				   (to == null || MiscUtilities.compareVersions(
				   	javaVersion,to) <= 0))
					return true;
				else
					return false;
			}
			else if(what.equals(""jedit""))
			{
				String build = jEdit.getBuild();
				if((from == null || MiscUtilities.compareVersions(
					build,from) >= 0)
					&&
				   (to == null || MiscUtilities.compareVersions(
				   	build,to) <= 0))
					return true;
				else
					return false;
			}
			else
			{
				Log.log(Log.ERROR,this,""Invalid dependency: "" + what);
				return false;
			}
		}
		boolean canSatisfy()
		{
			// new plugins can always be downloaded (assuming Mike
			// maintains plugin central properly)
			return (what.equals(""plugin"") || isSatisfied());
		}
		void satisfy(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			if(what.equals(""plugin""))
			{
				for(int i = 0; i < plugin.branches.size(); i++)
				{
					Branch branch = (Branch)plugin.branches
						.elementAt(i);
					if((plugin.installedVersion == null
						||
					MiscUtilities.compareVersions(
						plugin.installedVersion,branch.version) < 0)
						&&
					(from == null || MiscUtilities.compareVersions(
						branch.version,from) >= 0)
						&&
					   (to == null || MiscUtilities.compareVersions(
					   	branch.version,to) <= 0))
					{
						plugin.install(roster,installDirectory,
							downloadSource);
						return;
					}
				}
			}
		}
		public String toString()
		{
			return ""[what="" + what + "",from="" + from
				+ "",to="" + to + "",plugin="" + plugin + ""]"";
		}
	}
}
"
org.gjt.sp.jedit.pluginmgr.PluginListDownloadProgress,"/*
 * PluginListDownloadProgress.java - Plugin list download progress dialog
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
import com.microstar.xml.XmlException;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.InterruptedIOException;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
class PluginListDownloadProgress extends JDialog
{
	PluginListDownloadProgress(PluginManager window)
	{
		super(JOptionPane.getFrameForComponent(window),
			jEdit.getProperty(""plugin-list.progress.title""),true);
		this.window = window;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JLabel caption = new JLabel(jEdit.getProperty(""plugin-list.progress.caption""));
		caption.setBorder(new EmptyBorder(0,0,12,0));
		content.add(BorderLayout.NORTH,caption);
		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		JButton stop = new JButton(jEdit.getProperty(""plugin-list.progress.stop""));
		stop.addActionListener(new ActionHandler());
		stop.setMaximumSize(stop.getPreferredSize());
		box.add(stop);
		box.add(Box.createGlue());
		content.add(BorderLayout.CENTER,box);
		addWindowListener(new WindowHandler());
		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		pack();
		setLocationRelativeTo(window);
		setResizable(false);
		show();
	}
	PluginList getPluginList()
	{
		return list;
	}
	// private members
	private PluginManager window;
	private PluginList list;
	private DownloadThread thread;
	class DownloadThread extends Thread
	{
		public void run()
		{
			try
			{
				list = new PluginList();
				dispose();
			}
			catch(InterruptedIOException iio)
			{
				// do nothing, user clicked Stop
				dispose();
			}
			catch(XmlException xe)
			{
				dispose();
				int line = xe.getLine();
				String path = jEdit.getProperty(""plugin-manager.url"");
				String message = xe.getMessage();
				Log.log(Log.ERROR,this,path + "":"" + line
					+ "": "" + message);
				String[] pp = { path, String.valueOf(line), message };
				GUIUtilities.error(window,""plugin-list.xmlerror"",pp);
			}
			catch(Exception e)
			{
				dispose();
				Log.log(Log.ERROR,this,e);
				String[] pp = { e.toString() };
				GUIUtilities.error(window,""plugin-list.ioerror"",pp);
			}
		}
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			thread.interrupt();
		}
	}
	class WindowHandler extends WindowAdapter
	{
		boolean done;
		public void windowActivated(WindowEvent evt)
		{
			if(done)
				return;
			done = true;
			thread = new DownloadThread();
			thread.start();
		}
		public void windowClosing(WindowEvent evt)
		{
			thread.interrupt();
		}
	}
}
"
org.gjt.sp.jedit.pluginmgr.PluginListHandler,"/*
 * PluginListHandler.java - XML handler for the plugin list
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
import com.microstar.xml.*;
import java.io.*;
import java.util.Stack;
import org.gjt.sp.util.Log;
class PluginListHandler extends HandlerBase
{
	PluginListHandler(PluginList pluginList, String path)
	{
		this.pluginList = pluginList;
		this.path = path;
		stateStack = new Stack();
	}
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""plugins.dtd"".equals(systemId))
		{
			try
			{
				return new BufferedReader(new InputStreamReader(
					getClass().getResourceAsStream(
					""/org/gjt/sp/jedit/pluginmgr/plugins.dtd"")));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,""Error while opening""
					+ "" plugins.dtd:"");
				Log.log(Log.ERROR,this,e);
			}
		}
		return null;
	}
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();
		if(aname == ""NAME"")
			name = value;
		else if(aname == ""JAR"")
			jar = value;
		else if(aname == ""VERSION"")
			version = value;
		else if(aname == ""DATE"")
			date = value;
		else if(aname == ""OBSOLETE"")
			obsolete = (""TRUE"".equals(value));
		else if(aname == ""WHAT"")
			depWhat = value;
		else if(aname == ""FROM"")
			depFrom = value;
		else if(aname == ""TO"")
			depTo = value;
		else if(aname == ""PLUGIN"")
			depPlugin = value;
	}
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if(""PLUGINS"".equals(name))
			return;
		Log.log(Log.ERROR,this,path + "": DOCTYPE must be PLUGINS"");
	}
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);
		if(tag == ""DESCRIPTION"")
		{
			description = text;
		}
		else if(tag == ""PLUGIN_SET_ENTRY"")
			pluginSetEntry = text;
		else if(tag == ""AUTHOR"")
		{
			if(author != null && author.length() != 0)
				author = author + "", "" + text;
			else
				author = text;
		}
		else if(tag == ""DOWNLOAD"")
			download = text;
		else if(tag == ""DOWNLOAD_SOURCE"")
			downloadSource = text;
	}
	public void startElement(String tag)
	{
		tag = pushElement(tag);
		if(tag == ""PLUGIN_SET"")
		{
			description = null;
			pluginSet = new PluginList.PluginSet();
		}
		else if(tag == ""PLUGIN"")
		{
			description = null;
			author = null;
			branch = null;
			plugin = new PluginList.Plugin();
		}
		else if(tag == ""BRANCH"")
		{
			download = null;
			branch = new PluginList.Branch();
		}
	}
	public void endElement(String tag)
	{
		if(tag == null)
			return;
		else
			tag = tag.intern();
		popElement();
		if(tag == ""PLUGIN_SET"")
		{
			pluginList.addPluginSet(pluginSet);
			pluginSet = null;
			pluginSetEntry = null;
		}
		else if(tag == ""PLUGIN_SET_ENTRY"")
		{
			pluginSet.plugins.addElement(pluginSetEntry);
			pluginSetEntry = null;
		}
		else if(tag == ""PLUGIN"")
		{
			plugin.jar = jar;
			plugin.name = name;
			plugin.author = author;
			plugin.description = description;
			pluginList.addPlugin(plugin);
			jar = null;
			name = null;
			author = null;
		}
		else if(tag == ""BRANCH"")
		{
			branch.version = version;
			branch.date = date;
			branch.download = download;
			branch.downloadSource = downloadSource;
			branch.obsolete = obsolete;
			plugin.branches.addElement(branch);
			version = null;
			download = null;
			obsolete = false;
		}
		else if(tag == ""DEPEND"")
		{
			PluginList.Dependency dep = new PluginList.Dependency(
				depWhat,depFrom,depTo,depPlugin);
			branch.deps.addElement(dep);
			depWhat = null;
			depFrom = null;
			depTo = null;
			depPlugin = null;
		}
	}
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}
	public void endDocument()
	{
		pluginList.finished();
	}
	// end HandlerBase implementation
	// private members
	private String path;
	private PluginList pluginList;
	private PluginList.PluginSet pluginSet;
	private String pluginSetEntry;
	private PluginList.Plugin plugin;
	private String jar;
	private String author;
	private PluginList.Branch branch;
	private boolean obsolete;
	private String version;
	private String date;
	private String download;
	private String downloadSource;
	private String depWhat;
	private String depFrom;
	private String depTo;
	private String depPlugin;
	private String name;
	private String description;
	private Stack stateStack;
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();
		stateStack.push(name);
		return name;
	}
	private String peekElement()
	{
		return (String) stateStack.peek();
	}
	private String popElement()
	{
		return (String) stateStack.pop();
	}
}
"
org.gjt.sp.jedit.pluginmgr.PluginManager,"/*
 * PluginManager.java - Plugin manager window
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
public class PluginManager extends JDialog
{
	public PluginManager(View view)
	{
		super(view,jEdit.getProperty(""plugin-manager.title""),true);
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		JLabel caption = new JLabel(jEdit.getProperty(
			""plugin-manager.caption""));
		caption.setBorder(new EmptyBorder(0,0,6,0));
		content.add(BorderLayout.NORTH,caption);
		tree = new JTree();
		tree.setCellRenderer(new Renderer());
		tree.setRootVisible(false);
		tree.setVisibleRowCount(16);
		tree.addTreeSelectionListener(new TreeHandler());
		JPanel panel = new JPanel(new BorderLayout());
		panel.add(BorderLayout.CENTER,new JScrollPane(tree));
		JPanel panel2 = new JPanel(new BorderLayout());
		panel2.setBorder(new EmptyBorder(6,0,0,0));
		JPanel labelBox = new JPanel(new GridLayout(3,1,0,3));
		labelBox.setBorder(new EmptyBorder(0,0,0,12));
		labelBox.add(new JLabel(jEdit.getProperty(""plugin-manager""
			+ "".info.name""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""plugin-manager""
			+ "".info.author""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""plugin-manager""
			+ "".info.version""),SwingConstants.RIGHT));
		panel2.add(BorderLayout.WEST,labelBox);
		JPanel valueBox = new JPanel(new GridLayout(3,1,0,3));
		valueBox.add(name = new JLabel());
		valueBox.add(author = new JLabel());
		valueBox.add(version = new JLabel());
		panel2.add(BorderLayout.CENTER,valueBox);
		panel.add(BorderLayout.SOUTH,panel2);
		content.add(BorderLayout.CENTER,panel);
		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.add(Box.createGlue());
		remove = new JButton(jEdit.getProperty(""plugin-manager""
			+ "".remove""));
		remove.addActionListener(new ActionHandler());
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		update = new JButton(jEdit.getProperty(""plugin-manager""
			+ "".update""));
		update.addActionListener(new ActionHandler());
		buttons.add(update);
		buttons.add(Box.createHorizontalStrut(6));
		install = new JButton(jEdit.getProperty(""plugin-manager""
			+ "".install""));
		install.addActionListener(new ActionHandler());
		buttons.add(install);
		buttons.add(Box.createHorizontalStrut(6));
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(new ActionHandler());
		buttons.add(close);
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);
		updateTree();
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(view);
		show();
	}
	// private members
	private JTree tree;
	private JLabel name;
	private JLabel author;
	private JLabel version;
	private JButton remove;
	private JButton update;
	private JButton install;
	private JButton close;
	private void updateTree()
	{
		DefaultMutableTreeNode treeRoot = new DefaultMutableTreeNode();
		DefaultTreeModel treeModel = new DefaultTreeModel(treeRoot);
		DefaultMutableTreeNode loadedTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""plugin-manager.loaded""),true);
		DefaultMutableTreeNode notLoadedTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""plugin-manager.not-loaded""),true);
		DefaultMutableTreeNode newTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""plugin-manager.new""),true);
		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin plugin = plugins[i];
			String path = plugin.getJAR().getPath();
			if(!new File(path).exists())
			{
				// plugin was deleted
				continue;
			}
			if(plugin instanceof EditPlugin.Broken)
			{
				Entry entry = new Entry(path,plugin.getClassName(),true);
				notLoadedTree.add(new DefaultMutableTreeNode(entry));
			}
			else
			{
				Entry entry = new Entry(path,plugin.getClassName(),false);
				loadedTree.add(new DefaultMutableTreeNode(entry));
			}
		}
		if(notLoadedTree.getChildCount() != 0)
			treeRoot.add(notLoadedTree);
		if(loadedTree.getChildCount() != 0)
			treeRoot.add(loadedTree);
		String[] newPlugins = jEdit.getNotLoadedPluginJARs();
		for(int i = 0; i < newPlugins.length; i++)
		{
			Entry entry = new Entry(newPlugins[i],null,false);
			newTree.add(new DefaultMutableTreeNode(entry));
		}
		if(newTree.getChildCount() != 0)
			treeRoot.add(newTree);
		tree.setModel(treeModel);
		for(int i = 0; i < tree.getRowCount(); i++)
			tree.expandRow(i);
		remove.setEnabled(false);
		name.setText(null);
		author.setText(null);
		version.setText(null);
	}
	class Entry
	{
		String clazz;
		String name, version, author;
		Vector jars;
		boolean broken;
		Entry(String path, String clazz, boolean broken)
		{
			Entry.this.clazz = clazz;
			Entry.this.broken = broken;
			jars = new Vector();
			jars.addElement(path);
			if(clazz == null)
				Entry.this.name = path;
			else
			{
				Entry.this.name = jEdit.getProperty(""plugin."" + clazz + "".name"");
				if(name == null)
					name = clazz;
				Entry.this.version = jEdit.getProperty(""plugin."" + clazz
					+ "".version"");
				Entry.this.author = jEdit.getProperty(""plugin."" + clazz
					+ "".author"");
				String jarsProp = jEdit.getProperty(""plugin."" + clazz
					+ "".jars"");
				if(jarsProp != null)
				{
					String directory = MiscUtilities.getParentOfPath(path);
					StringTokenizer st = new StringTokenizer(jarsProp);
					while(st.hasMoreElements())
					{
						jars.addElement(MiscUtilities.constructPath(
							directory,st.nextToken()));
					}
				}
			}
		}
		public String toString()
		{
			return Entry.this.name;
		}
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == close)
				dispose();
			else if(source == remove)
			{
				TreePath[] selected = tree.getSelectionModel()
					.getSelectionPaths();
				StringBuffer buf = new StringBuffer();
				Roster roster = new Roster();
				for(int i = 0; i < selected.length; i++)
				{
					Object last = ((DefaultMutableTreeNode)
						selected[i].getLastPathComponent())
						.getUserObject();
					if(last instanceof Entry)
					{
						Entry entry = (Entry)last;
						for(int j = 0; j < entry.jars.size(); j++)
						{
							String jar = (String)entry.jars.elementAt(j);
							if(buf.length() != 0)
								buf.append('\n');
							buf.append(jar);
							roster.addOperation(new Roster.Remove(jar));
						}
					}
				}
				String[] args = { buf.toString() };
				if(GUIUtilities.confirm(PluginManager.this,
					""plugin-manager.remove-confirm"",args,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.QUESTION_MESSAGE)
					== JOptionPane.YES_OPTION)
				{
					new PluginManagerProgress(PluginManager.this,
						jEdit.getProperty(""plugin-manager.progress""
						+ "".removing-task""),roster);
					updateTree();
				}
			}
			else if(source == update)
			{
				PluginList list = new PluginListDownloadProgress(PluginManager.this)
					.getPluginList();
				if(list == null)
					return;
				if(jEdit.getSettingsDirectory() == null)
				{
					GUIUtilities.error(PluginManager.this,
						""no-settings"",null);
					return;
				}
				Vector plugins = new Vector();
				for(int i = 0; i < list.plugins.size(); i++)
				{
					PluginList.Plugin plugin = (PluginList.Plugin)list
						.plugins.elementAt(i);
					PluginList.Branch branch = plugin.getCompatibleBranch();
					if(branch != null
						&& plugin.installedVersion != null
						&& MiscUtilities.compareVersions(branch.version,
						plugin.installedVersion) > 0)
						plugins.addElement(plugin);
				}
				if(plugins.size() == 0)
				{
					GUIUtilities.message(PluginManager.this,
						""plugin-manager.up-to-date"",null);
					return;
				}
				Roster roster = new Roster();
				new InstallPluginsDialog(PluginManager.this,plugins,
					InstallPluginsDialog.UPDATE)
					.installPlugins(roster);
				if(roster.isEmpty())
					return;
				new PluginManagerProgress(PluginManager.this,
					jEdit.getProperty(""plugin-manager.progress""
					+ "".updating-task""),roster);
				updateTree();
			}
			else if(source == install)
			{
				PluginList list = new PluginListDownloadProgress(PluginManager.this)
					.getPluginList();
				if(list == null)
					return;
				if(jEdit.getSettingsDirectory() == null
					&& jEdit.getJEditHome() == null)
				{
					GUIUtilities.error(PluginManager.this,""no-settings"",null);
					return;
				}
				Vector plugins = new Vector();
				for(int i = 0; i < list.plugins.size(); i++)
				{
					PluginList.Plugin plugin = (PluginList.Plugin)list
						.plugins.elementAt(i);
					if(plugin.installed == null
						&& plugin.canBeInstalled())
						plugins.addElement(plugin);
				}
				Roster roster = new Roster();
				new InstallPluginsDialog(PluginManager.this,plugins,
					InstallPluginsDialog.INSTALL)
					.installPlugins(roster);
				if(roster.isEmpty())
					return;
				new PluginManagerProgress(PluginManager.this,
					jEdit.getProperty(""plugin-manager.progress""
					+ "".installing-task""),roster);
				updateTree();
			}
		}
	}
	class TreeHandler implements TreeSelectionListener
	{
		public void valueChanged(TreeSelectionEvent evt)
		{
			TreePath selection = evt.getPath();
			DefaultMutableTreeNode node;
			if(selection == null)
			{
				node = null;
			}
			else
			{
				node = (DefaultMutableTreeNode)
					selection.getLastPathComponent();
			}
			name.setText(null);
			author.setText(null);
			version.setText(null);
			if(node != null && node.isLeaf()
				&& node.getUserObject() instanceof Entry)
			{
				remove.setEnabled(true);
				Entry entry = (Entry)node.getUserObject();
				if(entry.clazz != null)
				{
					name.setText(entry.name);
					author.setText(entry.author);
					version.setText(entry.version);
				}
			}
			else
				remove.setEnabled(false);
		}
	}
	class Renderer extends DefaultTreeCellRenderer
	{
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean selected, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			super.getTreeCellRendererComponent(tree,value,
				selected,expanded,leaf,row,hasFocus);
			setIcon(null);
			return this;
		}
	}
}
"
org.gjt.sp.jedit.pluginmgr.PluginManagerProgress,"/*
 * PluginManagerProgress.java - Plugin download progress meter
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
public class PluginManagerProgress extends JDialog
{
	public PluginManagerProgress(JDialog dialog, String caption, Roster roster)
	{
		super(JOptionPane.getFrameForComponent(dialog),caption,true);
		this.roster = roster;
		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);
		globalProgress = new JProgressBar();
		globalProgress.setStringPainted(true);
		globalProgress.setString(caption);
		count = roster.getOperationCount();
		globalProgress.setMaximum(count);
		content.add(BorderLayout.NORTH,globalProgress);
		localProgress = new JProgressBar();
		localProgress.setStringPainted(true);
		content.add(BorderLayout.CENTER,localProgress);
		stop = new JButton(jEdit.getProperty(""plugin-manager.progress.stop""));
		stop.addActionListener(new ActionHandler());
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.add(Box.createGlue());
		panel.add(stop);
		panel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,panel);
		addWindowListener(new WindowHandler());
		pack();
		Dimension screen = getToolkit().getScreenSize();
		Dimension size = getSize();
		size.width = Math.max(size.width,500);
		setSize(size);
		setLocationRelativeTo(dialog);
		show();
	}
	public void removing(String plugin)
	{
		String[] args = { plugin };
		showMessage(jEdit.getProperty(""plugin-manager.progress.removing"",args));
		stop.setEnabled(true);
	}
	public void downloading(String plugin)
	{
		String[] args = { plugin };
		showMessage(jEdit.getProperty(""plugin-manager.progress.downloading"",args));
		stop.setEnabled(true);
	}
	public void installing(String plugin)
	{
		String[] args = { plugin };
		showMessage(jEdit.getProperty(""plugin-manager.progress.installing"",args));
		stop.setEnabled(false);
	}
	public void setMaximum(final int total)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				localProgress.setMaximum(total);
			}
		});
	}
	public void setValue(final int value)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				localProgress.setValue(value);
			}
		});
	}
	public void done(final boolean ok)
	{
		this.ok |= ok;
		try
		{
			if(!ok || done == count)
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						dispose();
						if(ok)
						{
							GUIUtilities.message(PluginManagerProgress.this,
								""plugin-manager.done"",null);
						}
						else
						{
							// user will see an error in any case
							//GUIUtilities.message(PluginManagerProgress.this,
							//	""plugin-manager.failed"",null);
						}
					}
				});
			}
			else
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						globalProgress.setValue(done++);
						localProgress.setValue(0);
					}
				});
			}
		}
		catch(Exception e)
		{
		}
	}
	public boolean isOK()
	{
		return ok;
	}
	// private members
	private Thread thread;
	private JProgressBar globalProgress, localProgress;
	private JButton stop;
	private int count;
	private int done = 1;
	private boolean ok;
	private Roster roster;
	private void showMessage(final String msg)
	{
		try
		{
			SwingUtilities.invokeAndWait(new Runnable()
			{
				public void run()
				{
					localProgress.setString(msg);
				}
			});
		}
		catch(Exception e)
		{
		}
		Thread.yield();
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == stop)
			{
				thread.interrupt();
				dispose();
			}
		}
	}
	class WindowHandler extends WindowAdapter
	{
		boolean done;
		public void windowActivated(WindowEvent evt)
		{
			if(done)
				return;
			done = true;
			thread = new RosterThread();
			thread.start();
		}
		public void windowClosing(WindowEvent evt)
		{
			thread.interrupt();
			dispose();
		}
	}
	class RosterThread extends Thread
	{
		RosterThread()
		{
			super(""Plugin manager thread"");
		}
		public void run()
		{
			roster.performOperations(PluginManagerProgress.this);
		}
	}
}
"
org.gjt.sp.jedit.pluginmgr.Roster,"/*
 * Roster.java - A list of things to do, used in various places
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.pluginmgr;
import javax.swing.JOptionPane;
import java.awt.Component;
import java.io.*;
import java.net.*;
import java.util.zip.*;
import java.util.*;
import org.gjt.sp.jedit.io.VFSManager; // we use VFSManager.error() method
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
class Roster
{
	Roster()
	{
		operations = new Vector();
	}
	void addOperation(Operation op)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			if(operations.elementAt(i).equals(op))
				return;
		}
		operations.addElement(op);
	}
	int getOperationCount()
	{
		return operations.size();
	}
	boolean isEmpty()
	{
		return operations.size() == 0;
	}
	boolean performOperations(PluginManagerProgress progress)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			Operation op = (Operation)operations.elementAt(i);
			if(op.perform(progress))
				progress.done(true);
			else
			{
				progress.done(false);
				return false;
			}
			if(Thread.interrupted())
				return false;
		}
		return true;
	}
	// private members
	private Vector operations;
	static interface Operation
	{
		boolean perform(PluginManagerProgress progress);
		boolean equals(Object o);
	}
	static class Remove implements Operation
	{
		Remove(String plugin)
		{
			this.plugin = plugin;
		}
		public boolean perform(PluginManagerProgress progress)
		{
			progress.removing(MiscUtilities.getFileName(plugin));
			// close JAR file
			EditPlugin.JAR jar = jEdit.getPluginJAR(plugin);
			if(jar != null)
				jar.getClassLoader().closeZipFile();
			// move JAR first
			File jarFile = new File(plugin);
			File srcFile = new File(plugin.substring(0,plugin.length() - 4));
			boolean ok = true;
			ok &= deleteRecursively(jarFile);
			if(srcFile.exists())
				ok &= deleteRecursively(srcFile);
			String[] args = { plugin };
			if(!ok)
				GUIUtilities.error(progress,""plugin-manager.remove-failed"",args);
			return ok;
		}
		public boolean equals(Object o)
		{
			if(o instanceof Remove
				&& ((Remove)o).plugin.equals(plugin))
				return true;
			else
				return false;
		}
		// private members
		private String plugin;
		private boolean deleteRecursively(File file)
		{
			Log.log(Log.NOTICE,this,""Deleting "" + file + "" recursively"");
			boolean ok = true;
			if(file.isDirectory())
			{
				String path = file.getPath();
				String[] children = file.list();
				for(int i = 0; i < children.length; i++)
				{
					ok &= deleteRecursively(new File(path,children[i]));
				}
			}
			ok &= file.delete();
			return ok;
		}
	}
	static class Install implements Operation
	{
		Install(String url, String installDirectory)
		{
			// catch those hooligans passing null urls
			if(url == null)
				throw new NullPointerException();
			this.url = url;
			this.installDirectory = installDirectory;
		}
		public boolean perform(PluginManagerProgress progress)
		{
			try
			{
				String fileName = MiscUtilities.getFileName(url);
				progress.downloading(fileName);
				String path = download(progress,fileName,url);
				if(path == null)
				{
					// interrupted download
					return false;
				}
				progress.installing(fileName);
				install(progress,path,installDirectory);
				return true;
			}
			catch(InterruptedIOException iio)
			{
				// do nothing, user clicked 'Stop'
				return false;
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] args = { io.getMessage() };
				VFSManager.error(progress,""ioerror"",args);
				return false;
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
				return false;
			}
		}
		public boolean equals(Object o)
		{
			if(o instanceof Install
				&& ((Install)o).url.equals(url))
			{
				/* even if installDirectory is different */
				return true;
			}
			else
				return false;
		}
		// private members
		private String url;
		private String installDirectory;
		private String download(PluginManagerProgress progress,
			String fileName, String url) throws Exception
		{
			URLConnection conn = new URL(url).openConnection();
			progress.setMaximum(Math.max(0,conn.getContentLength()));
			String path = MiscUtilities.constructPath(getDownloadDir(),fileName);
			if(!copy(progress,conn.getInputStream(),
				new FileOutputStream(path),true,true))
				return null;
			return path;
		}
		private boolean install(PluginManagerProgress progress,
			String path, String dir) throws Exception
		{
			progress.setMaximum(1);
			ZipFile zipFile = new ZipFile(path);
			Enumeration enum = zipFile.entries();
			while(enum.hasMoreElements())
			{
				ZipEntry entry = (ZipEntry)enum.nextElement();
				String name = entry.getName().replace('/',File.separatorChar);
				File file = new File(dir,name);
				if(entry.isDirectory())
					file.mkdirs();
				else
				{
					new File(file.getParent()).mkdirs();
					copy(progress,zipFile.getInputStream(entry),
						new FileOutputStream(file),false,false);
				}
			}
			new File(path).delete();
			progress.setValue(1);
			return true;
		}
		private boolean copy(PluginManagerProgress progress,
			InputStream in, OutputStream out, boolean canStop,
			boolean doProgress) throws Exception
		{
			in = new BufferedInputStream(in);
			out = new BufferedOutputStream(out);
			byte[] buf = new byte[4096];
			int copied = 0;
loop:			for(;;)
			{
				int count = in.read(buf,0,buf.length);
				if(count == -1)
					break loop;
				if(doProgress)
				{
					copied += count;
					progress.setValue(copied);
				}
				out.write(buf,0,count);
				if(canStop && Thread.interrupted())
				{
					in.close();
					out.close();
					return false;
				}
			}
			in.close();
			out.close();
			return true;
		}
		static File downloadDir;
		static String getDownloadDir()
		{
			if(downloadDir == null)
			{
				String settings = jEdit.getSettingsDirectory();
				if(settings == null)
					settings = System.getProperty(""user.home"");
				downloadDir = new File(MiscUtilities.constructPath(
					settings,""PluginManager.download""));
				downloadDir.mkdirs();
			}
			return downloadDir.getPath();
		}
	}
}
"
org.gjt.sp.jedit.proto.jeditresource.Handler,"/*
 * Handler.java - jEdit plugin list URL protocol handler
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.proto.jeditresource;
import java.io.IOException;
import java.net.*;
public class Handler extends URLStreamHandler
{
	public URLConnection openConnection(URL url)
		throws IOException
	{
		PluginResURLConnection c = new PluginResURLConnection(url);
		c.connect();
		return c;
	}
}
"
org.gjt.sp.jedit.proto.jeditresource.PluginResURLConnection,"/*
 * PluginResURLConnection.java - jEdit plugin resource URL connection
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.proto.jeditresource;
import java.io.*;
import java.net.*;
import org.gjt.sp.jedit.*;
public class PluginResURLConnection extends URLConnection
{
	public PluginResURLConnection(URL url)
		throws IOException
	{
		super(url);
		String file = url.getFile();
		int index = file.indexOf('!',0);
		if(index == -1)
		{
			plugin = null;
			resource = file;
		}
		else
		{
			int start;
			if(file.charAt(0) == '/')
				start = 1;
			else
				start = 0;
			plugin = file.substring(start,index);
			resource = file.substring(index + 1);
		}
		if(plugin != null && resource.startsWith(""/""))
			resource = resource.substring(1);
	}
	public void connect() throws IOException
	{
		if(!connected)
		{
			if(plugin == null)
			{
				in = jEdit.class.getResourceAsStream(resource);
			}
			else
			{
				EditPlugin.JAR[] plugins = jEdit.getPluginJARs();
				for(int i = 0; i < plugins.length; i++)
				{
					EditPlugin.JAR jar = plugins[i];
					if(MiscUtilities.getFileName(jar.getPath())
						.equalsIgnoreCase(plugin))
					{
						in = jar.getClassLoader()
							.getResourceAsStream(
							resource);
						break;
					}
				}
			}
			if(in == null)
			{
				throw new IOException(""Resource not found: ""
					+ resource);
			}
			connected = true;
		}
	}
	public InputStream getInputStream()
		throws IOException
	{
		connect();
		return in;
	}
	public String getHeaderField(String name)
	{
		if(name.equals(""content-type""))
		{
			if(resource.endsWith("".html""))
				return ""text/html"";
			else if(resource.endsWith("".txt""))
				return ""text/plain"";
			else if(resource.endsWith("".rtf""))
				return ""text/rtf"";
			else if(resource.endsWith("".gif""))
				return ""image/gif"";
			else if(resource.endsWith("".jpg"")
				|| resource.endsWith("".jpeg""))
				return ""image/jpeg"";
			else
				return null;
		}
		else
			return null;
	}
	// private members
	private InputStream in;
	private String plugin;
	private String resource;
}
"
org.gjt.sp.jedit.search.AllBufferSet,"/*
 * AllBufferSet.java - All buffer matcher
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import gnu.regexp.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * A file set for searching all open buffers.
 * @author Slava Pestov
 * @version $Id: AllBufferSet.java,v 1.10 2000/11/24 06:48:35 sp Exp $
 */
public class AllBufferSet extends BufferListSet
{
	/**
	 * Creates a new all buffer set.
	 * @param glob The filename glob
	 * @since jEdit 2.7pre3
	 */
	public AllBufferSet(String glob)
	{
		super(listFiles(glob));
		this.glob = glob;
	}
	/**
	 * Returns the filename filter.
	 * @since jEdit 2.7pre3
	 */
	public String getFileFilter()
	{
		return glob;
	}
	/**
	 * Returns the BeanShell code that will recreate this file set.
	 * @since jEdit 2.7pre3
	 */
	public String getCode()
	{
		return ""new AllBufferSet(\"""" + MiscUtilities.charsToEscapes(glob)
			+ ""\"")"";
	}
	// private members
	private String glob;
	private static Vector listFiles(String glob)
	{
		Buffer[] buffers = jEdit.getBuffers();
		Vector vector = new Vector(buffers.length);
		RE filter;
		try
		{
			filter = new RE(MiscUtilities.globToRE(glob));
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,DirectoryListSet.class,e);
			return vector;
		}
		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			if(filter.isMatch(buffer.getName()))
				vector.addElement(buffer.getPath());
		}
		return vector;
	}
}
"
org.gjt.sp.jedit.search.BoyerMooreSearchMatcher,"/*
 * BoyerMooreSearchMatcher.java - Literal pattern String matcher utilizing the
 *         Boyer-Moore algorithm
 * Copyright (C) 1999, 2000 mike dillon
 * Portions copyright (C) 2001 Tom Locke
 * Portions copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import bsh.NameSpace;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.BeanShell;
import org.gjt.sp.util.Log;
public class BoyerMooreSearchMatcher implements SearchMatcher
{
	/**
	 * Creates a new string literal matcher.
	 */
	public BoyerMooreSearchMatcher(String pattern, String replace,
		boolean ignoreCase, boolean reverseSearch,
		boolean beanshell, String replaceMethod)
	{
		if (ignoreCase)
		{
			this.pattern = pattern.toUpperCase().toCharArray();
		}
		else
		{
			this.pattern = pattern.toCharArray();
		}
		if (reverseSearch)
		{
			char[] tmp = new char[this.pattern.length];
			for (int i = 0; i < tmp.length; i++)
			{
				tmp[i] = this.pattern[this.pattern.length - (i + 1)];
			}
			this.pattern = tmp;
		}
		this.replace = replace;
		this.ignoreCase = ignoreCase;
		this.reverseSearch = reverseSearch;
		this.beanshell = beanshell;
		if(beanshell)
		{
			this.replaceMethod = replaceMethod;
			replaceNS = new NameSpace(BeanShell.getNameSpace(),
				""search and replace"");
		}
		generateSkipArray();
		generateSuffixArray();
	}
	/**
	 * Returns the offset of the first match of the specified text
	 * within this matcher.
	 * @param text The text to search in
	 * @return an array where the first element is the start offset
	 * of the match, and the second element is the end offset of
	 * the match
	 */
	public int[] nextMatch(Segment text)
	{
		int pos = match(text.array, text.offset, text.offset + text.count);
		if (pos == -1)
		{
			return null;
		}
		else
		{
			return new int[] { pos - text.offset, pos + pattern.length
				- text.offset };
		}
	}
	/**
	 * Returns the specified text, with any substitution specified
	 * within this matcher performed.
	 * @param text The text
	 */
	public String substitute(String text) throws Exception
	{
		if(beanshell)
		{
			replaceNS.setVariable(""_0"",text);
			Object obj = BeanShell.runCachedBlock(replaceMethod,
				null,replaceNS);
			if(obj == null)
				return null;
			else
				return obj.toString();
		}
		else
			return replace;
	}
	/*
	 *  a good introduction to the Boyer-Moore fast string matching
	 *  algorithm may be found on Moore's website at:
	 *
	 *   http://www.cs.utexas.edu/users/moore/best-ideas/string-searching/
	 *
	 */
	public int match(char[] text, int offset, int length)
	{
		// position variable for pattern start
		int anchor = reverseSearch ? length - 1 : offset;
		// position variable for pattern test position
		int pos;
		// last possible start position of a match with this pattern;
		// this is negative if the pattern is longer than the text
		// causing the search loop below to immediately fail
		int last_anchor = reverseSearch
			? offset + pattern.length - 1
			: length - pattern.length;
		// each time the pattern is checked, we start this many
		// characters ahead of 'anchor'
		int pattern_end = pattern.length - 1;
		char ch = 0;
		int bad_char;
		int good_suffix;
		// the search works by starting the anchor (first character
		// of the pattern) at the initial offset. as long as the
		// anchor is far enough from the enough of the text for the
		// pattern to match, and until the pattern matches, we
		// compare the pattern to the text from the last character
		// to the first character in reverse order. where a character
		// in the pattern mismatches, we use the two heuristics
		// based on the mismatch character and its position in the
		// pattern to determine the furthest we can move the anchor
		// without missing any potential pattern matches.
SEARCH:
		while (reverseSearch ? anchor >= last_anchor : anchor <= last_anchor)
		{
			for (pos = pattern_end; pos >= 0; --pos)
			{
				int idx = reverseSearch ? anchor - pos : anchor + pos;
				ch = ignoreCase
					? Character.toUpperCase(text[idx])
					: text[idx];
				// pattern test
				if (ch != pattern[pos])
				{
					// character mismatch, determine how many characters to skip
					// heuristic #1
					bad_char = pos - skip[getSkipIndex(ch)];
					// heuristic #2
					good_suffix = suffix[pos];
					// skip the greater of the two distances provided by the
					// heuristics
					int skip = (bad_char > good_suffix) ? bad_char : good_suffix;
					anchor += reverseSearch ? -skip : skip;
					// go back to the while loop
					continue SEARCH;
				}
			}
			// MATCH: return the position of its first character
			return (reverseSearch ? anchor - pattern_end : anchor);
		}
		// MISMATCH: return -1 as defined by API
		return -1;
	}
	// private members
	private char[] pattern;
	private String replace;
	private boolean ignoreCase;
	private boolean reverseSearch;
	private boolean beanshell;
	private String replaceMethod;
	private NameSpace replaceNS;
	// Boyer-Moore member fields
	private int[] skip;
	private int[] suffix;
	// Boyer-Moore helper methods
	/*
	 *  the 'skip' array is used to determine for each index in the
	 *  hashed alphabet how many characters can be skipped if
	 *  a mismatch occurs on a characater hashing to that index.
	 */
	private void generateSkipArray()
	{
		// initialize the skip array to all zeros
		skip = new int[256];
		// leave the table cleanly-initialized for an empty pattern
		if (pattern.length == 0) return;
		int pos = 0;
		do
		{
			skip[getSkipIndex(pattern[pos])] = pos;
		}
		while (++pos < pattern.length);
	}
	/*
	 *  to avoid our skip table having a length of 2 ^ 16, we hash each
	 *  character of the input into a character in the alphabet [\x00-\xFF]
	 *  using the lower 8 bits of the character's value (resulting in
	 *  a more reasonable skip table of length 2 ^ 8).
	 *
	 *  the result of this is that more than one character can hash to the
	 *  same index, but since the skip table encodes the position of
	 *  occurence of the character furthest into the string with a particular
	 *  index (whether or not it is the only character with that index), an
	 *  index collision only means that that this heuristic will give a
	 *  sub-optimal skip (i.e. a complete skip table could use the differences
	 *  between colliding characters to maximal effect, at the expense of
	 *  building a table that is over 2 orders of magnitude larger and very
	 *  sparse).
	 */
	private static final int getSkipIndex(char ch)
	{
		return ((int) ch) & 0x000000FF;
	}
	/*
	 *  XXX: hairy code that is basically just a functional(?) port of some
	 *  other code i barely understood
	 */
	private void generateSuffixArray()
	{
		int m = pattern.length;
		int j = m + 1;
		suffix = new int[j];
		int[] tmp = new int[j];
		tmp[m] = j;
		for (int i = m; i > 0; --i)
		{
			while (j <= m && pattern[i - 1] != pattern[j - 1])
			{
				if (suffix[j] == 0)
				{
					suffix[j] = j - i;
				}
				j = tmp[j];
			}
			tmp[i - 1] = --j;
		}
		int k = tmp[0];
		for (j = 0; j <= m; j++)
		{
			// the code above builds a 1-indexed suffix array,
			// but we shift it to be 0-indexed, ignoring the
			// original 0-th element
			if (j > 0)
			{
				suffix[j - 1] = (suffix[j] == 0) ? k : suffix[j];
			}
			if (j == k)
			{
				k = tmp[k];
			}
		}
	}
}
"
org.gjt.sp.jedit.search.BufferListSet,"/*
 * BufferListSet.java - Buffer list matcher
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import javax.swing.SwingUtilities;
import java.util.Vector;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * A file set for searching a user-specified list of buffers.
 * @author Slava Pestov
 * @version $Id: BufferListSet.java,v 1.19 2001/08/23 07:39:09 sp Exp $
 */
public class BufferListSet implements SearchFileSet
{
	/**
	 * Creates a new buffer list search set. This constructor is
	 * only used by the multifile settings dialog box.
	 * @param files The path names to search
	 */
	public BufferListSet(Object[] files)
	{
		this.files = new Vector(files.length);
		for(int i = 0; i < files.length; i++)
		{
			this.files.addElement(((Buffer)files[i]).getPath());
		}
	}
	/**
	 * Creates a new buffer list search set.
	 * @param files The path names to search
	 */
	public BufferListSet(Vector files)
	{
		this.files = files;
	}
	/**
	 * Returns the first buffer to search.
	 * @param view The view performing the search
	 */
	public Buffer getFirstBuffer(View view)
	{
		return getBuffer((String)files.elementAt(0));
	}
	/**
	 * Returns the next buffer to search.
	 * @param view The view performing the search
	 * @param buffer The last buffer searched
	 */
	public Buffer getNextBuffer(View view, Buffer buffer)
	{
		if(buffer == null)
		{
			buffer = view.getBuffer();
			for(int i = 0; i < files.size(); i++)
			{
				if(files.elementAt(i).equals(buffer.getPath()))
					return buffer;
			}
			return getFirstBuffer(view);
		}
		else
		{
			// -1 so that the last isn't checked
			for(int i = 0; i < files.size() - 1; i++)
			{
				if(files.elementAt(i).equals(buffer.getPath()))
					return getBuffer((String)files.elementAt(i+1));
			}
			return null;
		}
	}
	/**
	 * Called if the specified buffer was found to have a match.
	 * @param buffer The buffer
	 */
	public void matchFound(final Buffer buffer)
	{
		// HyperSearch runs stuff in another thread
		if(!SwingUtilities.isEventDispatchThread())
		{
			try
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						jEdit.commitTemporary(buffer);
					}
				});
			}
			catch(Exception e)
			{
			}
		}
		else
			jEdit.commitTemporary(buffer);
	}
	/**
	 * Returns the number of buffers in this file set.
	 */
	public int getBufferCount()
	{
		return files.size();
	}
	/**
	 * Returns if this fileset is valid (ie, has one or more buffers
	 * in it.
	 */
	public boolean isValid()
	{
		return files.size() != 0;
	}
	/**
	 * Returns the BeanShell code to recreate this fileset.
	 */
	public String getCode()
	{
		// not supported for arbitriary filesets
		return null;
	}
	// private members
	private Vector files;
	private Buffer getBuffer(final String path)
	{
		// HyperSearch runs stuff in another thread
		if(!SwingUtilities.isEventDispatchThread())
		{
			final Buffer[] retVal = new Buffer[1];
			try
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						retVal[0] = jEdit.openTemporary(null,null,
							path,false);
					}
				});
				return retVal[0];
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
				return null;
			}
		}
		else
			return jEdit.openTemporary(null,null,path,false);
	}
}
"
org.gjt.sp.jedit.search.CharIndexedSegment,"/*
 * CharIndexedSegment.java
 * Copyright (C) 1998 Wes Biggs
 * Copyright (C) 2000 Slava Pestov
 *
 * This library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Library General Public License as published
 * by the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
package org.gjt.sp.jedit.search;
import java.io.Serializable;
import javax.swing.text.Segment;
import gnu.regexp.*;
public class CharIndexedSegment implements CharIndexed, Serializable
{
	private Segment seg;
	private int m_index;
	CharIndexedSegment(Segment seg, int index)
	{
		this.seg = seg;
		m_index = index;
	}
	public char charAt(int index)
	{
		return ((m_index + index) < seg.count) ? seg.array[seg.offset
			+ m_index + index] : CharIndexed.OUT_OF_BOUNDS;
	}
	public boolean isValid()
	{
		return (m_index < seg.count);
	}
	public boolean move(int index)
	{
		return ((m_index += index) < seg.count);
	}
}
"
org.gjt.sp.jedit.search.CurrentBufferSet,"/*
 * CurrentBufferSet.java - Current buffer matcher
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import org.gjt.sp.jedit.*;
/**
 * A file set for searching the current buffer.
 * @author Slava Pestov
 * @version $Id: CurrentBufferSet.java,v 1.8 2000/11/24 06:48:35 sp Exp $
 */
public class CurrentBufferSet implements SearchFileSet
{
	/**
	 * Returns the first buffer to search.
	 * @param view The view performing the search
	 */
	public Buffer getFirstBuffer(View view)
	{
		return view.getBuffer();
	}
	/**
	 * Returns the next buffer to search.
	 * @param view The view performing the search
	 * @param buffer The last buffer searched
	 */
	public Buffer getNextBuffer(View view, Buffer buffer)
	{
		if(buffer == null)
			return view.getBuffer();
		else
			return null;
	}
	/**
	 * Called if the specified buffer was found to have a match.
	 * @param buffer The buffer
	 */
	public void matchFound(Buffer buffer) {}
	/**
	 * Returns the number of buffers in this file set.
	 */
	public int getBufferCount()
	{
		return 1;
	}
	/**
	 * Returns the BeanShell code that will recreate this file set.
	 * @since jEdit 2.7pre3
	 */
	public String getCode()
	{
		return ""new CurrentBufferSet()"";
	}
}
/*
 * ChangeLog:
 * $Log: CurrentBufferSet.java,v $
 * Revision 1.8  2000/11/24 06:48:35  sp
 * Caret position history
 *
 * Revision 1.7  2000/05/14 10:55:22  sp
 * Tool bar editor started, improved view registers dialog box
 *
 * Revision 1.6  1999/11/28 00:33:07  sp
 * Faster directory search, actions slimmed down, faster exit/close-all
 *
 * Revision 1.5  1999/10/10 06:38:45  sp
 * Bug fixes and quicksort routine
 *
 * Revision 1.4  1999/10/02 01:12:36  sp
 * Search and replace updates (doesn't work yet), some actions moved to TextTools
 *
 * Revision 1.3  1999/06/09 07:28:10  sp
 * Multifile search and replace tweaks, removed console.html
 *
 * Revision 1.2  1999/06/09 05:22:11  sp
 * Find next now supports multi-file searching, minor Perl mode tweak
 *
 * Revision 1.1  1999/06/03 08:24:13  sp
 * Fixing broken CVS
 *
 */
"
org.gjt.sp.jedit.search.DirectoryListSet,"/*
 * DirectoryListSet.java - Directory list matcher
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import gnu.regexp.RE;
import java.io.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * Recursive directory search.
 * @author Slava Pestov
 * @version $Id: DirectoryListSet.java,v 1.7 2000/11/24 06:48:35 sp Exp $
 */
public class DirectoryListSet extends BufferListSet
{
	public DirectoryListSet(String directory, String glob, boolean recurse)
	{
		super(listFiles(directory,glob,recurse));
		this.directory = directory;
		this.glob = glob;
		this.recurse = recurse;
	}
	public String getDirectory()
	{
		return directory;
	}
	public String getFileFilter()
	{
		return glob;
	}
	public boolean isRecursive()
	{
		return recurse;
	}
	/**
	 * Returns the BeanShell code that will recreate this file set.
	 * @since jEdit 2.7pre3
	 */
	public String getCode()
	{
		return ""new DirectoryListSet(\"""" + MiscUtilities.charsToEscapes(directory)
			+ ""\"",\"""" + MiscUtilities.charsToEscapes(glob) + ""\"",""
			+ recurse + "")"";
	}
	// private members
	private String directory;
	private String glob;
	private boolean recurse;
	/**
	 * One day this might become public and move to MiscUtilities...
	 */
	private static Vector listFiles(String directory,
		String glob, boolean recurse)
	{
		Log.log(Log.DEBUG,DirectoryListSet.class,""Searching in ""
			+ directory);
		Vector files = new Vector(50);
		RE filter;
		try
		{
			filter = new RE(MiscUtilities.globToRE(glob));
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,DirectoryListSet.class,e);
			return files;
		}
		listFiles(new Vector(),files,new File(directory),filter,recurse);
		return files;
	}
	private static void listFiles(Vector stack, Vector files,
		File directory, RE filter, boolean recurse)
	{
		if(stack.contains(directory))
		{
			Log.log(Log.ERROR,DirectoryListSet.class,
				""Recursion in DirectoryListSet: ""
				+ directory.getPath());
			return;
		}
		else
			stack.addElement(directory);
		String[] _files = directory.list();
		if(_files == null)
			return;
		MiscUtilities.quicksort(_files,new MiscUtilities.StringICaseCompare());
		for(int i = 0; i < _files.length; i++)
		{
			String name = _files[i];
			File file = new File(directory,name);
			if(file.isDirectory())
			{
				if(recurse)
					listFiles(stack,files,file,filter,recurse);
			}
			else
			{
				if(!filter.isMatch(name))
					continue;
				Log.log(Log.DEBUG,DirectoryListSet.class,file.getPath());
				String canonPath;
				try
				{
					canonPath = file.getCanonicalPath();
				}
				catch(IOException io)
				{
					canonPath = file.getPath();
				}
				files.addElement(canonPath);
			}
		}
	}
}
"
org.gjt.sp.jedit.search.HyperSearchRequest,"/*
 * HyperSearchRequest.java - HyperSearch request, run in I/O thread
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import javax.swing.text.BadLocationException;
import javax.swing.text.Element;
import javax.swing.text.Segment;
import javax.swing.tree.*;
import javax.swing.SwingUtilities;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.View;
import org.gjt.sp.util.*;
public class HyperSearchRequest extends WorkRequest
{
	public HyperSearchRequest(View view, SearchMatcher matcher,
		HyperSearchResults results)
	{
		this.view = view;
		this.matcher = matcher;
		this.results = results;
		this.resultTreeModel = results.getTreeModel();
		this.resultTreeRoot = (DefaultMutableTreeNode)resultTreeModel
			.getRoot();
	}
	public void run()
	{
		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		setProgressMaximum(fileset.getBufferCount());
		setStatus(jEdit.getProperty(""hypersearch.status""));
		int resultCount = 0;
		int bufferCount = 0;
		try
		{
			int current = 0;
			Buffer buffer = fileset.getFirstBuffer(view);
			if(buffer != null)
			{
				do
				{
					setProgressValue(++current);
					int thisResultCount = doHyperSearch(buffer,matcher);
					if(thisResultCount != 0)
					{
						bufferCount++;
						resultCount += thisResultCount;
					}
				}
				while((buffer = fileset.getNextBuffer(view,buffer)) != null);
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			VFSManager.error(view,""searcherror"",args);
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			final int _resultCount = resultCount;
			final int _bufferCount = bufferCount;
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					results.searchDone(_resultCount,_bufferCount);
				}
			});
		}
	}
	// private members
	private View view;
	private SearchMatcher matcher;
	private HyperSearchResults results;
	private DefaultTreeModel resultTreeModel;
	private DefaultMutableTreeNode resultTreeRoot;
	private int doHyperSearch(Buffer buffer, SearchMatcher matcher)
		throws Exception
	{
		setAbortable(false);
		int resultCount = 0;
		final DefaultMutableTreeNode bufferNode = new DefaultMutableTreeNode(
			buffer.getPath());
		try
		{
			buffer.readLock();
			Element map = buffer.getDefaultRootElement();
			Segment text = new Segment();
			int offset = 0;
			int length = buffer.getLength();
			int line = -1;
loop:			for(;;)
			{
				buffer.getText(offset,length - offset,text);
				int[] match = matcher.nextMatch(text);
				if(match == null)
					break loop;
				offset += match[1];
				int newLine = map.getElementIndex(offset);
				if(line == newLine)
				{
					// already had a result on this
					// line, skip
					continue loop;
				}
				line = newLine;
				resultCount++;
				bufferNode.insert(new DefaultMutableTreeNode(
					new HyperSearchResult(buffer,line),false),
					bufferNode.getChildCount());
			}
		}
		finally
		{
			buffer.readUnlock();
		}
		if(resultCount != 0)
		{
			resultTreeRoot.insert(bufferNode,resultTreeRoot.getChildCount());
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					resultTreeModel.reload(resultTreeRoot);
				}
			});
		}
		setAbortable(true);
		return resultCount;
	}
}
"
org.gjt.sp.jedit.search.HyperSearchResult,"/*
 * HyperSearchResult.java - HyperSearch result
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import javax.swing.text.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.Log;
public class HyperSearchResult
{
	public String path;
	public Buffer buffer;
	public int line;
	public Position linePos;
	public String str; // cached for speed
	public HyperSearchResult(Buffer buffer, int line)
	{
		path = buffer.getPath();
		this.line = line;
		if(!buffer.isTemporary())
			bufferOpened(buffer);
		str = (line + 1) + "": "" + getLine(buffer,
			buffer.getDefaultRootElement()
			.getElement(line));
	}
	String getLine(Buffer buffer, Element elem)
	{
		if(elem == null)
			return """";
		try
		{
			return buffer.getText(elem.getStartOffset(),
				elem.getEndOffset() -
				elem.getStartOffset() - 1)
				.replace('\t',' ');
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
			return """";
		}
	}
	public void bufferOpened(Buffer buffer)
	{
		this.buffer = buffer;
		Element map = buffer.getDefaultRootElement();
		Element elem = map.getElement(line);
		if(elem == null)
			elem = map.getElement(map.getElementCount()-1);
		try
		{
			linePos = buffer.createPosition(elem.getStartOffset());
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
	}
	public void bufferClosed()
	{
		buffer = null;
		linePos = null;
	}
	public Buffer getBuffer()
	{
		if(buffer == null)
			buffer = jEdit.openFile(null,path);
		return buffer;
	}
	public String toString()
	{
		return str;
	}
}
"
org.gjt.sp.jedit.search.HyperSearchResults,"/*
 * HyperSearchResults.java - HyperSearch results
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.text.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.EditBus;
import org.gjt.sp.jedit.View;
import org.gjt.sp.util.Log;
/**
 * HyperSearch results window.
 * @author Slava Pestov
 * @version $Id: HyperSearchResults.java,v 1.4 2001/07/19 06:26:52 sp Exp $
 */
public class HyperSearchResults extends JPanel implements DockableWindow,
	EBComponent
{
	public static final String NAME = ""hypersearch-results"";
	public HyperSearchResults(View view)
	{
		super(new BorderLayout());
		this.view = view;
		caption = new JLabel();
		updateCaption(0,0);
		add(BorderLayout.NORTH, caption);
		resultTreeRoot = new DefaultMutableTreeNode();
		resultTreeModel = new DefaultTreeModel(resultTreeRoot);
		resultTree = new JTree(resultTreeModel);
		resultTree.setCellRenderer(new ResultCellRenderer());
		resultTree.setVisibleRowCount(16);
		resultTree.setRootVisible(false);
		resultTree.setShowsRootHandles(true);
		resultTree.putClientProperty(""JTree.lineStyle"", ""Angled"");
		resultTree.setEditable(false);
		resultTree.addMouseListener(new MouseHandler());
		JScrollPane scrollPane = new JScrollPane(resultTree);
		Dimension dim = scrollPane.getPreferredSize();
		dim.width = 400;
		scrollPane.setPreferredSize(dim);
		add(BorderLayout.CENTER, scrollPane);
	}
	public String getName()
	{
		return NAME;
	}
	public Component getComponent()
	{
		return this;
	}
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	}
	public void removeNotify()
	{
		super.removeNotify();
		EditBus.removeFromBus(this);
	}
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof BufferUpdate)
		{
			BufferUpdate bmsg = (BufferUpdate)msg;
			Buffer buffer = bmsg.getBuffer();
			if(bmsg.getWhat() == BufferUpdate.LOADED)
			{
				for(int i = resultTreeRoot.getChildCount() - 1; i >= 0; i--)
				{
					DefaultMutableTreeNode bufferNode = (DefaultMutableTreeNode)
						resultTreeRoot.getChildAt(i);
					for(int j = bufferNode.getChildCount() - 1;
						j >= 0; j--)
					{
						HyperSearchResult result = (HyperSearchResult)
							((DefaultMutableTreeNode)bufferNode
							.getChildAt(j)).getUserObject();
						if(buffer.getPath().equals(result.path))
							result.bufferOpened(buffer);
					}
				}
			}
			else if(bmsg.getWhat() == BufferUpdate.CLOSED)
			{
				for(int i = resultTreeRoot.getChildCount() - 1; i >= 0; i--)
				{
					DefaultMutableTreeNode bufferNode = (DefaultMutableTreeNode)
						resultTreeRoot.getChildAt(i);
					for(int j = bufferNode.getChildCount() - 1;
						j >= 0; j--)
					{
						HyperSearchResult result = (HyperSearchResult)
							((DefaultMutableTreeNode)bufferNode
							.getChildAt(j)).getUserObject();
						if(buffer.getPath().equals(result.path))
							result.bufferClosed();
					}
				}
			}
		}
	}
	public DefaultTreeModel getTreeModel()
	{
		return resultTreeModel;
	}
	public void searchStarted()
	{
		caption.setText(jEdit.getProperty(""hypersearch-results.searching""));
		resultTreeRoot.removeAllChildren();
		resultTreeModel.reload(resultTreeRoot);
	}
	public void searchDone(int resultCount, int bufferCount)
	{
		updateCaption(resultCount,bufferCount);
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if(resultTreeRoot.getChildCount() == 1)
				{
					resultTree.expandPath(new TreePath(
						((DefaultMutableTreeNode)
						resultTreeRoot.getChildAt(0))
						.getPath()));
				}
			}
		});
	}
	// private members
	private View view;
	private JLabel caption;
	private JTree resultTree;
	private DefaultMutableTreeNode resultTreeRoot;
	private DefaultTreeModel resultTreeModel;
	private void updateCaption(int resultCount, int bufferCount)
	{
		Object[] pp = { new Integer(resultCount), new Integer(bufferCount) };
		caption.setText(jEdit.getProperty(""hypersearch-results.caption"",pp));
	}
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			TreePath path = resultTree.getPathForLocation(
				evt.getX(),evt.getY());
			if(path == null)
				return;
			Object value = ((DefaultMutableTreeNode)path
				.getLastPathComponent()).getUserObject();
			if(value instanceof String)
			{
				Buffer buffer = jEdit.openFile(view,(String)value);
				if(buffer == null)
					return;
				view.setBuffer(buffer);
				view.toFront();
				view.requestFocus();
			}
			else
			{
				final HyperSearchResult result = (HyperSearchResult)value;
				final Buffer buffer = result.getBuffer();
				if(buffer == null)
					return;
				VFSManager.runInAWTThread(new Runnable()
				{
					public void run()
					{
						int pos = result.linePos.getOffset();
						view.setBuffer(buffer);
						view.getTextArea().setCaretPosition(pos);
						view.toFront();
						view.requestFocus();
					}
				});
			}
		}
	}
	class ResultCellRenderer extends DefaultTreeCellRenderer
	{
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean sel, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			Component comp = super.getTreeCellRendererComponent(tree,value,sel,
				expanded,leaf,row,hasFocus);
			if (!(comp instanceof JLabel))
				return comp;
			JLabel label = (JLabel)comp;
			label.setIcon(null);
			return label;
		}
	}
}
"
org.gjt.sp.jedit.search.RESearchMatcher,"/*
 * RESearchMatcher.java - Regular expression matcher
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import bsh.NameSpace;
import gnu.regexp.*;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.BeanShell;
import org.gjt.sp.jedit.MiscUtilities;
/**
 * A regular expression string matcher.
 * @author Slava Pestov
 * @version $Id: RESearchMatcher.java,v 1.11 2001/07/02 09:33:02 sp Exp $
 */
public class RESearchMatcher implements SearchMatcher
{
	/**
	 * Perl5 syntax with character classes enabled.
	 * @since jEdit 3.0pre5
	 */
	public static final RESyntax RE_SYNTAX_JEDIT
		= new RESyntax(RESyntax.RE_SYNTAX_PERL5)
		.set(RESyntax.RE_CHAR_CLASSES)
		.setLineSeparator(""\n"");
	/**
	 * Creates a new regular expression string matcher.
	 */
	public RESearchMatcher(String search, String replace,
		boolean ignoreCase, boolean beanshell,
		String replaceMethod) throws Exception
	{
		// gnu.regexp doesn't seem to support \n and \t in the replace
		// string, so implement it here
		this.replace = MiscUtilities.escapesToChars(replace);
		this.beanshell = beanshell;
		this.replaceMethod = replaceMethod;
		replaceNS = new NameSpace(BeanShell.getNameSpace(),""search and replace"");
		re = new RE(search,(ignoreCase ? RE.REG_ICASE : 0)
			| RE.REG_MULTILINE,RE_SYNTAX_JEDIT);
	}
	/**
	 * Returns the offset of the first match of the specified text
	 * within this matcher.
	 * @param text The text to search in
	 * @return an array where the first element is the start offset
	 * of the match, and the second element is the end offset of
	 * the match
	 */
	public int[] nextMatch(Segment text)
	{
		REMatch match = re.getMatch(new CharIndexedSegment(text,0));
		if(match == null)
			return null;
		int start = match.getStartIndex();
		int end = match.getEndIndex();
		if(start == end)
		{
			// searched for (), or ^, or $, or other 'empty' regexp
			return null;
		}
		int[] result = { start, end };
		return result;
	}
	/**
	 * Returns the specified text, with any substitution specified
	 * within this matcher performed.
	 * @param text The text
	 */
	public String substitute(String text) throws Exception
	{
		REMatch match = re.getMatch(text);
		if(match == null)
			return null;
		if(beanshell)
		{
			int count = match.getSubCount();
			for(int i = 0; i < count; i++)
				replaceNS.setVariable(""_"" + i,match.toString(i));
			Object obj = BeanShell.runCachedBlock(replaceMethod,
				null,replaceNS);
			if(obj == null)
				return null;
			else
				return obj.toString();
		}
		else
			return match.substituteInto(replace);
	}
	// private members
	private String replace;
	private RE re;
	private boolean beanshell;
	private String replaceMethod;
	private NameSpace replaceNS;
}
"
org.gjt.sp.jedit.search.SearchAndReplace,"/*
 * SearchAndReplace.java - Search and replace
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 * Portions copyright (C) 2001 Tom Locke
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import javax.swing.text.BadLocationException;
import javax.swing.text.Segment;
import javax.swing.JOptionPane;
import java.awt.Component;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.SearchSettingsChanged;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * Class that implements regular expression and literal search within
 * jEdit buffers.
 * @author Slava Pestov
 * @version $Id: SearchAndReplace.java,v 1.62 2001/08/23 07:39:09 sp Exp $
 */
public class SearchAndReplace
{
	/**
	 * Sets the current search string.
	 * @param search The new search string
	 */
	public static void setSearchString(String search)
	{
		if(search.equals(SearchAndReplace.search))
			return;
		SearchAndReplace.search = search;
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	}
	/**
	 * Returns the current search string.
	 */
	public static String getSearchString()
	{
		return search;
	}
	/**
	 * Sets the current replacement string.
	 * @param search The new replacement string
	 */
	public static void setReplaceString(String replace)
	{
		if(replace.equals(SearchAndReplace.replace))
			return;
		SearchAndReplace.replace = replace;
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	}
	/**
	 * Returns the current replacement string.
	 */
	public static String getReplaceString()
	{
		return replace;
	}
	/**
	 * Sets the ignore case flag.
	 * @param ignoreCase True if searches should be case insensitive,
	 * false otherwise
	 */
	public static void setIgnoreCase(boolean ignoreCase)
	{
		if(ignoreCase == SearchAndReplace.ignoreCase)
			return;
		SearchAndReplace.ignoreCase = ignoreCase;
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	}
	/**
	 * Returns the state of the ignore case flag.
	 * @return True if searches should be case insensitive,
	 * false otherwise
	 */
	public static boolean getIgnoreCase()
	{
		return ignoreCase;
	}
	/**
	 * Sets the state of the regular expression flag.
	 * @param regexp True if regular expression searches should be
	 * performed
	 */
	public static void setRegexp(boolean regexp)
	{
		if(regexp == SearchAndReplace.regexp)
			return;
		SearchAndReplace.regexp = regexp;
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	}
	/**
	 * Returns the state of the regular expression flag.
	 * @return True if regular expression searches should be performed
	 */
	public static boolean getRegexp()
	{
		return regexp;
	}
	/**
	 * Sets the reverse search flag. Note that currently, only literal
	 * reverse searches are supported.
	 * @param reverse True if searches should go backwards,
	 * false otherwise
	 */
	public static void setReverseSearch(boolean reverse)
	{
		if(reverse == SearchAndReplace.reverse)
			return;
		SearchAndReplace.reverse = reverse;
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	}
	/**
	 * Returns the state of the reverse search flag.
	 * @return True if searches should go backwards,
	 * false otherwise
	 */
	public static boolean getReverseSearch()
	{
		return reverse;
	}
	/**
	 * Sets the state of the BeanShell replace flag.
	 * @param regexp True if the replace string is a BeanShell expression
	 * @since jEdit 3.2pre2
	 */
	public static void setBeanShellReplace(boolean beanshell)
	{
		if(beanshell == SearchAndReplace.beanshell)
			return;
		SearchAndReplace.beanshell = beanshell;
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	}
	/**
	 * Returns the state of the BeanShell replace flag.
	 * @return True if the replace string is a BeanShell expression
	 * @since jEdit 3.2pre2
	 */
	public static boolean getBeanShellReplace()
	{
		return beanshell;
	}
	/**
	 * Sets the state of the auto wrap around flag.
	 * @param wrap If true, the 'continue search from start' dialog
	 * will not be displayed
	 * @since jEdit 3.2pre2
	 */
	public static void setAutoWrapAround(boolean wrap)
	{
		if(wrap == SearchAndReplace.wrap)
			return;
		SearchAndReplace.wrap = wrap;
		EditBus.send(new SearchSettingsChanged(null));
	}
	/**
	 * Returns the state of the auto wrap around flag.
	 * @param wrap If true, the 'continue search from start' dialog
	 * will not be displayed
	 * @since jEdit 3.2pre2
	 */
	public static boolean getAutoWrapAround()
	{
		return wrap;
	}
	/**
	 * Sets the current search string matcher. Note that calling
	 * <code>setSearchString</code>, <code>setReplaceString</code>,
	 * <code>setIgnoreCase</code> or <code>setRegExp</code> will
	 * reset the matcher to the default.
	 */
	public static void setSearchMatcher(SearchMatcher matcher)
	{
		SearchAndReplace.matcher = matcher;
		EditBus.send(new SearchSettingsChanged(null));
	}
	/**
	 * Returns the current search string matcher.
	 * @exception IllegalArgumentException if regular expression search
	 * is enabled, the search string or replacement string is invalid
	 */
	public static SearchMatcher getSearchMatcher()
		throws Exception
	{
		return getSearchMatcher(true);
	}
	/**
	 * Returns the current search string matcher.
	 * @param reverseOK Replacement commands need a non-reversed matcher,
	 * so they set this to false
	 * @exception IllegalArgumentException if regular expression search
	 * is enabled, the search string or replacement string is invalid
	 */
	public static SearchMatcher getSearchMatcher(boolean reverseOK)
		throws Exception
	{
		reverseOK &= (fileset instanceof CurrentBufferSet);
		if(matcher != null && (reverseOK || !reverse))
			return matcher;
		if(search == null || """".equals(search))
			return null;
		// replace must not be null
		String replace = (SearchAndReplace.replace == null ? """" : SearchAndReplace.replace);
		String replaceMethod;
		if(beanshell && replace.length() != 0)
		{
			replaceMethod = BeanShell.cacheBlock(""replace"",""return (""
				+ replace + "");"",false);
		}
		else
			replaceMethod = null;
		if(regexp)
			matcher = new RESearchMatcher(search,replace,ignoreCase,
				beanshell,replaceMethod);
		else
		{
			matcher = new BoyerMooreSearchMatcher(search,replace,
				ignoreCase,reverse && reverseOK,beanshell,
				replaceMethod);
		}
		return matcher;
	}
	/**
	 * Sets the current search file set.
	 * @param fileset The file set to perform searches in
	 */
	public static void setSearchFileSet(SearchFileSet fileset)
	{
		SearchAndReplace.fileset = fileset;
		EditBus.send(new SearchSettingsChanged(null));
	}
	/**
	 * Returns the current search file set.
	 */
	public static SearchFileSet getSearchFileSet()
	{
		return fileset;
	}
	/**
	 * Performs a HyperSearch.
	 * @param view The view
	 * @since jEdit 2.7pre3
	 */
	public static boolean hyperSearch(View view)
	{
		record(view,""hyperSearch(view)"",false,true);
		view.getDockableWindowManager().addDockableWindow(
			HyperSearchResults.NAME);
		final HyperSearchResults results = (HyperSearchResults)
			view.getDockableWindowManager()
			.getDockableWindow(HyperSearchResults.NAME);
		results.searchStarted();
		try
		{
			VFSManager.runInWorkThread(new HyperSearchRequest(view,
				getSearchMatcher(false),results));
			return true;
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(view,""searcherror"",args);
			return false;
		}
	}
	/**
	 * Finds the next occurance of the search string.
	 * @param view The view
	 * @return True if the operation was successful, false otherwise
	 */
	public static boolean find(View view)
	{
		boolean repeat = false;
		Buffer buffer = fileset.getNextBuffer(view,null);
		try
		{
			SearchMatcher matcher = getSearchMatcher(true);
			if(matcher == null)
			{
				view.getToolkit().beep();
				return false;
			}
			record(view,""find(view)"",false,true);
			view.showWaitCursor();
loop:			for(;;)
			{
				while(buffer != null)
				{
					// Wait for the buffer to load
					if(!buffer.isLoaded())
						VFSManager.waitForRequests();
					int start;
					if(view.getBuffer() == buffer && !repeat)
					{
						JEditTextArea textArea = view.getTextArea();
						Selection s = textArea.getSelectionAtOffset(
							textArea.getCaretPosition());
						if(s == null)
							start = textArea.getCaretPosition();
						else if(reverse)
							start = s.getStart();
						else 
							start = s.getEnd();
					}
					else if(reverse)
						start = buffer.getLength();
					else
						start = 0;
					if(find(view,buffer,start))
						return true;
					buffer = fileset.getNextBuffer(view,buffer);
				}
				if(repeat)
				{
					// no point showing this dialog box twice
					view.getToolkit().beep();
					return false;
				}
				/* Don't do this when playing a macro */
				if(BeanShell.isScriptRunning())
					break loop;
				boolean restart;
				if(wrap)
				{
					view.getStatus().setMessageAndClear(
						jEdit.getProperty(""view.status.auto-wrap""));
					restart = true;
				}
				else
				{
					Integer[] args = { new Integer(reverse ? 1 : 0) };
					int result = GUIUtilities.confirm(view,
						""keepsearching"",args,
						JOptionPane.YES_NO_OPTION,
						JOptionPane.QUESTION_MESSAGE);
					restart = (result == JOptionPane.YES_OPTION);
				}
				if(restart)
				{
					// start search from beginning
					buffer = fileset.getFirstBuffer(view);
					repeat = true;
				}
				else
					break loop;
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(view,""searcherror"",args);
		}
		finally
		{
			view.hideWaitCursor();
		}
		return false;
	}
	/**
	 * Finds the next instance of the search string in the specified
	 * buffer.
	 * @param view The view
	 * @param buffer The buffer
	 * @param start Location where to start the search
	 */
	public static boolean find(final View view, final Buffer buffer, final int start)
		throws Exception
	{
		SearchMatcher matcher = getSearchMatcher(true);
		Segment text = new Segment();
		if(reverse)
			buffer.getText(0,start,text);
		else
			buffer.getText(start,buffer.getLength() - start,text);
		int[] match = matcher.nextMatch(text);
		if(match != null)
		{
			fileset.matchFound(buffer);
			view.setBuffer(buffer);
			JEditTextArea textArea = view.getTextArea();
			int matchStart = (reverse ? 0 : start);
			textArea.setSelection(new Selection.Range(
				matchStart + match[0],
				matchStart + match[1]));
			textArea.moveCaretPosition(matchStart + match[1]);
			return true;
		}
		else
			return false;
	}
	/**
	 * Replaces the current selection with the replacement string.
	 * @param view The view
	 * @return True if the operation was successful, false otherwise
	 */
	public static boolean replace(View view)
	{
		JEditTextArea textArea = view.getTextArea();
		Selection[] selection = textArea.getSelection();
		if(selection.length == 0)
		{
			view.getToolkit().beep();
			return false;
		}
		record(view,""replace(view)"",true,false);
		Buffer buffer = view.getBuffer();
		try
		{
			buffer.beginCompoundEdit();
			int retVal = 0;
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				/* if an occurence occurs at the
				beginning of the selection, the
				selection start will get moved.
				this sucks, so we hack to avoid it. */
				int start = s.getStart();
				retVal += _replace(view,buffer,
					s.getStart(),s.getEnd());
				// this has no effect if the selection
				// no longer exists
				textArea.removeFromSelection(s);
				if(s instanceof Selection.Range)
				{
					textArea.addToSelection(new Selection.Range(
						start,s.getEnd()));
				}
				else if(s instanceof Selection.Rect)
				{
					textArea.addToSelection(new Selection.Rect(
						start,s.getEnd()));
				}
			}
			if(retVal == 0)
			{
				view.getToolkit().beep();
				return false;
			}
			return true;
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(view,""searcherror"",args);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
		return false;
	}
	/**
	 * Replaces text in the specified range with the replacement string.
	 * @param view The view
	 * @param buffer The buffer
	 * @param start The start offset
	 * @param end The end offset
	 * @return True if the operation was successful, false otherwise
	 */
	public static boolean replace(View view, Buffer buffer, int start, int end)
	{
		JEditTextArea textArea = view.getTextArea();
		try
		{
			int retVal = 0;
			buffer.beginCompoundEdit();
			retVal += _replace(view,buffer,start,end);
			if(retVal != 0)
				return true;
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(view,""searcherror"",args);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
		return false;
	}
	/**
	 * Replaces all occurances of the search string with the replacement
	 * string.
	 * @param view The view
	 */
	public static boolean replaceAll(View view)
	{
		int fileCount = 0;
		int occurCount = 0;
		record(view,""replaceAll(view)"",true,true);
		view.showWaitCursor();
		try
		{
			Buffer buffer = fileset.getFirstBuffer(view);
			do
			{
				// Wait for buffer to finish loading
				if(buffer.isPerformingIO())
					VFSManager.waitForRequests();
				// Leave buffer in a consistent state if
				// an error occurs
				try
				{
					buffer.beginCompoundEdit();
					int retVal = _replace(view,buffer,
						0,buffer.getLength());
					if(retVal != 0)
					{
						fileCount++;
						occurCount += retVal;
						fileset.matchFound(buffer);
					}
				}
				finally
				{
					buffer.endCompoundEdit();
				}
			}
			while((buffer = fileset.getNextBuffer(view,buffer)) != null);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(view,""searcherror"",args);
		}
		finally
		{
			view.hideWaitCursor();
		}
		/* Don't do this when playing a macro, cos it's annoying */
		if(!BeanShell.isScriptRunning())
		{
			Object[] args = { new Integer(occurCount),
				new Integer(fileCount) };
			view.getStatus().setMessageAndClear(jEdit.getProperty(
				""view.status.replace-all"",args));
		}
		return (fileCount != 0);
	}
	/**
	 * Loads search and replace state from the properties.
	 */
	public static void load()
	{
		search = jEdit.getProperty(""search.find.value"");
		replace = jEdit.getProperty(""search.replace.value"");
		ignoreCase = jEdit.getBooleanProperty(""search.ignoreCase.toggle"");
		regexp = jEdit.getBooleanProperty(""search.regexp.toggle"");
		reverse = jEdit.getBooleanProperty(""search.reverse.toggle"");
		beanshell = jEdit.getBooleanProperty(""search.beanshell.toggle"");
		wrap = jEdit.getBooleanProperty(""search.wrap.toggle"");
		String filesetCode = jEdit.getProperty(""search.fileset.value"");
		if(filesetCode != null)
		{
			fileset = (SearchFileSet)BeanShell.eval(null,filesetCode,true);
		}
		if(fileset == null)
			fileset = new CurrentBufferSet();
	}
	/**
	 * Saves search and replace state to the properties.
	 */
	public static void save()
	{
		jEdit.setProperty(""search.find.value"",search);
		jEdit.setProperty(""search.replace.value"",replace);
		jEdit.setBooleanProperty(""search.ignoreCase.toggle"",ignoreCase);
		jEdit.setBooleanProperty(""search.regexp.toggle"",regexp);
		jEdit.setBooleanProperty(""search.reverse.toggle"",reverse);
		jEdit.setBooleanProperty(""search.beanshell.toggle"",beanshell);
		jEdit.setBooleanProperty(""search.wrap.toggle"",wrap);
		String code = fileset.getCode();
		if(code != null)
			jEdit.setProperty(""search.fileset.value"",code);
		else
			jEdit.unsetProperty(""search.fileset.value"");
	}
	// private members
	private static String search;
	private static String replace;
	private static boolean regexp;
	private static boolean ignoreCase;
	private static boolean reverse;
	private static boolean beanshell;
	private static boolean wrap;
	private static SearchMatcher matcher;
	private static SearchFileSet fileset;
	private static void record(View view, String action,
		boolean replaceAction, boolean recordFileSet)
	{
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
		{
			recorder.record(""SearchAndReplace.setSearchString(\""""
				+ MiscUtilities.charsToEscapes(search) + ""\"");"");
			if(replaceAction)
			{
				recorder.record(""SearchAndReplace.setReplaceString(\""""
					+ MiscUtilities.charsToEscapes(replace) + ""\"");"");
				recorder.record(""SearchAndReplace.setBeanShellReplace(""
					+ beanshell + "");"");
			}
			else
			{
				// only record this if doing a find next
				recorder.record(""SearchAndReplace.setAutoWrapAround(""
					+ wrap + "");"");
				recorder.record(""SearchAndReplace.setReverseSearch(""
					+ reverse + "");"");
			}
			recorder.record(""SearchAndReplace.setIgnoreCase(""
				+ ignoreCase + "");"");
			recorder.record(""SearchAndReplace.setRegexp(""
				+ regexp + "");"");
			if(recordFileSet)
			{
				recorder.record(""SearchAndReplace.setSearchFileSet(""
					+ fileset.getCode() + "");"");
			}
			recorder.record(""SearchAndReplace."" + action + "";"");
		}
	}
	/**
	 * Replaces all occurances of the search string with the replacement
	 * string.
	 * @param view The view
	 * @param buffer The buffer
	 * @param start The start offset
	 * @param end The end offset
	 * @return True if the replace operation was successful, false
	 * if no matches were found
	 */
	private static int _replace(View view, Buffer buffer,
		int start, int end) throws Exception
	{
		if(!buffer.isEditable())
			return 0;
		SearchMatcher matcher = getSearchMatcher(false);
		if(matcher == null)
			return 0;
		int occurCount = 0;
		Segment text = new Segment();
		int offset = start;
loop:		for(;;)
		{
			buffer.getText(offset,end - offset,text);
			int[] occur = matcher.nextMatch(text);
			if(occur == null)
				break loop;
			int _start = occur[0];
			int _length = occur[1] - occur[0];
			String found = new String(text.array,text.offset + _start,_length);
			String subst = matcher.substitute(found);
			if(subst != null)
			{
				buffer.remove(offset + _start,_length);
				buffer.insertString(offset + _start,subst,null);
				occurCount++;
				offset += _start + subst.length();
				end += (subst.length() - found.length());
			}
			else
				offset += _start + _length;
		}
		return occurCount;
	}
}
"
org.gjt.sp.jedit.search.SearchBar,"/*
 * SearchBar.java - Search & replace toolbar
 * Portions copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import java.awt.event.*;
import java.awt.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.text.BadLocationException;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.HistoryTextField;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;
public class SearchBar extends JPanel
{
	public SearchBar(View view)
	{
		super(new BorderLayout());
		this.view = view;
		//Font boldFont = new Font(""Dialog"",Font.BOLD,12);
		//Font plainFont = new Font(""Dialog"",Font.PLAIN,12);
		JLabel label = new JLabel(jEdit.getProperty(""view.search.find""));
		//label.setFont(boldFont);
		label.setBorder(new EmptyBorder(0,2,0,12));
		add(label,BorderLayout.WEST);
		Box box = new Box(BoxLayout.Y_AXIS);
		box.add(Box.createGlue());
		box.add(find = new HistoryTextField(""find""));
		//find.setFont(plainFont);
		Dimension min = find.getPreferredSize();
		min.width = Integer.MAX_VALUE;
		find.setMaximumSize(min);
		ActionHandler actionHandler = new ActionHandler();
		find.addKeyListener(new KeyHandler());
		find.addActionListener(actionHandler);
		find.getDocument().addDocumentListener(new DocumentHandler());
		box.add(Box.createGlue());
		add(box,BorderLayout.CENTER);
		Insets margin = new Insets(1,1,1,1);
		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createHorizontalStrut(12));
		buttons.add(ignoreCase = new JCheckBox(jEdit.getProperty(
			""search.case"")));
		//ignoreCase.setFont(boldFont);
		ignoreCase.addActionListener(actionHandler);
		ignoreCase.setMargin(margin);
		buttons.add(Box.createHorizontalStrut(2));
		buttons.add(regexp = new JCheckBox(jEdit.getProperty(
			""search.regexp"")));
		//regexp.setFont(boldFont);
		regexp.addActionListener(actionHandler);
		regexp.setMargin(margin);
		buttons.add(Box.createHorizontalStrut(2));
		buttons.add(hyperSearch = new JCheckBox(jEdit.getProperty(
			""search.hypersearch"")));
		//hyperSearch.setFont(boldFont);
		hyperSearch.addActionListener(actionHandler);
		hyperSearch.setMargin(margin);
		update();
		add(buttons,BorderLayout.EAST);
	}
	public HistoryTextField getField()
	{
		return find;
	}
	public void setHyperSearch(boolean hyperSearch)
	{
		jEdit.setBooleanProperty(""view.search.hypersearch.toggle"",hyperSearch);
		this.hyperSearch.setSelected(hyperSearch);
		find.setModel(this.hyperSearch.isSelected() ? ""find"" : null);
	}
	public void update()
	{
		ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
		regexp.setSelected(SearchAndReplace.getRegexp());
		hyperSearch.setSelected(jEdit.getBooleanProperty(
			""view.search.hypersearch.toggle""));
		find.setModel(hyperSearch.isSelected() ? ""find"" : null);
	}
	// private members
	private View view;
	private HistoryTextField find;
	private JCheckBox ignoreCase, regexp, hyperSearch;
	private void find(boolean reverse)
	{
		String text = find.getText();
		if(text.length() == 0)
		{
			jEdit.setBooleanProperty(""search.hypersearch.toggle"",
				hyperSearch.isSelected());
			new SearchDialog(view,null);
		}
		else if(hyperSearch.isSelected())
		{
			find.setText(null);
			SearchAndReplace.setSearchString(text);
			SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
			SearchAndReplace.hyperSearch(view);
		}
		else
		{
			// on enter, start search from end
			// of current match to find next one
			int start;
			JEditTextArea textArea = view.getTextArea();
			Selection s = textArea.getSelectionAtOffset(
				textArea.getCaretPosition());
			if(s == null)
				start = textArea.getCaretPosition();
			else if(reverse)
				start = s.getStart();
			else 
				start = s.getEnd();
			if(!incrementalSearch(start,reverse))
			{
				// not found. start from
				// beginning
				if(!incrementalSearch(reverse
					? view.getBuffer().getLength()
					: 0,reverse))
				{
					// not found at all. beep.
					getToolkit().beep();
				}
			}
		}
	}
	private boolean incrementalSearch(int start, boolean reverse)
	{
		/* For example, if the current fileset is a directory,
		 * C+g will find the next match within that fileset.
		 * This can be annoying if you have just done an
		 * incremental search and want the next occurrence
		 * in the current buffer. */
		SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
		SearchAndReplace.setSearchString(find.getText());
		SearchAndReplace.setReverseSearch(reverse);
		try
		{
			if(SearchAndReplace.find(view,view.getBuffer(),start))
				return true;
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
		catch(Exception e)
		{
			Log.log(Log.DEBUG,this,e);
			// invalid regexp, ignore
			// return true to avoid annoying beeping while
			// typing a re
			return true;
		}
		return false;
	}
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(evt.getSource() == find)
				find(false);
			else if(evt.getSource() == hyperSearch)
			{
				jEdit.setBooleanProperty(""view.search.hypersearch.toggle"",
					hyperSearch.isSelected());
				update();
			}
			else if(evt.getSource() == ignoreCase)
			{
				SearchAndReplace.setIgnoreCase(ignoreCase
					.isSelected());
			}
			else if(evt.getSource() == regexp)
			{
				SearchAndReplace.setRegexp(regexp
					.isSelected());
			}
		}
	}
	class DocumentHandler implements DocumentListener
	{
		public void insertUpdate(DocumentEvent evt)
		{
			// on insert, start search from beginning of
			// current match. This will continue to highlight
			// the current match until another match is found
			if(!hyperSearch.isSelected())
			{
				int start;
				JEditTextArea textArea = view.getTextArea();
				Selection s = textArea.getSelectionAtOffset(
					textArea.getCaretPosition());
				if(s == null)
					start = textArea.getCaretPosition();
				else 
					start = s.getStart();
				if(!incrementalSearch(start,false))
				{
					if(!incrementalSearch(0,false))
					{
						// not found at all. beep.
						getToolkit().beep();
					}
				}
			}
		}
		public void removeUpdate(DocumentEvent evt)
		{
			// on backspace, restart from beginning
			if(!hyperSearch.isSelected())
			{
				String text = find.getText();
				if(text.length() != 0)
				{
					// don't beep if not found.
					// subsequent beeps are very
					// annoying when backspacing an
					// invalid search string.
					if(regexp.isSelected())
					{
						// reverse regexp search
						// not supported yet, so
						// 'sumulate' with restart
						incrementalSearch(0,false);
					}
					else
					{
						int start;
						JEditTextArea textArea = view.getTextArea();
						Selection s = textArea.getSelectionAtOffset(
							textArea.getCaretPosition());
						if(s == null)
							start = textArea.getCaretPosition();
						else 
							start = s.getStart();
						incrementalSearch(start,true);
					}
				}
			}
		}
		public void changedUpdate(DocumentEvent evt)
		{
		}
	}
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_LEFT:
			case KeyEvent.VK_RIGHT:
			case KeyEvent.VK_UP:
			case KeyEvent.VK_DOWN:
				if(!hyperSearch.isSelected())
				{
					evt.consume();
					view.getEditPane().focusOnTextArea();
					view.getEditPane().getTextArea()
						.processKeyEvent(evt);
				}
				break;
			case KeyEvent.VK_ESCAPE:
				evt.consume();
				view.getEditPane().focusOnTextArea();
				break;
			case KeyEvent.VK_ENTER:
				if(evt.isShiftDown())
				{
					evt.consume();
					find(true);
				}
				break;
			}
		}
	}
}
"
org.gjt.sp.jedit.search.SearchDialog,"/*
 * SearchDialog.java - Search and replace dialog
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.text.BadLocationException;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * Search and replace dialog.
 * @author Slava Pestov
 * @version $Id: SearchDialog.java,v 1.14 2001/07/26 07:51:05 sp Exp $
 */
public class SearchDialog extends EnhancedDialog
{
	/**
	 * Default file set.
	 * @since jEdit 3.2pre2
	 */
	public static final int CURRENT_BUFFER = 0;
	public static final int ALL_BUFFERS = 1;
	public static final int DIRECTORY = 2;
	/**
	 * Creates a new search and replace dialog box.
	 * @param view The view
	 * @param searchString The search string
	 */
	public SearchDialog(View view, String searchString)
	{
		this(view,searchString,CURRENT_BUFFER);
	}
	/**
	 * Creates a new search and replace dialog box.
	 * @param view The view
	 * @param searchString The search string
	 * @param searchIn One of CURRENT_BUFFER, ALL_BUFFERS, or DIRECTORY
	 * @since jEdit 3.2pre2
	 */
	public SearchDialog(View view, String searchString, int searchIn)
	{
		super(view,jEdit.getProperty(""search.title""),false);
		this.view = view;
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(0,12,12,12));
		setContentPane(content);
		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.add(BorderLayout.NORTH,createFieldPanel());
		centerPanel.add(BorderLayout.CENTER,createSearchSettingsPanel());
		content.add(BorderLayout.CENTER,centerPanel);
		content.add(BorderLayout.SOUTH,createMultiFilePanel());
		content.add(BorderLayout.EAST,createButtonsPanel());
		if(searchString != null && searchString.indexOf('\n') == -1)
		{
			find.setText(searchString);
			find.selectAll();
		}
		else
			// ???
		replace.setText(null);
		ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
		regexp.setSelected(SearchAndReplace.getRegexp());
		wrap.setSelected(SearchAndReplace.getAutoWrapAround());
		if(SearchAndReplace.getReverseSearch())
			searchBack.setSelected(true);
		else
			searchForward.setSelected(true);
		if(SearchAndReplace.getBeanShellReplace())
			beanShellReplace.setSelected(true);
		else
			stringReplace.setSelected(true);
		if(searchIn == CURRENT_BUFFER)
			searchCurrentBuffer.setSelected(true);
		else if(searchIn == ALL_BUFFERS)
			searchAllBuffers.setSelected(true);
		else if(searchIn == DIRECTORY)
			searchDirectory.setSelected(true);
		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		if(fileset instanceof DirectoryListSet)
		{
			filter.setText(((DirectoryListSet)fileset)
				.getFileFilter());
			directory.setText(((DirectoryListSet)fileset)
				.getDirectory());
			searchSubDirectories.setSelected(((DirectoryListSet)fileset)
				.isRecursive());
		}
		else
		{
			String path;
			if(view.getBuffer().getVFS() instanceof FileVFS)
			{
				path = MiscUtilities.getParentOfPath(
					view.getBuffer().getPath());
			}
			else
				path = System.getProperty(""user.dir"");
			directory.setText(path);
			if(fileset instanceof AllBufferSet)
			{
				filter.setText(((AllBufferSet)fileset)
					.getFileFilter());
			}
			else
			{
				filter.setText(""*"" + MiscUtilities
					.getFileExtension(view.getBuffer()
					.getName()));
			}
			searchSubDirectories.setSelected(true);
		}
		keepDialog.setSelected(jEdit.getBooleanProperty(
			""search.keepDialog.toggle""));
		hyperSearch.setSelected(jEdit.getBooleanProperty(
			""search.hypersearch.toggle""));
		updateEnabled();
		pack();
		jEdit.unsetProperty(""search.width"");
		jEdit.unsetProperty(""search.d-width"");
		jEdit.unsetProperty(""search.height"");
		jEdit.unsetProperty(""search.d-height"");
		GUIUtilities.loadGeometry(this,""search"");
		show();
		GUIUtilities.requestFocus(this,find);
	}
	public void ok()
	{
		try
		{
			setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
			if(!save())
				return;
			if(hyperSearch.isSelected())
			{
				if(SearchAndReplace.hyperSearch(view));
					closeOrKeepDialog();
			}
			else
			{
				if(SearchAndReplace.find(view))
					closeOrKeepDialog();
			}
		}
		finally
		{
			setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
		}
	}
	public void cancel()
	{
		save();
		GUIUtilities.saveGeometry(this,""search"");
		setVisible(false);
	}
	// private members
	private View view;
	// fields
	private HistoryTextField find, replace;
	private JRadioButton stringReplace, beanShellReplace;
	// search settings
	private JCheckBox keepDialog, ignoreCase, regexp, hyperSearch,
		wrap;
	private JRadioButton searchBack, searchForward;
	private JRadioButton searchCurrentBuffer, searchAllBuffers,
		searchDirectory;
	// multifile settings
	private HistoryTextField filter, directory;
	private JCheckBox searchSubDirectories;
	private JButton choose;
	// buttons
	private JButton findBtn, replaceBtn, replaceAndFindBtn, replaceAllBtn,
		closeBtn;
	private JPanel createFieldPanel()
	{
		ButtonActionHandler actionHandler = new ButtonActionHandler();
		JPanel fieldPanel = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,1));
		fieldPanel.setBorder(new EmptyBorder(0,0,12,12));
		JLabel label = new JLabel(jEdit.getProperty(""search.find""));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.find.mnemonic"")
			.charAt(0));
		find = new HistoryTextField(""find"");
		find.addActionListener(actionHandler);
		label.setLabelFor(find);
		label.setBorder(new EmptyBorder(12,0,2,0));
		fieldPanel.add(label);
		fieldPanel.add(find);
		label = new JLabel(jEdit.getProperty(""search.replace""));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.replace.mnemonic"")
			.charAt(0));
		label.setBorder(new EmptyBorder(12,0,0,0));
		fieldPanel.add(label);
		ButtonGroup grp = new ButtonGroup();
		ReplaceActionHandler replaceActionHandler = new ReplaceActionHandler();
		// we use a custom JRadioButton subclass that returns
		// false for isFocusTraversable() so that the user can
		// tab from the search field to the replace field with
		// one keystroke
		Box replaceModeBox = new Box(BoxLayout.X_AXIS);
		stringReplace = new MyJRadioButton(jEdit.getProperty(
			""search.string-replace-btn""));
		stringReplace.addActionListener(replaceActionHandler);
		grp.add(stringReplace);
		replaceModeBox.add(stringReplace);
		replaceModeBox.add(Box.createHorizontalStrut(12));
		beanShellReplace = new MyJRadioButton(jEdit.getProperty(
			""search.beanshell-replace-btn""));
		beanShellReplace.addActionListener(replaceActionHandler);
		grp.add(beanShellReplace);
		replaceModeBox.add(beanShellReplace);
		fieldPanel.add(replaceModeBox);
		fieldPanel.add(Box.createVerticalStrut(3));
		replace = new HistoryTextField(""replace"");
		replace.addActionListener(actionHandler);
		label.setLabelFor(replace);
		fieldPanel.add(replace);
		return fieldPanel;
	}
	private JPanel createSearchSettingsPanel()
	{
		JPanel searchSettings = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,3));
		searchSettings.setBorder(new EmptyBorder(0,0,12,12));
		SettingsActionHandler actionHandler = new SettingsActionHandler();
		ButtonGroup fileset = new ButtonGroup();
		searchSettings.add(new JLabel(jEdit.getProperty(""search.fileset"")));
		keepDialog = new JCheckBox(jEdit.getProperty(""search.keep""));
		keepDialog.setMnemonic(jEdit.getProperty(""search.keep.mnemonic"")
			.charAt(0));
		searchSettings.add(keepDialog);
		searchSettings.add(new JLabel(jEdit.getProperty(""search.direction"")));
		ButtonGroup direction = new ButtonGroup();
		searchCurrentBuffer = new JRadioButton(jEdit.getProperty(""search.current""));
		searchCurrentBuffer.setMnemonic(jEdit.getProperty(""search.current.mnemonic"")
			.charAt(0));
		fileset.add(searchCurrentBuffer);
		searchSettings.add(searchCurrentBuffer);
		searchCurrentBuffer.addActionListener(actionHandler);
		ignoreCase = new JCheckBox(jEdit.getProperty(""search.case""));
		ignoreCase.setMnemonic(jEdit.getProperty(""search.case.mnemonic"")
			.charAt(0));
		searchSettings.add(ignoreCase);
		ignoreCase.addActionListener(actionHandler);
		searchBack = new JRadioButton(jEdit.getProperty(""search.back""));
		searchBack.setMnemonic(jEdit.getProperty(""search.back.mnemonic"")
			.charAt(0));
		direction.add(searchBack);
		searchSettings.add(searchBack);
		searchBack.addActionListener(actionHandler);
		searchAllBuffers = new JRadioButton(jEdit.getProperty(""search.all""));
		searchAllBuffers.setMnemonic(jEdit.getProperty(""search.all.mnemonic"")
			.charAt(0));
		fileset.add(searchAllBuffers);
		searchSettings.add(searchAllBuffers);
		searchAllBuffers.addActionListener(actionHandler);
		regexp = new JCheckBox(jEdit.getProperty(""search.regexp""));
		regexp.setMnemonic(jEdit.getProperty(""search.regexp.mnemonic"")
			.charAt(0));
		searchSettings.add(regexp);
		regexp.addActionListener(actionHandler);
		searchForward = new JRadioButton(jEdit.getProperty(""search.forward""));
		searchForward.setMnemonic(jEdit.getProperty(""search.forward.mnemonic"")
			.charAt(0));
		direction.add(searchForward);
		searchSettings.add(searchForward);
		searchForward.addActionListener(actionHandler);
		searchDirectory = new JRadioButton(jEdit.getProperty(""search.directory""));
		searchDirectory.setMnemonic(jEdit.getProperty(""search.directory.mnemonic"")
			.charAt(0));
		fileset.add(searchDirectory);
		searchSettings.add(searchDirectory);
		searchDirectory.addActionListener(actionHandler);
		hyperSearch = new JCheckBox(jEdit.getProperty(""search.hypersearch""));
		hyperSearch.setMnemonic(jEdit.getProperty(""search.hypersearch.mnemonic"")
			.charAt(0));
		searchSettings.add(hyperSearch);
		hyperSearch.addActionListener(actionHandler);
		wrap= new JCheckBox(jEdit.getProperty(""search.wrap""));
		wrap.setMnemonic(jEdit.getProperty(""search.wrap.mnemonic"")
			.charAt(0));
		searchSettings.add(wrap);
		wrap.addActionListener(actionHandler);
		return searchSettings;
	}
	private JPanel createMultiFilePanel()
	{
		JPanel multifile = new JPanel();
		GridBagLayout layout = new GridBagLayout();
		multifile.setLayout(layout);
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = cons.gridwidth = cons.gridheight = 1;
		cons.anchor = GridBagConstraints.WEST;
		cons.fill = GridBagConstraints.HORIZONTAL;
		MultiFileActionHandler actionListener = new MultiFileActionHandler();
		filter = new HistoryTextField(""search.filter"");
		filter.addActionListener(actionListener);
		cons.insets = new Insets(0,0,3,0);
		JLabel label = new JLabel(jEdit.getProperty(""search.filterField""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.filterField.mnemonic"")
			.charAt(0));
		label.setLabelFor(filter);
		cons.weightx = 0.0f;
		layout.setConstraints(label,cons);
		multifile.add(label);
		cons.insets = new Insets(0,0,3,6);
		cons.weightx = 1.0f;
		layout.setConstraints(filter,cons);
		multifile.add(filter);
		cons.gridy++;
		directory = new HistoryTextField(""search.directory"");
		directory.addActionListener(actionListener);
		label = new JLabel(jEdit.getProperty(""search.directoryField""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.directoryField.mnemonic"")
			.charAt(0));
		label.setLabelFor(directory);
		cons.insets = new Insets(0,0,3,0);
		cons.weightx = 0.0f;
		layout.setConstraints(label,cons);
		multifile.add(label);
		cons.insets = new Insets(0,0,3,6);
		cons.weightx = 1.0f;
		cons.gridwidth = 2;
		layout.setConstraints(directory,cons);
		multifile.add(directory);
		choose = new JButton(jEdit.getProperty(""search.choose""));
		choose.setMnemonic(jEdit.getProperty(""search.choose.mnemonic"")
			.charAt(0));
		cons.insets = new Insets(0,0,3,0);
		cons.weightx = 0.0f;
		cons.gridwidth = 1;
		layout.setConstraints(choose,cons);
		multifile.add(choose);
		choose.addActionListener(actionListener);
		cons.insets = new Insets(0,0,0,0);
		cons.gridy++;
		cons.gridwidth = 4;
		searchSubDirectories = new JCheckBox(jEdit.getProperty(
			""search.subdirs""));
		searchSubDirectories.setMnemonic(jEdit.getProperty(""search.subdirs.mnemonic"")
			.charAt(0));
		layout.setConstraints(searchSubDirectories,cons);
		multifile.add(searchSubDirectories);
		return multifile;
	}
	private Box createButtonsPanel()
	{
		Box box = new Box(BoxLayout.Y_AXIS);
		ButtonActionHandler actionHandler = new ButtonActionHandler();
		box.add(Box.createVerticalStrut(12));
		JPanel grid = new JPanel(new GridLayout(5,1,0,12));
		findBtn = new JButton(jEdit.getProperty(""search.findBtn""));
		getRootPane().setDefaultButton(findBtn);
		grid.add(findBtn);
		findBtn.addActionListener(actionHandler);
		replaceBtn = new JButton(jEdit.getProperty(""search.replaceBtn""));
		replaceBtn.setMnemonic(jEdit.getProperty(""search.replaceBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceBtn);
		replaceBtn.addActionListener(actionHandler);
		replaceAndFindBtn = new JButton(jEdit.getProperty(""search.replaceAndFindBtn""));
		replaceAndFindBtn.setMnemonic(jEdit.getProperty(""search.replaceAndFindBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceAndFindBtn);
		replaceAndFindBtn.addActionListener(actionHandler);
		replaceAllBtn = new JButton(jEdit.getProperty(""search.replaceAllBtn""));
		replaceAllBtn.setMnemonic(jEdit.getProperty(""search.replaceAllBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceAllBtn);
		replaceAllBtn.addActionListener(actionHandler);
		closeBtn = new JButton(jEdit.getProperty(""common.close""));
		grid.add(closeBtn);
		closeBtn.addActionListener(actionHandler);
		grid.setMaximumSize(grid.getPreferredSize());
		box.add(grid);
		box.add(Box.createGlue());
		return box;
	}
	private void updateEnabled()
	{
		boolean replaceEnabled = !hyperSearch.isSelected();
		stringReplace.setEnabled(replaceEnabled);
		beanShellReplace.setEnabled(replaceEnabled);
		replace.setEnabled(replaceEnabled);
		replaceBtn.setEnabled(replaceEnabled);
		replaceAndFindBtn.setEnabled(replaceEnabled);
		replaceAllBtn.setEnabled(replaceEnabled);
		wrap.setEnabled(replaceEnabled);
		boolean reverseEnabled = replaceEnabled
			&& searchCurrentBuffer.isSelected();
		searchBack.setEnabled(reverseEnabled);
		searchForward.setEnabled(reverseEnabled);
		boolean regexpEnabled = (hyperSearch.isSelected()
			|| !(searchBack.isEnabled() && searchBack.isSelected()));
		regexp.setEnabled(regexpEnabled);
		filter.setEnabled(searchAllBuffers.isSelected()
			|| searchDirectory.isSelected());
		boolean directoryEnabled = searchDirectory.isSelected();
		directory.setEnabled(directoryEnabled);
		choose.setEnabled(directoryEnabled);
		searchSubDirectories.setEnabled(directoryEnabled);
	}
	private boolean save()
	{
		String filter = this.filter.getText();
		this.filter.addCurrentToHistory();
		if(filter.length() == 0)
			filter = ""*"";
		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		if(searchCurrentBuffer.isSelected())
			fileset = new CurrentBufferSet();
		else if(searchAllBuffers.isSelected())
			fileset = new AllBufferSet(filter);
		else if(searchDirectory.isSelected())
		{
			String directory = this.directory.getText();
			this.directory.addCurrentToHistory();
			boolean recurse = searchSubDirectories.isSelected();
			if(fileset instanceof DirectoryListSet)
			{
				DirectoryListSet dset = (DirectoryListSet)fileset;
				if(!dset.getDirectory().equals(directory)
					|| !dset.getFileFilter().equals(filter)
					|| !dset.isRecursive() == recurse)
					fileset = new DirectoryListSet(directory,filter,recurse);
			}
			else
				fileset = new DirectoryListSet(directory,filter,recurse);
		}
		else
		{
			// can't happen
			fileset = null;
		}
		jEdit.setBooleanProperty(""search.keepDialog.toggle"",
			keepDialog.isSelected());
		jEdit.setBooleanProperty(""search.hypersearch.toggle"",
			hyperSearch.isSelected());
		boolean ok = true;
		if(fileset.getBufferCount() == 0)
		{
			// oops
			GUIUtilities.error(this,""empty-fileset"",null);
			ok = false;
		}
		else
			SearchAndReplace.setSearchFileSet(fileset);
		if(find.getText().length() != 0)
		{
			find.addCurrentToHistory();
			SearchAndReplace.setSearchString(find.getText());
			replace.addCurrentToHistory();
			SearchAndReplace.setReplaceString(replace.getText());
		}
		else
			ok = false;
		return ok;
	}
	private void closeOrKeepDialog()
	{
		if(keepDialog.isSelected())
			return;
		else
		{
			GUIUtilities.saveGeometry(this,""search"");
			setVisible(false);
		}
	}
	// used for the stringReplace and beanShell replace radio buttons,
	// so that the user can press tab to go from the find field to the
	// replace field in one go
	class MyJRadioButton extends JRadioButton
	{
		MyJRadioButton(String label)
		{
			super(label);
		}
		public boolean isFocusTraversable()
		{
			return false;
		}
	}
	class ReplaceActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			replace.setModel(beanShellReplace.isSelected()
				? ""replace.script""
				: ""replace"");
			SearchAndReplace.setBeanShellReplace(
				beanShellReplace.isSelected());
		}
	}
	class SettingsActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == ignoreCase)
				SearchAndReplace.setIgnoreCase(ignoreCase.isSelected());
			else if(source == regexp)
				SearchAndReplace.setRegexp(regexp.isSelected());
			else if(source == searchBack || source == searchForward)
				SearchAndReplace.setReverseSearch(searchBack.isSelected());
			else if(source == wrap)
				SearchAndReplace.setAutoWrapAround(wrap.isSelected());
			updateEnabled();
		}
	}
	class MultiFileActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == choose)
			{
				File dir = new File(directory.getText());
				JFileChooser chooser = new JFileChooser(dir.getParent());
				chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
				chooser.setSelectedFile(dir);
				if(chooser.showOpenDialog(SearchDialog.this)
					== JFileChooser.APPROVE_OPTION)
					directory.setText(chooser.getSelectedFile().getPath());
			}
			else // source is directory or filter field
			{
				// just as if Enter was pressed in another
				// text field
				ok();
			}
		}
	}
	class ButtonActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == closeBtn)
				cancel();
			else if(source == findBtn || source == find
				|| source == replace)
			{
				ok();
			}
			else if(source == replaceBtn)
			{
				save();
				if(SearchAndReplace.replace(view))
					closeOrKeepDialog();
				else
					getToolkit().beep();
			}
			else if(source == replaceAndFindBtn)
			{
				save();
				if(SearchAndReplace.replace(view))
					ok();
				else
					getToolkit().beep();
			}
			else if(source == replaceAllBtn)
			{
				setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
				save();
				if(SearchAndReplace.replaceAll(view))
					closeOrKeepDialog();
				else
					getToolkit().beep();
				setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			}
		}
	}
}
"
org.gjt.sp.jedit.search.SearchFileSet,"/*
 * SearchFileSet.java - Abstract file matcher interface
 * Copyright (C) 1999 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import org.gjt.sp.jedit.*;
/**
 * An abstract interface for matching files.
 * @author Slava Pestov
 * @version $Id: SearchFileSet.java,v 1.9 2000/11/24 06:48:35 sp Exp $
 */
public interface SearchFileSet
{
	/**
	 * Returns the first buffer to search.
	 * @param view The view performing the search
	 */
	Buffer getFirstBuffer(View view);
	/**
	 * Returns the next buffer to search.
	 * @param view The view performing the search
	 * @param buffer The last buffer searched
	 */
	Buffer getNextBuffer(View view, Buffer buffer);
	/**
	 * Called if the specified buffer was found to have a match.
	 * @param buffer The buffer
	 */
	void matchFound(Buffer buffer);
	/**
	 * Returns the number of buffers in this file set.
	 */
	int getBufferCount();
	/**
	 * Returns the BeanShell code that will recreate this file set.
	 * @since jEdit 2.7pre3
	 */
	String getCode();
}
"
org.gjt.sp.jedit.search.SearchMatcher,"/*
 * SearchMatcher.java - Abstract string matcher interface
 * Copyright (C) 1999, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.search;
import javax.swing.text.Segment;
/**
 * An abstract interface for matching strings.
 * @author Slava Pestov
 * @version $Id: SearchMatcher.java,v 1.6 2001/04/27 11:28:46 sp Exp $
 */
public interface SearchMatcher
{
	/**
	 * Returns the offset of the first match of the specified text
	 * within this matcher.
	 * @param text The text to search in
	 * @return an array where the first element is the start offset
	 * of the match, and the second element is the end offset of
	 * the match
	 */
	int[] nextMatch(Segment text);
	/**
	 * Returns the specified text, with any substitution specified
	 * within this matcher performed.
	 * @param text The text
	 * @return The changed string
	 */
	String substitute(String text) throws Exception;
}
"
org.gjt.sp.jedit.syntax.KeywordMap,"/*
 * KeywordMap.java - Fast keyword->id map
 * Copyright (C) 1998, 1999 Slava Pestov
 * Copyright (C) 1999 Mike Dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.TextUtilities;
/**
 * A <code>KeywordMap</code> is similar to a hashtable in that it maps keys
 * to values. However, the `keys' are Swing segments. This allows lookups of
 * text substrings without the overhead of creating a new string object.
 *
 * @author Slava Pestov, Mike Dillon
 * @version $Id: KeywordMap.java,v 1.18 2000/11/07 10:08:32 sp Exp $
 */
public class KeywordMap
{
	/**
	 * Creates a new <code>KeywordMap</code>.
	 * @param ignoreCase True if keys are case insensitive
	 */
	public KeywordMap(boolean ignoreCase)
	{
		this(ignoreCase, 52);
		this.ignoreCase = ignoreCase;
	}
	/**
	 * Creates a new <code>KeywordMap</code>.
	 * @param ignoreCase True if the keys are case insensitive
	 * @param mapLength The number of `buckets' to create.
	 * A value of 52 will give good performance for most maps.
	 */
	public KeywordMap(boolean ignoreCase, int mapLength)
	{
		this.mapLength = mapLength;
		this.ignoreCase = ignoreCase;
		map = new Keyword[mapLength];
	}
	/**
	 * Looks up a key.
	 * @param text The text segment
	 * @param offset The offset of the substring within the text segment
	 * @param length The length of the substring
	 */
	public byte lookup(Segment text, int offset, int length)
	{
		if(length == 0)
			return Token.NULL;
		Keyword k = map[getSegmentMapKey(text, offset, length)];
		while(k != null)
		{
			if(length != k.keyword.length)
			{
				k = k.next;
				continue;
			}
			if(TextUtilities.regionMatches(ignoreCase,text,offset,
				k.keyword))
				return k.id;
			k = k.next;
		}
		return Token.NULL;
	}
	/**
	 * Adds a key-value mapping.
	 * @param keyword The key
	 * @Param id The value
	 */
	public void add(String keyword, byte id)
	{
		int key = getStringMapKey(keyword);
		map[key] = new Keyword(keyword.toCharArray(),id,map[key]);
	}
	/**
	 * Returns true if the keyword map is set to be case insensitive,
	 * false otherwise.
	 */
	public boolean getIgnoreCase()
	{
		return ignoreCase;
	}
	/**
	 * Sets if the keyword map should be case insensitive.
	 * @param ignoreCase True if the keyword map should be case
	 * insensitive, false otherwise
	 */
	public void setIgnoreCase(boolean ignoreCase)
	{
		this.ignoreCase = ignoreCase;
	}
	// protected members
	protected int mapLength;
	protected int getStringMapKey(String s)
	{
		return (Character.toUpperCase(s.charAt(0)) +
				Character.toUpperCase(s.charAt(s.length()-1)))
				% mapLength;
	}
	protected int getSegmentMapKey(Segment s, int off, int len)
	{
		return (Character.toUpperCase(s.array[off]) +
				Character.toUpperCase(s.array[off + len - 1]))
				% mapLength;
	}
	// private members
	class Keyword
	{
		public Keyword(char[] keyword, byte id, Keyword next)
		{
			this.keyword = keyword;
			this.id = id;
			this.next = next;
		}
		public char[] keyword;
		public byte id;
		public Keyword next;
	}
	private Keyword[] map;
	private boolean ignoreCase;
}
/*
 * ChangeLog:
 * $Log: KeywordMap.java,v $
 * Revision 1.18  2000/11/07 10:08:32  sp
 * Options dialog improvements, documentation changes, bug fixes
 *
 * Revision 1.17  2000/04/07 06:57:26  sp
 * Buffer options dialog box updates, API docs updated a bit in syntax package
 *
 * Revision 1.16  1999/12/13 03:40:30  sp
 * Bug fixes, syntax is now mostly GPL'd
 *
 * Revision 1.15  1999/06/05 02:13:22  sp
 * LGPL'd remaining syntax files
 *
 * Revision 1.14  1999/05/01 00:55:11  sp
 * Option pane updates (new, easier API), syntax colorizing updates
 *
 * Revision 1.13  1999/04/19 05:38:20  sp
 * Syntax API changes
 *
 * Revision 1.12  1999/04/07 05:22:46  sp
 * Buffer options bug fix, keyword map API change (get/setIgnoreCase() methods)
 *
 * Revision 1.11  1999/03/17 05:32:52  sp
 * Event system bug fix, history text field updates (but it still doesn't work), code cleanups, lots of banging head against wall
 *
 * Revision 1.10  1999/03/13 08:50:39  sp
 * Syntax colorizing updates and cleanups, general code reorganizations
 *
 * Revision 1.9  1999/03/13 00:09:07  sp
 * Console updates, uncomment removed cos it's too buggy, cvs log tags added
 *
 */
"
org.gjt.sp.jedit.syntax.ParserRule,"/*
 * ParserRule.java - Sequence match rule for the token marker
 * Copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
/**
 * A parser rule.
 * @author mike dillon
 * @version $Id: ParserRule.java,v 1.5 2000/04/09 10:41:26 sp Exp $
 */
public class ParserRule
{
	// public members
	public final char[] searchChars;
	public final int[] sequenceLengths;
	public final int action;
	public final byte token;
	public ParserRule next;
	// package-private members
	ParserRule(char[] searchChars, int[] sequenceLengths, int action, byte token)
	{
		this.searchChars = searchChars;
		this.sequenceLengths = sequenceLengths;
		this.action = action;
		this.token = token;
	}
}
/*
 * ChangeLog:
 * $Log: ParserRule.java,v $
 * Revision 1.5  2000/04/09 10:41:26  sp
 * NO_WORD_BREAK SPANs fixed, action tokens removed
 *
 * Revision 1.4  2000/04/08 06:57:14  sp
 * Parser rules are now hashed; this dramatically speeds up tokenization
 *
 * Revision 1.3  2000/04/07 06:57:26  sp
 * Buffer options dialog box updates, API docs updated a bit in syntax package
 *
 * Revision 1.2  2000/04/01 08:40:55  sp
 * Streamlined syntax highlighting, Perl mode rewritten in XML
 *
 */
"
org.gjt.sp.jedit.syntax.ParserRuleFactory,"/*
 * ParserRuleFactory.java - Factory object for creating ParserRules
 * Copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
/**
 * Creates parser rules.
 * @author mike dillon
 * @version $Id: ParserRuleFactory.java,v 1.4 2000/04/09 10:41:26 sp Exp $
 */
public class ParserRuleFactory
{
	// public members
	public static final ParserRule createSpanRule(String begin, String end,
		byte id, boolean noLineBreak, boolean atLineStart,
		boolean excludeMatch, boolean noWordBreak)
	{
		int ruleAction = TokenMarker.SPAN |
			((noLineBreak) ? TokenMarker.NO_LINE_BREAK : 0) |
			((atLineStart) ? TokenMarker.AT_LINE_START : 0) |
			((excludeMatch) ? TokenMarker.EXCLUDE_MATCH : 0) |
			((noWordBreak) ? TokenMarker.NO_WORD_BREAK : 0);
		String[] strings = new String[2];
		strings[0] = begin;
		strings[1] = end;
		int[] ruleSeqLengths = getStringLengthArray(strings);
		char[] ruleChars = getCharArray(strings, ruleSeqLengths);
		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}
	public static final ParserRule createDelegateSpanRule(String begin, String end,
		String delegateSet, byte id, boolean noLineBreak, boolean atLineStart,
		boolean excludeMatch, boolean noWordBreak)
	{
		int ruleAction = TokenMarker.SPAN |
			TokenMarker.DELEGATE |
			((noLineBreak) ? TokenMarker.NO_LINE_BREAK : 0) |
			((atLineStart) ? TokenMarker.AT_LINE_START : 0) |
			((excludeMatch) ? TokenMarker.EXCLUDE_MATCH : 0) |
			((noWordBreak) ? TokenMarker.NO_WORD_BREAK : 0);
		String[] strings = new String[3];
		strings[0] = begin;
		strings[1] = end;
		strings[2] = delegateSet;
		int[] ruleSeqLengths = getStringLengthArray(strings);
		char[] ruleChars = getCharArray(strings, ruleSeqLengths);
		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}
	public static final ParserRule createEOLSpanRule(String seq, byte id,
		boolean atLineStart, boolean excludeMatch)
	{
		int ruleAction = TokenMarker.EOL_SPAN |
			((atLineStart) ? TokenMarker.AT_LINE_START : 0) |
			((excludeMatch) ? TokenMarker.EXCLUDE_MATCH : 0);
		String[] strings = new String[1];
		strings[0] = seq;
		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}
		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}
	public static final ParserRule createMarkPreviousRule(String seq, byte id,
		boolean atLineStart, boolean excludeMatch)
	{
		int ruleAction = TokenMarker.MARK_PREVIOUS |
			((atLineStart) ? TokenMarker.AT_LINE_START : 0) |
			((excludeMatch) ? TokenMarker.EXCLUDE_MATCH : 0);
		String[] strings = new String[1];
		strings[0] = seq;
		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}
		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}
	public static final ParserRule createMarkFollowingRule(String seq, byte id,
		boolean atLineStart, boolean excludeMatch)
	{
		int ruleAction = TokenMarker.MARK_FOLLOWING |
			((atLineStart) ? TokenMarker.AT_LINE_START : 0) |
			((excludeMatch) ? TokenMarker.EXCLUDE_MATCH : 0);
		String[] strings = new String[1];
		strings[0] = seq;
		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}
		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}
	public static final ParserRule createSequenceRule(String seq, byte id, boolean atLineStart)
	{
		int ruleAction = ((atLineStart) ? TokenMarker.AT_LINE_START : 0);
		String[] strings = new String[1];
		strings[0] = seq;
		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}
		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}
	public static final ParserRule createEscapeRule(String seq)
	{
		int ruleAction = TokenMarker.IS_ESCAPE;
		String[] strings = new String[1];
		strings[0] = seq;
		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}
		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, Token.NULL);
	}
	public static final ParserRule createWhitespaceRule(String seq)
	{
		int ruleAction = TokenMarker.WHITESPACE;
		String[] strings = new String[1];
		strings[0] = seq;
		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}
		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, Token.NULL);
	}
	// private members
	private static char[] getCharArray(String[] strings, int[] lengthArray)
	{
		if (lengthArray == null || lengthArray.length == 0) return new char[0];
		char[] chars;
		int charArrayLength = 0;
		for (int i = 0; i < lengthArray.length; i++)
		{
			charArrayLength += lengthArray[i];
		}
		chars = new char[charArrayLength];
		int copyOffset = 0;
		for (int i = 0; i < strings.length; i++)
		{
			if (strings[i] != null)
			{
				System.arraycopy(strings[i].toCharArray(),0,chars,copyOffset,lengthArray[i]);
				copyOffset += lengthArray[i];
			}
		}
		return chars;
	}
	private static int[] getStringLengthArray(String[] strings)
	{
		int[] stringLengthArray;
		if (strings == null) return new int[0];
		stringLengthArray = new int[strings.length];
		for (int i = 0; i < strings.length; i++)
		{
			if (strings[i] != null)
			{
				stringLengthArray[i] = strings[i].length();
			}
		}
		return stringLengthArray;
	}
}
/*
 * ChangeLog:
 * $Log: ParserRuleFactory.java,v $
 * Revision 1.4  2000/04/09 10:41:26  sp
 * NO_WORD_BREAK SPANs fixed, action tokens removed
 *
 * Revision 1.3  2000/04/07 06:57:26  sp
 * Buffer options dialog box updates, API docs updated a bit in syntax package
 *
 * Revision 1.2  2000/04/01 08:40:55  sp
 * Streamlined syntax highlighting, Perl mode rewritten in XML
 *
 */
"
org.gjt.sp.jedit.syntax.ParserRuleSet,"/*
 * ParserRuleSet.java - A set of parser rules
 * Copyright (C) 1999 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import java.util.Enumeration;
import java.util.Vector;
import javax.swing.text.Segment;
/**
 * A set of parser rules.
 * @author mike dillon
 * @version $Id: ParserRuleSet.java,v 1.7 2000/04/09 10:41:26 sp Exp $
 */
public class ParserRuleSet
{
	public ParserRuleSet()
	{
		ruleMapFirst = new ParserRule[RULE_BUCKET_COUNT];
		ruleMapLast = new ParserRule[RULE_BUCKET_COUNT];
	}
	public void addRule(ParserRule r)
	{
		int key = Character.toUpperCase(r.searchChars[0])
			% RULE_BUCKET_COUNT;
		ParserRule last = ruleMapLast[key];
		if(last == null)
			ruleMapFirst[key] = ruleMapLast[key] = r;
		else
		{
			last.next = r;
			ruleMapLast[key] = r;
		}
	}
	public void dump()
	{
		for(int i = 0; i < RULE_BUCKET_COUNT; i++)
		{
			ParserRule first = ruleMapFirst[i];
			if(first == null)
				System.err.println(0);
			else
			{
				int j = 0;
				while(first != null)
				{
					j++;
					first = first.next;
				}
				System.err.println(j);
			}
		}
	}
	public ParserRule getRules(char ch)
	{
		int key = Character.toUpperCase(ch) % RULE_BUCKET_COUNT;
		return ruleMapFirst[key];
	}
	public int getTerminateChar()
	{
		return terminateChar;
	}
	public void setTerminateChar(int atChar)
	{
		terminateChar = (atChar >= 0) ? atChar : -1;
	}
	public boolean getIgnoreCase()
	{
		return ignoreCase;
	}
	public void setIgnoreCase(boolean b)
	{
		ignoreCase = b;
	}
	public KeywordMap getKeywords()
	{
		return keywords;
	}
	public void setKeywords(KeywordMap km)
	{
		keywords = km;
	}
	public boolean getHighlightDigits()
	{
		return highlightDigits;
	}
	public void setHighlightDigits(boolean highlightDigits)
	{
		this.highlightDigits = highlightDigits;
	}
	public ParserRule getEscapeRule()
	{
		return escapeRule;
	}
	public Segment getEscapePattern()
	{
		if (escapePattern == null && escapeRule != null)
		{
			escapePattern = new Segment(escapeRule.searchChars, 0,
				escapeRule.sequenceLengths[0]);
		}
		return escapePattern;
	}
	public void setEscape(String esc)
	{
		if (esc == null)
		{
			escapeRule = null;
		}
		else
		{
			escapeRule = ParserRuleFactory.createEscapeRule(esc);
		}
		escapePattern = null;
	}
	public byte getDefault()
	{
		return defaultToken;
	}
	public void setDefault(byte def)
	{
		defaultToken = def;
	}
	private static final int RULE_BUCKET_COUNT = 32;
	private KeywordMap keywords;
	private ParserRule[] ruleMapFirst;
	private ParserRule[] ruleMapLast;
	private ParserRule escapeRule;
	private Segment escapePattern;
	private int terminateChar = -1;
	private boolean ignoreCase = true;
	private boolean highlightDigits;
	private byte defaultToken;
}
/*
 * ChangeLog:
 * $Log: ParserRuleSet.java,v $
 * Revision 1.7  2000/04/09 10:41:26  sp
 * NO_WORD_BREAK SPANs fixed, action tokens removed
 *
 * Revision 1.6  2000/04/08 09:34:58  sp
 * Documentation updates, minor syntax changes
 *
 * Revision 1.5  2000/04/08 06:57:14  sp
 * Parser rules are now hashed; this dramatically speeds up tokenization
 *
 * Revision 1.4  2000/04/08 06:10:51  sp
 * Digit highlighting, search bar bug fix
 *
 * Revision 1.3  2000/04/07 06:57:26  sp
 * Buffer options dialog box updates, API docs updated a bit in syntax package
 *
 * Revision 1.2  2000/04/01 08:40:55  sp
 * Streamlined syntax highlighting, Perl mode rewritten in XML
 *
 */
"
org.gjt.sp.jedit.syntax.SyntaxStyle,"/*
 * SyntaxStyle.java - A simple text style class
 * Copyright (C) 1999, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import java.awt.Font;
import java.awt.Color;
/**
 * A simple text style class. It can specify the color, italic flag,
 * and bold flag of a run of text.
 * @author Slava Pestov
 * @version $Id: SyntaxStyle.java,v 1.12 2001/07/15 09:55:14 sp Exp $
 */
public class SyntaxStyle
{
	/**
	 * Creates a new SyntaxStyle.
	 * @param fgColor The text color
	 * @param bgColor The background color
	 * @param font The text font
	 */
	public SyntaxStyle(Color fgColor, Color bgColor, Font font)
	{
		this.fgColor = fgColor;
		this.bgColor = bgColor;
		this.font = font;
	}
	/**
	 * Returns the text color.
	 */
	public Color getForegroundColor()
	{
		return fgColor;
	}
	/**
	 * Returns the background color.
	 */
	public Color getBackgroundColor()
	{
		return bgColor;
	}
	/**
	 * Returns the style font.
	 */
	public Font getFont()
	{
		return font;
	}
	// private members
	private Color fgColor;
	private Color bgColor;
	private Font font;
}
"
org.gjt.sp.jedit.syntax.Token,"/*
 * Token.java - Generic token
 * Copyright (C) 1998, 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
/**
 * A linked list of tokens. Each token has four fields - a token
 * identifier, which can be mapped to a color or font style for
 * painting, a length value which is the length of the token in the
 * text, and pointers to the previous and next tokens in the list,
 * respectively.
 *
 * @author Slava Pestov
 * @version $Id: Token.java,v 1.18 2001/05/13 07:21:27 sp Exp $
 */
public class Token
{
	public static final byte NULL = 0;
	public static final byte COMMENT1 = 1;
	public static final byte COMMENT2 = 2;
	public static final byte LITERAL1 = 3;
	public static final byte LITERAL2 = 4;
	public static final byte LABEL = 5;
	public static final byte KEYWORD1 = 6;
	public static final byte KEYWORD2 = 7;
	public static final byte KEYWORD3 = 8;
	public static final byte FUNCTION = 9;
	public static final byte MARKUP = 10;
	public static final byte OPERATOR = 11;
	public static final byte DIGIT = 12;
	public static final byte INVALID = 13;
	public static final byte ID_COUNT = 14;
	public static final byte END = 127;
	/**
	 * The length of this token.
	 */
	public int length;
	/**
	 * The id of this token.
	 */
	public byte id;
	/**
	 * The previous token in the linked list.
	 * @since jEdit 2.6pre1
	 */
	public Token prev;
	/**
	 * The next token in the linked list.
	 */
	public Token next;
	/**
	 * Creates a new token.
	 * @param length The length of the token
	 * @param id The id of the token
	 */
	public Token(int length, byte id)
	{
		this.length = length;
		this.id = id;
	}
	/**
	 * Returns a string representation of this token.
	 */
	public String toString()
	{
		return ""[id="" + id + "",length="" + length + ""]"";
	}
}
/*
 * ChangeLog:
 * $Log: Token.java,v $
 * Revision 1.18  2001/05/13 07:21:27  sp
 * more stuff
 *
 * Revision 1.17  2000/07/26 07:48:45  sp
 * stuff
 *
 * Revision 1.16  2000/07/14 06:00:45  sp
 * bracket matching now takes syntax info into account
 *
 * Revision 1.15  2000/04/08 02:39:33  sp
 * New Token.MARKUP type, remove Token.{CONSTANT,VARIABLE,DATATYPE}
 *
 * Revision 1.14  2000/04/07 06:57:26  sp
 * Buffer options dialog box updates, API docs updated a bit in syntax package
 *
 * Revision 1.13  2000/04/06 13:09:46  sp
 * More token types added
 *
 * Revision 1.12  1999/12/13 03:40:30  sp
 * Bug fixes, syntax is now mostly GPL'd
 *
 * Revision 1.11  1999/06/05 00:22:58  sp
 * LGPL'd syntax package
 *
 * Revision 1.10  1999/04/22 06:03:26  sp
 * Syntax colorizing change
 *
 * Revision 1.9  1999/04/19 05:38:20  sp
 * Syntax API changes
 *
 * Revision 1.8  1999/04/01 04:13:00  sp
 * Bug fixing for 1.5final
 *
 * Revision 1.7  1999/03/13 08:50:39  sp
 * Syntax colorizing updates and cleanups, general code reorganizations
 *
 * Revision 1.6  1999/03/12 23:51:00  sp
 * Console updates, uncomment removed cos it's too buggy, cvs log tags added
 *
 */
"
org.gjt.sp.jedit.syntax.TokenMarker,"/*
 * TokenMarker.java - Tokenizes lines of text
 * Copyright (C) 1998, 1999, 2000, 2001 Slava Pestov
 * Copyright (C) 1999, 2000 mike dillon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import javax.swing.text.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * A token marker splits lines of text into tokens. Each token carries
 * a length field and an identification tag that can be mapped to a color
 * or font style for painting that token.
 *
 * @author Slava Pestov, mike dillon
 * @version $Id: TokenMarker.java,v 1.60 2001/01/25 02:03:37 sp Exp $
 *
 * @see org.gjt.sp.jedit.syntax.Token
 */
public class TokenMarker
{
	// major actions (total: 8)
	public static final int MAJOR_ACTIONS = 0x000000FF;
	public static final int WHITESPACE = 1 << 0;
	public static final int SPAN = 1 << 1;
	public static final int MARK_PREVIOUS = 1 << 2;
	public static final int MARK_FOLLOWING = 1 << 3;
	public static final int EOL_SPAN = 1 << 4;
//	public static final int MAJOR_ACTION_5 = 1 << 5;
//	public static final int MAJOR_ACTION_6 = 1 << 6;
//	public static final int MAJOR_ACTION_7 = 1 << 7;
	// action hints (total: 8)
	public static final int ACTION_HINTS = 0x0000FF00;
	public static final int EXCLUDE_MATCH = 1 << 8;
	public static final int AT_LINE_START = 1 << 9;
	public static final int NO_LINE_BREAK = 1 << 10;
	public static final int NO_WORD_BREAK = 1 << 11;
	public static final int IS_ESCAPE = 1 << 12;
	public static final int DELEGATE = 1 << 13;
//	public static final int ACTION_HINT_14 = 1 << 14;
//	public static final int ACTION_HINT_15 = 1 << 15;
	public TokenMarker()
	{
		ruleSets = new Hashtable(64);
	}
	public void addRuleSet(String setName, ParserRuleSet rules)
	{
		if (rules == null) return;
		if (setName == null) setName = ""MAIN"";
		ruleSets.put(rulePfx.concat(setName), rules);
	}
	public ParserRuleSet getMainRuleSet()
	{
		return getRuleSet(rulePfx + ""MAIN"");
	}
	public ParserRuleSet getRuleSet(String setName)
	{
		ParserRuleSet rules;
		rules = (ParserRuleSet) ruleSets.get(setName);
		if (rules == null && !setName.startsWith(rulePfx))
		{
			int delim = setName.indexOf(""::"");
			String modeName = setName.substring(0, delim);
			Mode mode = jEdit.getMode(modeName);
			if(mode == null)
			{
				Log.log(Log.ERROR,TokenMarker.class,
					""Unknown edit mode: "" + modeName);
				rules = null;
			}
			else
			{
				TokenMarker marker = mode.getTokenMarker();
				rules = marker.getRuleSet(setName);
			}
			// store external ParserRuleSet in the local hashtable for
			// faster lookups later
			ruleSets.put(setName, rules);
		}
		if (rules == null)
		{
			Log.log(Log.ERROR,this,""Unresolved delegate target: "" + setName);
		}
		return rules;
	}
	public String getName()
	{
		return name;
	}
	public void setName(String name)
	{
		if (name == null) throw new NullPointerException();
		this.name = name;
		rulePfx = name.concat(""::"");
	}
	/**
	 * Do not call this method directly; call Buffer.markTokens() instead.
	 */
	public void markTokens(Buffer.LineInfo prevInfo,
		Buffer.LineInfo info, Segment line)
	{
		LineContext lastContext = (prevInfo == null ? null
			: prevInfo.context);
		if(lastContext == null)
		{
			lastContext = new LineContext(null,
				getRuleSet(rulePfx.concat(""MAIN"")));
		}
		context = info.context;
		context.parent = (lastContext.parent == null ? null
			: (LineContext)lastContext.parent.clone());
		context.inRule = lastContext.inRule;
		context.rules = lastContext.rules;
		lastOffset = lastKeyword = line.offset;
		lineLength = line.count + line.offset;
		int terminateChar = context.rules.getTerminateChar();
		int searchLimit = (terminateChar >= 0 && terminateChar < line.count)
			? line.offset + terminateChar : lineLength;
		escaped = false;
		boolean b;
		boolean tempEscaped;
		Segment tempPattern;
		ParserRule rule;
		LineContext tempContext;
		for(pos = line.offset; pos < searchLimit; pos++)
		{
			// if we are not in the top level context, we are delegated
			if (context.parent != null)
			{
				tempContext = context;
				context = context.parent;
				pattern.array = context.inRule.searchChars;
				pattern.count = context.inRule.sequenceLengths[1];
				pattern.offset = context.inRule.sequenceLengths[0];
				b = handleRule(info, line, context.inRule);
				context = tempContext;
				if (!b)
				{
					if (escaped)
					{
						escaped = false;
					}
					else
					{
						if (pos != lastOffset)
						{
							if (context.inRule == null)
							{
								markKeyword(info,line,lastKeyword,pos);
								info.addToken(pos - lastOffset,
									context.rules.getDefault());
							}
							else if ((context.inRule.action & (NO_LINE_BREAK | NO_WORD_BREAK)) == 0)
							{
								info.addToken(pos - lastOffset,
									context.inRule.token);
							}
							else
							{
								info.addToken(pos - lastOffset, Token.INVALID);
							}
						}
						context = (LineContext) context.parent;
						if ((context.inRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
						{
							info.addToken(pattern.count,
								context.rules.getDefault());
						}
						else
						{
							info.addToken(pattern.count,context.inRule.token);
						}
						context.inRule = null;
						lastKeyword = lastOffset = pos + pattern.count;
					}
					pos += (pattern.count - 1); // move pos to last character of match sequence
					continue;
				}
			}
			// check the escape rule for the current context, if there is one
			if ((rule = context.rules.getEscapeRule()) != null)
			{
				// assign tempPattern to mutable ""buffer"" pattern
				tempPattern = pattern;
				// swap in the escape pattern
				pattern = context.rules.getEscapePattern();
				tempEscaped = escaped;
				b = handleRule(info, line, rule);
				// swap back the buffer pattern
				pattern = tempPattern;
				if (!b)
				{
					if (tempEscaped) escaped = false;
					continue;
				}
			}
			// if we are inside a span, check for its end sequence
			rule = context.inRule;
			if(rule != null && (rule.action & SPAN) == SPAN)
			{
				pattern.array = rule.searchChars;
				pattern.count = rule.sequenceLengths[1];
				pattern.offset = rule.sequenceLengths[0];
				// if we match the end of the span, or if this is a ""hard"" span,
				// we continue to the next character; otherwise, we check all
				// applicable rules below
				if (!handleRule(info,line,rule)
					|| (rule.action & SOFT_SPAN) == 0)
				{
					escaped = false;
					continue;
				}
			}
			// now check every rule
			rule = context.rules.getRules(line.array[pos]);
			while(rule != null)
			{
				pattern.array = rule.searchChars;
				if (context.inRule == rule && (rule.action & SPAN) == SPAN)
				{
					pattern.count = rule.sequenceLengths[1];
					pattern.offset = rule.sequenceLengths[0];
				}
				else
				{
					pattern.count = rule.sequenceLengths[0];
					pattern.offset = 0;
				}
				// stop checking rules if there was a match and go to next pos
				if (!handleRule(info,line,rule))
					break;
				rule = rule.next;
			}
			escaped = false;
		}
		// check for keywords at the line's end
		if(context.inRule == null)
			markKeyword(info, line, lastKeyword, lineLength);
		// mark all remaining characters
		if(lastOffset != lineLength)
		{
			if (context.inRule == null)
			{
				info.addToken(lineLength - lastOffset,
					context.rules.getDefault());
			}
			else if (
				(context.inRule.action & SPAN) == SPAN &&
				(context.inRule.action & (NO_LINE_BREAK | NO_WORD_BREAK)) != 0
			)
			{
				info.addToken(lineLength - lastOffset,Token.INVALID);
				context.inRule = null;
			}
			else
			{
				info.addToken(lineLength - lastOffset,context.inRule.token);
				if((context.inRule.action & MARK_FOLLOWING) == MARK_FOLLOWING)
				{
					context.inRule = null;
				}
			}
		}
		info.context = context;
	}
	// private members
	private static final int SOFT_SPAN = MARK_FOLLOWING | NO_WORD_BREAK;
	private String name;
	private String rulePfx;
	private Hashtable ruleSets;
	private LineContext context;
	private Segment pattern = new Segment(new char[0],0,0);
	private int lastOffset;
	private int lastKeyword;
	private int lineLength;
	private int pos;
	private boolean escaped;
	/**
	 * Checks if the rule matches the line at the current position
	 * and handles the rule if it does match
	 * @param line Segment to check rule against
	 * @param checkRule ParserRule to check against line
	 * @return true,  keep checking other rules
	 *     <br>false, stop checking other rules
	 */
	private boolean handleRule(Buffer.LineInfo info, Segment line,
		ParserRule checkRule)
	{
		if (pattern.count == 0) return true;
		if (lineLength - pos < pattern.count) return true;
		char a, b;
		for (int k = 0; k < pattern.count; k++)
		{
			a = pattern.array[pattern.offset + k];
			b = line.array[pos + k];
			// break out and check the next rule if there is a mismatch
			if (
				!(
					a == b ||
					context.rules.getIgnoreCase() &&
					(
						Character.toLowerCase(a) == b ||
						a == Character.toLowerCase(b)
					)
				)
			) return true;
		}
		if (escaped)
		{
			pos += pattern.count - 1;
			return false;
		}
		else if ((checkRule.action & IS_ESCAPE) == IS_ESCAPE)
		{
			escaped = true;
			pos += pattern.count - 1;
			return false;
		}
		// handle soft spans
		if (context.inRule != checkRule && context.inRule != null
			&& (context.inRule.action & SOFT_SPAN) != 0)
		{
			if ((context.inRule.action & NO_WORD_BREAK) == NO_WORD_BREAK)
			{
				info.addToken(pos - lastOffset, Token.INVALID);
			}
			else
			{
				info.addToken(pos - lastOffset,context.inRule.token);
			}
			lastOffset = lastKeyword = pos;
			context.inRule = null;
		}
		if (context.inRule == null)
		{
			if ((checkRule.action & AT_LINE_START) == AT_LINE_START)
			{
				if (
					(((checkRule.action & MARK_PREVIOUS) != 0) ?
					lastKeyword :
					pos) != line.offset
				)
				{
					return true;
				}
			}
			markKeyword(info, line, lastKeyword, pos);
			if ((checkRule.action & MARK_PREVIOUS) != MARK_PREVIOUS)
			{
				lastKeyword = pos + pattern.count;
				if ((checkRule.action & WHITESPACE) == WHITESPACE)
				{
					return false; // break out of inner for loop to check next char
				}
				// mark previous sequence as NULL (plain text)
				if (lastOffset < pos)
				{
					info.addToken(pos - lastOffset,
						context.rules.getDefault());
				}
			}
			switch(checkRule.action & MAJOR_ACTIONS)
			{
			case 0:
				// this is a plain sequence rule
				info.addToken(pattern.count,checkRule.token);
				lastOffset = pos + pattern.count;
				break;
			case SPAN:
				context.inRule = checkRule;
				if ((checkRule.action & DELEGATE) != DELEGATE)
				{
					if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
					{
						info.addToken(pattern.count,
							context.rules.getDefault());
						lastOffset = pos + pattern.count;
					}
					else
					{
						lastOffset = pos;
					}
				}
				else
				{
					String setName = new String(checkRule.searchChars,
						checkRule.sequenceLengths[0] + checkRule.sequenceLengths[1],
						checkRule.sequenceLengths[2]);
					ParserRuleSet delegateSet = getRuleSet(setName);
					if (delegateSet != null)
					{
						if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
						{
							info.addToken(pattern.count,
								context.rules.getDefault());
						}
						else
						{
							info.addToken(pattern.count,checkRule.token);
						}
						lastOffset = pos + pattern.count;
						context = new LineContext(delegateSet, context);
					}
				}
				break;
			case EOL_SPAN:
				if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
				{
					info.addToken(pattern.count,
						context.rules.getDefault());
					info.addToken(lineLength - (pos + pattern.count),
						checkRule.token);
				}
				else
				{
					info.addToken(lineLength - pos,
						checkRule.token);
				}
				lastOffset = lineLength;
				lastKeyword = lineLength;
				pos = lineLength;
				return false;
			case MARK_PREVIOUS:
				if (lastKeyword > lastOffset)
				{
					info.addToken(lastKeyword - lastOffset,
						context.rules.getDefault());
					lastOffset = lastKeyword;
				}
				if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
				{
					info.addToken(pos - lastOffset, checkRule.token);
					info.addToken(pattern.count,
						context.rules.getDefault());
				}
				else
				{
					info.addToken(pos - lastOffset + pattern.count,
						checkRule.token);
				}
				lastOffset = pos + pattern.count;
				break;
			case MARK_FOLLOWING:
				context.inRule = checkRule;
				if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
				{
					info.addToken(pattern.count,
						context.rules.getDefault());
					lastOffset = pos + pattern.count;
				}
				else
				{
					lastOffset = pos;
				}
				break;
			default:
				throw new InternalError(""Unhandled major action"");
			}
			lastKeyword = lastOffset;
			pos += (pattern.count - 1); // move pos to last character of match sequence
			return false; // break out of inner for loop to check next char
		}
		else if ((checkRule.action & SPAN) == SPAN)
		{
			if ((checkRule.action & DELEGATE) != DELEGATE)
			{
				context.inRule = null;
				if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
				{
					info.addToken(pos - lastOffset,checkRule.token);
					info.addToken(pattern.count,
						context.rules.getDefault());
				}
				else
				{
					info.addToken((pos + pattern.count) - lastOffset,
						checkRule.token);
				}
				lastKeyword = lastOffset = pos + pattern.count;
				pos += (pattern.count - 1); // move pos to last character of match sequence
			}
			return false; // break out of inner for loop to check next char
		}
		return true;
	}
	private void markKeyword(Buffer.LineInfo info, Segment line,
		int start, int end)
	{
		KeywordMap keywords = context.rules.getKeywords();
		int len = end - start;
		// do digits
		if(context.rules.getHighlightDigits())
		{
			boolean digit = true;
			char[] array = line.array;
			boolean octal = false;
			boolean hex = false;
			boolean seenSomeDigits = false;
loop:			for(int i = 0; i < len; i++)
			{
				char ch = array[start+i];
				switch(ch)
				{
				case '0':
					if(i == 0)
						octal = true;
					seenSomeDigits = true;
					continue loop;
				case '1': case '2': case '3':
				case '4': case '5': case '6':
				case '7': case '8': case '9':
					seenSomeDigits = true;
					continue loop;
				case 'x': case 'X':
					if(octal && i == 1)
					{
						hex = true;
						continue loop;
					}
					else
						break;
				case 'd': case 'D':
					if(hex)
						continue loop;
					else
						break;
				case 'f': case 'F':
					if(hex || seenSomeDigits)
						continue loop;
					else
						break;
				case 'l': case 'L':
					if(seenSomeDigits)
						continue loop;
					else
						break;
				case 'e': case 'E':
					if(seenSomeDigits)
						continue loop;
					else
						break;
				case 'a': case 'A': case 'b': case 'B':
				case 'c': case 'C':
					if(hex)
						continue loop;
					else
						break;
				case '.': case '-':
					// normally, this shouldn't be
					// necessary, because most modes
					// define '.' and '-' SEQs. However,
					// in props mode, we can't define
					// such a SEQ because it would
					// break the AT_LINE_START
					// MARK_PREVIOUS rule.
					continue loop;
				default:
					break;
				}
				// if we ended up here, then we have found a
				// non-digit character.
				digit = false;
				break loop;
			}
			// if we got this far with digit = true, then the keyword
			// consists of all digits. Add it as such.
			if(digit)
			{
				if(start != lastOffset)
				{
					info.addToken(start - lastOffset,
						context.rules.getDefault());
				}
				info.addToken(len,Token.DIGIT);
				lastKeyword = lastOffset = end;
				return;
			}
		}
		if(keywords != null)
		{
			byte id = keywords.lookup(line, start, len);
			if(id != Token.NULL)
			{
				if(start != lastOffset)
				{
					info.addToken(start - lastOffset,
						context.rules.getDefault());
				}
				info.addToken(len, id);
				lastKeyword = lastOffset = end;
			}
		}
	}
	public static class LineContext
	{
		public LineContext parent;
		public ParserRule inRule;
		public ParserRuleSet rules;
		public LineContext(ParserRule r, ParserRuleSet rs)
		{
			inRule = r;
			rules = rs;
		}
		public LineContext(ParserRuleSet rs, LineContext lc)
		{
			rules = rs;
			parent = (lc == null ? null : (LineContext)lc.clone());
		}
		public LineContext(ParserRule r)
		{
			inRule = r;
		}
		public LineContext()
		{
		}
		public Object clone()
		{
			LineContext lc = new LineContext();
			lc.inRule = inRule;
			lc.rules = rules;
			lc.parent = (parent == null) ? null : (LineContext) parent.clone();
			return lc;
		}
	}
}
"
org.gjt.sp.jedit.syntax.XModeHandler,"/*
 * XModeHandler.java - XML handler for mode files
 * Copyright (C) 1999 mike dillon
 * Portions copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.syntax;
import com.microstar.xml.*;
import java.io.*;
import java.net.URL;
import java.util.Enumeration;
import java.util.Stack;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
public class XModeHandler extends HandlerBase
{
	// public members
	public XModeHandler (XmlParser parser, String modeName, String path)
	{
		this.modeName = modeName;
		this.parser = parser;
		this.path = path;
		stateStack = new Stack();
	}
	// begin HandlerBase implementation
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""xmode.dtd"".equals(systemId))
		{
			try
			{
				return new BufferedReader(new InputStreamReader(
					getClass().getResourceAsStream(
					""/org/gjt/sp/jedit/xmode.dtd"")));
			}
			catch(Exception e)
			{
				error(""dtd"",e);
			}
		}
		return null;
	}
	public void attribute(String aname, String value, boolean isSpecified)
	{
		String tag = peekElement();
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();
		if (aname == ""NAME"")
		{
			propName = value;
		}
		else if (aname == ""VALUE"")
		{
			propValue = value;
		}
		else if (aname == ""TYPE"")
		{
			lastTokenID = stringToToken(value);
		}
		else if (aname == ""AT_LINE_START"")
		{
			lastAtLineStart = (isSpecified) ? (value == ""TRUE"") :
				false;
		}
		else if (aname == ""NO_LINE_BREAK"")
		{
			lastNoLineBreak = (isSpecified) ? (value == ""TRUE"") :
				false;
		}
		else if (aname == ""NO_WORD_BREAK"")
		{
			lastNoWordBreak = (isSpecified) ? (value == ""TRUE"") :
				false;
		}
		else if (aname == ""EXCLUDE_MATCH"")
		{
			lastExcludeMatch = (isSpecified) ? (value == ""TRUE"") :
				false;
		}
		else if (aname == ""IGNORE_CASE"")
		{
			lastIgnoreCase = (isSpecified) ? (value != ""FALSE"") :
				true;
		}
		else if (aname == ""HIGHLIGHT_DIGITS"")
		{
			lastHighlightDigits = (isSpecified) ? (value != ""FALSE"") :
				false;
		}
		else if (aname == ""AT_CHAR"")
		{
			try
			{
				if (isSpecified) termChar =
					Integer.parseInt(value);
			}
			catch (NumberFormatException e)
			{
				error(""termchar-invalid"",value);
				termChar = -1;
			}
		}
		else if (aname == ""ESCAPE"")
		{
			lastEscape = value;
		}
		else if (aname == ""SET"")
		{
			lastSetName = value;
		}
		else if (aname == ""DELEGATE"")
		{
			lastDelegateSet = value;
		}
		else if (aname == ""DEFAULT"")
		{
			lastDefaultID = stringToToken(value);
		}
	}
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if (""MODE"".equalsIgnoreCase(name)) return;
		error(""doctype-invalid"",name);
	}
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);
		if (tag == ""WHITESPACE"" ||
			tag == ""EOL_SPAN"" ||
			tag == ""MARK_PREVIOUS"" ||
			tag == ""MARK_FOLLOWING"" ||
			tag == ""SEQ"" ||
			tag == ""BEGIN""
		)
		{
			lastStart = text;
		}
		else if (tag == ""END"")
		{
			lastEnd = text;
		}
		else
		{
			lastKeyword = text;
		}
	}
	public void startElement (String tag)
	{
		tag = pushElement(tag);
		if (tag == ""MODE"")
		{
			mode = jEdit.getMode(modeName);
			if (mode == null)
			{
				mode = new Mode(modeName);
				jEdit.addMode(mode);
			}
		}
		else if (tag == ""KEYWORDS"")
		{
			keywords = new KeywordMap(true);
		}
		else if (tag == ""RULES"")
		{
			rules = new ParserRuleSet();
			rules.setIgnoreCase(lastIgnoreCase);
			rules.setHighlightDigits(lastHighlightDigits);
			rules.setEscape(lastEscape);
			rules.setDefault(lastDefaultID);
		}
	}
	public void endElement (String name)
	{
		if (name == null) return;
		String tag = popElement();
		if (name.equalsIgnoreCase(tag))
		{
			if (tag == ""MODE"")
			{
				mode.init();
				mode.setTokenMarker(marker);
			}
			else if (tag == ""PROPERTY"")
			{
				try
				{
					mode.setProperty(propName,
						new Integer(propValue));
				}
				catch(NumberFormatException nf)
				{
					mode.setProperty(propName,propValue);
				}
			}
			else if (tag == ""KEYWORDS"")
			{
				keywords.setIgnoreCase(lastIgnoreCase);
				lastIgnoreCase = true;
			}
			else if (tag == ""RULES"")
			{
				rules.setKeywords(keywords);
				marker.addRuleSet(lastSetName, rules);
				keywords = null;
				lastSetName = null;
				lastEscape = null;
				lastIgnoreCase = true;
				lastHighlightDigits = false;
				lastDefaultID = Token.NULL;
				rules = null;
			}
			else if (tag == ""TERMINATE"")
			{
				setTerminateChar(termChar);
				termChar = -1;
			}
			else if (tag == ""WHITESPACE"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""WHITESPACE"");
					return;
				}
				addRule(ParserRuleFactory.createWhitespaceRule(
					lastStart));
				lastStart = null;
				lastEnd = null;
			}
			else if (tag == ""EOL_SPAN"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""EOL_SPAN"");
					return;
				}
				addRule(ParserRuleFactory.createEOLSpanRule(
					lastStart,lastTokenID,lastAtLineStart,
					lastExcludeMatch));
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastExcludeMatch = false;
			}
			else if (tag == ""MARK_PREVIOUS"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""MARK_PREVIOUS"");
					return;
				}
				addRule(ParserRuleFactory
					.createMarkPreviousRule(lastStart,
					lastTokenID,lastAtLineStart,
					lastExcludeMatch));
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastExcludeMatch = false;
			}
			else if (tag == ""MARK_FOLLOWING"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""MARK_FOLLOWING"");
					return;
				}
				addRule(ParserRuleFactory
					.createMarkFollowingRule(lastStart,
					lastTokenID,lastAtLineStart,
					lastExcludeMatch));
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastExcludeMatch = false;
			}
			else if (tag == ""SEQ"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""SEQ"");
					return;
				}
				addRule(ParserRuleFactory.createSequenceRule(
					lastStart,lastTokenID,lastAtLineStart));
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
			}
			else if (tag == ""END"")
			{
				// empty END tags should be supported; see
				// asp.xml, for example
				/* if(lastEnd == null)
				{
					error(""empty-tag"",""END"");
					return;
				} */
				if (lastDelegateSet == null)
				{
					addRule(ParserRuleFactory
						.createSpanRule(lastStart,
						lastEnd,lastTokenID,
						lastNoLineBreak,
						lastAtLineStart,
						lastExcludeMatch,
						lastNoWordBreak));
				}
				else
				{
					if (lastDelegateSet.indexOf(""::"") == -1)
					{
						lastDelegateSet = modeName + ""::"" + lastDelegateSet;
					}
					addRule(ParserRuleFactory
						.createDelegateSpanRule(
						lastStart,lastEnd,
						lastDelegateSet,
						lastTokenID,lastNoLineBreak,
						lastAtLineStart,
						lastExcludeMatch,
						lastNoWordBreak));
				}
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastNoLineBreak = false;
				lastExcludeMatch = false;
				lastNoWordBreak = false;
				lastDelegateSet = null;
			}
			else if (tag == ""NULL"")
			{
				addKeyword(lastKeyword,Token.NULL);
			}
			else if (tag == ""COMMENT1"")
			{
				addKeyword(lastKeyword,Token.COMMENT1);
			}
			else if (tag == ""COMMENT2"")
			{
				addKeyword(lastKeyword,Token.COMMENT2);
			}
			else if (tag == ""LITERAL1"")
			{
				addKeyword(lastKeyword,Token.LITERAL1);
			}
			else if (tag == ""LITERAL2"")
			{
				addKeyword(lastKeyword,Token.LITERAL2);
			}
			else if (tag == ""LABEL"")
			{
				addKeyword(lastKeyword,Token.LABEL);
			}
			else if (tag == ""KEYWORD1"")
			{
				addKeyword(lastKeyword,Token.KEYWORD1);
			}
			else if (tag == ""KEYWORD2"")
			{
				addKeyword(lastKeyword,Token.KEYWORD2);
			}
			else if (tag == ""KEYWORD3"")
			{
				addKeyword(lastKeyword,Token.KEYWORD3);
			}
			else if (tag == ""FUNCTION"")
			{
				addKeyword(lastKeyword,Token.FUNCTION);
			}
			else if (tag == ""MARKUP"")
			{
				addKeyword(lastKeyword,Token.MARKUP);
			}
			else if (tag == ""OPERATOR"")
			{
				addKeyword(lastKeyword,Token.OPERATOR);
			}
			else if (tag == ""DIGIT"")
			{
				addKeyword(lastKeyword,Token.DIGIT);
			}
		}
		else
		{
			// can't happen
			throw new InternalError();
		}
	}
	public void startDocument()
	{
		marker = new TokenMarker();
		marker.setName(modeName);
		pushElement(null);
	}
	// end HandlerBase implementation
	// private members
	private XmlParser parser;
	private String modeName;
	private String path;
	private TokenMarker marker;
	private KeywordMap keywords;
	private Mode mode;
	private Stack stateStack;
	private String propName;
	private String propValue;
	private String lastStart;
	private String lastEnd;
	private String lastKeyword;
	private String lastSetName;
	private String lastEscape;
	private String lastDelegateSet;
	private ParserRuleSet rules;
	private byte lastDefaultID = Token.NULL;
	private byte lastTokenID;
	private int termChar = -1;
	private boolean lastNoLineBreak;
	private boolean lastNoWordBreak;
	private boolean lastAtLineStart;
	private boolean lastExcludeMatch;
	private boolean lastIgnoreCase = true;
	private boolean lastHighlightDigits;
	private byte stringToToken(String value)
	{
		if (value == ""NULL"")
		{
			return Token.NULL;
		}
		else if (value == ""COMMENT1"")
		{
			return Token.COMMENT1;
		}
		else if (value == ""COMMENT2"")
		{
			return Token.COMMENT2;
		}
		else if (value == ""LITERAL1"")
		{
			return Token.LITERAL1;
		}
		else if (value == ""LITERAL2"")
		{
			return Token.LITERAL2;
		}
		else if (value == ""LABEL"")
		{
			return Token.LABEL;
		}
		else if (value == ""KEYWORD1"")
		{
			return Token.KEYWORD1;
		}
		else if (value == ""KEYWORD2"")
		{
			return Token.KEYWORD2;
		}
		else if (value == ""KEYWORD3"")
		{
			return Token.KEYWORD3;
		}
		else if (value == ""FUNCTION"")
		{
			return Token.FUNCTION;
		}
		else if (value == ""MARKUP"")
		{
			return Token.MARKUP;
		}
		else if (value == ""OPERATOR"")
		{
			return Token.OPERATOR;
		}
		else if (value == ""DIGIT"")
		{
			return Token.DIGIT;
		}
		else if (value == ""INVALID"")
		{
			return Token.INVALID;
		}
		else
		{
			error(""token-invalid"",value);
			return Token.NULL;
		}
	}
	private void addKeyword(String k, byte id)
	{
		if(k == null)
		{
			error(""empty-keyword"");
			return;
		}
		if (keywords == null) return;
		keywords.add(k,id);
	}
	private void addRule(ParserRule r)
	{
		rules.addRule(r);
	}
	private void setTerminateChar(int atChar)
	{
		rules.setTerminateChar(atChar);
	}
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();
		stateStack.push(name);
		return name;
	}
	private String peekElement()
	{
		return (String) stateStack.peek();
	}
	private String popElement()
	{
		return (String) stateStack.pop();
	}
	private void error(String msg)
	{
		_error(jEdit.getProperty(""xmode-error."" + msg));
	}
	private void error(String msg, String subst)
	{
		_error(jEdit.getProperty(""xmode-error."" + msg,new String[] { subst }));
	}
	private void error(String msg, Throwable t)
	{
		_error(jEdit.getProperty(""xmode-error."" + msg,new String[] { t.toString() }));
		Log.log(Log.ERROR,this,t);
	}
	private void _error(String msg)
	{
		Object[] args = { path, new Integer(parser.getLineNumber()),
			new Integer(parser.getColumnNumber()), msg };
		GUIUtilities.error(null,""xmode-error"",args);
	}
}
"
org.gjt.sp.jedit.textarea.Gutter,"/*
 * Gutter.java
 * Copyright (C) 1999, 2000 mike dillon
 * Portions copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;
import org.gjt.sp.jedit.*;
public class Gutter extends JComponent implements SwingConstants
{
	public Gutter(View view, JEditTextArea textArea)
	{
		this.view = view;
		this.textArea = textArea;
		setDoubleBuffered(true);
		MouseHandler ml = new MouseHandler();
		addMouseListener(ml);
		addMouseMotionListener(ml);
	}
	public void paintComponent(Graphics gfx)
	{
		// fill the background
		Rectangle clip = gfx.getClipBounds();
		gfx.setColor(getBackground());
		gfx.fillRect(clip.x, clip.y, clip.width, clip.height);
		// if buffer is loading, don't paint anything
		if (!textArea.getBuffer().isLoaded())
			return;
		// paint highlights and line numbers
		int lineHeight = textArea.getPainter().getFontMetrics()
			.getHeight();
		int firstLine = clip.y / lineHeight + textArea.getFirstLine();
		int lastLine = (clip.y + clip.height - 1) / lineHeight
			+ textArea.getFirstLine();
		FontMetrics pfm = textArea.getPainter().getFontMetrics();
		Color fg = getForeground();
		int baseline = (int)((this.baseline + lineHeight
			- pfm.getDescent()) / 2.0);
		boolean highlightCurrentLine = currentLineHighlightEnabled
			&& textArea.selection.size() == 0;
		int y = (clip.y - clip.y % lineHeight);
		Buffer buffer = textArea.getBuffer();
		int firstValidLine = firstLine >= 0 ? firstLine : 0;
		int lastValidLine = (lastLine >= buffer.getVirtualLineCount())
			? buffer.getVirtualLineCount() - 1 : lastLine;
		for (int line = firstLine; line <= lastLine;
			line++, y += lineHeight)
		{
			boolean valid = (line >= firstValidLine && line <= lastValidLine);
			if(highlights != null)
				highlights.paintHighlight(gfx, line, y);
			if(!valid)
				return;
			// calculate the physical line
			int physicalLine = buffer.virtualToPhysical(line);
			if(physicalLine != buffer.getLineCount() - 1)
			{
				if(buffer.isFoldStart(physicalLine))
				{
					gfx.setColor(foldColor);
					if(buffer.isLineVisible(physicalLine + 1))
						gfx.drawRect(2,y + (lineHeight - 6) / 2,5,5);
					else
						gfx.fillRect(2,y + (lineHeight - 6) / 2,6,6);
				}
			}
			if (!expanded)
				continue;
			String number = Integer.toString(physicalLine + 1);
			int offset;
			switch (alignment)
			{
			case RIGHT:
				offset = gutterSize.width - collapsedSize.width
					- (fm.stringWidth(number) + 1);
				break;
			case CENTER:
				offset = ((gutterSize.width - collapsedSize.width)
					- fm.stringWidth(number)) / 2;
				break;
			case LEFT: default:
				offset = 0;
				break;
			}
			if (physicalLine == textArea.getCaretLine() && highlightCurrentLine)
			{
				gfx.setColor(currentLineHighlight);
			}
			else if (interval > 1 && (line + 1) % interval == 0)
				gfx.setColor(intervalHighlight);
			else
				gfx.setColor(fg);
			gfx.drawString(number, FOLD_MARKER_SIZE + offset,
				baseline + y);
		}
	}
	/**
	 * Adds a custom highlight painter.
	 * @param highlight The highlight
	 */
	public void addCustomHighlight(TextAreaHighlight highlight)
	{
		highlight.init(textArea, highlights);
		highlights = highlight;
	}
	/**
	 * Convenience method for setting a default matte border on the right
	 * with the specified border width and color
	 * @param width The border width (in pixels)
	 * @param color1 The focused border color
	 * @param color2 The unfocused border color
	 * @param color3 The gutter/text area gap color
	 */
	public void setBorder(int width, Color color1, Color color2, Color color3)
	{
		this.borderWidth = width;
		focusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),
			new MatteBorder(0,0,0,width,color1));
		noFocusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),
			new MatteBorder(0,0,0,width,color2));
		updateBorder();
	}
	/**
	 * Sets the border differently if the text area has focus or not.
	 */
	public void updateBorder()
	{
		// because we are called from the text area's focus handler,
		// we do an invokeLater() so that the view's focus handler
		// has a chance to execute and set the edit pane properly
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if(view.getEditPane() == null)
					return;
				if(view.getEditPane().getTextArea() == textArea)
					setBorder(focusBorder);
				else
					setBorder(noFocusBorder);
			}
		});
	}
	/*
	 * JComponent.setBorder(Border) is overridden here to cache the left
	 * inset of the border (if any) to avoid having to fetch it during every
	 * repaint.
	 */
	public void setBorder(Border border)
	{
		super.setBorder(border);
		if (border == null)
		{
			collapsedSize.width = 0;
			collapsedSize.height = 0;
		}
		else
		{
			Insets insets = border.getBorderInsets(this);
			collapsedSize.width = FOLD_MARKER_SIZE + insets.right;
			collapsedSize.height = gutterSize.height
				= insets.top + insets.bottom;
			gutterSize.width = FOLD_MARKER_SIZE + insets.right
				+ fm.stringWidth(""12345"");
		}
	}
	/*
	 * JComponent.setFont(Font) is overridden here to cache the baseline for
	 * the font. This avoids having to get the font metrics during every
	 * repaint.
	 */
	public void setFont(Font font)
	{
		super.setFont(font);
		fm = getFontMetrics(font);
		baseline = fm.getAscent();
	}
	/**
	 * Get the foreground color for highlighted line numbers
	 * @return The highlight color
	 */
	public Color getHighlightedForeground()
	{
		return intervalHighlight;
	}
	public void setHighlightedForeground(Color highlight)
	{
		intervalHighlight = highlight;
	}
	public Color getCurrentLineForeground()
 	{
		return currentLineHighlight;
	}
	public void setCurrentLineForeground(Color highlight)
	{
		currentLineHighlight = highlight;
 	}
	public Color getFoldColor()
 	{
		return foldColor;
	}
	public void setFoldColor(Color foldColor)
	{
		this.foldColor = foldColor;
 	}
	/*
	 * Component.getPreferredSize() is overridden here to support the
	 * collapsing behavior.
	 */
	public Dimension getPreferredSize()
	{
		if (expanded)
			return gutterSize;
		else
			return collapsedSize;
	}
	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	}
	public String getToolTipText(MouseEvent evt)
	{
		return (highlights == null) ? null :
			highlights.getToolTipText(evt);
	}
	/**
	 * Identifies whether the horizontal alignment of the line numbers.
	 * @return Gutter.RIGHT, Gutter.CENTER, Gutter.LEFT
	 */
	public int getLineNumberAlignment()
	{
		return alignment;
	}
	/**
	 * Sets the horizontal alignment of the line numbers.
	 * @param alignment Gutter.RIGHT, Gutter.CENTER, Gutter.LEFT
	 */
	public void setLineNumberAlignment(int alignment)
	{
		if (this.alignment == alignment) return;
		this.alignment = alignment;
		repaint();
	}
	/**
	 * Identifies whether the gutter is collapsed or expanded.
	 * @return true if the gutter is expanded, false if it is collapsed
	 */
	public boolean isExpanded()
	{
		return expanded;
	}
	/**
	 * Sets whether the gutter is collapsed or expanded and force the text
	 * area to update its layout if there is a change.
	 * @param collapsed true if the gutter is expanded,
	 *                   false if it is collapsed
	 */
	public void setExpanded(boolean expanded)
	{
		if (this.expanded == expanded) return;
		this.expanded = expanded;
		textArea.revalidate();
	}
	/**
	 * Toggles whether the gutter is collapsed or expanded.
	 */
	public void toggleExpanded()
	{
		setExpanded(!expanded);
	}
	/**
	 * Sets the number of lines between highlighted line numbers.
	 * @return The number of lines between highlighted line numbers or
	 *          zero if highlighting is disabled
	 */
	public int getHighlightInterval()
	{
		return interval;
	}
	/**
	 * Sets the number of lines between highlighted line numbers. Any value
	 * less than or equal to one will result in highlighting being disabled.
	 * @param interval The number of lines between highlighted line numbers
	 */
	public void setHighlightInterval(int interval)
	{
		if (interval <= 1) interval = 0;
		this.interval = interval;
		repaint();
	}
	public boolean isCurrentLineHighlightEnabled()
	{
		return currentLineHighlightEnabled;
	}
	public void setCurrentLineHighlightEnabled(boolean enabled)
	{
		if (currentLineHighlightEnabled == enabled) return;
		currentLineHighlightEnabled = enabled;
		repaint();
	}
	// private members
	private static final int FOLD_MARKER_SIZE = 10;
	private View view;
	private JEditTextArea textArea;
	private TextAreaHighlight highlights;
	private int baseline;
	private Dimension gutterSize = new Dimension(0,0);
	private Dimension collapsedSize = new Dimension(0,0);
	private Color intervalHighlight;
	private Color currentLineHighlight;
	private Color foldColor;
	private FontMetrics fm;
	private int alignment;
	private int interval;
	private boolean currentLineHighlightEnabled;
	private boolean expanded;
	private int borderWidth;
	private Border focusBorder, noFocusBorder;
	class MouseHandler implements MouseListener, MouseMotionListener
	{
		boolean drag;
		int toolTipInitialDelay, toolTipReshowDelay;
		public void mouseEntered(MouseEvent e)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			toolTipInitialDelay = ttm.getInitialDelay();
			toolTipReshowDelay = ttm.getReshowDelay();
			ttm.setInitialDelay(0);
			ttm.setReshowDelay(0);
		}
		public void mouseExited(MouseEvent evt)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			ttm.setInitialDelay(toolTipInitialDelay);
			ttm.setReshowDelay(toolTipReshowDelay);
		}
		public void mousePressed(MouseEvent e)
		{
			if(e.getX() < getWidth() - borderWidth * 2)
			{
				Buffer buffer = textArea.getBuffer();
				int line = e.getY() / textArea.getPainter()
					.getFontMetrics().getHeight()
					+ textArea.getFirstLine();
				if(line > buffer.getVirtualLineCount() - 1)
					return;
				line = buffer.virtualToPhysical(line);
				if(buffer.isFoldStart(line))
				{
					if(e.isControlDown())
					{
						buffer.expandFoldAt(line,true,textArea);
						textArea.selectFoldAt(line);
					}
					else if(buffer.isLineVisible(line + 1))
						buffer.collapseFoldAt(line);
					else
						buffer.expandFoldAt(line,e.isShiftDown(),textArea);
				}
			}
			else
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mousePressed(e);
				drag = true;
			}
		}
		public void mouseDragged(MouseEvent e)
		{
			if(drag && e.getX() >= getWidth() - borderWidth * 2)
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mouseDragged(e);
			}
		}
		public void mouseMoved(MouseEvent e) {}
		public void mouseReleased(MouseEvent e)
		{
			if(drag && e.getX() >= getWidth() - borderWidth * 2)
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mouseReleased(e);
			}
			drag = false;
		}
		public void mouseClicked(MouseEvent e) {}
	}
}
"
org.gjt.sp.jedit.textarea.JEditTextArea,"/*
 * JEditTextArea.java - jEdit's text component
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 * Portions copyright (C) 2000 Ollie Rutherfurd
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.plaf.metal.MetalLookAndFeel;
import javax.swing.text.BadLocationException;
import javax.swing.text.Element;
import javax.swing.text.Segment;
import javax.swing.text.Utilities;
import javax.swing.undo.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
/**
 * jEdit's text component.
 *
 * @author Slava Pestov
 * @version $Id: JEditTextArea.java,v 1.159 2001/08/27 07:03:58 sp Exp $
 */
public class JEditTextArea extends JComponent
{
	/**
	 * Creates a new JEditTextArea.
	 */
	public JEditTextArea(View view)
	{
		enableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);
		this.view = view;
		// Initialize some misc. stuff
		selection = new Vector();
		renderer = TextRenderer.createTextRenderer();
		painter = new TextAreaPainter(this);
		gutter = new Gutter(view,this);
		documentHandler = new DocumentHandler();
		foldHandler = new FoldHandler();
		listenerList = new EventListenerList();
		caretEvent = new MutableCaretEvent();
		bracketLine = bracketPosition = -1;
		blink = true;
		lineSegment = new Segment();
		// Initialize the GUI
		setLayout(new ScrollLayout());
		add(LEFT,gutter);
		add(CENTER,painter);
		add(RIGHT,vertical = new JScrollBar(JScrollBar.VERTICAL));
		add(BOTTOM,horizontal = new JScrollBar(JScrollBar.HORIZONTAL));
		horizontal.setValues(0,0,0,0);
		// this ensures that the text area's look is slightly
		// more consistent with the rest of the metal l&f.
		// while it depends on not-so-well-documented portions
		// of Swing, it only affects appearance, so future
		// breakage shouldn't matter
		if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)
		{
			setBorder(new TextAreaBorder());
			vertical.putClientProperty(""JScrollBar.isFreeStanding"",
				Boolean.FALSE);
			horizontal.putClientProperty(""JScrollBar.isFreeStanding"",
				Boolean.FALSE);
			//horizontal.setBorder(null);
		}
		// Add some event listeners
		vertical.addAdjustmentListener(new AdjustHandler());
		horizontal.addAdjustmentListener(new AdjustHandler());
		painter.addComponentListener(new ComponentHandler());
		mouseHandler = new MouseHandler();
		painter.addMouseListener(mouseHandler);
		painter.addMouseMotionListener(mouseHandler);
		addFocusListener(new FocusHandler());
		// This doesn't seem very correct, but it fixes a problem
		// when setting the initial caret position for a buffer
		// (eg, from the recent file list)
		focusedComponent = this;
	}
	/**
	 * Returns the object responsible for painting this text area.
	 */
	public final TextAreaPainter getPainter()
	{
		return painter;
	}
 	/**
	 * Returns the gutter to the left of the text area or null if the gutter
	 * is disabled
	 */
	public final Gutter getGutter()
	{
		return gutter;
	}
	/**
	 * Returns true if the caret is blinking, false otherwise.
	 */
	public final boolean isCaretBlinkEnabled()
	{
		return caretBlinks;
	}
	/**
	 * Toggles caret blinking.
	 * @param caretBlinks True if the caret should blink, false otherwise
	 */
	public void setCaretBlinkEnabled(boolean caretBlinks)
	{
		this.caretBlinks = caretBlinks;
		if(!caretBlinks)
			blink = false;
		if(buffer != null)
			invalidateLine(caretLine);
	}
	/**
	 * Blinks the caret.
	 */
	public final void blinkCaret()
	{
		if(caretBlinks)
		{
			blink = !blink;
			invalidateLine(caretLine);
		}
		else
			blink = true;
	}
	/**
	 * Returns the number of lines from the top and button of the
	 * text area that are always visible.
	 */
	public final int getElectricScroll()
	{
		return electricScroll;
	}
	/**
	 * Sets the number of lines from the top and bottom of the text
	 * area that are always visible
	 * @param electricScroll The number of lines always visible from
	 * the top or bottom
	 */
	public final void setElectricScroll(int electricScroll)
	{
		this.electricScroll = electricScroll;
	}
	/**
	 * Returns if clicking the middle mouse button pastes the most
	 * recent selection (% register).
	 */
	public final boolean isMiddleMousePasteEnabled()
	{
		return middleMousePaste;
	}
	/**
	 * Sets if clicking the middle mouse button pastes the most
	 * recent selection (% register).
	 * @param middleMousePaste A boolean flag
	 */
	public final void setMiddleMousePasteEnabled(boolean middleMousePaste)
	{
		this.middleMousePaste = middleMousePaste;
	}
	/**
	 * Updates the state of the scroll bars. This should be called
	 * if the number of lines in the buffer changes, or when the
	 * size of the text are changes.
	 */
	public void updateScrollBars()
	{
		if(vertical != null && visibleLines != 0)
		{
			// don't display stuff past the end of the buffer if
			// we can help it
			int lineCount = getVirtualLineCount();
			if(lineCount < firstLine + visibleLines)
			{
				// this will call updateScrollBars(), so
				// just return...
				int newFirstLine = Math.max(0,lineCount - visibleLines);
				if(newFirstLine != firstLine)
				{
					setFirstLine(newFirstLine);
					return;
				}
			}
			vertical.setValues(firstLine,visibleLines,0,lineCount);
			vertical.setUnitIncrement(2);
			vertical.setBlockIncrement(visibleLines);
		}
		int width = painter.getWidth();
		if(horizontal != null && width != 0)
		{
			maxHorizontalScrollWidth = 0;
			painter.repaint();
			horizontal.setUnitIncrement(painter.getFontMetrics()
				.charWidth('w'));
			horizontal.setBlockIncrement(width / 2);
		}
	}
	/**
	 * Returns the line displayed at the text area's origin. This is
	 * a virtual, not a physical, line number.
	 */
	public final int getFirstLine()
	{
		return firstLine;
	}
	/**
	 * Sets the line displayed at the text area's origin. This is
	 * a virtual, not a physical, line number.
	 */
	public void setFirstLine(int firstLine)
	{
		if(firstLine == this.firstLine)
			return;
		_setFirstLine(firstLine);
		view.synchroScrollVertical(this,firstLine);
	}
	public void _setFirstLine(int firstLine)
	{
		this.firstLine = Math.max(0,firstLine);
		physFirstLine = buffer.virtualToPhysical(this.firstLine);
		maxHorizontalScrollWidth = 0;
		// hack so that if we scroll and the matching bracket
		// comes into view, it is highlighted
		// 3.2pre9 update: I am commenting this out once again because
		// I have changed the location of the documentChanged() call
		// in the DocumentHandler, so this is called before the caret
		// position is updated, which can be potentially tricky.
		//if(bracketPosition == -1)
		//	updateBracketHighlight();
		if(this.firstLine != vertical.getValue())
			updateScrollBars();
		painter.repaint();
		gutter.repaint();
		fireScrollEvent(true);
	}
	/**
	 * Returns the number of lines visible in this text area.
	 */
	public final int getVisibleLines()
	{
		return visibleLines;
	}
	/**
	 * Returns the horizontal offset of drawn lines.
	 */
	public final int getHorizontalOffset()
	{
		return horizontalOffset;
	}
	/**
	 * Sets the horizontal offset of drawn lines. This can be used to
	 * implement horizontal scrolling.
	 * @param horizontalOffset offset The new horizontal offset
	 */
	public void setHorizontalOffset(int horizontalOffset)
	{
		if(horizontalOffset == this.horizontalOffset)
			return;
		_setHorizontalOffset(horizontalOffset);
		view.synchroScrollHorizontal(this,horizontalOffset);
	}
	public void _setHorizontalOffset(int horizontalOffset)
	{
		this.horizontalOffset = horizontalOffset;
		if(horizontalOffset != horizontal.getValue())
			updateScrollBars();
		painter.repaint();
		fireScrollEvent(false);
	}
	/**
	 * @deprecated Use setFirstLine() and setHorizontalOffset() instead
	 */
	public boolean setOrigin(int firstLine, int horizontalOffset)
	{
		setFirstLine(firstLine);
		setHorizontalOffset(horizontalOffset);
		return true;
	}
	/**
	 * Centers the caret on the screen.
	 * @since jEdit 2.7pre2
	 */
	public void centerCaret()
	{
		Element map = buffer.getDefaultRootElement();
		int gotoLine = buffer.virtualToPhysical(firstLine + visibleLines / 2);
		if(gotoLine < 0 || gotoLine >= map.getElementCount())
		{
			getToolkit().beep();
			return;
		}
		Element element = map.getElement(gotoLine);
		setCaretPosition(element.getStartOffset());
	}
	/**
	 * Scrolls up by one line.
	 * @since jEdit 2.7pre2
	 */
	public void scrollUpLine()
	{
		if(firstLine > 0)
			setFirstLine(firstLine-1);
		else
			getToolkit().beep();
	}
	/**
	 * Scrolls up by one page.
	 * @since jEdit 2.7pre2
	 */
	public void scrollUpPage()
	{
		if(firstLine > 0)
		{
			int newFirstLine = firstLine - visibleLines;
			setFirstLine(newFirstLine);
		}
		else
		{
			getToolkit().beep();
		}
	}
	/**
	 * Scrolls down by one line.
	 * @since jEdit 2.7pre2
	 */
	public void scrollDownLine()
	{
		int numLines = getVirtualLineCount();
		if(firstLine + visibleLines < numLines)
			setFirstLine(firstLine + 1);
		else
			getToolkit().beep();
	}
	/**
	 * Scrolls down by one page.
	 * @since jEdit 2.7pre2
	 */
	public void scrollDownPage()
	{
		int numLines = getVirtualLineCount();
		if(firstLine + visibleLines < numLines)
		{
			int newFirstLine = firstLine + visibleLines;
			setFirstLine(newFirstLine + visibleLines < numLines
				? newFirstLine : numLines - visibleLines);
		}
		else
		{
			getToolkit().beep();
		}
	}
	/**
	 * Ensures that the caret is visible by scrolling the text area if
	 * necessary.
	 * @param doElectricScroll If true, electric scrolling will be performed
	 */
	public void scrollToCaret(boolean doElectricScroll)
	{
		if(!buffer.isLineVisible(caretLine))
			buffer.expandFoldAt(caretLine,true,this);
		int offset = caret - getLineStartOffset(caretLine);
		int virtualCaretLine = buffer.physicalToVirtual(caretLine);
		// visibleLines == 0 before the component is realized
		// we can't do any proper scrolling then, so we have
		// this hack...
		if(visibleLines == 0)
		{
			setFirstLine(caretLine - electricScroll);
			return;
		}
		int electricScroll;
		if(doElectricScroll && visibleLines > this.electricScroll * 2)
			electricScroll = this.electricScroll;
		else
			electricScroll = 0;
		boolean changed = false;
		int _firstLine = firstLine + electricScroll;
		int _lastLine = firstLine + visibleLines - electricScroll;
		if(virtualCaretLine > _firstLine && virtualCaretLine < _lastLine)
		{
			// vertical scroll position is correct already
		}
		else if(_firstLine - virtualCaretLine > visibleLines
			|| virtualCaretLine - _lastLine > visibleLines)
		{
			int startLine, endLine;
			Selection s = getSelectionAtOffset(caret);
			if(s == null)
			{
				startLine = endLine = virtualCaretLine;
			}
			else
			{
				startLine = buffer.physicalToVirtual(s.startLine);
				endLine = buffer.physicalToVirtual(s.endLine);
			}
			if(endLine - startLine <= visibleLines)
				firstLine = (startLine + endLine - visibleLines) / 2;
			else
				firstLine = buffer.physicalToVirtual(caretLine) - visibleLines / 2;
			firstLine = Math.min(firstLine,buffer.getVirtualLineCount()
				- visibleLines);
			firstLine = Math.max(firstLine,0);
			changed = true;
		}
		else if(virtualCaretLine < _firstLine)
		{
			firstLine = Math.max(0,virtualCaretLine - electricScroll);
			changed = true;
		}
		else if(virtualCaretLine >= _lastLine)
		{
			firstLine = (virtualCaretLine - visibleLines)
				+ electricScroll + 1;
			if(firstLine >= getVirtualLineCount() - visibleLines)
				firstLine = getVirtualLineCount() - visibleLines;
			changed = true;
		}
		int x = offsetToX(caretLine,offset);
		int width = painter.getFontMetrics().charWidth('w');
		if(x < 0)
		{
			horizontalOffset = Math.min(0,horizontalOffset
				- x + width + 5);
			changed = true;
		}
		else if(x >= painter.getWidth() - width - 5)
		{
			horizontalOffset = horizontalOffset +
				(painter.getWidth() - x) - width - 5;
			changed = true;
		}
		if(changed)
		{
			if(firstLine < 0)
				firstLine = 0;
			physFirstLine = buffer.virtualToPhysical(firstLine);
			updateScrollBars();
			painter.repaint();
			gutter.repaint();
			view.synchroScrollVertical(this,firstLine);
			view.synchroScrollHorizontal(this,horizontalOffset);
			// fire events for both a horizontal and vertical scroll
			fireScrollEvent(true);
			fireScrollEvent(false);
		}
	}
	/**
	 * Converts a line index to a y co-ordinate. This must be a virtual,
	 * not a physical, line number.
	 * @param line The line
	 */
	public int lineToY(int line)
	{
		FontMetrics fm = painter.getFontMetrics();
		return (line - firstLine) * fm.getHeight()
			- (fm.getLeading() + fm.getDescent());
	}
	/**
	 * Converts a y co-ordinate to a virtual line index.
	 * @param y The y co-ordinate
	 */
	public int yToLine(int y)
	{
		FontMetrics fm = painter.getFontMetrics();
		int height = fm.getHeight();
		return Math.max(0,Math.min(getVirtualLineCount() - 1,
			y / height + firstLine));
	}
	/**
	 * Returns the text renderer instance. This method is going away in
	 * the next major release, so do not use it.
	 * @since jEdit 3.2pre6
	 */
	public TextRenderer getTextRenderer()
	{
		return renderer;
	}
	/**
	 * Converts an offset in a line into an x co-ordinate.
	 * @param line The line
	 * @param offset The offset, from the start of the line
	 */
	public int offsetToX(int line, int offset)
	{
		Token tokens = buffer.markTokens(line).getFirstToken();
		getLineText(line,lineSegment);
		char[] text = lineSegment.array;
		int off = lineSegment.offset;
		float x = (float)horizontalOffset;
		Toolkit toolkit = painter.getToolkit();
		Font defaultFont = painter.getFont();
		SyntaxStyle[] styles = painter.getStyles();
		for(;;)
		{
			byte id = tokens.id;
			if(id == Token.END)
				return (int)x;
			Font font;
			if(id == Token.NULL)
				font = defaultFont;
			else
				font = styles[id].getFont();
			int len = tokens.length;
			if(offset < len)
			{
				return (int)(x + renderer.charsWidth(
					text,off,offset,font,x,painter));
			}
			else
			{
				x += renderer.charsWidth(
					text,off,len,font,x,painter);
				off += len;
				offset -= len;
			}
			tokens = tokens.next;
		}
	}
	/**
	 * Converts an x co-ordinate to an offset within a line.
	 * @param line The line
	 * @param x The x co-ordinate
	 */
	public int xToOffset(int line, int x)
	{
		return xToOffset(line,x,true);
	}
	/**
	 * Converts an x co-ordinate to an offset within a line.
	 * @param line The line
	 * @param x The x co-ordinate
	 * @param round Round up to next letter if past the middle of a letter?
	 * @since jEdit 3.2pre6
	 */
	public int xToOffset(int line, int x, boolean round)
	{
		Token tokens = buffer.markTokens(line).getFirstToken();
		getLineText(line,lineSegment);
		char[] text = lineSegment.array;
		int off = lineSegment.offset;
		Toolkit toolkit = painter.getToolkit();
		Font defaultFont = painter.getFont();
		SyntaxStyle[] styles = painter.getStyles();
		float[] widthArray = new float[] { horizontalOffset };
		for(;;)
		{
			byte id = tokens.id;
			if(id == Token.END)
				return lineSegment.count;
			Font font;
			if(id == Token.NULL)
				font = defaultFont;
			else
				font = styles[id].getFont();
			int len = tokens.length;
			int offset = renderer.xToOffset(text,off,len,font,x,
				painter,round,widthArray);
			if(offset != -1)
				return offset - lineSegment.offset;
			off += len;
			tokens = tokens.next;
		}
	}
	/**
	 * Converts a point to an offset, from the start of the text.
	 * @param x The x co-ordinate of the point
	 * @param y The y co-ordinate of the point
	 */
	public int xyToOffset(int x, int y)
	{
		return xyToOffset(x,y,true);
	}
	/**
	 * Converts a point to an offset, from the start of the text.
	 * @param x The x co-ordinate of the point
	 * @param y The y co-ordinate of the point
	 * @param round Round up to next letter if past the middle of a letter?
	 * @since jEdit 3.2pre6
	 */
	public int xyToOffset(int x, int y, boolean round)
	{
		FontMetrics fm = painter.getFontMetrics();
		int height = fm.getHeight();
		int line = y / height + firstLine;
		if(line < 0)
			return 0;
		else if(line >= getVirtualLineCount())
		{
			// WRONG!!!
			// return getBufferLength();
			return getLineEndOffset(buffer.virtualToPhysical(
				buffer.getVirtualLineCount() - 1)) - 1;
		}
		else
		{
			line = buffer.virtualToPhysical(line);
			return getLineStartOffset(line) + xToOffset(line,x);
		}
	}
	/**
	 * Marks a line as needing a repaint.
	 * @param line The line to invalidate
	 */
	public final void invalidateLine(int line)
	{
		line = buffer.physicalToVirtual(line);
		FontMetrics fm = painter.getFontMetrics();
		int y = lineToY(line) + fm.getDescent() + fm.getLeading();
		painter.repaint(0,y,painter.getWidth(),fm.getHeight());
		gutter.repaint(0,y,gutter.getWidth(),fm.getHeight());
	}
	/**
	 * Marks a range of lines as needing a repaint.
	 * @param firstLine The first line to invalidate
	 * @param lastLine The last line to invalidate
	 */
	public final void invalidateLineRange(int firstLine, int lastLine)
	{
		firstLine = buffer.physicalToVirtual(firstLine);
		// all your bugs are belong to us
		if(lastLine > buffer.virtualToPhysical(
			buffer.getVirtualLineCount() - 1))
		{
			lastLine = (lastLine - buffer.getLineCount())
				+ buffer.getVirtualLineCount();
		}
		else
			lastLine = buffer.physicalToVirtual(lastLine);
		FontMetrics fm = painter.getFontMetrics();
		int y = lineToY(firstLine) + fm.getDescent() + fm.getLeading();
		int height = (lastLine - firstLine + 1) * fm.getHeight();
		painter.repaint(0,y,painter.getWidth(),height);
		gutter.repaint(0,y,gutter.getWidth(),height);
	}
	/**
	 * Repaints the lines containing the selection.
	 */
	public final void invalidateSelectedLines()
	{
		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			invalidateLineRange(s.startLine,s.endLine);
		}
	}
	/**
	 * Returns the buffer this text area is editing.
	 */
	public final Buffer getBuffer()
	{
		return buffer;
	}
	/**
	 * Sets the buffer this text area is editing.
	 * @param buffer The buffer
	 */
	public void setBuffer(Buffer buffer)
	{
		if(this.buffer == buffer)
			return;
		if(this.buffer != null)
		{
			this.buffer.removeDocumentListener(documentHandler);
			this.buffer.removeFoldListener(foldHandler);
		}
		this.buffer = buffer;
		buffer.addDocumentListener(documentHandler);
		buffer.addFoldListener(foldHandler);
		documentHandlerInstalled = true;
		maxHorizontalScrollWidth = 0;
		painter.updateTabSize();
		setCaretPosition(0);
		updateScrollBars();
		painter.repaint();
		gutter.repaint();
	}
	/**
	 * Returns the length of the buffer. Equivalent to calling
	 * <code>getBuffer().getLength()</code>.
	 */
	public final int getBufferLength()
	{
		return buffer.getLength();
	}
	/**
	 * Returns the number of lines in the document.
	 */
	public final int getLineCount()
	{
		return buffer.getLineCount();
	}
	/**
	 * Returns the number of visible lines in the document (which may
	 * be less than the total due to folding).
	 * @since jEdit 3.1pre1
	 */
	public final int getVirtualLineCount()
	{
		return buffer.getVirtualLineCount();
	}
	/**
	 * Returns the line containing the specified offset.
	 * @param offset The offset
	 */
	public final int getLineOfOffset(int offset)
	{
		return buffer.getDefaultRootElement().getElementIndex(offset);
	}
	/**
	 * Returns the start offset of the specified line.
	 * @param line The line
	 * @return The start offset of the specified line, or -1 if the line is
	 * invalid
	 */
	public int getLineStartOffset(int line)
	{
		Element lineElement = buffer.getDefaultRootElement()
			.getElement(line);
		if(lineElement == null)
			return -1;
		else
			return lineElement.getStartOffset();
	}
	/**
	 * Returns the end offset of the specified line.
	 * @param line The line
	 * @return The end offset of the specified line, or -1 if the line is
	 * invalid.
	 */
	public int getLineEndOffset(int line)
	{
		Element lineElement = buffer.getDefaultRootElement()
			.getElement(line);
		if(lineElement == null)
			return -1;
		else
			return lineElement.getEndOffset();
	}
	/**
	 * Returns the length of the specified line.
	 * @param line The line
	 */
	public int getLineLength(int line)
	{
		Element lineElement = buffer.getDefaultRootElement()
			.getElement(line);
		if(lineElement == null)
			return -1;
		else
			return lineElement.getEndOffset()
				- lineElement.getStartOffset() - 1;
	}
	/**
	 * Returns the entire text of this text area.
	 */
	public String getText()
	{
		try
		{
			return buffer.getText(0,buffer.getLength());
		}
		catch(BadLocationException bl)
		{
			bl.printStackTrace();
			return null;
		}
	}
	/**
	 * Sets the entire text of this text area.
	 */
	public void setText(String text)
	{
		try
		{
			buffer.beginCompoundEdit();
			buffer.remove(0,buffer.getLength());
			buffer.insertString(0,text,null);
		}
		catch(BadLocationException bl)
		{
			bl.printStackTrace();
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	}
	/**
	 * Returns the specified substring of the buffer.
	 * @param start The start offset
	 * @param len The length of the substring
	 * @return The substring, or null if the offsets are invalid
	 */
	public final String getText(int start, int len)
	{
		try
		{
			return buffer.getText(start,len);
		}
		catch(BadLocationException bl)
		{
			bl.printStackTrace();
			return null;
		}
	}
	/**
	 * Copies the specified substring of the buffer into a segment.
	 * If the offsets are invalid, the segment will contain a null string.
	 * @param start The start offset
	 * @param len The length of the substring
	 * @param segment The segment
	 */
	public final void getText(int start, int len, Segment segment)
	{
		try
		{
			buffer.getText(start,len,segment);
		}
		catch(BadLocationException bl)
		{
			bl.printStackTrace();
			segment.offset = segment.count = 0;
		}
	}
	/**
	 * Returns the text on the specified line.
	 * @param lineIndex The line
	 * @return The text, or null if the line is invalid
	 */
	public final String getLineText(int lineIndex)
	{
		int start = getLineStartOffset(lineIndex);
		return getText(start,getLineEndOffset(lineIndex) - start - 1);
	}
	/**
	 * Copies the text on the specified line into a segment. If the line
	 * is invalid, the segment will contain a null string.
	 * @param lineIndex The line
	 */
	public final void getLineText(int lineIndex, Segment segment)
	{
		Element lineElement = buffer.getDefaultRootElement()
			.getElement(lineIndex);
		int start = lineElement.getStartOffset();
		getText(start,lineElement.getEndOffset() - start - 1,segment);
	}
	/**
	 * Selects all text in the buffer.
	 */
	public final void selectAll()
	{
		setSelection(new Selection.Range(0,buffer.getLength()));
		moveCaretPosition(buffer.getLength(),true);
	}
	/**
	 * Selects the current line.
	 * @since jEdit 2.7pre2
	 */
	public void selectLine()
	{
		int caretLine = getCaretLine();
		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine) - 1;
		setSelection(new Selection.Range(start,end));
		moveCaretPosition(end);
	}
	/**
	 * Selects the paragraph at the caret position.
	 * @since jEdit 2.7pre2
	 */
	public void selectParagraph()
	{
		int caretLine = getCaretLine();
		if(getLineLength(caretLine) == 0)
		{
			view.getToolkit().beep();
			return;
		}
		int start = caretLine;
		int end = caretLine;
		while(start >= 0)
		{
			if(getLineLength(start) == 0)
				break;
			else
				start--;
		}
		while(end < getLineCount())
		{
			if(getLineLength(end) == 0)
				break;
			else
				end++;
		}
		int selectionStart = getLineStartOffset(start + 1);
		int selectionEnd = getLineEndOffset(end - 1) - 1;
		setSelection(new Selection.Range(selectionStart,
			selectionEnd));
		moveCaretPosition(selectionEnd);
	}
	/**
	 * Selects the word at the caret position.
	 * @since jEdit 2.7pre2
	 */
	public void selectWord()
	{
		int line = getCaretLine();
		int lineStart = getLineStartOffset(line);
		int offset = getCaretPosition() - lineStart;
		if(getLineLength(line) == 0)
			return;
		String lineText = getLineText(line);
		String noWordSep = (String)buffer.getProperty(""noWordSep"");
		if(offset == getLineLength(line))
			offset--;
		int wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);
		int wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);
		setSelection(new Selection.Range(lineStart + wordStart,
			lineStart + wordEnd));
		moveCaretPosition(lineStart + wordEnd);
	}
	// OLD (NON-MULTI AWARE) SELECTION API
		/**
		 * @deprecated Instead, obtain a Selection instance using
		 * any means, and call its <code>getStart()</code> method
		 */
		public final int getSelectionStart()
		{
			if(selection.size() != 1)
				return caret;
			return ((Selection)selection.elementAt(0)).getStart();
		}
		/**
		 * @deprecated Instead, obtain a Selection instance using
		 * any means, and call its <code>getStart(int)</code> method
		 */
		public int getSelectionStart(int line)
		{
			if(selection.size() != 1)
				return caret;
			return ((Selection)selection.elementAt(0)).getStart(
				buffer,line);
		}
		/**
		 * @deprecated Instead, obtain a Selection instance using
		 * any means, and call its <code>getStartLine()</code> method
		 */
		public final int getSelectionStartLine()
		{
			if(selection.size() != 1)
				return caret;
			return ((Selection)selection.elementAt(0)).getStartLine();
		}
		/**
		 * @deprecated Do not use.
		 */
		public final void setSelectionStart(int selectionStart)
		{
			select(selectionStart,getSelectionEnd(),true);
		}
		/**
		 * @deprecated Instead, obtain a Selection instance using
		 * any means, and call its <code>getEnd()</code> method
		 */
		public final int getSelectionEnd()
		{
			if(selection.size() != 1)
				return caret;
			return ((Selection)selection.elementAt(0)).getEnd();
		}
		/**
		 * @deprecated Instead, obtain a Selection instance using
		 * any means, and call its <code>getEnd(int)</code> method
		 */
		public int getSelectionEnd(int line)
		{
			if(selection.size() != 1)
				return caret;
			return ((Selection)selection.elementAt(0)).getEnd(
				buffer,line);
		}
		/**
		 * @deprecated Instead, obtain a Selection instance using
		 * any means, and call its <code>getEndLine()</code> method
		 */
		public final int getSelectionEndLine()
		{
			if(selection.size() != 1)
				return caret;
			return ((Selection)selection.elementAt(0)).getEndLine();
		}
		/**
		 * @deprecated Do not use.
		 */
		public final void setSelectionEnd(int selectionEnd)
		{
			select(getSelectionStart(),selectionEnd,true);
		}
		/**
		 * @deprecated Do not use.
		 */
		public final int getMarkPosition()
		{
			Selection s = getSelectionAtOffset(caret);
			if(s == null)
				return caret;
			if(s.start == caret)
				return s.end;
			else if(s.end == caret)
				return s.start;
			else
				return caret;
		}
		/**
		 * @deprecated Do not use.
		 */
		public final int getMarkLine()
		{
			if(selection.size() != 1)
				return caretLine;
			Selection s = (Selection)selection.elementAt(0);
			if(s.start == caret)
				return s.endLine;
			else if(s.end == caret)
				return s.startLine;
			else
				return caretLine;
		}
		/**
		 * @deprecated Instead, call either <code>addToSelection()</code>,
		 * or <code>setSelection()</code> with a new Selection instance.
		 */
		public void select(int start, int end)
		{
			select(start,end,true);
		}
		/**
		 * @deprecated Instead, call either <code>addToSelection()</code>,
		 * or <code>setSelection()</code> with a new Selection instance.
		 */
		public void select(int start, int end, boolean doElectricScroll)
		{
			selectNone();
			int newStart, newEnd;
			if(start < end)
			{
				newStart = start;
				newEnd = end;
			}
			else
			{
				newStart = end;
				newEnd = start;
			}
			setSelection(new Selection.Range(newStart,newEnd));
			moveCaretPosition(end,doElectricScroll);
		}
		/**
		 * @deprecated Instead, check if the appropriate Selection
		 * is an instance of the Selection.Rect class.
		 */
		public boolean isSelectionRectangular()
		{
			Selection s = getSelectionAtOffset(caret);
			if(s == null)
				return false;
			else
				return (s instanceof Selection.Rect);
		}
	// OLD SELECTION API ENDS HERE
	/**
	 * Sets the caret position and deactivates the selection.
	 * @param caret The caret position
	 */
	public void setCaretPosition(int newCaret)
	{
		invalidateSelectedLines();
		selection.removeAllElements();
		moveCaretPosition(newCaret,true);
	}
	/**
	 * Sets the caret position and deactivates the selection.
	 * @param caret The caret position
	 * @param doElectricScroll Do electric scrolling?
	 */
	public void setCaretPosition(int newCaret, boolean doElectricScroll)
	{
		invalidateSelectedLines();
		selection.removeAllElements();
		moveCaretPosition(newCaret,doElectricScroll);
	}
	/**
	 * Sets the caret position without deactivating the selection.
	 * @param caret The caret position
	 */
	public void moveCaretPosition(int newCaret)
	{
		moveCaretPosition(newCaret,true);
	}
	/**
	 * Sets the caret position without deactivating the selection.
	 * @param caret The caret position
	 * @param doElectricScroll Do electric scrolling?
	 */
	public void moveCaretPosition(int newCaret, boolean doElectricScroll)
	{
		if(newCaret < 0 || newCaret > buffer.getLength())
		{
			throw new IllegalArgumentException(""caret out of bounds: ""
				+ newCaret);
		}
		// When the user is typing, etc, we don't want the caret
		// to blink
		blink = true;
		caretTimer.restart();
		if(caret == newCaret)
		{
			// so that C+y <marker>, for example, will return
			// to the saved location even if the caret was
			// never moved but the user scrolled instead
			scrollToCaret(doElectricScroll);
			return;
		}
		int newCaretLine = getLineOfOffset(newCaret);
		magicCaret = offsetToX(newCaretLine,newCaret
			- getLineStartOffset(newCaretLine));
		// call invalidateLine() twice, as opposed to calling
		// invalidateLineRange(), because invalidateLineRange()
		// doesn't handle start > end
		invalidateLine(caretLine);
		invalidateLine(newCaretLine);
		buffer.addUndoableEdit(new CaretUndo(caret));
		caret = newCaret;
		caretLine = newCaretLine;
		if(focusedComponent == this)
			scrollToCaret(doElectricScroll);
		updateBracketHighlight();
		fireCaretEvent();
	}
	/**
	 * Returns the caret position.
	 */
	public int getCaretPosition()
	{
		return caret;
	}
	/**
	 * Returns the line number containing the caret.
	 */
	public int getCaretLine()
	{
		return caretLine;
	}
	/**
	 * Returns the number of selections. This is primarily for use by the
	 * the status bar.
	 * @since jEdit 3.2pre2
	 */
	public int getSelectionCount()
	{
		return selection.size();
	}
	/**
	 * Returns the current selection.
	 * @since jEdit 3.2pre1
	 */
	public Selection[] getSelection()
	{
		Selection[] sel = new Selection[selection.size()];
		selection.copyInto(sel);
		return sel;
	}
	/**
	 * Deselects everything.
	 */
	public void selectNone()
	{
		setSelection((Selection)null);
	}
	/**
	 * Sets the selection.
	 * @param selection The new selection
	 * since jEdit 3.2pre1
	 */
	public void setSelection(Selection[] selection)
	{
		// invalidate the old selection
		invalidateSelectedLines();
		this.selection.removeAllElements();
		if(selection != null)
		{
			for(int i = 0; i < selection.length; i++)
				_addToSelection(selection[i]);
		}
		fireCaretEvent();
	}
	/**
	 * Sets the selection.
	 * @param selection The new selection
	 * since jEdit 3.2pre1
	 */
	public void setSelection(Selection selection)
	{
		invalidateSelectedLines();
		this.selection.removeAllElements();
		if(selection != null)
			_addToSelection(selection);
		fireCaretEvent();
	}
	/**
	 * Adds to the selection.
	 * @param selection The new selection
	 * since jEdit 3.2pre1
	 */
	public void addToSelection(Selection[] selection)
	{
		if(selection != null)
		{
			for(int i = 0; i < selection.length; i++)
				_addToSelection(selection[i]);
		}
		fireCaretEvent();
	}
	/**
	 * Adds to the selection.
	 * @param selection The new selection
	 * since jEdit 3.2pre1
	 */
	public void addToSelection(Selection selection)
	{
		_addToSelection(selection);
		fireCaretEvent();
	}
	/**
	 * Returns the selection containing the specific offset, or null
	 * if there is no selection at that offset.
	 * @param offset The offset
	 * @since jEdit 3.2pre1
	 */
	public Selection getSelectionAtOffset(int offset)
	{
		if(selection != null)
		{
			for(int i = 0; i < selection.size(); i++)
			{
				Selection s = (Selection)selection.elementAt(i);
				if(offset >= s.start && offset <= s.end)
					return s;
			}
		}
		return null;
	}
	/**
	 * Deactivates the specified selection.
	 * @param s The selection
	 * @since jEdit 3.2pre1
	 */
	public void removeFromSelection(Selection sel)
	{
		selection.removeElement(sel);
		invalidateLineRange(sel.startLine,sel.endLine);
		fireCaretEvent();
	}
	/**
	 * Deactivates the selection at the specified offset. If there is
	 * no selection at that offset, does nothing.
	 * @param offset The offset
	 * @since jEdit 3.2pre1
	 */
	public void removeFromSelection(int offset)
	{
		Selection sel = getSelectionAtOffset(offset);
		if(sel == null)
			return;
		selection.removeElement(sel);
		invalidateLineRange(sel.startLine,sel.endLine);
		fireCaretEvent();
	}
	/**
	 * Resizes the selection at the specified offset, or creates a new
	 * one if there is no selection at the specified offset. This is a
	 * utility method that is mainly useful in the mouse event handler
	 * because it handles the case of end being before offset gracefully
	 * (unlike the rest of the selection API).
	 * @param offset The offset
	 * @param end The new selection end
	 * @param rect Make the selection rectangular?
	 * @since jEdit 3.2pre1
	 */
	public void resizeSelection(int offset, int end, boolean rect)
	{
		Selection s = getSelectionAtOffset(offset);
		if(s != null)
		{
			invalidateLineRange(s.startLine,s.endLine);
			selection.removeElement(s);
		}
		if(end < offset)
		{
			int tmp = offset;
			offset = end;
			end = tmp;
		}
		Selection newSel;
		if(rect)
			newSel = new Selection.Rect(offset,end);
		else
			newSel = new Selection.Range(offset,end);
		_addToSelection(newSel);
		fireCaretEvent();
	}
	/**
	 * Extends the selection at the specified offset, or creates a new
	 * one if there is no selection at the specified offset. This is
	 * different from resizing in that the new chunk is added to the
	 * selection in question, instead of replacing it.
	 * @param offset The offset
	 * @param end The new selection end
	 * @param rect Make the selection rectangular?
	 * @since jEdit 3.2pre1
	 */
	public void extendSelection(int offset, int end)
	{
		Selection s = getSelectionAtOffset(offset);
		if(s != null)
		{
			invalidateLineRange(s.startLine,s.endLine);
			selection.removeElement(s);
			if(offset == s.start)
			{
				offset = end;
				end = s.end;
			}
			else if(offset == s.end)
			{
				offset = s.start;
			}
		}
		if(end < offset)
		{
			int tmp = end;
			end = offset;
			offset = tmp;
		}
		_addToSelection(new Selection.Range(offset,end));
		fireCaretEvent();
	}
	/**
	 * Returns the text in the specified selection.
	 * @param s The selection
	 * @since jEdit 3.2pre1
	 */
	public String getSelectedText(Selection s)
	{
		StringBuffer buf = new StringBuffer();
		getSelectedText(s,buf);
		return buf.toString();
	}
	/**
	 * Returns the text in all active selections.
	 * @param separator The string to insert between each text chunk
	 * (for example, a newline)
	 * @since jEdit 3.2pre1
	 */
	public String getSelectedText(String separator)
	{
		if(selection.size() == 0)
			return null;
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < selection.size(); i++)
		{
			if(i != 0)
				buf.append(separator);
			getSelectedText((Selection)selection.elementAt(i),buf);
		}
		return buf.toString();
	}
	/**
	 * Returns the text in all active selections, with a newline
	 * between each text chunk.
	 */
	public String getSelectedText()
	{
		return getSelectedText(""\n"");
	}
	/**
	 * Replaces the selection with the specified text.
	 * @param s The selection
	 * @param selectedText The new text
	 * @since jEdit 3.2pre1
	 */
	public void setSelectedText(Selection s, String selectedText)
	{
		if(!isEditable())
		{
			throw new InternalError(""Text component""
				+ "" read only"");
		}
		try
		{
			buffer.beginCompoundEdit();
			if(s instanceof Selection.Rect)
			{
				Element map = buffer.getDefaultRootElement();
				int start = s.start - map.getElement(s.startLine)
					.getStartOffset();
				int end = s.end - map.getElement(s.endLine)
					.getStartOffset();
				// Certain rectangles satisfy this condition...
				if(end < start)
				{
					int tmp = end;
					end = start;
					start = tmp;
				}
				int lastNewline = 0;
				int currNewline = 0;
				for(int i = s.startLine; i <= s.endLine; i++)
				{
					Element lineElement = map.getElement(i);
					int lineStart = lineElement.getStartOffset();
					int lineEnd = lineElement.getEndOffset() - 1;
					int rectStart = Math.min(lineEnd,lineStart + start);
					buffer.remove(rectStart,Math.min(lineEnd - rectStart,
						end - start));
					if(selectedText == null)
						continue;
					currNewline = selectedText.indexOf('\n',lastNewline);
					if(currNewline == -1)
						currNewline = selectedText.length();
					buffer.insertString(rectStart,selectedText
						.substring(lastNewline,currNewline),null);
					lastNewline = Math.min(selectedText.length(),
						currNewline + 1);
				}
				if(selectedText != null &&
					currNewline != selectedText.length())
				{
					int offset = map.getElement(s.endLine)
						.getEndOffset() - 1;
					buffer.insertString(offset,""\n"",null);
					buffer.insertString(offset + 1,selectedText
						.substring(currNewline + 1),null);
				}
			}
			else
			{
				buffer.remove(s.start,s.end - s.start);
				if(selectedText != null && selectedText.length() != 0)
				{
					buffer.insertString(s.start,
						selectedText,null);
				}
			}
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
		// No matter what happends... stops us from leaving buffer
		// in a bad state
		finally
		{
			buffer.endCompoundEdit();
		}
		// no no no!!!!
		//selectNone();
	}
	/**
	 * Replaces the selection at the caret with the specified text.
	 * If there is no selection at the caret, the text is inserted at
	 * the caret position.
	 */
	public void setSelectedText(String selectedText)
	{
		if(!isEditable())
		{
			throw new InternalError(""Text component""
				+ "" read only"");
		}
		Selection[] selection = getSelection();
		if(selection.length == 0)
		{
			// for compatibility with older jEdit versions
			try
			{
				buffer.insertString(caret,selectedText,null);
			}
			catch(BadLocationException bl)
			{
				Log.log(Log.ERROR,this,bl);
			}
		}
		else
		{
			try
			{
				buffer.beginCompoundEdit();
				for(int i = 0; i < selection.length; i++)
				{
					setSelectedText(selection[i],selectedText);
				}
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
		selectNone();
	}
	/**
	 * Returns an array of all line numbers that contain a selection.
	 * This array will also include the line number containing the
	 * caret, for convinience.
	 * @since jEdit 3.2pre1
	 */
	public int[] getSelectedLines()
	{
		Integer line;
		// this algorithm sucks
		Hashtable hash = new Hashtable();
		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			for(int j = s.startLine; j <= s.endLine; j++)
			{
				line = new Integer(j);
				hash.put(line,line);
			}
		}
		line = new Integer(caretLine);
		hash.put(line,line);
		int[] returnValue = new int[hash.size()];
		int i = 0;
		Enumeration keys = hash.keys();
		while(keys.hasMoreElements())
		{
			line = (Integer)keys.nextElement();
			returnValue[i++] = line.intValue();
		}
		quicksort(returnValue,0,returnValue.length - 1);
		return returnValue;
	}
	/**
	 * Returns true if this text area is editable, false otherwise.
	 */
	public final boolean isEditable()
	{
		return buffer.isEditable();
	}
	/**
	 * Returns the right click popup menu.
	 */
	public final JPopupMenu getRightClickPopup()
	{
		return popup;
	}
	/**
	 * Sets the right click popup menu.
	 * @param popup The popup
	 */
	public final void setRightClickPopup(JPopupMenu popup)
	{
		this.popup = popup;
	}
	/**
	 * Returns the `magic' caret position. This can be used to preserve
	 * the column position when moving up and down lines.
	 */
	public final int getMagicCaretPosition()
	{
		return (magicCaret == -1
			? offsetToX(caretLine,caret - getLineStartOffset(caretLine))
			: magicCaret);
	}
	/**
	 * Sets the `magic' caret position. This can be used to preserve
	 * the column position when moving up and down lines.
	 * @param magicCaret The magic caret position
	 */
	public final void setMagicCaretPosition(int magicCaret)
	{
		this.magicCaret = magicCaret;
	}
	/**
	 * Handles the insertion of the specified character. Performs
	 * auto indent, expands abbreviations, does word wrap, etc.
	 * @param ch The character
	 * @see #setSelectedText(String)
	 * @see #isOverwriteEnabled()
	 * @since jEdit 2.7pre3
	 */
	public void userInput(char ch)
	{
		if(!isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(ch == ' ' && Abbrevs.getExpandOnInput()
			&& Abbrevs.expandAbbrev(view,false))
			return;
		else if(ch == '\t')
		{
			if(buffer.getBooleanProperty(""indentOnTab"")
				&& selection.size() == 0
				&& buffer.indentLine(caretLine,true,false))
				return;
			else if(buffer.getBooleanProperty(""noTabs""))
			{
				int lineStart = getLineStartOffset(caretLine);
				String line = getText(lineStart,caret - lineStart);
				setSelectedText(createSoftTab(line,buffer.getTabSize()));
			}
			else
				setSelectedText(""\t"");
			return;
		}
		else if(ch == '\n')
		{
			try
			{
				buffer.beginCompoundEdit();
				setSelectedText(""\n"");
				if(buffer.getBooleanProperty(""indentOnEnter""))
					buffer.indentLine(caretLine,true,false);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
			return;
		}
		else
		{
			String str = String.valueOf(ch);
			if(selection.size() != 0)
			{
				setSelectedText(str);
				return;
			}
			try
			{
				if(ch == ' ')
				{
					if(doWordWrap(caretLine,true))
						return;
				}
				else
					doWordWrap(caretLine,false);
			}
			catch(BadLocationException bl)
			{
				Log.log(Log.ERROR,this,bl);
			}
			try
			{
				buffer.beginCompoundEdit();
				// Don't overstrike if we're on the end of
				// the line
				if(overwrite)
				{
					int caretLineEnd = getLineEndOffset(caretLine);
					if(caretLineEnd - caret > 1)
						buffer.remove(caret,1);
				}
				buffer.insertString(caret,str,null);
			}
			catch(BadLocationException bl)
			{
				Log.log(Log.ERROR,this,bl);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
		// check if the user entered a bracket
		String indentOpenBrackets = (String)buffer
			.getProperty(""indentOpenBrackets"");
		String indentCloseBrackets = (String)buffer
			.getProperty(""indentCloseBrackets"");
		if((indentCloseBrackets != null
			&& indentCloseBrackets.indexOf(ch) != -1)
			|| (indentOpenBrackets != null
			&& indentOpenBrackets.indexOf(ch) != -1))
		{
			buffer.indentLine(caretLine,false,true);
		}
	}
	/**
	 * Returns true if overwrite mode is enabled, false otherwise.
	 */
	public final boolean isOverwriteEnabled()
	{
		return overwrite;
	}
	/**
	 * Sets overwrite mode.
	 */
	public final void setOverwriteEnabled(boolean overwrite)
	{
		this.overwrite = overwrite;
		invalidateLine(caretLine);
		if(view.getStatus() != null)
			view.getStatus().updateMiscStatus();
	}
	/**
	 * Toggles overwrite mode.
	 * @since jEdit 2.7pre2
	 */
	public final void toggleOverwriteEnabled()
	{
		overwrite = !overwrite;
		invalidateLine(caretLine);
		if(view.getStatus() != null)
			view.getStatus().updateMiscStatus();
	}
	/**
	 * Returns the position of the highlighted bracket (the bracket
	 * matching the one before the caret)
	 */
	public final int getBracketPosition()
	{
		return bracketPosition;
	}
	/**
	 * Returns the line of the highlighted bracket (the bracket
	 * matching the one before the caret)
	 */
	public final int getBracketLine()
	{
		return bracketLine;
	}
	/**
	 * Adds a caret change listener to this text area.
	 * @param listener The listener
	 */
	public final void addCaretListener(CaretListener listener)
	{
		listenerList.add(CaretListener.class,listener);
	}
	/**
	 * Removes a caret change listener from this text area.
	 * @param listener The listener
	 */
	public final void removeCaretListener(CaretListener listener)
	{
		listenerList.remove(CaretListener.class,listener);
	}
	/**
	 * Adds a scroll listener to this text area.
	 * @param listener The listener
	 * @since jEdit 3.2pre2
	 */
	public final void addScrollListener(ScrollListener listener)
	{
		listenerList.add(ScrollListener.class,listener);
	}
	/**
	 * Removes a scroll listener from this text area.
	 * @param listener The listener
	 * @since jEdit 3.2pre2
	 */
	public final void removeScrollListener(ScrollListener listener)
	{
		listenerList.remove(ScrollListener.class,listener);
	}
	/**
	 * Deletes the character before the caret, or the selection, if one is
	 * active.
	 * @since jEdit 2.7pre2
	 */
	public void backspace()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(selection.size() != 0)
			setSelectedText("""");
		else
		{
			if(caret == 0)
			{
				getToolkit().beep();
				return;
			}
			try
			{
				buffer.remove(caret - 1,1);
			}
			catch(BadLocationException bl)
			{
				Log.log(Log.ERROR,this,bl);
			}
		}
	}
	/**
	 * Deletes the word before the caret.
	 * @since jEdit 2.7pre2
	 */
	public void backspaceWord()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(selection.size() != 0)
		{
			setSelectedText("""");
			return;
		}
		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;
		String lineText = getLineText(caretLine);
		if(_caret == 0)
		{
			if(lineStart == 0)
			{
				getToolkit().beep();
				return;
			}
			_caret--;
		}
		else
		{
			String noWordSep = (String)buffer.getProperty(""noWordSep"");
			_caret = TextUtilities.findWordStart(lineText,_caret-1,noWordSep);
		}
		try
		{
			buffer.remove(_caret + lineStart,
				caret - (_caret + lineStart));
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
	}
	/**
	 * Deletes the character after the caret.
	 * @since jEdit 2.7pre2
	 */
	public void delete()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(selection.size() != 0)
			setSelectedText(null);
		else
		{
			if(caret == buffer.getLength())
			{
				getToolkit().beep();
				return;
			}
			try
			{
				buffer.remove(caret,1);
			}
			catch(BadLocationException bl)
			{
				Log.log(Log.ERROR,this,bl);
			}
		}
	}
	/**
	 * Deletes from the caret to the end of the current line.
	 * @since jEdit 2.7pre2
	 */
	public void deleteToEndOfLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		try
		{
			buffer.remove(caret,getLineEndOffset(caretLine)
				- caret - 1);
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
	}
	/**
	 * Deletes the line containing the caret.
	 * @since jEdit 2.7pre2
	 */
	public void deleteLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		Element map = buffer.getDefaultRootElement();
		Element lineElement = map.getElement(caretLine);
		try
		{
			int start = lineElement.getStartOffset();
			int end = lineElement.getEndOffset();
			if(end > buffer.getLength())
			{
				if(start != 0)
					start--;
				end--;
			}
			buffer.remove(start,end - start);
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
	}
	/**
	 * Deletes the paragraph containing the caret.
	 * @since jEdit 2.7pre2
	 */
	public void deleteParagraph()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		int start = 0, end = buffer.getLength();
loop:		for(int i = caretLine - 1; i >= 0; i--)
		{
			//if(!buffer.isLineVisible(i))
			//	continue loop;
			getLineText(i,lineSegment);
			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					continue loop;
				}
			}
			start = getLineStartOffset(i);
			break loop;
		}
loop:		for(int i = caretLine + 1; i < getLineCount(); i++)
		{
			//if(!buffer.isLineVisible(i))
			//	continue loop;
			getLineText(i,lineSegment);
			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					continue loop;
				}
			}
			end = getLineEndOffset(i) - 1;
			break loop;
		}
		try
		{
			buffer.remove(start,end - start);
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
	}
	/**
	 * Deletes from the caret to the beginning of the current line.
	 * @since jEdit 2.7pre2
	 */
	public void deleteToStartOfLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		Element map = buffer.getDefaultRootElement();
		Element lineElement = map.getElement(caretLine);
		try
		{
			buffer.remove(lineElement.getStartOffset(),
				caret - lineElement.getStartOffset());
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
	}
	/**
	 * Deletes the word in front of the caret.
	 * @since jEdit 2.7pre2
	 */
	public void deleteWord()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		if(selection.size() != 0)
		{
			setSelectedText("""");
			return;
		}
		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;
		String lineText = getLineText(caretLine);
		if(_caret == lineText.length())
		{
			if(lineStart + _caret == buffer.getLength())
			{
				getToolkit().beep();
				return;
			}
			_caret++;
		}
		else
		{
			String noWordSep = (String)buffer.getProperty(""noWordSep"");
			_caret = TextUtilities.findWordEnd(lineText,
				_caret+1,noWordSep);
		}
		try
		{
			buffer.remove(caret,(_caret + lineStart) - caret);
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
	}
	/**
	 * Moves the caret to the next closing bracket.
	 * @since jEdit 2.7pre2.
	 */
	public void goToNextBracket(boolean select)
	{
		String text = getText(caret,buffer.getLength() - caret - 1);
		int newCaret = -1;
loop:		for(int i = 0; i < text.length(); i++)
		{
			switch(text.charAt(i))
			{
			case ')': case ']': case '}':
				newCaret = caret + i + 1;
				break loop;
			}
		}
		if(newCaret == -1)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,newCaret);
			else if(!multi)
				selectNone();
			moveCaretPosition(newCaret);
		}
	}
	/**
	 * Moves the caret to the next character.
	 * @since jEdit 2.7pre2.
	 */
	public void goToNextCharacter(boolean select)
	{
		if(!select && selection.size() != 0)
		{
			Selection s = getSelectionAtOffset(caret);
			if(s != null)
			{
				if(multi)
				{
					if(caret != s.end)
					{
						moveCaretPosition(s.end);
						return;
					}
				}
				else
				{
					setCaretPosition(s.end);
					return;
				}
			}
		}
		if(caret == buffer.getLength())
			getToolkit().beep();
		int newCaret;
		if(caret == getLineEndOffset(caretLine) - 1)
		{
			int line = buffer.getNextVisibleLine(caretLine);
			if(line == -1)
			{
				getToolkit().beep();
				return;
			}
			newCaret = getLineStartOffset(line);
		}
		else
			newCaret = caret + 1;
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	}
	/**
	 * Movse the caret to the next line.
	 * @since jEdit 2.7pre2
	 */
	public void goToNextLine(boolean select)
	{
		int caret = getCaretPosition();
		int line = getCaretLine();
		int magic = getMagicCaretPosition();
		int nextLine = buffer.getNextVisibleLine(line);
		if(nextLine == -1)
		{
			getToolkit().beep();
			return;
		}
		int newCaret = getLineStartOffset(nextLine)
			+ xToOffset(nextLine,magic + 1);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	}
	/**
	 * Moves the caret to the next marker.
	 * @since jEdit 2.7pre2
	 */
	public void goToNextMarker(boolean select)
	{
		Vector markers = buffer.getMarkers();
		Marker marker = null;
		for(int i = 0; i < markers.size(); i++)
		{
			Marker _marker = (Marker)markers.elementAt(i);
			if(_marker.getPosition() > caret)
			{
				marker = _marker;
				break;
			}
		}
		if(marker == null)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,marker.getPosition());
			else if(!multi)
				selectNone();
			moveCaretPosition(marker.getPosition());
		}
	}
	/**
	 * Moves the caret to the next screenful.
	 * @since jEdit 2.7pre2.
	 */
	public void goToNextPage(boolean select)
	{
		int lineCount = buffer.getVirtualLineCount();
		int magic = getMagicCaretPosition();
		if(firstLine + visibleLines * 2 >= lineCount - 1)
			setFirstLine(lineCount - visibleLines);
		else
			setFirstLine(firstLine + visibleLines);
		int newLine = buffer.virtualToPhysical(Math.min(lineCount - 1,
			buffer.physicalToVirtual(caretLine) + visibleLines));
		int newCaret = getLineStartOffset(newLine)
			+ xToOffset(newLine,magic + 1);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	}
	/**
	 * Moves the caret to the start of the next paragraph.
	 * @since jEdit 2.7pre2
	 */
	public void goToNextParagraph(boolean select)
	{
		int lineNo = getCaretLine();
		int newCaret = getBufferLength();
		boolean foundBlank = false;
loop:		for(int i = lineNo + 1; i < getLineCount(); i++)
		{
			if(!buffer.isLineVisible(i))
				continue;
			getLineText(i,lineSegment);
			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					if(foundBlank)
					{
						newCaret = getLineStartOffset(i);
						break loop;
					}
					else
						continue loop;
				}
			}
			foundBlank = true;
		}
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	}
	/**
	 * Moves the caret to the start of the next word.
	 * @since jEdit 2.7pre2
	 */
	public void goToNextWord(boolean select)
	{
		int lineStart = getLineStartOffset(caretLine);
		int newCaret = caret - lineStart;
		String lineText = getLineText(caretLine);
		if(newCaret == lineText.length())
		{
			int nextLine = buffer.getNextVisibleLine(caretLine);
			if(nextLine == -1)
			{
				getToolkit().beep();
				return;
			}
			newCaret = getLineStartOffset(nextLine);
		}
		else
		{
			String noWordSep = (String)buffer.getProperty(""noWordSep"");
			newCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,noWordSep)
				+ lineStart;
		}
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	}
	/**
	 * Moves the caret to the previous bracket.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevBracket(boolean select)
	{
		String text = getText(0,caret);
		int newCaret = -1;
loop:		for(int i = getCaretPosition() - 1; i >= 0; i--)
		{
			switch(text.charAt(i))
			{
			case '(': case '[': case '{':
				newCaret = i;
				break loop;
			}
		}
		if(newCaret == -1)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,newCaret);
			else if(!multi)
				selectNone();
			moveCaretPosition(newCaret);
		}
	}
	/**
	 * Moves the caret to the previous character.
	 * @since jEdit 2.7pre2.
	 */
	public void goToPrevCharacter(boolean select)
	{
		if(!select && selection.size() != 0)
		{
			Selection s = getSelectionAtOffset(caret);
			if(s != null)
			{
				if(multi)
				{
					if(caret != s.start)
					{
						moveCaretPosition(s.start);
						return;
					}
				}
				else
				{
					setCaretPosition(s.start);
					return;
				}
			}
		}
		int newCaret;
		if(caret == getLineStartOffset(caretLine))
		{
			int line = buffer.getPrevVisibleLine(caretLine);
			if(line == -1)
			{
				getToolkit().beep();
				return;
			}
			newCaret = getLineEndOffset(line) - 1;
		}
		else
			newCaret = caret - 1;
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	}
	/**
	 * Moves the caret to the previous line.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevLine(boolean select)
	{
		int magic = getMagicCaretPosition();
		int prevLine = buffer.getPrevVisibleLine(caretLine);
		if(prevLine == -1)
		{
			getToolkit().beep();
			return;
		}
		int newCaret = getLineStartOffset(prevLine) + xToOffset(prevLine,magic + 1);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	}
	/**
	 * Moves the caret to the previous marker.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevMarker(boolean select)
	{
		Vector markers = buffer.getMarkers();
		Marker marker = null;
		for(int i = markers.size() - 1; i >= 0; i--)
		{
			Marker _marker = (Marker)markers.elementAt(i);
			if(_marker.getPosition() < caret)
			{
				marker = _marker;
				break;
			}
		}
		if(marker == null)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,marker.getPosition());
			else if(!multi)
				selectNone();
			moveCaretPosition(marker.getPosition());
		}
	}
	/**
	 * Moves the caret to the previous screenful.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevPage(boolean select)
	{
		if(firstLine < visibleLines)
			setFirstLine(0);
		else
			setFirstLine(firstLine - visibleLines);
		int magic = getMagicCaretPosition();
		int newLine = buffer.virtualToPhysical(Math.max(0,
			buffer.physicalToVirtual(caretLine) - visibleLines));
		int newCaret = getLineStartOffset(newLine)
			+ xToOffset(newLine,magic + 1);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	}
	/**
	 * Moves the caret to the start of the previous paragraph.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevParagraph(boolean select)
	{
		int lineNo = caretLine;
		int newCaret = 0;
		boolean foundBlank = false;
loop:		for(int i = lineNo - 1; i >= 0; i--)
		{
			if(!buffer.isLineVisible(i))
				continue;
			getLineText(i,lineSegment);
			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					if(foundBlank)
					{
						newCaret = getLineEndOffset(i) - 1;
						break loop;
					}
					else
						continue loop;
				}
			}
			foundBlank = true;
		}
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	}
	/**
	 * Moves the caret to the start of the previous word.
	 * @since jEdit 2.7pre2
	 */
	public void goToPrevWord(boolean select)
	{
		int lineStart = getLineStartOffset(caretLine);
		int newCaret = caret - lineStart;
		String lineText = getLineText(caretLine);
		if(newCaret == 0)
		{
			if(lineStart == 0)
			{
				view.getToolkit().beep();
				return;
			}
			else
			{
				int prevLine = buffer.getPrevVisibleLine(caretLine);
				if(prevLine == -1)
				{
					getToolkit().beep();
					return;
				}
				newCaret = getLineEndOffset(prevLine) - 1;
			}
		}
		else
		{
			String noWordSep = (String)buffer.getProperty(""noWordSep"");
			newCaret = TextUtilities.findWordStart(lineText,newCaret - 1,noWordSep)
				+ lineStart;
		}
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	}
	/**
	 * On subsequent invocations, first moves the caret to the first
	 * non-whitespace character of the line, then the beginning of the
	 * line, then to the first visible line.
	 * @since jEdit 2.7pre2
	 */
	public void smartHome(boolean select)
	{
		if(!jEdit.getBooleanProperty(""view.homeEnd""))
			goToStartOfLine(select);
		else
		{
			switch(view.getInputHandler().getLastActionCount())
			{
			case 1:
				goToStartOfWhiteSpace(select);
				break;
			case 2:
				goToStartOfLine(select);
				break;
			default: //case 3:
				goToFirstVisibleLine(select);
				break;
			}
		}
	}
	/**
	 * On subsequent invocations, first moves the caret to the last
	 * non-whitespace character of the line, then the end of the
	 * line, then to the last visible line.
	 * @since jEdit 2.7pre2
	 */
	public void smartEnd(boolean select)
	{
		if(!jEdit.getBooleanProperty(""view.homeEnd""))
			goToEndOfLine(select);
		else
		{
			switch(view.getInputHandler().getLastActionCount())
			{
			case 1:
				goToEndOfWhiteSpace(select);
				break;
			case 2:
				goToEndOfLine(select);
				break;
			default: //case 3:
				goToLastVisibleLine(select);
				break;
			}
		}
	}
	/**
	 * Moves the caret to the beginning of the current line.
	 * @since jEdit 2.7pre2
	 */
	public void goToStartOfLine(boolean select)
	{
		// do this here, for weird reasons
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToStartOfLine("" + select + "");"");
		int newCaret = getLineStartOffset(getCaretLine());
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	}
	/**
	 * Moves the caret to the end of the current line.
	 * @since jEdit 2.7pre2
	 */
	public void goToEndOfLine(boolean select)
	{
		// do this here, for weird reasons
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToEndOfLine("" + select + "");"");
		int newCaret = getLineEndOffset(getCaretLine()) - 1;
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
		// so that end followed by up arrow will always put caret at
		// the end of the previous line, for example
		setMagicCaretPosition(Integer.MAX_VALUE);
	}
	/**
	 * Moves the caret to the first non-whitespace character of the current
	 * line.
	 * @since jEdit 2.7pre2
	 */
	public void goToStartOfWhiteSpace(boolean select)
	{
		// do this here, for weird reasons
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToStartOfWhiteSpace("" + select + "");"");
		int firstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(caretLine));
		int firstOfLine = getLineStartOffset(caretLine);
		firstIndent = firstOfLine + firstIndent;
		if(firstIndent == getLineEndOffset(caretLine) - 1)
			firstIndent = firstOfLine;
		if(select)
			extendSelection(caret,firstIndent);
		else if(!multi)
			selectNone();
		moveCaretPosition(firstIndent);
	}
	/**
	 * Moves the caret to the last non-whitespace character of the current
	 * line.
	 * @since jEdit 2.7pre2
	 */
	public void goToEndOfWhiteSpace(boolean select)
	{
		// do this here, for weird reasons
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToEndOfWhiteSpace("" + select + "");"");
		int lastIndent = MiscUtilities.getTrailingWhiteSpace(getLineText(caretLine));
		int lastOfLine = getLineEndOffset(caretLine) - 1;
		lastIndent = lastOfLine - lastIndent;
		if(lastIndent == getLineStartOffset(caretLine))
			lastIndent = lastOfLine;
		if(select)
			extendSelection(caret,lastIndent);
		else if(!multi)
			selectNone();
		moveCaretPosition(lastIndent);
	}
	/**
	 * Moves the caret to the first visible line.
	 * @since jEdit 2.7pre2
	 */
	public void goToFirstVisibleLine(boolean select)
	{
		// do this here, for weird reasons
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToFirstVisibleLine("" + select + "");"");
		int firstVisibleLine = (firstLine <= electricScroll) ? 0 :
			firstLine + electricScroll;
		if(firstVisibleLine >= getVirtualLineCount())
			firstVisibleLine = getVirtualLineCount() - 1;
		firstVisibleLine = buffer.virtualToPhysical(firstVisibleLine);
		int firstVisible = getLineEndOffset(firstVisibleLine) - 1;
		if(select)
			extendSelection(caret,firstVisible);
		else if(!multi)
			selectNone();
		moveCaretPosition(firstVisible);
	}
	/**
	 * Moves the caret to the last visible line.
	 * @since jEdit 2.7pre2
	 */
	public void goToLastVisibleLine(boolean select)
	{
		// do this here, for weird reasons
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToLastVisibleLine("" + select + "");"");
		int lastVisibleLine = firstLine + visibleLines;
		if(lastVisibleLine >= getVirtualLineCount())
			lastVisibleLine = getVirtualLineCount() - 1;
		else if(lastVisibleLine <= electricScroll)
			lastVisibleLine = 0;
		else
			lastVisibleLine -= (electricScroll + 1);
		lastVisibleLine = buffer.virtualToPhysical(lastVisibleLine);
		int lastVisible = getLineEndOffset(lastVisibleLine) - 1;
		if(select)
			extendSelection(caret,lastVisible);
		else if(!multi)
			selectNone();
		moveCaretPosition(lastVisible);
	}
	/**
	 * Moves the caret to the marker with the specified shortcut.
	 * @param shortcut The shortcut
	 * @param select True if the selection should be extended,
	 * false otherwise
	 * @since jEdit 3.2pre2
	 */
	public void goToMarker(char shortcut, boolean select)
	{
		Marker marker = buffer.getMarker(shortcut);
		if(marker == null)
		{
			getToolkit().beep();
			return;
		}
		int pos = marker.getPosition();
		if(select)
			extendSelection(caret,pos);
		else if(!multi)
			selectNone();
		moveCaretPosition(pos);
	}
	/**
	 * Adds a marker at the caret position.
	 * @since jEdit 3.2pre1
	 */
	public void addMarker()
	{
		// always add markers on selected lines
		Selection[] selection = getSelection();
		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			if(s.startLine != s.endLine)
			{
				if(s.startLine != caretLine)
					buffer.addMarker('\0',s.start);
			}
			if(s.endLine != caretLine)
				buffer.addMarker('\0',s.end);
		}
		// toggle marker on caret line
		buffer.addOrRemoveMarker('\0',caret);
	}
	/**
	 * Moves the caret to the marker with the specified shortcut,
	 * then sets the marker position to the former caret position.
	 * @param shortcut The shortcut
	 * @since jEdit 3.2pre2
	 */
	public void swapMarkerAndCaret(char shortcut)
	{
		Marker marker = buffer.getMarker(shortcut);
		if(marker == null)
		{
			getToolkit().beep();
			return;
		}
		int caret = getCaretPosition();
		setCaretPosition(marker.getPosition());
		buffer.addMarker(shortcut,caret);
	}
	/**
	 * Prepends each line of the selection with the line comment string.
	 * @since jEdit 3.2pre1
	 */
	public void lineComment()
	{
		String comment = (String)buffer.getProperty(""lineComment"");
		if(!buffer.isEditable() || comment == null || comment.length() == 0)
		{
			getToolkit().beep();
			return;
		}
		comment = comment + ' ';
		buffer.beginCompoundEdit();
		int[] lines = getSelectedLines();
		try
		{
			for(int i = 0; i < lines.length; i++)
			{
				buffer.insertString(getLineStartOffset(lines[i]),
					comment,null);
			}
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
		selectNone();
	}
	/**
	 * Adds comment start and end strings to the beginning and end of the
	 * selection.
	 * @since jEdit 3.2pre1
	 */
	public void rangeComment()
	{
		String commentStart = (String)buffer.getProperty(""commentStart"");
		String commentEnd = (String)buffer.getProperty(""commentEnd"");
		if(!buffer.isEditable() || commentStart == null || commentEnd == null
			|| commentStart.length() == 0 || commentEnd.length() == 0)
		{
			getToolkit().beep();
			return;
		}
		commentStart = commentStart + ' ';
		commentEnd = ' ' + commentEnd;
		try
		{
			buffer.beginCompoundEdit();
			Selection[] selection = getSelection();
			if(selection.length == 0)
			{
				int oldCaret = caret;
				buffer.insertString(caret,
					commentStart,null);
				buffer.insertString(caret,
					commentEnd,null);
				setCaretPosition(oldCaret + commentStart.length());
			}
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				if(s instanceof Selection.Range)
				{
					buffer.insertString(s.start,
						commentStart,null);
					buffer.insertString(s.end,
						commentEnd,null);
				}
				else if(s instanceof Selection.Rect)
				{
					for(int j = s.startLine; j <= s.endLine; j++)
					{
						buffer.insertString(s.getStart(buffer,j),
							commentStart,null);
						int end = s.getEnd(buffer,j)
							+ (j == s.endLine
							? 0
							: commentStart.length());
						buffer.insertString(end,commentEnd,null);
					}
				}
			}
			selectNone();
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	}
	/**
	 * Formats the paragraph containing the caret.
	 * @since jEdit 2.7pre2
	 */
	public void formatParagraph()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		int maxLineLength = ((Integer)buffer.getProperty(""maxLineLen""))
			.intValue();
		if(maxLineLength <= 0)
		{
			getToolkit().beep();
			return;
		}
		Selection[] selection = getSelection();
		if(selection.length != 0)
		{
			buffer.beginCompoundEdit();
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.format(
					getSelectedText(s),maxLineLength));
			}
			buffer.endCompoundEdit();
		}
		else
		{
			int lineNo = getCaretLine();
			int start = 0, end = buffer.getLength();
loop:			for(int i = lineNo - 1; i >= 0; i--)
			{
				getLineText(i,lineSegment);
				for(int j = 0; j < lineSegment.count; j++)
				{
					switch(lineSegment.array[lineSegment.offset + j])
					{
					case ' ':
					case '\t':
						break;
					default:
						continue loop;
					}
				}
				start = getLineStartOffset(i);
				break loop;
			}
loop:			for(int i = lineNo + 1; i < getLineCount(); i++)
			{
				getLineText(i,lineSegment);
				for(int j = 0; j < lineSegment.count; j++)
				{
					switch(lineSegment.array[lineSegment.offset + j])
					{
					case ' ':
					case '\t':
						break;
					default:
						continue loop;
					}
				}
				end = getLineEndOffset(i) - 1;
				break loop;
			}
			try
			{
				buffer.beginCompoundEdit();
				String text = buffer.getText(start,end - start);
				buffer.remove(start,end - start);
				buffer.insertString(start,TextUtilities.format(
					text,maxLineLength),null);
			}
			catch(BadLocationException bl)
			{
				return;
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	}
	/**
	 * Converts spaces to tabs in the selection.
	 * @since jEdit 2.7pre2
	 */
	public void spacesToTabs()
	{
		Selection[] selection = getSelection();
		if(!buffer.isEditable() || selection.length == 0)
                {
                	getToolkit().beep();
                	return;
                }
		buffer.beginCompoundEdit();
		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,TextUtilities.spacesToTabs(
				getSelectedText(s),buffer.getTabSize()));
		}
		buffer.endCompoundEdit();
	}
	/**
	 * Converts tabs to spaces in the selection.
	 * @since jEdit 2.7pre2
	 */
	public void tabsToSpaces()
	{
		Selection[] selection = getSelection();
		if(!buffer.isEditable() || selection.length == 0)
                {
                	getToolkit().beep();
                	return;
                }
		buffer.beginCompoundEdit();
		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,TextUtilities.tabsToSpaces(
				getSelectedText(s),buffer.getTabSize()));
		}
		buffer.endCompoundEdit();
	}
	/**
	 * Converts the selected text to upper case.
	 * @since jEdit 2.7pre2
	 */
	public void toUpperCase()
	{
		Selection[] selection = getSelection();
		if(!buffer.isEditable() || selection.length == 0)
                {
                	getToolkit().beep();
                	return;
                }
		buffer.beginCompoundEdit();
		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toUpperCase());
		}
		buffer.endCompoundEdit();
	}
	/**
	 * Converts the selected text to lower case.
	 * @since jEdit 2.7pre2
	 */
	public void toLowerCase()
	{
		Selection[] selection = getSelection();
		if(!buffer.isEditable() || selection.length == 0)
                {
                	getToolkit().beep();
                	return;
                }
		buffer.beginCompoundEdit();
		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toLowerCase());
		}
		buffer.endCompoundEdit();
	}
	/**
	 * Removes trailing whitespace from all lines in the selection.
	 * @since jEdit 2.7pre2
	 */
	public void removeTrailingWhiteSpace()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.removeTrailingWhiteSpace(getSelectedLines());
		}
	}
	/**
	 * Indents all selected lines.
	 * @since jEdit 3.1pre3
	 */
	public void indentSelectedLines()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.indentLines(getSelectedLines());
			selectNone();
		}
	}
	/**
	 * Shifts the indent to the left.
	 * @since jEdit 2.7pre2
	 */
	public void shiftIndentLeft()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.shiftIndentLeft(getSelectedLines());
		}
	}
	/**
	 * Shifts the indent to the right.
	 * @since jEdit 2.7pre2
	 */
	public void shiftIndentRight()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.shiftIndentRight(getSelectedLines());
		}
	}
	/**
	 * Joins the current and the next line.
	 * @since jEdit 2.7pre2
	 */
	public void joinLines()
	{
		Element map = buffer.getDefaultRootElement();
		Element lineElement = map.getElement(caretLine);
		int start = lineElement.getStartOffset();
		int end = lineElement.getEndOffset();
		if(end > buffer.getLength())
		{
			getToolkit().beep();
			return;
		}
		Element nextLineElement = map.getElement(caretLine + 1);
		int nextStart = nextLineElement.getStartOffset();
		int nextEnd = nextLineElement.getEndOffset();
		try
		{
			buffer.remove(end - 1,MiscUtilities.getLeadingWhiteSpace(
				buffer.getText(nextStart,nextEnd - nextStart)) + 1);
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
	}
	/**
	 * Moves the caret to the bracket matching the one before the caret.
	 * @since jEdit 2.7pre3
	 */
	public void goToMatchingBracket()
	{
		int dot = caret - getLineStartOffset(caretLine);
		try
		{
			int bracket = TextUtilities.findMatchingBracket(
				buffer,caretLine,Math.max(0,dot - 1));
			if(bracket != -1)
			{
				setCaretPosition(bracket + 1);
				return;
			}
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
		getToolkit().beep();
	}
	// Eliminates lots of switch() statements
	private final String openBrackets = ""([{"";
	private final String closeBrackets = "")]}"";
	/**
	 * Selects the code block surrounding the caret.
	 * @since jEdit 2.7pre2
	 */
	public void selectBlock()
	{
		Selection s = getSelectionAtOffset(caret);
		int start, end;
		if(s == null)
			start = end = caret;
		else
		{
			start = s.start;
			end = s.end;
		}
		String text = getText(0,buffer.getLength());
		// Scan backwards, trying to find a bracket
		int count = 1;
		char openBracket = '\0';
		char closeBracket = '\0';
		// We can't do the backward scan if start == 0
		if(start == 0)
		{
			view.getToolkit().beep();
			return;
		}
backward_scan:	while(--start > 0)
		{
			char c = text.charAt(start);
			int index = openBrackets.indexOf(c);
			if(index != -1)
			{
				if(--count == 0)
				{
					openBracket = c;
					closeBracket = closeBrackets.charAt(index);
					break backward_scan;
				}
			}
			else if(closeBrackets.indexOf(c) != -1)
				count++;
		}
		// Reset count
		count = 1;
		// Scan forward, matching that bracket
		if(openBracket == '\0')
		{
			getToolkit().beep();
			return;
		}
		else
		{
forward_scan:		do
			{
				char c = text.charAt(end);
				if(c == closeBracket)
				{
					if(--count == 0)
					{
						end++;
						break forward_scan;
					}
				}
				else if(c == openBracket)
					count++;
			}
			while(++end < buffer.getLength());
		}
		setSelection(new Selection.Range(start,end));
		moveCaretPosition(end);
	}
	/**
	 * Displays the 'go to line' dialog box, and moves the caret to the
	 * specified line number.
	 * @since jEdit 2.7pre2
	 */
	public void showGoToLineDialog()
	{
		String line = GUIUtilities.input(view,""goto-line"",null);
		if(line == null)
			return;
		try
		{
			int lineNumber = Integer.parseInt(line) - 1;
			setCaretPosition(getLineStartOffset(lineNumber));
		}
		catch(Exception e)
		{
			getToolkit().beep();
		}
	}
	/**
	 * Displays the 'select line range' dialog box, and selects the
	 * specified range of lines.
	 * @since jEdit 2.7pre2
	 */
	public void showSelectLineRangeDialog()
	{
		new SelectLineRange(view);
	}
	/**
	 * Displays the 'word count' dialog box.
	 * @since jEdit 2.7pre2
	 */
	public void showWordCountDialog()
	{
		String selection = getSelectedText();
		if(selection != null)
		{
			doWordCount(view,selection);
			return;
		}
		try
		{
			doWordCount(view,buffer.getText(0,buffer.getLength()));
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
	}
	/**
	 * Attempts to complete the word at the caret position, by searching
	 * the buffer for words that start with the currently entered text. If
	 * only one completion is found, it is inserted immediately, otherwise
	 * a popup is shown will all possible completions.
	 * @since jEdit 2.7pre2
	 */
	public void completeWord()
	{
		String noWordSep = (String)buffer.getProperty(""noWordSep"");
		if(noWordSep == null)
			noWordSep = """";
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}
		// first, we get the word before the caret
		String line = getLineText(caretLine);
		int dot = caret - getLineStartOffset(caretLine);
		if(dot == 0)
		{
			getToolkit().beep();
			return;
		}
		char ch = line.charAt(dot-1);
		if(!Character.isLetterOrDigit(ch)
			&& noWordSep.indexOf(ch) == -1)
		{
			// attempting to expand non-word char
			getToolkit().beep();
			return;
		}
		int wordStart = TextUtilities.findWordStart(line,dot-1,noWordSep);
		String word = line.substring(wordStart,dot);
		if(word.length() == 0)
		{
			getToolkit().beep();
			return;
		}
		Vector completions = new Vector();
		int wordLen = word.length();
		// now loop through all lines of current buffer
		for(int i = 0; i < getLineCount(); i++)
		{
			line = getLineText(i);
			// check for match at start of line
			if(line.startsWith(word))
			{
				if(i == caretLine && wordStart == 0)
					continue;
				String _word = completeWord(line,0,noWordSep);
				if(_word.length() != wordLen)
				{
					// remove duplicates
					if(completions.indexOf(_word) == -1)
						completions.addElement(_word);
				}
			}
			// check for match inside line
			int len = line.length() - word.length();
			for(int j = 0; j < len; j++)
			{
				char c = line.charAt(j);
				if(!Character.isLetterOrDigit(c) && noWordSep.indexOf(c) == -1)
				{
					if(i == caretLine && wordStart == (j + 1))
						continue;
					if(line.regionMatches(j + 1,word,0,wordLen))
					{
						String _word = completeWord(line,j + 1,noWordSep);
						if(_word.length() != wordLen)
						{
							// remove duplicates
							if(completions.indexOf(_word) == -1)
								completions.addElement(_word);
						}
					}
				}
			}
		}
		// sort completion list
		MiscUtilities.quicksort(completions,new MiscUtilities.StringICaseCompare());
		if(completions.size() == 0)
			getToolkit().beep();
		// if there is only one competion, insert in buffer
		else if(completions.size() == 1)
		{
			// chop off 'wordLen' because that's what's already
			// in the buffer
			setSelectedText(((String)completions
				.elementAt(0)).substring(wordLen));
		}
		// show dialog box if > 1
		else
		{
			Point location = new Point(offsetToX(caretLine,wordStart),
				painter.getFontMetrics().getHeight()
				* (buffer.physicalToVirtual(caretLine)
				- firstLine + 1));
			SwingUtilities.convertPointToScreen(location,painter);
			new CompleteWord(view,word,completions,location);
		}
	}
	/**
	 * Selects the fold that contains the caret line number.
	 * @since jEdit 3.1pre3
	 */
	public void selectFold()
	{
		selectFoldAt(caretLine);
	}
	/**
	 * Selects the fold that contains the specified line number.
	 * @param line The line number
	 * @since jEdit 3.1pre3
	 */
	public void selectFoldAt(int line)
	{
		int start;
		int end;
		if(buffer.isFoldStart(line))
		{
			start = line;
			int foldLevel = buffer.getFoldLevel(line);
			line++;
			while(line < buffer.getLineCount()
				&& buffer.getFoldLevel(line) > foldLevel)
				line++;
			end = line;
		}
		else
		{
			start = line;
			int foldLevel = buffer.getFoldLevel(line);
			while(start >= 0 && buffer.getFoldLevel(start) >= foldLevel)
				start--;
			end = line;
			while(end < buffer.getLineCount()
				&& buffer.getFoldLevel(end) >= foldLevel)
				end++;
		}
		int newCaret = getLineEndOffset(end) - 1;
		extendSelection(getLineStartOffset(start),newCaret);
		moveCaretPosition(newCaret);
	}
	/**
	 * Called by the AWT when this component is added to a parent.
	 * Adds document listener.
	 */
	public void addNotify()
	{
		super.addNotify();
		ToolTipManager.sharedInstance().registerComponent(painter);
		ToolTipManager.sharedInstance().registerComponent(gutter);
		if(!documentHandlerInstalled)
		{
			documentHandlerInstalled = true;
			buffer.addDocumentListener(documentHandler);
			buffer.addFoldListener(foldHandler);
		}
		recalculateVisibleLines();
	}
	/**
	 * Called by the AWT when this component is removed from it's parent.
	 * This clears the pointer to the currently focused component.
	 * Also removes document listener.
	 */
	public void removeNotify()
	{
		super.removeNotify();
		ToolTipManager.sharedInstance().unregisterComponent(painter);
		ToolTipManager.sharedInstance().unregisterComponent(gutter);
		if(focusedComponent == this)
			focusedComponent = null;
		if(documentHandlerInstalled)
		{
			buffer.removeDocumentListener(documentHandler);
			buffer.removeFoldListener(foldHandler);
			documentHandlerInstalled = false;
		}
	}
	/**
	 * Bug workarounds.
	 * @since jEdit 2.7pre1
	 */
	public boolean hasFocus()
	{
		Component c = this;
		while(!(c instanceof Window))
		{
			if(c == null)
				return false;
			c = c.getParent();
		}
		Component focusOwner = ((Window)c).getFocusOwner();
		boolean hasFocus = (focusOwner == this);
		if(hasFocus && focusedComponent != this)
			focusedComponent = this;
		return hasFocus;
	}
	/**
	 * Bug workarounds.
	 * @since jEdit 2.7pre1
	 */
	public void grabFocus()
	{
		super.grabFocus();
		// ensure that focusedComponent is set correctly
		hasFocus();
	}
	/**
	 * Java 1.4 compatibility fix to make Tab key work.
	 * @since jEdit 3.2pre4
	 */
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	}
	/**
	 * Returns if multiple selection is enabled.
	 * @since jEdit 3.2pre1
	 */
	public final boolean isMultipleSelectionEnabled()
	{
		return multi;
	}
	/**
	 * Toggles multiple selection.
	 * @since jEdit 3.2pre1
	 */
	public final void toggleMultipleSelectionEnabled()
	{
		multi = !multi;
		if(view.getStatus() != null)
			view.getStatus().updateMiscStatus();
	}
	/**
	 * Sets multiple selection.
	 * @param multi Should multiple selection be enabled?
	 * @since jEdit 3.2pre1
	 */
	public final void setMultipleSelectionEnabled(boolean multi)
	{
		JEditTextArea.multi = multi;
		if(view.getStatus() != null)
			view.getStatus().updateMiscStatus();
	}
	// protected members
	public void processKeyEvent(KeyEvent evt)
	{
		evt = KeyEventWorkaround.processKeyEvent(evt);
		if(evt == null)
			return;
		// Ignore
		if(view.isClosed())
			return;
		InputHandler inputHandler = view.getInputHandler();
		KeyListener keyEventInterceptor = view.getKeyEventInterceptor();
		switch(evt.getID())
		{
		case KeyEvent.KEY_TYPED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyTyped(evt);
			else
				inputHandler.keyTyped(evt);
			break;
		case KeyEvent.KEY_PRESSED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyPressed(evt);
			else
				inputHandler.keyPressed(evt);
			break;
		case KeyEvent.KEY_RELEASED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyReleased(evt);
			else
				inputHandler.keyReleased(evt);
			break;
		}
		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	}
	// package-private members
	Segment lineSegment;
	MouseHandler mouseHandler;
	int maxHorizontalScrollWidth;
	// this is package-private so that the painter can use it without
	// having to call getSelection() (which involves an array copy)
	Vector selection;
	/**
	 * Returns true if the caret is visible, false otherwise.
	 */
	final boolean isCaretVisible()
	{
		return blink && hasFocus();
	}
	/**
	 * Returns true if the line and bracket is visible, false otherwise.
	 */
	final boolean isHighlightVisible()
	{
		return hasFocus();
	}
	/**
	 * Recalculates the number of visible lines. This should not
	 * be called directly.
	 */
	void recalculateVisibleLines()
	{
		if(painter == null)
			return;
		int height = painter.getHeight();
		int lineHeight = painter.getFontMetrics().getHeight();
		visibleLines = height / lineHeight;
		updateScrollBars();
	}
	void updateMaxHorizontalScrollWidth()
	{
		int _maxHorizontalScrollWidth = buffer.getMaxLineWidth(
			physFirstLine,visibleLines);
		if(_maxHorizontalScrollWidth != maxHorizontalScrollWidth)
		{
			maxHorizontalScrollWidth = _maxHorizontalScrollWidth;
			horizontal.setValues(-horizontalOffset,painter.getWidth(),
				0,maxHorizontalScrollWidth
				+ painter.getFontMetrics().charWidth('w'));
		}
	}
	// private members
	private static String CENTER = ""center"";
	private static String RIGHT = ""right"";
	private static String LEFT = ""left"";
	private static String BOTTOM = ""bottom"";
	private static Timer caretTimer;
	private static JEditTextArea focusedComponent;
	private View view;
	private Gutter gutter;
	private TextAreaPainter painter;
	private JPopupMenu popup;
	private EventListenerList listenerList;
	private MutableCaretEvent caretEvent;
	private boolean caretBlinks;
	private boolean blink;
	private int firstLine;
	private int physFirstLine; // only used when fold structure changes
	private int visibleLines;
	private int electricScroll;
	private int horizontalOffset;
	private boolean middleMousePaste;
	private JScrollBar vertical;
	private JScrollBar horizontal;
	private boolean scrollBarsInitialized;
	private Buffer buffer;
	private DocumentHandler documentHandler;
	private FoldHandler foldHandler;
	private boolean documentHandlerInstalled;
	private int caret;
	private int caretLine;
	private int bracketPosition;
	private int bracketLine;
	private int magicCaret;
	private static boolean multi;
	private boolean overwrite;
	private TextRenderer renderer;
	private static void quicksort(int[] obj, int _start, int _end)
	{
		int start = _start;
		int end = _end;
		int mid = obj[(_start + _end) / 2];
		if(_start > _end)
			return;
		while(start <= end)
		{
			while(start < _end && obj[start] < mid)
				start++;
			while(end > _start && obj[end] > mid)
				end--;
			if(start <= end)
			{
				int tmp = obj[start];
				obj[start] = obj[end];
				obj[end] = tmp;
				start++;
				end--;
			}
		}
		if(_start < end)
			quicksort(obj,_start,end);
		if(start < _end)
			quicksort(obj,start,_end);
	}
	private void _addToSelection(Selection addMe)
	{
		// this is stupid but it makes things much simpler for
		// the EditPane class
		if(addMe.start < 0)
			addMe.start = 0;
		else if(addMe.end > buffer.getLength())
			addMe.end = buffer.getLength();
		if(addMe.start > addMe.end)
		{
			throw new IllegalArgumentException(addMe.start
				+ "" > "" + addMe.end);
		}
		else if(addMe.start == addMe.end)
			return;
		for(int i = 0; i < selection.size(); i++)
		{
			// try and merge existing selections one by
			// one with the new selection
			Selection s = (Selection)selection.elementAt(i);
			if(_selectionsOverlap(s,addMe))
			{
				addMe.start = Math.min(s.start,addMe.start);
				addMe.end = Math.max(s.end,addMe.end);
				selection.removeElement(s);
				i--;
			}
		}
		addMe.startLine = getLineOfOffset(addMe.start);
		addMe.endLine = getLineOfOffset(addMe.end);
		selection.addElement(addMe);
		invalidateLineRange(addMe.startLine,addMe.endLine);
	}
	private boolean _selectionsOverlap(Selection s1, Selection s2)
	{
		if((s1.start >= s2.start && s1.start <= s2.end)
			|| (s1.end >= s2.start && s1.end <= s2.end))
			return true;
		else
			return false;
	}
	private void getSelectedText(Selection s, StringBuffer buf)
	{
		if(s instanceof Selection.Rect)
		{
			// Return each row of the selection on a new line
			Element map = buffer.getDefaultRootElement();
			int start = s.start - map.getElement(s.startLine)
				.getStartOffset();
			int end = s.end - map.getElement(s.endLine)
				.getStartOffset();
			// Certain rectangles satisfy this condition...
			if(end < start)
			{
				int tmp = end;
				end = start;
				start = tmp;
			}
			for(int i = s.startLine; i <= s.endLine; i++)
			{
				Element lineElement = map.getElement(i);
				int lineStart = lineElement.getStartOffset();
				int lineEnd = lineElement.getEndOffset() - 1;
				int lineLen = lineEnd - lineStart;
				lineStart = Math.min(lineStart + start,lineEnd);
				lineLen = Math.min(end - start,lineEnd - lineStart);
				getText(lineStart,lineLen,lineSegment);
				buf.append(lineSegment.array,
					lineSegment.offset,
					lineSegment.count);
				if(i != s.endLine)
					buf.append('\n');
			}
		}
		else
		{
			getText(s.start,s.end - s.start,lineSegment);
			buf.append(lineSegment.array,
				lineSegment.offset,
				lineSegment.count);
		}
	}
	private void fireCaretEvent()
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == CaretListener.class)
			{
				((CaretListener)listeners[i+1]).caretUpdate(caretEvent);
			}
		}
	}
	private void fireScrollEvent(boolean vertical)
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == ScrollListener.class)
			{
				if(vertical)
					((ScrollListener)listeners[i+1]).scrolledVertically(this);
				else
					((ScrollListener)listeners[i+1]).scrolledHorizontally(this);
			}
		}
	}
	private String createSoftTab(String line, int tabSize)
	{
		int pos = 0;
		for(int i = 0; i < line.length(); i++)
		{
			switch(line.charAt(pos))
			{
			case '\t':
				pos = 0;
				break;
			default:
				if(++pos >= tabSize)
					pos = 0;
				break;
			}
		}
		return MiscUtilities.createWhiteSpace(tabSize - pos,0);
	}
	private boolean doWordWrap(int line, boolean spaceInserted)
		throws BadLocationException
	{
		int maxLineLen = ((Integer)buffer.getProperty(""maxLineLen""))
			.intValue();
		if(maxLineLen <= 0)
			return false;
		Element lineElement = buffer.getDefaultRootElement()
			.getElement(line);
		int start = lineElement.getStartOffset();
		int end = lineElement.getEndOffset();
		int len = end - start - 1;
		// don't wrap unless we're at the end of the line
		if(getCaretPosition() != end - 1)
			return false;
		boolean returnValue = false;
		int tabSize = buffer.getTabSize();
		String wordBreakChars = (String)buffer.getProperty(""wordBreakChars"");
		buffer.getText(start,len,lineSegment);
		int lineStart = lineSegment.offset;
		int logicalLength = 0; // length with tabs expanded
		int lastWordOffset = -1;
		boolean lastWasSpace = true;
		boolean initialWhiteSpace = true;
		int initialWhiteSpaceLength = 0;
		for(int i = 0; i < len; i++)
		{
			char ch = lineSegment.array[lineStart + i];
			if(ch == '\t')
			{
				if(initialWhiteSpace)
					initialWhiteSpaceLength = i + 1;
				logicalLength += tabSize - (logicalLength % tabSize);
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(ch == ' ')
			{
				if(initialWhiteSpace)
					initialWhiteSpaceLength = i + 1;
				logicalLength++;
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)
			{
				initialWhiteSpace = false;
				logicalLength++;
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else
			{
				initialWhiteSpace = false;
				logicalLength++;
				lastWasSpace = false;
			}
			int insertNewLineAt;
			if(spaceInserted && logicalLength == maxLineLen
				&& i == len - 1)
			{
				insertNewLineAt = end - 1;
				returnValue = true;
			}
			else if(logicalLength >= maxLineLen && lastWordOffset != -1)
				insertNewLineAt = lastWordOffset + start;
			else
				continue;
			try
			{
				buffer.beginCompoundEdit();
				buffer.insertString(insertNewLineAt,""\n"",null);
				buffer.indentLine(line + 1,true,true);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
			/* only ever return true if space was pressed
			 * with logicalLength == maxLineLen */
			return returnValue;
		}
		return false;
	}
	private void doWordCount(View view, String text)
	{
		char[] chars = text.toCharArray();
		int characters = chars.length;
		int words;
		if(characters == 0)
			words = 0;
		else
			words = 1;
		int lines = 1;
		boolean word = false;
		for(int i = 0; i < chars.length; i++)
		{
			switch(chars[i])
			{
			case '\r': case '\n':
				lines++;
			case ' ': case '\t':
				if(word)
				{
					words++;
					word = false;
				}
				break;
			default:
				word = true;
				break;
			}
		}
		Object[] args = { new Integer(characters), new Integer(words),
			new Integer(lines) };
		GUIUtilities.message(view,""wordcount"",args);
	}
	// return word that starts at 'offset'
	private String completeWord(String line, int offset, String noWordSep)
	{
		// '+ 1' so that findWordEnd() doesn't pick up the space at the start
		int wordEnd = TextUtilities.findWordEnd(line,offset + 1,noWordSep);
		return line.substring(offset,wordEnd);
	}
	private void updateBracketHighlight()
	{
		if(!painter.isBracketHighlightEnabled())
			return;
		if(bracketLine != -1)
			invalidateLine(bracketLine);
		int line = getCaretLine();
		int offset = getCaretPosition() - getLineStartOffset(line);
		if(offset == 0)
		{
			bracketPosition = bracketLine = -1;
			return;
		}
		int endLine;
		if(visibleLines == 0)
			endLine = buffer.getLineCount();
		else
		{
			endLine = Math.min(buffer.getLineCount(),
				buffer.virtualToPhysical(
				firstLine + visibleLines));
		}
		int beginLine = Math.min(line,physFirstLine);
		try
		{
			int bracketOffset = TextUtilities.findMatchingBracket(
				buffer,line,offset - 1,beginLine,endLine);
			if(bracketOffset != -1)
			{
				bracketLine = getLineOfOffset(bracketOffset);
				bracketPosition = bracketOffset
					- getLineStartOffset(bracketLine);
				invalidateLine(bracketLine);
				return;
			}
		}
		catch(BadLocationException bl)
		{
			Log.log(Log.ERROR,this,bl);
		}
		bracketLine = bracketPosition = -1;
	}
	private void documentChanged(DocumentEvent evt)
	{
		DocumentEvent.ElementChange ch = evt.getChange(
			buffer.getDefaultRootElement());
		int count;
		if(ch == null)
			count = 0;
		else
			count = ch.getChildrenAdded().length -
				ch.getChildrenRemoved().length;
		int line = getLineOfOffset(evt.getOffset());
		if(count == 0)
			invalidateLine(line);
		// do magic stuff
		else if(line < firstLine)
		{
			setFirstLine(firstLine + count);
			// calls updateScrollBars()
		}
		// end of magic stuff
		else
		{
			updateScrollBars();
			invalidateLineRange(line,buffer.virtualToPhysical(
				firstLine + visibleLines));
		}
	}
	static class TextAreaBorder extends AbstractBorder
	{
		private static final Insets insets = new Insets(1, 1, 2, 2);
		public void paintBorder(Component c, Graphics g, int x, int y,
			int width, int height)
		{
			g.translate(x,y);
			g.setColor(MetalLookAndFeel.getControlDarkShadow());
			g.drawRect(0,0,width-2,height-2);
			g.setColor(MetalLookAndFeel.getControlHighlight());
			g.drawLine(width-1,1,width-1,height-1);
			g.drawLine(1,height-1,width-1,height-1);
			g.setColor(MetalLookAndFeel.getControl());
			g.drawLine(width-2,2,width-2,2);
			g.drawLine(1,height-2,1,height-2);
			g.translate(-x,-y);
		}
		public Insets getBorderInsets(Component c)
		{
			return new Insets(1,1,2,2);
		}
	}
	class ScrollLayout implements LayoutManager
	{
		public void addLayoutComponent(String name, Component comp)
		{
			if(name.equals(CENTER))
				center = comp;
			else if(name.equals(RIGHT))
				right = comp;
			else if(name.equals(LEFT))
				left = comp;
			else if(name.equals(BOTTOM))
				bottom = comp;
		}
		public void removeLayoutComponent(Component comp)
		{
			if(center == comp)
				center = null;
			else if(right == comp)
				right = null;
			else if(left == comp)
				left = null;
			else if(bottom == comp)
				bottom = null;
		}
		public Dimension preferredLayoutSize(Container parent)
		{
			Dimension dim = new Dimension();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}
			dim.width = insets.left + insets.right;
			dim.height = insets.top + insets.bottom;
			Dimension leftPref = left.getPreferredSize();
			dim.width += leftPref.width;
			Dimension centerPref = center.getPreferredSize();
			dim.width += centerPref.width;
			dim.height += centerPref.height;
			Dimension rightPref = right.getPreferredSize();
			dim.width += rightPref.width;
			Dimension bottomPref = bottom.getPreferredSize();
			dim.height += bottomPref.height;
			return dim;
		}
		public Dimension minimumLayoutSize(Container parent)
		{
			Dimension dim = new Dimension();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}
			dim.width = insets.left + insets.right;
			dim.height = insets.top + insets.bottom;
			Dimension leftPref = left.getMinimumSize();
			dim.width += leftPref.width;
			Dimension centerPref = center.getMinimumSize();
			dim.width += centerPref.width; 
			dim.height += centerPref.height;
			Dimension rightPref = right.getMinimumSize();
			dim.width += rightPref.width;
			Dimension bottomPref = bottom.getMinimumSize();
			dim.height += bottomPref.height;
			return dim;
		}
		public void layoutContainer(Container parent)
		{
			Dimension size = parent.getSize();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}
			int itop = insets.top;
			int ileft = insets.left;
			int ibottom = insets.bottom;
			int iright = insets.right;
			int rightWidth = right.getPreferredSize().width;
			int leftWidth = left.getPreferredSize().width;
			int bottomHeight = bottom.getPreferredSize().height;
			int centerWidth = Math.max(0,size.width - leftWidth
				- rightWidth - ileft - iright);
			int centerHeight = Math.max(0,size.height
				- bottomHeight - itop - ibottom);
			left.setBounds(
				ileft,
				itop,
				leftWidth,
				centerHeight);
			center.setBounds(
				ileft + leftWidth,
				itop,
				centerWidth,
				centerHeight);
			right.setBounds(
				ileft + leftWidth + centerWidth,
				itop,
				rightWidth,
				centerHeight);
			bottom.setBounds(
				ileft,
				itop + centerHeight,
				Math.max(0,size.width - rightWidth - ileft - iright),
				bottomHeight);
		}
		Component center;
		Component left;
		Component right;
		Component bottom;
	}
	static class CaretBlinker implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(focusedComponent != null && focusedComponent.hasFocus())
				focusedComponent.blinkCaret();
		}
	}
	class MutableCaretEvent extends CaretEvent
	{
		MutableCaretEvent()
		{
			super(JEditTextArea.this);
		}
		public int getDot()
		{
			return getCaretPosition();
		}
		public int getMark()
		{
			return getMarkPosition();
		}
	}
	class AdjustHandler implements AdjustmentListener
	{
		public void adjustmentValueChanged(final AdjustmentEvent evt)
		{
			if(!scrollBarsInitialized)
				return;
			if(evt.getAdjustable() == vertical)
				setFirstLine(vertical.getValue());
			else
				setHorizontalOffset(-horizontal.getValue());
		}
	}
	class ComponentHandler extends ComponentAdapter
	{
		public void componentResized(ComponentEvent evt)
		{
			recalculateVisibleLines();
			scrollBarsInitialized = true;
		}
	}
	class DocumentHandler implements DocumentListener
	{
		public void insertUpdate(DocumentEvent evt)
		{
			if(!buffer.isLoaded())
				return;
			documentChanged(evt);
			int offset = evt.getOffset();
			int length = evt.getLength();
			if(caret >= offset)
				moveCaretPosition(caret + length,true);
			else
				updateBracketHighlight();
			// loop through all selections, resizing them if
			// necessary
			for(int i = 0; i < selection.size(); i++)
			{
				Selection s = (Selection)selection.elementAt(i);
				boolean changed = false;
				if(s.start >= offset)
				{
					s.start += length;
					s.startLine = getLineOfOffset(s.start);
					changed = true;
				}
				if(s.end >= offset)
				{
					s.end += length;
					s.endLine = getLineOfOffset(s.end);
					changed = true;
				}
				if(changed)
					invalidateLineRange(s.startLine,s.endLine);
			}
		}
		public void removeUpdate(DocumentEvent evt)
		{
			if(!buffer.isLoaded())
				return;
			documentChanged(evt);
			int offset = evt.getOffset();
			int length = evt.getLength();
			int end = offset + length;
			boolean caretEvent = false;
			// loop through all selections, resizing them if
			// necessary
			for(int i = 0; i < selection.size(); i++)
			{
				Selection s = (Selection)selection.elementAt(i);
				boolean changed = false;
				if(s.start > offset && s.start <= end)
				{
					s.start = offset;
					changed = caretEvent = true;
				}
				else if(s.start > end)
				{
					s.start -= length;
					changed = caretEvent = true;
				}
				if(s.end > offset && s.end <= end)
				{
					s.end = offset;
					changed = caretEvent = true;
				}
				else if(s.end > end)
				{
					s.end -= length;
					changed = caretEvent = true;
				}
				if(s.start == s.end)
				{
					selection.removeElement(s);
					invalidateLineRange(s.startLine,s.endLine);
					i--;
				}
				else if(changed)
				{
					s.startLine = getLineOfOffset(s.start);
					s.endLine = getLineOfOffset(s.end);
					invalidateLineRange(s.startLine,s.endLine);
				}
			}
			if(caret > offset && caret <= end)
				moveCaretPosition(offset,false);
			else if(caret > end)
				moveCaretPosition(caret - length,false);
			else
			{
				updateBracketHighlight();
				if(caretEvent)
					fireCaretEvent();
			}
		}
		public void changedUpdate(DocumentEvent evt) {}
	}
	class FoldHandler implements Buffer.FoldListener
	{
		public void foldLevelsChanged(int firstLine, int lastLine)
		{
			invalidateLineRange(firstLine,lastLine);
		}
		public void foldStructureChanged()
		{
			// recalculate first line
			setFirstLine(buffer.physicalToVirtual(physFirstLine));
			// update scroll bars because the number of
			// virtual lines might have changed
			updateScrollBars();
			// repaint gutter and painter
			gutter.repaint();
			// this should really go elsewhere!!!
			if(view.getTextArea() == JEditTextArea.this)
				view.getStatus().updateFoldStatus();
		}
	}
	class FocusHandler implements FocusListener
	{
		public void focusGained(FocusEvent evt)
		{
			invalidateLine(caretLine);
			// repaint the gutter so that the border color
			// reflects the focus state
			view.updateGutterBorders();
		}
		public void focusLost(FocusEvent evt)
		{
			invalidateLine(caretLine);
		}
	}
	class MouseHandler extends MouseAdapter implements MouseMotionListener
	{
		private int dragStartLine;
		private int dragStartOffset;
		private int dragStart;
		private int clickCount;
		public void mousePressed(MouseEvent evt)
		{
			buffer.endCompoundEdit();
			grabFocus();
			if(GUIUtilities.isPopupTrigger(evt) && popup != null)
			{
				if(popup.isVisible())
					popup.setVisible(false);
				else
					popup.show(painter,evt.getX()+1,evt.getY()+1);
				return;
			}
			blink = true;
			invalidateLine(caretLine);
			int x = evt.getX();
			int y = evt.getY();
			dragStartLine = buffer.virtualToPhysical(yToLine(y));
			dragStartOffset = xToOffset(dragStartLine,x);
			dragStart = xyToOffset(x,y,!painter.isBlockCaretEnabled());
			clickCount = evt.getClickCount();
			switch(clickCount)
			{
			case 1:
				doSingleClick(evt);
				break;
			case 2:
				// It uses the bracket matching stuff, so
				// it can throw a BLE
				try
				{
					doDoubleClick(evt);
				}
				catch(BadLocationException bl)
				{
					bl.printStackTrace();
				}
				break;
			default: //case 3:
				doTripleClick(evt);
				break;
			}
		}
		public void mouseReleased(MouseEvent evt)
		{
			if(getSelectionCount() != 0)
				Registers.setRegister('%',getSelectedText());
		}
		private void doSingleClick(MouseEvent evt)
		{
			if(evt.isShiftDown())
			{
				// XXX: getMarkPosition() deprecated!
				resizeSelection(getMarkPosition(),dragStart,
					evt.isControlDown());
				moveCaretPosition(dragStart,false);
				// so that shift-click-drag works
				dragStartLine = getMarkLine();
				dragStart = getMarkPosition();
				dragStartOffset = dragStart
					- getLineStartOffset(dragStartLine);
			}
			else
			{
				if(!multi)
					selectNone();
				moveCaretPosition(dragStart,false);
				if(middleMousePaste
					&& (evt.getModifiers() & InputEvent.BUTTON2_MASK) != 0)
				{
					if(!isEditable())
						getToolkit().beep();
					else
						Registers.paste(JEditTextArea.this,'%');
				}
			}
		}
		private void doDoubleClick(MouseEvent evt)
			throws BadLocationException
		{
			// Ignore empty lines
			if(getLineLength(dragStartLine) == 0)
				return;
			try
			{
				int bracket = TextUtilities.findMatchingBracket(
					buffer,dragStartLine,
					Math.max(0,dragStartOffset - 1));
				if(bracket != -1)
				{
					// Hack
					if(bracket < caret)
					{
						addToSelection(new Selection.Range(
							bracket,caret));
					}
					else
					{
						addToSelection(new Selection.Range(
							caret - 1,++bracket));
					}
					moveCaretPosition(bracket,false);
					return;
				}
			}
			catch(BadLocationException bl)
			{
				Log.log(Log.ERROR,this,bl);
			}
			// Ok, it's not a bracket... select the word
			String lineText = getLineText(dragStartLine);
			String noWordSep = (String)buffer.getProperty(""noWordSep"");
			if(dragStartOffset == getLineLength(dragStartLine))
				dragStartOffset--;
			int wordStart = TextUtilities.findWordStart(lineText,
				dragStartOffset,noWordSep);
			int wordEnd = TextUtilities.findWordEnd(lineText,
				dragStartOffset+1,noWordSep);
			int lineStart = getLineStartOffset(dragStartLine);
			addToSelection(new Selection.Range(lineStart + wordStart,
				lineStart + wordEnd));
			moveCaretPosition(lineStart + wordEnd,false);
		}
		private void doTripleClick(MouseEvent evt)
		{
			int newCaret = getLineEndOffset(dragStartLine);
			addToSelection(new Selection.Range(
				getLineStartOffset(dragStartLine),
				newCaret));
			moveCaretPosition(newCaret);
		}
		public void mouseDragged(MouseEvent evt)
		{
			if(GUIUtilities.isPopupTrigger(evt)
				|| (popup != null && popup.isVisible()))
				return;
			boolean rect = evt.isControlDown();
			switch(clickCount)
			{
			case 1:
				doSingleDrag(evt,rect);
				break;
			case 2:
				doDoubleDrag(evt,rect);
				break;
			default: //case 3:
				doTripleDrag(evt,rect);
				break;
			}
		}
		public void mouseMoved(MouseEvent evt) {}
		private void doSingleDrag(MouseEvent evt, boolean rect)
		{
			int dot = xyToOffset(evt.getX(),evt.getY(),
				!painter.isBlockCaretEnabled());
			if(dot == caret)
				return;
			resizeSelection(dragStart,dot,rect);
			moveCaretPosition(dot,false);
		}
		private void doDoubleDrag(MouseEvent evt, boolean rect)
		{
			int markLineStart = getLineStartOffset(dragStartLine);
			int markLineLength = getLineLength(dragStartLine);
			int mark = dragStartOffset;
			int line = buffer.virtualToPhysical(yToLine(evt.getY()));
			int lineStart = getLineStartOffset(line);
			int lineLength = getLineLength(line);
			int offset = xToOffset(line,evt.getX());
			String lineText = getLineText(line);
			String markLineText = getLineText(dragStartLine);
			String noWordSep = (String)buffer.getProperty(""noWordSep"");
			if(markLineStart + dragStartOffset > lineStart + offset)
			{
				if(offset != 0 && offset != lineLength)
				{
					offset = TextUtilities.findWordStart(
						lineText,offset,noWordSep);
				}
				if(markLineLength != 0)
				{
					mark = TextUtilities.findWordEnd(
						markLineText,mark,noWordSep);
				}
			}
			else
			{
				if(offset != 0 && lineLength != 0)
				{
					offset = TextUtilities.findWordEnd(
						lineText,offset,noWordSep);
				}
				if(mark != 0 && mark != markLineLength)
				{
					mark = TextUtilities.findWordStart(
						markLineText,mark,noWordSep);
				}
			}
			if(lineStart + offset == caret)
				return;
			resizeSelection(markLineStart + mark,lineStart + offset,rect);
			moveCaretPosition(lineStart + offset,false);
		}
		private void doTripleDrag(MouseEvent evt, boolean rect)
		{
			int mouseLine = buffer.virtualToPhysical(yToLine(evt.getY()));
			int offset = xToOffset(mouseLine,evt.getX());
			int mark;
			int mouse;
			if(dragStartLine > mouseLine)
			{
				mark = getLineEndOffset(dragStartLine) - 1;
				if(offset == getLineLength(mouseLine))
					mouse = getLineEndOffset(mouseLine) - 1;
				else
					mouse = getLineStartOffset(mouseLine);
			}
			else
			{
				mark = getLineStartOffset(dragStartLine);
				if(offset == 0)
					mouse = getLineStartOffset(mouseLine);
				else
					mouse = getLineEndOffset(mouseLine) - 1;
			}
			if(mouse == caret)
				return;
			resizeSelection(mark,mouse,rect);
			moveCaretPosition(mouse,false);
		}
	}
	static class CaretUndo extends AbstractUndoableEdit
	{
		private int caret;
		CaretUndo(int caret)
		{
			this.caret = caret;
		}
		public boolean isSignificant()
		{
			return false;
		}
		public String getPresentationName()
		{
			return ""caret move"";
		}
		public void undo() throws CannotUndoException
		{
			super.undo();
			if(focusedComponent != null)
			{
				int length = focusedComponent
					.getBuffer().getLength();
				if(caret <= length)
				{
					focusedComponent.selectNone();
					focusedComponent.setCaretPosition(caret);
				}
				else
					Log.log(Log.WARNING,this,
						caret + "" > "" + length + ""??!!"");
			}
		}
		public boolean addEdit(UndoableEdit edit)
		{
			if(edit instanceof CaretUndo)
			{
				edit.die();
				return true;
			}
			else
				return false;
		}
		public String toString()
		{
			return getPresentationName() + ""[caret="" + caret + ""]"";
		}
	}
	static
	{
		caretTimer = new Timer(500,new CaretBlinker());
		caretTimer.setInitialDelay(500);
		caretTimer.start();
	}
}
"
org.gjt.sp.jedit.textarea.MarkerHighlight,"/*
 * MarkerHighlight.java - Paints marker highlights in the gutter
 * Copyright (C) 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.Vector;
import org.gjt.sp.jedit.*;
public class MarkerHighlight implements TextAreaHighlight
{
	public void init(JEditTextArea textArea, TextAreaHighlight next)
	{
		this.textArea = textArea;
		this.next = next;
	}
	public void paintHighlight(Graphics gfx, int line, int y)
	{
		if(textArea.getBuffer().isLoaded() && highlightEnabled)
		{
			Buffer buffer = textArea.getBuffer();
			if(buffer.getMarkerAtLine(buffer.virtualToPhysical(line)) != null)
			{
				int firstLine = textArea.getFirstLine();
				line -= firstLine;
				FontMetrics fm = textArea.getPainter().getFontMetrics();
				gfx.setColor(markerHighlightColor);
				gfx.fillRect(0,line * fm.getHeight(),textArea.getGutter()
					.getWidth(),fm.getHeight());
			}
		}
		if(next != null)
			next.paintHighlight(gfx,line,y);
	}
	public String getToolTipText(MouseEvent evt)
	{
		if(textArea.getBuffer().isLoaded() && highlightEnabled)
		{
			FontMetrics fm = textArea.getPainter().getFontMetrics();
			int line = textArea.getFirstLine() + evt.getY() / fm.getHeight();
			Buffer buffer = textArea.getBuffer();
			Marker marker = buffer.getMarkerAtLine(buffer.virtualToPhysical(line));
			if(marker != null)
			{
				char shortcut = marker.getShortcut();
				if(shortcut == '\0')
					return jEdit.getProperty(""view.gutter.marker.no-name"");
				else
				{
					String[] args = { String.valueOf(shortcut) };
					return jEdit.getProperty(""view.gutter.marker"",args);
				}
			}
		}
		if(next != null)
			return next.getToolTipText(evt);
		else
			return null;
	}
	public Color getMarkerHighlightColor()
	{
		return markerHighlightColor;
	}
	public void setMarkerHighlightColor(Color markerHighlightColor)
	{
		this.markerHighlightColor = markerHighlightColor;
	}
	public boolean isHighlightEnabled()
	{
		return highlightEnabled;
	}
	public void setHighlightEnabled(boolean highlightEnabled)
	{
		this.highlightEnabled = highlightEnabled;
	}
	// private members
	private JEditTextArea textArea;
	private TextAreaHighlight next;
	private boolean highlightEnabled;
	private Color markerHighlightColor;
}
"
org.gjt.sp.jedit.textarea.ScrollListener,"/*
 * ScrollListener.java - Text area scroll listener
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
/**
 * A scroll listener will be notified when the text area is scrolled, either
 * horizontally or vertically.
 * @author Slava Pestov
 * @version $Id: ScrollListener.java,v 1.3 2001/05/18 07:12:10 sp Exp $
 * @since jEdit 3.2pre2
 */
public interface ScrollListener extends java.util.EventListener
{
	void scrolledVertically(JEditTextArea textArea);
	void scrolledHorizontally(JEditTextArea textArea);
}
"
org.gjt.sp.jedit.textarea.Selection,"/*
 * Selection.java - Selected text
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
import javax.swing.text.*;
import org.gjt.sp.jedit.Buffer;
/**
 * An interface representing a portion of the current selection.
 * @author Slava Pestov
 * @version $Id: Selection.java,v 1.1 2001/04/27 11:28:46 sp Exp $
 * @since jEdit 3.2pre1
 */
public abstract class Selection
{
	/**
	 * Returns the start offset of this selection.
	 */
	public int getStart()
	{
		return start;
	}
	/**
	 * Returns the end offset of this selection.
	 */
	public int getEnd()
	{
		return end;
	}
	/**
	 * Returns the starting line number of this selection.
	 */
	public int getStartLine()
	{
		return startLine;
	}
	/**
	 * Returns the ending line number of this selection.
	 */
	public int getEndLine()
	{
		return endLine;
	}
	/**
	 * Returns the start offset of this selection on the specified
	 * line.
	 * @param buffer The buffer
	 * @param line The line number
	 */
	public abstract int getStart(Buffer buffer, int line);
	/**
	 * Returns the end offset of this selection on the specified
	 * line.
	 * @param buffer The buffer
	 * @param line The line number
	 */
	public abstract int getEnd(Buffer buffer, int line);
	public String toString()
	{
		return getClass().getName() + ""[start="" + start
			+ "",end="" + end + "",startLine="" + startLine
			+ "",endLine="" + endLine + ""]"";
	}
	// package-private members
	int start, end, startLine, endLine;
	// protected members
	protected Selection()
	{
	}
	protected Selection(Selection copy)
	{
		start = copy.start;
		end = copy.end;
	}
	protected Selection(int start, int end)
	{
		this.start = start;
		this.end = end;
		// setting these is handled by textArea._addToSelection();
		//this.startLine = startLine;
		//this.endLine = endLine;
	}
	/**
	 * An ordinary range selection.
	 * @since jEdit 3.2pre1
	 */
	public static class Range extends Selection
	{
		public Range()
		{
			super();
		}
		public Range(Selection sel)
		{
			super(sel);
		}
		public Range(int start, int end)
		{
			super(start,end);
		}
		public int getStart(Buffer buffer, int line)
		{
			if(line == startLine)
				return start;
			else
			{
				Element map = buffer.getDefaultRootElement();
				Element lineElement = map.getElement(line);
				return lineElement.getStartOffset();
			}
		}
		public int getEnd(Buffer buffer, int line)
		{
			if(line == endLine)
				return end;
			else
			{
				Element map = buffer.getDefaultRootElement();
				Element lineElement = map.getElement(line);
				return lineElement.getEndOffset() - 1;
			}
		}
	}
	/**
	 * A rectangular selection.
	 * @since jEdit 3.2pre1
	 */
	public static class Rect extends Selection
	{
		public Rect()
		{
			super();
		}
		public Rect(Selection sel)
		{
			super(sel);
		}
		public Rect(int start, int end)
		{
			super(start,end);
		}
		public int getStart(Buffer buffer, int line)
		{
			if(line == startLine)
				return start;
			else
			{
				Element map = buffer.getDefaultRootElement();
				int _start = start - map.getElement(startLine)
					.getStartOffset();
				int _end = end - map.getElement(endLine)
					.getStartOffset();
				Element lineElement = map.getElement(line);
				return Math.min(lineElement.getEndOffset() - 1,
					lineElement.getStartOffset()
					+ Math.min(_start,_end));
			}
		}
		public int getEnd(Buffer buffer, int line)
		{
			if(line == endLine)
				return end;
			else
			{
				Element map = buffer.getDefaultRootElement();
				int _start = start - map.getElement(startLine)
					.getStartOffset();
				int _end = end - map.getElement(endLine)
					.getStartOffset();
				Element lineElement = map.getElement(line);
				return Math.min(lineElement.getEndOffset() - 1,
					lineElement.getStartOffset()
					+ Math.max(_start,_end));
			}
		}
	}
}
"
org.gjt.sp.jedit.textarea.TextAreaHighlight,"/*
 * TextAreaHighlight.java - Paints custom highlights in the text area
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
import java.awt.Graphics;
import java.awt.event.MouseEvent;
/**
 * Highlight interface. Create implementations of this interface and
 * add them to the text area with <code>TextAreaPainter.addCustomHighlight()</code>
 * to paint custom highlights.
 *
 * @author Slava Pestov
 * @version $Id: TextAreaHighlight.java,v 1.3 2001/01/26 03:46:56 sp Exp $
 */
public interface TextAreaHighlight
{
	/**
	 * Called after the highlight painter has been added.
	 * @param textArea The text area
	 * @param next The painter this one should delegate to
	 */
	void init(JEditTextArea textArea, TextAreaHighlight next);
	/**
	 * This should paint the highlight and delgate to the
	 * next highlight painter.
	 * @param gfx The graphics context
	 * @param line The virtual line number
	 * @param y The y co-ordinate of the line
	 */
	void paintHighlight(Graphics gfx, int line, int y);
	/**
	 * Returns the tool tip to display at the specified
	 * location. If this highlighter doesn't know what to
	 * display, it should delegate to the next highlight
	 * painter.
	 * @param evt The mouse event
	 */
	String getToolTipText(MouseEvent evt);
}
"
org.gjt.sp.jedit.textarea.TextAreaPainter,"/*
 * TextAreaPainter.java - Paints the text area
 * Copyright (C) 1999, 2000, 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
import javax.swing.text.*;
import javax.swing.JComponent;
import java.awt.event.MouseEvent;
import java.awt.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.TextUtilities;
import org.gjt.sp.util.Log;
/**
 * The text area repaint manager. It performs double buffering and paints
 * lines of text.
 * @author Slava Pestov
 * @version $Id: TextAreaPainter.java,v 1.66 2001/07/20 11:29:05 sp Exp $
 */
public class TextAreaPainter extends JComponent implements TabExpander
{
	/**
	 * Creates a new painter. Do not create instances of this class
	 * directly.
	 */
	public TextAreaPainter(JEditTextArea textArea)
	{
		enableEvents(AWTEvent.FOCUS_EVENT_MASK
			| AWTEvent.KEY_EVENT_MASK
			| AWTEvent.MOUSE_EVENT_MASK);
		this.textArea = textArea;
		setAutoscrolls(true);
		setDoubleBuffered(true);
		setOpaque(true);
		setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));
	}
	/**
	 * Returns if this component can be traversed by pressing the
	 * Tab key. This returns false.
	 */
	public boolean isManagingFocus()
	{
		return false;
	}
	/**
	 * Makes the tab key work in Java 1.4.
	 * @since jEdit 3.2pre4
	 */
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	}
	/**
	 * Returns the syntax styles used to paint colorized text. Entry <i>n</i>
	 * will be used to paint tokens with id = <i>n</i>.
	 * @see org.gjt.sp.jedit.syntax.Token
	 */
	public final SyntaxStyle[] getStyles()
	{
		return styles;
	}
	/**
	 * Sets the syntax styles used to paint colorized text. Entry <i>n</i>
	 * will be used to paint tokens with id = <i>n</i>.
	 * @param styles The syntax styles
	 * @see org.gjt.sp.jedit.syntax.Token
	 */
	public final void setStyles(SyntaxStyle[] styles)
	{
		this.styles = styles;
		repaint();
	}
	/**
	 * Returns the caret color.
	 */
	public final Color getCaretColor()
	{
		return caretColor;
	}
	/**
	 * Sets the caret color.
	 * @param caretColor The caret color
	 */
	public final void setCaretColor(Color caretColor)
	{
		this.caretColor = caretColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	}
	/**
	 * Returns the selection color.
	 */
	public final Color getSelectionColor()
	{
		return selectionColor;
	}
	/**
	 * Sets the selection color.
	 * @param selectionColor The selection color
	 */
	public final void setSelectionColor(Color selectionColor)
	{
		this.selectionColor = selectionColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateSelectedLines();
	}
	/**
	 * Returns the line highlight color.
	 */
	public final Color getLineHighlightColor()
	{
		return lineHighlightColor;
	}
	/**
	 * Sets the line highlight color.
	 * @param lineHighlightColor The line highlight color
	 */
	public final void setLineHighlightColor(Color lineHighlightColor)
	{
		this.lineHighlightColor = lineHighlightColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	}
	/**
	 * Returns true if line highlight is enabled, false otherwise.
	 */
	public final boolean isLineHighlightEnabled()
	{
		return lineHighlight;
	}
	/**
	 * Enables or disables current line highlighting.
	 * @param lineHighlight True if current line highlight should be enabled,
	 * false otherwise
	 */
	public final void setLineHighlightEnabled(boolean lineHighlight)
	{
		this.lineHighlight = lineHighlight;
		if(textArea.getBuffer() != null)
			textArea.invalidateSelectedLines();
	}
	/**
	 * Returns the bracket highlight color.
	 */
	public final Color getBracketHighlightColor()
	{
		return bracketHighlightColor;
	}
	/**
	 * Sets the bracket highlight color.
	 * @param bracketHighlightColor The bracket highlight color
	 */
	public final void setBracketHighlightColor(Color bracketHighlightColor)
	{
		this.bracketHighlightColor = bracketHighlightColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getBracketLine());
	}
	/**
	 * Returns true if bracket highlighting is enabled, false otherwise.
	 * When bracket highlighting is enabled, the bracket matching the
	 * one before the caret (if any) is highlighted.
	 */
	public final boolean isBracketHighlightEnabled()
	{
		return bracketHighlight;
	}
	/**
	 * Enables or disables bracket highlighting.
	 * When bracket highlighting is enabled, the bracket matching the
	 * one before the caret (if any) is highlighted.
	 * @param bracketHighlight True if bracket highlighting should be
	 * enabled, false otherwise
	 */
	public final void setBracketHighlightEnabled(boolean bracketHighlight)
	{
		this.bracketHighlight = bracketHighlight;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getBracketLine());
	}
	/**
	 * Returns true if the caret should be drawn as a block, false otherwise.
	 */
	public final boolean isBlockCaretEnabled()
	{
		return blockCaret;
	}
	/**
	 * Sets if the caret should be drawn as a block, false otherwise.
	 * @param blockCaret True if the caret should be drawn as a block,
	 * false otherwise.
	 */
	public final void setBlockCaretEnabled(boolean blockCaret)
	{
		this.blockCaret = blockCaret;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	}
	/**
	 * Returns the EOL marker color.
	 */
	public final Color getEOLMarkerColor()
	{
		return eolMarkerColor;
	}
	/**
	 * Sets the EOL marker color.
	 * @param eolMarkerColor The EOL marker color
	 */
	public final void setEOLMarkerColor(Color eolMarkerColor)
	{
		this.eolMarkerColor = eolMarkerColor;
		repaint();
	}
	/**
	 * Returns true if EOL markers are drawn, false otherwise.
	 */
	public final boolean getEOLMarkersPainted()
	{
		return eolMarkers;
	}
	/**
	 * Sets if EOL markers are to be drawn.
	 * @param eolMarkers True if EOL markers should be drawn, false otherwise
	 */
	public final void setEOLMarkersPainted(boolean eolMarkers)
	{
		this.eolMarkers = eolMarkers;
		repaint();
	}
	/**
	 * Returns the wrap guide color.
	 */
	public final Color getWrapGuideColor()
	{
		return wrapGuideColor;
	}
	/**
	 * Sets the wrap guide color.
	 * @param wrapGuideColor The wrap guide color
	 */
	public final void setWrapGuideColor(Color wrapGuideColor)
	{
		this.wrapGuideColor = wrapGuideColor;
		repaint();
	}
	/**
	 * Returns true if the wrap guide is drawn, false otherwise.
	 */
	public final boolean getWrapGuidePainted()
	{
		return wrapGuide;
	}
	/**
	 * Sets if the wrap guide is to be drawn.
	 * @param wrapGuide True if the wrap guide should be drawn, false otherwise
	 */
	public final void setWrapGuidePainted(boolean wrapGuide)
	{
		this.wrapGuide = wrapGuide;
		repaint();
	}
	/**
	 * Sets if anti-aliasing should be enabled. Has no effect when
	 * running on Java 1.1.
	 * @since jEdit 3.2pre6
	 */
	public void setAntiAliasEnabled(boolean antiAlias)
	{
		this.antiAlias = antiAlias;
		textArea.getTextRenderer().configure(antiAlias,fracFontMetrics);
	}
	/**
	 * Returns if anti-aliasing is enabled.
	 * @since jEdit 3.2pre6
	 */
	public boolean isAntiAliasEnabled()
	{
		return antiAlias;
	}
	/**
	 * Sets if fractional font metrics should be enabled. Has no effect when
	 * running on Java 1.1.
	 * @since jEdit 3.2pre6
	 */
	public void setFractionalFontMetricsEnabled(boolean fracFontMetrics)
	{
		this.fracFontMetrics = fracFontMetrics;
		textArea.getTextRenderer().configure(antiAlias,fracFontMetrics);
	}
	/**
	 * Returns if fractional font metrics are enabled.
	 * @since jEdit 3.2pre6
	 */
	public boolean isFractionalFontMetricsEnabled()
	{
		return fracFontMetrics;
	}
	/**
	 * Adds a custom highlight painter.
	 * @param highlight The highlight
	 */
	public void addCustomHighlight(TextAreaHighlight highlight)
	{
		highlight.init(textArea,highlights);
		highlights = highlight;
	}
	/**
	 * Returns the tool tip to display at the specified location.
	 * @param evt The mouse event
	 */
	public String getToolTipText(MouseEvent evt)
	{
		if(maxLineLen != 0)
		{
			int wrapGuidePos = maxLineLen + textArea.getHorizontalOffset();
			if(Math.abs(evt.getX() - wrapGuidePos) < 5)
			{
				return String.valueOf(textArea.getBuffer()
					.getProperty(""maxLineLen""));
			}
		}
		if(highlights != null)
			return highlights.getToolTipText(evt);
		else
			return null;
	}
	/**
	 * Returns the font metrics used by this component.
	 */
	public FontMetrics getFontMetrics()
	{
		return fm;
	}
	/**
	 * Sets the font for this component. This is overridden to update the
	 * cached font metrics and to recalculate which lines are visible.
	 * @param font The font
	 */
	public void setFont(Font font)
	{
		super.setFont(font);
		fm = getFontMetrics(font);
		textArea.recalculateVisibleLines();
		updateTabSize();
	}
	/**
	 * Repaints the text.
	 * @param g The graphics context
	 */
	public void paintComponent(Graphics gfx)
	{
		updateTabSize();
		textArea.getTextRenderer().setupGraphics(gfx);
		Buffer buffer = textArea.getBuffer();
		Rectangle clipRect = gfx.getClipBounds();
		gfx.setColor(getBackground());
		gfx.fillRect(clipRect.x,clipRect.y,clipRect.width,clipRect.height);
		int x = textArea.getHorizontalOffset();
		int height = fm.getHeight();
		int firstLine = textArea.getFirstLine();
		int firstInvalid = firstLine + clipRect.y / height;
		// Because the clipRect's height is usually an even multiple
		// of the font height, we subtract 1 from it, otherwise one
		// too many lines will always be painted.
		int lastInvalid = firstLine + (clipRect.y + clipRect.height - 1) / height;
		int lineCount = textArea.getVirtualLineCount();
		int y = (clipRect.y - clipRect.y % height);
		try
		{
			int maxWidth = textArea.maxHorizontalScrollWidth;
			boolean updateMaxHorizontalScrollWidth = false;
			for(int line = firstInvalid; line <= lastInvalid; line++)
			{
				boolean valid = buffer.isLoaded()
					&& line >= 0 && line < lineCount;
				int physicalLine;
				if(valid)
					physicalLine = buffer.virtualToPhysical(line);
				else
				{
					int virtualLineCount = buffer.getVirtualLineCount();
					physicalLine = buffer.virtualToPhysical(
						virtualLineCount - 1)
						+ (line - virtualLineCount);
				}
				int width = paintLine(gfx,buffer,valid,line,
					physicalLine,x,y)
					- x + 5 /* Yay */;
				if(valid)
				{
					buffer.setLineWidth(physicalLine,width);
					if(width > maxWidth)
						updateMaxHorizontalScrollWidth = true;
				}
				y += height;
			}
			if(buffer.isNextLineRequested())
			{
				int h = clipRect.y + clipRect.height;
				repaint(0,h,getWidth(),getHeight() - h);
			}
			if(updateMaxHorizontalScrollWidth)
				textArea.updateMaxHorizontalScrollWidth();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,""Error repainting line""
				+ "" range {"" + firstInvalid + "",""
				+ lastInvalid + ""}:"");
			Log.log(Log.ERROR,this,e);
		}
	}
	/**
	 * Implementation of TabExpander interface. Returns next tab stop after
	 * a specified point.
	 * @param x The x co-ordinate
	 * @param tabOffset Ignored
	 * @return The next tab stop after <i>x</i>
	 */
	public float nextTabStop(float x, int tabOffset)
	{
		int offset = textArea.getHorizontalOffset();
		int ntabs = ((int)x - offset) / tabSize;
		return (ntabs + 1) * tabSize + offset;
	}
	/**
	 * Returns the painter's preferred size.
	 */
	public Dimension getPreferredSize()
	{
		Dimension dim = new Dimension();
		dim.width = fm.charWidth('w') * 80;
		dim.height = fm.getHeight() * 25;
		return dim;
	}
	/**
	 * Returns the painter's minimum size.
	 */
	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	}
	// package-private members
	void updateTabSize()
	{
		if(textArea.getBuffer() == null)
			return;
		tabSize = fm.charWidth(' ') * ((Integer)textArea
			.getBuffer().getProperty(
			PlainDocument.tabSizeAttribute)).intValue();
		int _maxLineLen = ((Integer)textArea.getBuffer()
			.getProperty(""maxLineLen"")).intValue();
		if(_maxLineLen <= 0)
			maxLineLen = 0;
		else
			maxLineLen = fm.charWidth(' ') * _maxLineLen;
	}
	// private members
	private JEditTextArea textArea;
	private SyntaxStyle[] styles;
	private Color caretColor;
	private Color selectionColor;
	private Color lineHighlightColor;
	private Color bracketHighlightColor;
	private Color eolMarkerColor;
	private Color wrapGuideColor;
	private boolean blockCaret;
	private boolean lineHighlight;
	private boolean bracketHighlight;
	private boolean eolMarkers;
	private boolean wrapGuide;
	private boolean antiAlias;
	private boolean fracFontMetrics;
	private int tabSize;
	private int maxLineLen;
	private FontMetrics fm;
	private TextAreaHighlight highlights;
	private int paintLine(Graphics gfx, Buffer buffer, boolean valid,
		int virtualLine, int physicalLine, int x, int y)
	{
		paintHighlight(gfx,virtualLine,physicalLine,y,valid);
		if(maxLineLen != 0 && wrapGuide)
		{
			gfx.setColor(wrapGuideColor);
			gfx.drawLine(x + maxLineLen,y,x + maxLineLen,
				y + fm.getHeight());
		}
		if(valid)
		{
			Font defaultFont = getFont();
			Color defaultColor = getForeground();
			gfx.setFont(defaultFont);
			gfx.setColor(defaultColor);
			int baseLine = y + fm.getHeight()
				- fm.getLeading() - fm.getDescent();
			x = buffer.paintSyntaxLine(physicalLine,gfx,x,baseLine,
				this,true,true,defaultFont,defaultColor,
				(lineHighlight
				&& textArea.getSelectionCount() == 0
				&& physicalLine == textArea.getCaretLine()
				? lineHighlightColor
				: getBackground()),styles,
				textArea.getTextRenderer());
			if(eolMarkers)
			{
				gfx.setFont(defaultFont);
				gfx.setColor(eolMarkerColor);
				gfx.drawString(""."",x,baseLine);
			}
			if(physicalLine == textArea.getCaretLine()
				&& textArea.isCaretVisible())
				paintCaret(gfx,physicalLine,y);
			if(buffer.isFoldStart(physicalLine)
				&& !buffer.isLineVisible(physicalLine + 1))
			{
				gfx.setColor(defaultColor);
				int start = textArea.getHorizontalOffset()
					+ fm.charWidth(' ') * buffer.getFoldLevel(physicalLine);
				gfx.drawLine(start,y + fm.getHeight() - 1,
					x - 1,y + fm.getHeight() - 1);
			}
		}
		return x;
	}
	private void paintHighlight(Graphics gfx, int virtualLine,
		int physicalLine, int y, boolean valid)
	{
		if(valid)
		{
			if(textArea.selection.size() == 0)
			{
				if(lineHighlight && physicalLine == textArea.getCaretLine())
				{
					gfx.setColor(lineHighlightColor);
					gfx.fillRect(0,y,getWidth(),fm.getHeight());
				}
			}
			else
			{
				gfx.setColor(selectionColor);
				for(int i = textArea.selection.size() - 1;
					i >= 0; i--)
				{
					paintSelection(gfx,physicalLine,y,
						(Selection)textArea.selection
						.elementAt(i));
				}
			}
			if(bracketHighlight
				&& physicalLine == textArea.getBracketLine()
				&& textArea.isHighlightVisible())
				paintBracketHighlight(gfx,physicalLine,y);
		}
		if(highlights != null)
		{
			highlights.paintHighlight(gfx,virtualLine,
				y - fm.getLeading() - fm.getDescent());
		}
	}
	private void paintBracketHighlight(Graphics gfx, int physicalLine, int y)
	{
		int position = textArea.getBracketPosition();
		if(position == -1)
			return;
		int x = textArea.offsetToX(physicalLine,position);
		gfx.setColor(bracketHighlightColor);
		// Hack!!! Since there is no fast way to get the character
		// from the bracket matching routine, we use ( since all
		// brackets probably have the same width anyway
		gfx.drawRect(x,y,fm.charWidth('(') - 1,
			fm.getHeight() - 1);
	}
	private void paintCaret(Graphics gfx, int physicalLine, int y)
	{
		int offset = textArea.getCaretPosition()
			- textArea.getLineStartOffset(physicalLine);
		int caretX = textArea.offsetToX(physicalLine,offset);
		int height = fm.getHeight();
		gfx.setColor(caretColor);
		if(textArea.isOverwriteEnabled())
		{
			gfx.drawLine(caretX,y + height - 1,
				caretX + fm.charWidth('w'),y + height - 1);
		}
		else if(blockCaret)
		{
			if(textArea.selection == null && lineHighlight)
				gfx.setXORMode(lineHighlightColor);
			else
				gfx.setXORMode(getBackground());
			gfx.fillRect(caretX,y,fm.charWidth('w'),height);
			gfx.setPaintMode();
		}
		else
		{
			gfx.drawLine(caretX,y,caretX,y + height - 1);
		}
	}
	private void paintSelection(Graphics gfx, int physicalLine, int y,
		Selection s)
	{
		if(physicalLine < s.startLine || physicalLine > s.endLine)
			return;
		int lineStart = textArea.getLineStartOffset(physicalLine);
		int x1, x2;
		if(s instanceof Selection.Rect)
		{
			int lineLen = textArea.getLineLength(physicalLine);
			x1 = textArea.offsetToX(physicalLine,Math.min(lineLen,
				s.start - textArea.getLineStartOffset(
				s.startLine)));
			x2 = textArea.offsetToX(physicalLine,Math.min(lineLen,
				s.end - textArea.getLineStartOffset(
				s.endLine)));
			if(x1 > x2)
			{
				int tmp = x2;
				x2 = x1;
				x1 = tmp;
			}
		}
		else if(s.startLine == s.endLine)
		{
			x1 = textArea.offsetToX(physicalLine,
				s.start - lineStart);
			x2 = textArea.offsetToX(physicalLine,
				s.end - lineStart);
		}
		else if(physicalLine == s.startLine)
		{
			x1 = textArea.offsetToX(physicalLine,
				s.start - lineStart);
			x2 = getWidth();
		}
		else if(physicalLine == s.endLine)
		{
			x1 = 0;
			x2 = textArea.offsetToX(physicalLine,
				s.end - lineStart);
		}
		else
		{
			x1 = 0;
			x2 = getWidth();
		}
		if(x1 == x2)
			x2++;
		gfx.fillRect(x1,y,x2 - x1,fm.getHeight());
	}
}
"
org.gjt.sp.jedit.textarea.TextRenderer,"/*
 * TextRenderer.java - Abstract differences between AWT and Java 2D
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
import javax.swing.text.TabExpander;
import java.awt.*;
import org.gjt.sp.util.Log;
/**
 * Java 1.1 and Java 2 have different APIs for drawing and measuring text.
 * Using the Java 1.1 API in Java 2 can result in incorrect caret placement,
 * etc. So we abstract away the differences with this class.
 */
public abstract class TextRenderer
{
	static final String JAVA2D_RENDER_CLASS = ""org.gjt.sp.jedit.textarea.TextRenderer2D"";
	public static TextRenderer createTextRenderer()
	{
		if(java2d)
		{
			try
			{
				ClassLoader loader = TextRenderer.class
					.getClassLoader();
				Class clazz;
				if(loader == null)
					clazz = Class.forName(JAVA2D_RENDER_CLASS);
				else
					clazz = loader.loadClass(JAVA2D_RENDER_CLASS);
				return (TextRenderer)clazz.newInstance();
			}
			catch(Exception e)
			{
				throw new NoClassDefFoundError(JAVA2D_RENDER_CLASS);
			}
		}
		else
			return new TextRendererAWT();
	}
	public static TextRenderer createPrintTextRenderer()
	{
		return new TextRendererAWT();
	}
	public void setupGraphics(Graphics g) {}
	public void configure(boolean antiAlias, boolean fracFontMetrics) {}
	public float drawChars(char[] text, int off, int len, Graphics g,
		float x, float y, TabExpander e, Color foreground,
		Color tokenBackground, Color componentBackground)
	{
		// this probably should be moved elsewhere
		if(tokenBackground != null)
		{
			float width = charsWidth(text,off,len,g.getFont(),x,e);
			FontMetrics fm = g.getFontMetrics();
			float height = fm.getHeight();
			float descent = fm.getDescent();
			float leading = fm.getLeading();
			g.setXORMode(componentBackground);
			g.setColor(tokenBackground);
			g.fillRect((int)x,(int)(y - height + descent + leading),
				(int)width,(int)height);
			g.setPaintMode();
		}
		g.setColor(foreground);
		int flushLen = 0;
		int flushIndex = off;
		int end = off + len;
		for(int i = off; i < end; i++)
		{
			if(text[i] == '\t')
			{
				if(flushLen > 0)
				{
					x += _drawChars(text,flushIndex,
						flushLen,g,x,y);
					flushLen = 0;
				}
				flushIndex = i + 1;
				x = e.nextTabStop(x,i - off);
			}
			else
				flushLen++;
		}
		if(flushLen > 0)
			x += _drawChars(text,flushIndex,flushLen,g,x,y);
		return x;
	}
	public float charsWidth(char[] text, int off, int len, Font font, float x,
		TabExpander e)
	{
		float newX = x;
		int flushLen = 0;
		int flushIndex = off;
		int end = off + len;
		for(int i = off; i < end; i++)
		{
			if(text[i] == '\t')
			{
				if(flushLen > 0)
				{
					newX += _getWidth(text,flushIndex,flushLen,font);
					flushLen = 0;
				}
				flushIndex = i + 1;
				newX = e.nextTabStop(newX,i - off);
			}
			else
				flushLen++;
		}
		if(flushLen > 0)
			newX += _getWidth(text,flushIndex,flushLen,font);
		return newX - x;
	}
	public int xToOffset(char[] text, int off, int len, Font font, float x,
		TabExpander e, boolean round, float[] widthArray)
	{
		int flushLen = 0;
		int flushIndex = off;
		int end = off + len;
		float width = widthArray[0];
		for(int i = off; i < end; i++)
		{
			if(text[i] == '\t')
			{
				if(flushLen > 0)
				{
					float newWidth = _getWidth(text,flushIndex,
						flushLen,font);
					if(x <= width + newWidth)
					{
						return _xToOffset(text,flushIndex,
							flushLen,font,x - width,
							round) + flushIndex;
					}
					else
						width += newWidth;
					flushLen = 0;
				}
				flushIndex = i + 1;
				float newWidth = e.nextTabStop(width,i - off) - width;
				if(x <= width + newWidth)
				{
					if(round && (x - width) < (width + newWidth - x))
						return i;
					else
						return i + 1;
				}
				else
					width += newWidth;
			}
			else
				flushLen++;
		}
		if(flushLen > 0)
		{
			float newWidth = _getWidth(text,flushIndex,flushLen,font);
			if(x <= width + newWidth)
			{
				return _xToOffset(text,flushIndex,flushLen,font,
					x - width,round) + flushIndex;
			}
			else
				width += newWidth;
		}
		widthArray[0] = width;
		return -1;
	}
	abstract float _drawChars(char[] text, int start, int len, Graphics g,
		float x, float y);
	abstract float _getWidth(char[] text, int start, int len, Font font);
	abstract int _xToOffset(char[] text, int start, int len, Font font,
		float x, boolean round);
	static boolean java2d;
	static
	{
		try
		{
			ClassLoader loader = TextRenderer.class.getClassLoader();
			if(loader == null)
				Class.forName(""java.awt.Graphics2D"");
			else
				loader.loadClass(""java.awt.Graphics2D"");
			Log.log(Log.DEBUG,TextRenderer.class,
				""Java2D detected; will use new text rendering code"");
			java2d = true;
		}
		catch(ClassNotFoundException cnf)
		{
			Log.log(Log.DEBUG,TextRenderer.class,
				""Java2D not detected; will use old text rendering code"");
			java2d = false;
		}
	}
}
"
org.gjt.sp.jedit.textarea.TextRenderer2D,"/*
 * TextRenderer2D.java - Uses new Java2D methods to draw text
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
// this is the only file in the jEdit source that will not compile with
// Java 1.1.
import java.awt.font.*;
import java.awt.*;
import java.util.Hashtable;
class TextRenderer2D extends TextRenderer
{
	public void setupGraphics(Graphics g)
	{
		((Graphics2D)g).setRenderingHints(renderingHints);
	}
	public void configure(boolean antiAlias, boolean fracFontMetrics)
	{
		Hashtable hints = new Hashtable();
		if(antiAlias)
		{
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
			hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
			hints.put(RenderingHints.KEY_FRACTIONALMETRICS,
				fracFontMetrics ?
					RenderingHints.VALUE_FRACTIONALMETRICS_ON
					: RenderingHints.VALUE_FRACTIONALMETRICS_OFF);
		}
		else
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
		renderingHints = new RenderingHints(hints);
		fontRenderContext = new FontRenderContext(null,antiAlias,
			fracFontMetrics);
	}
	float _drawChars(char[] text, int start, int len, Graphics _g,
		float x, float y)
	{
		Graphics2D g = (Graphics2D)_g;
		Font font = g.getFont();
		// update it just in case
		fontRenderContext = g.getFontRenderContext();
		GlyphVector glyphs = font.createGlyphVector(fontRenderContext,
			new String(text,start,len));
		((Graphics2D)g).drawGlyphVector(glyphs,x,y);
		return (float)glyphs.getLogicalBounds().getWidth();
	}
	float _getWidth(char[] text, int start, int len, Font font)
	{
		GlyphVector glyphs = font.createGlyphVector(fontRenderContext,
			new String(text,start,len));
		return (float)glyphs.getLogicalBounds().getWidth();
	}
	int _xToOffset(char[] text, int start, int len, Font font, float x,
		boolean round)
	{
		// this is slow!
		TextLayout layout = new TextLayout(new String(text,start,len),font,
			fontRenderContext);
		TextHitInfo info = layout.hitTestChar(x,0);
		return (round ? info.getInsertionIndex() : info.getCharIndex());
	}
	// private members
	private RenderingHints renderingHints;
	private FontRenderContext fontRenderContext;
}
"
org.gjt.sp.jedit.textarea.TextRendererAWT,"/*
 * TextRendererAWT.java - Uses old AWT methods to draw text
 * Copyright (C) 2001 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.jedit.textarea;
import java.awt.*;
class TextRendererAWT extends TextRenderer
{
	float _drawChars(char[] text, int start, int len, Graphics g,
		float x, float y)
	{
		g.drawChars(text,start,len,(int)x,(int)y);
		return (float)g.getFontMetrics().charsWidth(text,start,len);
	}
	float _getWidth(char[] text, int start, int len, Font font)
	{
		return (float)Toolkit.getDefaultToolkit()
			.getFontMetrics(font).charsWidth(text,start,len);
	}
	int _xToOffset(char[] text, int start, int len, Font font, float x,
		boolean round)
	{
		int end = start + len;
		FontMetrics fm = Toolkit.getDefaultToolkit()
			.getFontMetrics(font);
		int width = 0;
		for(int i = start; i < end; i++)
		{
			int newWidth = fm.charWidth(text[i]);
			if(x <= width + newWidth)
			{
				if(round && (x - width) < (width + newWidth - x))
					return i - start;
				else
					return i + 1 - start;
			}
			else
				width += newWidth;
		}
		return -1;
	}
}
"
org.gjt.sp.util.Log,"/*
 * Log.java - A class for logging events
 * Copyright (C) 1999, 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
import javax.swing.text.*;
import java.io.*;
import java.util.StringTokenizer;
/**
 * This class provides methods for logging events. It has the same
 * purpose as System.out.println() and such, but more powerful.
 * All events are logged to a Swing document and optionally a stream,
 * and those with a high urgency (warnings and errors) are also printed
 * to the standard error stream. This class can also optionally redirect
 * standard output and error to the log.
 * @author Slava Pestov
 * @version $Id: Log.java,v 1.14 2001/07/04 06:42:46 sp Exp $
 */
public class Log
{
	/**
	 * The maximum number of log messages that will be kept in memory.
	 * @since jEdit 2.6pre5
	 */
	public static final int MAXLINES = 500;
	/**
	 * Debugging message urgency. Should be used for messages only
	 * useful when debugging a problem.
	 * @since jEdit 2.2pre2
	 */
	public static final int DEBUG = 1;
	/**
	 * Message urgency. Should be used for messages which give more
	 * detail than notices.
	 * @since jEdit 2.2pre2
	 */
	public static final int MESSAGE = 3;
	/**
	 * Notice urgency. Should be used for messages that directly
	 * affect the user.
	 * @since jEdit 2.2pre2
	 */
	public static final int NOTICE = 5;
	/**
	 * Warning urgency. Should be used for messages that warrant
	 * attention.
	 * @since jEdit 2.2pre2
	 */
	public static final int WARNING = 7;
	/**
	 * Error urgency. Should be used for messages that signal a
	 * failure.
	 * @since jEdit 2.2pre2
	 */
	public static final int ERROR = 9;
	/**
	 * Initializes the log.
	 * @param stdio If true, standard output and error will be
	 * sent to the log
	 * @param level Messages with this log level or higher will
	 * be printed to the system console
	 * @param stream The stream to save log data to
	 * @since jEdit 3.2pre4
	 */
	public static void init(boolean stdio, int level)
	{
		if(stdio)
		{
			if(System.out == realOut && System.err == realErr)
			{
				System.setOut(createPrintStream(NOTICE,null));
				System.setErr(createPrintStream(ERROR,null));
			}
		}
		Log.level = level;
		Log.stream = stream;
		// Log some stuff
		log(MESSAGE,Log.class,""When reporting bugs, please""
			+ "" include the following information:"");
		String[] props = {
			""java.version"", ""java.vendor"",
			""java.compiler"", ""os.name"", ""os.version"",
			""os.arch"", ""user.home"", ""java.class.path"",
			};
		for(int i = 0; i < props.length; i++)
		{
			log(MESSAGE,Log.class,
				props[i] + ""="" + System.getProperty(props[i]));
		}
	}
	/**
	 * Writes all currently logged messages to this stream if there was no
	 * stream set previously, and sets the stream to write future log
	 * messages to.
	 * @param stream The writer
	 * @since jEdit 3.2pre4
	 */
	public static void setLogWriter(Writer stream)
	{
		if(Log.stream == null && stream != null)
		{
			try
			{
				stream.write(logDocument.getText(0,
					logDocument.getLength()));
				stream.flush();
			}
			catch(Exception e)
			{
				// do nothing, who cares
			}
		}
		Log.stream = stream;
	}
	/**
	 * Returns the document where the most recent messages are stored.
	 * The document of a Swing text area can be set to this to graphically
	 * view log messages.
	 * @since jEdit 2.2pre2
	 */
	public static Document getLogDocument()
	{
		return logDocument;
	}
	/**
	 * Flushes the log stream.
	 * @since jEdit 2.6pre5
	 */
	public static void flushStream()
	{
		if(stream != null)
		{
			try
			{
				stream.flush();
			}
			catch(IOException io)
			{
				io.printStackTrace(realErr);
			}
		}
	}
	/**
	 * Closes the log stream. Should be done before your program exits.
	 * @since jEdit 2.6pre5
	 */
	public static void closeStream()
	{
		if(stream != null)
		{
			try
			{
				stream.close();
				stream = null;
			}
			catch(IOException io)
			{
				io.printStackTrace(realErr);
			}
		}
	}
	/**
	 * Logs a message. This method is threadsafe.
	 * @param urgency The urgency
	 * @param source The object that logged this message.
	 * @param message The message. This can either be a string or
	 * an exception
	 *
	 * @since jEdit 2.2pre2
	 */
	public static void log(int urgency, Object source, Object message)
	{
		String _source;
		if(source == null)
		{
			_source = Thread.currentThread().getName();
			if(_source == null)
			{
				_source = Thread.currentThread().getClass().getName();
			}
		}
		else if(source instanceof Class)
			_source = ((Class)source).getName();
		else
			_source = source.getClass().getName();
		int index = _source.lastIndexOf('.');
		if(index != -1)
			_source = _source.substring(index+1);
		if(message instanceof Throwable)
		{
			_logException(urgency,source,(Throwable)message);
		}
		else
		{
			String _message = String.valueOf(message);
			// If multiple threads log stuff, we don't want
			// the output to get mixed up
			synchronized(LOCK)
			{
				StringTokenizer st = new StringTokenizer(
					_message,""\r\n"");
				while(st.hasMoreTokens())
				{
					_log(urgency,_source,st.nextToken());
				}
			}
		}
	}
	// private members
	private static Object LOCK = new Object();
	private static Document logDocument;
	private static int level;
	private static Writer stream;
	private static String lineSep;
	private static PrintStream realOut;
	private static PrintStream realErr;
	static
	{
		level = WARNING;
		realOut = System.out;
		realErr = System.err;
		logDocument = new PlainDocument();
		lineSep = System.getProperty(""line.separator"");
	}
	private static PrintStream createPrintStream(final int urgency,
		final Object source)
	{
		return new PrintStream(new OutputStream() {
			public void write(int b)
			{
				byte[] barray = { (byte)b };
				write(barray,0,1);
			}
			public void write(byte[] b, int off, int len)
			{
				String str = new String(b,off,len);
				log(urgency,source,str);
			}
		});
	}
	private static void _logException(final int urgency,
		final Object source,
		final Throwable message)
	{
		PrintStream out = createPrintStream(urgency,source);
		synchronized(LOCK)
		{
			message.printStackTrace(out);
		}
	}
	private static void _log(int urgency, String source, String message)
	{
		String urgencyString = ""["" + urgencyToString(urgency) + ""] "";
		String fullMessage = urgencyString + source + "": "" + message;
		try
		{
			logDocument.insertString(logDocument.getLength(),
				fullMessage,null);
			logDocument.insertString(logDocument.getLength(),
				""\n"",null);
			Element map = logDocument.getDefaultRootElement();
			int lines = map.getElementCount();
			if(lines > MAXLINES)
			{
				Element first = map.getElement(0);
				Element last = map.getElement(lines - MAXLINES);
				logDocument.remove(first.getStartOffset(),
					last.getEndOffset());
			}
			if(stream != null)
			{
				stream.write(fullMessage);
				stream.write(lineSep);
			}
		}
		catch(Exception e)
		{
			e.printStackTrace(realErr);
		}
		message = urgencyString +  message + '\n';
		if(urgency >= level)
		{
			if(urgency == ERROR)
				realErr.print(message);
			else
				realOut.print(message);
		}
	}
	private static String urgencyToString(int urgency)
	{
		switch(urgency)
		{
		case DEBUG:
			return ""debug"";
		case MESSAGE:
			return ""message"";
		case NOTICE:
			return ""notice"";
		case WARNING:
			return ""warning"";
		case ERROR:
			return ""error"";
		}
		throw new IllegalArgumentException(""Invalid urgency: "" + urgency);
	}
}
"
org.gjt.sp.util.WorkRequest,"/*
 * WorkRequest.java - Runnable subclass
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
/**
 * A subclass of the Runnable interface.
 * @since jEdit 2.6pre1
 */
public abstract class WorkRequest implements Runnable
{
	/**
	 * Sets if the request can be aborted.
	 */
	public void setAbortable(boolean abortable)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setAbortable(abortable);
	}
	/**
	 * Sets the status text.
	 * @param status The status text
	 */
	public void setStatus(String status)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setStatus(status);
	}
	/**
	 * Sets the progress value.
	 * @param status The progress value.
	 */
	public void setProgressValue(int value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setProgressValue(value);
	}
	/**
	 * Sets the maximum progress value.
	 * @param status The progress value.
	 */
	public void setProgressMaximum(int value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setProgressMaximum(value);
	}
}
/*
 * ChangeLog:
 * $Log: WorkRequest.java,v $
 * Revision 1.4  2000/10/15 04:10:35  sp
 * bug fixes
 *
 * Revision 1.3  2000/07/26 07:48:46  sp
 * stuff
 *
 * Revision 1.2  2000/07/22 03:27:04  sp
 * threaded I/O improved, autosave rewrite started
 *
 */
"
org.gjt.sp.util.WorkThread,"/*
 * WorkThread.java - Background thread that does stuff
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
/**
 * Services work requests in the background.
 * @author Slava Pestov
 * @version $Id: WorkThread.java,v 1.18 2000/12/06 07:00:41 sp Exp $
 */
public class WorkThread extends Thread
{
	public WorkThread(WorkThreadPool pool, ThreadGroup group, String name)
	{
		super(group, name);
		setDaemon(true);
		setPriority(4);
		this.pool = pool;
	}
	/**
	 * Sets if the current request can be aborted.
	 * @since jEdit 2.6pre1
	 */
	public void setAbortable(boolean abortable)
	{
		synchronized(abortLock)
		{
			this.abortable = abortable;
			if(aborted)
				stop(new Abort());
		}
	}
	/**
	 * Returns if the work thread is currently running a request.
	 */
	public boolean isRequestRunning()
	{
		return requestRunning;
	}
	/**
	 * Returns the status text.
	 */
	public String getStatus()
	{
		return status;
	}
	/**
	 * Sets the status text.
	 * @since jEdit 2.6pre1
	 */
	public void setStatus(String status)
	{
		this.status = status;
		pool.fireProgressChanged(this);
	}
	/**
	 * Returns the progress value.
	 */
	public int getProgressValue()
	{
		return progressValue;
	}
	/**
	 * Sets the progress value.
	 * @since jEdit 2.6pre1
	 */
	public void setProgressValue(int progressValue)
	{
		this.progressValue = progressValue;
		pool.fireProgressChanged(this);
	}
	/**
	 * Returns the progress maximum.
	 */
	public int getProgressMaximum()
	{
		return progressMaximum;
	}
	/**
	 * Sets the maximum progress value.
	 * @since jEdit 2.6pre1
	 */
	public void setProgressMaximum(int progressMaximum)
	{
		this.progressMaximum = progressMaximum;
		pool.fireProgressChanged(this);
	}
	/**
	 * Aborts the currently running request, if allowed.
	 * @since jEdit 2.6pre1
	 */
	public void abortCurrentRequest()
	{
		synchronized(abortLock)
		{
			if(abortable && !aborted)
				stop(new Abort());
			aborted = true;
		}
	}
	public void run()
	{
		Log.log(Log.DEBUG,this,""Work request thread starting ["" + getName() + ""]"");
		for(;;)
		{
			doRequests();
		}
	}
	// private members
	private WorkThreadPool pool;
	private Object abortLock = new Object();
	private boolean requestRunning;
	private boolean abortable;
	private boolean aborted;
	private String status;
	private int progressValue;
	private int progressMaximum;
	private void doRequests()
	{
		WorkThreadPool.Request request;
		for(;;)
		{
			request = pool.getNextRequest();
			if(request == null)
				break;
			else
			{
				requestRunning = true;
				pool.fireProgressChanged(this);
				doRequest(request);
				requestRunning = false;
				pool.fireProgressChanged(this);
			}
		}
		synchronized(pool.waitForAllLock)
		{
			// notify a running waitForRequests() method
			pool.waitForAllLock.notifyAll();
		}
		synchronized(pool.lock)
		{
			// wait for more requests
			try
			{
				pool.lock.wait();
			}
			catch(InterruptedException ie)
			{
				Log.log(Log.ERROR,this,ie);
			}
		}
	}
	private void doRequest(WorkThreadPool.Request request)
	{
// 		Log.log(Log.DEBUG,WorkThread.class,""Running in work thread: "" + request);
		try
		{
			request.run.run();
		}
		catch(Abort a)
		{
			Log.log(Log.ERROR,WorkThread.class,""Unhandled abort"");
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,WorkThread.class,""Exception ""
				+ ""in work thread:"");
			Log.log(Log.ERROR,WorkThread.class,t);
		}
		finally
		{
			synchronized(abortLock)
			{
				aborted = abortable = false;
			}
			status = null;
			progressValue = progressMaximum = 0;
			pool.requestDone();
			pool.fireProgressChanged(this);
		}
	}
	public static class Abort extends Error
	{
		public Abort()
		{
			super(""Work request aborted"");
		}
	}
}
"
org.gjt.sp.util.WorkThreadPool,"/*
 * WorkThread.java - Background thread that does stuff
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
import javax.swing.event.EventListenerList;
import javax.swing.SwingUtilities;
/**
 * A pool of work threads.
 * @author Slava Pestov
 * @version $Id: WorkThreadPool.java,v 1.10 2000/12/06 07:00:41 sp Exp $
 * @see org.gjt.sp.util.WorkThread
 * @since jEdit 2.6pre1
 */
public class WorkThreadPool
{
	/**
	 * Creates a new work thread pool with the specified number of
	 * work threads.
	 * @param name The thread name prefix
	 * @param count The number of work threads
	 */
	public WorkThreadPool(String name, int count)
	{
		listenerList = new EventListenerList();
		if(count != 0)
		{
			threadGroup = new ThreadGroup(name);
			threads = new WorkThread[count];
			for(int i = 0; i < threads.length; i++)
			{
				threads[i] = new WorkThread(this,threadGroup,name + "" #"" + (i+1));
			}
		}
		else
			Log.log(Log.WARNING,this,""Async I/O disabled"");
	}
	/**
	 * Starts all the threads in this thread pool.
	 */
	public void start()
	{
		if(threads != null)
		{
			for(int i = 0; i < threads.length; i++)
			{
				threads[i].start();
			}
		}
	}
	/**
	 * Adds a work request to the queue.
	 * @param run The runnable
	 * @param inAWT If true, will be executed in AWT thread. Otherwise,
	 * will be executed in work thread
	 */
	public void addWorkRequest(Runnable run, boolean inAWT)
	{
		if(threads == null)
		{
			run.run();
			return;
		}
		// if inAWT is set and there are no requests
		// pending, execute it immediately
		if(inAWT && requestCount == 0 && awtRequestCount == 0)
		{
// 			Log.log(Log.DEBUG,this,""AWT immediate: "" + run);
			if(SwingUtilities.isEventDispatchThread())
				run.run();
			else
				SwingUtilities.invokeLater(run);
			return;
		}
		Request request = new Request(run);
		synchronized(lock)
		{
			if(inAWT)
			{
				if(firstAWTRequest == null && lastAWTRequest == null)
					firstAWTRequest = lastAWTRequest = request;
				else
				{
					lastAWTRequest.next = request;
					lastAWTRequest = request;
				}
				awtRequestCount++;
				// if no requests are running, requestDone()
				// will not be called, so we must queue the
				// AWT runner ourselves.
				if(requestCount == 0)
					queueAWTRunner();
			}
			else
			{
				if(firstRequest == null && lastRequest == null)
					firstRequest = lastRequest = request;
				else
				{
					lastRequest.next = request;
					lastRequest = request;
				}
				requestCount++;
			}
			lock.notify();
		}
	}
	/**
	 * Waits until all requests are complete.
	 */
	public void waitForRequests()
	{
		if(threads == null)
			return;
		synchronized(waitForAllLock)
		{
			while(requestCount != 0)
			{
				try
				{
					waitForAllLock.wait();
				}
				catch(InterruptedException ie)
				{
					Log.log(Log.ERROR,this,ie);
				}
			}
		}
		if(SwingUtilities.isEventDispatchThread())
		{
			// do any queued AWT runnables
			doAWTRequests();
		}
		else
		{
			try
			{
				SwingUtilities.invokeAndWait(new RunRequestsInAWTThread());
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}
		}
	}
	/**
	 * Returns the number of pending requests.
	 */
	public int getRequestCount()
	{
		return requestCount;
	}
	/**
	 * Returns the number of threads in this pool.
	 */
	public int getThreadCount()
	{
		if(threads == null)
			return 0;
		else
			return threads.length;
	}
	/**
	 * Returns the specified thread.
	 * @param index The index of the thread
	 */
	public WorkThread getThread(int index)
	{
		return threads[index];
	}
	/**
	 * Adds a progress listener to this thread pool.
	 * @param listener The listener
	 */
	public final void addProgressListener(WorkThreadProgressListener listener)
	{
		listenerList.add(WorkThreadProgressListener.class,listener);
	}
	/**
	 * Removes a progress listener from this thread pool.
	 * @param listener The listener
	 */
	public final void removeProgressListener(WorkThreadProgressListener listener)
	{
		listenerList.remove(WorkThreadProgressListener.class,listener);
	}
	// package-private members
	Object lock = new String(""Work thread pool request queue lock"");
	Object waitForAllLock = new String(""Work thread pool waitForAll() notifier"");
	void fireProgressChanged(WorkThread thread)
	{
		final Object[] listeners = listenerList.getListenerList();
		if(listeners.length != 0)
		{
			int index = 0;
			for(int i = 0; i < threads.length; i++)
			{
				if(threads[i] == thread)
				{
					index = i;
					break;
				}
			}
			final int _index = index;
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					for(int i = listeners.length - 2; i >= 0; i--)
					{
						if(listeners[i] == WorkThreadProgressListener.class)
						{
							((WorkThreadProgressListener)listeners[i+1])
								.progressUpdate(WorkThreadPool.this,_index);
						}
					}
				}
			});
		}
	}
	void requestDone()
	{
		synchronized(lock)
		{
			requestCount--;
			if(requestCount == 0 && firstAWTRequest != null)
				queueAWTRunner();
		}
	}
	Request getNextRequest()
	{
		synchronized(lock)
		{
			Request request = firstRequest;
			if(request == null)
				return null;
			firstRequest = firstRequest.next;
			if(firstRequest == null)
				lastRequest = null;
			if(request.alreadyRun)
				throw new InternalError(""AIEE!!! Request run twice!!! "" + request.run);
			request.alreadyRun = true;
			/* StringBuffer buf = new StringBuffer(""request queue is now: "");
			Request _request = request.next;
			while(_request != null)
			{
				buf.append(_request.id);
				if(_request.next != null)
					buf.append("","");
				_request = _request.next;
			}
			Log.log(Log.DEBUG,this,buf.toString()); */
			return request;
		}
	}
	// private members
	private ThreadGroup threadGroup;
	private WorkThread[] threads;
	// Request queue
	private Request firstRequest;
	private Request lastRequest;
	private int requestCount;
	// AWT thread magic
	private boolean awtRunnerQueued;
	private Request firstAWTRequest;
	private Request lastAWTRequest;
	private int awtRequestCount;
	private EventListenerList listenerList;
	private void doAWTRequests()
	{
		while(firstAWTRequest != null)
		{
			doAWTRequest(getNextAWTRequest());
		}
	}
	private void doAWTRequest(Request request)
	{
//		Log.log(Log.DEBUG,this,""Running in AWT thread: "" + request);
		try
		{
			request.run.run();
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,WorkThread.class,""Exception ""
				+ ""in AWT thread:"");
			Log.log(Log.ERROR,WorkThread.class,t);
		}
		awtRequestCount--;
	}
	private void queueAWTRunner()
	{
		if(!awtRunnerQueued)
		{
			awtRunnerQueued = true;
			SwingUtilities.invokeLater(new RunRequestsInAWTThread());
			//Log.log(Log.DEBUG,this,""AWT runner queued"");
		}
	}
	private Request getNextAWTRequest()
	{
		synchronized(lock)
		{
			Request request = firstAWTRequest;
			firstAWTRequest = firstAWTRequest.next;
			if(firstAWTRequest == null)
				lastAWTRequest = null;
			if(request.alreadyRun)
				throw new InternalError(""AIEE!!! Request run twice!!! "" + request.run);
			request.alreadyRun = true;
			/* StringBuffer buf = new StringBuffer(""AWT request queue is now: "");
			Request _request = request.next;
			while(_request != null)
			{
				buf.append(_request.id);
				if(_request.next != null)
					buf.append("","");
				_request = _request.next;
			}
			Log.log(Log.DEBUG,this,buf.toString()); */
			return request;
		}
	}
	static int ID;
	static class Request
	{
		int id = ++ID;
		Runnable run;
		boolean alreadyRun;
		Request next;
		Request(Runnable run)
		{
			this.run = run;
		}
		public String toString()
		{
			return ""[id="" + id + "",run="" + run + ""]"";
		}
	}
	class RunRequestsInAWTThread implements Runnable
	{
		public void run()
		{
			awtRunnerQueued = false;
			doAWTRequests();
		}
	}
}
/*
 * ChangeLog:
 * $Log: WorkThreadPool.java,v $
 * Revision 1.10  2000/12/06 07:00:41  sp
 * Lotsa bug fixes
 *
 * Revision 1.9  2000/11/21 02:58:04  sp
 * 2.7pre2 finished
 *
 * Revision 1.8  2000/10/15 04:10:35  sp
 * bug fixes
 *
 * Revision 1.7  2000/08/27 02:06:52  sp
 * Filter combo box changed to a text field in VFS browser, passive mode FTP toggle
 *
 * Revision 1.6  2000/08/22 07:25:01  sp
 * Improved abbrevs, bug fixes
 *
 * Revision 1.5  2000/07/26 07:48:46  sp
 * stuff
 *
 * Revision 1.4  2000/07/22 12:37:39  sp
 * WorkThreadPool bug fix, IORequest.load() bug fix, version wound back to 2.6
 *
 * Revision 1.3  2000/07/22 06:22:27  sp
 * I/O progress monitor done
 *
 * Revision 1.2  2000/07/22 03:27:04  sp
 * threaded I/O improved, autosave rewrite started
 *
 * Revision 1.1  2000/07/21 10:23:49  sp
 * Multiple work threads
 *
 */
"
org.gjt.sp.util.WorkThreadProgressListener,"/*
 * WorkThreadProgressListener.java - Progress listener
 * Copyright (C) 2000 Slava Pestov
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.gjt.sp.util;
import java.util.EventListener;
/**
 * A work thread execution progress listener.
 * @since jEdit 2.6pre1
 */
public interface WorkThreadProgressListener extends EventListener
{
	void progressUpdate(WorkThreadPool threadPool, int threadIndex);
}
"
