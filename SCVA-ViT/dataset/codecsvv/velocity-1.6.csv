metric_name,file
org.apache.velocity.Template,"package org.apache.velocity;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.util.List;
import org.apache.velocity.context.Context;
import org.apache.velocity.context.InternalContextAdapterImpl;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.runtime.resource.ResourceManager;
/**
 * This class is used for controlling all template
 * operations. This class uses a parser created
 * by JavaCC to create an AST that is subsequently
 * traversed by a Visitor.
 *
 * <pre>
 * // set up and initialize Velocity before this code block
 *
 * Template template = Velocity.getTemplate(""test.wm"");
 * Context context = new VelocityContext();
 *
 * context.put(""foo"", ""bar"");
 * context.put(""customer"", new Customer());
 *
 * template.merge(context, writer);
 * </pre>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: Template.java 685724 2008-08-13 23:12:12Z nbubna $
 */
public class Template extends Resource
{
    private VelocityException errorCondition = null;
    /** Default constructor */
    public Template()
    {
        super();
        setType(ResourceManager.RESOURCE_TEMPLATE);
    }
    /**
     *  gets the named resource as a stream, parses and inits
     *
     * @return true if successful
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws IOException problem reading input stream
     */
    public boolean process()
        throws ResourceNotFoundException, ParseErrorException, IOException
    {
        data = null;
        InputStream is = null;
        errorCondition = null;
        /*
         *  first, try to get the stream from the loader
         */
        try
        {
            is = resourceLoader.getResourceStream(name);
        }
        catch( ResourceNotFoundException rnfe )
        {
            /*
             *  remember and re-throw
             */
            errorCondition = rnfe;
            throw rnfe;
        }
        /*
         *  if that worked, lets protect in case a loader impl
         *  forgets to throw a proper exception
         */
        if (is != null)
        {
            /*
             *  now parse the template
             */
            try
            {
                BufferedReader br = new BufferedReader( new InputStreamReader( is, encoding ) );
                data = rsvc.parse( br, name);
                initDocument();
                return true;
            }
            catch( UnsupportedEncodingException  uce )
            {
                String msg = ""Template.process : Unsupported input encoding : "" + encoding
                + "" for template "" + name;
                errorCondition  = new ParseErrorException( msg );
                throw errorCondition;
            }
            catch ( ParseException pex )
            {
                /*
                 *  remember the error and convert
                 */
                errorCondition =  new ParseErrorException( pex );
                throw errorCondition;
            }
            catch ( TemplateInitException pex )
            {
                errorCondition = new ParseErrorException( pex );
                throw errorCondition;
            }
            /**
             * pass through runtime exceptions
             */
            catch( RuntimeException e )
            {
                throw new RuntimeException(""Exception thrown processing Template ""+getName(), e);
            }
            finally
            {
                /*
                 *  Make sure to close the inputstream when we are done.
                 */
                is.close();
            }
        }
        else
        {
            /*
             *  is == null, therefore we have some kind of file issue
             */
            errorCondition = new ResourceNotFoundException(""Unknown resource error for resource "" + name );
            throw errorCondition;
        }
    }
    /**
     *  initializes the document.  init() is not longer
     *  dependant upon context, but we need to let the
     *  init() carry the template name down throught for VM
     *  namespace features
     * @throws TemplateInitException When a problem occurs during the document initialization.
     */
    public void initDocument()
    throws TemplateInitException
    {
        /*
         *  send an empty InternalContextAdapter down into the AST to initialize it
         */
        InternalContextAdapterImpl ica = new InternalContextAdapterImpl(  new VelocityContext() );
        try
        {
            /*
             *  put the current template name on the stack
             */
            ica.pushCurrentTemplateName( name );
            ica.setCurrentResource( this );
            /*
             *  init the AST
             */
            ((SimpleNode)data).init( ica, rsvc);
        }
        finally
        {
            /*
             *  in case something blows up...
             *  pull it off for completeness
             */
            ica.popCurrentTemplateName();
            ica.setCurrentResource( null );
        }
    }
    /**
     * The AST node structure is merged with the
     * context to produce the final output.
     *
     *  @param context Conext with data elements accessed by template
     *  @param writer output writer for rendered template
     *  @throws ResourceNotFoundException if template not found
     *          from any available source.
     *  @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     *  @throws MethodInvocationException When a method on a referenced object in the context could not invoked.
     *  @throws IOException  Might be thrown while rendering.
     */
    public void merge( Context context, Writer writer)
        throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, IOException
    {
        merge(context, writer, null);
    }
    /**
     * The AST node structure is merged with the
     * context to produce the final output.
     *
     *  @param context Conext with data elements accessed by template
     *  @param writer output writer for rendered template
     *  @param macroLibraries a list of template files containing macros to be used when merging
     *  @throws ResourceNotFoundException if template not found
     *          from any available source.
     *  @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     *  @throws MethodInvocationException When a method on a referenced object in the context could not invoked.
     *  @throws IOException  Might be thrown while rendering.
     *  @since 1.6
     */
    public void merge( Context context, Writer writer, List macroLibraries)
        throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, IOException
    {
        /*
         *  we shouldn't have to do this, as if there is an error condition,
         *  the application code should never get a reference to the
         *  Template
         */
        if (errorCondition != null)
        {
            throw errorCondition;
        }
        if( data != null)
        {
            /*
             *  create an InternalContextAdapter to carry the user Context down
             *  into the rendering engine.  Set the template name and render()
             */
            InternalContextAdapterImpl ica = new InternalContextAdapterImpl( context );
            /**
             * Set the macro libraries
             */
            ica.setMacroLibraries(macroLibraries);
            if (macroLibraries != null)
            {
                for (int i = 0; i < macroLibraries.size(); i++)
                {
                    /**
                     * Build the macro library
                     */
                    try
                    {
                        rsvc.getTemplate((String) macroLibraries.get(i));
                    }
                    catch (ResourceNotFoundException re)
                    {
                        /*
                        * the macro lib wasn't found.  Note it and throw
                        */
                        rsvc.getLog().error(""template.merge(): "" +
                                ""cannot find template "" +
                                (String) macroLibraries.get(i));
                        throw re;
                    }
                    catch (ParseErrorException pe)
                    {
                        /*
                        * the macro lib was found, but didn't parse - syntax error
                        *  note it and throw
                        */
                        rsvc.getLog().error(""template.merge(): "" +
                                ""syntax error in template "" +
                                (String) macroLibraries.get(i) + ""."");
                        throw pe;
                    }
                    catch (Exception e)
                    {
                        throw new RuntimeException(""Template.merge(): parse failed in template  "" +
                                (String) macroLibraries.get(i) + ""."", e);
                    }
                }
            }
            try
            {
                ica.pushCurrentTemplateName( name );
                ica.setCurrentResource( this );
                ( (SimpleNode) data ).render( ica, writer);
            }
            finally
            {
                /*
                 *  lets make sure that we always clean up the context
                 */
                ica.popCurrentTemplateName();
                ica.setCurrentResource( null );
            }
        }
        else
        {
            /*
             * this shouldn't happen either, but just in case.
             */
            String msg = ""Template.merge() failure. The document is null, "" +
                ""most likely due to parsing error."";
            throw new RuntimeException(msg);
        }
    }
}
"
org.apache.velocity.VelocityContext,"package org.apache.velocity;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.HashMap;
import java.util.Map;
import org.apache.velocity.context.AbstractContext;
import org.apache.velocity.context.Context;
/**
 *  General purpose implemention of the application Context
 *  interface for general application use.  This class should
 *  be used in place of the original Context class.
 *
 *  This implementation uses a HashMap  (@see java.util.HashMap )
 *  for data storage.
 *
 *  This context implementation cannot be shared between threads
 *  without those threads synchronizing access between them, as
 *  the HashMap is not synchronized, nor are some of the fundamentals
 *  of AbstractContext.  If you need to share a Context between
 *  threads with simultaneous access for some reason, please create
 *  your own and extend the interface Context
 *
 *  @see org.apache.velocity.context.Context
 *
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 *  @author <a href=""mailto:fedor.karpelevitch@home.com"">Fedor Karpelevitch</a>
 *  @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 *  @version $Id: VelocityContext.java 463298 2006-10-12 16:10:32Z henning $
 */
public class VelocityContext extends AbstractContext implements Cloneable
{
    /**
     * Version Id for serializable
     */
    private static final long serialVersionUID = 9033846851064645037L;
    /**
     *  Storage for key/value pairs.
     */
    private Map context = null;
    /**
     *  Creates a new instance (with no inner context).
     */
    public VelocityContext()
    {
        this(null, null);
    }
    /**
     *  Creates a new instance with the provided storage (and no inner
     *  context).
     * @param context
     */
    public VelocityContext(Map context)
    {
        this(context, null);
    }
    /**
     *  Chaining constructor, used when you want to
     *  wrap a context in another.  The inner context
     *  will be 'read only' - put() calls to the
     *  wrapping context will only effect the outermost
     *  context
     *
     *  @param innerContext The <code>Context</code> implementation to
     *  wrap.
     */
    public VelocityContext( Context innerContext )
    {
        this(null, innerContext);
    }
    /**
     *  Initializes internal storage (never to <code>null</code>), and
     *  inner context.
     *
     *  @param context Internal storage, or <code>null</code> to
     *  create default storage.
     *  @param innerContext Inner context.
     */
    public VelocityContext(Map context, Context innerContext)
    {
        super(innerContext);
        this.context = (context == null ? new HashMap() : context);
    }
    /**
     *  retrieves value for key from internal
     *  storage
     *
     *  @param key name of value to get
     *  @return value as object
     */
    public Object internalGet( String key )
    {
        return context.get( key );
    }
    /**
     *  stores the value for key to internal
     *  storage
     *
     *  @param key name of value to store
     *  @param value value to store
     *  @return previous value of key as Object
     */
    public Object internalPut( String key, Object value )
    {
        return context.put( key, value );
    }
    /**
     *  determines if there is a value for the
     *  given key
     *
     *  @param key name of value to check
     *  @return true if non-null value in store
     */
    public  boolean internalContainsKey(Object key)
    {
        return context.containsKey( key );
    }
    /**
     *  returns array of keys
     *
     *  @return keys as []
     */
    public  Object[] internalGetKeys()
    {
        return context.keySet().toArray();
    }
    /**
     *  remove a key/value pair from the
     *  internal storage
     *
     *  @param key name of value to remove
     *  @return value removed
     */
    public  Object internalRemove(Object key)
    {
        return context.remove( key );
    }
    /**
     * Clones this context object.
     *
     * @return A deep copy of this <code>Context</code>.
     */
    public Object clone()
    {
        VelocityContext clone = null;
        try
        {
            clone = (VelocityContext) super.clone();
            clone.context = new HashMap(context);
        }
        catch (CloneNotSupportedException ignored)
        {
        }
        return clone;
    }
}
"
org.apache.velocity.anakia.AnakiaElement,"package org.apache.velocity.anakia;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import java.util.List;
/**
 * A JDOM {@link Element} that is tailored for Anakia needs. It has
 * {@link #selectNodes(String)} method as well as a {@link #toString()} that
 * outputs the XML serialized form of the element. This way it acts in much the
 * same way as a single-element {@link NodeList} would.
 *
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: AnakiaElement.java 463298 2006-10-12 16:10:32Z henning $
 */
public class AnakiaElement extends Element
{
    /**
     * Version Id for serializable
     */
    private static final long serialVersionUID = 8429597252274491314L;
    private static final XMLOutputter DEFAULT_OUTPUTTER = new XMLOutputter();
    static
    {
        DEFAULT_OUTPUTTER.getFormat().setLineSeparator(System.getProperty(""line.separator""));
    }
    /**
     * <p>
     * This will create a new <code>AnakiaElement</code>
     *   with the supplied (local) name, and define
     *   the <code>{@link Namespace}</code> to be used.
     * If the provided namespace is null, the element will have
     * no namespace.
     * </p>
     *
     * @param name <code>String</code> name of element.
     * @param namespace <code>Namespace</code> to put element in.
     */
    public AnakiaElement(String name, Namespace namespace)
    {
        super(name, namespace);
    }
    /**
     * <p>
     *  This will create an <code>AnakiaElement</code> in no
     *    <code>{@link Namespace}</code>.
     * </p>
     *
     * @param name <code>String</code> name of element.
     */
    public AnakiaElement(String name)
    {
        super(name);
    }
    /**
     * <p>
     *  This will create a new <code>AnakiaElement</code> with
     *    the supplied (local) name, and specifies the URI
     *    of the <code>{@link Namespace}</code> the <code>Element</code>
     *    should be in, resulting it being unprefixed (in the default
     *    namespace).
     * </p>
     *
     * @param name <code>String</code> name of element.
     * @param uri <code>String</code> URI for <code>Namespace</code> element
     *        should be in.
     */
    public AnakiaElement(String name, String uri)
    {
        super(name, uri);
    }
    /**
     * <p>
     *  This will create a new <code>AnakiaElement</code> with
     *    the supplied (local) name, and specifies the prefix and URI
     *    of the <code>{@link Namespace}</code> the <code>Element</code>
     *    should be in.
     * </p>
     *
     * @param name <code>String</code> name of element.
     * @param prefix The prefix of the element.
     * @param uri <code>String</code> URI for <code>Namespace</code> element
     *        should be in.
     */
    public AnakiaElement(String name, String prefix, String uri)
    {
        super(name, prefix, uri);
    }
    /**
     * Applies an XPath expression to this element and returns the resulting
     * node list. In order for this method to work, your application must have
     * access to <a href=""http://code.werken.com"">werken.xpath</a> library
     * classes. The implementation does cache the parsed format of XPath
     * expressions in a weak hash map, keyed by the string representation of
     * the XPath expression. As the string object passed as the argument is
     * usually kept in the parsed template, this ensures that each XPath
     * expression is parsed only once during the lifetime of the template that
     * first invoked it.
     * @param xpathExpression the XPath expression you wish to apply
     * @return a NodeList representing the nodes that are the result of
     * application of the XPath to the current element. It can be empty.
     */
    public NodeList selectNodes(String xpathExpression)
    {
        return new NodeList(XPathCache.getXPath(xpathExpression).applyTo(this), false);
    }
    /**
     * Returns the XML serialized form of this element, as produced by the default
     * {@link XMLOutputter}.
     * @return The XML serialized form of this element, as produced by the default
     * {@link XMLOutputter}.
     */
    public String toString()
    {
        return DEFAULT_OUTPUTTER.outputString(this);
    }
    /**
     * <p>
     * This returns the full content of the element as a NodeList which
     * may contain objects of type <code>String</code>, <code>Element</code>,
     * <code>Comment</code>, <code>ProcessingInstruction</code>,
     * <code>CDATA</code>, and <code>EntityRef</code>.
     * The List returned is ""live"" in document order and modifications
     * to it affect the element's actual contents.  Whitespace content is
     * returned in its entirety.
     * </p>
     *
     * @return a <code>List</code> containing the mixed content of the
     *         element: may contain <code>String</code>,
     *         <code>{@link Element}</code>, <code>{@link org.jdom.Comment}</code>,
     *         <code>{@link org.jdom.ProcessingInstruction}</code>,
     *         <code>{@link org.jdom.CDATA}</code>, and
     *         <code>{@link org.jdom.EntityRef}</code> objects.
     */
    public List getContent()
    {
        return new NodeList(super.getContent(), false);
    }
    /**
     * <p>
     * This returns a <code>NodeList</code> of all the child elements
     * nested directly (one level deep) within this element, as
     * <code>Element</code> objects.  If this target element has no nested
     * elements, an empty List is returned.  The returned list is ""live""
     * in document order and changes to it affect the element's actual
     * contents.
     * </p>
     * <p>
     * This performs no recursion, so elements nested two levels
     *   deep would have to be obtained with:
     * <pre>
     * <code>
     *   Iterator itr = currentElement.getChildren().iterator();
     *   while (itr.hasNext()) {
     *     Element oneLevelDeep = (Element)nestedElements.next();
     *     List twoLevelsDeep = oneLevelDeep.getChildren();
     *     // Do something with these children
     *   }
     * </code>
     * </pre>
     * </p>
     *
     * @return list of child <code>Element</code> objects for this element
     */
    public List getChildren()
    {
        return new NodeList(super.getChildren(), false);
    }
    /**
     * <p>
     * This returns a <code>NodeList</code> of all the child elements
     * nested directly (one level deep) within this element with the given
     * local name and belonging to no namespace, returned as
     * <code>Element</code> objects.  If this target element has no nested
     * elements with the given name outside a namespace, an empty List
     * is returned.  The returned list is ""live"" in document order
     * and changes to it affect the element's actual contents.
     * </p>
     * <p>
     * Please see the notes for <code>{@link #getChildren()}</code>
     * for a code example.
     * </p>
     *
     * @param name local name for the children to match
     * @return all matching child elements
     */
    public List getChildren(String name)
    {
        return new NodeList(super.getChildren(name));
    }
    /**
     * <p>
     * This returns a <code>NodeList</code> of all the child elements
     * nested directly (one level deep) within this element with the given
     * local name and belonging to the given Namespace, returned as
     * <code>Element</code> objects.  If this target element has no nested
     * elements with the given name in the given Namespace, an empty List
     * is returned.  The returned list is ""live"" in document order
     * and changes to it affect the element's actual contents.
     * </p>
     * <p>
     * Please see the notes for <code>{@link #getChildren()}</code>
     * for a code example.
     * </p>
     *
     * @param name local name for the children to match
     * @param ns <code>Namespace</code> to search within
     * @return all matching child elements
     */
    public List getChildren(String name, Namespace ns)
    {
        return new NodeList(super.getChildren(name, ns));
    }
    /**
     * <p>
     * This returns the complete set of attributes for this element, as a
     * <code>NodeList</code> of <code>Attribute</code> objects in no particular
     * order, or an empty list if there are none.
     * The returned list is ""live"" and changes to it affect the
     * element's actual attributes.
     * </p>
     *
     * @return attributes for the element
     */
    public List getAttributes()
    {
        return new NodeList(super.getAttributes());
    }
}
"
org.apache.velocity.anakia.AnakiaJDOMFactory,"package org.apache.velocity.anakia;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.DefaultJDOMFactory;
/**
 * A customized JDOMFactory for Anakia that produces {@link AnakiaElement}
 * instances instead of ordinary JDOM {@link Element} instances.
 *
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: AnakiaJDOMFactory.java 463298 2006-10-12 16:10:32Z henning $
 */
public class AnakiaJDOMFactory extends DefaultJDOMFactory
{
    /**
     *
     */
    public AnakiaJDOMFactory()
    {
    }
    /**
     * @see org.jdom.DefaultJDOMFactory#element(java.lang.String, org.jdom.Namespace)
     */
    public Element element(String name, Namespace namespace)
    {
        return new AnakiaElement(name, namespace);
    }
    /**
     * @see org.jdom.DefaultJDOMFactory#element(java.lang.String)
     */
    public Element element(String name)
    {
        return new AnakiaElement(name);
    }
    /**
     * @see org.jdom.DefaultJDOMFactory#element(java.lang.String, java.lang.String)
     */
    public Element element(String name, String uri)
    {
        return new AnakiaElement(name, uri);
    }
    /**
     * @see org.jdom.DefaultJDOMFactory#element(java.lang.String, java.lang.String, java.lang.String)
     */
    public Element element(String name, String prefix, String uri)
    {
        return new AnakiaElement(name, prefix, uri);
    }
}
"
org.apache.velocity.anakia.AnakiaTask,"package org.apache.velocity.anakia;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.StringTokenizer;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.MatchingTask;
import org.apache.velocity.Template;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.util.StringUtils;
import org.jdom.Document;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;
import org.jdom.output.Format;
import org.xml.sax.SAXParseException;
/**
 * The purpose of this Ant Task is to allow you to use
 * Velocity as an XML transformation tool like XSLT is.
 * So, instead of using XSLT, you will be able to use this
 * class instead to do your transformations. It works very
 * similar in concept to Ant's &lt;style&gt; task.
 * <p>
 * You can find more documentation about this class on the
 * Velocity
 * <a href=""http://velocity.apache.org/engine/devel/docs/anakia.html"">Website</a>.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: AnakiaTask.java 501574 2007-01-30 21:32:26Z henning $
 */
public class AnakiaTask extends MatchingTask
{
    /** <code>{@link SAXBuilder}</code> instance to use */
    SAXBuilder builder;
    /** the destination directory */
    private File destDir = null;
    /** the base directory */
    File baseDir = null;
    /** the style= attribute */
    private String style = null;
    /** last modified of the style sheet */
    private long styleSheetLastModified = 0;
    /** the projectFile= attribute */
    private String projectAttribute = null;
    /** the File for the project.xml file */
    private File projectFile = null;
    /** last modified of the project file if it exists */
    private long projectFileLastModified = 0;
    /** check the last modified date on files. defaults to true */
    private boolean lastModifiedCheck = true;
    /** the default output extension is .html */
    private String extension = "".html"";
    /** the template path */
    private String templatePath = null;
    /** the file to get the velocity properties file */
    private File velocityPropertiesFile = null;
    /** the VelocityEngine instance to use */
    private VelocityEngine ve = new VelocityEngine();
    /** the Velocity subcontexts */
    private List contexts = new LinkedList();
    /**
     * Constructor creates the SAXBuilder.
     */
    public AnakiaTask()
    {
        builder = new SAXBuilder();
        builder.setFactory(new AnakiaJDOMFactory());
    }
    /**
     * Set the base directory.
     * @param dir
     */
    public void setBasedir(File dir)
    {
        baseDir = dir;
    }
    /**
     * Set the destination directory into which the VSL result
     * files should be copied to
     * @param dir the name of the destination directory
     */
    public void setDestdir(File dir)
    {
        destDir = dir;
    }
    /**
     * Allow people to set the default output file extension
     * @param extension
     */
    public void setExtension(String extension)
    {
        this.extension = extension;
    }
    /**
     * Allow people to set the path to the .vsl file
     * @param style
     */
    public void setStyle(String style)
    {
        this.style = style;
    }
    /**
     * Allow people to set the path to the project.xml file
     * @param projectAttribute
     */
    public void setProjectFile(String projectAttribute)
    {
        this.projectAttribute = projectAttribute;
    }
    /**
     * Set the path to the templates.
     * The way it works is this:
     * If you have a Velocity.properties file defined, this method
     * will <strong>override</strong> whatever is set in the
     * Velocity.properties file. This allows one to not have to define
     * a Velocity.properties file, therefore using Velocity's defaults
     * only.
     * @param templatePath
     */
    public void setTemplatePath(File templatePath)
     {
         try
         {
             this.templatePath = templatePath.getCanonicalPath();
         }
         catch (java.io.IOException ioe)
         {
             throw new BuildException(ioe);
         }
     }
    /**
     * Allow people to set the path to the velocity.properties file
     * This file is found relative to the path where the JVM was run.
     * For example, if build.sh was executed in the ./build directory,
     * then the path would be relative to this directory.
     * This is optional based on the setting of setTemplatePath().
     * @param velocityPropertiesFile
     */
    public void setVelocityPropertiesFile(File velocityPropertiesFile)
    {
        this.velocityPropertiesFile = velocityPropertiesFile;
    }
    /**
     * Turn on/off last modified checking. by default, it is on.
     * @param lastmod
     */
    public void setLastModifiedCheck(String lastmod)
    {
        if (lastmod.equalsIgnoreCase(""false"") || lastmod.equalsIgnoreCase(""no"")
                || lastmod.equalsIgnoreCase(""off""))
        {
            this.lastModifiedCheck = false;
        }
    }
    /**
     * Main body of the application
     * @throws BuildException
     */
    public void execute () throws BuildException
    {
        DirectoryScanner scanner;
        String[]         list;
        if (baseDir == null)
        {
            baseDir = project.resolveFile(""."");
        }
        if (destDir == null )
        {
            String msg = ""destdir attribute must be set!"";
            throw new BuildException(msg);
        }
        if (style == null)
        {
            throw new BuildException(""style attribute must be set!"");
        }
        if (velocityPropertiesFile == null)
        {
            velocityPropertiesFile = new File(""velocity.properties"");
        }
        /*
         * If the props file doesn't exist AND a templatePath hasn't
         * been defined, then throw the exception.
         */
        if ( !velocityPropertiesFile.exists() && templatePath == null )
        {
            throw new BuildException (""No template path and could not "" +
                ""locate velocity.properties file: "" +
                velocityPropertiesFile.getAbsolutePath());
        }
        log(""Transforming into: "" + destDir.getAbsolutePath(), Project.MSG_INFO);
        // projectFile relative to baseDir
        if (projectAttribute != null && projectAttribute.length() > 0)
        {
            projectFile = new File(baseDir, projectAttribute);
            if (projectFile.exists())
            {
                projectFileLastModified = projectFile.lastModified();
            }
            else
            {
                log (""Project file is defined, but could not be located: "" +
                    projectFile.getAbsolutePath(), Project.MSG_INFO );
                projectFile = null;
            }
        }
        Document projectDocument = null;
        try
        {
            if ( velocityPropertiesFile.exists() )
            {
                String file = velocityPropertiesFile.getAbsolutePath();
                ExtendedProperties config = new ExtendedProperties(file);
                ve.setExtendedProperties(config);
            }
            // override the templatePath if it exists
            if (templatePath != null && templatePath.length() > 0)
            {
                ve.setProperty( RuntimeConstants.FILE_RESOURCE_LOADER_PATH,
                    templatePath);
            }
            ve.init();
            // get the last modification of the VSL stylesheet
            styleSheetLastModified = ve.getTemplate( style ).getLastModified();
            // Build the Project file document
            if (projectFile != null)
            {
                projectDocument = builder.build(projectFile);
            }
        }
        catch (Exception e)
        {
            log(""Error: "" + e.toString(), Project.MSG_INFO);
            throw new BuildException(e);
        }
        // find the files/directories
        scanner = getDirectoryScanner(baseDir);
        // get a list of files to work on
        list = scanner.getIncludedFiles();
        for (int i = 0;i < list.length; ++i)
        {
            process(list[i], projectDocument );
        }
    }
    /**
     * Process an XML file using Velocity
     */
    private void process(String xmlFile, Document projectDocument)
        throws BuildException
    {
        File   outFile=null;
        File   inFile=null;
        Writer writer = null;
        try
        {
            // the current input file relative to the baseDir
            inFile = new File(baseDir,xmlFile);
            // the output file relative to basedir
            outFile = new File(destDir,
                            xmlFile.substring(0,
                            xmlFile.lastIndexOf('.')) + extension);
            // only process files that have changed
            if (lastModifiedCheck == false ||
                    (inFile.lastModified() > outFile.lastModified() ||
                    styleSheetLastModified > outFile.lastModified() ||
                    projectFileLastModified > outFile.lastModified() ||
                    userContextsModifed(outFile.lastModified())))
            {
                ensureDirectoryFor( outFile );
                //-- command line status
                log(""Input:  "" + xmlFile, Project.MSG_INFO );
                // Build the JDOM Document
                Document root = builder.build(inFile);
                // Shove things into the Context
                VelocityContext context = new VelocityContext();
                /*
                 *  get the property TEMPLATE_ENCODING
                 *  we know it's a string...
                 */
                String encoding = (String) ve.getProperty( RuntimeConstants.OUTPUT_ENCODING );
                if (encoding == null || encoding.length() == 0
                    || encoding.equals(""8859-1"") || encoding.equals(""8859_1""))
                {
                    encoding = ""ISO-8859-1"";
                }
                Format f = Format.getRawFormat();
                f.setEncoding(encoding);
                OutputWrapper ow = new OutputWrapper(f);
                context.put (""root"", root.getRootElement());
                context.put (""xmlout"", ow );
                context.put (""relativePath"", getRelativePath(xmlFile));
                context.put (""treeWalk"", new TreeWalker());
                context.put (""xpath"", new XPathTool() );
                context.put (""escape"", new Escape() );
                context.put (""date"", new java.util.Date() );
                /**
                 * only put this into the context if it exists.
                 */
                if (projectDocument != null)
                {
                    context.put (""project"", projectDocument.getRootElement());
                }
                /**
                 *  Add the user subcontexts to the to context
                 */
                for (Iterator iter = contexts.iterator(); iter.hasNext();)
                {
                    Context subContext = (Context) iter.next();
                    if (subContext == null)
                    {
                        throw new BuildException(""Found an undefined SubContext!"");
                    }
                    if (subContext.getContextDocument() == null)
                    {
                        throw new BuildException(""Could not build a subContext for "" + subContext.getName());
                    }
                    context.put(subContext.getName(), subContext
                            .getContextDocument().getRootElement());
                }
                /**
                 * Process the VSL template with the context and write out
                 * the result as the outFile.
                 */
                writer = new BufferedWriter(new OutputStreamWriter(
                                            new FileOutputStream(outFile),
                                                encoding));
                /**
                 * get the template to process
                 */
                Template template = ve.getTemplate(style);
                template.merge(context, writer);
                log(""Output: "" + outFile, Project.MSG_INFO );
            }
        }
        catch (JDOMException e)
        {
            outFile.delete();
            if (e.getCause() != null)
            {
                Throwable rootCause = e.getCause();
                if (rootCause instanceof SAXParseException)
                {
                    System.out.println("""");
                    System.out.println(""Error: "" + rootCause.getMessage());
                    System.out.println(
                        ""       Line: "" +
                            ((SAXParseException)rootCause).getLineNumber() +
                        "" Column: "" +
                            ((SAXParseException)rootCause).getColumnNumber());
                    System.out.println("""");
                }
                else
                {
                    rootCause.printStackTrace();
                }
            }
            else
            {
                e.printStackTrace();
            }
        }
        catch (Throwable e)
        {
            if (outFile != null)
            {
                outFile.delete();
            }
            e.printStackTrace();
        }
        finally
        {
            if (writer != null)
            {
                try
                {
                    writer.flush();
                }
                catch (IOException e)
                {
                    // Do nothing
                }
                try
                {
                    writer.close();
                }
                catch (IOException e)
                {
                    // Do nothing
                }
            }
        }
    }
    /**
     * Hacky method to figure out the relative path
     * that we are currently in. This is good for getting
     * the relative path for images and anchor's.
     */
    private String getRelativePath(String file)
    {
        if (file == null || file.length()==0)
            return """";
        StringTokenizer st = new StringTokenizer(file, ""/\\"");
        // needs to be -1 cause ST returns 1 even if there are no matches. huh?
        int slashCount = st.countTokens() - 1;
        StringBuffer sb = new StringBuffer();
        for (int i=0;i<slashCount ;i++ )
        {
            sb.append (""../"");
        }
        if (sb.toString().length() > 0)
        {
            return StringUtils.chop(sb.toString(), 1);
        }
        return ""."";
    }
    /**
     * create directories as needed
     */
    private void ensureDirectoryFor( File targetFile ) throws BuildException
    {
        File directory = new File( targetFile.getParent() );
        if (!directory.exists())
        {
            if (!directory.mkdirs())
            {
                throw new BuildException(""Unable to create directory: ""
                                         + directory.getAbsolutePath() );
            }
        }
    }
    /**
     * Check to see if user context is modified.
     */
    private boolean userContextsModifed(long lastModified)
    {
        for (Iterator iter = contexts.iterator(); iter.hasNext();)
        {
            AnakiaTask.Context ctx = (AnakiaTask.Context) iter.next();
            if(ctx.getLastModified() > lastModified)
            {
                return true;
            }
        }
        return false;
    }
    /**
     * Create a new context.
     * @return A new context.
     */
    public Context createContext()
    {
        Context context = new Context();
        contexts.add(context);
        return context;
    }
    /**
     * A context implementation that loads all values from an XML file.
     */
    public class Context
    {
        private String name;
        private Document contextDoc = null;
        private String file;
        /**
         * Public constructor.
         */
        public Context()
        {
        }
        /**
         * Get the name of the context.
         * @return The name of the context.
         */
        public String getName()
        {
            return name;
        }
        /**
         * Set the name of the context.
         * @param name
         *
         * @throws IllegalArgumentException if a reserved word is used as a
         * name, specifically any of ""relativePath"", ""treeWalk"", ""xpath"",
         * ""escape"", ""date"", or ""project""
         */
        public void setName(String name)
        {
            if (name.equals(""relativePath"") ||
                    name.equals(""treeWalk"") ||
                    name.equals(""xpath"") ||
                    name.equals(""escape"") ||
                    name.equals(""date"") ||
                    name.equals(""project""))
            {
                    throw new IllegalArgumentException(""Context name '"" + name
                            + ""' is reserved by Anakia"");
            }
            this.name = name;
        }
        /**
         * Build the context based on a file path.
         * @param file
         */
        public void setFile(String file)
        {
            this.file = file;
        }
        /**
         * Retrieve the time the source file was last modified.
         * @return The time the source file was last modified.
         */
        public long getLastModified()
        {
            return new File(baseDir, file).lastModified();
        }
        /**
         * Retrieve the context document object.
         * @return The context document object.
         */
        public Document getContextDocument()
        {
            if (contextDoc == null)
            {
                File contextFile = new File(baseDir, file);
                try
                {
                    contextDoc = builder.build(contextFile);
                }
                catch (Exception e)
                {
                    throw new BuildException(e);
                }
            }
            return contextDoc;
        }
    }
}
"
org.apache.velocity.anakia.Escape,"package org.apache.velocity.anakia;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * This class is for escaping CDATA sections. The code was
 * ""borrowed"" from the JDOM code. Also included is escaping
 * the "" -> &amp;quot; character and the conversion of newlines
 * to the platform line separator.
 *
 * @author <a href=""mailto:wglass@apache.org"">Will Glass-Husain</a>
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @version $Id: Escape.java 463298 2006-10-12 16:10:32Z henning $
 */
public class Escape
{
    /**
     *
     */
    public static final String LINE_SEPARATOR = System.getProperty(""line.separator"");
    /**
     * Empty constructor
     */
    public Escape()
    {
        // left blank on purpose
    }
    /**
     * Do the escaping.
     * @param st
     * @return The escaped text.
     */
    public static final String getText(String st)
    {
        StringBuffer buff = new StringBuffer();
        char[] block = st.toCharArray();
        String stEntity = null;
        int i, last;
        for (i=0, last=0; i < block.length; i++)
        {
            switch(block[i])
            {
                case '<' :
                    stEntity = ""&lt;"";
                    break;
                case '>' :
                    stEntity = ""&gt;"";
                    break;
                case '&' :
                    stEntity = ""&amp;"";
                    break;
                case '""' :
                    stEntity = ""&quot;"";
                    break;
                case '\n' :
                    stEntity = LINE_SEPARATOR;
                    break;
                default :
                    /* no-op */
                    break;
            }
            if (stEntity != null)
            {
                buff.append(block, last, i - last);
                buff.append(stEntity);
                stEntity = null;
                last = i + 1;
            }
        }
        if(last < block.length)
        {
            buff.append(block, last, i - last);
        }
        return buff.toString();
    }
}
"
org.apache.velocity.anakia.NodeList,"package org.apache.velocity.anakia;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import org.jdom.Attribute;
import org.jdom.CDATA;
import org.jdom.Comment;
import org.jdom.DocType;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.EntityRef;
import org.jdom.ProcessingInstruction;
import org.jdom.Text;
import org.jdom.output.XMLOutputter;
/**
 * Provides a class for wrapping a list of JDOM objects primarily for use in template
 * engines and other kinds of text transformation tools.
 * It has a {@link #toString()} method that will output the XML serialized form of the
 * nodes it contains - again focusing on template engine usage, as well as the
 * {@link #selectNodes(String)} method that helps selecting a different set of nodes
 * starting from the nodes in this list. The class also implements the {@link java.util.List}
 * interface by simply delegating calls to the contained list (the {@link #subList(int, int)}
 * method is implemented by delegating to the contained list and wrapping the returned
 * sublist into a <code>NodeList</code>).
 *
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: NodeList.java 463298 2006-10-12 16:10:32Z henning $
 */
public class NodeList implements List, Cloneable
{
    private static final AttributeXMLOutputter DEFAULT_OUTPUTTER =
        new AttributeXMLOutputter();
    /** The contained nodes */
    private List nodes;
    /**
     * Creates an empty node list.
     */
    public NodeList()
    {
        nodes = new ArrayList();
    }
    /**
     * Creates a node list that holds a single {@link Document} node.
     * @param document
     */
    public NodeList(Document document)
    {
        this((Object)document);
    }
    /**
     * Creates a node list that holds a single {@link Element} node.
     * @param element
     */
    public NodeList(Element element)
    {
        this((Object)element);
    }
    private NodeList(Object object)
    {
        if(object == null)
        {
            throw new IllegalArgumentException(
                ""Cannot construct NodeList with null."");
        }
        nodes = new ArrayList(1);
        nodes.add(object);
    }
    /**
     * Creates a node list that holds a list of nodes.
     * @param nodes the list of nodes this template should hold. The created
     * template will copy the passed nodes list, so changes to the passed list
     * will not affect the model.
     */
    public NodeList(List nodes)
    {
        this(nodes, true);
    }
    /**
     * Creates a node list that holds a list of nodes.
     * @param nodes the list of nodes this template should hold.
     * @param copy if true, the created template will copy the passed nodes
     * list, so changes to the passed list will not affect the model. If false,
     * the model will reference the passed list and will sense changes in it,
     * altough no operations on the list will be synchronized.
     */
    public NodeList(List nodes, boolean copy)
    {
        if(nodes == null)
        {
            throw new IllegalArgumentException(
                ""Cannot initialize NodeList with null list"");
        }
        this.nodes = copy ? new ArrayList(nodes) : nodes;
    }
    /**
     * Retrieves the underlying list used to store the nodes. Note however, that
     * you can fully use the underlying list through the <code>List</code> interface
     * of this class itself. You would probably access the underlying list only for
     * synchronization purposes.
     * @return The internal node List.
     */
    public List getList()
    {
        return nodes;
    }
    /**
     * This method returns the string resulting from concatenation of string
     * representations of its nodes. Each node is rendered using its XML
     * serialization format. This greatly simplifies creating XML-transformation
     * templates, as to output a node contained in variable x as XML fragment,
     * you simply write ${x} in the template (or whatever your template engine
     * uses as its expression syntax).
     * @return The Nodelist as printable object.
     */
    public String toString()
    {
        if(nodes.isEmpty())
        {
            return """";
        }
        StringWriter sw = new StringWriter(nodes.size() * 128);
        try
        {
            for(Iterator i = nodes.iterator(); i.hasNext();)
            {
                Object node = i.next();
                if(node instanceof Element)
                {
                    DEFAULT_OUTPUTTER.output((Element)node, sw);
                }
                else if(node instanceof Attribute)
                {
                    DEFAULT_OUTPUTTER.output((Attribute)node, sw);
                }
                else if(node instanceof Text)
                {
                    DEFAULT_OUTPUTTER.output((Text)node, sw);
                }
                else if(node instanceof Document)
                {
                    DEFAULT_OUTPUTTER.output((Document)node, sw);
                }
                else if(node instanceof ProcessingInstruction)
                {
                    DEFAULT_OUTPUTTER.output((ProcessingInstruction)node, sw);
                }
                else if(node instanceof Comment)
                {
                    DEFAULT_OUTPUTTER.output((Comment)node, sw);
                }
                else if(node instanceof CDATA)
                {
                    DEFAULT_OUTPUTTER.output((CDATA)node, sw);
                }
                else if(node instanceof DocType)
                {
                    DEFAULT_OUTPUTTER.output((DocType)node, sw);
                }
                else if(node instanceof EntityRef)
                {
                    DEFAULT_OUTPUTTER.output((EntityRef)node, sw);
                }
                else
                {
                    throw new IllegalArgumentException(
                        ""Cannot process a "" +
                        (node == null
                         ? ""null node""
                         : ""node of class "" + node.getClass().getName()));
                }
            }
        }
        catch(IOException e)
        {
            // Cannot happen as we work with a StringWriter in memory
            throw new Error();
        }
        return sw.toString();
    }
    /**
     * Returns a NodeList that contains the same nodes as this node list.
     * @return A clone of this list.
     * @throws CloneNotSupportedException if the contained list's class does
     * not have an accessible no-arg constructor.
     */
    public Object clone()
        throws CloneNotSupportedException
    {
        NodeList clonedList = (NodeList)super.clone();
        clonedList.cloneNodes();
        return clonedList;
    }
    private void cloneNodes()
        throws CloneNotSupportedException
    {
        Class listClass = nodes.getClass();
        try
        {
            List clonedNodes = (List)listClass.newInstance();
            clonedNodes.addAll(nodes);
            nodes = clonedNodes;
        }
        catch(IllegalAccessException e)
        {
            throw new CloneNotSupportedException(""Cannot clone NodeList since""
            + "" there is no accessible no-arg constructor on class ""
            + listClass.getName());
        }
        catch(InstantiationException e)
        {
            // Cannot happen as listClass represents a concrete, non-primitive,
            // non-array, non-void class - there's an instance of it in ""nodes""
            // which proves these assumptions.
            throw new Error();
        }
    }
    /**
     * Returns the hash code of the contained list.
     * @return The hashcode of the list.
     */
    public int hashCode()
    {
        return nodes.hashCode();
    }
    /**
     * Tests for equality with another object.
     * @param o the object to test for equality
     * @return true if the other object is also a NodeList and their contained
     * {@link List} objects evaluate as equals.
     */
    public boolean equals(Object o)
    {
        return o instanceof NodeList
            ? ((NodeList)o).nodes.equals(nodes)
            : false;
    }
    /**
     * Applies an XPath expression to the node list and returns the resulting
     * node list. In order for this method to work, your application must have
     * access to <a href=""http://code.werken.com"">werken.xpath</a> library
     * classes. The implementation does cache the parsed format of XPath
     * expressions in a weak hash map, keyed by the string representation of
     * the XPath expression. As the string object passed as the argument is
     * usually kept in the parsed template, this ensures that each XPath
     * expression is parsed only once during the lifetime of the template that
     * first invoked it.
     * @param xpathString the XPath expression you wish to apply
     * @return a NodeList representing the nodes that are the result of
     * application of the XPath to the current node list. It can be empty.
     */
    public NodeList selectNodes(String xpathString)
    {
        return new NodeList(XPathCache.getXPath(xpathString).applyTo(nodes), false);
    }
// List methods implemented hereafter
    /**
     * @see java.util.List#add(java.lang.Object)
     */
    public boolean add(Object o)
    {
        return nodes.add(o);
    }
    /**
     * @see java.util.List#add(int, java.lang.Object)
     */
    public void add(int index, Object o)
    {
        nodes.add(index, o);
    }
    /**
     * @see java.util.List#addAll(java.util.Collection)
     */
    public boolean addAll(Collection c)
    {
        return nodes.addAll(c);
    }
    /**
     * @see java.util.List#addAll(int, java.util.Collection)
     */
    public boolean addAll(int index, Collection c)
    {
        return nodes.addAll(index, c);
    }
    /**
     * @see java.util.List#clear()
     */
    public void clear()
    {
        nodes.clear();
    }
    /**
     * @see java.util.List#contains(java.lang.Object)
     */
    public boolean contains(Object o)
    {
        return nodes.contains(o);
    }
    /**
     * @see java.util.List#containsAll(java.util.Collection)
     */
    public boolean containsAll(Collection c)
    {
        return nodes.containsAll(c);
    }
    /**
     * @see java.util.List#get(int)
     */
    public Object get(int index)
    {
        return nodes.get(index);
    }
    /**
     * @see java.util.List#indexOf(java.lang.Object)
     */
    public int indexOf(Object o)
    {
        return nodes.indexOf(o);
    }
    /**
     * @see java.util.List#isEmpty()
     */
    public boolean isEmpty()
    {
        return nodes.isEmpty();
    }
    /**
     * @see java.util.List#iterator()
     */
    public Iterator iterator()
    {
        return nodes.iterator();
    }
    /**
     * @see java.util.List#lastIndexOf(java.lang.Object)
     */
    public int lastIndexOf(Object o)
    {
        return nodes.lastIndexOf(o);
    }
    /**
     * @see java.util.List#listIterator()
     */
    public ListIterator listIterator()
    {
        return nodes.listIterator();
    }
    /**
     * @see java.util.List#listIterator(int)
     */
    public ListIterator listIterator(int index)
    {
        return nodes.listIterator(index);
    }
    /**
     * @see java.util.List#remove(int)
     */
    public Object remove(int index)
    {
        return nodes.remove(index);
    }
    /**
     * @see java.util.List#remove(java.lang.Object)
     */
    public boolean remove(Object o)
    {
        return nodes.remove(o);
    }
    /**
     * @see java.util.List#removeAll(java.util.Collection)
     */
    public boolean removeAll(Collection c)
    {
        return nodes.removeAll(c);
    }
    /**
     * @see java.util.List#retainAll(java.util.Collection)
     */
    public boolean retainAll(Collection c)
    {
        return nodes.retainAll(c);
    }
    /**
     * @see java.util.List#set(int, java.lang.Object)
     */
    public Object set(int index, Object o)
    {
        return nodes.set(index, o);
    }
    /**
     * @see java.util.List#size()
     */
    public int size()
    {
        return nodes.size();
    }
    /**
     * @see java.util.List#subList(int, int)
     */
    public List subList(int fromIndex, int toIndex)
    {
        return new NodeList(nodes.subList(fromIndex, toIndex));
    }
    /**
     * @see java.util.List#toArray()
     */
    public Object[] toArray()
    {
        return nodes.toArray();
    }
    /**
     * @see java.util.List#toArray(java.lang.Object[])
     */
    public Object[] toArray(Object[] a)
    {
        return nodes.toArray(a);
    }
    /**
     * A special subclass of XMLOutputter that will be used to output
     * Attribute nodes. As a subclass of XMLOutputter it can use its protected
     * method escapeAttributeEntities() to serialize the attribute
     * appropriately.
     */
    private static final class AttributeXMLOutputter extends XMLOutputter
    {
        /**
         * @param attribute
         * @param out
         * @throws IOException
         */
        public void output(Attribute attribute, Writer out)
            throws IOException
        {
            out.write("" "");
            out.write(attribute.getQualifiedName());
            out.write(""="");
            out.write(""\"""");
            out.write(escapeAttributeEntities(attribute.getValue()));
            out.write(""\"""");
        }
    }
}
"
org.apache.velocity.anakia.OutputWrapper,"package org.apache.velocity.anakia;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.StringWriter;
import org.jdom.Element;
import org.jdom.output.XMLOutputter;
import org.jdom.output.Format;
/**
 * This class extends XMLOutputter in order to provide
 * a way to walk an Element tree into a String.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:rubys@us.ibm.com"">Sam Ruby</a>
 * @version $Id: OutputWrapper.java 463298 2006-10-12 16:10:32Z henning $
 */
public class OutputWrapper extends XMLOutputter
{
    /**
     * Empty constructor
     */
    public OutputWrapper()
    {
    }
    /**
     * @param f
     */
    public OutputWrapper(Format f)
    {
        super(f);
    }
    /**
     * This method walks an Element tree into a String. The cool
     * thing about it is that it will strip off the first Element.
     * For example, if you have:
     * <p>
     * &lt;td&gt; foo &lt;strong&gt;bar&lt;/strong&gt; ack &lt;/td&gt;
     * </p>
     * It will output
     * <p>
     *  foo &lt;strong&gt;bar&lt;/strong&gt; ack &lt;/td&gt;
     * </p>
     * @param element
     * @param strip
     * @return The output string.
     */
    public String outputString(Element element, boolean strip)
    {
        StringWriter buff = new StringWriter();
        try
        {
            outputElementContent(element, buff);
        }
        catch (IOException e)
        {
        }
        return buff.toString();
    }
}
"
org.apache.velocity.anakia.TreeWalker,"package org.apache.velocity.anakia;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import org.jdom.Element;
/**
 * This class allows you to walk a tree of JDOM Element objects.
 * It first walks the tree itself starting at the Element passed
 * into allElements() and stores each node of the tree
 * in a Vector which allElements() returns as a result of its
 * execution. You can then use a #foreach in Velocity to walk
 * over the Vector and visit each Element node. However, you can
 * achieve the same effect by calling <code>element.selectNodes(""//*"")</code>.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: TreeWalker.java 463298 2006-10-12 16:10:32Z henning $
 */
public class TreeWalker
{
    /**
     * Empty constructor
     */
    public TreeWalker()
    {
        // Left blank
    }
    /**
     * Creates a new Vector and walks the Element tree.
     *
     * @param e the starting Element node
     * @return Vector a vector of Element nodes
     */
    public NodeList allElements(Element e)
    {
        ArrayList theElements = new ArrayList();
        treeWalk (e, theElements);
        return new NodeList(theElements, false);
    }
    /**
     * A recursive method to walk the Element tree.
     * @param Element the current Element
     */
    private final void treeWalk(Element e, Collection theElements )
    {
        for (Iterator i=e.getChildren().iterator(); i.hasNext(); )
        {
            Element child = (Element)i.next();
            theElements.add(child);
            treeWalk(child, theElements);
        }
    }
}
"
org.apache.velocity.anakia.XPathCache,"package org.apache.velocity.anakia;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import com.werken.xpath.XPath;
import java.util.Map;
import java.util.WeakHashMap;
/**
 * Provides a cache for XPath expressions. Used by {@link NodeList} and
 * {@link AnakiaElement} to minimize XPath parsing in their
 * <code>selectNodes()</code> methods.
 *
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: XPathCache.java 463298 2006-10-12 16:10:32Z henning $
 */
class XPathCache
{
    // Cache of already parsed XPath expressions, keyed by String representations
    // of the expression as passed to getXPath().
    private static final Map XPATH_CACHE = new WeakHashMap();
    private XPathCache()
    {
    }
    /**
     * Returns an XPath object representing the requested XPath expression.
     * A cached object is returned if it already exists for the requested expression.
     * @param xpathString the XPath expression to parse
     * @return the XPath object that represents the parsed XPath expression.
     */
    static XPath getXPath(String xpathString)
    {
        XPath xpath = null;
        synchronized(XPATH_CACHE)
        {
            xpath = (XPath)XPATH_CACHE.get(xpathString);
            if(xpath == null)
            {
                xpath = new XPath(xpathString);
                XPATH_CACHE.put(xpathString, xpath);
            }
        }
        return xpath;
    }
}
"
org.apache.velocity.anakia.XPathTool,"package org.apache.velocity.anakia;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.List;
import org.jdom.Document;
import org.jdom.Element;
/**
 * This class adds an entrypoint into XPath functionality,
 * for Anakia.
 * <p>
 * All methods take a string XPath specification, along with
 * a context, and produces a resulting java.util.List.
 * <p>
 * The W3C XPath Specification (http://www.w3.org/TR/xpath) refers
 * to NodeSets repeatedly, but this implementation simply uses
 * java.util.List to hold all Nodes.  A 'Node' is any object in
 * a JDOM object tree, such as an org.jdom.Element, org.jdom.Document,
 * or org.jdom.Attribute.
 * <p>
 * To use it in Velocity, do this:
 * <p>
 * <pre>
 * #set $authors = $xpath.applyTo(""document/author"", $root)
 * #foreach ($author in $authors)
 *   $author.getValue()
 * #end
 * #set $chapterTitles = $xpath.applyTo(""document/chapter/@title"", $root)
 * #foreach ($title in $chapterTitles)
 *   $title.getValue()
 * #end
 * </pre>
 * <p>
 * In newer Anakia builds, this class is obsoleted in favor of calling
 * <code>selectNodes()</code> on the element directly:
 * <pre>
 * #set $authors = $root.selectNodes(""document/author"")
 * #foreach ($author in $authors)
 *   $author.getValue()
 * #end
 * #set $chapterTitles = $root.selectNodes(""document/chapter/@title"")
 * #foreach ($title in $chapterTitles)
 *   $title.getValue()
 * #end
 * </pre>
 * <p>
 *
 * @author <a href=""mailto:bob@werken.com"">bob mcwhirter</a>
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: XPathTool.java 463298 2006-10-12 16:10:32Z henning $
 */
public class XPathTool
{
    /**
     * Constructor does nothing, as this is mostly
     * just objectified static methods
     */
    public XPathTool()
    {
        //        RuntimeSingleton.info(""XPathTool::XPathTool()"");
        // intentionally left blank
    }
    /**
     * Apply an XPath to a JDOM Document
     *
     * @param xpathSpec The XPath to apply
     * @param doc The Document context
     *
     * @return A list of selected nodes
     */
    public NodeList applyTo(String xpathSpec,
                        Document doc)
    {
        //RuntimeSingleton.info(""XPathTool::applyTo(String, Document)"");
        return new NodeList(XPathCache.getXPath(xpathSpec).applyTo( doc ), false);
    }
    /**
     * Apply an XPath to a JDOM Element
     *
     * @param xpathSpec The XPath to apply
     * @param elem The Element context
     *
     * @return A list of selected nodes
     */
    public NodeList applyTo(String xpathSpec,
                        Element elem)
    {
        //RuntimeSingleton.info(""XPathTool::applyTo(String, Element)"");
        return new NodeList(XPathCache.getXPath(xpathSpec).applyTo( elem ), false);
    }
    /**
     * Apply an XPath to a nodeset
     *
     * @param xpathSpec The XPath to apply
     * @param nodeSet The nodeset context
     *
     * @return A list of selected nodes
     */
    public NodeList applyTo(String xpathSpec,
                        List nodeSet)
    {
        //RuntimeSingleton.info(""XPathTool::applyTo(String, List)"");
        return new NodeList(XPathCache.getXPath(xpathSpec).applyTo( nodeSet ), false);
    }
}
"
org.apache.velocity.app.FieldMethodizer,"package org.apache.velocity.app;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import org.apache.velocity.util.ClassUtils;
/**
 *  <p>
 *  This is a small utility class allow easy access to static fields in a class,
 *  such as string constants.  Velocity will not introspect for class
 *  fields (and won't in the future :), but writing setter/getter methods to do
 *  this really is a pain,  so use this if you really have
 *  to access fields.
 *
 *  <p>
 *  The idea it so enable access to the fields just like you would in Java.
 *  For example, in Java, you would access a static field like
 *  <blockquote><pre>
 *  MyClass.STRING_CONSTANT
 *  </pre></blockquote>
 *  and that is the same thing we are trying to allow here.
 *
 *  <p>
 *  So to use in your Java code, do something like this :
 *  <blockquote><pre>
 *   context.put(""runtime"", new FieldMethodizer( ""org.apache.velocity.runtime.Runtime"" ));
 *  </pre></blockquote>
 *  and then in your template, you can access any of your static fields in this way :
 *  <blockquote><pre>
 *   $runtime.COUNTER_NAME
 *  </pre></blockquote>
 *
 *  <p>
 *  Right now, this class only methodizes <code>public static</code> fields.  It seems
 *  that anything else is too dangerous.  This class is for convenience accessing
 *  'constants'.  If you have fields that aren't <code>static</code> it may be better
 *  to handle them by explicitly placing them into the context.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: FieldMethodizer.java 652755 2008-05-02 04:00:58Z nbubna $
 */
public class FieldMethodizer
{
    /** Hold the field objects by field name */
    private HashMap fieldHash = new HashMap();
    /**
     * Allow object to be initialized without any data. You would use
     * addObject() to add data later.
     */
    public FieldMethodizer()
    {
    }
    /**
     *  Constructor that takes as it's arg the name of the class
     *  to methodize.
     *
     *  @param s Name of class to methodize.
     */
    public FieldMethodizer( String s )
    {
        try
        {
            addObject(s);
        }
        catch( Exception e )
        {
            System.err.println(""Could not add "" + s
                    + "" for field methodizing: ""
                    + e.getMessage());
        }
    }
  /**
     *  Constructor that takes as it's arg a living
     *  object to methodize.  Note that it will still
     *  only methodized the public static fields of
     *  the class.
     *
     *  @param o Name of class to methodize.
     */
    public FieldMethodizer( Object o )
    {
        try
        {
            addObject(o);
        }
        catch( Exception e )
        {
            System.err.println(""Could not add "" + o
                    + "" for field methodizing: ""
                    + e.getMessage());
        }
    }
    /**
     * Add the Name of the class to methodize
     * @param s
     * @throws Exception
     */
    public void addObject ( String s )
        throws Exception
    {
        inspect(ClassUtils.getClass(s));
    }
    /**
     * Add an Object to methodize
     * @param o
     * @throws Exception
     */
    public void addObject ( Object o )
        throws Exception
    {
        inspect(o.getClass());
    }
    /**
     *  Accessor method to get the fields by name.
     *
     *  @param fieldName Name of static field to retrieve
     *
     *  @return The value of the given field.
     */
    public Object get( String fieldName )
    {
        Object value = null;
        try
        {
            Field f = (Field) fieldHash.get( fieldName );
            if (f != null)
            {
                value = f.get(null);
            }
        }
        catch( IllegalAccessException e )
        {
            System.err.println(""IllegalAccessException while trying to access "" + fieldName
                    + "": "" + e.getMessage());
        }
        return value;
    }
    /**
     *  Method that retrieves all public static fields
     *  in the class we are methodizing.
     */
    private void inspect(Class clas)
    {
        Field[] fields = clas.getFields();
        for( int i = 0; i < fields.length; i++)
        {
            /*
             *  only if public and static
             */
            int mod = fields[i].getModifiers();
            if ( Modifier.isStatic(mod) && Modifier.isPublic(mod) )
            {
                fieldHash.put(fields[i].getName(), fields[i]);
            }
        }
    }
}
"
org.apache.velocity.app.Velocity,"package org.apache.velocity.app;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.util.Properties;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.velocity.Template;
import org.apache.velocity.context.Context;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.runtime.log.Log;
/**
 * This class provides  services to the application
 * developer, such as :
 * <ul>
 * <li> Simple Velocity Runtime engine initialization methods.
 * <li> Functions to apply the template engine to streams and strings
 *      to allow embedding and dynamic template generation.
 * <li> Methods to access Velocimacros directly.
 * </ul>
 *
 * <br><br>
 * While the most common way to use Velocity is via templates, as
 * Velocity is a general-purpose template engine, there are other
 * uses that Velocity is well suited for, such as processing dynamically
 * created templates, or processing content streams.
 *
 * <br><br>
 * The methods herein were developed to allow easy access to the Velocity
 * facilities without direct spelunking of the internals.  If there is
 * something you feel is necessary to add here, please, send a patch.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:Christoph.Reck@dlr.de"">Christoph Reck</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: Velocity.java 687177 2008-08-19 22:00:32Z nbubna $
 */
public class Velocity implements RuntimeConstants
{
    /**
     *  initialize the Velocity runtime engine, using the default
     *  properties of the Velocity distribution
     *
     * @throws Exception When an error during initialization occurs.
     */
    public static void init()
        throws Exception
    {
        RuntimeSingleton.init();
    }
    /**
     *  initialize the Velocity runtime engine, using default properties
     *  plus the properties in the properties file passed in as the arg
     *
     *  @param propsFilename file containing properties to use to initialize
     *         the Velocity runtime
     * @throws Exception When an error during initialization occurs.
     */
    public static void init( String propsFilename )
        throws Exception
    {
        RuntimeSingleton.init(propsFilename);
    }
    /**
     *  initialize the Velocity runtime engine, using default properties
     *  plus the properties in the passed in java.util.Properties object
     *
     *  @param p  Properties object containing initialization properties
     * @throws Exception When an error during initialization occurs.
     *
     */
    public static void init( Properties p )
        throws Exception
    {
        RuntimeSingleton.init( p );
    }
    /**
     * Set a Velocity Runtime property.
     *
     * @param key The property key.
     * @param value The property value.
     */
    public static void setProperty(String key, Object value)
    {
        RuntimeSingleton.setProperty(key,value);
    }
    /**
     * Add a Velocity Runtime property.
     *
     * @param key The property key.
     * @param value The property value.
     */
    public static void addProperty(String key, Object value)
    {
        RuntimeSingleton.addProperty(key,value);
    }
    /**
     * Clear a Velocity Runtime property.
     *
     * @param key of property to clear
     */
    public static void clearProperty(String key)
    {
        RuntimeSingleton.clearProperty(key);
    }
    /**
     * Set an entire configuration at once. This is
     * useful in cases where the parent application uses
     * the ExtendedProperties class and the velocity configuration
     * is a subset of the parent application's configuration.
     *
     * @param configuration A configuration object.
     *
     */
    public static void setExtendedProperties( ExtendedProperties configuration)
    {
        RuntimeSingleton.setConfiguration( configuration );
    }
    /**
     *  Get a Velocity Runtime property.
     *
     *  @param key property to retrieve
     *  @return property value or null if the property
     *        not currently set
     */
    public static Object getProperty( String key )
    {
        return RuntimeSingleton.getProperty( key );
    }
    /**
     *  renders the input string using the context into the output writer.
     *  To be used when a template is dynamically constructed, or want to use
     *  Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param out  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log
     *                 messages in case of error
     *  @param instring input string containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see
     *             Velocity runtime log
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws IOException While rendering to the writer, an I/O problem occured.
     */
    public static  boolean evaluate( Context context,  Writer out,
                                     String logTag, String instring )
        throws ParseErrorException, MethodInvocationException,
            ResourceNotFoundException, IOException
    {
        return RuntimeSingleton.getRuntimeServices()
            .evaluate(context, out, logTag, instring);
    }
    /**
     *  Renders the input stream using the context into the output writer.
     *  To be used when a template is dynamically constructed, or want to
     *  use Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param writer  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log messages
     *                 in case of error
     *  @param instream input stream containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see
     *               Velocity runtime log
     *  @deprecated Use
     *  {@link #evaluate( Context context, Writer writer,
     *      String logTag, Reader reader ) }
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws IOException While loading a reference, an I/O problem occured.
     */
    public static boolean evaluate( Context context, Writer writer,
                                    String logTag, InputStream instream )
        throws ParseErrorException, MethodInvocationException,
            ResourceNotFoundException, IOException
    {
        /*
         *  first, parse - convert ParseException if thrown
         */
        BufferedReader br  = null;
        String encoding = null;
        try
        {
            encoding = RuntimeSingleton.getString(INPUT_ENCODING,ENCODING_DEFAULT);
            br = new BufferedReader(  new InputStreamReader( instream, encoding));
        }
        catch( UnsupportedEncodingException  uce )
        {
            String msg = ""Unsupported input encoding : "" + encoding
                + "" for template "" + logTag;
            throw new ParseErrorException( msg );
        }
        return evaluate( context, writer, logTag, br );
    }
    /**
     *  Renders the input reader using the context into the output writer.
     *  To be used when a template is dynamically constructed, or want to
     *  use Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param writer  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log messages
     *                 in case of error
     *  @param reader Reader containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see
     *               Velocity runtime log
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws IOException While reading from the reader or rendering to the writer,
     *                     an I/O problem occured.
     *  @since Velocity v1.1
     */
    public static boolean evaluate( Context context, Writer writer,
                                    String logTag, Reader reader )
        throws ParseErrorException, MethodInvocationException,
            ResourceNotFoundException,IOException
    {
        return RuntimeSingleton.getRuntimeServices().evaluate(context, writer,
                                                              logTag, reader);
    }
    /**
     * Invokes a currently registered Velocimacro with the params provided
     * and places the rendered stream into the writer.
     * <br>
     * Note : currently only accepts args to the VM if they are in the context.
     *
     * @param vmName name of Velocimacro to call
     * @param logTag string to be used for template name in case of error. if null,
     *               the vmName will be used
     * @param params keys for args used to invoke Velocimacro, in java format
     *               rather than VTL (eg  ""foo"" or ""bar"" rather than ""$foo"" or ""$bar"")
     * @param context Context object containing data/objects used for rendering.
     * @param writer  Writer for output stream
     * @return true if Velocimacro exists and successfully invoked, false otherwise.
     */
    public static  boolean invokeVelocimacro( String vmName, String logTag,
                                              String params[], Context context,
                                              Writer writer )
    {
        try
        {
            return RuntimeSingleton.getRuntimeServices()
                .invokeVelocimacro(vmName, logTag, params, context, writer);
        }
        catch (IOException ioe)
        {
            String msg = ""Velocity.invokeVelocimacro(""+vmName+"") failed"";
            getLog().error(msg, ioe);
            throw new VelocityException(msg, ioe);
        }
    }
    /**
     *  Merges a template and puts the rendered stream into the writer.
     *  The default encoding that Velocity uses to read template files is defined in
     *  the property input.encoding and defaults to ISO-8859-1.
     *
     *  @param templateName name of template to be used in merge
     *  @param context  filled context to be used in merge
     *  @param  writer  writer to write template into
     *
     *  @return true if successful, false otherwise.  Errors
     *           logged to velocity log.
     *  @deprecated Use
     *  {@link #mergeTemplate( String templateName, String encoding,
     *                Context context, Writer writer )}
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws Exception Any other exception.
     */
    public static boolean mergeTemplate( String templateName,
                                         Context context, Writer writer )
        throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, Exception
    {
        return mergeTemplate( templateName, RuntimeSingleton.getString(INPUT_ENCODING,ENCODING_DEFAULT),
                               context, writer );
    }
    /**
     *  merges a template and puts the rendered stream into the writer
     *
     *  @param templateName name of template to be used in merge
     *  @param encoding encoding used in template
     *  @param context  filled context to be used in merge
     *  @param  writer  writer to write template into
     *
     *  @return true if successful, false otherwise.  Errors
     *           logged to velocity log
     *
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws Exception Any other exception.
     *
     * @since Velocity v1.1
     */
    public static boolean mergeTemplate( String templateName, String encoding,
                                      Context context, Writer writer )
        throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, Exception
    {
        Template template = RuntimeSingleton.getTemplate(templateName, encoding);
        if ( template == null )
        {
            String msg = ""Velocity.mergeTemplate() was unable to load template '""
                           + templateName + ""'"";
            getLog().error(msg);
            throw new ResourceNotFoundException(msg);
        }
        else
        {
            template.merge(context, writer);
            return true;
        }
    }
    /**
     *  Returns a <code>Template</code> from the Velocity
     *  resource management system.
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public static Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate( name );
    }
    /**
     *  Returns a <code>Template</code> from the Velocity
     *  resource management system.
     *
     * @param name The file name of the desired template.
     * @param encoding The character encoding to use for the template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     *
     *  @since Velocity v1.1
     */
    public static Template getTemplate(String name, String encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate( name, encoding );
    }
    /**
     * <p>Determines whether a resource is accessable via the
     * currently configured resource loaders.  {@link
     * org.apache.velocity.runtime.resource.Resource} is the generic
     * description of templates, static content, etc.</p>
     *
     * <p>Note that the current implementation will <b>not</b> change
     * the state of the system in any real way - so this cannot be
     * used to pre-load the resource cache, as the previous
     * implementation did as a side-effect.</p>
     *
     * @param resourceName The name of the resource to search for.
     * @return Whether the resource was located.
     */
    public static boolean resourceExists(String resourceName)
    {
        return (RuntimeSingleton.getLoaderNameForResource(resourceName) != null);
    }
    /**
     * Returns a convenient Log instance that wraps the current LogChute.
     * Use this to log error messages. It has the usual methods.
     *
     * @return A convenience Log instance that wraps the current LogChute.
     * @since 1.5
     */
    public static Log getLog()
    {
        return RuntimeSingleton.getLog();
    }
    /**
     * @deprecated Use getLog() and call warn() on it.
     * @see Log#warn(Object)
     * @param message The message to log.
     */
    public static void warn(Object message)
    {
        getLog().warn( message );
    }
    /**
     * @deprecated Use getLog() and call info() on it.
     * @see Log#info(Object)
     * @param message The message to log.
     */
    public static void info(Object message)
    {
        getLog().info( message );
    }
    /**
     * @deprecated Use getLog() and call error() on it.
     * @see Log#error(Object)
     * @param message The message to log.
     */
    public static void error(Object message)
    {
        getLog().error( message );
    }
    /**
     * @deprecated Use getLog() and call debug() on it.
     * @see Log#debug(Object)
     * @param message The message to log.
     */
    public static void debug(Object message)
    {
        getLog().debug( message );
    }
    /**
     *  <p>
     *  Set the an ApplicationAttribue, which is an Object
     *  set by the application which is accessable from
     *  any component of the system that gets a RuntimeServices.
     *  This allows communication between the application
     *  environment and custom pluggable components of the
     *  Velocity engine, such as loaders and loggers.
     *  </p>
     *
     *  <p>
     *  Note that there is no enfocement or rules for the key
     *  used - it is up to the application developer.  However, to
     *  help make the intermixing of components possible, using
     *  the target Class name (e.g.  com.foo.bar ) as the key
     *   might help avoid collision.
     *  </p>
     *
     *  @param key object 'name' under which the object is stored
     *  @param value object to store under this key
     */
     public static void setApplicationAttribute( Object key, Object value )
     {
        RuntimeSingleton.getRuntimeInstance().setApplicationAttribute( key, value);
     }
    /**
     * @param resourceName Name of the Template to check.
     * @return True if the template exists.
     * @see #resourceExists(String)
     * @deprecated Use resourceExists(String) instead.
     */
    public static boolean templateExists(String resourceName)
    {
        return resourceExists(resourceName);
    }
}
"
org.apache.velocity.app.VelocityEngine,"package org.apache.velocity.app;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.util.Properties;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.velocity.Template;
import org.apache.velocity.context.Context;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeInstance;
import org.apache.velocity.runtime.log.Log;
/**
 * <p>
 * This class provides a separate new-able instance of the
 * Velocity template engine.  The alternative model for use
 * is using the Velocity class which employs the singleton
 * model.
 * </p>
 * <p>Velocity will call
 * the parameter-less init() at the first use of this class
 * if the init() wasn't explicitly called.  While this will
 * ensure that Velocity functions, it probably won't
 * function in the way you intend, so it is strongly recommended that
 * you call an init() method yourself if you use the default constructor.
 * </p>
 *
 * @version $Id: VelocityEngine.java 687177 2008-08-19 22:00:32Z nbubna $
 */
public class VelocityEngine implements RuntimeConstants
{
    private RuntimeInstance ri = new RuntimeInstance();
    /**
     *  Init-less CTOR
     */
    public VelocityEngine()
    {
        // do nothing
    }
    /**
     *  CTOR that invokes an init(String), initializing
     *  the engine using the properties file specified
     *
     * @param propsFilename name of properties file to init with
     * @throws Exception
     * @since 1.5
     */
    public VelocityEngine(String propsFilename)
        throws Exception
    {
        ri.init(propsFilename);
    }
    /**
     *  CTOR that invokes an init(String), initializing
     *  the engine using the Properties specified
     *
     * @param p name of properties  to init with
     * @throws Exception
     * @since 1.5
     */
    public VelocityEngine(Properties p)
        throws Exception
    {
        ri.init(p);
    }
    /**
     *  initialize the Velocity runtime engine, using the default
     *  properties of the Velocity distribution
     * @throws Exception
     */
    public void init()
        throws Exception
    {
        ri.init();
    }
    /**
     *  initialize the Velocity runtime engine, using default properties
     *  plus the properties in the properties file passed in as the arg
     *
     *  @param propsFilename file containing properties to use to initialize
     *         the Velocity runtime
     * @throws Exception
     */
    public void init(String propsFilename)
        throws Exception
    {
        ri.init(propsFilename);
    }
    /**
     *  initialize the Velocity runtime engine, using default properties
     *  plus the properties in the passed in java.util.Properties object
     *
     *  @param p  Proprties object containing initialization properties
     * @throws Exception
     *
     */
    public void init(Properties p)
        throws Exception
    {
        ri.init(p);
    }
    /**
     * Set a Velocity Runtime property.
     *
     * @param  key
     * @param  value
     */
    public void setProperty(String key, Object value)
    {
        ri.setProperty(key,value);
    }
    /**
     * Add a Velocity Runtime property.
     *
     * @param  key
     * @param  value
     */
    public void addProperty(String key, Object value)
    {
        ri.addProperty(key,value);
    }
    /**
     * Clear a Velocity Runtime property.
     *
     * @param key of property to clear
     */
    public void clearProperty(String key)
    {
        ri.clearProperty(key);
    }
    /**
     * Set an entire configuration at once. This is
     * useful in cases where the parent application uses
     * the ExtendedProperties class and the velocity configuration
     * is a subset of the parent application's configuration.
     *
     * @param  configuration
     *
     */
    public void setExtendedProperties( ExtendedProperties configuration)
    {
        ri.setConfiguration( configuration );
    }
    /**
     *  Get a Velocity Runtime property.
     *
     *  @param key property to retrieve
     *  @return property value or null if the property
     *        not currently set
     */
    public Object getProperty( String key )
    {
        return ri.getProperty( key );
    }
    /**
     *  renders the input string using the context into the output writer.
     *  To be used when a template is dynamically constructed, or want to use
     *  Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param out  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log
     *                 messages in case of error
     *  @param instring input string containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see
     *             Velocity runtime log
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws IOException While rendering to the writer, an I/O problem occured.
     */
    public  boolean evaluate( Context context,  Writer out,
                                     String logTag, String instring )
        throws ParseErrorException, MethodInvocationException,
            ResourceNotFoundException, IOException
    {
        return ri.evaluate(context, out, logTag, instring);
    }
    /**
     *  Renders the input stream using the context into the output writer.
     *  To be used when a template is dynamically constructed, or want to
     *  use Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param writer  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log messages
     *                 in case of error
     *  @param instream input stream containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see
     *               Velocity runtime log
     * @throws ParseErrorException
     * @throws MethodInvocationException
     * @throws ResourceNotFoundException
     * @throws IOException
     *  @deprecated Use
     *  {@link #evaluate( Context context, Writer writer,
     *      String logTag, Reader reader ) }
     */
    public boolean evaluate( Context context, Writer writer,
                                    String logTag, InputStream instream )
        throws ParseErrorException, MethodInvocationException,
            ResourceNotFoundException, IOException
    {
        /*
         *  first, parse - convert ParseException if thrown
         */
        BufferedReader br  = null;
        String encoding = null;
        try
        {
            encoding = ri.getString(INPUT_ENCODING,ENCODING_DEFAULT);
            br = new BufferedReader(  new InputStreamReader( instream, encoding));
        }
        catch( UnsupportedEncodingException  uce )
        {
            String msg = ""Unsupported input encoding : "" + encoding
                + "" for template "" + logTag;
            throw new ParseErrorException( msg );
        }
        return evaluate( context, writer, logTag, br );
    }
    /**
     *  Renders the input reader using the context into the output writer.
     *  To be used when a template is dynamically constructed, or want to
     *  use Velocity as a token replacer.
     *
     *  @param context context to use in rendering input string
     *  @param writer  Writer in which to render the output
     *  @param logTag  string to be used as the template name for log messages
     *                 in case of error
     *  @param reader Reader containing the VTL to be rendered
     *
     *  @return true if successful, false otherwise.  If false, see
     *               Velocity runtime log
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws IOException While reading from the reader or rendering to the writer,
     *                     an I/O problem occured.
     *  @since Velocity v1.1
     */
    public boolean evaluate(Context context, Writer writer,
                                    String logTag, Reader reader)
        throws ParseErrorException, MethodInvocationException,
            ResourceNotFoundException,IOException
    {
        return ri.evaluate(context, writer, logTag, reader);
    }
    /**
     * Invokes a currently registered Velocimacro with the params provided
     * and places the rendered stream into the writer.
     * <br>
     * Note : currently only accepts args to the VM if they are in the context.
     *
     * @param vmName name of Velocimacro to call
     * @param logTag string to be used for template name in case of error. if null,
     *               the vmName will be used
     * @param params keys for args used to invoke Velocimacro, in java format
     *               rather than VTL (eg  ""foo"" or ""bar"" rather than ""$foo"" or ""$bar"")
     * @param context Context object containing data/objects used for rendering.
     * @param writer  Writer for output stream
     * @return true if Velocimacro exists and successfully invoked, false otherwise.
     * @throws IOException While rendering to the writer, an I/O problem occured.
     */
    public boolean invokeVelocimacro( String vmName, String logTag,
                                              String params[], Context context,
                                              Writer writer )
        throws Exception
    {
        return ri.invokeVelocimacro(vmName, logTag, params, context, writer);
    }
    /**
     *  Merges a template and puts the rendered stream into the writer.
     *  The default encoding that Velocity uses to read template files is defined in
     *  the property input.encoding and defaults to ISO-8859-1.
     *
     *  @param templateName name of template to be used in merge
     *  @param context  filled context to be used in merge
     *  @param  writer  writer to write template into
     *
     *  @return true if successful, false otherwise.  Errors
     *           logged to velocity log.
     * @throws ResourceNotFoundException
     * @throws ParseErrorException
     * @throws MethodInvocationException
     * @throws Exception
     * @deprecated Use
     *  {@link #mergeTemplate( String templateName, String encoding,
     *                Context context, Writer writer )}
     */
    public boolean mergeTemplate( String templateName,
                                         Context context, Writer writer )
        throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, Exception
    {
        return mergeTemplate( templateName, ri.getString(INPUT_ENCODING,ENCODING_DEFAULT),
                               context, writer );
    }
    /**
     *  merges a template and puts the rendered stream into the writer
     *
     *  @param templateName name of template to be used in merge
     *  @param encoding encoding used in template
     *  @param context  filled context to be used in merge
     *  @param  writer  writer to write template into
     *
     *  @return true if successful, false otherwise.  Errors
     *           logged to velocity log
     * @throws ResourceNotFoundException
     * @throws ParseErrorException
     * @throws MethodInvocationException
     * @throws Exception
     *
     *  @since Velocity v1.1
     */
    public boolean mergeTemplate( String templateName, String encoding,
                                      Context context, Writer writer )
        throws ResourceNotFoundException, ParseErrorException, MethodInvocationException, Exception
    {
        Template template = ri.getTemplate(templateName, encoding);
        if ( template == null )
        {
            String msg = ""VelocityEngine.mergeTemplate() was unable to load template '""
                           + templateName + ""'"";
            getLog().error(msg);
            throw new ResourceNotFoundException(msg);
        }
        else
        {
            template.merge(context, writer);
            return true;
         }
    }
    /**
     *  Returns a <code>Template</code> from the Velocity
     *  resource management system.
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getTemplate( name );
    }
    /**
     *  Returns a <code>Template</code> from the Velocity
     *  resource management system.
     *
     * @param name The file name of the desired template.
     * @param encoding The character encoding to use for the template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     *
     *  @since Velocity v1.1
     */
    public Template getTemplate(String name, String encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getTemplate( name, encoding );
    }
    /**
     *   Determines if a resource is accessable via the currently
     *   configured resource loaders.
     *   <br><br>
     *   Note that the current implementation will <b>not</b>
     *   change the state of the system in any real way - so this
     *   cannot be used to pre-load the resource cache, as the
     *   previous implementation did as a side-effect.
     *   <br><br>
     *   The previous implementation exhibited extreme lazyness and
     *   sloth, and the author has been flogged.
     *
     *   @param resourceName  name of the resource to search for
     *   @return true if found, false otherwise
     *   @since 1.5
     */
    public boolean resourceExists(String resourceName)
    {
        return (ri.getLoaderNameForResource(resourceName) != null);
    }
    /**
     * @param resourceName
     * @return True if the template exists.
     * @see #resourceExists(String)
     * @deprecated Use resourceExists(String) instead.
     */
    public boolean templateExists(String resourceName)
    {
        return resourceExists(resourceName);
    }
    /**
     * Returns a convenient Log instance that wraps the current LogChute.
     * Use this to log error messages. It has the usual methods you'd expect.
     * @return A log object.
     * @since 1.5
     */
    public Log getLog()
    {
        return ri.getLog();
    }
    /**
     * @param message
     * @deprecated Use getLog() and call warn() on it.
     */
    public void warn(Object message)
    {
        getLog().warn(message);
    }
    /**
     * @param message
     * @deprecated Use getLog() and call warn() on it.
     */
    public void info(Object message)
    {
        getLog().info(message);
    }
    /**
     * @param message
     * @deprecated Use getLog() and call warn() on it.
     */
    public void error(Object message)
    {
        getLog().error(message);
    }
    /**
     * @param message
     * @deprecated Use getLog() and call warn() on it.
     */
    public void debug(Object message)
    {
        getLog().debug(message);
    }
    /**
     *  <p>
     *  Sets an application attribute (which can be any Object) that will be
     *  accessible from any component of the system that gets a
     *  RuntimeServices. This allows communication between the application
     *  environment and custom pluggable components of the Velocity engine,
     *  such as ResourceLoaders and LogChutes.
     *  </p>
     *
     *  <p>
     *  Note that there is no enforcement or rules for the key
     *  used - it is up to the application developer.  However, to
     *  help make the intermixing of components possible, using
     *  the target Class name (e.g. com.foo.bar ) as the key
     *  might help avoid collision.
     *  </p>
     *
     *  @param key object 'name' under which the object is stored
     *  @param value object to store under this key
     */
     public void setApplicationAttribute( Object key, Object value )
     {
        ri.setApplicationAttribute(key, value);
     }
     /**
      *  <p>
      *  Return an application attribute (which can be any Object)
      *  that was set by the application in order to be accessible from
      *  any component of the system that gets a RuntimeServices.
      *  This allows communication between the application
      *  environment and custom pluggable components of the
      *  Velocity engine, such as ResourceLoaders and LogChutes.
      *  </p>
      *
      *  @param key object 'name' under which the object is stored
      *  @return value object to store under this key
      * @since 1.5
      */
     public Object getApplicationAttribute( Object key )
     {
        return ri.getApplicationAttribute(key);
     }
}
"
org.apache.velocity.app.event.EventCartridge,"package org.apache.velocity.app.event;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import org.apache.velocity.context.Context;
import org.apache.velocity.context.InternalEventContext;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.RuntimeServicesAware;
/**
 * Stores the event handlers. Event handlers can be assigned on a per
 * VelocityEngine instance basis by specifying the class names in the
 * velocity.properties file. Event handlers may also be assigned on a per-page
 * basis by creating a new instance of EventCartridge, adding the event
 * handlers, and then calling attachToContext. For clarity, it's recommended
 * that one approach or the other be followed, as the second method is primarily
 * presented for backwards compatibility.
 *
 * <P>
 * Note that Event Handlers follow a filter pattern, with multiple event
 * handlers allowed for each event. When the appropriate event occurs, all the
 * appropriate event handlers are called in the sequence they were added to the
 * Event Cartridge. See the javadocs of the specific event handler interfaces
 * for more details.
 *
 * @author <a href=""mailto:wglass@wglass@forio.com"">Will Glass-Husain </a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr. </a>
 * @author <a href=""mailto:j_a_fernandez@yahoo.com"">Jose Alberto Fernandez </a>
 * @version $Id: EventCartridge.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public class EventCartridge
  {
    private List referenceHandlers = new ArrayList();
    private List nullSetHandlers = new ArrayList();
    private List methodExceptionHandlers = new ArrayList();
    private List includeHandlers = new ArrayList();
    private List invalidReferenceHandlers = new ArrayList();
    /**
     * Ensure that handlers are not initialized more than once.
     */
    Set initializedHandlers = new HashSet();
    /**
     *  Adds an event handler(s) to the Cartridge.  This method
     *  will find all possible event handler interfaces supported
     *  by the passed in object.
     *
     *  @param ev object impementing a valid EventHandler-derived interface
     *  @return true if a supported interface, false otherwise or if null
     */
    public boolean addEventHandler( EventHandler ev )
    {
        if (ev == null)
        {
            return false;
        }
        boolean found = false;
        if ( ev instanceof ReferenceInsertionEventHandler)
        {
            addReferenceInsertionEventHandler( (ReferenceInsertionEventHandler) ev );
            found = true;
        }
        if ( ev instanceof NullSetEventHandler )
        {
            addNullSetEventHandler( (NullSetEventHandler) ev );
            found = true;
        }
        if ( ev instanceof MethodExceptionEventHandler )
        {
            addMethodExceptionHandler( (MethodExceptionEventHandler) ev );
            found = true;
        }
        if ( ev instanceof IncludeEventHandler )
        {
            addIncludeEventHandler( (IncludeEventHandler) ev );
            found = true;
        }
        if ( ev instanceof InvalidReferenceEventHandler )
        {
            addInvalidReferenceEventHandler( (InvalidReferenceEventHandler) ev );
            found = true;
        }
        return found;
    }
    /**
      *  Add a reference insertion event handler to the Cartridge.
      *
      *  @param ev ReferenceInsertionEventHandler
     * @since 1.5
     */
     public void addReferenceInsertionEventHandler( ReferenceInsertionEventHandler ev )
     {
         referenceHandlers.add( ev );
     }
    /**
      *  Add a null set event handler to the Cartridge.
      *
      *  @param ev NullSetEventHandler
      * @since 1.5
      */
     public void addNullSetEventHandler( NullSetEventHandler ev )
     {
         nullSetHandlers.add( ev );
     }
    /**
     *  Add a method exception event handler to the Cartridge.
     *
     *  @param ev MethodExceptionEventHandler
     *  @since 1.5
     */
    public void addMethodExceptionHandler( MethodExceptionEventHandler ev )
    {
        methodExceptionHandlers.add( ev );
    }
    /**
     *  Add an include event handler to the Cartridge.
     *
     *  @param ev IncludeEventHandler
     *  @since 1.5
     */
    public void addIncludeEventHandler( IncludeEventHandler ev )
    {
        includeHandlers.add( ev );
    }
    /**
     *  Add an invalid reference event handler to the Cartridge.
     *
     *  @param ev InvalidReferenceEventHandler
     *  @since 1.5
     */
    public void addInvalidReferenceEventHandler( InvalidReferenceEventHandler ev )
    {
        invalidReferenceHandlers.add( ev );
    }
    /**
     * Removes an event handler(s) from the Cartridge. This method will find all
     * possible event handler interfaces supported by the passed in object and
     * remove them.
     *
     * @param ev  object impementing a valid EventHandler-derived interface
     * @return true if event handler was previously registered, false if not
     *         found
     */
    public boolean removeEventHandler( EventHandler ev )
    {
        if ( ev == null )
        {
            return false;
        }
        boolean found = false;
        if ( ev instanceof ReferenceInsertionEventHandler )
            return referenceHandlers.remove( ev );
        if ( ev instanceof NullSetEventHandler )
            return nullSetHandlers.remove( ev );
        if ( ev instanceof MethodExceptionEventHandler )
            return methodExceptionHandlers.remove(ev );
        if ( ev instanceof IncludeEventHandler )
            return includeHandlers.remove( ev );
        if ( ev instanceof InvalidReferenceEventHandler )
            return invalidReferenceHandlers.remove( ev );
        return found;
    }
    /**
     * Iterate through all the stored ReferenceInsertionEventHandler objects
     * 
     * @return iterator of handler objects, null if there are not handlers
     * @since 1.5
     */
    public Iterator getReferenceInsertionEventHandlers()
    {
        return referenceHandlers.size() == 0 ? null : referenceHandlers.iterator();
    }
    /**
     * Iterate through all the stored NullSetEventHandler objects
     * 
     * @return iterator of handler objects
     * @since 1.5
     */
    public Iterator getNullSetEventHandlers()
    {
        return nullSetHandlers.iterator();
    }
    /**
     * Iterate through all the stored MethodExceptionEventHandler objects
     * 
     * @return iterator of handler objects
     * @since 1.5
     */
    public Iterator getMethodExceptionEventHandlers()
    {
        return methodExceptionHandlers.iterator();
    }
    /**
     * Iterate through all the stored IncludeEventHandlers objects
     * 
     * @return iterator of handler objects
     */
    public Iterator getIncludeEventHandlers()
    {
        return includeHandlers.iterator();
    }
    /**
     * Iterate through all the stored InvalidReferenceEventHandlers objects
     * 
     * @return iterator of handler objects
     * @since 1.5
     */
    public Iterator getInvalidReferenceEventHandlers()
    {
        return invalidReferenceHandlers.iterator();
    }
    /**
     *  Attached the EventCartridge to the context
     *
     *  Final because not something one should mess with lightly :)
     *
     *  @param context context to attach to
     *  @return true if successful, false otherwise
     */
    public final boolean attachToContext( Context context )
    {
        if (  context instanceof InternalEventContext )
        {
            InternalEventContext iec = (InternalEventContext) context;
            iec.attachEventCartridge( this );
            /**
             * while it's tempting to call setContext on each handler from here,
             * this needs to be done before each method call.  This is
             * because the specific context will change as inner contexts
             * are linked in through macros, foreach, or directly by the user.
             */
            return true;
        }
        else
        {
            return false;
        }
    }
    /**
     * Initialize the handlers.  For global handlers this is called when Velocity
     * is initialized. For local handlers this is called when the first handler
     * is executed.  Handlers will not be initialized more than once.
     * 
     * @param rs
     * @throws Exception
     * @since 1.5
     */
    public void initialize (RuntimeServices rs) throws Exception
    {
        for ( Iterator i = referenceHandlers.iterator(); i.hasNext(); )
        {
            EventHandler eh = ( EventHandler ) i.next();
            if ( (eh instanceof RuntimeServicesAware) &&
                    !initializedHandlers.contains(eh) )
            {
                ((RuntimeServicesAware) eh).setRuntimeServices ( rs );
                initializedHandlers.add( eh );
            }
        }
        for ( Iterator i = nullSetHandlers.iterator(); i.hasNext(); )
        {
            EventHandler eh = ( EventHandler ) i.next();
            if ( (eh instanceof RuntimeServicesAware) &&
                    !initializedHandlers.contains(eh) )
            {
                ((RuntimeServicesAware) eh).setRuntimeServices ( rs );
                initializedHandlers.add( eh );
            }
        }
        for ( Iterator i = methodExceptionHandlers.iterator(); i.hasNext(); )
        {
            EventHandler eh = ( EventHandler ) i.next();
            if ( (eh instanceof RuntimeServicesAware) &&
                    !initializedHandlers.contains(eh) )
            {
                ((RuntimeServicesAware) eh).setRuntimeServices ( rs );
                initializedHandlers.add( eh );
            }
        }
        for ( Iterator i = includeHandlers.iterator(); i.hasNext(); )
        {
            EventHandler eh = ( EventHandler ) i.next();
            if ( (eh instanceof RuntimeServicesAware) &&
                    !initializedHandlers.contains(eh) )
            {
                ((RuntimeServicesAware) eh).setRuntimeServices ( rs );
                initializedHandlers.add( eh );
            }
        }
        for ( Iterator i = invalidReferenceHandlers.iterator(); i.hasNext(); )
        {
            EventHandler eh = ( EventHandler ) i.next();
            if ( (eh instanceof RuntimeServicesAware) &&
                    !initializedHandlers.contains(eh) )
            {
                ((RuntimeServicesAware) eh).setRuntimeServices ( rs );
                initializedHandlers.add( eh );
            }
        }
    }
}
"
org.apache.velocity.app.event.EventHandler,"package org.apache.velocity.app.event;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * Base interface for all event handlers
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: EventHandler.java 463298 2006-10-12 16:10:32Z henning $
 */
public interface  EventHandler
{
}
"
org.apache.velocity.app.event.EventHandlerMethodExecutor,"package org.apache.velocity.app.event;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/** 
 * Strategy object used to execute event handler method.  Will be called
 * while looping through all the chained event handler implementations.
 * Each EventHandler method call should have a parallel executor object
 * defined.  
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: EventHandlerMethodExecutor.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public interface EventHandlerMethodExecutor
{
    /**
     * Execute the event handler method.  If Object is not null, do not 
     * iterate further through the handler chain.
     * If appropriate, the returned Object will be the return value.
     *  
     * @param handler call the appropriate method on this handler
     * @exception Exception generic exception potentially thrown by event handlers
     */
    public void execute(EventHandler handler) throws Exception;
    /**
     * Called after execute() to see if iterating should stop. Should
     * always return false before method execute() is run.
     * 
     * @return true if no more event handlers for this method should be called.
     */
    public boolean isDone();
    /**
     * Get return value at end of all the iterations
     * 
     * @return null if no return value is required
     */
    public Object getReturnValue();
}
"
org.apache.velocity.app.event.EventHandlerUtil,"package org.apache.velocity.app.event;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Iterator;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.ExceptionUtils;
import org.apache.velocity.util.introspection.Info;
/**
 * Calls on request all registered event handlers for a particular event. Each
 * method accepts two event cartridges (typically one from the application and
 * one from the context). All appropriate event handlers are executed in order
 * until a stopping condition is met. See the docs for the individual methods to
 * see what the stopping condition is for that method.
 *
 * @author <a href=""mailto:wglass@wglass@forio.com"">Will Glass-Husain </a>
 * @version $Id: EventHandlerUtil.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class EventHandlerUtil {
    /**
     * Called before a reference is inserted. All event handlers are called in
     * sequence. The default implementation inserts the reference as is.
     * 
     * This is a major hotspot method called by ASTReference render.
     *
     * @param reference reference from template about to be inserted
     * @param value value about to be inserted (after toString() )
     * @param rsvc current instance of RuntimeServices
     * @param context The internal context adapter.
     * @return Object on which toString() should be called for output.
     */
    public static Object referenceInsert(RuntimeServices rsvc,
            InternalContextAdapter context, String reference, Object value)
    {
        // app level cartridges have already been initialized
        /*
         * Performance modification: EventCartridge.getReferenceInsertionEventHandlers
         * now returns a null if there are no handlers. Thus we can avoid creating the
         * Iterator object.
         */
        EventCartridge ev1 = rsvc.getApplicationEventCartridge();
        Iterator applicationEventHandlerIterator = 
            (ev1 == null) ? null: ev1.getReferenceInsertionEventHandlers();              
        EventCartridge ev2 = context.getEventCartridge();
        initializeEventCartridge(rsvc, ev2);
        Iterator contextEventHandlerIterator = 
            (ev2 == null) ? null: ev2.getReferenceInsertionEventHandlers();              
        try 
        {
            /*
             * Performance modification: methodExecutor is created only if one of the
             * iterators is not null.
             */
            EventHandlerMethodExecutor methodExecutor = null; 
            if( applicationEventHandlerIterator != null )
            {
                methodExecutor = 
                    new ReferenceInsertionEventHandler.referenceInsertExecutor(context, reference, value);
                iterateOverEventHandlers(applicationEventHandlerIterator, methodExecutor);
            }
            if( contextEventHandlerIterator != null )
            {
                if( methodExecutor == null )
                    methodExecutor = 
                        new ReferenceInsertionEventHandler.referenceInsertExecutor(context, reference, value);
                iterateOverEventHandlers(contextEventHandlerIterator, methodExecutor);
            }
            return methodExecutor != null ? methodExecutor.getReturnValue() : value;   
        }
        catch (RuntimeException e)
        {
            throw e;
        }
        catch (Exception e)
        {
            throw ExceptionUtils.createRuntimeException(""Exception in event handler."",e);
        }
    }
    /**
     * Called when a null is evaluated during a #set. All event handlers are
     * called in sequence until a false is returned. The default implementation
     * always returns true.
     *
     * @param lhs Left hand side of the expression.
     * @param rhs Right hand side of the expression.
     * @param rsvc current instance of RuntimeServices
     * @param context The internal context adapter.
     * @return true if to be logged, false otherwise
     */
    public static boolean shouldLogOnNullSet(RuntimeServices rsvc,
            InternalContextAdapter context, String lhs, String rhs)
    {
        // app level cartridges have already been initialized
        EventCartridge ev1 = rsvc.getApplicationEventCartridge();
        Iterator applicationEventHandlerIterator = 
            (ev1 == null) ? null: ev1.getNullSetEventHandlers();              
        EventCartridge ev2 = context.getEventCartridge();
        initializeEventCartridge(rsvc, ev2);
        Iterator contextEventHandlerIterator = 
            (ev2 == null) ? null: ev2.getNullSetEventHandlers();              
        try 
        {
            EventHandlerMethodExecutor methodExecutor = 
                new NullSetEventHandler.ShouldLogOnNullSetExecutor(context, lhs, rhs);
            callEventHandlers(
                    applicationEventHandlerIterator, 
                    contextEventHandlerIterator, methodExecutor);
            return ((Boolean) methodExecutor.getReturnValue()).booleanValue();    
        }
        catch (RuntimeException e)
        {
            throw e;
        }
        catch (Exception e)
        {
            throw ExceptionUtils.createRuntimeException(""Exception in event handler."",e);
        }
    }
    /**
     * Called when a method exception is generated during Velocity merge. Only
     * the first valid event handler in the sequence is called. The default
     * implementation simply rethrows the exception.
     *
     * @param claz
     *            Class that is causing the exception
     * @param method
     *            method called that causes the exception
     * @param e
     *            Exception thrown by the method
     * @param rsvc current instance of RuntimeServices
     * @param context The internal context adapter.
     * @return Object to return as method result
     * @throws Exception
     *             to be wrapped and propogated to app
     */
    public static Object methodException(RuntimeServices rsvc,
            InternalContextAdapter context, Class claz, String method,
            Exception e) throws Exception 
    {
        // app level cartridges have already been initialized
        EventCartridge ev1 = rsvc.getApplicationEventCartridge();
        Iterator applicationEventHandlerIterator = 
            (ev1 == null) ? null: ev1.getMethodExceptionEventHandlers();              
        EventCartridge ev2 = context.getEventCartridge();
        initializeEventCartridge(rsvc, ev2);
        Iterator contextEventHandlerIterator = 
            (ev2 == null) ? null: ev2.getMethodExceptionEventHandlers();              
        EventHandlerMethodExecutor methodExecutor = 
            new MethodExceptionEventHandler.MethodExceptionExecutor(context, claz, method, e);
        if ( ((applicationEventHandlerIterator == null) || !applicationEventHandlerIterator.hasNext()) &&
                ((contextEventHandlerIterator == null) || !contextEventHandlerIterator.hasNext()) )
        {
            throw e;
        }
        callEventHandlers(
                applicationEventHandlerIterator, 
                contextEventHandlerIterator, methodExecutor);
        return methodExecutor.getReturnValue();
    }
    /**
     * Called when an include-type directive is encountered (#include or
     * #parse). All the registered event handlers are called unless null is
     * returned. The default implementation always processes the included
     * resource.
     *
     * @param includeResourcePath
     *            the path as given in the include directive.
     * @param currentResourcePath
     *            the path of the currently rendering template that includes the
     *            include directive.
     * @param directiveName
     *            name of the directive used to include the resource. (With the
     *            standard directives this is either ""parse"" or ""include"").
     * @param rsvc current instance of RuntimeServices
     * @param context The internal context adapter.
     *
     * @return a new resource path for the directive, or null to block the
     *         include from occurring.
     */
    public static String includeEvent(RuntimeServices rsvc,
            InternalContextAdapter context, String includeResourcePath,
            String currentResourcePath, String directiveName)
    {
        // app level cartridges have already been initialized
        EventCartridge ev1 = rsvc.getApplicationEventCartridge();
        Iterator applicationEventHandlerIterator = 
            (ev1 == null) ? null: ev1.getIncludeEventHandlers();              
        EventCartridge ev2 = context.getEventCartridge();
        initializeEventCartridge(rsvc, ev2);
        Iterator contextEventHandlerIterator = 
            (ev2 == null) ? null: ev2.getIncludeEventHandlers();              
        try 
        {
            EventHandlerMethodExecutor methodExecutor = 
                new IncludeEventHandler.IncludeEventExecutor(
                        context, includeResourcePath, 
                        currentResourcePath, directiveName);
            callEventHandlers(
                    applicationEventHandlerIterator, 
                    contextEventHandlerIterator, methodExecutor);
            return (String) methodExecutor.getReturnValue();
        }
        catch (RuntimeException e)
        {
            throw e;
        }
        catch (Exception e)
        {
            throw ExceptionUtils.createRuntimeException(""Exception in event handler."",e);
        }
    }
    /**
     * Called when an invalid get method is encountered.
     * 
     * @param rsvc current instance of RuntimeServices
     * @param context the context when the reference was found invalid
     * @param reference complete invalid reference
     * @param object object from reference, or null if not available
     * @param property name of property, or null if not relevant
     * @param info contains info on template, line, col
     * @return substitute return value for missing reference, or null if no substitute
     */
    public static Object invalidGetMethod(RuntimeServices rsvc,
            InternalContextAdapter context, String reference, 
            Object object, String property, Info info)
    {
        return  
        invalidReferenceHandlerCall (
                new InvalidReferenceEventHandler.InvalidGetMethodExecutor
                (context, reference, object, property, info),
                rsvc, 
                context);       
    }
   /**
     * Called when an invalid set method is encountered.
     * 
     * @param rsvc current instance of RuntimeServices
     * @param context the context when the reference was found invalid
     * @param leftreference left reference being assigned to
     * @param rightreference invalid reference on the right
     * @param info contains info on template, line, col
     */
    public static void invalidSetMethod(RuntimeServices rsvc,
            InternalContextAdapter context, String leftreference, 
            String rightreference, Info info)
    {
        /**
         * ignore return value
         */
        invalidReferenceHandlerCall (
                new InvalidReferenceEventHandler.InvalidSetMethodExecutor
                (context, leftreference, rightreference, info),
                rsvc, 
                context);   
    }
    /**
     * Called when an invalid method is encountered.
     * 
     * @param rsvc current instance of RuntimeServices
     * @param context the context when the reference was found invalid
     * @param reference complete invalid reference
     * @param object object from reference, or null if not available
     * @param method name of method, or null if not relevant
     * @param info contains info on template, line, col
     * @return substitute return value for missing reference, or null if no substitute
     */
    public static Object invalidMethod(RuntimeServices rsvc,
            InternalContextAdapter context,  String reference,
            Object object, String method, Info info)
    {
        return 
        invalidReferenceHandlerCall (
                new InvalidReferenceEventHandler.InvalidMethodExecutor
                (context, reference, object, method, info),
                rsvc, 
                context);       
    }
    /**
     * Calls event handler method with appropriate chaining across event handlers.
     * 
     * @param methodExecutor
     * @param rsvc current instance of RuntimeServices
     * @param context The current context
     * @return return value from method, or null if no return value
     */
    public static Object invalidReferenceHandlerCall(
            EventHandlerMethodExecutor methodExecutor, 
            RuntimeServices rsvc,
            InternalContextAdapter context)
    {
        // app level cartridges have already been initialized
        EventCartridge ev1 = rsvc.getApplicationEventCartridge();
        Iterator applicationEventHandlerIterator = 
            (ev1 == null) ? null: ev1.getInvalidReferenceEventHandlers();              
        EventCartridge ev2 = context.getEventCartridge();
        initializeEventCartridge(rsvc, ev2);
        Iterator contextEventHandlerIterator = 
            (ev2 == null) ? null: ev2.getInvalidReferenceEventHandlers();              
        try
        {
            callEventHandlers(
                    applicationEventHandlerIterator, 
                    contextEventHandlerIterator, methodExecutor);
            return methodExecutor.getReturnValue();
        }
        catch (RuntimeException e)
        {
            throw e;
        }
        catch (Exception e)
        {
            throw ExceptionUtils.createRuntimeException(""Exception in event handler."",e);
        }
    }
    /**
     * Initialize the event cartridge if appropriate.
     * 
     * @param rsvc current instance of RuntimeServices
     * @param eventCartridge the event cartridge to be initialized
     */
    private static void initializeEventCartridge(RuntimeServices rsvc, EventCartridge eventCartridge)
    {
        if (eventCartridge != null)
        {
            try
            {
                eventCartridge.initialize(rsvc);
            }
            catch (Exception e)
            {
                throw ExceptionUtils.createRuntimeException(""Couldn't initialize event cartridge : "", e);
            }
        }
    }
    /**
     * Loop through both the application level and context-attached event handlers.
     * 
     * @param applicationEventHandlerIterator Iterator that loops through all global event handlers declared at application level
     * @param contextEventHandlerIterator Iterator that loops through all global event handlers attached to context
     * @param eventExecutor Strategy object that executes event handler method
     * @exception Exception generic exception potentially thrown by event handlers
     */
    private static void callEventHandlers(
            Iterator applicationEventHandlerIterator, 
            Iterator contextEventHandlerIterator,
            EventHandlerMethodExecutor eventExecutor)
    throws Exception
    {
        /**
         * First loop through the event handlers configured at the app level
         * in the properties file.
         */
        iterateOverEventHandlers(applicationEventHandlerIterator, eventExecutor);
        /**
         * Then loop through the event handlers attached to the context.
         */
        iterateOverEventHandlers(contextEventHandlerIterator, eventExecutor);
    }
    /**
     * Loop through a given iterator of event handlers.
     * 
     * @param handlerIterator Iterator that loops through event handlers
     * @param eventExecutor Strategy object that executes event handler method
     * @exception Exception generic exception potentially thrown by event handlers
     */
    private static void iterateOverEventHandlers(
            Iterator handlerIterator,
            EventHandlerMethodExecutor eventExecutor)
    throws Exception
    {
        if (handlerIterator != null)
        {
            for (Iterator i = handlerIterator; i.hasNext();)
            {
                EventHandler eventHandler = (EventHandler) i.next();
                if (!eventExecutor.isDone())
                {
                    eventExecutor.execute(eventHandler);
                }
            }            
        }
    }
}
"
org.apache.velocity.app.event.IncludeEventHandler,"package org.apache.velocity.app.event;
import org.apache.velocity.context.Context;
import org.apache.velocity.util.ContextAware;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Event handler for include type directives (e.g. <code>#include()</code>, <code>#parse()</code>)
 *  Allows the developer to modify the path of the resource returned.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: IncludeEventHandler.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public interface  IncludeEventHandler extends EventHandler
{
    /**
     * Called when an include-type directive is encountered (
     * <code>#include</code> or <code>#parse</code>). May modify the path
     * of the resource to be included or may block the include entirely. All the
     * registered IncludeEventHandlers are called unless null is returned. If
     * none are registered the template at the includeResourcePath is retrieved.
     *
     * @param includeResourcePath  the path as given in the include directive.
     * @param currentResourcePath the path of the currently rendering template that includes the
     *            include directive.
     * @param directiveName  name of the directive used to include the resource. (With the
     *            standard directives this is either ""parse"" or ""include"").
     *
     * @return a new resource path for the directive, or null to block the
     *         include from occurring.
     */
    public String includeEvent( String includeResourcePath, String currentResourcePath, String directiveName );
    /**
     * Defines the execution strategy for includeEvent
     */
    static class IncludeEventExecutor implements EventHandlerMethodExecutor
    {
        private Context context;
        private String includeResourcePath;
        private String currentResourcePath;
        private String directiveName;
        private boolean executed = false;
        IncludeEventExecutor(
                Context context, 
                String includeResourcePath,
                String currentResourcePath,
                String directiveName)
        {
            this.context = context;
            this.includeResourcePath = includeResourcePath;
            this.currentResourcePath = currentResourcePath;
            this.directiveName = directiveName;
        }
        /**
         * Call the method includeEvent()
         *  
         * @param handler call the appropriate method on this handler
         */
        public void execute(EventHandler handler)
        {
            IncludeEventHandler eh = (IncludeEventHandler) handler;
            if (eh instanceof ContextAware)
                ((ContextAware) eh).setContext(context);
            executed = true;
            includeResourcePath = ((IncludeEventHandler) handler)
                .includeEvent(includeResourcePath, currentResourcePath, directiveName); 
        }
        public Object getReturnValue()
        {
            return includeResourcePath;
        }
        public boolean isDone()
        {
            return executed && (includeResourcePath == null);
        }        
    }
}
"
org.apache.velocity.app.event.InvalidReferenceEventHandler,"package org.apache.velocity.app.event;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.Context;
import org.apache.velocity.util.introspection.Info;
/**
 * Event handler called when an invalid reference is encountered.  Allows 
 * the application to report errors or substitute return values. May be chained
 * in sequence; the behavior will differ per method.
 * 
 * <p>This feature should be regarded as experimental.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: InvalidReferenceEventHandler.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public interface InvalidReferenceEventHandler extends EventHandler
{
    /**
     * Called when object is null or there is no getter for the given 
     * property.  Also called for invalid references without properties.  
     * invalidGetMethod() will be called in sequence for
     * each link in the chain until the first non-null value is
     * returned.
     * 
     * @param context the context when the reference was found invalid
     * @param reference string with complete invalid reference
     * @param object the object referred to, or null if not found
     * @param property the property name from the reference
     * @param info contains template, line, column details
     * @return substitute return value for missing reference, or null if no substitute
     */
    public Object invalidGetMethod(Context context, String reference, 
            Object object, String property, Info info);
    /**
     * Called when object is null or there is no setter for the given 
     * property.  invalidSetMethod() will be called in sequence for
     * each link in the chain until a true value is returned.  It's
     * recommended that false be returned as a default to allow
     * for easy chaining.
     * 
     * @param context the context when the reference was found invalid
     * @param leftreference left reference being assigned to
     * @param rightreference invalid reference on the right
     * @param info contains info on template, line, col
     * 
     * @return if true then stop calling invalidSetMethod along the 
     * chain.
     */
    public boolean invalidSetMethod(Context context, String leftreference, 
            String rightreference, Info info);
    /**
     * Called when object is null or the given method does not exist.
     * invalidMethod() will be called in sequence for each link in 
     * the chain until the first non-null value is returned. 
     * 
     * @param context the context when the reference was found invalid
     * @param reference string with complete invalid reference
     * @param object the object referred to, or null if not found
     * @param method the name of the (non-existent) method
     * @param info contains template, line, column details
     * @return substitute return value for missing reference, or null if no substitute
     */
    public Object invalidMethod(Context context, String reference,  
            Object object, String method, Info info);
    /**
     * Defines the execution strategy for invalidGetMethod
     */
    static class InvalidGetMethodExecutor implements EventHandlerMethodExecutor 
    {
        private Context context;
        private String reference;
        private Object object;
        private String property;
        private Info info;
        private Object result;
        InvalidGetMethodExecutor(
                Context context, 
                String reference, 
                Object object, 
                String property, 
                Info info)
        {
            this.context = context;
            this.reference = reference;
            this.object = object;
            this.property = property;
            this.info = info;
        }
        /**
         * Call the method invalidGetMethod()
         *  
         * @param handler call the appropriate method on this handler
         */
        public void execute(EventHandler handler)
        {
            result = ((InvalidReferenceEventHandler) handler).invalidGetMethod(
                    context, reference, object, property, info);
        }
        public Object getReturnValue()
        {
            return result;
        }
        public boolean isDone()
        {
            return (result != null);
        }                
    }
    /**
     * Defines the execution strategy for invalidGetMethod
     */
    static class InvalidSetMethodExecutor implements EventHandlerMethodExecutor 
    {
        private Context context;
        private String leftreference;
        private String rightreference;
        private Info info;
        private boolean result;
        InvalidSetMethodExecutor(
                Context context, 
                String leftreference, 
                String rightreference, 
                Info info)
        {
            this.context = context;
            this.leftreference = leftreference;
            this.rightreference = rightreference;
            this.info = info;
        }
        /**
         * Call the method invalidSetMethod()
         *  
         * @param handler call the appropriate method on this handler
         */
        public void execute(EventHandler handler)
        {
            result = ((InvalidReferenceEventHandler) handler).invalidSetMethod(
                    context, leftreference, rightreference, info);            
        }        
        public Object getReturnValue()
        {
            return null;
        }
        public boolean isDone()
        {
            return result;
        }        
    }
    /**
     * Defines the execution strategy for invalidGetMethod
     */
    static class InvalidMethodExecutor implements EventHandlerMethodExecutor
    {
        private Context context;
        private String reference;
        private Object object;
        private String method;
        private Info info;
        private Object result;
        private boolean executed = false;
        InvalidMethodExecutor(
                Context context, 
                String reference, 
                Object object,
                String method,
                Info info)
        {
            this.context = context;
            this.reference = reference;
            this.object = object;
            this.method = method;
            this.info = info;
        }
        /**
         * Call the method invalidMethod()
         *  
         * @param handler call the appropriate method on this handler
         */
        public void execute(EventHandler handler)
        {
            executed = true;
            result = ((InvalidReferenceEventHandler) handler).invalidMethod(
                    context, reference, object, method, info);
        }
        public Object getReturnValue()
        {
            return result;
        }
        public boolean isDone()
        {
            return executed && (result != null);
        }        
    }
}
"
org.apache.velocity.app.event.MethodExceptionEventHandler,"package org.apache.velocity.app.event;
import org.apache.velocity.context.Context;
import org.apache.velocity.util.ContextAware;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Event handler called when a method throws an exception.  This gives the
 *  application a chance to deal with it and either
 *  return something nice, or throw.
 *
 *  Please return what you want rendered into the output stream.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: MethodExceptionEventHandler.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public interface MethodExceptionEventHandler extends EventHandler
{
    /**
     * Called when a method throws an exception.
     * Only the first registered MethodExceptionEventHandler is called.  If
     * none are registered a MethodInvocationException is thrown.
     *
     * @param claz the class of the object the method is being applied to
     * @param method the method
     * @param e the thrown exception
     * @return an object to insert in the page
     * @throws Exception an exception to be thrown instead inserting an object
     */
    public Object methodException( Class claz, String method, Exception e )
         throws Exception;
    /**
     * Defines the execution strategy for methodException
     * @since 1.5
     */
    static class MethodExceptionExecutor implements EventHandlerMethodExecutor
    {
        private Context context;
        private Class claz;
        private String method;
        private Exception e;
        private Object result;
        private boolean executed = false;
        MethodExceptionExecutor(
                Context context, 
                Class claz,
                String method,
                Exception e)
        {
            this.context = context;
            this.claz = claz;
            this.method = method;
            this.e = e;
        }
        /**
         * Call the method methodException()
         *  
         * @param handler call the appropriate method on this handler
         * @exception Exception generic exception thrown by methodException event handler method call
         */
        public void execute(EventHandler handler) throws Exception
        {
            MethodExceptionEventHandler eh = (MethodExceptionEventHandler) handler;
            if (eh instanceof ContextAware)
                ((ContextAware) eh).setContext(context);
            executed = true;
            result = ((MethodExceptionEventHandler) handler).methodException(claz, method, e);
        }
        public Object getReturnValue()
        {
            return result;
        }
        /**
         * Only run the first MethodExceptionEventHandler
         * 
         * @return true after this is executed once.
         */
        public boolean isDone()
        {
           return executed;
        }        
    }
}
"
org.apache.velocity.app.event.NullSetEventHandler,"package org.apache.velocity.app.event;
import org.apache.velocity.context.Context;
import org.apache.velocity.util.ContextAware;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Event handler called when the RHS of #set is null.  Lets an app approve / veto
 *  writing a log message based on the specific reference.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: NullSetEventHandler.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public interface NullSetEventHandler extends EventHandler
{
    /**
     * Called when the RHS of a #set() is null, which will result
     * in a null LHS. All NullSetEventHandlers
     * are called in sequence until a false is returned.  If no NullSetEventHandler
     * is registered all nulls will be logged.
     *
     *  @param lhs  reference literal of left-hand-side of set statement
     *  @param rhs  reference literal of right-hand-side of set statement
     *  @return true if log message should be written, false otherwise
     */
    public boolean shouldLogOnNullSet( String lhs, String rhs );
    /**
     * Defines the execution strategy for shouldLogOnNullSet
     * @since 1.5
     */
    static class ShouldLogOnNullSetExecutor implements EventHandlerMethodExecutor
    {
        private Context context;
        private String lhs;
        private String rhs;
        /**
         * when this is false, quit iterating
         */
        private boolean result = true;
        private boolean executed = false;
        ShouldLogOnNullSetExecutor(
                Context context, 
                String lhs, 
                String rhs) 
        {
            this.context = context;
            this.lhs = lhs;
            this.rhs = rhs;
        }
        /**
         * Call the method shouldLogOnNullSet()
         *  
         * @param handler call the appropriate method on this handler
         */
        public void execute(EventHandler handler)
        {
            NullSetEventHandler eh = (NullSetEventHandler) handler;
            if (eh instanceof ContextAware)
                ((ContextAware) eh).setContext(context);
            executed = true;
            result = ((NullSetEventHandler) handler).shouldLogOnNullSet(lhs, rhs); 
        }
        public Object getReturnValue()
        {            
            // return new Boolean(result);
            return result ? Boolean.TRUE : Boolean.FALSE;
        }
        public boolean isDone()
        {
            return executed && !result;
        }        
    }
}
"
org.apache.velocity.app.event.ReferenceInsertionEventHandler,"package org.apache.velocity.app.event;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.Context;
import org.apache.velocity.util.ContextAware;
/**
 *  Reference 'Stream insertion' event handler.  Called with object
 *  that will be inserted into stream via value.toString().
 *
 *  Please return an Object that will toString() nicely :)
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ReferenceInsertionEventHandler.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public interface  ReferenceInsertionEventHandler extends EventHandler
{
    /**
     * A call-back which is executed during Velocity merge before a reference
     * value is inserted into the output stream. All registered
     * ReferenceInsertionEventHandlers are called in sequence. If no
     * ReferenceInsertionEventHandlers are are registered then reference value
     * is inserted into the output stream as is.
     *
     * @param reference Reference from template about to be inserted.
     * @param value Value about to be inserted (after its <code>toString()</code>
     *            method is called).
     * @return Object on which <code>toString()</code> should be called for
     *         output.
     */
    public Object referenceInsert( String reference, Object value  );
    /**
     * Defines the execution strategy for referenceInsert
     * @since 1.5
     */
    static class referenceInsertExecutor implements EventHandlerMethodExecutor
    {
        private Context context;
        private String reference;
        private Object value;
        referenceInsertExecutor(
                Context context, 
                String reference, 
                Object value)
        {
            this.context = context;
            this.reference = reference;
            this.value = value;
        }
        /**
         * Call the method referenceInsert()
         *  
         * @param handler call the appropriate method on this handler
         */
        public void execute(EventHandler handler)
        {
            ReferenceInsertionEventHandler eh = (ReferenceInsertionEventHandler) handler;
            if (eh instanceof ContextAware)
                ((ContextAware) eh).setContext(context);
            /**
             * Every successive call will alter the same value
             */
            value = ((ReferenceInsertionEventHandler) handler).referenceInsert(reference, value); 
        }
        public Object getReturnValue()
        {
            return value;
        }
        /**
         * Continue to end of event handler iteration
         * 
         * @return always returns false
         */
        public boolean isDone()
        {
            return false;
        }        
    }
}
"
org.apache.velocity.app.event.implement.EscapeHtmlReference,"package org.apache.velocity.app.event.implement;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.commons.lang.StringEscapeUtils;
/**
 * Escape all HTML entities.
 * @see <a href=""http://jakarta.apache.org/commons/lang/api/org/apache/commons/lang/StringEscapeUtils.html#escapeHtml(java.lang.String)"">StringEscapeUtils</a>
 * @author wglass
 * @since 1.5
 */
public class EscapeHtmlReference extends EscapeReference
{
    /**
     * Escape all HTML entities.
     * 
     * @param text
     * @return An escaped String.
     * @see <a href=""http://jakarta.apache.org/commons/lang/api/org/apache/commons/lang/StringEscapeUtils.html#escapeHtml(java.lang.String)"">StringEscapeUtils</a>
     */
    protected String escape(Object text)
    {
        return StringEscapeUtils.escapeHtml(text.toString());
    }
    /**
     * @return attribute ""eventhandler.escape.html.match""
     */
    protected String getMatchAttribute()
    {
        return ""eventhandler.escape.html.match"";
    }
}
"
org.apache.velocity.app.event.implement.EscapeJavaScriptReference,"package org.apache.velocity.app.event.implement;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.commons.lang.StringEscapeUtils;
/**
 * Escapes the characters in a String to be suitable for use in JavaScript.
 * @see <a href=""http://jakarta.apache.org/commons/lang/api/org/apache/commons/lang/StringEscapeUtils.html#escapeJavaScript(java.lang.String)"">StringEscapeUtils</a>
 * @author wglass
 * @since 1.5
 */
public class EscapeJavaScriptReference extends EscapeReference
{
    /**
     * Escapes the characters in a String to be suitable for use in JavaScript.
     * 
     * @param text
     * @return An escaped String.
     * @see <a href=""http://jakarta.apache.org/commons/lang/api/org/apache/commons/lang/StringEscapeUtils.html#escapeJavaScript(java.lang.String)"">StringEscapeUtils</a>
     */
    protected String escape(Object text)
    {
        return StringEscapeUtils.escapeJavaScript(text.toString());
    }
    /**
     * @return attribute ""eventhandler.escape.javascript.match""
     */
    protected String getMatchAttribute()
    {
        return ""eventhandler.escape.javascript.match"";
    }
}
"
org.apache.velocity.app.event.implement.EscapeReference,"package org.apache.velocity.app.event.implement;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.oro.text.perl.MalformedPerl5PatternException;
import org.apache.oro.text.perl.Perl5Util;
import org.apache.velocity.app.event.ReferenceInsertionEventHandler;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.RuntimeServicesAware;
import org.apache.velocity.util.StringUtils;
/**
 * Base class for escaping references.  To use it, override the following methods:
 * <DL>
 * <DT><code>String escape(String text)</code></DT>
 * <DD>escape the provided text</DD>
 * <DT><code>String getMatchAttribute()</code></DT>
 * <DD>retrieve the configuration attribute used to match references (see below)</DD>
 * </DL>
 *
 * <P>By default, all references are escaped.  However, by setting the match attribute
 * in the configuration file to a regular expression, users can specify which references
 * to escape.  For example the following configuration property tells the EscapeSqlReference
 * event handler to only escape references that start with ""sql"".
 * (e.g. <code>$sql</code>, <code>$sql.toString(),</code>, etc).
 *
 * <PRE>
 * <CODE>eventhandler.escape.sql.match = /sql.*<!-- -->/
 * </CODE>
 * </PRE>
 * <!-- note: ignore empty HTML comment above - breaks up star slash avoiding javadoc end -->
 *
 * Regular expressions should follow the ""Perl5"" format used by the ORO regular expression
 * library.  More info is at
 * <a href=""http://jakarta.apache.org/oro/api/org/apache/oro/text/perl/package-summary.html"">http://jakarta.apache.org/oro/api/org/apache/oro/text/perl/package-summary.html</a>.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain </a>
 * @version $Id: EscapeReference.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public abstract class EscapeReference implements ReferenceInsertionEventHandler,RuntimeServicesAware {
    private Perl5Util perl = new Perl5Util();
    private RuntimeServices rs;
    private String matchRegExp = null;
    /**
     * Escape the given text.  Override this in a subclass to do the actual
     * escaping.
     *
     * @param text the text to escape
     * @return the escaped text
     */
    protected abstract String escape(Object text);
    /**
     * Specify the configuration attribute that specifies the
     * regular expression.  Ideally should be in a form
     * <pre><code>eventhandler.escape.XYZ.match</code></pre>
     *
     * <p>where <code>XYZ</code> is the type of escaping being done.
     * @return configuration attribute
     */
    protected abstract String getMatchAttribute();
    /**
     * Escape the provided text if it matches the configured regular expression.
     * 
     * @param reference
     * @param value
     * @return Escaped text.
     */
    public Object referenceInsert(String reference, Object value)
    {
        if(value == null)
        {
            return value;
        }
        if (matchRegExp == null)
        {
            return escape(value);
        }
        else if (perl.match(matchRegExp,reference))
        {
            return escape(value);
        }
        else
        {
            return value;
        }
    }
    /**
     * Called automatically when event cartridge is initialized.
     * 
     * @param rs instance of RuntimeServices
     */
    public void setRuntimeServices(RuntimeServices rs)
    {
        this.rs = rs;
        /**
         * Get the regular expression pattern.
         */
        matchRegExp = StringUtils.nullTrim(rs.getConfiguration().getString(getMatchAttribute()));
        if ((matchRegExp != null) && (matchRegExp.length() == 0))
        {
            matchRegExp = null;
        }
        /**
         * Test the regular expression for a well formed pattern
         */
        if (matchRegExp != null)
        {
            try
            {
                perl.match(matchRegExp,"""");
            }
            catch (MalformedPerl5PatternException E)
            {
                rs.getLog().error(""Invalid regular expression '"" + matchRegExp
                                  + ""'.  No escaping will be performed."", E);
                matchRegExp = null;
            }
        }
    }
    /**
     * Retrieve a reference to RuntimeServices.  Use this for checking additional
     * configuration properties.
     * 
     * @return The current runtime services object.
     */
    protected RuntimeServices getRuntimeServices()
    {
        return rs;
    }
}
"
org.apache.velocity.app.event.implement.EscapeSqlReference,"package org.apache.velocity.app.event.implement;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.commons.lang.StringEscapeUtils;
/**
 * Escapes the characters in a String to be suitable to pass to an SQL query.
 * @see <a href=""http://jakarta.apache.org/commons/lang/api/org/apache/commons/lang/StringEscapeUtils.html#escapeSql(java.lang.String)"">StringEscapeUtils</a>
 * @author wglass
 * @since 1.5
 */
public class EscapeSqlReference extends EscapeReference
{
    /**
     * Escapes the characters in a String to be suitable to pass to an SQL query.
     * 
     * @param text
     * @return An escaped string.
     * @see <a href=""http://jakarta.apache.org/commons/lang/api/org/apache/commons/lang/StringEscapeUtils.html#escapeSql(java.lang.String)"">StringEscapeUtils</a>
     */
    protected String escape(Object text)
    {
        return StringEscapeUtils.escapeSql(text.toString());
    }
    /**
     * @return attribute ""eventhandler.escape.sql.match""
     */
    protected String getMatchAttribute()
    {
        return ""eventhandler.escape.sql.match"";
    }
}
"
org.apache.velocity.app.event.implement.EscapeXmlReference,"package org.apache.velocity.app.event.implement;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.commons.lang.StringEscapeUtils;
/**
 * Escape all XML entities.
 * @see <a href=""http://jakarta.apache.org/commons/lang/api/org/apache/commons/lang/StringEscapeUtils.html#escapeSql(java.lang.String)"">StringEscapeUtils</a>
 * @author wglass
 * @since 1.5
 */
public class EscapeXmlReference extends EscapeReference
{
    /**
     * Escape all XML entities.
     * 
     * @param text
     * @return An escaped String.
     * @see <a href=""http://jakarta.apache.org/commons/lang/api/org/apache/commons/lang/StringEscapeUtils.html#escapeSql(java.lang.String)"">StringEscapeUtils</a>
     */
    protected String escape(Object text)
    {
        return StringEscapeUtils.escapeXml(text.toString());
    }
    /**
     * @return attribute ""eventhandler.escape.xml.match""
     */
    protected String getMatchAttribute()
    {
        return ""eventhandler.escape.xml.match"";
    }
}
"
org.apache.velocity.app.event.implement.IncludeNotFound,"package org.apache.velocity.app.event.implement;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.app.event.IncludeEventHandler;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.RuntimeServicesAware;
import org.apache.velocity.util.StringUtils;
/**
 * Simple event handler that checks to see if an included page is available.
 * If not, it includes a designated replacement page instead.
 *
 * <P>By default, the name of the replacement page is ""notfound.vm"", however this
 * page name can be changed by setting the Velocity property
 * <code>eventhandler.include.notfound</code>, for example:
 * <code>
 * <PRE>
 * eventhandler.include.notfound = error.vm
 * </PRE>
 * </code>
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: IncludeNotFound.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class IncludeNotFound implements IncludeEventHandler,RuntimeServicesAware {
    private static final String DEFAULT_NOT_FOUND = ""notfound.vm"";
    private static final String PROPERTY_NOT_FOUND = ""eventhandler.include.notfound"";
    private RuntimeServices rs = null;
    String notfound;
    /**
     * Chseck to see if included file exists, and display ""not found"" page if it
     * doesn't. If ""not found"" page does not exist, log an error and return
     * null.
     * 
     * @param includeResourcePath
     * @param currentResourcePath
     * @param directiveName
     * @return message.
     */
    public String includeEvent(
        String includeResourcePath,
        String currentResourcePath,
        String directiveName)
    {
        /**
         * check to see if page exists
         */
        boolean exists = (rs.getLoaderNameForResource(includeResourcePath) != null);
        if (!exists)
        {
            if (rs.getLoaderNameForResource(notfound) != null)
            {
                return notfound;
            }
            else
            {
                /**
                 * can't find not found, so display nothing
                 */
                rs.getLog().error(""Can't find include not found page: "" + notfound);
                return null;
            }
        }
        else
            return includeResourcePath;
    }
    /**
     * @see org.apache.velocity.util.RuntimeServicesAware#setRuntimeServices(org.apache.velocity.runtime.RuntimeServices)
     */
    public void setRuntimeServices(RuntimeServices rs)
    {
         this.rs = rs;
         notfound = StringUtils.nullTrim(rs.getString(PROPERTY_NOT_FOUND, DEFAULT_NOT_FOUND));
     }
}
"
org.apache.velocity.app.event.implement.IncludeRelativePath,"package org.apache.velocity.app.event.implement;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.app.event.IncludeEventHandler;
/**
 * <p>Event handler that looks for included files relative to the path of the
 * current template. The handler assumes that paths are separated by a forward
 * slash ""/"" or backwards slash ""\"".
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain </a>
 * @version $Id: IncludeRelativePath.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class IncludeRelativePath implements IncludeEventHandler {
    /**
     * Return path relative to the current template's path.
     * 
     * @param includeResourcePath  the path as given in the include directive.
     * @param currentResourcePath the path of the currently rendering template that includes the
     *            include directive.
     * @param directiveName  name of the directive used to include the resource. (With the
     *            standard directives this is either ""parse"" or ""include"").
     * @return new path relative to the current template's path
     */
    public String includeEvent(
        String includeResourcePath,
        String currentResourcePath,
        String directiveName)
    {
        // if the resource name starts with a slash, it's not a relative path
        if (includeResourcePath.startsWith(""/"") || includeResourcePath.startsWith(""\\"") ) {
            return includeResourcePath;
        }
        int lastslashpos = Math.max(
                currentResourcePath.lastIndexOf(""/""),
                currentResourcePath.lastIndexOf(""\\"")
                );
        // root of resource tree
        if (lastslashpos == -1) {
            return includeResourcePath;
        }
        // prepend path to the include path
        return currentResourcePath.substring(0,lastslashpos) + ""/"" + includeResourcePath;
    }
}
"
org.apache.velocity.app.event.implement.InvalidReferenceInfo,"package org.apache.velocity.app.event.implement;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.util.introspection.Info;
/**
 * Convenience class to use when reporting out invalid syntax 
 * with line, column, and template name.
 * 
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain </a>
 * @version $Id: InvalidReferenceInfo.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class InvalidReferenceInfo extends Info
{
    private String invalidReference;
    public InvalidReferenceInfo(String invalidReference, Info info)
    {
        super(info.getTemplateName(),info.getLine(),info.getColumn());
        this.invalidReference = invalidReference; 
    }
    /**
     * Get the specific invalid reference string.
     * @return the invalid reference string
     */
    public String getInvalidReference()
    {
        return invalidReference;
    }
    /**
     * Formats a textual representation of this object as <code>SOURCE
     * [line X, column Y]: invalidReference</code>.
     *
     * @return String representing this object.
     */
    public String toString()
    {
        return getTemplateName() + "" [line "" + getLine() + "", column "" +
            getColumn() + ""]: "" + invalidReference;
    }
}
"
org.apache.velocity.app.event.implement.PrintExceptions,"package org.apache.velocity.app.event.implement;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.PrintWriter;
import java.io.StringWriter;
import org.apache.velocity.app.event.MethodExceptionEventHandler;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.RuntimeServicesAware;
/**
 * Simple event handler that renders method exceptions in the page
 * rather than throwing the exception.  Useful for debugging.
 *
 * <P>By default this event handler renders the exception name only.
 * To include both the exception name and the message, set the property
 * <code>eventhandler.methodexception.message</code> to <code>true</code>.  To render
 * the stack trace, set the property <code>eventhandler.methodexception.stacktrace</code>
 * to <code>true</code>.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: PrintExceptions.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class PrintExceptions implements MethodExceptionEventHandler, RuntimeServicesAware
{
    private static String SHOW_MESSAGE = ""eventhandler.methodexception.message"";
    private static String SHOW_STACK_TRACE = ""eventhandler.methodexception.stacktrace"";
    /** Reference to the runtime service */
    private RuntimeServices rs = null;
    /**
     * Render the method exception, and optionally the exception message and stack trace.
     * 
     * @param claz the class of the object the method is being applied to
     * @param method the method
     * @param e the thrown exception
     * @return an object to insert in the page
     * @throws Exception an exception to be thrown instead inserting an object
     */
    public Object methodException(Class claz, String method, Exception e) throws Exception
    {
        boolean showMessage = rs.getBoolean(SHOW_MESSAGE,false);
        boolean showStackTrace = rs.getBoolean(SHOW_STACK_TRACE,false);
        StringBuffer st;
        if (showMessage && showStackTrace)
        {
            st = new StringBuffer(200);
            st.append(e.getClass().getName()).append(""\n"");
            st.append(e.getMessage()).append(""\n"");
            st.append(getStackTrace(e));
        } else if (showMessage)
        {
            st = new StringBuffer(50);
            st.append(e.getClass().getName()).append(""\n"");
            st.append(e.getMessage()).append(""\n"");
        } else if (showStackTrace)
        {
            st = new StringBuffer(200);
            st.append(e.getClass().getName()).append(""\n"");
            st.append(getStackTrace(e));
        } else
        {
            st = new StringBuffer(15);
            st.append(e.getClass().getName()).append(""\n"");
        }
        return st.toString();
    }
    private static String getStackTrace(Throwable throwable)
    {
        PrintWriter printWriter = null;
        try
        {
            StringWriter stackTraceWriter = new StringWriter();
            printWriter = new PrintWriter(stackTraceWriter);
            throwable.printStackTrace(printWriter);
            printWriter.flush();
            return stackTraceWriter.toString();
        }
        finally
        {
            if (printWriter != null)
            {
                printWriter.close();
            }
        }
    }
    /**
     * @see org.apache.velocity.util.RuntimeServicesAware#setRuntimeServices(org.apache.velocity.runtime.RuntimeServices)
     */
    public void setRuntimeServices(RuntimeServices rs)
    {
        this.rs = rs;
    }
}
"
org.apache.velocity.app.event.implement.ReportInvalidReferences,"package org.apache.velocity.app.event.implement;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.ArrayList;
import java.util.List;
import org.apache.velocity.app.event.InvalidReferenceEventHandler;
import org.apache.velocity.context.Context;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.RuntimeServicesAware;
import org.apache.velocity.util.introspection.Info;
/**
 * Use this event handler to flag invalid references.  Since this 
 * is intended to be used for a specific request, this should be
 * used as a local event handler attached to a specific context
 * instead of being globally defined in the Velocity properties file.
 * 
 * <p>
 * Note that InvalidReferenceHandler can be used
 * in two modes.  If the Velocity properties file contains the following:
 * <pre>
 * eventhandler.invalidreference.exception = true
 * </pre>
 * then the event handler will throw a ParseErrorRuntimeException upon 
 * hitting the first invalid reference.  This stops processing and is 
 * passed through to the application code.  The ParseErrorRuntimeException
 * contain information about the template name, line number, column number,
 * and invalid reference.
 * 
 * <p>
 * If this configuration setting is false or omitted then the page 
 * will be processed as normal, but all invalid references will be collected
 * in a List of InvalidReferenceInfo objects.
 * 
 * <p>This feature should be regarded as experimental.
 * 
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: ReportInvalidReferences.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class ReportInvalidReferences implements 
    InvalidReferenceEventHandler, RuntimeServicesAware
{
    public static final String EVENTHANDLER_INVALIDREFERENCE_EXCEPTION = ""eventhandler.invalidreference.exception"";
    /** 
     * List of InvalidReferenceInfo objects
     */
    List invalidReferences = new ArrayList();
    /**
     * If true, stop at the first invalid reference and throw an exception.
     */
    private boolean stopOnFirstInvalidReference = false;
    /**
     * Collect the error and/or throw an exception, depending on configuration.
     *
     * @param context the context when the reference was found invalid
     * @param reference string with complete invalid reference
     * @param object the object referred to, or null if not found
     * @param property the property name from the reference
     * @param info contains template, line, column details
     * @return always returns null
     * @throws ParseErrorException
     */
    public Object invalidGetMethod(Context context, String reference, Object object, 
            String property, Info info)
    {
        reportInvalidReference(reference, info);
        return null;
    }
    /**
     * Collect the error and/or throw an exception, depending on configuration.
     *
     * @param context the context when the reference was found invalid
     * @param reference complete invalid reference
     * @param object the object referred to, or null if not found
     * @param method the property name from the reference
     * @param info contains template, line, column details
     * @return always returns null
     * @throws ParseErrorException
     */
    public Object invalidMethod(Context context, String reference, Object object, 
            String method, Info info)
    {
        if (reference == null)
        {
            reportInvalidReference(object.getClass().getName() + ""."" + method, info);
        }
        else
        {
            reportInvalidReference(reference, info);
        }
        return null;
    }
    /**
     * Collect the error and/or throw an exception, depending on configuration.
     *
     * @param context the context when the reference was found invalid
     * @param leftreference left reference being assigned to
     * @param rightreference invalid reference on the right
     * @param info contains info on template, line, col
     * @return loop to end -- always returns false
     */
    public boolean invalidSetMethod(Context context, String leftreference, String rightreference, Info info)
    {
        reportInvalidReference(leftreference, info);
        return false;
    }
    /**
     * Check for an invalid reference and collect the error or throw an exception 
     * (depending on configuration).
     * 
     * @param reference the invalid reference
     * @param info line, column, template name
     */
    private void reportInvalidReference(String reference, Info info)
    {
        InvalidReferenceInfo invalidReferenceInfo = new InvalidReferenceInfo(reference, info);
        invalidReferences.add(invalidReferenceInfo);
        if (stopOnFirstInvalidReference)
        {
            throw new ParseErrorException(
                    ""Error in page - invalid reference.  "",
                    info,
                    invalidReferenceInfo.getInvalidReference());
        }
    }
    /**
     * All invalid references during the processing of this page.
     * @return a List of InvalidReferenceInfo objects
     */
    public List getInvalidReferences()
    {
        return invalidReferences;
    }
    /**
     * Called automatically when event cartridge is initialized.
     * @param rs RuntimeServices object assigned during initialization
     */
    public void setRuntimeServices(RuntimeServices rs)
    {
        stopOnFirstInvalidReference = rs.getConfiguration().getBoolean(
                EVENTHANDLER_INVALIDREFERENCE_EXCEPTION,
                false);        
    }
}
"
org.apache.velocity.app.tools.VelocityFormatter,"package org.apache.velocity.app.tools;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.Array;
import java.text.DateFormat;
import java.util.Date;
import java.util.List;
import org.apache.velocity.context.Context;
/**
 * Formatting tool for inserting into the Velocity WebContext.  Can
 * format dates or lists of objects.
 *
 * <p>Here's an example of some uses:
 *
 * <code><pre>
 * $formatter.formatShortDate($object.Date)
 * $formatter.formatLongDate($db.getRecord(232).getDate())
 * $formatter.formatArray($array)
 * $formatter.limitLen(30, $object.Description)
 * </pre></code>
 *
 * @deprecated This class has been replaced by NumberTool, DateTool,
 * DisplayTool, and AlternatorTool available from the Velocity-Tools sub-project.
 * VelocityFormatter will be removed in a future version of Velocity.
 *
 * @author <a href=""sean@somacity.com"">Sean Legassick</a>
 * @author <a href=""dlr@collab.net"">Daniel Rall</a>
 * @version $Id: VelocityFormatter.java 544641 2007-06-05 21:30:22Z nbubna $
 */
public class VelocityFormatter
{
    Context context = null;
    /**
     * Constructor needs a backpointer to the context.
     *
     * @param context A Context.
     */
    public VelocityFormatter(Context context)
    {
        this.context = context;
    }
    /**
     * Formats a date in <code>DateFormat.SHORT</code> style.
     *
     * @param date The date to format.
     * @return The formatted date as text.
     */
    public String formatShortDate(Date date)
    {
        return DateFormat.getDateInstance(DateFormat.SHORT).format(date);
    }
    /**
     * Formats a date in <code>DateFormat.LONG</code> style.
     *
     * @param date The date to format.
     * @return The formatted date as text.
     */
    public String formatLongDate(Date date)
    {
        return DateFormat.getDateInstance(DateFormat.LONG).format(date);
    }
    /**
     * Formats a date/time in 'short' style.
     *
     * @param date The date to format.
     * @return The formatted date as text.
     */
    public String formatShortDateTime(Date date)
    {
        return DateFormat
            .getDateTimeInstance(DateFormat.SHORT,
                                 DateFormat.SHORT).format(date);
    }
    /**
     * Formats a date/time in 'long' style.
     *
     * @param date The date to format.
     * @return The formatted date as text.
     */
    public String formatLongDateTime(Date date)
    {
        return DateFormat.getDateTimeInstance(
                DateFormat.LONG, DateFormat.LONG).format(date);
    }
    /**
     * Formats an array into the form ""A, B and C"".
     *
     * @param array An Object.
     * @return A String.
     */
    public String formatArray(Object array)
    {
        return formatArray(array, "", "", "" and "");
    }
    /**
     * Formats an array into the form
     * ""A&lt;delim&gt;B&lt;delim&gt;C"".
     *
     * @param array An Object.
     * @param delim A String.
     * @return A String.
     */
    public String formatArray(Object array,
                              String delim)
    {
        return formatArray(array, delim, delim);
    }
    /**
     * Formats an array into the form
     * ""A&lt;delim&gt;B&lt;finaldelim&gt;C"".
     *
     * @param array An Object.
     * @param delim A String.
     * @param finaldelim A String.
     * @return A String.
     */
    public String formatArray(Object array,
                              String delim,
                              String finaldelim)
    {
        StringBuffer sb = new StringBuffer();
        int arrayLen = Array.getLength(array);
        for (int i = 0; i < arrayLen; i++)
        {
            // Use the Array.get method as this will automatically
            // wrap primitive types in a suitable Object-derived
            // wrapper if necessary.
            sb.append(Array.get(array, i).toString());
            if (i  < arrayLen - 2)
            {
                sb.append(delim);
            }
            else if (i < arrayLen - 1)
            {
                sb.append(finaldelim);
            }
        }
        return sb.toString();
    }
    /**
     * Formats a vector into the form ""A, B and C"".
     *
     * @param list The list of elements to format.
     * @return A String.
     */
    public String formatVector(List list)
    {
        return formatVector(list, "", "", "" and "");
    }
    /**
     * Formats a vector into the form ""A&lt;delim&gt;B&lt;delim&gt;C"".
     *
     * @param list The list of elements to format.
     * @param delim A String.
     * @return A String.
     */
    public String formatVector(List list,
                               String delim)
    {
        return formatVector(list, delim, delim);
    }
    /**
     * Formats a list into the form
     * ""Adelim&gt;B&lt;finaldelim&gt;C"".
     *
     * @param list The list of elements to format.
     * @param delim A String.
     * @param finaldelim A String.
     * @return A String.
     */
    public String formatVector(List list,
                               String delim,
                               String finaldelim)
    {
        StringBuffer sb = new StringBuffer();
        int size = list.size();
        for (int i = 0; i < size; i++)
        {
            sb.append(list.get(i));
            if (i < size - 2)
            {
                sb.append(delim);
            }
            else if (i < size - 1)
            {
                sb.append(finaldelim);
            }
        }
        return sb.toString();
    }
    /**
     * Limits 'string' to 'maxlen' characters.  If the string gets
     * curtailed, ""..."" is appended to it.
     *
     * @param maxlen An int with the maximum length.
     * @param string A String.
     * @return A String.
     */
    public String limitLen(int maxlen,
                           String string)
    {
        return limitLen(maxlen, string, ""..."");
    }
    /**
     * Limits 'string' to 'maxlen' character.  If the string gets
     * curtailed, 'suffix' is appended to it.
     *
     * @param maxlen An int with the maximum length.
     * @param string A String.
     * @param suffix A String.
     * @return A String.
     */
    public String limitLen(int maxlen,
                           String string,
                           String suffix)
    {
        String ret = string;
        if (string.length() > maxlen)
        {
            ret = string.substring(0, maxlen - suffix.length()) + suffix;
        }
        return ret;
    }
    /**
     * Class that returns alternating values in a template.  It stores
     * a list of alternate Strings, whenever alternate() is called it
     * switches to the next in the list.  The current alternate is
     * retrieved through toString() - i.e. just by referencing the
     * object in a Velocity template.  For an example of usage see the
     * makeAlternator() method below.
     */
    public class VelocityAlternator
    {
        /**
         *
         */
        protected String[] alternates = null;
        /**
         *
         */
        protected int current = 0;
        /**
         * Constructor takes an array of Strings.
         *
         * @param alternates A String[].
         */
        public VelocityAlternator(String[] alternates)
        {
            this.alternates = alternates;
        }
        /**
         * Alternates to the next in the list.
         *
         * @return The current alternate in the sequence.
         */
        public String alternate()
        {
            current++;
            current %= alternates.length;
            return """";
        }
        /**
         * Returns the current alternate.
         *
         * @return A String.
         */
        public String toString()
        {
            return alternates[current];
        }
    }
    /**
     * As VelocityAlternator, but calls <code>alternate()</code>
     * automatically on rendering in a template.
     */
    public class VelocityAutoAlternator extends VelocityAlternator
    {
        /**
         * Constructor takes an array of Strings.
         *
         * @param alternates A String[].
         */
        public VelocityAutoAlternator(String[] alternates)
        {
            super(alternates);
        }
        /**
         * Returns the current alternate, and automatically alternates
         * to the next alternate in its sequence (trigged upon
         * rendering).
         *
         * @return The current alternate in the sequence.
         */
        public final String toString()
        {
            String s = alternates[current];
            alternate();
            return s;
        }
    }
    /**
     * Makes an alternator object that alternates between two values.
     *
     * <p>Example usage in a Velocity template:
     *
     * <code><pre>
     * &lt;table&gt;
     * $formatter.makeAlternator(""rowcolor"", ""#c0c0c0"", ""#e0e0e0"")
     * #foreach $item in $items
     * #begin
     * &lt;tr&gt;&lt;td bgcolor=""$rowcolor""&gt;$item.Name&lt;/td&gt;&lt;/tr&gt;
     * $rowcolor.alternate()
     * #end
     * &lt;/table&gt;
     * </pre></code>
     *
     * @param name The name for the alternator int the context.
     * @param alt1 The first alternate.
     * @param alt2 The second alternate.
     * @return The newly created instance.
     */
    public String makeAlternator(String name,
                                 String alt1,
                                 String alt2)
    {
        String[] alternates = { alt1, alt2 };
        context.put(name, new VelocityAlternator(alternates));
        return """";
    }
    /**
     * Makes an alternator object that alternates between three
     * values.
     * @param name
     * @param alt1
     * @param alt2
     * @param alt3
     * @return alternated object.
     *
     * @see #makeAlternator(String name, String alt1, String alt2)
     */
    public String makeAlternator(String name,
                                 String alt1,
                                 String alt2,
                                 String alt3)
    {
        String[] alternates = { alt1, alt2, alt3 };
        context.put(name, new VelocityAlternator(alternates));
        return """";
    }
    /**
     * Makes an alternator object that alternates between four values.
     * @param name
     * @param alt1
     * @param alt2
     * @param alt3
     * @param alt4
     * @return Alternated object.
     *
     * @see #makeAlternator(String name, String alt1, String alt2)
     */
    public String makeAlternator(String name, String alt1, String alt2,
                                 String alt3, String alt4)
    {
        String[] alternates = { alt1, alt2, alt3, alt4 };
        context.put(name, new VelocityAlternator(alternates));
        return """";
    }
    /**
     * Makes an alternator object that alternates between two values
     * automatically.
     * @param name
     * @param alt1
     * @param alt2
     * @return Alternated object.
     *
     * @see #makeAlternator(String name, String alt1, String alt2)
     */
    public String makeAutoAlternator(String name, String alt1, String alt2)
    {
        String[] alternates = { alt1, alt2 };
        context.put(name, new VelocityAutoAlternator(alternates));
        return """";
    }
    /**
     * Returns a default value if the object passed is null.
     * @param o
     * @param dflt
     * @return Object or default value when object is null.
     */
    public Object isNull(Object o, Object dflt)
    {
        if ( o == null )
        {
            return dflt;
        }
        else
        {
            return o;
        }
    }
}
"
org.apache.velocity.context.AbstractContext,"package org.apache.velocity.context;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  This class is the abstract base class for all conventional
 *  Velocity Context  implementations.  Simply extend this class
 *  and implement the abstract routines that access your preferred
 *  storage method.
 *
 *  Takes care of context chaining.
 *
 *  Also handles / enforces policy on null keys and values :
 *
 *  <ul>
 *  <li> Null keys and values are accepted and basically dropped.
 *  <li> If you place an object into the context with a null key, it
 *        will be ignored and logged.
 *  <li> If you try to place a null into the context with any key, it
 *        will be dropped and logged.
 *  </ul>
 *
 *  The default implementation of this for application use is
 *  org.apache.velocity.VelocityContext.
 *
 *  All thanks to Fedor for the chaining idea.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:fedor.karpelevitch@home.com"">Fedor Karpelevitch</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: AbstractContext.java 702218 2008-10-06 18:15:18Z nbubna $
 */
public abstract class AbstractContext extends InternalContextBase
    implements Context
{
    /**
     *  the chained Context if any
     */
    private   Context  innerContext = null;
    /**
     *  Implement to return a value from the context storage.
     *  <br><br>
     *  The implementation of this method is required for proper
     *  operation of a Context implementation in general
     *  Velocity use.
     *
     *  @param key key whose associated value is to be returned
     *  @return object stored in the context
     */
    public abstract Object internalGet( String key );
    /**
     *  Implement to put a value into the context storage.
     *  <br><br>
     *  The implementation of this method is required for
     *  proper operation of a Context implementation in
     *  general Velocity use.
     *
     *  @param key key with which to associate the value
     *  @param value value to be associated with the key
     *  @return previously stored value if exists, or null
     */
    public abstract Object internalPut( String key, Object value );
    /**
     *  Implement to determine if a key is in the storage.
     *  <br><br>
     *  Currently, this method is not used internally by
     *  the Velocity engine.
     *
     *   @param key key to test for existance
     *   @return true if found, false if not
     */
    public abstract boolean internalContainsKey(Object key);
    /**
     *  Implement to return an object array of key
     *  strings from your storage.
     *  <br><br>
     *  Currently, this method is not used internally by
     *  the Velocity engine.
     *
     *  @return array of keys
     */
    public abstract Object[] internalGetKeys();
    /**
     *  I mplement to remove an item from your storage.
     *  <br><br>
     *  Currently, this method is not used internally by
     *  the Velocity engine.
     *
     *  @param key key to remove
     *  @return object removed if exists, else null
     */
    public abstract Object internalRemove(Object key);
    /**
     *  default CTOR
     */
    public AbstractContext()
    {
    }
    /**
     *  Chaining constructor accepts a Context argument.
     *  It will relay get() operations into this Context
     *  in the even the 'local' get() returns null.
     *
     *  @param inner context to be chained
     */
    public AbstractContext( Context inner )
    {
        innerContext = inner;
        /*
         *  now, do a 'forward pull' of event cartridge so
         *  it's accessable, bringing to the top level.
         */
        if (innerContext instanceof InternalEventContext )
        {
            attachEventCartridge( ( (InternalEventContext) innerContext).getEventCartridge() );
        }
    }
    /**
     * Adds a name/value pair to the context.
     *
     * @param key   The name to key the provided value with.
     * @param value The corresponding value.
     * @return Object that was replaced in the the Context if
     *         applicable or null if not.
     */
    public Object put(String key, Object value)
    {
        /*
         * don't even continue if key is null
         */
        if (key == null)
        {
            return null;
        }
        return internalPut(key, value);
    }
    /**
     *  Gets the value corresponding to the provided key from the context.
     *
     *  Supports the chaining context mechanism.  If the 'local' context
     *  doesn't have the value, we try to get it from the chained context.
     *
     *  @param key The name of the desired value.
     *  @return    The value corresponding to the provided key or null if
     *             the key param is null.
     */
    public Object get(String key)
    {
        /*
         *  punt if key is null
         */
        if (key == null)
        {
            return null;
        }
        /*
         *  get the object for this key.  If null, and we are chaining another Context
         *  call the get() on it.
         */
        Object o = internalGet( key );
        if (o == null && innerContext != null)
        {
            o = innerContext.get( key );
        }
        return o;
    }
    /**
     *  Indicates whether the specified key is in the context.  Provided for
     *  debugging purposes.
     *
     * @param key The key to look for.
     * @return true if the key is in the context, false if not.
     */
    public boolean containsKey(Object key)
    {
        if (key == null)
        {
            return false;
        }
        boolean exists = internalContainsKey(key);
        if (!exists && innerContext != null)
        {
            exists = innerContext.containsKey(key);
        }
        return exists;
    }
    /**
     *  Get all the keys for the values in the context
     *  @return Object[] of keys in the Context. Does not return
     *          keys in chained context.
     */
    public Object[] getKeys()
    {
        return internalGetKeys();
    }
    /**
     * Removes the value associated with the specified key from the context.
     *
     * @param key The name of the value to remove.
     * @return    The value that the key was mapped to, or <code>null</code>
     *            if unmapped.
     */
    public Object remove(Object key)
    {
        if (key == null)
        {
            return null;
        }
        return internalRemove(key);
    }
    /**
     *  returns innerContext if one is chained
     *
     *  @return Context if chained, <code>null</code> if not
     */
    public Context getChainedContext()
    {
        return innerContext;
    }
}
"
org.apache.velocity.context.ChainedInternalContextAdapter,"package org.apache.velocity.context;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.HashSet;
import java.util.Set;
import java.util.List;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.util.ClassUtils;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
/**
 * This is an abstract internal-use-only context implementation to be
 * used as a subclass for other internal-use-only contexts that wrap
 * other internal-use-only contexts.
 *
 * We use this context to make it easier to chain an existing context
 * as part of a new context implementation.  It just delegates everything
 * to the inner/parent context. Subclasses then only need to override
 * the methods relevant to them.
 *
 * @author Nathan Bubna
 * @version $Id: ChainedInternalContextAdapter.java 685724 2008-08-13 23:12:12Z nbubna $
 * @since 1.6
 */
public abstract class ChainedInternalContextAdapter implements InternalContextAdapter
{
    /** the parent context */
    protected InternalContextAdapter innerContext = null;
    /**
     * CTOR, wraps an ICA
     * @param inner context
     */
    public ChainedInternalContextAdapter(InternalContextAdapter inner)
    {
        innerContext = inner;
    }
    /**
     * Return the inner / user context.
     * @return The inner / user context.
     */
    public Context getInternalUserContext()
    {
        return innerContext.getInternalUserContext();
    }
    /**
     * @see org.apache.velocity.context.InternalWrapperContext#getBaseContext()
     */
    public InternalContextAdapter getBaseContext()
    {
        return innerContext.getBaseContext();
    }
    /**
     * Retrieves from parent context.
     *
     * @param key name of item to get
     * @return  stored object or null
     */
    public Object get(String key)
    {
        return innerContext.get(key);
    }
    /**
     * Put method also stores values in parent context
     *
     * @param key name of item to set
     * @param value object to set to key
     * @return old stored object
     */
    public Object put(String key, Object value)
    {
        /*
         * just put in the local context
         */
        return innerContext.put(key, value);
    }
    /**
     * @see org.apache.velocity.context.Context#containsKey(java.lang.Object)
     */
    public boolean containsKey(Object key)
    {
        return innerContext.containsKey(key);
    }
    /**
     * @see org.apache.velocity.context.Context#getKeys()
     */
    public Object[] getKeys()
    {
        return innerContext.getKeys();
    }
    /**
     * @see org.apache.velocity.context.Context#remove(java.lang.Object)
     */
    public Object remove(Object key)
    {
        return innerContext.remove(key);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#pushCurrentTemplateName(java.lang.String)
     */
    public void pushCurrentTemplateName(String s)
    {
        innerContext.pushCurrentTemplateName(s);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#popCurrentTemplateName()
     */
    public void popCurrentTemplateName()
    {
        innerContext.popCurrentTemplateName();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getCurrentTemplateName()
     */
    public String getCurrentTemplateName()
    {
        return innerContext.getCurrentTemplateName();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getTemplateNameStack()
     */
    public Object[] getTemplateNameStack()
    {
        return innerContext.getTemplateNameStack();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#pushCurrentMacroName(java.lang.String)
     */
    public void pushCurrentMacroName(String s)
    {
        innerContext.pushCurrentMacroName(s);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#popCurrentMacroName()
     */
    public void popCurrentMacroName()
    {
        innerContext.popCurrentMacroName();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getCurrentMacroName()
     */
    public String getCurrentMacroName()
    {
        return innerContext.getCurrentMacroName();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getCurrentMacroCallDepth()
     */
    public int getCurrentMacroCallDepth()
    {
        return innerContext.getCurrentMacroCallDepth();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getMacroNameStack()
     */
    public Object[] getMacroNameStack()
    {
        return innerContext.getMacroNameStack();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#icacheGet(java.lang.Object)
     */
    public IntrospectionCacheData icacheGet(Object key)
    {
        return innerContext.icacheGet(key);
    }
    /**
     * @see org.apache.velocity.context.InternalWrapperContext#localPut(java.lang.String,java.lang.Object)
     */
    public Object localPut(final String key, final Object value)
    {
        return innerContext.put(key, value);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#icachePut(java.lang.Object, org.apache.velocity.util.introspection.IntrospectionCacheData)
     */
    public void icachePut(Object key, IntrospectionCacheData o)
    {
        innerContext.icachePut(key, o);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getAllowRendering()
     */
    public boolean getAllowRendering()
    {
       return innerContext.getAllowRendering();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#setAllowRendering(boolean)
     */
    public void setAllowRendering(boolean v)
    {
        innerContext.setAllowRendering(v);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#setMacroLibraries(List)
     */
    public void setMacroLibraries(List macroLibraries)
    {
        innerContext.setMacroLibraries(macroLibraries);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getMacroLibraries()
     */
    public List getMacroLibraries()
    {
        return innerContext.getMacroLibraries();
    }
    /**
     * @see org.apache.velocity.context.InternalEventContext#attachEventCartridge(org.apache.velocity.app.event.EventCartridge)
     */
    public EventCartridge attachEventCartridge(EventCartridge ec)
    {
        return innerContext.attachEventCartridge(ec);
    }
    /**
     * @see org.apache.velocity.context.InternalEventContext#getEventCartridge()
     */
    public EventCartridge getEventCartridge()
    {
        return innerContext.getEventCartridge();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#setCurrentResource(org.apache.velocity.runtime.resource.Resource)
     */
    public void setCurrentResource(Resource r)
    {
        innerContext.setCurrentResource(r);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getCurrentResource()
     */
    public Resource getCurrentResource()
    {
        return innerContext.getCurrentResource();
    }
}
"
org.apache.velocity.context.Context,"package org.apache.velocity.context;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Interface describing the application data context.  This set of
 *  routines is used by the application to set and remove 'named' data
 *  object to pass them to the template engine to use when rendering
 *  a template.
 *
 *  This is the same set of methods supported by the original Context
 *  class
 *
 *  @see org.apache.velocity.context.AbstractContext
 *  @see org.apache.velocity.VelocityContext
 *
 *  @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: Context.java 463298 2006-10-12 16:10:32Z henning $
 */
public interface Context
{
    /**
     * Adds a name/value pair to the context.
     *
     * @param key   The name to key the provided value with.
     * @param value The corresponding value.
     * @return The old object or null if there was no old object.
     */
    Object put(String key, Object value);
    /**
     * Gets the value corresponding to the provided key from the context.
     *
     * @param key The name of the desired value.
     * @return    The value corresponding to the provided key.
     */
    Object get(String key);
    /**
     * Indicates whether the specified key is in the context.
     *
     * @param key The key to look for.
     * @return    Whether the key is in the context.
     */
    boolean containsKey(Object key);
    /**
     * Get all the keys for the values in the context.
     * @return All the keys for the values in the context.
     */
    Object[] getKeys();
    /**
     * Removes the value associated with the specified key from the context.
     *
     * @param key The name of the value to remove.
     * @return    The value that the key was mapped to, or <code>null</code>
     *            if unmapped.
     */
    Object remove(Object key);
}
"
org.apache.velocity.context.EvaluateContext,"package org.apache.velocity.context;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.HashSet;
import java.util.Set;
import java.util.List;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.util.ClassUtils;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
/**
 *  This is a special, internal-use-only context implementation to be
 *  used for the #evaluate directive.
 *
 *  We use this context to chain the existing context, preventing any changes
 *  from impacting the parent context.  By separating this context into a 
 *  separate class it also allows for the future possibility of changing
 *  the context behavior for the #evaluate directive.
 *  
 *  Note that the context used to store values local to #evaluate()
 *  is user defined but defaults to {@link VelocityContext}.
 *
 *  @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 *  @version $Id: EvaluateContext.java 691519 2008-09-03 05:36:11Z nbubna $
 *  @since 1.6
 */
public class EvaluateContext extends ChainedInternalContextAdapter
{
    /** container for any local items */
    Context localContext;
    boolean allowRendering = true;
     /**
     *  CTOR, wraps an ICA
     * @param inner context for parent template
     * @param rsvc 
     */
    public EvaluateContext( InternalContextAdapter  inner, RuntimeServices rsvc )
    {
        super(inner);
        initContext(rsvc);
    }
    /**
     * Initialize the context based on user-configured class 
     * @param rsvc
     */
    private void initContext( RuntimeServices rsvc )
    {
        String contextClass = rsvc.getString(RuntimeConstants.EVALUATE_CONTEXT_CLASS);
        if (contextClass != null && contextClass.length() > 0)
        {
            Object o = null;
            try
            {
                o = ClassUtils.getNewInstance( contextClass );
            }
            catch (ClassNotFoundException cnfe)
            {
                String err = ""The specified class for #evaluate() context ("" + contextClass
                + "") does not exist or is not accessible to the current classloader."";
                rsvc.getLog().error(err);
                throw new RuntimeException(err,cnfe);
            }
            catch (Exception e)
            {
                String err = ""The specified class for #evaluate() context ("" + contextClass
                + "") can not be loaded."";
                rsvc.getLog().error(err,e);
                throw new RuntimeException(err);
            }
            if (!(o instanceof Context))
            {                
                String err = ""The specified class for #evaluate() context ("" + contextClass
                + "") does not implement "" + Context.class.getName() + ""."";
                rsvc.getLog().error(err);
                throw new RuntimeException(err);
            }
            localContext = (Context) o; 
        }
        else
        {
            String err = ""No class specified for #evaluate() context."";
            rsvc.getLog().error(err);
            throw new RuntimeException(err);
        }
    }
    /**
     *  Put method also stores values in local scope 
     *
     *  @param key name of item to set
     *  @param value object to set to key
     *  @return old stored object
     */
    public Object put(String key, Object value)
    {
        /*
         *  just put in the local context
         */
        return localContext.put(key, value);
    }
    /**
     *  Retrieves from local or global context.
     *
     *  @param key name of item to get
     *  @return  stored object or null
     */
    public Object get( String key )
    {
        /*
         *  always try the local context then innerContext
         */
        Object o = localContext.get( key );
        if ( o == null)
        {
            o = super.get( key );
        }
        return o;
    }
    /**
     * @see org.apache.velocity.context.Context#containsKey(java.lang.Object)
     */
    public boolean containsKey(Object key)
    {
        return localContext.containsKey(key) || super.containsKey(key);
    }
    /**
     * @see org.apache.velocity.context.Context#getKeys()
     */
    public Object[] getKeys()
    {
        Set keys = new HashSet();
        Object[] localKeys = localContext.getKeys();
        for (int i=0; i < localKeys.length; i++)
        {
            keys.add(localKeys[i]);
        }
        Object[] innerKeys = super.getKeys();
        for (int i=0; i < innerKeys.length; i++)
        {
            keys.add(innerKeys[i]);
        }
        return keys.toArray();
    }
    /**
     * @see org.apache.velocity.context.Context#remove(java.lang.Object)
     */
    public Object remove(Object key)
    {
        return localContext.remove( key );
    }
    /**
     * Allows callers to explicitly put objects in the local context.
     * Objects added to the context through this method always end up
     * in the top-level context of possible wrapped contexts.
     *
     *  @param key name of item to set.
     *  @param value object to set to key.
     *  @return old stored object
     */
    public Object localPut(final String key, final Object value)
    {
        return localContext.put(key, value);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getAllowRendering()
     */
    public boolean getAllowRendering()
    {
       return allowRendering && innerContext.getAllowRendering();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#setAllowRendering(boolean)
     */
    public void setAllowRendering(boolean v)
    {
        allowRendering = false;
    }
}
"
org.apache.velocity.context.InternalContextAdapter,"package org.apache.velocity.context;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  interface to bring all necessary internal and user contexts together.
 *  this is what the AST expects to deal with.  If anything new comes
 *  along, add it here.
 *
 *  I will rename soon :)
 *
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: InternalContextAdapter.java 463298 2006-10-12 16:10:32Z henning $
 */
public interface InternalContextAdapter
    extends InternalHousekeepingContext, Context, InternalWrapperContext, InternalEventContext
{
}
"
org.apache.velocity.context.InternalContextAdapterImpl,"package org.apache.velocity.context;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
import java.util.List;
/**
 *  This adapter class is the container for all context types for internal
 *  use.  The AST now uses this class rather than the app-level Context
 *  interface to allow flexibility in the future.
 *
 *  Currently, we have two context interfaces which must be supported :
 *  <ul>
 *  <li> Context : used for application/template data access
 *  <li> InternalHousekeepingContext : used for internal housekeeping and caching
 *  <li> InternalWrapperContext : used for getting root cache context and other
 *       such.
 *  <li> InternalEventContext : for event handling.
 *  </ul>
 *
 *  This class implements the two interfaces to ensure that all methods are
 *  supported.  When adding to the interfaces, or adding more context
 *  functionality, the interface is the primary definition, so alter that first
 *  and then all classes as necessary.  As of this writing, this would be
 *  the only class affected by changes to InternalContext
 *
 *  This class ensures that an InternalContextBase is available for internal
 *  use.  If an application constructs their own Context-implementing
 *  object w/o subclassing AbstractContext, it may be that support for
 *  InternalContext is not available.  Therefore, InternalContextAdapter will
 *  create an InternalContextBase if necessary for this support.  Note that
 *  if this is necessary, internal information such as node-cache data will be
 *  lost from use to use of the context.  This may or may not be important,
 *  depending upon application.
 *
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: InternalContextAdapterImpl.java 685724 2008-08-13 23:12:12Z nbubna $
 */
public final class InternalContextAdapterImpl implements InternalContextAdapter
{
    /**
     *  the user data Context that we are wrapping
     */
    Context context = null;
    /**
     *  the ICB we are wrapping.  We may need to make one
     *  if the user data context implementation doesn't
     *  support one.  The default AbstractContext-derived
     *  VelocityContext does, and it's recommended that
     *  people derive new contexts from AbstractContext
     *  rather than piecing things together
     */
    InternalHousekeepingContext icb = null;
    /**
     *  The InternalEventContext that we are wrapping.  If
     *  the context passed to us doesn't support it, no
     *  biggie.  We don't make it for them - since its a
     *  user context thing, nothing gained by making one
     *  for them now
     */
    InternalEventContext iec = null;
    /**
     *  CTOR takes a Context and wraps it, delegating all 'data' calls
     *  to it.
     *
     *  For support of internal contexts, it will create an InternalContextBase
     *  if need be.
     * @param c
     */
    public InternalContextAdapterImpl( Context c )
    {
        context = c;
        if ( !( c instanceof InternalHousekeepingContext ))
        {
            icb = new InternalContextBase();
        }
        else
        {
            icb = (InternalHousekeepingContext) context;
        }
        if ( c instanceof InternalEventContext)
        {
            iec = ( InternalEventContext) context;
        }
    }
    /* --- InternalHousekeepingContext interface methods --- */
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#pushCurrentTemplateName(java.lang.String)
     */
    public void pushCurrentTemplateName( String s )
    {
        icb.pushCurrentTemplateName( s );
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#popCurrentTemplateName()
     */
    public void popCurrentTemplateName()
    {
        icb.popCurrentTemplateName();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getCurrentTemplateName()
     */
    public String getCurrentTemplateName()
    {
        return icb.getCurrentTemplateName();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getTemplateNameStack()
     */
    public Object[] getTemplateNameStack()
    {
        return icb.getTemplateNameStack();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#pushCurrentMacroName(java.lang.String)
     * @since 1.6
     */
    public void pushCurrentMacroName( String s )
    {
        icb.pushCurrentMacroName( s );
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#popCurrentMacroName()
     * @since 1.6
     */
    public void popCurrentMacroName()
    {
        icb.popCurrentMacroName();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getCurrentMacroName()
     * @since 1.6
     */
    public String getCurrentMacroName()
    {
        return icb.getCurrentMacroName();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getCurrentMacroCallDepth()
     * @since 1.6
     */
    public int getCurrentMacroCallDepth()
    {
        return icb.getCurrentMacroCallDepth();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getMacroNameStack()
     * @since 1.6
     */
    public Object[] getMacroNameStack()
    {
        return icb.getMacroNameStack();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#icacheGet(java.lang.Object)
     */
    public IntrospectionCacheData icacheGet( Object key )
    {
        return icb.icacheGet( key );
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#icachePut(java.lang.Object, org.apache.velocity.util.introspection.IntrospectionCacheData)
     */
    public void icachePut( Object key, IntrospectionCacheData o )
    {
        icb.icachePut( key, o );
    }
   /**
    * @see org.apache.velocity.context.InternalHousekeepingContext#setCurrentResource(org.apache.velocity.runtime.resource.Resource)
    */
    public void setCurrentResource( Resource r )
    {
        icb.setCurrentResource(r);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getCurrentResource()
     */
    public Resource getCurrentResource()
    {
        return icb.getCurrentResource();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getAllowRendering()
     * @since 1.5
     */
    public boolean getAllowRendering()
    {
       return icb.getAllowRendering();
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#setAllowRendering(boolean)
     * @since 1.5
     */
    public void setAllowRendering(boolean v)
    {
        icb.setAllowRendering(v);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#setMacroLibraries(List)
     * @since 1.6
     */
    public void setMacroLibraries(List macroLibraries)
    {
        icb.setMacroLibraries(macroLibraries);
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getMacroLibraries()
     * @since 1.6
     */
    public List getMacroLibraries()
    {
        return icb.getMacroLibraries();
    }
    /* ---  Context interface methods --- */
    /**
     * @see org.apache.velocity.context.Context#put(java.lang.String, java.lang.Object)
     */
    public Object put(String key, Object value)
    {
        return context.put( key , value );
    }
    /**
     * @see InternalWrapperContext#localPut(String, Object)
     * @since 1.5
     */
    public Object localPut(final String key, final Object value)
    {
        return put(key, value);
    }
    /**
     * @see org.apache.velocity.context.Context#get(java.lang.String)
     */
    public Object get(String key)
    {
        return context.get( key );
    }
    /**
     * @see org.apache.velocity.context.Context#containsKey(java.lang.Object)
     */
    public boolean containsKey(Object key)
    {
        return context.containsKey( key );
    }
    /**
     * @see org.apache.velocity.context.Context#getKeys()
     */
    public Object[] getKeys()
    {
        return context.getKeys();
    }
    /**
     * @see org.apache.velocity.context.Context#remove(java.lang.Object)
     */
    public Object remove(Object key)
    {
        return context.remove( key );
    }
    /* ---- InternalWrapperContext --- */
    /**
     *  returns the user data context that
     *  we are wrapping
     * @return The internal user data context.
     */
    public Context getInternalUserContext()
    {
        return context;
    }
    /**
     *  Returns the base context that we are
     *  wrapping. Here, its this, but for other thing
     *  like VM related context contortions, it can
     *  be something else
     * @return The base context.
     */
    public InternalContextAdapter getBaseContext()
    {
        return this;
    }
    /* -----  InternalEventContext ---- */
    /**
     * @see org.apache.velocity.context.InternalEventContext#attachEventCartridge(org.apache.velocity.app.event.EventCartridge)
     */
    public EventCartridge attachEventCartridge( EventCartridge ec )
    {
        if (iec != null)
        {
            return iec.attachEventCartridge( ec );
        }
        return null;
    }
    /**
     * @see org.apache.velocity.context.InternalEventContext#getEventCartridge()
     */
    public EventCartridge getEventCartridge()
    {
        if ( iec != null)
        {
            return iec.getEventCartridge( );
        }
        return null;
    }
}
"
org.apache.velocity.context.InternalContextBase,"package org.apache.velocity.context;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.HashMap;
import java.util.Stack;
import java.util.List;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
/**
 *  class to encapsulate the 'stuff' for internal operation of velocity.
 *  We use the context as a thread-safe storage : we take advantage of the
 *  fact that it's a visitor  of sorts  to all nodes (that matter) of the
 *  AST during init() and render().
 *  Currently, it carries the template name for namespace
 *  support, as well as node-local context data introspection caching.
 *
 *  Note that this is not a public class.  It is for package access only to
 *  keep application code from accessing the internals, as AbstractContext
 *  is derived from this.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: InternalContextBase.java 679861 2008-07-25 17:17:50Z nbubna $
 */
class InternalContextBase implements InternalHousekeepingContext, InternalEventContext
{
    /**
     * Version Id for serializable
     */
    private static final long serialVersionUID = -245905472770843470L;
    /**
     *  cache for node/context specific introspection information
     */
    private HashMap introspectionCache = new HashMap(33);
    /**
     *  Template name stack. The stack top contains the current template name.
     */
    private Stack templateNameStack = new Stack();
    /**
     *  Velocimacro name stack. The stack top contains the current macro name.
     */
    private Stack macroNameStack = new Stack();
    /**
     *  EventCartridge we are to carry.  Set by application
     */
    private EventCartridge eventCartridge = null;
    /**
     *  Current resource - used for carrying encoding and other
     *  information down into the rendering process
     */
    private Resource currentResource = null;
    /**
     *  Is rendering allowed?  Defaults to true, can be changed by #stop directive.
     */
    private boolean allowRendering = true;
    /**
     *  List for holding the macro libraries. Contains the macro library
     *  template name as strings.
     */
    private List macroLibraries = null;
    /**
     *  set the current template name on top of stack
     *
     *  @param s current template name
     */
    public void pushCurrentTemplateName( String s )
    {
        templateNameStack.push(s);
    }
    /**
     *  remove the current template name from stack
     */
    public void popCurrentTemplateName()
    {
        templateNameStack.pop();
    }
    /**
     *  get the current template name
     *
     *  @return String current template name
     */
    public String getCurrentTemplateName()
    {
        if ( templateNameStack.empty() )
            return ""<undef>"";
        else
            return (String) templateNameStack.peek();
    }
    /**
     *  get the current template name stack
     *
     *  @return Object[] with the template name stack contents.
     */
    public Object[] getTemplateNameStack()
    {
        return templateNameStack.toArray();
    }
    /**
     *  set the current macro name on top of stack
     *
     *  @param s current macro name
     */
    public void pushCurrentMacroName( String s )
    {
        macroNameStack.push(s);
    }
    /**
     *  remove the current macro name from stack
     */
    public void popCurrentMacroName()
    {
        macroNameStack.pop();
    }
    /**
     *  get the current macro name
     *
     *  @return String current macro name
     */
    public String getCurrentMacroName()
    {
        if (macroNameStack.empty())
        {
            return ""<undef>"";
        }
        else
        {
            return (String) macroNameStack.peek();
        }
    }
    /**
     *  get the current macro call depth
     *
     *  @return int current macro call depth
     */
    public int getCurrentMacroCallDepth()
    {
        return macroNameStack.size();
    }
    /**
     *  get the current macro name stack
     *
     *  @return Object[] with the macro name stack contents.
     */
    public Object[] getMacroNameStack()
    {
        return macroNameStack.toArray();
    }
    /**
     *  returns an IntrospectionCache Data (@see IntrospectionCacheData)
     *  object if exists for the key
     *
     *  @param key  key to find in cache
     *  @return cache object
     */
    public IntrospectionCacheData icacheGet( Object key )
    {
        return ( IntrospectionCacheData ) introspectionCache.get( key );
    }
    /**
     *  places an IntrospectionCache Data (@see IntrospectionCacheData)
     *  element in the cache for specified key
     *
     *  @param key  key
     *  @param o  IntrospectionCacheData object to place in cache
     */
    public void icachePut( Object key, IntrospectionCacheData o )
    {
        introspectionCache.put( key, o );
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#setCurrentResource(org.apache.velocity.runtime.resource.Resource)
     */
    public void setCurrentResource( Resource r )
    {
        currentResource = r;
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getCurrentResource()
     */
    public Resource getCurrentResource()
    {
        return currentResource;
    }
     /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getAllowRendering()
     */
    public boolean getAllowRendering()
     {
        return allowRendering;
     }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#setAllowRendering(boolean)
     */
    public void setAllowRendering(boolean v)
    {
        allowRendering = v;
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#setMacroLibraries(List)
     */
    public void setMacroLibraries(List macroLibraries)
    {
        this.macroLibraries = macroLibraries;
    }
    /**
     * @see org.apache.velocity.context.InternalHousekeepingContext#getMacroLibraries()
     */
    public List getMacroLibraries()
    {
        return macroLibraries;
    }
    /**
     * @see org.apache.velocity.context.InternalEventContext#attachEventCartridge(org.apache.velocity.app.event.EventCartridge)
     */
    public EventCartridge attachEventCartridge( EventCartridge ec )
    {
        EventCartridge temp = eventCartridge;
        eventCartridge = ec;
        return temp;
    }
    /**
     * @see org.apache.velocity.context.InternalEventContext#getEventCartridge()
     */
    public EventCartridge getEventCartridge()
    {
        return eventCartridge;
    }
}
"
org.apache.velocity.context.InternalEventContext,"package org.apache.velocity.context;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.app.event.EventCartridge;
/**
 *  Interface for event support.  Note that this is a public internal
 *  interface, as it is something that will be accessed from outside
 *  of the .context package.
 *
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: InternalEventContext.java 463298 2006-10-12 16:10:32Z henning $
 */
public interface InternalEventContext
{
    /**
     * @param ec
     * @return The old EventCartridge.
     */
    public EventCartridge attachEventCartridge( EventCartridge ec);
    /**
     * @return The current EventCartridge.
     */
    public EventCartridge getEventCartridge();
}
"
org.apache.velocity.context.InternalHousekeepingContext,"package org.apache.velocity.context;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.util.introspection.IntrospectionCacheData;
import org.apache.velocity.runtime.resource.Resource;
import java.util.List;
/**
 *  interface to encapsulate the 'stuff' for internal operation of velocity.
 *  We use the context as a thread-safe storage : we take advantage of the
 *  fact that it's a visitor  of sorts  to all nodes (that matter) of the
 *  AST during init() and render().
 *
 *  Currently, it carries the template name for namespace
 *  support, as well as node-local context data introspection caching.
 *
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @author <a href=""mailto:Christoph.Reck@dlr.de"">Christoph Reck</a>
 *  @version $Id: InternalHousekeepingContext.java 679861 2008-07-25 17:17:50Z nbubna $
 */
interface InternalHousekeepingContext
{
    /**
     *  set the current template name on top of stack
     *
     *  @param s current template name
     */
    void pushCurrentTemplateName( String s );
    /**
     *  remove the current template name from stack
     */
    void popCurrentTemplateName();
    /**
     *  get the current template name
     *
     *  @return String current template name
     */
    String getCurrentTemplateName();
    /**
     *  Returns the template name stack in form of an array.
     *
     *  @return Object[] with the template name stack contents.
     */
    Object[] getTemplateNameStack();
    /**
     *  set the current macro name on top of stack
     *
     *  @param s current macro name
     */
    void pushCurrentMacroName( String s );
    /**
     *  remove the current macro name from stack
     */
    void popCurrentMacroName();
    /**
     *  get the current macro name
     *
     *  @return String current macro name
     */
    String getCurrentMacroName();
    /**
     *  get the current macro call depth
     *
     *  @return int current macro call depth
     */
    int getCurrentMacroCallDepth();
    /**
     *  Returns the macro name stack in form of an array.
     *
     *  @return Object[] with the macro name stack contents.
     */
    Object[] getMacroNameStack();
    /**
     *  returns an IntrospectionCache Data (@see IntrospectionCacheData)
     *  object if exists for the key
     *
     *  @param key  key to find in cache
     *  @return cache object
     */
    IntrospectionCacheData icacheGet( Object key );
    /**
     *  places an IntrospectionCache Data (@see IntrospectionCacheData)
     *  element in the cache for specified key
     *
     *  @param key  key
     *  @param o  IntrospectionCacheData object to place in cache
     */
    void icachePut( Object key, IntrospectionCacheData o );
    /**
     *  temporary fix to enable #include() to figure out
     *  current encoding.
     *
     * @return The current resource.
     */
    Resource getCurrentResource();
    /**
     * @param r
     */
    void setCurrentResource( Resource r );
    /**
     * Checks to see if rendering should be allowed.  Defaults to true but will
     * return false after a #stop directive.
     *
     * @return true if rendering is allowed, false if no rendering should occur
     */
     boolean getAllowRendering();
    /**
     * Set whether rendering is allowed.  Defaults to true but is set to
     * false after a #stop directive.
     * @param v
     */
     void setAllowRendering(boolean v);
    /**
     * Set the macro library list for the current template.
     *
     * @param macroLibraries list of macro libraries to set
     */
     void setMacroLibraries(List macroLibraries);
    /**
     * Get the macro library list for the current template.
     *
     * @return List of macro library names
     */
     List getMacroLibraries();
}
"
org.apache.velocity.context.InternalWrapperContext,"package org.apache.velocity.context;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  interface for internal context wrapping functionality
 *
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: InternalWrapperContext.java 471908 2006-11-06 22:39:28Z henning $
 */
public interface InternalWrapperContext
{
    /**
     * Returns the wrapped user context.
     * @return The wrapped user context.
     */
    Context getInternalUserContext();
    /**
     * Returns the base full context impl.
     * @return The base full context impl.
     *
     */
    InternalContextAdapter getBaseContext();
    /**
     * Allows callers to explicitly put objects in the local context.
     * Objects added to the context through this method always end up
     * in the top-level context of possible wrapped contexts.
     *
     *  @param key name of item to set.
     *  @param value object to set to key.
     *  @return old stored object
     */
    Object localPut(final String key, final Object value);
}
"
org.apache.velocity.context.ProxyVMContext,"package org.apache.velocity.context;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.StringWriter;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.ParserTreeConstants;
import org.apache.velocity.runtime.parser.node.ASTReference;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
/**
 * Context for Velocity macro arguments.
 * 
 * This special context combines ideas of earlier VMContext and VMProxyArgs
 * by implementing routing functionality internally. This significantly
 * reduces memory allocation upon macro invocations.
 * Since the macro AST is now shared and RuntimeMacro directive is used,
 * the earlier implementation of precalculating VMProxyArgs would not work.
 * 
 * See <a href=""http://issues.apache.org/jira/browse/VELOCITY-607"">Issue 607</a>
 * for more info on this class.
 * @author <a href=""mailto:wyla@removeme.sci.fi"">Jarkko Viinamaki</a>
 * @version $Id$
 * @since 1.6
 */
public class ProxyVMContext extends ChainedInternalContextAdapter
{
    /** container for our macro AST node arguments. Size must be power of 2. */
    Map vmproxyhash = new HashMap(8, 0.8f);
    /** container for any local or constant macro arguments. Size must be power of 2. */
    Map localcontext = new HashMap(8, 0.8f);;
    /** context that we are wrapping */
    InternalContextAdapter wrappedContext;
    /** support for local context scope feature, where all references are local */
    private boolean localContextScope;
    /** needed for writing log entries. */
    private RuntimeServices rsvc;
    /**
     * @param inner Velocity context for processing
     * @param rsvc RuntimeServices provides logging reference
     * @param localContextScope if true, all references are set to be local
     */
    public ProxyVMContext(InternalContextAdapter inner,
                          RuntimeServices rsvc,
                          boolean localContextScope)
    {
        super(inner);
        this.localContextScope = localContextScope;
        this.rsvc = rsvc;
        wrappedContext = inner;
    }
    /**
     * Used to put Velocity macro arguments into this context. 
     * 
     * @param context rendering context
     * @param macroArgumentName name of the macro argument that we received
     * @param literalMacroArgumentName "".literal.$""+macroArgumentName
     * @param argumentValue actual value of the macro argument
     * 
     * @throws MethodInvocationException
     */
    public void addVMProxyArg(InternalContextAdapter context,
                              String macroArgumentName,
                              String literalMacroArgumentName,
                              Node argumentValue) throws MethodInvocationException
    {
        if (isConstant(argumentValue))
        {
            localcontext.put(macroArgumentName, argumentValue.value(context));
        }
        else
        {
            vmproxyhash.put(macroArgumentName, argumentValue);
            localcontext.put(literalMacroArgumentName, argumentValue);
        }
    }
    /**
     * AST nodes that are considered constants can be directly
     * saved into the context. Dynamic values are stored in
     * another argument hashmap.
     * 
     * @param node macro argument as AST node
     * @return true if the node is a constant value
     */
    private boolean isConstant(Node node)
    {
        switch (node.getType())
        {
            case ParserTreeConstants.JJTINTEGERRANGE:
            case ParserTreeConstants.JJTREFERENCE:
            case ParserTreeConstants.JJTOBJECTARRAY:
            case ParserTreeConstants.JJTMAP:
            case ParserTreeConstants.JJTSTRINGLITERAL:
            case ParserTreeConstants.JJTTEXT:
                return (false);
            default:
                return (true);
        }
    }
    /**
     * Impl of the Context.put() method.
     * 
     * @param key name of item to set
     * @param value object to set to key
     * @return old stored object
     */
    public Object put(final String key, final Object value)
    {
        return put(key, value, localContextScope);
    }
    /**
     * Allows callers to explicitly put objects in the local context, no matter what the
     * velocimacro.context.local setting says. Needed e.g. for loop variables in foreach.
     * 
     * @param key name of item to set.
     * @param value object to set to key.
     * @return old stored object
     */
    public Object localPut(final String key, final Object value)
    {
        return put(key, value, true);
    }
    /**
     * Internal put method to select between local and global scope.
     * 
     * @param key name of item to set
     * @param value object to set to key
     * @param forceLocal True forces the object into the local scope.
     * @return old stored object
     */
    protected Object put(final String key, final Object value, final boolean forceLocal)
    {
        Node astNode = (Node) vmproxyhash.get(key);
        if (astNode != null)
        {
            if (astNode.getType() == ParserTreeConstants.JJTREFERENCE)
            {
                ASTReference ref = (ASTReference) astNode;
                if (ref.jjtGetNumChildren() > 0)
                    ref.setValue(wrappedContext, value);
                else
                    wrappedContext.put(ref.getRootString(), value);
            }
            else
            {
                rsvc.getLog().error(""ProxyVMContext.put() : New value cannot be assigned to a constant: ""
                                    + key + "" / "" + get(""$"" + key + "".literal""));
            }
            return null;
        }
        else
        {
            if (forceLocal)
            {
                return localcontext.put(key, value);
            }
            else
            {
                if (localcontext.containsKey(key))
                {
                    return localcontext.put(key, value);
                }
                else
                {
                    return super.put(key, value);
                }
            }
        }
    }
    /**
     * Implementation of the Context.get() method.
     * 
     * @param key name of item to get
     * @return stored object or null
     */
    public Object get(String key)
    {
        Object o = null;
        Node astNode = (Node) vmproxyhash.get(key);
        if (astNode != null)
        {
            int type = astNode.getType();
            // if the macro argument (astNode) is a reference, we need to evaluate it
            // in case it is a multilevel node
            if (type == ParserTreeConstants.JJTREFERENCE)
            {
                ASTReference ref = (ASTReference) astNode;
                if (ref.jjtGetNumChildren() > 0)
                {
                    return ref.execute(null, wrappedContext);
                }
                else
                {
                    Object obj = wrappedContext.get(ref.getRootString());
                    if (obj == null && ref.strictRef)
                    {
                        if (!wrappedContext.containsKey(ref.getRootString()))
                        {
                            throw new MethodInvocationException(""Parameter '"" + ref.getRootString() 
                                + ""' not defined"", null, key, ref.getTemplateName(), 
                                ref.getLine(), ref.getColumn());
                        }
                    }
                    return obj;
                }
            }
            else if (type == ParserTreeConstants.JJTTEXT)
            {
                // this really shouldn't happen. text is just a throwaway arg for #foreach()
                try
                {
                    StringWriter writer = new StringWriter();
                    astNode.render(wrappedContext, writer);
                    return writer.toString();
                }
                catch (RuntimeException e)
                {
                    throw e;
                }
                catch (Exception e)
                {
                    String msg = ""ProxyVMContext.get() : error rendering reference"";
                    rsvc.getLog().error(msg, e);
                    throw new VelocityException(msg, e);
                }
            }
            else
            {
                // use value method to render other dynamic nodes
                return astNode.value(wrappedContext);
            }
        }
        else
        {
            o = localcontext.get(key);
            if (o == null)
            {
                o = super.get(key);
            }
        }
        return o;
    }
    /**
     * @see org.apache.velocity.context.Context#containsKey(java.lang.Object)
     */
    public boolean containsKey(Object key)
    {
      return vmproxyhash.containsKey(key)
          || localcontext.containsKey(key)
          || super.containsKey(key);
    }
    /**
     * @see org.apache.velocity.context.Context#getKeys()
     */
    public Object[] getKeys()
    {
        return vmproxyhash.keySet().toArray();
    }
    /**
     * @see org.apache.velocity.context.Context#remove(java.lang.Object)
     */
    public Object remove(Object key)
    {
        if (vmproxyhash.containsKey(key))
        {
            return vmproxyhash.remove(key);
        }
        else
        {
            if (localContextScope)
            {
                return localcontext.remove(key);
            }
            Object oldValue = localcontext.remove(key);
            if (oldValue == null)
            {
                oldValue = super.remove(key);
            }
            return oldValue;
        }
    }
}
"
org.apache.velocity.convert.WebMacro,"package org.apache.velocity.convert;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import org.apache.oro.text.perl.Perl5Util;
import org.apache.velocity.util.StringUtils;
import org.apache.tools.ant.DirectoryScanner;
/**
 * This class will convert a WebMacro template to
 * a Velocity template. Uses the ORO Regexp package to do the
 * rewrites. Note, it isn't 100% perfect, but will definitely get
 * you about 99.99% of the way to a converted system. Please
 * see the website documentation for more information on how to use
 * this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 * @version $Id: WebMacro.java 463298 2006-10-12 16:10:32Z henning $
 */
public class WebMacro
{
    /**
     *
     */
    protected static final String VM_EXT = "".vm"";
    /**
     *
     */
    protected static final String WM_EXT = "".wm"";
    /**
     * The regexes to use for line by line substition. The regexes
     * come in pairs. The first is the string to match, the second is
     * the substitution to make.
     */
    protected static String[] perLineREs =
    {
        // Make #if directive match the Velocity directive style.
        ""#if\\s*[(]\\s*(.*\\S)\\s*[)]\\s*(#begin|{)[ \\t]?"",
        ""#if( $1 )"",
        // Remove the WM #end #else #begin usage.
        ""[ \\t]?(#end|})[ \\t]*\n(\\s*)#else\\s*(#begin|{)[ \\t]?(\\w)"",
        ""$2#else#**#$4"", // avoid touching followup word with embedded comment
        ""[ \\t]?(#end|})[ \\t]*\n(\\s*)#else\\s*(#begin|{)[ \\t]?"",
        ""$2#else"",
        ""(#end|})(\\s*#else)\\s*(#begin|{)[ \\t]?"",
        ""$1\n$2"",
        // Convert WM style #foreach to Velocity directive style.
        ""#foreach\\s+(\\$\\w+)\\s+in\\s+(\\$[^\\s#]+)\\s*(#begin|{)[ \\t]?"",
        ""#foreach( $1 in $2 )"",
        // Convert WM style #set to Velocity directive style.
        ""#set\\s+(\\$[^\\s=]+)\\s*=\\s*([\\S \\t]+)"",
        ""#set( $1 = $2 )"",
        ""(##[# \\t\\w]*)\\)"", // fix comments included at end of line
        "")$1"",
        // Convert WM style #parse to Velocity directive style.
        ""#parse\\s+([^\\s#]+)[ \\t]?"",
        ""#parse( $1 )"",
        // Convert WM style #include to Velocity directive style.
        ""#include\\s+([^\\s#]+)[ \\t]?"",
        ""#include( $1 )"",
        // Convert WM formal reference to VTL syntax.
        ""\\$\\(([^\\)]+)\\)"",
        ""${$1}"",
        ""\\${([^}\\(]+)\\(([^}]+)}\\)"", // fix encapsulated brakets: {(})
        ""${$1($2)}"",
        // Velocity currently does not permit leading underscore.
        ""\\$_"",
        ""$l_"",
        ""\\${(_[^}]+)}"", // within a formal reference
        ""${l$1}"",
        // Eat semi-colons in (converted) VTL #set directives.
        ""(#set\\s*\\([^;]+);(\\s*\\))"",
        ""$1$2"",
        // Convert explicitly terminated WM statements to VTL syntax.
        ""(^|[^\\\\])\\$(\\w[^=\n;'\""]*);"",
        ""$1${$2}"",
        // Change extensions when seen.
        ""\\.wm"",
        "".vm""
    };
    /**
     * Iterate through the set of find/replace regexes
     * that will convert a given WM template to a VM template
     * @param target
     */
    public void convert(String target)
    {
        File file = new File(target);
        if (!file.exists())
        {
            throw new RuntimeException(""The specified template or directory does not exist"");
        }
        if (file.isDirectory())
        {
            String basedir = file.getAbsolutePath();
            String newBasedir = basedir + VM_EXT;
            DirectoryScanner ds = new DirectoryScanner();
            ds.setBasedir(basedir);
            ds.addDefaultExcludes();
            ds.scan();
            String[] files = ds.getIncludedFiles();
            for (int i = 0; i < files.length; i++)
            {
                writeTemplate(files[i], basedir, newBasedir);
            }
        }
        else
        {
            writeTemplate(file.getAbsolutePath(), """", """");
        }
    }
    /**
     * Write out the converted template to the given named file
     * and base directory.
     */
    private boolean writeTemplate(String file, String basedir,
                                  String newBasedir)
    {
        if (file.indexOf(WM_EXT) < 0)
        {
            return false;
        }
        System.out.println(""Converting "" + file + ""..."");
        String template = file;
        String newTemplate = convertName(file);
        if (basedir.length() > 0)
        {
            String templateDir = newBasedir + extractPath(file);
            File outputDirectory = new File(templateDir);
            template = basedir + File.separator + file;
            if (! outputDirectory.exists())
            {
                outputDirectory.mkdirs();
            }
            newTemplate = newBasedir + File.separator + convertName(file);
        }
        String convertedTemplate = convertTemplate(template);
        FileWriter fw = null;
        try
        {
            fw = new FileWriter(newTemplate);
            fw.write(convertedTemplate);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        finally
        {
            if (fw != null)
            {
                try
                {
                    fw.close();
                }
                catch (IOException io)
                {
                    // Do nothing
                }
            }
        }
        return true;
    }
    /**
     * Gets the path segment of the full path to a file (i.e. one
     * which originally included the file name).
     */
    private final String extractPath(String file)
    {
        int lastSepPos = file.lastIndexOf(File.separator);
        return (lastSepPos == -1 ? """" :
                File.separator + file.substring(0, lastSepPos));
    }
    /**
     * Simple extension conversion of .wm to .vm
     */
    private String convertName(String name)
    {
        return (name.indexOf(WM_EXT) < 0)
                ? name
                : name.substring(0, name.indexOf(WM_EXT)) + VM_EXT;
    }
    /**
     * How to use this little puppy :-)
     */
    private static final void usage()
    {
        System.err.println(""Usage: convert-wm <template.wm | directory>"");
    }
    /**
     * Apply find/replace regexes to our WM template
     * @param template
     * @return Returns the template with all regexprs applied.
     */
    public String convertTemplate(String template)
    {
        String contents = StringUtils.fileContentsToString(template);
        // Overcome Velocity 0.71 limitation.
        // HELP: Is this still necessary?
        if (!contents.endsWith(""\n""))
        {
            contents += ""\n"";
        }
        // Convert most markup.
        Perl5Util perl = new Perl5Util();
        for (int i = 0; i < perLineREs.length; i += 2)
        {
            contents = perl.substitute(makeSubstRE(i), contents);
        }
        // Convert closing curlies.
        if (perl.match(""m/javascript/i"", contents))
        {
            // ASSUMPTION: JavaScript is indented, WM is not.
            contents = perl.substitute(""s/\n}/\n#end/g"", contents);
        }
        else
        {
            contents = perl.substitute(""s/(\n\\s*)}/$1#end/g"", contents);
            contents = perl.substitute(""s/#end\\s*\n\\s*#else/#else/g"",
                                       contents);
        }
        return contents;
    }
    /**
     * Makes a Perl 5 regular expression for use by ORO.
     */
    private final String makeSubstRE(int i)
    {
        return (""s/"" + perLineREs[i] + '/' + perLineREs[i + 1] + ""/g"");
    }
    /**
     * Main hook for the conversion process.
     * @param args
     */
    public static void main(String[] args)
    {
        if (args.length > 0)
        {
            for (int x=0; x < args.length; x++)
            {
                WebMacro converter = new WebMacro();
                converter.convert(args[x]);
            }
        }
        else
        {
            usage();
        }
    }
}
"
org.apache.velocity.exception.ExtendedParseException,"package org.apache.velocity.exception;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * All Exceptions that can provide additional information about the place
 * where the error happened (template name, column and line number) can
 * implement this interface and the ParseErrorException will then be able
 * to deal with this information.
 *
 * @author <a href=""hps@intermeta.de"">Henning P. Schmiedehausen</a>
 * @version $Id: ExtendedParseException.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public interface ExtendedParseException
{
    /**
     * returns the Template name where this exception occured.
     * @return The Template name where this exception occured.
     */
    String getTemplateName();
    /**
     * returns the line number where this exception occured.
     * @return The line number where this exception occured.
     */
    int getLineNumber();
    /**
     * returns the column number where this exception occured.
     * @return The column number where this exception occured.
     */
    int getColumnNumber();
}
"
org.apache.velocity.exception.MacroOverflowException,"package org.apache.velocity.exception;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * Application-level exception thrown when macro calls within macro calls
 * exceeds the maximum allowed depth. The maximum allowable depth is given
 * in the configuration as velocimacro.max.depth.
 * @since 1.6
 */
public class MacroOverflowException extends VelocityException
{
    /**
    * Version Id for serializable
    */
    private static final long serialVersionUID = 7305635093478106342L;
    /**
     * @param exceptionMessage The message to register.
     */
    public MacroOverflowException(final String exceptionMessage)
    {
        super(exceptionMessage);
    }
    /**
     * @param exceptionMessage The message to register.
     * @param wrapped A throwable object that caused the Exception.
     */
    public MacroOverflowException(final String exceptionMessage, final Throwable wrapped)
    {
        super(exceptionMessage, wrapped);
    }
    /**
     * @param wrapped A throwable object that caused the Exception.
     */
    public MacroOverflowException(final Throwable wrapped)
    {
        super(wrapped);
    }
}
"
org.apache.velocity.exception.MathException,"package org.apache.velocity.exception;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * Separate exception class to distinguish math problems.   
 *
 * @author Nathan Bubna
 * @since 1.6
 * @version $Id: MathException.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public class MathException extends VelocityException
{
    public MathException(final String exceptionMessage)
    {
        super(exceptionMessage);
    }
}
"
org.apache.velocity.exception.MethodInvocationException,"package org.apache.velocity.exception;
import org.apache.commons.lang.StringUtils;
import org.apache.velocity.runtime.log.Log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 *  Application-level exception thrown when a reference method is
 *  invoked and an exception is thrown.
 *  <br>
 *  When this exception is thrown, a best effort will be made to have
 *  useful information in the exception's message.  For complete
 *  information, consult the runtime log.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: MethodInvocationException.java 703544 2008-10-10 18:15:53Z nbubna $
 */
public class MethodInvocationException extends VelocityException implements ExtendedParseException
{
    /**
     * Version Id for serializable
     */
    private static final long serialVersionUID = 7305685093478106342L;
    private String referenceName = """";
    private final String methodName;
    private final int lineNumber;
    private final int columnNumber;
    private final String templateName;
    /**
     *  CTOR - wraps the passed in exception for
     *  examination later
     *
     *  @param message
     *  @param e Throwable that we are wrapping
     *  @param methodName name of method that threw the exception
     *  @param templateName The name of the template where the exception occured.
     */
    public MethodInvocationException(final String message, final Throwable e, final String methodName, final String templateName, final int lineNumber, final int columnNumber)
    {
        super(message, e);
        this.methodName = methodName;
        this.templateName = templateName;
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    }
    /**
     *  Returns the name of the method that threw the
     *  exception.
     *
     *  @return String name of method
     */
    public String getMethodName()
    {
        return methodName;
    }
    /**
     *  Sets the reference name that threw this exception.
     *
     *  @param ref name of reference
     */
    public void setReferenceName(String ref)
    {
        referenceName = ref;
    }
    /**
     *  Retrieves the name of the reference that caused the
     *  exception.
     *
     *  @return name of reference.
     */
    public String getReferenceName()
    {
        return referenceName;
    }
    /**
     * @see ExtendedParseException#getColumnNumber()
     * @since 1.5
     */
    public int getColumnNumber()
    {
	    return columnNumber;
    }
    /**
     * @see ExtendedParseException#getLineNumber()
     * @since 1.5
     */
    public int getLineNumber()
    {
	    return lineNumber;
    }
    /**
     * @see ExtendedParseException#getTemplateName()
     * @since 1.5
     */
    public String getTemplateName()
    {
	    return templateName;
    }
    /**
     * @see Exception#getMessage()
     * @since 1.5
     */
    public String getMessage()
    {
        StringBuffer message = new StringBuffer();
        message.append(super.getMessage());
        message.append("" at "");
        message.append(Log.formatFileString(templateName, lineNumber, columnNumber));
        return message.toString();
    }
}
"
org.apache.velocity.exception.ParseErrorException,"package org.apache.velocity.exception;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.util.introspection.Info;
/**
 *  Application-level exception thrown when a resource of any type
 *  has a syntax or other error which prevents it from being parsed.
 *  <br>
 *  When this resource is thrown, a best effort will be made to have
 *  useful information in the exception's message.  For complete
 *  information, consult the runtime log.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""hps@intermeta.de"">Henning P. Schmiedehausen</a>
 * @version $Id: ParseErrorException.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public class ParseErrorException extends VelocityException
{
    /**
     * Version Id for serializable
     */
    private static final long serialVersionUID = -6665197935086306472L;
    /**
     * The column number of the parsing error, or -1 if not defined.
     */
    private int columnNumber = -1;
    /**
     * The line number of the parsing error, or -1 if not defined.
     */
    private int lineNumber = -1;
    /**
     * The name of the template containing the error, or null if not defined.
     */
    private String templateName = ""*unset*"";
    /**
     * If applicable, contains the invalid syntax or reference that triggered this exception
     */
    private String invalidSyntax;
    /**
     * Create a ParseErrorException with the given message.
     *
     * @param exceptionMessage the error exception message
     */
    public ParseErrorException(String exceptionMessage)
      {
          super(exceptionMessage);
    }
    /**
     * Create a ParseErrorException with the given ParseException.
     *
     * @param pex the parsing exception
     * @since 1.5
     */
    public ParseErrorException(ParseException pex)
    {
        super(pex.getMessage());
        // Don't use a second C'tor, TemplateParseException is a subclass of
        // ParseException...
        if (pex instanceof ExtendedParseException)
        {
            ExtendedParseException xpex = (ExtendedParseException) pex;
            columnNumber = xpex.getColumnNumber();
            lineNumber = xpex.getLineNumber();
            templateName = xpex.getTemplateName();
        }
        else
        {
            //  ugly, ugly, ugly...
            if (pex.currentToken != null && pex.currentToken.next != null)
            {
                columnNumber = pex.currentToken.next.beginColumn;
                lineNumber = pex.currentToken.next.beginLine;
            }
        }
    }
    /**
     * Create a ParseErrorException with the given ParseException.
     *
     * @param pex the parsing exception
     * @since 1.5
     */
    public ParseErrorException(VelocityException pex)
    {
        super(pex.getMessage());
        // Don't use a second C'tor, TemplateParseException is a subclass of
        // ParseException...
        if (pex instanceof ExtendedParseException)
        {
            ExtendedParseException xpex = (ExtendedParseException) pex;
            columnNumber = xpex.getColumnNumber();
            lineNumber = xpex.getLineNumber();
            templateName = xpex.getTemplateName();
        }
        else if (pex.getWrappedThrowable() instanceof ParseException)
        {
            ParseException pex2 = (ParseException) pex.getWrappedThrowable();
            if (pex2.currentToken != null && pex2.currentToken.next != null)
            {
                columnNumber = pex2.currentToken.next.beginColumn;
                lineNumber = pex2.currentToken.next.beginLine;
            }
        }
    }
    /**
     * Create a ParseErrorRuntimeException with the given message and info
     * 
     * @param exceptionMessage the error exception message
     * @param info an Info object with the current template info
     * @since 1.5
     */
    public ParseErrorException(String exceptionMessage, Info info)
    {
        super(exceptionMessage);
        columnNumber = info.getColumn();
        lineNumber = info.getLine();
        templateName = info.getTemplateName();        
    }    
    /**
     * Create a ParseErrorRuntimeException with the given message and info
     * 
     * @param exceptionMessage the error exception message
     * @param info an Info object with the current template info
     * @param invalidSyntax the invalid syntax or reference triggering this exception
     * @since 1.5
     */
    public ParseErrorException(String exceptionMessage, 
            Info info, String invalidSyntax)
    {
        super(exceptionMessage);
        columnNumber = info.getColumn();
        lineNumber = info.getLine();
        templateName = info.getTemplateName();  
        this.invalidSyntax = invalidSyntax;       
    }    
    /**
     * Return the column number of the parsing error, or -1 if not defined.
     *
     * @return column number of the parsing error, or -1 if not defined
     * @since 1.5
     */
    public int getColumnNumber()
    {
        return columnNumber;
    }
    /**
     * Return the line number of the parsing error, or -1 if not defined.
     *
     * @return line number of the parsing error, or -1 if not defined
     * @since 1.5
     */
    public int getLineNumber()
    {
        return lineNumber;
    }
    /**
     * Return the name of the template containing the error, or null if not
     * defined.
     *
     * @return the name of the template containing the parsing error, or null
     *      if not defined
     * @since 1.5
     */
    public String getTemplateName()
    {
        return templateName;
    }
    /**
     * Return the invalid syntax or reference that triggered this error, or null
     * if not defined.
     * 
     * @return Return the invalid syntax or reference that triggered this error, or null
     * if not defined
     * @since 1.5
     */
    public String getInvalidSyntax()
    {
        return invalidSyntax;
    }
}
"
org.apache.velocity.exception.ResourceNotFoundException,"package org.apache.velocity.exception;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Application-level exception thrown when a resource of any type
 *  isn't found by the Velocity engine.
 *  <br>
 *  When this exception is thrown, a best effort will be made to have
 *  useful information in the exception's message.  For complete
 *  information, consult the runtime log.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 * @version $Id: ResourceNotFoundException.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public class ResourceNotFoundException extends VelocityException
{
    /**
     * Version Id for serializable
     */
    private static final long serialVersionUID = -4287732191458420347L;
    /**
     * @see VelocityException#VelocityException(String)
     */
    public ResourceNotFoundException(final String exceptionMessage)
    {
        super(exceptionMessage);
    }
    /**
     * @see VelocityException#VelocityException(String, Throwable)
     * @since 1.5
     */
    public ResourceNotFoundException(final String exceptionMessage, final Throwable t)
    {
        super(exceptionMessage, t);
    }
    /**
     * @see VelocityException#VelocityException(Throwable)
     * @since 1.5
     */
    public ResourceNotFoundException(final Throwable t)
    {
        super(t);
    }
}
"
org.apache.velocity.exception.TemplateInitException,"package org.apache.velocity.exception;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.parser.ParseException;
/**
 * Exception generated to indicate parse errors caught during
 * directive initialization (e.g. wrong number of arguments)
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: TemplateInitException.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class TemplateInitException extends VelocityException 
        implements ExtendedParseException
{
    private final String templateName;
    private final int col;
    private final int line;
    /**
     * Version Id for serializable
     */
    private static final long serialVersionUID = -4985224672336070621L;
    public TemplateInitException(final String msg, 
            final String templateName, final int col, final int line)
    {
        super(msg);
        this.templateName = templateName;
        this.col = col;
        this.line = line;
    }
    public TemplateInitException(final String msg, ParseException parseException,
            final String templateName, final int col, final int line)
    {
        super(msg,parseException);
        this.templateName = templateName;
        this.col = col;
        this.line = line;
    }
    /**
     * Returns the Template name where this exception occured.
     * @return the template name
     */
    public String getTemplateName()
    {
        return templateName;
    }
    /**
     * Returns the line number where this exception occured.
     * @return the line number
     */
    public int getLineNumber()
    {
        return line;
    }
    /**
     * Returns the column number where this exception occured.
     * @return the line number
     */
    public int getColumnNumber()
    {
        return col;
    }
}
"
org.apache.velocity.exception.VelocityException,"package org.apache.velocity.exception;
import org.apache.velocity.util.ExceptionUtils;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
*  Base class for Velocity runtime exceptions thrown to the 
 * application layer.    
 *
 * @author <a href=""mailto:kdowney@amberarcher.com"">Kyle F. Downey</a>
 * @version $Id: VelocityException.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public class VelocityException
        extends RuntimeException
{
    /**
     * Version Id for serializable
     */
    private static final long serialVersionUID = 1251243065134956045L;
    private final Throwable wrapped;
    /**
     * @param exceptionMessage The message to register.
     */
    public VelocityException(final String exceptionMessage)
    {
        super(exceptionMessage);
        wrapped = null;
    }
    /**
     * @param exceptionMessage The message to register.
     * @param wrapped A throwable object that caused the Exception.
     * @since 1.5
     */
    public VelocityException(final String exceptionMessage, final Throwable wrapped)
    {
        super(exceptionMessage);
        this.wrapped = wrapped;
        ExceptionUtils.setCause(this, wrapped);
    }
    /**
     * @param wrapped A throwable object that caused the Exception.
     * @since 1.5
     */
    public VelocityException(final Throwable wrapped)
    {
        super();
        this.wrapped = wrapped;
        ExceptionUtils.setCause(this, wrapped);
    }
    /**
     *  returns the wrapped Throwable that caused this
     *  MethodInvocationException to be thrown
     *
     *  @return Throwable thrown by method invocation
     *  @since 1.5
     */
    public Throwable getWrappedThrowable()
    {
        return wrapped;
    }
}
"
org.apache.velocity.io.UnicodeInputStream,"package org.apache.velocity.io;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;
import org.apache.velocity.util.ExceptionUtils;
/**
 * This is an input stream that is unicode BOM aware. This allows you to e.g. read
 * Windows Notepad Unicode files as Velocity templates.
 *
 * It allows you to check the actual encoding of a file by calling {@link #getEncodingFromStream()} on
 * the input stream reader.
 *
 * This class is not thread safe! When more than one thread wants to use an instance of UnicodeInputStream,
 * the caller must provide synchronization.
 *
 * @author <a href=""mailto:mailmur@yahoo.com"">Aki Nieminen</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: UnicodeInputStream.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class UnicodeInputStream
    extends InputStream
{
    /** BOM Marker for UTF 8. See http://www.unicode.org/unicode/faq/utf_bom.html */
    public static final UnicodeBOM UTF8_BOM = new UnicodeBOM(""UTF-8"", new byte [] { (byte)0xef, (byte)0xbb, (byte)0xbf });
    /** BOM Marker for UTF 16, little endian. See http://www.unicode.org/unicode/faq/utf_bom.html */
    public static final UnicodeBOM UTF16LE_BOM = new UnicodeBOM(""UTF-16LE"", new byte [] { (byte)0xff, (byte)0xfe });
    /** BOM Marker for UTF 16, big endian. See http://www.unicode.org/unicode/faq/utf_bom.html */
    public static final UnicodeBOM UTF16BE_BOM = new UnicodeBOM(""UTF-16BE"", new byte [] { (byte)0xfe, (byte)0xff });
    /**
     * BOM Marker for UTF 32, little endian. See http://www.unicode.org/unicode/faq/utf_bom.html
     *
     * TODO: Does Java actually support this?
     */
    public static final UnicodeBOM UTF32LE_BOM = new UnicodeBOM(""UTF-32LE"", new byte [] { (byte)0xff, (byte)0xfe, (byte)0x00, (byte)0x00 });
    /**
     * BOM Marker for UTF 32, big endian. See http://www.unicode.org/unicode/faq/utf_bom.html
     *
     * TODO: Does Java actually support this?
     */
    public static final UnicodeBOM UTF32BE_BOM = new UnicodeBOM(""UTF-32BE"", new byte [] { (byte)0x00, (byte)0x00, (byte)0xfe, (byte)0xff });
    /** The maximum amount of bytes to read for a BOM */
    private static final int MAX_BOM_SIZE = 4;
    /** Buffer for BOM reading */
    private byte [] buf = new byte[MAX_BOM_SIZE];
    /** Buffer pointer. */
    private int pos = 0;
    /** The stream encoding as read from the BOM or null. */
    private final String encoding;
    /** True if the BOM itself should be skipped and not read. */
    private final boolean skipBOM;
    private final PushbackInputStream inputStream;
    /**
     * Creates a new UnicodeInputStream object. Skips a BOM which defines the file encoding.
     *
     * @param  inputStream The input stream to use for reading.
     */
    public UnicodeInputStream(final InputStream inputStream)
            throws IllegalStateException, IOException
    {
        this(inputStream, true);
    }
    /**
     * Creates a new UnicodeInputStream object.
     *
     * @param  inputStream The input stream to use for reading.
     * @param skipBOM If this is set to true, a BOM read from the stream is discarded. This parameter should normally be true.
     */
    public UnicodeInputStream(final InputStream inputStream, boolean skipBOM)
            throws IllegalStateException, IOException
    {
        super();
        this.skipBOM = skipBOM;
        this.inputStream = new PushbackInputStream(inputStream, MAX_BOM_SIZE);
        try
        {
            this.encoding = readEncoding();
        }
        catch (IOException ioe)
        {
            IllegalStateException ex = new IllegalStateException(""Could not read BOM from Stream"");
            ExceptionUtils.setCause(ex, ioe);
            throw ex;
        }
    }
    /**
     * Returns true if the input stream discards the BOM.
     *
     * @return  True if the input stream discards the BOM.
     */
    public boolean isSkipBOM()
    {
        return skipBOM;
    }
    /**
     * Read encoding based on BOM.
     *
     * @return  The encoding based on the BOM.
     *
     * @throws  IllegalStateException  When a problem reading the BOM occured.
     */
    public String getEncodingFromStream()
    {
        return encoding;
    }
    /**
     * This method gets the encoding from the stream contents if a BOM exists. If no BOM exists, the encoding
     * is undefined.
     *
     * @return The encoding of this streams contents as decided by the BOM or null if no BOM was found.
     */
    protected String readEncoding()
        throws IOException
    {
        pos = 0;
        UnicodeBOM encoding = null;
        // read first byte.
        if (readByte())
        {
            // Build a list of matches
            //
            // 00 00 FE FF --> UTF 32 BE
            // EF BB BF    --> UTF 8
            // FE FF       --> UTF 16 BE
            // FF FE       --> UTF 16 LE
            // FF FE 00 00 --> UTF 32 LE
            switch (buf[0])
            {
            case (byte)0x00: // UTF32 BE
                encoding = match(UTF32BE_BOM, null);
                break;
            case (byte)0xef: // UTF8
                encoding = match(UTF8_BOM, null);
                break;
            case (byte)0xfe: // UTF16 BE
                encoding = match(UTF16BE_BOM, null);
                break;
            case (byte)0xff: // UTF16/32 LE
                encoding = match(UTF16LE_BOM, null);
                if (encoding != null)
                {
                    encoding = match(UTF32LE_BOM, encoding);
                }
                break;
            default:
                encoding = null;
                break;
            }
        }
        pushback(encoding);
        return (encoding != null) ? encoding.getEncoding() : null;
    }
    private final UnicodeBOM match(final UnicodeBOM matchEncoding, final UnicodeBOM noMatchEncoding)
        throws IOException
    {
        byte [] bom = matchEncoding.getBytes();
        for (int i = 0; i < bom.length; i++)
        {
            if (pos <= i) // Byte has not yet been read
            {
                if (!readByte())
                {
                    return noMatchEncoding;
                }
            }
            if (bom[i] != buf[i])
            {
                return noMatchEncoding;
            }
        }
        return matchEncoding;
    }
    private final boolean readByte()
            throws IOException
    {
        int res = inputStream.read();
        if (res == -1)
        {
            return false;
        }
        if (pos >= buf.length)
        {
            throw new IOException(""BOM read error"");
        }
        buf[pos++] = (byte) res;
        return true;
    }
    private final void pushback(final UnicodeBOM matchBOM)
        throws IOException
    {
        int count = pos; // By default, all bytes are pushed back.
        int start = 0;
        if (matchBOM != null && skipBOM)
        {
            // We have a match (some bytes are part of the BOM)
            // and we want to skip the BOM. Push back only the bytes
            // after the BOM.
            start = matchBOM.getBytes().length;
            count = (pos - start);
            if (count < 0)
            {
                throw new IllegalStateException(""Match has more bytes than available!"");
            }
        }
        inputStream.unread(buf, start, count);
    }
    /**
     * @see java.io.InputStream#close()
     */
    public void close()
        throws IOException
    {
        inputStream.close();
    }
    /**
     * @see java.io.InputStream#available()
     */
    public int available()
        throws IOException
    {
        return inputStream.available();
    }
    /**
     * @see java.io.InputStream#mark(int)
     */
    public void mark(final int readlimit)
    {
        inputStream.mark(readlimit);
    }
    /**
     * @see java.io.InputStream#markSupported()
     */
    public boolean markSupported()
    {
        return inputStream.markSupported();
    }
    /**
     * @see java.io.InputStream#read()
     */
    public int read()
        throws IOException
    {
        return inputStream.read();
    }
    /**
     * @see java.io.InputStream#read(byte[])
     */
    public int read(final byte [] b)
        throws IOException
    {
        return inputStream.read(b);
    }
    /**
     * @see java.io.InputStream#read(byte[], int, int)
     */
    public int read(final byte [] b, final int off, final int len)
        throws IOException
    {
        return inputStream.read(b, off, len);
    }
    /**
     * @see java.io.InputStream#reset()
     */
    public void reset()
        throws IOException
    {
        inputStream.reset();
    }
    /**
     * @see java.io.InputStream#skip(long)
     */
    public long skip(final long n)
        throws IOException
    {
        return inputStream.skip(n);
    }
    /**
     * Helper class to bundle encoding and BOM marker.
     *
     * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
     * @version $Id: UnicodeInputStream.java 685685 2008-08-13 21:43:27Z nbubna $
     */
    static final class UnicodeBOM
    {
        private final String encoding;
        private final byte [] bytes;
        private UnicodeBOM(final String encoding, final byte [] bytes)
        {
            this.encoding = encoding;
            this.bytes = bytes;
        }
        String getEncoding()
        {
            return encoding;
        }
        byte [] getBytes()
        {
            return bytes;
        }
    }
}
"
org.apache.velocity.io.VelocityWriter,"package org.apache.velocity.io;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
/**
 * Implementation of a fast Writer. It was originally taken from JspWriter
 * and modified to have less syncronization going on.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author Anil K. Vijendran
 * @version $Id: VelocityWriter.java 463298 2006-10-12 16:10:32Z henning $
 */
public final class VelocityWriter extends Writer
{
    /**
     * constant indicating that the Writer is not buffering output
     */
    public static final int	NO_BUFFER = 0;
    /**
     * constant indicating that the Writer is buffered and is using the
     * implementation default buffer size
     */
    public static final int	DEFAULT_BUFFER = -1;
    /**
     * constant indicating that the Writer is buffered and is unbounded;
     * this is used in BodyContent
     */
    public static final int	UNBOUNDED_BUFFER = -2;
    private int     bufferSize;
    private boolean autoFlush;
    private Writer writer;
    private char cb[];
    private int nextChar;
    private static int defaultCharBufferSize = 8 * 1024;
    /**
     * Create a buffered character-output stream that uses a default-sized
     * output buffer.
     *
     * @param  writer  Writer to wrap around
     */
    public VelocityWriter(Writer writer)
    {
        this(writer, defaultCharBufferSize, true);
    }
    /**
     * private constructor.
     */
    private VelocityWriter(int bufferSize, boolean autoFlush)
    {
        this.bufferSize = bufferSize;
        this.autoFlush  = autoFlush;
    }
    /**
     * This method returns the size of the buffer used by the JspWriter.
     *
     * @return the size of the buffer in bytes, or 0 is unbuffered.
     */
    public int getBufferSize() { return bufferSize; }
    /**
     * This method indicates whether the JspWriter is autoFlushing.
     *
     * @return if this JspWriter is auto flushing or throwing IOExceptions on
     *         buffer overflow conditions
     */
    public boolean isAutoFlush() { return autoFlush; }
    /**
     * Create a new buffered character-output stream that uses an output
     * buffer of the given size.
     *
     * @param  writer  Writer to wrap around
     * @param  sz   	Output-buffer size, a positive integer
     * @param autoFlush
     *
     * @exception  IllegalArgumentException  If sz is <= 0
     */
    public VelocityWriter(Writer writer, int sz, boolean autoFlush)
    {
        this(sz, autoFlush);
        if (sz < 0)
            throw new IllegalArgumentException(""Buffer size <= 0"");
        this.writer = writer;
        cb = sz == 0 ? null : new char[sz];
        nextChar = 0;
    }
    /**
     * Flush the output buffer to the underlying character stream, without
     * flushing the stream itself.  This method is non-private only so that it
     * may be invoked by PrintStream.
     */
    private final void flushBuffer() throws IOException
    {
        if (bufferSize == 0)
            return;
        if (nextChar == 0)
            return;
        writer.write(cb, 0, nextChar);
        nextChar = 0;
    }
    /**
     * Discard the output buffer.
     */
    public final void clear()
    {
        nextChar = 0;
    }
    private final void bufferOverflow() throws IOException
    {
        throw new IOException(""overflow"");
    }
    /**
     * Flush the stream.
     * @throws IOException
     *
     */
    public final void flush()  throws IOException
    {
        flushBuffer();
        if (writer != null)
        {
            writer.flush();
        }
    }
    /**
     * Close the stream.
     * @throws IOException
     *
     */
    public final void close() throws IOException {
        if (writer == null)
            return;
        flush();
    }
    /**
     * @return the number of bytes unused in the buffer
     */
    public final int getRemaining()
    {
        return bufferSize - nextChar;
    }
    /**
     * Write a single character.
     * @param c
     * @throws IOException
     *
     */
    public final void write(int c) throws IOException
    {
        if (bufferSize == 0)
        {
            writer.write(c);
        }
        else
        {
            if (nextChar >= bufferSize)
                if (autoFlush)
                    flushBuffer();
                else
                    bufferOverflow();
            cb[nextChar++] = (char) c;
        }
    }
    /**
     * Our own little min method, to avoid loading
     * <code>java.lang.Math</code> if we've run out of file
     * descriptors and we're trying to print a stack trace.
     */
    private final int min(int a, int b)
    {
	    return (a < b ? a : b);
    }
    /**
     * Write a portion of an array of characters.
     *
     * <p> Ordinarily this method stores characters from the given array into
     * this stream's buffer, flushing the buffer to the underlying stream as
     * needed.  If the requested length is at least as large as the buffer,
     * however, then this method will flush the buffer and write the characters
     * directly to the underlying stream.  Thus redundant
     * <code>DiscardableBufferedWriter</code>s will not copy data unnecessarily.
     *
     * @param  cbuf  A character array
     * @param  off   Offset from which to start reading characters
     * @param  len   Number of characters to write
     * @throws IOException
     *
     */
    public final void write(char cbuf[], int off, int len)
        throws IOException
    {
        if (bufferSize == 0)
        {
            writer.write(cbuf, off, len);
            return;
        }
        if (len == 0)
        {
            return;
        }
        if (len >= bufferSize)
        {
            /* If the request length exceeds the size of the output buffer,
            flush the buffer and then write the data directly.  In this
            way buffered streams will cascade harmlessly. */
            if (autoFlush)
                flushBuffer();
            else
                bufferOverflow();
                writer.write(cbuf, off, len);
            return;
        }
        int b = off, t = off + len;
        while (b < t)
        {
            int d = min(bufferSize - nextChar, t - b);
            System.arraycopy(cbuf, b, cb, nextChar, d);
            b += d;
            nextChar += d;
            if (nextChar >= bufferSize)
                if (autoFlush)
                    flushBuffer();
                else
                    bufferOverflow();
        }
    }
    /**
     * Write an array of characters.  This method cannot be inherited from the
     * Writer class because it must suppress I/O exceptions.
     * @param buf
     * @throws IOException
     */
    public final void write(char buf[]) throws IOException
    {
    	write(buf, 0, buf.length);
    }
    /**
     * Write a portion of a String.
     *
     * @param  s     String to be written
     * @param  off   Offset from which to start reading characters
     * @param  len   Number of characters to be written
     * @throws IOException
     *
     */
    public final void write(String s, int off, int len) throws IOException
    {
        if (bufferSize == 0)
        {
            writer.write(s, off, len);
            return;
        }
        int b = off, t = off + len;
        while (b < t)
        {
            int d = min(bufferSize - nextChar, t - b);
            s.getChars(b, b + d, cb, nextChar);
            b += d;
            nextChar += d;
            if (nextChar >= bufferSize)
                if (autoFlush)
                    flushBuffer();
                else
                    bufferOverflow();
        }
    }
    /**
     * Write a string.  This method cannot be inherited from the Writer class
     * because it must suppress I/O exceptions.
     * @param s
     * @throws IOException
     */
    public final void write(String s) throws IOException
    {
        if (s != null)
        {
            write(s, 0, s.length());
        }
    }
    /**
     * resets this class so that it can be reused
     * @param writer
     *
     */
    public final void recycle(Writer writer)
    {
        this.writer = writer;
        clear();
    }
}
"
org.apache.velocity.runtime.ParserPool,"package org.apache.velocity.runtime;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.parser.Parser;
/**
 * Provides instances of parsers as needed.  get() will return a new parser if
 * available.  If a parser is acquired from the pool, put() should be called
 * with that parser to make it available again for reuse.
 *
 * @author <a href=""mailto:sergek@lokitech.com"">Serge Knystautas</a>
 * @version $Id: RuntimeInstance.java 384374 2006-03-08 23:19:30Z nbubna $
 * @since 1.5
 */
public interface ParserPool
{
    /**
     * Initialize the pool so that it can begin serving parser instances.
     * @param svc
     */
    void initialize(RuntimeServices svc);
    /**
     * Retrieve an instance of a parser pool.
     * @return A parser object.
     */
    Parser get();
    /**
     * Return the parser to the pool so that it may be reused.
     * @param parser
     */
    void put(Parser parser);
}
"
org.apache.velocity.runtime.ParserPoolImpl,"package org.apache.velocity.runtime;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.SimplePool;
import org.apache.velocity.runtime.parser.CharStream;
/**
 * This wraps the original parser SimplePool class.  It also handles
 * instantiating ad-hoc parsers if none are available.
 *
 * @author <a href=""mailto:sergek@lokitech.com"">Serge Knystautas</a>
 * @version $Id: RuntimeInstance.java 384374 2006-03-08 23:19:30Z nbubna $
 * @since 1.5
 */
public class ParserPoolImpl implements ParserPool {
    SimplePool pool = null;
    int max = RuntimeConstants.NUMBER_OF_PARSERS;
    /**
     * Create the underlying ""pool"".
     * @param rsvc
     */
    public void initialize(RuntimeServices rsvc)
    {
        max = rsvc.getInt(RuntimeConstants.PARSER_POOL_SIZE, RuntimeConstants.NUMBER_OF_PARSERS);
        pool = new SimplePool(max);
        for (int i = 0; i < max; i++)
        {
            pool.put(rsvc.createNewParser());
        }
        if (rsvc.getLog().isDebugEnabled())
        {
            rsvc.getLog().debug(""Created '"" + max + ""' parsers."");
        }
    }
    /**
     * Call the wrapped pool.  If none are available, it will create a new
     * temporary one.
     * @return A parser Object.
     */
    public Parser get()
    {
        return (Parser) pool.get();
    }
    /**
     * Call the wrapped pool.
     * @param parser
     */
    public void put(Parser parser)
    {
        parser.ReInit((CharStream) null);
        pool.put(parser);
    }
}
"
org.apache.velocity.runtime.Renderable,"package org.apache.velocity.runtime;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import java.io.Writer;
import java.io.IOException;
/**
 *  This interface caraterize objects other than ASTNodes that can be rendered
 *  to a writer using a context.
 *
 * @author <a href=""mailto:claude.brisson@gmail.com"">Claude Brisson</a>
 * @version $Id:$
 * @since 1.6
 */
public interface Renderable {
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException, MethodInvocationException, ParseErrorException, ResourceNotFoundException;
}
"
org.apache.velocity.runtime.Runtime,"package org.apache.velocity.runtime;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.io.Reader;
import java.util.Properties;
import org.apache.velocity.Template;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.resource.ContentResource;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * This is the Runtime system for Velocity. It is the
 * single access point for all functionality in Velocity.
 * It adheres to the mediator pattern and is the only
 * structure that developers need to be familiar with
 * in order to get Velocity to perform.
 *
 * The Runtime will also cooperate with external
 * systems like Turbine. Runtime properties can
 * set and then the Runtime is initialized.
 *
 * Turbine for example knows where the templates
 * are to be loaded from, and where the velocity
 * log file should be placed.
 *
 * So in the case of Velocity cooperating with Turbine
 * the code might look something like the following:
 *
 * <pre>
 * Runtime.setProperty(Runtime.FILE_RESOURCE_LOADER_PATH, templatePath);
 * Runtime.setProperty(Runtime.RUNTIME_LOG, pathToVelocityLog);
 * Runtime.init();
 * </pre>
 *
 * <pre>
 * -----------------------------------------------------------------------
 * N O T E S  O N  R U N T I M E  I N I T I A L I Z A T I O N
 * -----------------------------------------------------------------------
 * Runtime.init()
 *
 * If Runtime.init() is called by itself the Runtime will
 * initialize with a set of default values.
 * -----------------------------------------------------------------------
 * Runtime.init(String/Properties)
 *
 * In this case the default velocity properties are layed down
 * first to provide a solid base, then any properties provided
 * in the given properties object will override the corresponding
 * default property.
 * -----------------------------------------------------------------------
 * </pre>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:jlb@houseofdistraction.com"">Jeff Bowden</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magusson Jr.</a>
 *
 * @see org.apache.velocity.runtime.RuntimeInstance
 * @see org.apache.velocity.runtime.RuntimeSingleton
 * @deprecated Use RuntimeInstance or RuntimeSingleton instead.
 *
 * @version $Id: Runtime.java 685390 2008-08-13 00:07:23Z nbubna $
 */
public class Runtime implements RuntimeConstants
{
    /**
     * This is the primary initialization method in the Velocity
     * Runtime. The systems that are setup/initialized here are
     * as follows:
     *
     * <ul>
     *   <li>Logging System</li>
     *   <li>ResourceManager</li>
     *   <li>Parser Pool</li>
     *   <li>Global Cache</li>
     *   <li>Static Content Include System</li>
     *   <li>Velocimacro System</li>
     * </ul>
     *
     * @throws Exception When init fails for any reason.
     */
    public synchronized static void init()
        throws Exception
    {
        RuntimeSingleton.init();
    }
    /**
     * Allows an external system to set a property in
     * the Velocity Runtime.
     *
     * @param key The property key.
     * @param value The property value.
     */
    public static void setProperty(String key, Object value)
    {
        RuntimeSingleton.setProperty( key, value );
    }
    /**
     * Allow an external system to set an ExtendedProperties
     * object to use. This is useful where the external
     * system also uses the ExtendedProperties class and
     * the velocity configuration is a subset of
     * parent application's configuration. This is
     * the case with Turbine.
     *
     * @param configuration A configuration object.
     */
    public static void setConfiguration( ExtendedProperties configuration)
    {
        RuntimeSingleton.setConfiguration( configuration );
    }
    /**
     * Add a property to the configuration. If it already
     * exists then the value stated here will be added
     * to the configuration entry. For example, if
     *
     * resource.loader = file
     *
     * is already present in the configuration and you
     *
     * addProperty(""resource.loader"", ""classpath"")
     *
     * Then you will end up with a Vector like the
     * following:
     *
     * [""file"", ""classpath""]
     *
     * @param key A property key.
     * @param value The property value.
     */
    public static void addProperty(String key, Object value)
    {
        RuntimeSingleton.addProperty( key, value );
    }
    /**
     * Clear the values pertaining to a particular
     * property.
     *
     * @param key Name of the property to clear.
     */
    public static void clearProperty(String key)
    {
        RuntimeSingleton.clearProperty( key );
    }
    /**
     *  Allows an external caller to get a property.  The calling
     *  routine is required to know the type, as this routine
     *  will return an Object, as that is what properties can be.
     *
     *  @param key property to return
     * @return The property value or null.
     */
    public static Object getProperty( String key )
    {
        return RuntimeSingleton.getProperty( key );
    }
    /**
     * Initialize the Velocity Runtime with a Properties
     * object.
     *
     * @param p The properties used for initializiation.
     * @throws Exception When a problem occurs during init.
     */
    public static void init(Properties p) throws Exception
    {
        RuntimeSingleton.init(p);
    }
    /**
     * Initialize the Velocity Runtime with the name of
     * ExtendedProperties object.
     *
     * @param configurationFile The name of a properties file.
     * @throws Exception When a problem occurs during init.
     */
    public static void init(String configurationFile)
        throws Exception
    {
        RuntimeSingleton.init( configurationFile );
    }
    /**
     * Parse the input and return the root of
     * AST node structure.
     * <br><br>
     *  In the event that it runs out of parsers in the
     *  pool, it will create and let them be GC'd
     *  dynamically, logging that it has to do that.  This
     *  is considered an exceptional condition.  It is
     *  expected that the user will set the
     *  PARSER_POOL_SIZE property appropriately for their
     *  application.  We will revisit this.
     *
     * @param reader A reader returning the template input stream.
     * @param templateName name of the template being parsed
     * @return The root node of an AST structure for the template input stream.
     * @throws ParseException When the input stream is not parsable.
     */
    public static SimpleNode parse( Reader reader, String templateName )
        throws ParseException
    {
        return RuntimeSingleton.parse( reader, templateName );
    }
    /**
     * Parse the input and return the root of the AST node structure.
     *
     * @see #parse(Reader, String)
     *
     * @param reader A reader returning the template input stream.
     * @param templateName name of the template being parsed
     * @param dumpNamespace flag to dump the Velocimacro namespace for this template.
     * @return The root node of an AST structure for the template input stream.
     * @throws ParseException When the input stream is not parsable.
     */
    public static SimpleNode parse( Reader reader, String templateName, boolean dumpNamespace )
        throws ParseException
    {
        return RuntimeSingleton.parse( reader, templateName, dumpNamespace );
    }
    /**
     * Returns a <code>Template</code> from the resource manager.
     * This method assumes that the character encoding of the
     * template is set by the <code>input.encoding</code>
     * property.  The default is ""ISO-8859-1""
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization.
     */
    public static Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate( name );
    }
    /**
     * Returns a <code>Template</code> from the resource manager
     *
     * @param name The  name of the desired template.
     * @param encoding Character encoding of the template
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public static Template getTemplate(String name, String  encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate( name, encoding );
    }
    /**
     * Returns a static content resource from the
     * resource manager.  Uses the current value
     * if INPUT_ENCODING as the character encoding.
     *
     * @param name Name of content resource to get
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public static ContentResource getContent(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getContent( name );
    }
    /**
     * Returns a static content resource from the
     * resource manager.
     *
     * @param name Name of content resource to get
     * @param encoding Character encoding to use
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public static ContentResource getContent( String name, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getContent( name, encoding );
    }
    /**
     *  Determines is a template exists, and returns name of the loader that
     *  provides it.  This is a slightly less hokey way to support
     *  the Velocity.templateExists() utility method, which was broken
     *  when per-template encoding was introduced.  We can revisit this.
     *
     *  @param resourceName Name of template or content resource
     *  @return class name of loader than can provide it
     */
    public static String getLoaderNameForResource( String resourceName )
    {
        return RuntimeSingleton.getLoaderNameForResource( resourceName );
    }
    /**
     * Log a warning message.
     *
     * @param message message to log
     */
    public static void warn(Object message)
    {
        RuntimeSingleton.warn( message );
    }
    /**
     * Log an info message.
     *
     * @param message message to log
     */
    public static void info(Object message)
    {
        RuntimeSingleton.info( message );
    }
    /**
     * Log an error message.
     *
     * @param message message to log
     */
    public static void error(Object message)
    {
        RuntimeSingleton.error( message );
    }
    /**
     * Log a debug message.
     *
     * @param message message to log
     */
    public static void debug(Object message)
    {
        RuntimeSingleton.debug( message );
    }
    /**
     * String property accessor method with default to hide the
     * configuration implementation.
     *
     * @param key A property key.
     * @param defaultValue  default value to return if key not
     *               found in resource manager.
     * @return The property value of of key or default.
     */
    public static String getString( String key, String defaultValue)
    {
        return RuntimeSingleton.getString( key, defaultValue );
    }
    /**
     * Returns the appropriate VelocimacroProxy object if strVMname
     * is a valid current Velocimacro.
     *
     * @param vmName  Name of velocimacro requested
     * @param templateName The template from which the macro is requested.
     * @return A VelocimacroProxy object for the macro.
     */
    public static Directive getVelocimacro( String vmName, String templateName  )
    {
        return RuntimeSingleton.getVelocimacro( vmName, templateName );
    }
   /**
     * Adds a new Velocimacro. Usually called by Macro only while parsing.
     *
     * @param name  Name of a new velocimacro.
     * @param macro String form of the macro body.
     * @param argArray  Array of strings, containing the
     *                         #macro() arguments.  the 0th argument is the name.
     * @param sourceTemplate The template from which the macro is requested.
     * @return boolean  True if added, false if rejected for some
     *                  reason (either parameters or permission settings)
     * @deprecated Just like the whole class....
     */
    public static boolean addVelocimacro( String name,
                                          String macro,
                                          String argArray[],
                                          String sourceTemplate )
    {
        return RuntimeSingleton.addVelocimacro( name, macro, argArray, sourceTemplate );
    }
    /**
     *  Checks to see if a VM exists
     *
     * @param vmName  The name of velocimacro.
     * @param templateName The template from which the macro is requested.
     * @return boolean  True if VM by that name exists, false if not
     */
    public static boolean isVelocimacro( String vmName, String templateName )
    {
        return RuntimeSingleton.isVelocimacro( vmName, templateName );
    }
    /**
     *  tells the vmFactory to dump the specified namespace.  This is to support
     *  clearing the VM list when in inline-VM-local-scope mode
     *
     * @param namespace The namespace to dump.
     * @return True if the namespace has been dumped.
     */
    public static boolean dumpVMNamespace( String namespace )
    {
        return RuntimeSingleton.dumpVMNamespace( namespace );
    }
    /* --------------------------------------------------------------------
     * R U N T I M E  A C C E S S O R  M E T H O D S
     * --------------------------------------------------------------------
     * These are the getXXX() methods that are a simple wrapper
     * around the configuration object. This is an attempt
     * to make a the Velocity Runtime the single access point
     * for all things Velocity, and allow the Runtime to
     * adhere as closely as possible the the Mediator pattern
     * which is the ultimate goal.
     * --------------------------------------------------------------------
     */
    /**
     * String property accessor method to hide the configuration implementation
     * @param key  property key
     * @return   value of key or null
     */
    public static String getString(String key)
    {
        return RuntimeSingleton.getString( key );
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key A property key.
     * @return Integer value for this key.
     */
    public static int getInt( String key )
    {
        return RuntimeSingleton.getInt( key );
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key  property key
     * @param defaultValue default value
     * @return The integer value.
     */
    public static int getInt( String key, int defaultValue )
    {
        return RuntimeSingleton.getInt( key, defaultValue );
    }
    /**
     * Boolean property accessor method to hide the configuration implementation.
     *
     * @param key  property key
     * @param def default default value if property not found
     * @return boolean  value of key or default value
     */
    public static boolean getBoolean( String key, boolean def )
    {
        return RuntimeSingleton.getBoolean( key, def );
    }
    /**
     * Return the velocity runtime configuration object.
     *
     * @return ExtendedProperties configuration object which houses
     *                       the velocity runtime properties.
     */
    public static ExtendedProperties getConfiguration()
    {
        return RuntimeSingleton.getConfiguration();
    }
}
"
org.apache.velocity.runtime.RuntimeConstants,"package org.apache.velocity.runtime;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * This class defines the keys that are used in the velocity.properties file so that they can be referenced as a constant within
 * Java code.
 *
 * @author  <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author  <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author  <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version  $Id: RuntimeConstants.java 702218 2008-10-06 18:15:18Z nbubna $
 */
public interface RuntimeConstants
{
    /*
     * ----------------------------------------------------------------------
     * These are public constants that are used as handles for the
     * properties that can be specified in your typical
     * velocity.properties file.
     * ----------------------------------------------------------------------
     */
    /*
     * ----------------------------------------------------------------------
     * L O G G I N G  C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     */
    /** Location of the velocity log file. */
    String RUNTIME_LOG = ""runtime.log"";
    /** externally provided logger. */
    String RUNTIME_LOG_LOGSYSTEM = ""runtime.log.logsystem"";
    /** class of log system to use. */
    String RUNTIME_LOG_LOGSYSTEM_CLASS = ""runtime.log.logsystem.class"";
    /**
     * Properties referenced in the template are required to exist the object
     */
    String RUNTIME_REFERENCES_STRICT = ""runtime.references.strict"";
    /**
     * @deprecated  This appears to have always been meaningless.
     */
    String RUNTIME_LOG_ERROR_STACKTRACE = ""runtime.log.error.stacktrace"";
    /**
     * @deprecated  The functionality this controlled is confusing and no longer necessary.
     */
    String RUNTIME_LOG_WARN_STACKTRACE = ""runtime.log.warn.stacktrace"";
    /**
     * @deprecated  This appears to have always been meaningless.
     */
    String RUNTIME_LOG_INFO_STACKTRACE = ""runtime.log.info.stacktrace"";
    /** Logging of invalid references. */
    String RUNTIME_LOG_REFERENCE_LOG_INVALID = ""runtime.log.invalid.references"";
    /**
     * @deprecated  Use LogChute.TRACE_PREFIX instead
     */
    String TRACE_PREFIX = "" [trace] "";
    /**
     * @deprecated  Use LogChute.DEBUG_PREFIX instead
     */
    String DEBUG_PREFIX = "" [debug] "";
    /**
     * @deprecated  Use LogChute.INFO_PREFIX instead
     */
    String INFO_PREFIX = ""  [info] "";
    /**
     * @deprecated  Use LogChute.WARN_PREFIX instead
     */
    String WARN_PREFIX = ""  [warn] "";
    /**
     * @deprecated  Use LogChute.ERROR_PREFIX instead
     */
    String ERROR_PREFIX = "" [error] "";
    /**
     * @deprecated  This will be removed in a future version
     */
    String UNKNOWN_PREFIX = "" [unknown] "";
    /*
     * ----------------------------------------------------------------------
     * D I R E C T I V E  C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     * Directive properties are of the form:
     *
     * directive.<directive-name>.<property>
     * ----------------------------------------------------------------------
     */
    /** Counter reference name in #foreach directives. */
    String COUNTER_NAME = ""directive.foreach.counter.name"";
    /**
     * Iterator.hasNext() reference name in #foreach directives.
     * @since 1.6
     */
    String HAS_NEXT_NAME = ""directive.foreach.iterator.name"";
    /** Initial counter value in #foreach directives. */
    String COUNTER_INITIAL_VALUE = ""directive.foreach.counter.initial.value"";
    /** Maximum allowed number of loops. */
    String MAX_NUMBER_LOOPS = ""directive.foreach.maxloops"";
    /**
     * Whether to throw an exception or just skip bad iterables. Default is true.
     * @since 1.6
     */
    String SKIP_INVALID_ITERATOR = ""directive.foreach.skip.invalid"";
    /** if set to true then allows #set to accept null values in the right hand side. */
    String SET_NULL_ALLOWED = ""directive.set.null.allowed"";
    /**
     * Starting tag for error messages triggered by passing a parameter not allowed in the #include directive. Only string literals,
     * and references are allowed.
     */
    String ERRORMSG_START = ""directive.include.output.errormsg.start"";
    /**
     * Ending tag for error messages triggered by passing a parameter not allowed in the #include directive. Only string literals,
     * and references are allowed.
     */
    String ERRORMSG_END = ""directive.include.output.errormsg.end"";
    /** Maximum recursion depth allowed for the #parse directive. */
    String PARSE_DIRECTIVE_MAXDEPTH = ""directive.parse.max.depth"";
    /** Maximum recursion depth allowed for the #define directive. */
    String DEFINE_DIRECTIVE_MAXDEPTH = ""directive.define.max.depth"";
    /**
     * class to use for local context with #evaluate()
     * @since 1.6
     */
    String EVALUATE_CONTEXT_CLASS = ""directive.evaluate.context.class"";
    /*
     * ----------------------------------------------------------------------
     *  R E S O U R C E   M A N A G E R   C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     */
    /**  */
    String RESOURCE_MANAGER_CLASS = ""resource.manager.class"";
    /**
     * The <code>resource.manager.cache.class</code> property specifies the name of the
     * {@link org.apache.velocity.runtime.resource.ResourceCache} implementation to use.
     */
    String RESOURCE_MANAGER_CACHE_CLASS = ""resource.manager.cache.class"";
    /** The <code>resource.manager.cache.size</code> property specifies the cache upper bound (if relevant). */
    String RESOURCE_MANAGER_DEFAULTCACHE_SIZE = ""resource.manager.defaultcache.size"";
    /*
     * ----------------------------------------------------------------------
     * R E S O U R C E  L O A D E R  C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     */
    /** controls if the finding of a resource is logged. */
    String RESOURCE_MANAGER_LOGWHENFOUND = ""resource.manager.logwhenfound"";
    /**
     * Key used to retrieve the names of the resource loaders to be used. In a properties file they may appear as the following:
     *
     * <p>resource.loader = file,classpath</p>
     */
    String RESOURCE_LOADER = ""resource.loader"";
    /** The public handle for setting a path in the FileResourceLoader. */
    String FILE_RESOURCE_LOADER_PATH = ""file.resource.loader.path"";
    /** The public handle for turning the caching on in the FileResourceLoader. */
    String FILE_RESOURCE_LOADER_CACHE = ""file.resource.loader.cache"";
    /*
     * ----------------------------------------------------------------------
     *  E V E N T  H A N D L E R  C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     */
    /**
     * The <code>eventhandler.referenceinsertion.class</code> property specifies a list of the
     * {@link org.apache.velocity.app.event.ReferenceInsertionEventHandler} implementations to use.
     */
    String EVENTHANDLER_REFERENCEINSERTION = ""eventhandler.referenceinsertion.class"";
    /**
     * The <code>eventhandler.nullset.class</code> property specifies a list of the
     * {@link org.apache.velocity.app.event.NullSetEventHandler} implementations to use.
     */
    String EVENTHANDLER_NULLSET = ""eventhandler.nullset.class"";
    /**
     * The <code>eventhandler.methodexception.class</code> property specifies a list of the
     * {@link org.apache.velocity.app.event.MethodExceptionEventHandler} implementations to use.
     */
    String EVENTHANDLER_METHODEXCEPTION = ""eventhandler.methodexception.class"";
    /**
     * The <code>eventhandler.include.class</code> property specifies a list of the
     * {@link org.apache.velocity.app.event.IncludeEventHandler} implementations to use.
     */
    String EVENTHANDLER_INCLUDE = ""eventhandler.include.class"";
    /**
     * The <code>eventhandler.invalidreferences.class</code> property specifies a list of the
     * {@link org.apache.velocity.app.event.InvalidReferenceEventHandler} implementations to use.
     */
    String EVENTHANDLER_INVALIDREFERENCES = ""eventhandler.invalidreferences.class"";
    /*
     * ----------------------------------------------------------------------
     * V E L O C I M A C R O  C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     */
    /** Name of local Velocimacro library template. */
    String VM_LIBRARY = ""velocimacro.library"";
    /** Default Velocimacro library template. */
    String VM_LIBRARY_DEFAULT = ""VM_global_library.vm"";
    /** switch for autoloading library-sourced VMs (for development). */
    String VM_LIBRARY_AUTORELOAD = ""velocimacro.library.autoreload"";
    /** boolean (true/false) default true : allow inline (in-template) macro definitions. */
    String VM_PERM_ALLOW_INLINE = ""velocimacro.permissions.allow.inline"";
    /** boolean (true/false) default false : allow inline (in-template) macro definitions to replace existing. */
    String VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL = ""velocimacro.permissions.allow.inline.to.replace.global"";
    /** Switch for forcing inline macros to be local : default false. */
    String VM_PERM_INLINE_LOCAL = ""velocimacro.permissions.allow.inline.local.scope"";
    /** Switch for VM blather : default true. */
    String VM_MESSAGES_ON = ""velocimacro.messages.on"";
    /** switch for local context in VM : default false. */
    String VM_CONTEXT_LOCALSCOPE = ""velocimacro.context.localscope"";
    /** if true, throw an exception for wrong number of arguments **/
    String VM_ARGUMENTS_STRICT = ""velocimacro.arguments.strict"";
    /**
     * Specify the maximum depth for macro calls
     * @since 1.6
     */
    String VM_MAX_DEPTH = ""velocimacro.max.depth"";
    /*
     * ----------------------------------------------------------------------
     * G E N E R A L  R U N T I M E  C O N F I G U R A T I O N
     * ----------------------------------------------------------------------
     */
    /** Switch for the interpolation facility for string literals. */
    String INTERPOLATE_STRINGLITERALS = ""runtime.interpolate.string.literals"";
    /** The character encoding for the templates. Used by the parser in processing the input streams. */
    String INPUT_ENCODING = ""input.encoding"";
    /** Encoding for the output stream. Currently used by Anakia and VelocityServlet */
    String OUTPUT_ENCODING = ""output.encoding"";
    /** Default Encoding is ISO-8859-1. */
    String ENCODING_DEFAULT = ""ISO-8859-1"";
    /** key name for uberspector. Multiple classnames can be specified,in which case uberspectors will be chained. */
    String UBERSPECT_CLASSNAME = ""runtime.introspector.uberspect"";
    /** A comma separated list of packages to restrict access to in the SecureIntrospector. */
    String INTROSPECTOR_RESTRICT_PACKAGES = ""introspector.restrict.packages"";
    /** A comma separated list of classes to restrict access to in the SecureIntrospector. */
    String INTROSPECTOR_RESTRICT_CLASSES = ""introspector.restrict.classes"";
    /** Switch for ignoring nulls in math equations vs throwing exceptions. */
    String STRICT_MATH = ""runtime.strict.math"";
    /**
     * The <code>parser.pool.class</code> property specifies the name of the {@link org.apache.velocity.util.SimplePool}
     * implementation to use.
     */
    String PARSER_POOL_CLASS = ""parser.pool.class"";
    /**
     * @see  #NUMBER_OF_PARSERS
     */
    String PARSER_POOL_SIZE = ""parser.pool.size"";
    /*
     * ----------------------------------------------------------------------
     * These constants are used internally by the Velocity runtime i.e.
     * the constants listed below are strictly used in the Runtime
     * class itself.
     * ----------------------------------------------------------------------
     */
    /** Default Runtime properties. */
    String DEFAULT_RUNTIME_PROPERTIES = ""org/apache/velocity/runtime/defaults/velocity.properties"";
    /** Default Runtime properties. */
    String DEFAULT_RUNTIME_DIRECTIVES = ""org/apache/velocity/runtime/defaults/directive.properties"";
    /**
     * The default number of parser instances to create. Configurable via the parameter named by the {@link #PARSER_POOL_SIZE}
     * constant.
     */
    int NUMBER_OF_PARSERS = 20;
}
"
org.apache.velocity.runtime.RuntimeInstance,"package org.apache.velocity.runtime;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.Writer;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import java.util.Properties;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.commons.lang.text.StrBuilder;
import org.apache.velocity.Template;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.app.event.EventHandler;
import org.apache.velocity.app.event.IncludeEventHandler;
import org.apache.velocity.app.event.InvalidReferenceEventHandler;
import org.apache.velocity.app.event.MethodExceptionEventHandler;
import org.apache.velocity.app.event.NullSetEventHandler;
import org.apache.velocity.app.event.ReferenceInsertionEventHandler;
import org.apache.velocity.context.Context;
import org.apache.velocity.context.InternalContextAdapterImpl;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.log.LogManager;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.resource.ContentResource;
import org.apache.velocity.runtime.resource.ResourceManager;
import org.apache.velocity.util.ClassUtils;
import org.apache.velocity.util.RuntimeServicesAware;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.util.introspection.Introspector;
import org.apache.velocity.util.introspection.Uberspect;
import org.apache.velocity.util.introspection.UberspectLoggable;
import org.apache.velocity.util.introspection.ChainableUberspector;
import org.apache.velocity.util.introspection.LinkingUberspector;
/**
 * This is the Runtime system for Velocity. It is the
 * single access point for all functionality in Velocity.
 * It adheres to the mediator pattern and is the only
 * structure that developers need to be familiar with
 * in order to get Velocity to perform.
 *
 * The Runtime will also cooperate with external
 * systems like Turbine. Runtime properties can
 * set and then the Runtime is initialized.
 *
 * Turbine, for example, knows where the templates
 * are to be loaded from, and where the Velocity
 * log file should be placed.
 *
 * So in the case of Velocity cooperating with Turbine
 * the code might look something like the following:
 *
 * <blockquote><code><pre>
 * ri.setProperty(Runtime.FILE_RESOURCE_LOADER_PATH, templatePath);
 * ri.setProperty(Runtime.RUNTIME_LOG, pathToVelocityLog);
 * ri.init();
 * </pre></code></blockquote>
 *
 * <pre>
 * -----------------------------------------------------------------------
 * N O T E S  O N  R U N T I M E  I N I T I A L I Z A T I O N
 * -----------------------------------------------------------------------
 * init()
 *
 * If init() is called by itself the RuntimeInstance will initialize
 * with a set of default values.
 * -----------------------------------------------------------------------
 * init(String/Properties)
 *
 * In this case the default velocity properties are layed down
 * first to provide a solid base, then any properties provided
 * in the given properties object will override the corresponding
 * default property.
 * -----------------------------------------------------------------------
 * </pre>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:jlb@houseofdistraction.com"">Jeff Bowden</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magusson Jr.</a>
 * @version $Id: RuntimeInstance.java 703049 2008-10-09 03:18:58Z nbubna $
 */
public class RuntimeInstance implements RuntimeConstants, RuntimeServices
{
    /**
     *  VelocimacroFactory object to manage VMs
     */
    private  VelocimacroFactory vmFactory = null;
    /**
     * The Runtime logger.  We start with an instance of
     * a 'primordial logger', which just collects log messages
     * then, when the log system is initialized, all the
     * messages get dumpted out of the primordial one into the real one.
     */
    private Log log = new Log();
    /**
     * The Runtime parser pool
     */
    private  ParserPool parserPool;
    /**
     * Indicate whether the Runtime is in the midst of initialization.
     */
    private boolean initializing = false;
    /**
     * Indicate whether the Runtime has been fully initialized.
     */
    private boolean initialized = false;
    /**
     * These are the properties that are laid down over top
     * of the default properties when requested.
     */
    private  ExtendedProperties overridingProperties = null;
    /**
     * This is a hashtable of initialized directives.
     * The directives that populate this hashtable are
     * taken from the RUNTIME_DEFAULT_DIRECTIVES
     * property file. This hashtable is passed
     * to each parser that is created.
     */
    private Hashtable runtimeDirectives;
    /**
     * Object that houses the configuration options for
     * the velocity runtime. The ExtendedProperties object allows
     * the convenient retrieval of a subset of properties.
     * For example all the properties for a resource loader
     * can be retrieved from the main ExtendedProperties object
     * using something like the following:
     *
     * ExtendedProperties loaderConfiguration =
     *         configuration.subset(loaderID);
     *
     * And a configuration is a lot more convenient to deal
     * with then conventional properties objects, or Maps.
     */
    private  ExtendedProperties configuration = new ExtendedProperties();
    private ResourceManager resourceManager = null;
    /**
     * This stores the engine-wide set of event handlers.  Event handlers for
     * each specific merge are stored in the context.
     */
    private EventCartridge eventCartridge = null;
    /*
     *  Each runtime instance has it's own introspector
     *  to ensure that each instance is completely separate.
     */
    private Introspector introspector = null;
    /*
     *  Opaque reference to something specificed by the
     *  application for use in application supplied/specified
     *  pluggable components
     */
    private Map applicationAttributes = null;
    private Uberspect uberSpect;
    private String encoding;
    /**
     * Creates a new RuntimeInstance object.
     */
    public RuntimeInstance()
    {
        /*
         *  create a VM factory, introspector, and application attributes
         */
        vmFactory = new VelocimacroFactory( this );
        /*
         *  make a new introspector and initialize it
         */
        introspector = new Introspector(getLog());
        /*
         * and a store for the application attributes
         */
        applicationAttributes = new HashMap();
    }
    /**
     * This is the primary initialization method in the Velocity
     * Runtime. The systems that are setup/initialized here are
     * as follows:
     *
     * <ul>
     *   <li>Logging System</li>
     *   <li>ResourceManager</li>
     *   <li>EventHandler</li>
     *   <li>Parser Pool</li>
     *   <li>Global Cache</li>
     *   <li>Static Content Include System</li>
     *   <li>Velocimacro System</li>
     * </ul>
     * @throws Exception When an error occured during initialization.
     */
    public synchronized void init()
        throws Exception
    {
        if (!initialized && !initializing)
        {
            initializing = true;
            log.trace(""*******************************************************************"");
            log.debug(""Starting Apache Velocity v@build.version@ (compiled: @build.time@)"");
            log.trace(""RuntimeInstance initializing."");
            initializeProperties();
            initializeLog();
            initializeResourceManager();
            initializeDirectives();
            initializeEventHandlers();
            initializeParserPool();
            initializeIntrospection();
            /*
             *  initialize the VM Factory.  It will use the properties
             * accessable from Runtime, so keep this here at the end.
             */
            vmFactory.initVelocimacro();
            log.trace(""RuntimeInstance successfully initialized."");
            initialized = true;
            initializing = false;
        }
    }
    /**
     * Returns true if the RuntimeInstance has been successfully initialized.
     * @return True if the RuntimeInstance has been successfully initialized.
     * @since 1.5
     */
    public boolean isInitialized()
    {
        return initialized;
    }
    /**
     * Init or die! (with some log help, of course)
     */
    private void requireInitialization()
    {
        if (!initialized && !initializing)
        {
            log.debug(""Velocity was not initialized! Calling init()..."");
            try
            {
                init();
            }
            catch (Exception e)
            {
                getLog().error(""Could not auto-initialize Velocity"", e);
                throw new RuntimeException(""Velocity could not be initialized!"", e);
            }
        }
    }
    /**
     *  Gets the classname for the Uberspect introspection package and
     *  instantiates an instance.
     */
    private void initializeIntrospection()
        throws Exception
    {
        String[] uberspectors = configuration.getStringArray(RuntimeConstants.UBERSPECT_CLASSNAME);
        for (int i=0; i <uberspectors.length;i++)
        {
            String rm = uberspectors[i];
            Object o = null;
            try
            {
               o = ClassUtils.getNewInstance( rm );
            }
            catch (ClassNotFoundException cnfe)
            {
                String err = ""The specified class for Uberspect ("" + rm
                    + "") does not exist or is not accessible to the current classloader."";
                log.error(err);
                throw new Exception(err);
            }
            if (!(o instanceof Uberspect))
            {
                String err = ""The specified class for Uberspect (""
                    + rm + "") does not implement "" + Uberspect.class.getName()
                    + ""; Velocity is not initialized correctly."";
                log.error(err);
                throw new Exception(err);
            }
            Uberspect u = (Uberspect)o;
            if (u instanceof UberspectLoggable)
            {
                ((UberspectLoggable)u).setLog(getLog());
            }
            if (u instanceof RuntimeServicesAware)
            {
                ((RuntimeServicesAware)u).setRuntimeServices(this);
            }
            if (uberSpect == null)
            {
                uberSpect = u;
            }
            else
            {
                if (u instanceof ChainableUberspector)
                {
                    ((ChainableUberspector)u).wrap(uberSpect);
                    uberSpect = u;
                }
                else
                {
                    uberSpect = new LinkingUberspector(uberSpect,u);
                }
            }
        }
        if(uberSpect != null)
        {
            uberSpect.init();
        }
        else
        {
           /*
            *  someone screwed up.  Lets not fool around...
            */
           String err = ""It appears that no class was specified as the""
           + "" Uberspect.  Please ensure that all configuration""
           + "" information is correct."";
           log.error(err);
           throw new Exception(err);
        }
    }
    /**
     * Initializes the Velocity Runtime with properties file.
     * The properties file may be in the file system proper,
     * or the properties file may be in the classpath.
     */
    private void setDefaultProperties()
    {
        InputStream inputStream = null;
        try
        {
            inputStream = getClass()
                .getResourceAsStream('/' + DEFAULT_RUNTIME_PROPERTIES);
            configuration.load( inputStream );
            if (log.isDebugEnabled())
            {
                log.debug(""Default Properties File: "" +
                    new File(DEFAULT_RUNTIME_PROPERTIES).getPath());
            }
        }
        catch (IOException ioe)
        {
            String msg = ""Cannot get Velocity Runtime default properties!"";
            log.error(msg, ioe);
            throw new RuntimeException(msg, ioe);
        }
        finally
        {
            try
            {
                if (inputStream != null)
                {
                    inputStream.close();
                }
            }
            catch (IOException ioe)
            {
                String msg = ""Cannot close Velocity Runtime default properties!"";
                log.error(msg, ioe);
                throw new RuntimeException(msg, ioe);
            }
        }
    }
    /**
     * Allows an external system to set a property in
     * the Velocity Runtime.
     *
     * @param key property key
     * @param  value property value
     */
    public void setProperty(String key, Object value)
    {
        if (overridingProperties == null)
        {
            overridingProperties = new ExtendedProperties();
        }
        overridingProperties.setProperty(key, value);
    }
    /**
     * Allow an external system to set an ExtendedProperties
     * object to use. This is useful where the external
     * system also uses the ExtendedProperties class and
     * the velocity configuration is a subset of
     * parent application's configuration. This is
     * the case with Turbine.
     *
     * @param  configuration
     */
    public void setConfiguration( ExtendedProperties configuration)
    {
        if (overridingProperties == null)
        {
            overridingProperties = configuration;
        }
        else
        {
            // Avoid possible ConcurrentModificationException
            if (overridingProperties != configuration)
            {
                overridingProperties.combine(configuration);
            }
        }
    }
    /**
     * Add a property to the configuration. If it already
     * exists then the value stated here will be added
     * to the configuration entry. For example, if
     *
     * resource.loader = file
     *
     * is already present in the configuration and you
     *
     * addProperty(""resource.loader"", ""classpath"")
     *
     * Then you will end up with a Vector like the
     * following:
     *
     * [""file"", ""classpath""]
     *
     * @param  key
     * @param  value
     */
    public void addProperty(String key, Object value)
    {
        if (overridingProperties == null)
        {
            overridingProperties = new ExtendedProperties();
        }
        overridingProperties.addProperty(key, value);
    }
    /**
     * Clear the values pertaining to a particular
     * property.
     *
     * @param key of property to clear
     */
    public void clearProperty(String key)
    {
        if (overridingProperties != null)
        {
            overridingProperties.clearProperty(key);
        }
    }
    /**
     *  Allows an external caller to get a property.  The calling
     *  routine is required to know the type, as this routine
     *  will return an Object, as that is what properties can be.
     *
     *  @param key property to return
     *  @return Value of the property or null if it does not exist.
     */
    public Object getProperty(String key)
    {
        Object o = null;
        /**
         * Before initialization, check the user-entered properties first.
         */
        if (!initialized && !initializing && overridingProperties != null) 
        {
            o = overridingProperties.get(key);
        }
        /**
         * After initialization, configuration will hold all properties.
         */
        if (o == null) 
        {
            o = configuration.getProperty(key);
        }
        if (o instanceof String)
        {
            return StringUtils.nullTrim((String) o);
        }
        else
        {
            return o;
        }
    }
    /**
     * Initialize Velocity properties, if the default
     * properties have not been laid down first then
     * do so. Then proceed to process any overriding
     * properties. Laying down the default properties
     * gives a much greater chance of having a
     * working system.
     */
    private void initializeProperties()
    {
        /*
         * Always lay down the default properties first as
         * to provide a solid base.
         */
        if (configuration.isInitialized() == false)
        {
            setDefaultProperties();
        }
        if( overridingProperties != null)
        {
            configuration.combine(overridingProperties);
        }
    }
    /**
     * Initialize the Velocity Runtime with a Properties
     * object.
     *
     * @param p
     * @throws Exception When an error occurs during initialization.
     */
    public void init(Properties p) throws Exception
    {
        setProperties(ExtendedProperties.convertProperties(p));
        init();
    }
    private void setProperties(ExtendedProperties p)
    {
        if (overridingProperties == null)
        {
            overridingProperties = p;
        }
        else
        {
            overridingProperties.combine(p);
        }
    }
    /**
     * Initialize the Velocity Runtime with the name of
     * ExtendedProperties object.
     *
     * @param configurationFile
     * @throws Exception When an error occurs during initialization.
     */
    public void init(String configurationFile)
        throws Exception
    {
        setProperties(new ExtendedProperties(configurationFile));
        init();
    }
    private void initializeResourceManager()
        throws Exception
    {
        /*
         * Which resource manager?
         */
        String rm = getString(RuntimeConstants.RESOURCE_MANAGER_CLASS);
        if (rm != null && rm.length() > 0)
        {
            /*
             *  if something was specified, then make one.
             *  if that isn't a ResourceManager, consider
             *  this a huge error and throw
             */
            Object o = null;
            try
            {
               o = ClassUtils.getNewInstance( rm );
            }
            catch (ClassNotFoundException cnfe )
            {
                String err = ""The specified class for ResourceManager ("" + rm
                    + "") does not exist or is not accessible to the current classloader."";
                log.error(err);
                throw new Exception(err);
            }
            if (!(o instanceof ResourceManager))
            {
                String err = ""The specified class for ResourceManager ("" + rm
                    + "") does not implement "" + ResourceManager.class.getName()
                    + ""; Velocity is not initialized correctly."";
                log.error(err);
                throw new Exception(err);
            }
            resourceManager = (ResourceManager) o;
            resourceManager.initialize(this);
         }
         else
         {
            /*
             *  someone screwed up.  Lets not fool around...
             */
            String err = ""It appears that no class was specified as the""
            + "" ResourceManager.  Please ensure that all configuration""
            + "" information is correct."";
            log.error(err);
            throw new Exception( err );
        }
    }
    private void initializeEventHandlers()
        throws Exception
    {
        eventCartridge = new EventCartridge();
        /**
         * For each type of event handler, get the class name, instantiate it, and store it.
         */
        String[] referenceinsertion = configuration.getStringArray(RuntimeConstants.EVENTHANDLER_REFERENCEINSERTION);
        if ( referenceinsertion != null )
        {
            for ( int i=0; i < referenceinsertion.length; i++ )
            {
                EventHandler ev = initializeSpecificEventHandler(referenceinsertion[i],RuntimeConstants.EVENTHANDLER_REFERENCEINSERTION,ReferenceInsertionEventHandler.class);
                if (ev != null)
                    eventCartridge.addReferenceInsertionEventHandler((ReferenceInsertionEventHandler) ev);
            }
        }
        String[] nullset = configuration.getStringArray(RuntimeConstants.EVENTHANDLER_NULLSET);
        if ( nullset != null )
        {
            for ( int i=0; i < nullset.length; i++ )
            {
                EventHandler ev = initializeSpecificEventHandler(nullset[i],RuntimeConstants.EVENTHANDLER_NULLSET,NullSetEventHandler.class);
                if (ev != null)
                    eventCartridge.addNullSetEventHandler((NullSetEventHandler) ev);
            }
        }
        String[] methodexception = configuration.getStringArray(RuntimeConstants.EVENTHANDLER_METHODEXCEPTION);
        if ( methodexception != null )
        {
            for ( int i=0; i < methodexception.length; i++ )
            {
                EventHandler ev = initializeSpecificEventHandler(methodexception[i],RuntimeConstants.EVENTHANDLER_METHODEXCEPTION,MethodExceptionEventHandler.class);
                if (ev != null)
                    eventCartridge.addMethodExceptionHandler((MethodExceptionEventHandler) ev);
            }
        }
        String[] includeHandler = configuration.getStringArray(RuntimeConstants.EVENTHANDLER_INCLUDE);
        if ( includeHandler != null )
        {
            for ( int i=0; i < includeHandler.length; i++ )
            {
                EventHandler ev = initializeSpecificEventHandler(includeHandler[i],RuntimeConstants.EVENTHANDLER_INCLUDE,IncludeEventHandler.class);
                if (ev != null)
                    eventCartridge.addIncludeEventHandler((IncludeEventHandler) ev);
            }
        }
        String[] invalidReferenceSet = configuration.getStringArray(RuntimeConstants.EVENTHANDLER_INVALIDREFERENCES);
        if ( invalidReferenceSet != null )
        {
            for ( int i=0; i < invalidReferenceSet.length; i++ )
            {
                EventHandler ev = initializeSpecificEventHandler(invalidReferenceSet[i],RuntimeConstants.EVENTHANDLER_INVALIDREFERENCES,InvalidReferenceEventHandler.class);
                if (ev != null)
                {
                    eventCartridge.addInvalidReferenceEventHandler((InvalidReferenceEventHandler) ev);
                }
            }
        }
    }
    private EventHandler initializeSpecificEventHandler(String classname, String paramName, Class EventHandlerInterface)
        throws Exception
    {
        if ( classname != null && classname.length() > 0)
        {
            Object o = null;
            try {
                o = ClassUtils.getNewInstance(classname);
            }
            catch (ClassNotFoundException cnfe )
            {
                String err = ""The specified class for ""
                    + paramName + "" ("" + classname
                    + "") does not exist or is not accessible to the current classloader."";
                log.error(err);
                throw new Exception(err);
            }
            if (!EventHandlerInterface.isAssignableFrom(EventHandlerInterface))
            {
                String err = ""The specified class for "" + paramName + "" (""
                    + classname + "") does not implement ""
                    + EventHandlerInterface.getName()
                    + ""; Velocity is not initialized correctly."";
                log.error(err);
                throw new Exception(err);
            }
            EventHandler ev = (EventHandler) o;
            if ( ev instanceof RuntimeServicesAware )
                ((RuntimeServicesAware) ev).setRuntimeServices(this);
            return ev;
        } else
            return null;
    }
    /**
     * Initialize the Velocity logging system.
     *
     * @throws Exception
     */
    private void initializeLog() throws Exception
    {
        // since the Log we started with was just placeholding,
        // let's update it with the real LogChute settings.
        LogManager.updateLog(this.log, this);
    }
    /**
     * This methods initializes all the directives
     * that are used by the Velocity Runtime. The
     * directives to be initialized are listed in
     * the RUNTIME_DEFAULT_DIRECTIVES properties
     * file.
     *
     * @throws Exception
     */
    private void initializeDirectives()
        throws Exception
    {
        /*
         * Initialize the runtime directive table.
         * This will be used for creating parsers.
         */
        runtimeDirectives = new Hashtable();
        Properties directiveProperties = new Properties();
        /*
         * Grab the properties file with the list of directives
         * that we should initialize.
         */
        InputStream inputStream = null;
        try
        {
            inputStream = getClass().getResourceAsStream('/' + DEFAULT_RUNTIME_DIRECTIVES);
            if (inputStream == null)
            {
                throw new Exception(""Error loading directive.properties! "" +
                                    ""Something is very wrong if these properties "" +
                                    ""aren't being located. Either your Velocity "" +
                                    ""distribution is incomplete or your Velocity "" +
                                    ""jar file is corrupted!"");
            }
            directiveProperties.load(inputStream);
        }
        catch (IOException ioe)
        {
            String msg = ""Error while loading directive properties!"";
            log.error(msg, ioe);
            throw new RuntimeException(msg, ioe);
        }
        finally
        {
            try
            {
                if (inputStream != null)
                {
                    inputStream.close();
                }
            }
            catch (IOException ioe)
            {
                String msg = ""Cannot close directive properties!"";
                log.error(msg, ioe);
                throw new RuntimeException(msg, ioe);
            }
        }
        /*
         * Grab all the values of the properties. These
         * are all class names for example:
         *
         * org.apache.velocity.runtime.directive.Foreach
         */
        Enumeration directiveClasses = directiveProperties.elements();
        while (directiveClasses.hasMoreElements())
        {
            String directiveClass = (String) directiveClasses.nextElement();
            loadDirective(directiveClass);
            log.debug(""Loaded System Directive: "" + directiveClass);
        }
        /*
         *  now the user's directives
         */
        String[] userdirective = configuration.getStringArray(""userdirective"");
        for( int i = 0; i < userdirective.length; i++)
        {
            loadDirective(userdirective[i]);
            if (log.isDebugEnabled())
            {
                log.debug(""Loaded User Directive: "" + userdirective[i]);
            }
        }
    }
    /**
     * Programatically add a directive.
     * @param directive
     */
    public void addDirective(Directive directive) 
    {
        runtimeDirectives.put(directive.getName(), directive);
    }
    /**
     * Retrieve a previously instantiated directive.
     * @param name name of the directive
     * @return the {@link Directive} for that name
     */
    public Directive getDirective(String name) 
    {
        return (Directive) runtimeDirectives.get(name);
    }
    /**
     * Remove a directive.
     * @param name name of the directive.
     */
    public void removeDirective(String name) 
    {
        runtimeDirectives.remove(name);
    }
    /**
     *  instantiates and loads the directive with some basic checks
     *
     *  @param directiveClass classname of directive to load
     */
    private void loadDirective(String directiveClass)
    {
        try
        {
            Object o = ClassUtils.getNewInstance( directiveClass );
            if (o instanceof Directive)
            {
                Directive directive = (Directive) o;
                addDirective(directive);
            }
            else
            {
                String msg = directiveClass + "" does not implement ""
                    + Directive.class.getName() + ""; it cannot be loaded."";
                log.error(msg);
                throw new VelocityException(msg);
            }
        }
        // The ugly threesome:  ClassNotFoundException,
        // IllegalAccessException, InstantiationException.
        // Ignore Findbugs complaint for now.
        catch (Exception e)
        {
            String msg = ""Failed to load Directive: "" + directiveClass;
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
    }
    /**
     * Initializes the Velocity parser pool.
     */
    private void initializeParserPool() throws Exception
    {
        /*
         * Which parser pool?
         */
        String pp = getString(RuntimeConstants.PARSER_POOL_CLASS);
        if (pp != null && pp.length() > 0)
        {
            /*
             *  if something was specified, then make one.
             *  if that isn't a ParserPool, consider
             *  this a huge error and throw
             */
            Object o = null;
            try
            {
                o = ClassUtils.getNewInstance( pp );
            }
            catch (ClassNotFoundException cnfe )
            {
                String err = ""The specified class for ParserPool (""
                    + pp
                    + "") does not exist (or is not accessible to the current classloader."";
                log.error(err);
                throw new Exception(err);
            }
            if (!(o instanceof ParserPool))
            {
                String err = ""The specified class for ParserPool (""
                    + pp + "") does not implement "" + ParserPool.class
                    + "" Velocity not initialized correctly."";
                log.error(err);
                throw new Exception(err);
            }
            parserPool = (ParserPool) o;
            parserPool.initialize(this);
        }
        else
        {
            /*
             *  someone screwed up.  Lets not fool around...
             */
            String err = ""It appears that no class was specified as the""
                + "" ParserPool.  Please ensure that all configuration""
                + "" information is correct."";
            log.error(err);
            throw new Exception( err );
        }
    }
    /**
     * Returns a JavaCC generated Parser.
     *
     * @return Parser javacc generated parser
     */
    public Parser createNewParser()
    {
        requireInitialization();
        Parser parser = new Parser(this);
        parser.setDirectives(runtimeDirectives);
        return parser;
    }
    /**
     * Parse the input and return the root of
     * AST node structure.
     * <br><br>
     *  In the event that it runs out of parsers in the
     *  pool, it will create and let them be GC'd
     *  dynamically, logging that it has to do that.  This
     *  is considered an exceptional condition.  It is
     *  expected that the user will set the
     *  PARSER_POOL_SIZE property appropriately for their
     *  application.  We will revisit this.
     *
     * @param string String to be parsed
     * @param templateName name of the template being parsed
     * @return A root node representing the template as an AST tree.
     * @throws ParseException When the string could not be parsed as a template.
     * @since 1.6
     */
    public SimpleNode parse(String string, String templateName)
        throws ParseException
    {
        return parse(new StringReader(string), templateName);
    }
    /**
     * Parse the input and return the root of
     * AST node structure.
     * <br><br>
     *  In the event that it runs out of parsers in the
     *  pool, it will create and let them be GC'd
     *  dynamically, logging that it has to do that.  This
     *  is considered an exceptional condition.  It is
     *  expected that the user will set the
     *  PARSER_POOL_SIZE property appropriately for their
     *  application.  We will revisit this.
     *
     * @param reader Reader retrieved by a resource loader
     * @param templateName name of the template being parsed
     * @return A root node representing the template as an AST tree.
     * @throws ParseException When the template could not be parsed.
     */
    public SimpleNode parse(Reader reader, String templateName)
        throws ParseException
    {
        /*
         *  do it and dump the VM namespace for this template
         */
        return parse(reader, templateName, true);
    }
    /**
     *  Parse the input and return the root of the AST node structure.
     *
     * @param reader Reader retrieved by a resource loader
     * @param templateName name of the template being parsed
     * @param dumpNamespace flag to dump the Velocimacro namespace for this template
     * @return A root node representing the template as an AST tree.
     * @throws ParseException When the template could not be parsed.
     */
    public SimpleNode parse(Reader reader, String templateName, boolean dumpNamespace)
        throws ParseException
    {
        requireInitialization();
        Parser parser = (Parser) parserPool.get();
        boolean keepParser = true;
        if (parser == null)
        {
            /*
             *  if we couldn't get a parser from the pool make one and log it.
             */
            if (log.isInfoEnabled())
            {
                log.info(""Runtime : ran out of parsers. Creating a new one. ""
                      + "" Please increment the parser.pool.size property.""
                      + "" The current value is too small."");
            }
            parser = createNewParser();
            keepParser = false;
        }
        try
        {
            /*
             *  dump namespace if we are told to.  Generally, you want to
             *  do this - you don't in special circumstances, such as
             *  when a VM is getting init()-ed & parsed
             */
            if (dumpNamespace)
            {
                dumpVMNamespace(templateName);
            }
            return parser.parse(reader, templateName);
        }
        finally
        {
            if (keepParser)
            {
                parserPool.put(parser);
            }
        }
    }
    /**
     * Renders the input string using the context into the output writer.
     * To be used when a template is dynamically constructed, or want to use
     * Velocity as a token replacer.
     *
     * @param context context to use in rendering input string
     * @param out  Writer in which to render the output
     * @param logTag  string to be used as the template name for log
     *                messages in case of error
     * @param instring input string containing the VTL to be rendered
     *
     * @return true if successful, false otherwise.  If false, see
     *              Velocity runtime log
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws IOException While rendering to the writer, an I/O problem occured.
     * @since Velocity 1.6
     */
    public boolean evaluate(Context context,  Writer out,
                            String logTag, String instring) throws IOException
    {
        return evaluate(context, out, logTag, new StringReader(instring));
    }
    /**
     * Renders the input reader using the context into the output writer.
     * To be used when a template is dynamically constructed, or want to
     * use Velocity as a token replacer.
     *
     * @param context context to use in rendering input string
     * @param writer  Writer in which to render the output
     * @param logTag  string to be used as the template name for log messages
     *                in case of error
     * @param reader Reader containing the VTL to be rendered
     *
     * @return true if successful, false otherwise.  If false, see
     *              Velocity runtime log
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws IOException While reading from the reader or rendering to the writer,
     *                     an I/O problem occured.
     * @since Velocity 1.6
     */
    public boolean evaluate(Context context, Writer writer,
                            String logTag, Reader reader) throws IOException
    {
        if (logTag == null)
        {
            throw new NullPointerException(""logTag (i.e. template name) cannot be null, you must provide an identifier for the content being evaluated"");
        }
        SimpleNode nodeTree = null;
        try
        {
            nodeTree = parse(reader, logTag);
        }
        catch (ParseException pex)
        {
            throw new ParseErrorException(pex);
        }
        catch (TemplateInitException pex)
        {
            throw new ParseErrorException(pex);
        }
        if (nodeTree == null)
        {
            return false;
        }
        else
        {
            return render(context, writer, logTag, nodeTree);
        }
    }
    /**
     * Initializes and renders the AST {@link SimpleNode} using the context
     * into the output writer.
     *
     * @param context context to use in rendering input string
     * @param writer  Writer in which to render the output
     * @param logTag  string to be used as the template name for log messages
     *                in case of error
     * @param nodeTree SimpleNode which is the root of the AST to be rendered
     *
     * @return true if successful, false otherwise.  If false, see
     *              Velocity runtime log for errors
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws IOException While rendering to the writer, an I/O problem occured.
     * @since Velocity 1.6
     */
    public boolean render(Context context, Writer writer,
                          String logTag, SimpleNode nodeTree) throws IOException
    {
        /*
         * we want to init then render
         */
        InternalContextAdapterImpl ica =
            new InternalContextAdapterImpl(context);
        ica.pushCurrentTemplateName(logTag);
        try
        {
            try
            {
                nodeTree.init(ica, this);
            }
            catch (TemplateInitException pex)
            {
                throw new ParseErrorException(pex);
            }
            /**
             * pass through application level runtime exceptions
             */
            catch(RuntimeException e)
            {
                throw e;
            }
            catch(Exception e)
            {
                String msg = ""RuntimeInstance.render(): init exception for tag = ""+logTag;
                getLog().error(msg, e);
                throw new VelocityException(msg, e);
            }
            /*
             *  now render, and let any exceptions fly
             */
            nodeTree.render(ica, writer);
        }
        finally
        {
            ica.popCurrentTemplateName();
        }
        return true;
    }
    /**
     * Invokes a currently registered Velocimacro with the params provided
     * and places the rendered stream into the writer.
     * <br>
     * Note : currently only accepts args to the VM if they are in the context.
     *
     * @param vmName name of Velocimacro to call
     * @param logTag string to be used for template name in case of error. if null,
     *               the vmName will be used
     * @param params keys for args used to invoke Velocimacro, in java format
     *               rather than VTL (eg  ""foo"" or ""bar"" rather than ""$foo"" or ""$bar"")
     * @param context Context object containing data/objects used for rendering.
     * @param writer  Writer for output stream
     * @return true if Velocimacro exists and successfully invoked, false otherwise.
     * @throws IOException While rendering to the writer, an I/O problem occured.
     * @since 1.6
     */
    public boolean invokeVelocimacro(final String vmName, String logTag,
                                     String[] params, final Context context,
                                     final Writer writer)
        throws IOException
    {
        /* check necessary parameters */
        if (vmName == null || context == null || writer == null)
        {
            String msg = ""RuntimeInstance.invokeVelocimacro() : invalid call : vmName, context, and writer must not be null"";
            getLog().error(msg);
            throw new NullPointerException(msg);
        }
        /* handle easily corrected parameters */
        if (logTag == null)
        {
            logTag = vmName;
        }
        if (params == null)
        {
            params = new String[0];
        }
        /* does the VM exist? */
        if (!isVelocimacro(vmName, logTag))
        {
            String msg = ""RuntimeInstance.invokeVelocimacro() : VM '"" + vmName
                         + ""' is not registered."";
            getLog().error(msg);
            throw new VelocityException(msg);
        }
        /* now just create the VM call, and use evaluate */
        StrBuilder template = new StrBuilder(""#"");
        template.append(vmName);
        template.append(""("");
        for( int i = 0; i < params.length; i++)
        {
            template.append("" $"");
            template.append(params[i]);
        }
        template.append("" )"");
        return evaluate(context, writer, logTag, template.toString());
    }
    /**
     * Retrieves and caches the configured default encoding
     * for better performance. (VELOCITY-606)
     */
    private String getDefaultEncoding()
    {
        if (encoding == null)
        {
            encoding = getString(INPUT_ENCODING, ENCODING_DEFAULT);
        }
        return encoding;
    }
    /**
     * Returns a <code>Template</code> from the resource manager.
     * This method assumes that the character encoding of the
     * template is set by the <code>input.encoding</code>
     * property.  The default is ""ISO-8859-1""
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return getTemplate(name, getDefaultEncoding());
    }
    /**
     * Returns a <code>Template</code> from the resource manager
     *
     * @param name The  name of the desired template.
     * @param encoding Character encoding of the template
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate(String name, String  encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        requireInitialization();
        return (Template)
                resourceManager.getResource(name,
                    ResourceManager.RESOURCE_TEMPLATE, encoding);
    }
    /**
     * Returns a static content resource from the
     * resource manager.  Uses the current value
     * if INPUT_ENCODING as the character encoding.
     *
     * @param name Name of content resource to get
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException When the template could not be parsed.
     * @throws Exception Any other error.
     */
    public ContentResource getContent(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        /*
         *  the encoding is irrelvant as we don't do any converstion
         *  the bytestream should be dumped to the output stream
         */
        return getContent(name, getDefaultEncoding());
    }
    /**
     * Returns a static content resource from the
     * resource manager.
     *
     * @param name Name of content resource to get
     * @param encoding Character encoding to use
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException When the template could not be parsed.
     * @throws Exception Any other error.
     */
    public ContentResource getContent(String name, String encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        requireInitialization();
        return (ContentResource)
                resourceManager.getResource(name,
                        ResourceManager.RESOURCE_CONTENT, encoding);
    }
    /**
     *  Determines if a template exists and returns name of the loader that
     *  provides it.  This is a slightly less hokey way to support
     *  the Velocity.resourceExists() utility method, which was broken
     *  when per-template encoding was introduced.  We can revisit this.
     *
     *  @param resourceName Name of template or content resource
     *  @return class name of loader than can provide it
     */
    public String getLoaderNameForResource(String resourceName)
    {
        requireInitialization();
        return resourceManager.getLoaderNameForResource(resourceName);
    }
    /**
     * Returns a convenient Log instance that wraps the current LogChute.
     * Use this to log error messages. It has the usual methods.
     *
     * @return A convenience Log instance that wraps the current LogChute.
     * @since 1.5
     */
    public Log getLog()
    {
        return log;
    }
    /**
     * @deprecated Use getLog() and call warn() on it.
     * @see Log#warn(Object)
     * @param message The message to log.
     */
    public void warn(Object message)
    {
        getLog().warn(message);
    }
    /**
     * @deprecated Use getLog() and call info() on it.
     * @see Log#info(Object)
     * @param message The message to log.
     */
    public void info(Object message)
    {
        getLog().info(message);
    }
    /**
     * @deprecated Use getLog() and call error() on it.
     * @see Log#error(Object)
     * @param message The message to log.
     */
    public void error(Object message)
    {
        getLog().error(message);
    }
    /**
     * @deprecated Use getLog() and call debug() on it.
     * @see Log#debug(Object)
     * @param message The message to log.
     */
    public void debug(Object message)
    {
        getLog().debug(message);
    }
    /**
     * String property accessor method with default to hide the
     * configuration implementation.
     *
     * @param key property key
     * @param defaultValue  default value to return if key not
     *               found in resource manager.
     * @return value of key or default
     */
    public String getString( String key, String defaultValue)
    {
        return configuration.getString(key, defaultValue);
    }
    /**
     * Returns the appropriate VelocimacroProxy object if vmName
     * is a valid current Velocimacro.
     *
     * @param vmName Name of velocimacro requested
     * @param templateName Name of the template that contains the velocimacro.
     * @return The requested VelocimacroProxy.
     * @since 1.6
     */
    public Directive getVelocimacro(String vmName, String templateName)
    {
        return vmFactory.getVelocimacro( vmName, templateName );
    }
    /**
     * Returns the appropriate VelocimacroProxy object if vmName
     * is a valid current Velocimacro.
     *
     * @param vmName  Name of velocimacro requested
     * @param templateName Name of the namespace.
     * @param renderingTemplate Name of the template we are currently rendering. This
     *    information is needed when VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL setting is true
     *    and template contains a macro with the same name as the global macro library.
     * 
     * @since Velocity 1.6
     * 
     * @return VelocimacroProxy
     */
    public Directive getVelocimacro(String vmName, String templateName, String renderingTemplate)
    {
        return vmFactory.getVelocimacro( vmName, templateName, renderingTemplate );
    }
   /**
    * Adds a new Velocimacro. Usually called by Macro only while parsing.
    *
    * @param name Name of velocimacro
    * @param macro String form of macro body
    * @param argArray Array of strings, containing the
    *                         #macro() arguments.  the 0th is the name.
    * @param sourceTemplate Name of the template that contains the velocimacro.
    * 
    * @deprecated Use addVelocimacro(String, Node, String[], String) instead
    * 
    * @return True if added, false if rejected for some
    *                  reason (either parameters or permission settings)
    */
    public boolean addVelocimacro( String name,
                                          String macro,
                                          String argArray[],
                                          String sourceTemplate )
    {
        return vmFactory.addVelocimacro(name, macro,  argArray,  sourceTemplate);
    }
    /**
     * Adds a new Velocimacro. Usually called by Macro only while parsing.
     * 
     * Called by org.apache.velocity.runtime.directive.processAndRegister
     *
     * @param name  Name of velocimacro
     * @param macro  root AST node of the parsed macro
     * @param argArray  Array of strings, containing the
     *                         #macro() arguments.  the 0th is the name.
     * @param sourceTemplate
     * 
     * @since Velocity 1.6
     *                   
     * @return boolean  True if added, false if rejected for some
     *                  reason (either parameters or permission settings)
     */
    public boolean addVelocimacro( String name,
                                          Node macro,
                                          String argArray[],
                                          String sourceTemplate )
    {
        return vmFactory.addVelocimacro(name, macro,  argArray,  sourceTemplate);
    }
    /**
     *  Checks to see if a VM exists
     *
     * @param vmName Name of the Velocimacro.
     * @param templateName Template on which to look for the Macro.
     * @return True if VM by that name exists, false if not
     */
    public boolean isVelocimacro( String vmName, String templateName )
    {
        return vmFactory.isVelocimacro(vmName, templateName);
    }
    /**
     * tells the vmFactory to dump the specified namespace.  This is to support
     * clearing the VM list when in inline-VM-local-scope mode
     * @param namespace Namespace to dump.
     * @return True if namespace was dumped successfully.
     */
    public boolean dumpVMNamespace(String namespace)
    {
        return vmFactory.dumpVMNamespace( namespace );
    }
    /* --------------------------------------------------------------------
     * R U N T I M E  A C C E S S O R  M E T H O D S
     * --------------------------------------------------------------------
     * These are the getXXX() methods that are a simple wrapper
     * around the configuration object. This is an attempt
     * to make a the Velocity Runtime the single access point
     * for all things Velocity, and allow the Runtime to
     * adhere as closely as possible the the Mediator pattern
     * which is the ultimate goal.
     * --------------------------------------------------------------------
     */
    /**
     * String property accessor method to hide the configuration implementation
     * @param key  property key
     * @return   value of key or null
     */
    public String getString(String key)
    {
        return StringUtils.nullTrim(configuration.getString(key));
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key Property key
     * @return value
     */
    public int getInt(String key)
    {
        return configuration.getInt(key);
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key  property key
     * @param defaultValue The default value.
     * @return value
     */
    public int getInt(String key, int defaultValue)
    {
        return configuration.getInt(key, defaultValue);
    }
    /**
     * Boolean property accessor method to hide the configuration implementation.
     *
     * @param key property key
     * @param def The default value if property not found.
     * @return value of key or default value
     */
    public boolean getBoolean(String key, boolean def)
    {
        return configuration.getBoolean(key, def);
    }
    /**
     * Return the velocity runtime configuration object.
     *
     * @return Configuration object which houses the Velocity runtime
     * properties.
     */
    public ExtendedProperties getConfiguration()
    {
        return configuration;
    }
    /**
     *  Return the Introspector for this instance
     * @return The Introspector for this instance
     */
    public Introspector getIntrospector()
    {
        return introspector;
    }
    /**
     * Returns the event handlers for the application.
     * @return The event handlers for the application.
     * @since 1.5
     */
    public EventCartridge getApplicationEventCartridge()
    {
        return eventCartridge;
    }
    /**
     *  Gets the application attribute for the given key
     *
     * @param key
     * @return The application attribute for the given key.
     */
    public Object getApplicationAttribute(Object key)
    {
        return applicationAttributes.get(key);
    }
    /**
     *   Sets the application attribute for the given key
     *
     * @param key
     * @param o The new application attribute.
     * @return The old value of this attribute or null if it hasn't been set before.
     */
    public Object setApplicationAttribute(Object key, Object o)
    {
        return applicationAttributes.put(key, o);
    }
    /**
     * Returns the Uberspect object for this Instance.
     *
     * @return The Uberspect object for this Instance.
     */
    public Uberspect getUberspect()
    {
        return uberSpect;
    }
}
"
org.apache.velocity.runtime.RuntimeLogger,"package org.apache.velocity.runtime;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * Interface for internal runtime logging services. This will hopefully
 * be dissolved into the Log class at some point soon.
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magusson Jr.</a>
 * @version $Id: RuntimeLogger.java 463298 2006-10-12 16:10:32Z henning $
 * @deprecated This functionality has been taken over by the Log class
 */
public interface RuntimeLogger
{
    /**
     * @deprecated Use Log.warn(Object).
     * @see org.apache.velocity.runtime.log.Log#warn(Object)
     * @param message The message to log.
     */
    public void warn(Object message);
    /**
     * @deprecated Use Log.info(Object)
     * @see org.apache.velocity.runtime.log.Log#info(Object)
     * @param message The message to log.
     */
    public  void info(Object message);
    /**
     * @deprecated Use Log.error(Object)
     * @see org.apache.velocity.runtime.log.Log#error(Object)
     * @param message The message to log.
     */
    public void error(Object message);
    /**
     * @deprecated Use Log.debug(Object)
     * @see org.apache.velocity.runtime.log.Log#debug(Object)
     * @param message The message to log.
     */
    public void debug(Object message);
}
"
org.apache.velocity.runtime.RuntimeServices,"package org.apache.velocity.runtime;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.util.Properties;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.velocity.Template;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.context.Context;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.resource.ContentResource;
import org.apache.velocity.util.introspection.Introspector;
import org.apache.velocity.util.introspection.Uberspect;
/**
 * Interface for internal runtime services that are needed by the
 * various components w/in Velocity.  This was taken from the old
 * Runtime singleton, and anything not necessary was removed.
 *
 *  Currently implemented by RuntimeInstance.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magusson Jr.</a>
 * @version $Id: RuntimeServices.java 685724 2008-08-13 23:12:12Z nbubna $
 */
public interface RuntimeServices extends RuntimeLogger
{
   /**
     * This is the primary initialization method in the Velocity
     * Runtime. The systems that are setup/initialized here are
     * as follows:
     *
     * <ul>
     *   <li>Logging System</li>
     *   <li>ResourceManager</li>
     *   <li>Parser Pool</li>
     *   <li>Global Cache</li>
     *   <li>Static Content Include System</li>
     *   <li>Velocimacro System</li>
     * </ul>
     * @throws Exception
     */
    public void init() throws Exception;
    /**
     * Allows an external system to set a property in
     * the Velocity Runtime.
     *
     * @param key property key
     * @param value property value
     */
    public  void setProperty(String key, Object value);
    /**
     * Allow an external system to set an ExtendedProperties
     * object to use. This is useful where the external
     * system also uses the ExtendedProperties class and
     * the velocity configuration is a subset of
     * parent application's configuration. This is
     * the case with Turbine.
     *
     * @param configuration
     */
    public void setConfiguration( ExtendedProperties configuration);
    /**
     * Add a property to the configuration. If it already
     * exists then the value stated here will be added
     * to the configuration entry. For example, if
     *
     * resource.loader = file
     *
     * is already present in the configuration and you
     *
     * addProperty(""resource.loader"", ""classpath"")
     *
     * Then you will end up with a Vector like the
     * following:
     *
     * [""file"", ""classpath""]
     *
     * @param key
     * @param value
     */
    public void addProperty(String key, Object value);
    /**
     * Clear the values pertaining to a particular
     * property.
     *
     * @param key of property to clear
     */
    public void clearProperty(String key);
    /**
     *  Allows an external caller to get a property.  The calling
     *  routine is required to know the type, as this routine
     *  will return an Object, as that is what properties can be.
     *
     *  @param key property to return
     * @return The value.
     */
    public  Object getProperty( String key );
    /**
     * Initialize the Velocity Runtime with a Properties
     * object.
     *
     * @param p
     * @throws Exception
     */
    public void init(Properties p) throws Exception;
    /**
     * Initialize the Velocity Runtime with the name of
     * ExtendedProperties object.
     *
     * @param configurationFile
     * @throws Exception
     */
    public void init(String configurationFile) throws Exception;
    /**
     * Wraps the String in a StringReader and passes it off to
     * {@link #parse(Reader,String)}.
     * @since 1.6
     */
    public SimpleNode parse(String string, String templateName)
        throws ParseException;
    /**
     * Parse the input and return the root of
     * AST node structure.
     * <br><br>
     *  In the event that it runs out of parsers in the
     *  pool, it will create and let them be GC'd
     *  dynamically, logging that it has to do that.  This
     *  is considered an exceptional condition.  It is
     *  expected that the user will set the
     *  PARSER_POOL_SIZE property appropriately for their
     *  application.  We will revisit this.
     *
     * @param reader inputstream retrieved by a resource loader
     * @param templateName name of the template being parsed
     * @return The AST representing the template.
     * @throws ParseException
     */
    public  SimpleNode parse( Reader reader, String templateName )
        throws ParseException;
    /**
     *  Parse the input and return the root of the AST node structure.
     *
     * @param reader inputstream retrieved by a resource loader
     * @param templateName name of the template being parsed
     * @param dumpNamespace flag to dump the Velocimacro namespace for this template
     * @return The AST representing the template.
     * @throws ParseException
     */
    public SimpleNode parse( Reader reader, String templateName, boolean dumpNamespace )
        throws ParseException;
    /**
     * Renders the input string using the context into the output writer.
     * To be used when a template is dynamically constructed, or want to use
     * Velocity as a token replacer.
     *
     * @param context context to use in rendering input string
     * @param out  Writer in which to render the output
     * @param logTag  string to be used as the template name for log
     *                messages in case of error
     * @param instring input string containing the VTL to be rendered
     *
     * @return true if successful, false otherwise.  If false, see
     *              Velocity runtime log
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws IOException While rendering to the writer, an I/O problem occured.
     * @since Velocity 1.6
     */
    public boolean evaluate(Context context, Writer out,
                            String logTag, String instring) throws IOException;
    /**
     * Renders the input reader using the context into the output writer.
     * To be used when a template is dynamically constructed, or want to
     * use Velocity as a token replacer.
     *
     * @param context context to use in rendering input string
     * @param writer  Writer in which to render the output
     * @param logTag  string to be used as the template name for log messages
     *                in case of error
     * @param reader Reader containing the VTL to be rendered
     *
     * @return true if successful, false otherwise.  If false, see
     *              Velocity runtime log
     * @throws ParseErrorException The template could not be parsed.
     * @throws MethodInvocationException A method on a context object could not be invoked.
     * @throws ResourceNotFoundException A referenced resource could not be loaded.
     * @throws IOException While reading from the reader or rendering to the writer,
     *                     an I/O problem occured.
     * @since Velocity 1.6
     */
    public boolean evaluate(Context context, Writer writer,
                            String logTag, Reader reader) throws IOException;
    /**
     * Invokes a currently registered Velocimacro with the params provided
     * and places the rendered stream into the writer.
     * <br>
     * Note : currently only accepts args to the VM if they are in the context.
     *
     * @param vmName name of Velocimacro to call
     * @param logTag string to be used for template name in case of error. if null,
     *               the vmName will be used
     * @param params keys for args used to invoke Velocimacro, in java format
     *               rather than VTL (eg  ""foo"" or ""bar"" rather than ""$foo"" or ""$bar"")
     * @param context Context object containing data/objects used for rendering.
     * @param writer  Writer for output stream
     * @return true if Velocimacro exists and successfully invoked, false otherwise.
     * @throws IOException While rendering to the writer, an I/O problem occured.
     * @since 1.6
     */
    public boolean invokeVelocimacro(final String vmName, String logTag,
                                     String[] params, final Context context,
                                     final Writer writer) throws IOException;
    /**
     * Returns a <code>Template</code> from the resource manager.
     * This method assumes that the character encoding of the
     * template is set by the <code>input.encoding</code>
     * property.  The default is ""ISO-8859-1""
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception;
    /**
     * Returns a <code>Template</code> from the resource manager
     *
     * @param name The  name of the desired template.
     * @param encoding Character encoding of the template
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate(String name, String  encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception;
    /**
     * Returns a static content resource from the
     * resource manager.  Uses the current value
     * if INPUT_ENCODING as the character encoding.
     *
     * @param name Name of content resource to get
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException
     * @throws Exception
     */
    public ContentResource getContent(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception;
    /**
     * Returns a static content resource from the
     * resource manager.
     *
     * @param name Name of content resource to get
     * @param encoding Character encoding to use
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException
     * @throws Exception
     */
    public ContentResource getContent( String name, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception;
    /**
     *  Determines is a template exists, and returns name of the loader that
     *  provides it.  This is a slightly less hokey way to support
     *  the Velocity.templateExists() utility method, which was broken
     *  when per-template encoding was introduced.  We can revisit this.
     *
     *  @param resourceName Name of template or content resource
     *  @return class name of loader than can provide it
     */
    public String getLoaderNameForResource( String resourceName );
    /**
     * String property accessor method with default to hide the
     * configuration implementation.
     *
     * @param key property key
     * @param defaultValue  default value to return if key not
     *               found in resource manager.
     * @return String  value of key or default
     */
    public String getString( String key, String defaultValue);
    /**
     * Returns the appropriate VelocimacroProxy object if strVMname
     * is a valid current Velocimacro.
     *
     * @param vmName  Name of velocimacro requested
     * @param templateName Name of the namespace.
     * @return VelocimacroProxy
     */
    public Directive getVelocimacro( String vmName, String templateName  );
    /**
     * Returns the appropriate VelocimacroProxy object if strVMname
     * is a valid current Velocimacro.
     *
     * @param vmName  Name of velocimacro requested
     * @param templateName Name of the namespace.
     * @param renderingTemplate Name of the template we are currently rendering. This
     *    information is needed when VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL setting is true
     *    and template contains a macro with the same name as the global macro library.
     * 
     * @since Velocity 1.6
     * 
     * @return VelocimacroProxy
     */
    public Directive getVelocimacro( String vmName, String templateName, String renderingTemplate  );
   /**
     * Adds a new Velocimacro. Usually called by Macro only while parsing.
     *
     * @param name  Name of velocimacro
     * @param macro  String form of macro body
     * @param argArray  Array of strings, containing the
     *                         #macro() arguments.  the 0th is the name.
     * @param sourceTemplate
     * 
     * @deprecated Use addVelocimacro(String, Node, String[], String) instead
     *                   
     * @return boolean  True if added, false if rejected for some
     *                  reason (either parameters or permission settings)
     */
    public boolean addVelocimacro( String name,
                                          String macro,
                                          String argArray[],
                                          String sourceTemplate );
    /**
     * Adds a new Velocimacro. Usually called by Macro only while parsing.
     *
     * @param name  Name of velocimacro
     * @param macro  root AST node of the parsed macro
     * @param argArray  Array of strings, containing the
     *                         #macro() arguments.  the 0th is the name.
     * @param sourceTemplate
     * 
     * @since Velocity 1.6
     *                   
     * @return boolean  True if added, false if rejected for some
     *                  reason (either parameters or permission settings)
     */
    public boolean addVelocimacro( String name,
                                          Node macro,
                                          String argArray[],
                                          String sourceTemplate );
    /**
     *  Checks to see if a VM exists
     *
     * @param vmName  Name of velocimacro
     * @param templateName
     * @return boolean  True if VM by that name exists, false if not
     */
    public boolean isVelocimacro( String vmName, String templateName );
    /**
     *  tells the vmFactory to dump the specified namespace.  This is to support
     *  clearing the VM list when in inline-VM-local-scope mode
     * @param namespace
     * @return True if the Namespace was dumped.
     */
    public boolean dumpVMNamespace( String namespace );
    /**
     * String property accessor method to hide the configuration implementation
     * @param key  property key
     * @return   value of key or null
     */
    public String getString(String key);
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key property key
     * @return int value
     */
    public int getInt( String key );
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key  property key
     * @param defaultValue default value
     * @return int  value
     */
    public int getInt( String key, int defaultValue );
    /**
     * Boolean property accessor method to hide the configuration implementation.
     *
     * @param key  property key
     * @param def default default value if property not found
     * @return boolean  value of key or default value
     */
    public boolean getBoolean( String key, boolean def );
    /**
     * Return the velocity runtime configuration object.
     *
     * @return ExtendedProperties configuration object which houses
     *                       the velocity runtime properties.
     */
    public ExtendedProperties getConfiguration();
    /**
     * Return the specified application attribute.
     *
     * @param key The name of the attribute to retrieve.
     * @return The value of the attribute.
     */
    public Object getApplicationAttribute( Object key );
    /**
     * Set the specified application attribute.
     *
     * @param key The name of the attribute to set.
     * @param value The attribute value to set.
     * @return the displaced attribute value
     */
    public Object setApplicationAttribute( Object key, Object value );
    /**
     * Returns the configured class introspection/reflection
     * implementation.
     * @return The current Uberspect object.
     */
    public Uberspect getUberspect();
    /**
     * Returns a convenient Log instance that wraps the current LogChute.
     * @return A log object.
     */
    public Log getLog();
    /**
     * Returns the event handlers for the application.
     * @return The event handlers for the application.
     */
    public EventCartridge getApplicationEventCartridge();
    /**
     * Returns the configured method introspection/reflection
     * implementation.
     * @return The configured method introspection/reflection
     * implementation.
     */
    public Introspector getIntrospector();
    /**
     * Returns true if the RuntimeInstance has been successfully initialized.
     * @return True if the RuntimeInstance has been successfully initialized.
     */
    public boolean isInitialized();
    /**
     * Create a new parser instance.
     * @return A new parser instance.
     */
    public Parser createNewParser();
    /**
     * Retrieve a previously instantiated directive.
     * @param name name of the directive
     * @return the directive with that name, if any
     * @since 1.6
     */
    public Directive getDirective(String name);
}
"
org.apache.velocity.runtime.RuntimeSingleton,"package org.apache.velocity.runtime;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.Reader;
import java.util.Properties;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.velocity.Template;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.resource.ContentResource;
import org.apache.velocity.util.introspection.Introspector;
import org.apache.velocity.util.introspection.Uberspect;
/**
 * This is the Runtime system for Velocity. It is the
 * single access point for all functionality in Velocity.
 * It adheres to the mediator pattern and is the only
 * structure that developers need to be familiar with
 * in order to get Velocity to perform.
 *
 * The Runtime will also cooperate with external
 * systems like Turbine. Runtime properties can
 * set and then the Runtime is initialized.
 *
 * Turbine for example knows where the templates
 * are to be loaded from, and where the velocity
 * log file should be placed.
 *
 * So in the case of Velocity cooperating with Turbine
 * the code might look something like the following:
 *
 * <pre>
 * RuntimeSingleton.setProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, templatePath);
 * RuntimeSingleton.setProperty(RuntimeConstants.RUNTIME_LOG, pathToVelocityLog);
 * RuntimeSingleton.init();
 * </pre>
 *
 * <pre>
 * -----------------------------------------------------------------------
 * N O T E S  O N  R U N T I M E  I N I T I A L I Z A T I O N
 * -----------------------------------------------------------------------
 * RuntimeSingleton.init()
 *
 * If Runtime.init() is called by itself the Runtime will
 * initialize with a set of default values.
 * -----------------------------------------------------------------------
 * RuntimeSingleton.init(String/Properties)
 *
 * In this case the default velocity properties are layed down
 * first to provide a solid base, then any properties provided
 * in the given properties object will override the corresponding
 * default property.
 * -----------------------------------------------------------------------
 * </pre>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:jlb@houseofdistraction.com"">Jeff Bowden</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magusson Jr.</a>
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 *
 * @see org.apache.velocity.runtime.RuntimeInstance
 *
 * @version $Id: RuntimeSingleton.java 685724 2008-08-13 23:12:12Z nbubna $
 */
public class RuntimeSingleton implements RuntimeConstants
{
    private static RuntimeInstance ri = new RuntimeInstance();
    /**
     * This is the primary initialization method in the Velocity
     * Runtime. The systems that are setup/initialized here are
     * as follows:
     *
     * <ul>
     *   <li>Logging System</li>
     *   <li>ResourceManager</li>
     *   <li>Event Handlers</li>
     *   <li>Parser Pool</li>
     *   <li>Global Cache</li>
     *   <li>Static Content Include System</li>
     *   <li>Velocimacro System</li>
     * </ul>
     * @throws Exception When an error occured during initialization.
     * @see RuntimeInstance#init()
     */
    public synchronized static void init()
        throws Exception
    {
        ri.init();
    }
    /**
     * Returns true if the RuntimeInstance has been successfully initialized.
     * @return True if the RuntimeInstance has been successfully initialized.
     * @see RuntimeInstance#isInitialized()
     * @since 1.5
     */
    public static boolean isInitialized()
    {
        return ri.isInitialized();
    }
    /**
     * Returns the RuntimeServices Instance used by this wrapper.
     *
     * @return The RuntimeServices Instance used by this wrapper.
     */
    public static RuntimeServices getRuntimeServices()
    {
        return ri;
    }
    /**
     * Allows an external system to set a property in
     * the Velocity Runtime.
     *
     * @param key property key
     * @param  value property value
     * @see RuntimeInstance#setProperty(String, Object)
     */
    public static void setProperty(String key, Object value)
    {
        ri.setProperty( key, value );
    }
    /**
     * Allow an external system to set an ExtendedProperties
     * object to use. This is useful where the external
     * system also uses the ExtendedProperties class and
     * the velocity configuration is a subset of
     * parent application's configuration. This is
     * the case with Turbine.
     *
     * @param configuration
     * @see RuntimeInstance#setConfiguration(ExtendedProperties)
     */
    public static void setConfiguration( ExtendedProperties configuration)
    {
        ri.setConfiguration( configuration );
    }
    /**
     * Add a property to the configuration. If it already
     * exists then the value stated here will be added
     * to the configuration entry. For example, if
     *
     * resource.loader = file
     *
     * is already present in the configuration and you
     *
     * addProperty(""resource.loader"", ""classpath"")
     *
     * Then you will end up with a Vector like the
     * following:
     *
     * [""file"", ""classpath""]
     *
     * @param key
     * @param value
     * @see RuntimeInstance#addProperty(String, Object)
     */
    public static void addProperty(String key, Object value)
    {
        ri.addProperty( key, value );
    }
    /**
     * Clear the values pertaining to a particular
     * property.
     *
     * @param key of property to clear
     * @see RuntimeInstance#clearProperty(String)
     */
    public static void clearProperty(String key)
    {
        ri.clearProperty( key );
    }
    /**
     *  Allows an external caller to get a property.  The calling
     *  routine is required to know the type, as this routine
     *  will return an Object, as that is what properties can be.
     *
     *  @param key property to return
     *  @return Value of the property or null if it does not exist.
     * @see RuntimeInstance#getProperty(String)
     */
    public static Object getProperty( String key )
    {
        return ri.getProperty( key );
    }
    /**
     * Initialize the Velocity Runtime with a Properties
     * object.
     *
     * @param p
     * @throws Exception When an error occurs during initialization.
     * @see RuntimeInstance#init(Properties)
     */
    public static void init(Properties p) throws Exception
    {
        ri.init(p);
    }
    /**
     * Initialize the Velocity Runtime with the name of
     * ExtendedProperties object.
     *
     * @param configurationFile
     * @throws Exception When an error occurs during initialization.
     * @see RuntimeInstance#init(String)
     */
    public static void init(String configurationFile)
        throws Exception
    {
        ri.init( configurationFile );
    }
    /**
     * Parse the input and return the root of
     * AST node structure.
     * <br><br>
     *  In the event that it runs out of parsers in the
     *  pool, it will create and let them be GC'd
     *  dynamically, logging that it has to do that.  This
     *  is considered an exceptional condition.  It is
     *  expected that the user will set the
     *  PARSER_POOL_SIZE property appropriately for their
     *  application.  We will revisit this.
     *
     * @param reader Reader retrieved by a resource loader
     * @param templateName name of the template being parsed
     * @return A root node representing the template as an AST tree.
     * @throws ParseException When the template could not be parsed.
     * @see RuntimeInstance#parse(Reader, String)
     */
    public static SimpleNode parse( Reader reader, String templateName )
        throws ParseException
    {
        return ri.parse( reader, templateName );
    }
    /**
     *  Parse the input and return the root of the AST node structure.
     *
     * @param reader Reader retrieved by a resource loader
     * @param templateName name of the template being parsed
     * @param dumpNamespace flag to dump the Velocimacro namespace for this template
     * @return A root node representing the template as an AST tree.
     * @throws ParseException When the template could not be parsed.
     * @see RuntimeInstance#parse(Reader, String, boolean)
     */
    public static SimpleNode parse( Reader reader, String templateName, boolean dumpNamespace )
        throws ParseException
    {
        return ri.parse( reader, templateName, dumpNamespace );
    }
    /**
     * Returns a <code>Template</code> from the resource manager.
     * This method assumes that the character encoding of the
     * template is set by the <code>input.encoding</code>
     * property.  The default is ""ISO-8859-1""
     *
     * @param name The file name of the desired template.
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     * @see RuntimeInstance#getTemplate(String)
     */
    public static Template getTemplate(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getTemplate( name );
    }
    /**
     * Returns a <code>Template</code> from the resource manager
     *
     * @param name The  name of the desired template.
     * @param encoding Character encoding of the template
     * @return     The template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     * @throws ParseErrorException When the template could not be parsed.
     * @throws Exception Any other error.
     * @see RuntimeInstance#getTemplate(String, String)
     */
    public static Template getTemplate(String name, String  encoding)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getTemplate( name, encoding );
    }
    /**
     * Returns a static content resource from the
     * resource manager.  Uses the current value
     * if INPUT_ENCODING as the character encoding.
     *
     * @param name Name of content resource to get
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException When the template could not be parsed.
     * @throws Exception Any other error.
     * @see RuntimeInstance#getContent(String)
     */
    public static ContentResource getContent(String name)
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getContent( name );
    }
    /**
     * Returns a static content resource from the
     * resource manager.
     *
     * @param name Name of content resource to get
     * @param encoding Character encoding to use
     * @return parsed ContentResource object ready for use
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException When the template could not be parsed.
     * @throws Exception Any other error.
     * @see RuntimeInstance#getContent(String, String)
     */
    public static ContentResource getContent( String name, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return ri.getContent( name, encoding );
    }
    /**
     *  Determines is a template exists, and returns name of the loader that
     *  provides it.  This is a slightly less hokey way to support
     *  the Velocity.templateExists() utility method, which was broken
     *  when per-template encoding was introduced.  We can revisit this.
     *
     *  @param resourceName Name of template or content resource
     *  @return class name of loader than can provide it
     * @see RuntimeInstance#getLoaderNameForResource(String)
     */
    public static String getLoaderNameForResource( String resourceName )
    {
        return ri.getLoaderNameForResource( resourceName );
    }
    /**
     * Returns a convenient Log instance that wraps the current LogChute.
     *
     * @return A convenience Log instance that wraps the current LogChute.
     * @see RuntimeInstance#getLog()
     * @since 1.5
     */
    public static Log getLog()
    {
        return ri.getLog();
    }
    /**
     * @deprecated Use getLog() and call warn() on it.
     * @see Log#warn(Object)
     * @param message The message to log.
     */
    public static void warn(Object message)
    {
        getLog().warn(message);
    }
    /**
     * @deprecated Use getLog() and call info() on it.
     * @see Log#info(Object)
     * @param message The message to log.
     */
    public static void info(Object message)
    {
        getLog().info(message);
    }
    /**
     * @deprecated Use getLog() and call error() on it.
     * @see Log#error(Object)
     * @param message The message to log.
     */
    public static void error(Object message)
    {
        getLog().error(message);
    }
    /**
     * @deprecated Use getLog() and call debug() on it.
     * @see Log#debug(Object)
     * @param message The message to log.
     */
    public static void debug(Object message)
    {
        getLog().debug(message);
    }
    /**
     * String property accessor method with default to hide the
     * configuration implementation.
     *
     * @param key property key
     * @param defaultValue  default value to return if key not
     *               found in resource manager.
     * @return value of key or default
     * @see RuntimeInstance#getString(String, String)
     */
    public static String getString( String key, String defaultValue)
    {
        return ri.getString( key, defaultValue );
    }
    /**
     * Returns the appropriate VelocimacroProxy object if strVMname
     * is a valid current Velocimacro.
     *
     * @param vmName Name of velocimacro requested
     * @param templateName Name of the template that contains the velocimacro.
     * @return The requested VelocimacroProxy.
     * @see RuntimeInstance#getVelocimacro(String, String)
     */
    public static Directive getVelocimacro( String vmName, String templateName  )
    {
        return ri.getVelocimacro( vmName, templateName );
    }
    /**
     * Adds a new Velocimacro. Usually called by Macro only while parsing.
     *
     * @param name  Name of a new velocimacro.
     * @param macro  root AST node of the parsed macro
     * @param argArray  Array of strings, containing the
     *                         #macro() arguments.  the 0th argument is the name.
     * @param sourceTemplate The template from which the macro is requested.
     * @return boolean  True if added, false if rejected for some
     *                  reason (either parameters or permission settings)
     * @see RuntimeInstance#addVelocimacro(String, Node, String[], String)
     * @since 1.6
     */
    public static boolean addVelocimacro(String name, Node macro,
                                         String argArray[], String sourceTemplate)
    {
        return ri.addVelocimacro(name, macro, argArray, sourceTemplate);
    }
   /**
    * Adds a new Velocimacro. Usually called by Macro only while parsing.
    *
    * @param name Name of velocimacro
    * @param macro String form of macro body
    * @param argArray Array of strings, containing the
    *                         #macro() arguments.  the 0th is the name.
    * @param sourceTemplate Name of the template that contains the velocimacro.
    * @return True if added, false if rejected for some
    *                  reason (either parameters or permission settings)
    *                  
    * @deprecated Use addVelocimacro(String, Node, String[], String) instead                  
    *                  
    * @see RuntimeInstance#addVelocimacro(String, String, String[], String)
    */
    public static boolean addVelocimacro( String name,
                                          String macro,
                                          String argArray[],
                                          String sourceTemplate )
    {
        return ri.addVelocimacro( name, macro, argArray, sourceTemplate );
    }
    /**
     *  Checks to see if a VM exists
     *
     * @param vmName Name of the Velocimacro.
     * @param templateName Template on which to look for the Macro.
     * @return True if VM by that name exists, false if not
     * @see RuntimeInstance#isVelocimacro(String, String)
     */
    public static boolean isVelocimacro( String vmName, String templateName )
    {
        return ri.isVelocimacro( vmName, templateName );
    }
    /**
     * tells the vmFactory to dump the specified namespace.  This is to support
     * clearing the VM list when in inline-VM-local-scope mode
     * @param namespace Namespace to dump.
     * @return True if namespace was dumped successfully.
     * @see RuntimeInstance#dumpVMNamespace(String)
     */
    public static boolean dumpVMNamespace( String namespace )
    {
        return ri.dumpVMNamespace( namespace );
    }
    /* --------------------------------------------------------------------
     * R U N T I M E  A C C E S S O R  M E T H O D S
     * --------------------------------------------------------------------
     * These are the getXXX() methods that are a simple wrapper
     * around the configuration object. This is an attempt
     * to make a the Velocity Runtime the single access point
     * for all things Velocity, and allow the Runtime to
     * adhere as closely as possible the the Mediator pattern
     * which is the ultimate goal.
     * --------------------------------------------------------------------
     */
    /**
     * String property accessor method to hide the configuration implementation
     * @param key  property key
     * @return   value of key or null
     * @see RuntimeInstance#getString(String)
     */
    public static String getString(String key)
    {
        return ri.getString( key );
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key Property key
     * @return value
     * @see RuntimeInstance#getInt(String)
     */
    public static int getInt( String key )
    {
        return ri.getInt( key );
    }
    /**
     * Int property accessor method to hide the configuration implementation.
     *
     * @param key  property key
     * @param defaultValue The default value.
     * @return value
     * @see RuntimeInstance#getInt(String, int)
     */
    public static int getInt( String key, int defaultValue )
    {
        return ri.getInt( key, defaultValue );
    }
    /**
     * Boolean property accessor method to hide the configuration implementation.
     *
     * @param key property key
     * @param def The default value if property not found.
     * @return value of key or default value
     * @see RuntimeInstance#getBoolean(String, boolean)
     */
    public static boolean getBoolean( String key, boolean def )
    {
        return ri.getBoolean( key, def );
    }
    /**
     * Return the velocity runtime configuration object.
     *
     * @return ExtendedProperties configuration object which houses
     *                       the velocity runtime properties.
     * @see RuntimeInstance#getConfiguration()
     */
    public static ExtendedProperties getConfiguration()
    {
        return ri.getConfiguration();
    }
    /**
     *  Return the Introspector for this RuntimeInstance
     *
     *  @return Introspector object for this runtime instance
     * @see RuntimeInstance#getIntrospector()
     */
    public static Introspector getIntrospector()
    {
        return ri.getIntrospector();
    }
    /**
     * Returns the event handlers for the application.
     * @return The event handlers for the application.
     * @see RuntimeInstance#getApplicationEventCartridge()
     * @since 1.5
     */
     public EventCartridge getEventCartridge()
     {
         return ri.getApplicationEventCartridge();
     }
    /**
     *  Gets the application attribute for the given key
     *
     * @see org.apache.velocity.runtime.RuntimeServices#getApplicationAttribute(Object)
     * @param key
     * @return The application attribute for the given key.
     * @see RuntimeInstance#getApplicationAttribute(Object)
     */
    public static Object getApplicationAttribute(Object key)
    {
        return ri.getApplicationAttribute(key);
    }
    /**
     * Returns the Uberspect object for this Instance.
     *
     * @return The Uberspect object for this Instance.
     * @see org.apache.velocity.runtime.RuntimeServices#getUberspect()
     * @see RuntimeInstance#getUberspect()
     */
    public static Uberspect getUberspect()
    {
        return ri.getUberspect();
    }
    /**
     * @deprecated Use getRuntimeServices() instead.
     * @return The RuntimeInstance used by this Singleton.
     */
    public static RuntimeInstance getRuntimeInstance()
    {
        return ri;
    }
}
"
org.apache.velocity.runtime.VelocimacroFactory,"package org.apache.velocity.runtime;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.StringReader;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import java.util.ArrayList;
import org.apache.commons.lang.StringUtils;
import org.apache.velocity.Template;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.directive.Macro;
import org.apache.velocity.runtime.directive.VelocimacroProxy;
import org.apache.velocity.runtime.log.LogDisplayWrapper;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.node.Node;
/**
 *  VelocimacroFactory.java
 *
 *   manages the set of VMs in a running Velocity engine.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelocimacroFactory.java 718442 2008-11-18 00:01:17Z nbubna $
 */
public class VelocimacroFactory
{
    /**
     *  runtime services for this instance
     */
    private final RuntimeServices rsvc;
    /**
     *  the log for this instance
     */
    private final LogDisplayWrapper log;
    /**
     *  VMManager : deal with namespace management
     *  and actually keeps all the VM definitions
     */
    private VelocimacroManager vmManager = null;
    /**
     *  determines if replacement of global VMs are allowed
     *  controlled by  VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL
     */
    private boolean replaceAllowed = false;
    /**
     *  controls if new VMs can be added.  Set by
     *  VM_PERM_ALLOW_INLINE  Note the assumption that only
     *  through inline defs can this happen.
     *  additions through autoloaded VMs is allowed
     */
    private boolean addNewAllowed = true;
    /**
     *  sets if template-local namespace in used
     */
    private boolean templateLocal = false;
    /**
     *  determines if the libraries are auto-loaded
     *  when they change
     */
    private boolean autoReloadLibrary = false;
    /**
     *  vector of the library names
     */
    private List macroLibVec = null;
    /**
     *  map of the library Template objects
     *  used for reload determination
     */
    private Map libModMap;
    /**
     *  C'tor for the VelociMacro factory.
     *
     * @param rsvc Reference to a runtime services object.
     */
    public VelocimacroFactory(final RuntimeServices rsvc)
    {
        this.rsvc = rsvc;
        this.log = new LogDisplayWrapper(rsvc.getLog(), ""Velocimacro : "",
                rsvc.getBoolean(RuntimeConstants.VM_MESSAGES_ON, true));
        /*
         *  we always access in a synchronized(), so we
         *  can use an unsynchronized hashmap
         */
        libModMap = new HashMap();
        vmManager = new VelocimacroManager(rsvc);
    }
    /**
     *  initialize the factory - setup all permissions
     *  load all global libraries.
     */
    public void initVelocimacro()
    {
        /*
         *  maybe I'm just paranoid...
         */
        synchronized(this)
        {
            log.trace(""initialization starting."");
            /*
             *   allow replacements while we add the libraries, if exist
             */
            setReplacementPermission(true);
            /*
             *  add all library macros to the global namespace
             */
            vmManager.setNamespaceUsage(false);
            /*
             *  now, if there is a global or local libraries specified, use them.
             *  All we have to do is get the template. The template will be parsed;
             *  VM's  are added during the parse phase
             */
             Object libfiles = rsvc.getProperty(RuntimeConstants.VM_LIBRARY);
             if (libfiles == null)
             {
                 log.debug(""\"""" + RuntimeConstants.VM_LIBRARY +
                     ""\"" is not set.  Trying default library: "" +
                     RuntimeConstants.VM_LIBRARY_DEFAULT);
                 // try the default library.
                 if (rsvc.getLoaderNameForResource(RuntimeConstants.VM_LIBRARY_DEFAULT) != null)
                 {
                     libfiles = RuntimeConstants.VM_LIBRARY_DEFAULT;
                 }
                 else
                 {
                     log.debug(""Default library not found."");
                 }
             }
             if(libfiles != null)
             {
                 macroLibVec = new ArrayList();
                 if (libfiles instanceof Vector)
                 {
                     macroLibVec.addAll((Vector)libfiles);
                 }
                 else if (libfiles instanceof String)
                 {
                     macroLibVec.add(libfiles);
                 }
                 for(int i = 0, is = macroLibVec.size(); i < is; i++)
                 {
                     String lib = (String) macroLibVec.get(i);
                     /*
                      * only if it's a non-empty string do we bother
                      */
                     if (StringUtils.isNotEmpty(lib))
                     {
                         /*
                          *  let the VMManager know that the following is coming
                          *  from libraries - need to know for auto-load
                          */
                         vmManager.setRegisterFromLib(true);
                         log.debug(""adding VMs from VM library : "" + lib);
                         try
                         {
                             Template template = rsvc.getTemplate(lib);
                             /*
                              *  save the template.  This depends on the assumption
                              *  that the Template object won't change - currently
                              *  this is how the Resource manager works
                              */
                             Twonk twonk = new Twonk();
                             twonk.template = template;
                             twonk.modificationTime = template.getLastModified();
                             libModMap.put(lib, twonk);
                         }
                         catch (Exception e)
                         {
                             String msg = ""Velocimacro : Error using VM library : "" + lib;
                             log.error(true, msg, e);
                             throw new VelocityException(msg, e);
                         }
                         log.trace(""VM library registration complete."");
                         vmManager.setRegisterFromLib(false);
                     }
                 }
             }
            /*
             *   now, the permissions
             */
            /*
             *  allowinline : anything after this will be an inline macro, I think
             *  there is the question if a #include is an inline, and I think so
             *
             *  default = true
             */
            setAddMacroPermission(true);
            if (!rsvc.getBoolean( RuntimeConstants.VM_PERM_ALLOW_INLINE, true))
            {
                setAddMacroPermission(false);
                log.debug(""allowInline = false : VMs can NOT be defined inline in templates"");
            }
            else
            {
                log.debug(""allowInline = true : VMs can be defined inline in templates"");
            }
            /*
             *  allowInlineToReplaceGlobal : allows an inline VM , if allowed at all,
             *  to replace an existing global VM
             *
             *  default = false
             */
            setReplacementPermission(false);
            if (rsvc.getBoolean(
                 RuntimeConstants.VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL, false))
            {
                setReplacementPermission(true);
                log.debug(""allowInlineToOverride = true : VMs "" +
                    ""defined inline may replace previous VM definitions"");
            }
            else
            {
                log.debug(""allowInlineToOverride = false : VMs "" +
                    ""defined inline may NOT replace previous VM definitions"");
            }
            /*
             * now turn on namespace handling as far as permissions allow in the
             * manager, and also set it here for gating purposes
             */
            vmManager.setNamespaceUsage(true);
            /*
             *  template-local inline VM mode : default is off
             */
            setTemplateLocalInline(rsvc.getBoolean(
                RuntimeConstants.VM_PERM_INLINE_LOCAL, false));
            if (getTemplateLocalInline())
            {
                log.debug(""allowInlineLocal = true : VMs "" +
                    ""defined inline will be local to their defining template only."");
            }
            else
            {
                log.debug(""allowInlineLocal = false : VMs "" +
                    ""defined inline will be global in scope if allowed."");
            }
            vmManager.setTemplateLocalInlineVM(getTemplateLocalInline());
            /*
             *  autoload VM libraries
             */
            setAutoload(rsvc.getBoolean(RuntimeConstants.VM_LIBRARY_AUTORELOAD, false));
            if (getAutoload())
            {
                log.debug(""autoload on : VM system "" +
                     ""will automatically reload global library macros"");
            }
            else
            {
                log.debug(""autoload off : VM system "" +
                      ""will not automatically reload global library macros"");
            }
            log.trace(""Velocimacro : initialization complete."");
        }
    }
    /**
     * Adds a macro to the factory.
     * 
     * addVelocimacro(String, Node, String[] argArray, String) should be used internally
     * instead of this.
     *
     * @param name Name of the Macro to add.
     * @param macroBody String representation of the macro.
     * @param argArray Macro arguments. First element is the macro name.
     * @param sourceTemplate Source template from which the macro gets registered.
     * 
     * @return true if Macro was registered successfully.
     */
    public boolean addVelocimacro(String name, String macroBody,
            String argArray[], String sourceTemplate)
    {
        /*
         * maybe we should throw an exception, maybe just tell
         * the caller like this...
         *
         * I hate this : maybe exceptions are in order here...
         * They definitely would be if this was only called by directly
         * by users, but Velocity calls this internally.
         */
        if (name == null || macroBody == null || argArray == null ||
            sourceTemplate == null)
        {
            String msg = ""VM '""+name+""' addition rejected : "";
            if (name == null)
            {
                msg += ""name"";
            }
            else if (macroBody == null)
            {
                msg += ""macroBody"";
            }
            else if (argArray == null)
            {
                msg += ""argArray"";
            }
            else
            {
                msg += ""sourceTemplate"";
            }
            msg += "" argument was null"";
            log.error(msg);
            throw new NullPointerException(msg);
        }
        /*
         *  see if the current ruleset allows this addition
         */
        if (!canAddVelocimacro(name, sourceTemplate))
        {
            return false;
        }
        synchronized (this)
        {
            try
            {
                Node macroRootNode = rsvc.parse(new StringReader(macroBody), sourceTemplate);
                vmManager.addVM(name, macroRootNode, argArray, sourceTemplate, replaceAllowed);
            }
            catch (ParseException ex)
            {
                // to keep things 1.3 compatible call toString() here
                throw new RuntimeException(ex.toString());
            }
        }
        if (log.isDebugEnabled())
        {
            StringBuffer msg = new StringBuffer(""added "");
            Macro.macroToString(msg, argArray);
            msg.append("" : source = "").append(sourceTemplate);
            log.debug(msg.toString());
        }
        return true;
    }
    /**
     * Adds a macro to the factory.
     * 
     * @param name Name of the Macro to add.
     * @param macroBody root node of the parsed macro AST
     * @param argArray Name of the macro arguments. First element is the macro name.
     * @param sourceTemplate Source template from which the macro gets registered.
     * @return true if Macro was registered successfully.
     * @since 1.6
     */
    public boolean addVelocimacro(String name, Node macroBody,
            String argArray[], String sourceTemplate)
    {
        // Called by RuntimeInstance.addVelocimacro
    	/*
         * maybe we should throw an exception, maybe just tell
         * the caller like this...
         *
         * I hate this : maybe exceptions are in order here...
         * They definitely would be if this was only called by directly
         * by users, but Velocity calls this internally.
         */
        if (name == null || macroBody == null || argArray == null ||
            sourceTemplate == null)
        {
            String msg = ""VM '""+name+""' addition rejected : "";
            if (name == null)
            {
                msg += ""name"";
            }
            else if (macroBody == null)
            {
                msg += ""macroBody"";
            }
            else if (argArray == null)
            {
                msg += ""argArray"";
            }
            else
            {
                msg += ""sourceTemplate"";
            }
            msg += "" argument was null"";
            log.error(msg);
            throw new NullPointerException(msg);
        }
        /*
         *  see if the current ruleset allows this addition
         */
        if (!canAddVelocimacro(name, sourceTemplate))
        {
            return false;
        }
        synchronized(this)
        {
            vmManager.addVM(name, macroBody, argArray, sourceTemplate, replaceAllowed);
        }
        return(true);
    }
    /**
     *  determines if a given macro/namespace (name, source) combo is allowed
     *  to be added
     *
     *  @param name Name of VM to add
     *  @param sourceTemplate Source template that contains the defintion of the VM
     *  @return true if it is allowed to be added, false otherwise
     */
    private synchronized boolean canAddVelocimacro(String name, String sourceTemplate)
    {
        /*
         *  short circuit and do it if autoloader is on, and the
         *  template is one of the library templates
         */
        if (autoReloadLibrary && (macroLibVec != null))
        {
            if( macroLibVec.contains(sourceTemplate) )
                return true;
        }
        /*
         * maybe the rules should be in manager?  I dunno. It's to manage
         * the namespace issues first, are we allowed to add VMs at all?
         * This trumps all.
         */
        if (!addNewAllowed)
        {
            log.warn(""VM addition rejected : ""+name+"" : inline VMs not allowed."");
            return false;
        }
        /*
         *  are they local in scope?  Then it is ok to add.
         */
        if (!templateLocal)
        {
            /*
             * otherwise, if we have it already in global namespace, and they can't replace
             * since local templates are not allowed, the global namespace is implied.
             *  remember, we don't know anything about namespace managment here, so lets
             *  note do anything fancy like trying to give it the global namespace here
             *
             *  so if we have it, and we aren't allowed to replace, bail
             */
            if (!replaceAllowed && isVelocimacro(name, sourceTemplate))
            {
                /*
                 * Concurrency fix: the log entry was changed to debug scope because it
                 * causes false alarms when several concurrent threads simultaneously (re)parse
                 * some macro
                 */ 
                if (log.isDebugEnabled())
                    log.debug(""VM addition rejected : ""+name+"" : inline not allowed to replace existing VM"");
                return false;
            }
        }
        return true;
    }
    /**
     * Tells the world if a given directive string is a Velocimacro
     * @param vm Name of the Macro.
     * @param sourceTemplate Source template from which the macro should be loaded.
     * @return True if the given name is a macro.
     */
    public boolean isVelocimacro(String vm, String sourceTemplate)
    {
        // synchronization removed
        return(vmManager.get(vm, sourceTemplate) != null);
    }
    /**
     *  actual factory : creates a Directive that will
     *  behave correctly wrt getting the framework to
     *  dig out the correct # of args
     * @param vmName Name of the Macro.
     * @param sourceTemplate Source template from which the macro should be loaded.
     * @return A directive representing the Macro.
     */
     public Directive getVelocimacro(String vmName, String sourceTemplate)
     {
        return(getVelocimacro(vmName, sourceTemplate, null));
     }
     /**
      * @since 1.6
      */
     public Directive getVelocimacro(String vmName, String sourceTemplate, String renderingTemplate)
     {
        VelocimacroProxy vp = null;
        vp = vmManager.get(vmName, sourceTemplate, renderingTemplate);
        /*
         * if this exists, and autoload is on, we need to check where this VM came from
         */
        if (vp != null && autoReloadLibrary )
        {
            synchronized (this)
            {
                /*
                 * see if this VM came from a library. Need to pass sourceTemplate in the event
                 * namespaces are set, as it could be masked by local
                 */
                String lib = vmManager.getLibraryName(vmName, sourceTemplate);
                if (lib != null)
                {
                    try
                    {
                        /*
                         * get the template from our map
                         */
                        Twonk tw = (Twonk) libModMap.get(lib);
                        if (tw != null)
                        {
                            Template template = tw.template;
                            /*
                             * now, compare the last modified time of the resource with the last
                             * modified time of the template if the file has changed, then reload.
                             * Otherwise, we should be ok.
                             */
                            long tt = tw.modificationTime;
                            long ft = template.getResourceLoader().getLastModified(template);
                            if (ft > tt)
                            {
                                log.debug(""auto-reloading VMs from VM library : "" + lib);
                                /*
                                 * when there are VMs in a library that invoke each other, there are
                                 * calls into getVelocimacro() from the init() process of the VM
                                 * directive. To stop the infinite loop we save the current time
                                 * reported by the resource loader and then be honest when the
                                 * reload is complete
                                 */
                                tw.modificationTime = ft;
                                template = rsvc.getTemplate(lib);
                                /*
                                 * and now we be honest
                                 */
                                tw.template = template;
                                tw.modificationTime = template.getLastModified();
                                /*
                                 * note that we don't need to put this twonk
                                 * back into the map, as we can just use the
                                 * same reference and this block is synchronized
                                 */
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        String msg = ""Velocimacro : Error using VM library : "" + lib;
                        log.error(true, msg, e);
                        throw new VelocityException(msg, e);
                    }
                    vp = vmManager.get(vmName, sourceTemplate, renderingTemplate);
                }
            }
        }
        return vp;
    }
    /**
     * tells the vmManager to dump the specified namespace
     * 
     * @param namespace Namespace to dump.
     * @return True if namespace has been dumped successfully.
     */
    public boolean dumpVMNamespace(String namespace)
    {
        return vmManager.dumpNamespace(namespace);
    }
    /**
     * sets permission to have VMs local in scope to their declaring template note that this is
     * really taken care of in the VMManager class, but we need it here for gating purposes in addVM
     * eventually, I will slide this all into the manager, maybe.
     */
    private void setTemplateLocalInline(boolean b)
    {
        templateLocal = b;
    }
    private boolean getTemplateLocalInline()
    {
        return templateLocal;
    }
    /**
     * sets the permission to add new macros
     */
    private boolean setAddMacroPermission(final boolean addNewAllowed)
    {
        boolean b = this.addNewAllowed;
        this.addNewAllowed = addNewAllowed;
        return b;
    }
    /**
     * sets the permission for allowing addMacro() calls to replace existing VM's
     */
    private boolean setReplacementPermission(boolean arg)
    {
        boolean b = replaceAllowed;
        replaceAllowed = arg;
        vmManager.setInlineReplacesGlobal(arg);
        return b;
    }
    /**
     *  set the switch for automatic reloading of
     *  global library-based VMs
     */
    private void setAutoload(boolean b)
    {
        autoReloadLibrary = b;
    }
    /**
     *  get the switch for automatic reloading of
     *  global library-based VMs
     */
    private boolean getAutoload()
    {
        return autoReloadLibrary;
    }
    /**
     * small container class to hold the tuple
     * of a template and modification time.
     * We keep the modification time so we can
     * 'override' it on a reload to prevent
     * recursive reload due to inter-calling
     * VMs in a library
     */
    private static class Twonk
    {
        /** Template kept in this container. */
        public Template template;
        /** modification time of the template. */
        public long modificationTime;
    }
}
"
org.apache.velocity.runtime.VelocimacroManager,"package org.apache.velocity.runtime;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Collections;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import org.apache.velocity.runtime.directive.VelocimacroProxy;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.util.MapFactory;
/**
 * Manages VMs in namespaces.  Currently, two namespace modes are
 * supported:
 *
 * <ul>
 * <li>flat - all allowable VMs are in the global namespace</li>
 * <li>local - inline VMs are added to it's own template namespace</li>
 * </ul>
 *
 * Thanks to <a href=""mailto:JFernandez@viquity.com"">Jose Alberto Fernandez</a>
 * for some ideas incorporated here.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:JFernandez@viquity.com"">Jose Alberto Fernandez</a>
 * @version $Id: VelocimacroManager.java 698376 2008-09-23 22:15:49Z nbubna $
 */
public class VelocimacroManager
{
    private static String GLOBAL_NAMESPACE = """";
    private boolean registerFromLib = false;
    /** Hash of namespace hashes. */
    private final Map namespaceHash = MapFactory.create(17, 0.5f, 20, false);
    /** reference to global namespace hash */
    private final Map globalNamespace;
    /** set of names of library tempates/namespaces */
    private final Set libraries = Collections.synchronizedSet(new HashSet());
    /*
     * big switch for namespaces.  If true, then properties control
     * usage. If false, no.
     */
    private boolean namespacesOn = true;
    private boolean inlineLocalMode = false;
    private boolean inlineReplacesGlobal = false;
    /**
     * Adds the global namespace to the hash.
     */
    VelocimacroManager(RuntimeServices rsvc)
    {
        /*
         *  add the global namespace to the namespace hash. We always have that.
         */
        globalNamespace = addNamespace(GLOBAL_NAMESPACE);
    }
    /**
     * Adds a VM definition to the cache.
     * 
     * Called by VelocimacroFactory.addVelociMacro (after parsing and discovery in Macro directive)
     * 
     * @param vmName Name of the new VelociMacro.
     * @param macroBody String representation of the macro body.
     * @param argArray Array of macro parameters, first parameter is the macro name.
     * @param namespace The namespace/template from which this macro has been loaded.
     * @return Whether everything went okay.
     */
    public boolean addVM(final String vmName, final Node macroBody, final String argArray[],
                         final String namespace, boolean canReplaceGlobalMacro)
    {
        if (macroBody == null)
        {
            // happens only if someone uses this class without the Macro directive
            // and provides a null value as an argument
            throw new RuntimeException(""Null AST for ""+vmName+"" in ""+namespace);
        }
        MacroEntry me = new MacroEntry(vmName, macroBody, argArray, namespace);
        me.setFromLibrary(registerFromLib);
        /*
         *  the client (VMFactory) will signal to us via
         *  registerFromLib that we are in startup mode registering
         *  new VMs from libraries.  Therefore, we want to
         *  addto the library map for subsequent auto reloads
         */
        boolean isLib = true;
        MacroEntry exist = (MacroEntry) globalNamespace.get(vmName);
        if (registerFromLib)
        {
           libraries.add(namespace);
        }
        else
        {
            /*
             *  now, we first want to check to see if this namespace (template)
             *  is actually a library - if so, we need to use the global namespace
             *  we don't have to do this when registering, as namespaces should
             *  be shut off. If not, the default value is true, so we still go
             *  global
             */
            isLib = libraries.contains(namespace);
        }
        if ( !isLib && usingNamespaces(namespace) )
        {
            /*
             *  first, do we have a namespace hash already for this namespace?
             *  if not, add it to the namespaces, and add the VM
             */
            Map local = getNamespace(namespace, true);
            local.put(vmName, me);
            return true;
        }
        else
        {
            /*
             *  otherwise, add to global template.  First, check if we
             *  already have it to preserve some of the autoload information
             */
            if (exist != null)
            {
                me.setFromLibrary(exist.getFromLibrary());
            }
            /*
             *  now add it
             */
            globalNamespace.put(vmName, me);
            return true;
        }
    }
    /**
     * Gets a VelocimacroProxy object by the name / source template duple.
     * 
     * @param vmName Name of the VelocityMacro to look up.
     * @param namespace Namespace in which to look up the macro.
     * @return A proxy representing the Macro.
     */
     public VelocimacroProxy get(final String vmName, final String namespace)
     {
        return(get(vmName, namespace, null));
     }
     /**
      * Gets a VelocimacroProxy object by the name / source template duple.
      * 
      * @param vmName Name of the VelocityMacro to look up.
      * @param namespace Namespace in which to look up the macro.
      * @param renderingTemplate Name of the template we are currently rendering.
      * @return A proxy representing the Macro.
      * @since 1.6
      */
     public VelocimacroProxy get(final String vmName, final String namespace, final String renderingTemplate)
     {
        if( inlineReplacesGlobal && renderingTemplate != null )
        {
            /*
             * if VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL is true (local macros can
             * override global macros) and we know which template we are rendering at the
             * moment, check if local namespace contains a macro we are looking for
             * if so, return it instead of the global one
             */
            Map local = getNamespace(renderingTemplate, false);
            if (local != null)
            {
                MacroEntry me = (MacroEntry) local.get(vmName);
                if (me != null)
                {
                    return me.getProxy(namespace);
                }
            }
        }
        if (usingNamespaces(namespace))
        {
            Map local = getNamespace(namespace, false);
            /*
             *  if we have macros defined for this template
             */
            if (local != null)
            {
                MacroEntry me = (MacroEntry) local.get(vmName);
                if (me != null)
                {
                    return me.getProxy(namespace);
                }
            }
        }
        /*
         * if we didn't return from there, we need to simply see
         * if it's in the global namespace
         */
        MacroEntry me = (MacroEntry) globalNamespace.get(vmName);
        if (me != null)
        {
            return me.getProxy(namespace);
        }
        return null;
    }
    /**
     * Removes the VMs and the namespace from the manager.
     * Used when a template is reloaded to avoid
     * losing memory.
     *
     * @param namespace namespace to dump
     * @return boolean representing success
     */
    public boolean dumpNamespace(final String namespace)
    {
        synchronized(this)
        {
            if (usingNamespaces(namespace))
            {
                Map h = (Map) namespaceHash.remove(namespace);
                if (h == null)
                {
                    return false;
                }
                h.clear();
                return true;
            }
            return false;
        }
    }
    /**
     *  public switch to let external user of manager to control namespace
     *  usage indep of properties.  That way, for example, at startup the
     *  library files are loaded into global namespace
     *
     * @param namespaceOn True if namespaces should be used.
     */
    public void setNamespaceUsage(final boolean namespaceOn)
    {
        this.namespacesOn = namespaceOn;
    }
    /**
     * Should macros registered from Libraries be marked special?
     * @param registerFromLib True if macros from Libs should be marked.
     */
    public void setRegisterFromLib(final boolean registerFromLib)
    {
        this.registerFromLib = registerFromLib;
    }
    /**
     * Should macros from the same template be inlined?
     *
     * @param inlineLocalMode True if macros should be inlined on the same template.
     */
    public void setTemplateLocalInlineVM(final boolean inlineLocalMode)
    {
        this.inlineLocalMode = inlineLocalMode;
    }
    /**
     *  returns the hash for the specified namespace, and if it doesn't exist
     *  will create a new one and add it to the namespaces
     *
     *  @param namespace  name of the namespace :)
     *  @param addIfNew  flag to add a new namespace if it doesn't exist
     *  @return namespace Map of VMs or null if doesn't exist
     */
    private Map getNamespace(final String namespace, final boolean addIfNew)
    {
        Map h = (Map) namespaceHash.get(namespace);
        if (h == null && addIfNew)
        {
            h = addNamespace(namespace);
        }
        return h;
    }
    /**
     *   adds a namespace to the namespaces
     *
     *  @param namespace name of namespace to add
     *  @return Hash added to namespaces, ready for use
     */
    private Map addNamespace(final String namespace)
    {
        Map h = MapFactory.create(17, 0.5f, 20, false);
        Object oh;
        if ((oh = namespaceHash.put(namespace, h)) != null)
        {
          /*
           * There was already an entry on the table, restore it!
           * This condition should never occur, given the code
           * and the fact that this method is private.
           * But just in case, this way of testing for it is much
           * more efficient than testing before hand using get().
           */
          namespaceHash.put(namespace, oh);
          /*
           * Should't we be returning the old entry (oh)?
           * The previous code was just returning null in this case.
           */
          return null;
        }
        return h;
    }
    /**
     *  determines if currently using namespaces.
     *
     *  @param namespace currently ignored
     *  @return true if using namespaces, false if not
     */
    private boolean usingNamespaces(final String namespace)
    {
        /*
         *  if the big switch turns of namespaces, then ignore the rules
         */
        if (!namespacesOn)
        {
            return false;
        }
        /*
         *  currently, we only support the local template namespace idea
         */
        if (inlineLocalMode)
        {
            return true;
        }
        return false;
    }
    /**
     * Return the library name for a given macro.
     * @param vmName Name of the Macro to look up.
     * @param namespace Namespace to look the macro up.
     * @return The name of the library which registered this macro in a namespace.
     */
    public String getLibraryName(final String vmName, final String namespace)
    {
        if (usingNamespaces(namespace))
        {
            Map local = getNamespace(namespace, false);
            /*
             *  if we have this macro defined in this namespace, then
             *  it is masking the global, library-based one, so
             *  just return null
             */
            if ( local != null)
            {
                MacroEntry me = (MacroEntry) local.get(vmName);
                if (me != null)
                {
                    return null;
                }
            }
        }
        /*
         * if we didn't return from there, we need to simply see
         * if it's in the global namespace
         */
        MacroEntry me = (MacroEntry) globalNamespace.get(vmName);
        if (me != null)
        {
            return me.getSourceTemplate();
        }
        return null;
    }
    /**
     * @since 1.6
     */
    public void setInlineReplacesGlobal(boolean is)
    {
        inlineReplacesGlobal = is;
    }
    /**
     *  wrapper class for holding VM information
     */
    private static class MacroEntry
    {
        private final String vmName;
        private final String[] argArray;
        private final String sourceTemplate;
        private SimpleNode nodeTree = null;
        private boolean fromLibrary = false;
        private VelocimacroProxy vp;
        private MacroEntry(final String vmName, final Node macro,
                   final String argArray[], final String sourceTemplate)
        {
            this.vmName = vmName;
            this.argArray = argArray;
            this.nodeTree = (SimpleNode)macro;
            this.sourceTemplate = sourceTemplate;
            vp = new VelocimacroProxy();
            vp.setName(this.vmName);
            vp.setArgArray(this.argArray);
            vp.setNodeTree(this.nodeTree);
        }
        /**
         * Has the macro been registered from a library.
         * @param fromLibrary True if the macro was registered from a Library.
         */
        public void setFromLibrary(final boolean fromLibrary)
        {
            this.fromLibrary = fromLibrary;
        }
        /**
         * Returns true if the macro was registered from a library.
         * @return True if the macro was registered from a library.
         */
        public boolean getFromLibrary()
        {
            return fromLibrary;
        }
        /**
         * Returns the node tree for this macro.
         * @return The node tree for this macro.
         */
        public SimpleNode getNodeTree()
        {
            return nodeTree;
        }
        /**
         * Returns the source template name for this macro.
         * @return The source template name for this macro.
         */
        public String getSourceTemplate()
        {
            return sourceTemplate;
        }
        VelocimacroProxy getProxy(final String namespace)
        {
            /*
             * FIXME: namespace data is omitted, this probably 
             * breaks some error reporting?
             */ 
            return vp;
        }
    }
}
"
org.apache.velocity.runtime.directive.Break,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import java.util.Iterator;
import java.util.List;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.context.Context;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.node.ASTReference;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.util.introspection.Info;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
/**
 * Break directive used for interrupting foreach loops.
 *
 * @author <a href=""mailto:wyla@removethis.sci.fi"">Jarkko Viinamaki</a>
 * @version $Id$
 */
public class Break extends Directive
{
    /**
     * Return name of this directive.
     * @return The name of this directive.
     */
    public String getName()
    {
        return ""break"";
    }
    /**
     * Return type of this directive.
     * @return The type of this directive.
     */
    public int getType()
    {
        return LINE;
    }
    /**
     *  simple init - init the tree and get the elementKey from
     *  the AST
     * @param rs
     * @param context
     * @param node
     * @throws TemplateInitException
     */
    public void init(RuntimeServices rs, InternalContextAdapter context, Node node)
        throws TemplateInitException
    {
        super.init(rs, context, node);
    }
    /**
     * Break directive does not actually do any rendering. 
     * 
     * This directive throws a BreakException (RuntimeException) which
     * signals foreach directive to break out of the loop. Note that this
     * directive does not verify that it is being called inside a foreach
     * loop.
     * 
     * @param context
     * @param writer
     * @param node
     * @return true if the directive rendered successfully.
     * @throws IOException
     * @throws MethodInvocationException
     * @throws ResourceNotFoundException
     * @throws ParseErrorException
     */
    public boolean render(InternalContextAdapter context,
                           Writer writer, Node node)
        throws IOException,  MethodInvocationException, ResourceNotFoundException,
        	ParseErrorException
    {
        throw new BreakException();
    }
    public static class BreakException extends RuntimeException 
    {
    }
}
"
org.apache.velocity.runtime.directive.Define,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.Writer;
import java.io.IOException;
import java.io.StringWriter;
import org.apache.commons.lang.text.StrBuilder;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.Renderable;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.node.Node;
/**
 * Directive that puts an unrendered AST block in the context
 * under the specified key, postponing rendering until the
 * reference is used and rendered.
 *
 * @author Andrew Tetlaw
 * @author Nathan Bubna
 * @version $Id: Define.java 686842 2008-08-18 18:29:31Z nbubna $
 */
public class Define extends Directive
{
    private String key;
    private Node block;
    private Log log;
    private int maxDepth;
    private String definingTemplate;
    /**
     * Return name of this directive.
     */
    public String getName()
    {
        return ""define"";
    }
    /**
     * Return type of this directive.
     */
    public int getType()
    {
        return BLOCK;
    }
    /**
     *  simple init - get the key
     */
    public void init(RuntimeServices rs, InternalContextAdapter context, Node node)
        throws TemplateInitException
    {
        super.init(rs, context, node);
        log = rs.getLog();
        /*
         * default max depth of two is used because intentional recursion is
         * unlikely and discouraged, so make unintentional ones end fast
         */
        maxDepth = rs.getInt(RuntimeConstants.DEFINE_DIRECTIVE_MAXDEPTH, 2);
        /*
         * first token is the name of the block. We don't even check the format,
         * just assume it looks like this: $block_name. Should we check if it has
         * a '$' or not?
         */
        key = node.jjtGetChild(0).getFirstToken().image.substring(1);
        /**
         * No checking is done. We just grab the second child node and assume
         * that it's the block!
         */
        block = node.jjtGetChild(1);
        /**
         * keep tabs on the template this came from
         */
        definingTemplate = context.getCurrentTemplateName();
    }
    /**
     * directive.render() simply makes an instance of the Block inner class
     * and places it into the context as indicated.
     */
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
    {
        /* put a Block instance into the context,
         * using the user-defined key, for later inline rendering.
         */
        context.put(key, new Block(context, this));
        return true;
    }
    /**
     * Creates a string identifying the source and location of the block
     * definition, and the current template being rendered if that is
     * different.
     */
    protected String id(InternalContextAdapter context)
    {
        StrBuilder str = new StrBuilder(100)
            .append(""block $"").append(key)
            .append("" (defined in "").append(definingTemplate)
            .append("" [line "").append(getLine())
            .append("", column "").append(getColumn()).append(""])"");
        if (!context.getCurrentTemplateName().equals(definingTemplate))
        {
            str.append("" used in "").append(context.getCurrentTemplateName());
        }
        return str.toString();
    }
    /**
     * actual class placed in the context, holds the context and writer
     * being used for the render, as well as the parent (which already holds
     * everything else we need).
     */
    public static class Block implements Renderable
    {
        private InternalContextAdapter context;
        private Define parent;
        private int depth;
        public Block(InternalContextAdapter context, Define parent)
        {
            this.context = context;
            this.parent = parent;
        }
        /**
         *
         */
        public boolean render(InternalContextAdapter context, Writer writer)
        {
            try
            {
                depth++;
                if (depth > parent.maxDepth)
                {
                    /* this is only a debug message, as recursion can
                     * happen in quasi-innocent situations and is relatively
                     * harmless due to how we handle it here.
                     * this is more to help anyone nuts enough to intentionally
                     * use recursive block definitions and having problems
                     * pulling it off properly.
                     */
                    parent.log.debug(""Max recursion depth reached for ""+parent.id(context));
                    depth--;
                    return false;
                }
                else
                {
                    parent.block.render(context, writer);
                    depth--;
                    return true;
                }
            }
            catch (IOException e)
            {
                String msg = ""Failed to render ""+parent.id(context)+"" to writer"";
                parent.log.error(msg, e);
                throw new RuntimeException(msg, e);
            }
            catch (VelocityException ve)
            {
                String msg = ""Failed to render ""+parent.id(context)+"" due to ""+ve;
                parent.log.error(msg, ve);
                throw ve;
            }
        }
        public String toString()
        {
            Writer stringwriter = new StringWriter();
            if(render(context,stringwriter))
            {
                return stringwriter.toString();
            }
            else
            {
                return null;
            }
        }
    }
}
"
org.apache.velocity.runtime.directive.Directive,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.Writer;
import java.io.IOException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.TemplateInitException;
/**
 * Base class for all directives used in Velocity.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: Directive.java 471381 2006-11-05 08:56:58Z wglass $
 */
public abstract class Directive implements DirectiveConstants, Cloneable
{
    private int line = 0;
    private int column = 0;
    /**
     *
     */
    protected RuntimeServices rsvc = null;
    /**
     * Return the name of this directive.
     * @return The name of this directive.
     */
    public abstract String getName();
    /**
     * Get the directive type BLOCK/LINE.
     * @return The directive type BLOCK/LINE.
     */
    public abstract int getType();
    /**
     * Allows the template location to be set.
     * @param line
     * @param column
     */
    public void setLocation( int line, int column )
    {
        this.line = line;
        this.column = column;
    }
    /**
     * for log msg purposes
     * @return The current line for log msg purposes.
     */
    public int getLine()
    {
        return line;
    }
    /**
     * for log msg purposes
     * @return The current column for log msg purposes.
     */
    public int getColumn()
    {
        return column;
    }
    /**
     * How this directive is to be initialized.
     * @param rs
     * @param context
     * @param node
     * @throws TemplateInitException
     */
    public void init( RuntimeServices rs, InternalContextAdapter context,
                      Node node)
        throws TemplateInitException
    {
        rsvc = rs;
        //        int i, k = node.jjtGetNumChildren();
        //for (i = 0; i < k; i++)
        //    node.jjtGetChild(i).init(context, rs);
    }
    /**
     * How this directive is to be rendered
     * @param context
     * @param writer
     * @param node
     * @return True if the directive rendered successfully.
     * @throws IOException
     * @throws ResourceNotFoundException
     * @throws ParseErrorException
     * @throws MethodInvocationException
     */
    public abstract boolean render( InternalContextAdapter context,
                                    Writer writer, Node node )
           throws IOException, ResourceNotFoundException, ParseErrorException,
                MethodInvocationException;
}
"
org.apache.velocity.runtime.directive.DirectiveConstants,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Base class for all directives used in Velocity.
 *
 *  @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 *  @version $Id: DirectiveConstants.java 463298 2006-10-12 16:10:32Z henning $
 */
public interface DirectiveConstants
{
    /** Block directive indicator */
    public static final int BLOCK = 1;
    /** Line directive indicator */
    public static final int LINE = 2;
}
"
org.apache.velocity.runtime.directive.Evaluate,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.EvaluateContext;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.context.InternalContextAdapterImpl;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.ParserTreeConstants;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.util.introspection.Info;
/**
 * Evaluates the macro argument as a Velocity string, using the existing
 * context.
 *
 * @author <a href=""mailto:wglass@apache.org"">Will Glass-Husain</a>
 * @version $Id: Evaluate.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.6
 */
public class Evaluate extends Directive
{
    /**
     * Return name of this directive.
     * @return The name of this directive.
     */
    public String getName()
    {
        return ""evaluate"";
    }
    /**
     * Return type of this directive.
     * @return The type of this directive.
     */
    public int getType()
    {
        return LINE;
    }
    /**
     * Initialize and check arguments.
     * @param rs
     * @param context
     * @param node
     * @throws TemplateInitException
     */
    public void init(RuntimeServices rs, InternalContextAdapter context,
                     Node node)
        throws TemplateInitException
    {
        super.init( rs, context, node );
        /**
         * Check that there is exactly one argument and it is a string or reference.
         */  
        int argCount = node.jjtGetNumChildren();
        if (argCount == 0)
        {
            throw new TemplateInitException(
                    ""#"" + getName() + ""() requires exactly one argument"", 
                    context.getCurrentTemplateName(),
                    node.getColumn(),
                    node.getLine());            
        }
        if (argCount > 1)
        {
            /* 
             * use line/col of second argument
             */
            throw new TemplateInitException(
                    ""#"" + getName() + ""() requires exactly one argument"", 
                    context.getCurrentTemplateName(),
                    node.jjtGetChild(1).getColumn(),
                    node.jjtGetChild(1).getLine());
        }
        Node childNode = node.jjtGetChild(0);
        if ( childNode.getType() !=  ParserTreeConstants.JJTSTRINGLITERAL &&
             childNode.getType() !=  ParserTreeConstants.JJTREFERENCE )
        {
           throw new TemplateInitException(
                   ""#"" + getName() + ""()  argument must be a string literal or reference"", 
                   context.getCurrentTemplateName(),
                   childNode.getColumn(),
                   childNode.getLine());
        }
    }
    /**
     * Evaluate the argument, convert to a String, and evaluate again 
     * (with the same context).
     * @param context
     * @param writer
     * @param node
     * @return True if the directive rendered successfully.
     * @throws IOException
     * @throws ResourceNotFoundException
     * @throws ParseErrorException 
     * @throws MethodInvocationException
     */
    public boolean render(InternalContextAdapter context, Writer writer,
            Node node) throws IOException, ResourceNotFoundException,
            ParseErrorException, MethodInvocationException
    {
        /*
         * Evaluate the string with the current context.  We know there is
         * exactly one argument and it is a string or reference.
         */
        Object value = node.jjtGetChild(0).value( context );
        String sourceText;
        if ( value != null )
        {
            sourceText = value.toString();
        } 
        else
        {
            sourceText = """";
        }
        /*
         * The new string needs to be parsed since the text has been dynamically generated.
         */
        String templateName = context.getCurrentTemplateName();
        SimpleNode nodeTree = null;
        try
        {
            nodeTree = rsvc.parse(sourceText, templateName);
        }
        catch (ParseException pex)
        {
            // use the line/column from the template
            Info info = new Info( templateName, node.getLine(), node.getColumn() );
            throw  new ParseErrorException( pex.getMessage(), info );
        }
        catch (TemplateInitException pex)
        {
            Info info = new Info( templateName, node.getLine(), node.getColumn() );
            throw  new ParseErrorException( pex.getMessage(), info );
        }
        /*
         * now we want to init and render.  Chain the context
         * to prevent any changes to the current context.
         */
        if (nodeTree != null)
        {
            InternalContextAdapterImpl ica =
                new InternalContextAdapterImpl( new EvaluateContext(context, rsvc) );
            ica.pushCurrentTemplateName( templateName );
            try
            {
                try
                {
                    nodeTree.init( ica, rsvc );
                }
                catch (TemplateInitException pex)
                {
                    Info info = new Info( templateName, node.getLine(), node.getColumn() );
                    throw  new ParseErrorException( pex.getMessage(), info );
                }
                try 
                {
                    /*
                     *  now render, and let any exceptions fly
                     */
                    nodeTree.render( ica, writer );
                }
                catch (ParseErrorException pex)
                {
                    // convert any parsing errors to the correct line/col
                    Info info = new Info( templateName, node.getLine(), node.getColumn() );
                    throw  new ParseErrorException( pex.getMessage(), info );
                }
            }
            finally
            {
                ica.popCurrentTemplateName();
            }
            return true;
        }
        return false;
    }
}
"
org.apache.velocity.runtime.directive.Foreach,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import java.util.Iterator;
import java.util.List;
import org.apache.velocity.app.event.EventCartridge;
import org.apache.velocity.context.ChainedInternalContextAdapter;
import org.apache.velocity.context.Context;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.node.ASTReference;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.SimpleNode;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.util.introspection.Info;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
/**
 * Foreach directive used for moving through arrays,
 * or objects that provide an Iterator.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author Daniel Rall
 * @version $Id: Foreach.java 705363 2008-10-16 21:23:23Z nbubna $
 */
public class Foreach extends Directive
{
    /**
     * A special context to use when the foreach iterator returns a null.  This
     * is required since the standard context may not support nulls.
     * All puts and gets are passed through, except for the foreach iterator key.
     * @since 1.5
     */
    protected static class NullHolderContext extends ChainedInternalContextAdapter
    {
        private String   loopVariableKey = """";
        private boolean  active = true;
        /**
         * Create the context as a wrapper to be used within the foreach
         * @param key the reference used in the foreach
         * @param context the parent context
         */
        private NullHolderContext( String key, InternalContextAdapter context )
        {
           super(context);
           if( key != null )
               loopVariableKey = key;
        }
        /**
         * Get an object from the context, or null if the key is equal to the loop variable
         * @see org.apache.velocity.context.InternalContextAdapter#get(java.lang.String)
         * @exception MethodInvocationException passes on potential exception from reference method call
         */
        public Object get( String key ) throws MethodInvocationException
        {
            return ( active && loopVariableKey.equals(key) )
                ? null
                : super.get(key);
        }
        /**
         * @see org.apache.velocity.context.InternalContextAdapter#put(java.lang.String key, java.lang.Object value)
         */
        public Object put( String key, Object value )
        {
            if( loopVariableKey.equals(key) && (value == null) )
            {
                active = true;
            }
            return super.put( key, value );
        }
        /**
         * Allows callers to explicitly put objects in the local context.
         * Objects added to the context through this method always end up
         * in the top-level context of possible wrapped contexts.
         *
         * @param key name of item to set.
         * @param value object to set to key.
         * @see org.apache.velocity.context.InternalWrapperContext#localPut(String, Object)
         */        
        public Object localPut(final String key, final Object value)
        {
            return put(key, value);
        }
        /**
         * Remove an object from the context
         * @see org.apache.velocity.context.InternalContextAdapter#remove(java.lang.Object key)
         */
        public Object remove(Object key)
        {
           if( loopVariableKey.equals(key) )
           {
             active = false;
           }
           return super.remove(key);
        }
    }
    /**
     * Return name of this directive.
     * @return The name of this directive.
     */
    public String getName()
    {
        return ""foreach"";
    }
    /**
     * Return type of this directive.
     * @return The type of this directive.
     */
    public int getType()
    {
        return BLOCK;
    }
    /**
     * The name of the variable to use when placing
     * the counter value into the context. Right
     * now the default is $velocityCount.
     */
    private String counterName;
    /**
     * The name of the variable to use when placing
     * iterator hasNext() value into the context.Right
     * now the defailt is $velocityHasNext
     */
    private String hasNextName;
    /**
     * What value to start the loop counter at.
     */
    private int counterInitialValue;
    /**
     * The maximum number of times we're allowed to loop.
     */
    private int maxNbrLoops;
    /**
     * Whether or not to throw an Exception if the iterator is null.
     */
    private boolean skipInvalidIterator;
    /**
     * The reference name used to access each
     * of the elements in the list object. It
     * is the $item in the following:
     *
     * #foreach ($item in $list)
     *
     * This can be used class wide because
     * it is immutable.
     */
    private String elementKey;
    /**
     *  immutable, so create in init
     */
    protected Info uberInfo;
    /**
     *  simple init - init the tree and get the elementKey from
     *  the AST
     * @param rs
     * @param context
     * @param node
     * @throws TemplateInitException
     */
    public void init(RuntimeServices rs, InternalContextAdapter context, Node node)
        throws TemplateInitException
    {
        super.init(rs, context, node);
        counterName = rsvc.getString(RuntimeConstants.COUNTER_NAME);
        hasNextName = rsvc.getString(RuntimeConstants.HAS_NEXT_NAME);
        counterInitialValue = rsvc.getInt(RuntimeConstants.COUNTER_INITIAL_VALUE);
        maxNbrLoops = rsvc.getInt(RuntimeConstants.MAX_NUMBER_LOOPS,
                                  Integer.MAX_VALUE);
        if (maxNbrLoops < 1)
        {
            maxNbrLoops = Integer.MAX_VALUE;
        }
        skipInvalidIterator =
            rsvc.getBoolean(RuntimeConstants.SKIP_INVALID_ITERATOR, true);
        /*
         *  this is really the only thing we can do here as everything
         *  else is context sensitive
         */
        SimpleNode sn = (SimpleNode) node.jjtGetChild(0);
        if (sn instanceof ASTReference)
        {
            elementKey = ((ASTReference) sn).getRootString();
        }
        else
        {
            /*
             * the default, error-prone way which we'll remove
             *  TODO : remove if all goes well
             */
            elementKey = sn.getFirstToken().image.substring(1);
        }
        /*
         * make an uberinfo - saves new's later on
         */
        uberInfo = new Info(context.getCurrentTemplateName(),
                getLine(),getColumn());
    }
    /**
     * Extension hook to allow subclasses to control whether loop vars
     * are set locally or not. So, those in favor of VELOCITY-285, can
     * make that happen easily by overriding this and having it use
     * context.localPut(k,v). See VELOCITY-630 for more on this.
     */
    protected void put(InternalContextAdapter context, String key, Object value)
    {
        context.put(key, value);
    }
    /**
     *  renders the #foreach() block
     * @param context
     * @param writer
     * @param node
     * @return True if the directive rendered successfully.
     * @throws IOException
     * @throws MethodInvocationException
     * @throws ResourceNotFoundException
     * @throws ParseErrorException
     */
    public boolean render(InternalContextAdapter context,
                           Writer writer, Node node)
        throws IOException,  MethodInvocationException, ResourceNotFoundException,
        	ParseErrorException
    {
        /*
         *  do our introspection to see what our collection is
         */
        Object listObject = node.jjtGetChild(2).value(context);
        if (listObject == null)
             return false;
        Iterator i = null;
        try
        {
            i = rsvc.getUberspect().getIterator(listObject, uberInfo);
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch(Exception ee)
        {
            String msg = ""Error getting iterator for #foreach at ""+uberInfo;
            rsvc.getLog().error(msg, ee);
            throw new VelocityException(msg, ee);
        }
        if (i == null)
        {
            if (skipInvalidIterator)
            {
                return false;
            }
            else
            {
                Node pnode = node.jjtGetChild(2);
                String msg = ""#foreach parameter "" + pnode.literal() + "" at ""
                    + rsvc.getLog().formatFileString(uberInfo.getTemplateName(),
                       pnode.getLine(), pnode.getColumn()) 
                    + "" is of type "" + listObject.getClass().getName()
                    + "" and is either of wrong type or cannot be iterated."";
                rsvc.getLog().error(msg);
                throw new VelocityException(msg);
            }
        }
        int counter = counterInitialValue;
        boolean maxNbrLoopsExceeded = false;
        /*
         *  save the element key if there is one, and the loop counter
         */
        Object o = context.get(elementKey);
        Object savedCounter = context.get(counterName);
        /*
         * Instantiate the null holder context if a null value
         * is returned by the foreach iterator.  Only one instance is
         * created - it's reused for every null value.
         */
        NullHolderContext nullHolderContext = null;
        while (!maxNbrLoopsExceeded && i.hasNext())
        {
            // TODO: JDK 1.5+ -> Integer.valueOf()
            put(context, counterName , new Integer(counter));
            put(context, hasNextName, Boolean.valueOf(i.hasNext()));
            Object value = i.next();
            put(context, elementKey, value);
            try
            {
                /*
                 * If the value is null, use the special null holder context
                 */
                if (value == null)
                {
                    if (nullHolderContext == null)
                    {
                        // lazy instantiation
                        nullHolderContext = new NullHolderContext(elementKey, context);
                    }
                    node.jjtGetChild(3).render(nullHolderContext, writer);
                }
                else
                {
                    node.jjtGetChild(3).render(context, writer);
                }
            }
            catch (Break.BreakException ex)
            {
                // encountered #break directive inside #foreach loop
                break;
            }
            counter++;
            // Determine whether we're allowed to continue looping.
            // ASSUMPTION: counterInitialValue is not negative!
            maxNbrLoopsExceeded = (counter - counterInitialValue) >= maxNbrLoops;
        }
        /*
         * restores the loop counter (if we were nested)
         * if we have one, else just removes
         */
        if (savedCounter != null)
        {
            context.put(counterName, savedCounter);
        }
        else
        {
            context.remove(counterName);
        }
        /*
         *  restores element key if exists
         *  otherwise just removes
         */
        if (o != null)
        {
            context.put(elementKey, o);
        }
        else
        {
            context.remove(elementKey);
        }
        return true;
    }
}
"
org.apache.velocity.runtime.directive.Include,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.app.event.EventHandlerUtil;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.ParserTreeConstants;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.resource.Resource;
/**
 * <p>Pluggable directive that handles the #include() statement in VTL.
 * This #include() can take multiple arguments of either
 * StringLiteral or Reference.</p>
 *
 * <p>Notes:</p>
 * <ol>
 * <li>For security reasons, the included source material can only come
 *    from somewhere within the template root tree.  If you want to include
 *    content from elsewhere on your disk, add extra template roots, or use
 *    a link from somwhere under template root to that content.</li>
 *
 *  <li>By default, there is no output to the render stream in the event of
 *    a problem.  You can override this behavior with two property values :
 *       include.output.errormsg.start
 *       include.output.errormsg.end
 *     If both are defined in velocity.properties, they will be used to
 *     in the render output to bracket the arg string that caused the
 *     problem.
 *     Ex. : if you are working in html then
 *       include.output.errormsg.start=&lt;!-- #include error :
 *       include.output.errormsg.end= --&gt;
 *     might be an excellent way to start...</li>
 *
 *  <li>As noted above, #include() can take multiple arguments.
 *    Ex : #include('foo.vm' 'bar.vm' $foo)
 *    will include all three if valid to output without any
 *    special separator.</li>
 *  </ol>
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:kav@kav.dk"">Kasper Nielsen</a>
 * @version $Id: Include.java 687177 2008-08-19 22:00:32Z nbubna $
 */
public class Include extends InputBase
{
    private String outputMsgStart = """";
    private String outputMsgEnd = """";
    /**
     * Return name of this directive.
     * @return The name of this directive.
     */
    public String getName()
    {
        return ""include"";
    }
    /**
     * Return type of this directive.
     * @return The type of this directive.
     */
    public int getType()
    {
        return LINE;
    }
    /**
     *  simple init - init the tree and get the elementKey from
     *  the AST
     * @param rs
     * @param context
     * @param node
     * @throws TemplateInitException
     */
    public void init(RuntimeServices rs, InternalContextAdapter context,
                     Node node)
        throws TemplateInitException
    {
        super.init( rs, context, node );
        /*
         *  get the msg, and add the space so we don't have to
         *  do it each time
         */
        outputMsgStart = rsvc.getString(RuntimeConstants.ERRORMSG_START);
        outputMsgStart = outputMsgStart + "" "";
        outputMsgEnd = rsvc.getString(RuntimeConstants.ERRORMSG_END );
        outputMsgEnd = "" "" + outputMsgEnd;
    }
    /**
     *  iterates through the argument list and renders every
     *  argument that is appropriate.  Any non appropriate
     *  arguments are logged, but render() continues.
     * @param context
     * @param writer
     * @param node
     * @return True if the directive rendered successfully.
     * @throws IOException
     * @throws MethodInvocationException
     * @throws ResourceNotFoundException
     */
    public boolean render(InternalContextAdapter context,
                           Writer writer, Node node)
        throws IOException, MethodInvocationException,
               ResourceNotFoundException
    {
        /*
         *  get our arguments and check them
         */
        int argCount = node.jjtGetNumChildren();
        for( int i = 0; i < argCount; i++)
        {
            /*
             *  we only handle StringLiterals and References right now
             */
            Node n = node.jjtGetChild(i);
            if ( n.getType() ==  ParserTreeConstants.JJTSTRINGLITERAL ||
                 n.getType() ==  ParserTreeConstants.JJTREFERENCE )
            {
                if (!renderOutput( n, context, writer ))
                    outputErrorToStream( writer, ""error with arg "" + i
                        + "" please see log."");
            }
            else
            {
                String msg = ""invalid #include() argument type [line ""+getLine()+
                             "", column ""+getColumn()+"", template ""+
                             context.getCurrentTemplateName()+""]: ""+n.toString();
                rsvc.getLog().error(msg);
                outputErrorToStream( writer, ""error with arg "" + i
                    + "" please see log."");
                throw new VelocityException(msg);
            }
        }
        return true;
    }
    /**
     *  does the actual rendering of the included file
     *
     *  @param node AST argument of type StringLiteral or Reference
     *  @param context valid context so we can render References
     *  @param writer output Writer
     *  @return boolean success or failure.  failures are logged
     *  @exception IOException
     *  @exception MethodInvocationException
     *  @exception ResourceNotFoundException
     */
    private boolean renderOutput( Node node, InternalContextAdapter context,
                                  Writer writer )
        throws IOException, MethodInvocationException,
               ResourceNotFoundException
    {
        if ( node == null )
        {
            rsvc.getLog().error(""#include() null argument"");
            return false;
        }
        /*
         *  does it have a value?  If you have a null reference, then no.
         */
        Object value = node.value( context );
        if ( value == null)
        {
            rsvc.getLog().error(""#include()  null argument"");
            return false;
        }
        /*
         *  get the path
         */
        String sourcearg = value.toString();
        /*
         *  check to see if the argument will be changed by the event handler
         */
        String arg = EventHandlerUtil.includeEvent( rsvc, context, sourcearg, context.getCurrentTemplateName(), getName() );
        /*
         *   a null return value from the event cartridge indicates we should not
         *   input a resource.
         */
        boolean blockinput = false;
        if (arg == null)
            blockinput = true;
        Resource resource = null;
        try
        {
            if (!blockinput)
                resource = rsvc.getContent(arg, getInputEncoding(context));
        }
        catch ( ResourceNotFoundException rnfe )
        {
            /*
             * the arg wasn't found.  Note it and throw
             */
            rsvc.getLog().error(""#include(): cannot find resource '"" + arg +
                                ""', called from template "" +
                                context.getCurrentTemplateName() + "" at ("" +
                                getLine() + "", "" + getColumn() + "")"" );
            throw rnfe;
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch (Exception e)
        {
            String msg = ""#include(): arg = '"" + arg +
                        ""', called from template "" +
                        context.getCurrentTemplateName() + "" at ("" +
                        getLine() + "", "" + getColumn() + ')';
            rsvc.getLog().error(msg, e);
            throw new VelocityException(msg, e);
        }
        /*
         *    note - a blocked input is still a successful operation as this is
         *    expected behavior.
         */
        if ( blockinput )
            return true;
        else if ( resource == null )
            return false;
        writer.write((String)resource.getData());
        return true;
    }
    /**
     *  Puts a message to the render output stream if ERRORMSG_START / END
     *  are valid property strings.  Mainly used for end-user template
     *  debugging.
     *  @param writer
     *  @param msg
     *  @throws IOException
     */
    private void outputErrorToStream( Writer writer, String msg )
        throws IOException
    {
        if ( outputMsgStart != null  && outputMsgEnd != null)
        {
            writer.write(outputMsgStart);
            writer.write(msg);
            writer.write(outputMsgEnd);
        }
    }
}
"
org.apache.velocity.runtime.directive.InputBase,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.resource.Resource;
/**
 * Base class for directives which do input operations
 * (e.g. <code>#include()</code>, <code>#parse()</code>, etc.).
 *
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 * @since 1.4
 */
public abstract class InputBase extends Directive
{
    /**
     * Decides the encoding used during input processing of this
     * directive.
     *
     * Get the resource, and assume that we use the encoding of the
     * current template the 'current resource' can be
     * <code>null</code> if we are processing a stream....
     *
     * @param context The context to derive the default input encoding
     * from.
     * @return The encoding to use when processing this directive.
     */
    protected String getInputEncoding(InternalContextAdapter context)
    {
        Resource current = context.getCurrentResource();
        if (current != null)
        {
            return current.getEncoding();
        }
        else
        {
            return (String) rsvc.getProperty(RuntimeConstants.INPUT_ENCODING);
        }
    }
}
"
org.apache.velocity.runtime.directive.Literal,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.node.Node;
/**
 * A very simple directive that leverages the Node.literal()
 * to grab the literal rendition of a node. We basically
 * grab the literal value on init(), then repeatedly use
 * that during render().
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: Literal.java 471381 2006-11-05 08:56:58Z wglass $
 */
public class Literal extends Directive
{
    String literalText;
    /**
     * Return name of this directive.
     * @return The name of this directive.
     */
    public String getName()
    {
        return ""literal"";
    }
    /**
     * Return type of this directive.
     * @return The type of this directive.
     */
    public int getType()
    {
        return BLOCK;
    }
    /**
     * Store the literal rendition of a node using
     * the Node.literal().
     * @param rs
     * @param context
     * @param node
     * @throws TemplateInitException
     */
    public void init(RuntimeServices rs, InternalContextAdapter context,
                     Node node)
        throws TemplateInitException
    {
        super.init( rs, context, node );
        literalText = node.jjtGetChild(0).literal();
    }
    /**
     * Throw the literal rendition of the block between
     * #literal()/#end into the writer.
     * @param context
     * @param writer
     * @param node
     * @return True if the directive rendered successfully.
     * @throws IOException
     */
    public boolean render( InternalContextAdapter context,
                           Writer writer, Node node)
        throws IOException
    {
        writer.write(literalText);
        return true;
    }
}
"
org.apache.velocity.runtime.directive.Macro,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.ParserTreeConstants;
import org.apache.velocity.runtime.parser.Token;
import org.apache.velocity.runtime.parser.node.Node;
/**
 *  Macro implements the macro definition directive of VTL.
 *
 *  example :
 *
 *  #macro( isnull $i )
 *     #if( $i )
 *         $i
 *      #end
 *  #end
 *
 *  This object is used at parse time to mainly process and register the
 *  macro.  It is used inline in the parser when processing a directive.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""hps@intermeta.de"">Henning P. Schmiedehausen</a>
 * @version $Id: Macro.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public class Macro extends Directive
{
    private static  boolean debugMode = false;
    /**
     * Return name of this directive.
     * @return The name of this directive.
     */
    public String getName()
    {
        return ""macro"";
    }
    /**
     * Return type of this directive.
     * @return The type of this directive.
     */
    public int getType()
    {
        return BLOCK;
    }
    /**
     *   render() doesn't do anything in the final output rendering.
     *   There is no output from a #macro() directive.
     * @param context
     * @param writer
     * @param node
     * @return True if the directive rendered successfully.
     * @throws IOException
     */
    public boolean render(InternalContextAdapter context,
                           Writer writer, Node node)
        throws IOException
    {
        /*
         *  do nothing : We never render.  The VelocimacroProxy object does that
         */
        return true;
    }
    /**
     * @see org.apache.velocity.runtime.directive.Directive#init(org.apache.velocity.runtime.RuntimeServices, org.apache.velocity.context.InternalContextAdapter, org.apache.velocity.runtime.parser.node.Node)
     */
    public void init(RuntimeServices rs, InternalContextAdapter context,
                     Node node)
       throws TemplateInitException
    {
        super.init(rs, context, node);
        /*
         * again, don't do squat.  We want the AST of the macro
         * block to hang off of this but we don't want to
         * init it... it's useless...
         */
    }
    /**
     *  Used by Parser.java to process VMs during the parsing process.
     *
     *  This method does not render the macro to the output stream,
     *  but rather <i>processes the macro body</i> into the internal
     *  representation used by {#link
     *  org.apache.velocity.runtime.directive.VelocimacroProxy}
     *  objects, and if not currently used, adds it to the macro
     *  Factory.
     * @param rs
     * @param t
     * @param node
     * @param sourceTemplate
     * @throws IOException
     * @throws ParseException
     */
    public static void processAndRegister(RuntimeServices rs,  Token t, Node node,
                                          String sourceTemplate)
        throws IOException, ParseException
    {
        /*
         *  There must be at least one arg to  #macro,
         *  the name of the VM.  Note that 0 following
         *  args is ok for naming blocks of HTML
         */
        int numArgs = node.jjtGetNumChildren();
        /*
         *  this number is the # of args + 1.  The + 1
         *  is for the block tree
         */
        if (numArgs < 2)
        {
            /*
             *  error - they didn't name the macro or
             *  define a block
             */
            rs.getLog().error(""#macro error : Velocimacro must have name as 1st "" +
                              ""argument to #macro(). #args = "" + numArgs);
            throw new MacroParseException(""First argument to #macro() must be "" +
                    "" macro name."", sourceTemplate, t);
        }
        /*
         *  lets make sure that the first arg is an ASTWord
         */
        int firstType = node.jjtGetChild(0).getType();
        if(firstType != ParserTreeConstants.JJTWORD)
        {
            throw new MacroParseException(""First argument to #macro() must be a""
                    + "" token without surrounding \' or \"", which specifies""
                    + "" the macro name.  Currently it is a ""
                    + ParserTreeConstants.jjtNodeName[firstType], sourceTemplate, t);
        }
        // get the arguments to the use of the VM - element 0 contains the macro name
        String argArray[] = getArgArray(node, rs);
        /* 
         * we already have the macro parsed as AST so there is no point to
         * transform it into a String again
         */ 
        rs.addVelocimacro(argArray[0], node.jjtGetChild(numArgs - 1), argArray, sourceTemplate);
        /*
         * Even if the add attempt failed, we don't log anything here.
         * Logging must be done at VelocimacroFactory or VelocimacroManager because
         * those classes know the real reason.
         */ 
    }
    /**
     * Creates an array containing the literal text from the macro
     * arguement(s) (including the macro's name as the first arg).
     *
     * @param node The parse node from which to grok the argument
     * list.  It's expected to include the block node tree (for the
     * macro body).
     * @param rsvc For debugging purposes only.
     * @return array of arguments
     */
    private static String[] getArgArray(Node node, RuntimeServices rsvc)
    {
        /*
         * Get the number of arguments for the macro, excluding the
         * last child node which is the block tree containing the
         * macro body.
         */
        int numArgs = node.jjtGetNumChildren();
        numArgs--;  // avoid the block tree...
        String argArray[] = new String[numArgs];
        int i = 0;
        /*
         *  eat the args
         */
        while (i < numArgs)
        {
            argArray[i] = node.jjtGetChild(i).getFirstToken().image;
            /*
             *  trim off the leading $ for the args after the macro name.
             *  saves everyone else from having to do it
             */
            if (i > 0)
            {
                if (argArray[i].startsWith(""$""))
                {
                    argArray[i] = argArray[i]
                        .substring(1, argArray[i].length());
                }
            }
            i++;
        }
        if (debugMode)
        {
            StringBuffer msg = new StringBuffer(""Macro.getArgArray() : nbrArgs="");
            msg.append(numArgs).append("" : "");
            macroToString(msg, argArray);
            rsvc.getLog().debug(msg);
        }
        return argArray;
    }
    /**
     * For debugging purposes.  Formats the arguments from
     * <code>argArray</code> and appends them to <code>buf</code>.
     *
     * @param buf A StringBuffer. If null, a new StringBuffer is allocated.
     * @param argArray The Macro arguments to format
     *
     * @return A StringBuffer containing the formatted arguments. If a StringBuffer
     *         has passed in as buf, this method returns it.
     * @since 1.5
     */
    public static final StringBuffer macroToString(final StringBuffer buf,
                                                   final String[] argArray)
    {
        StringBuffer ret = (buf == null) ? new StringBuffer() : buf;
        ret.append('#').append(argArray[0]).append(""( "");
        for (int i = 1; i < argArray.length; i++)
        {
            ret.append(' ').append(argArray[i]);
        }
        ret.append("" )"");
        return ret;
    }
}
"
org.apache.velocity.runtime.directive.MacroParseException,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.exception.ExtendedParseException;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.Token;
/**
 *  Exception to indicate problem happened while constructing #macro()
 *
 *  For internal use in parser - not to be passed to app level
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @author <a href=""hps@intermeta.de"">Henning P. Schmiedehausen</a>
 * @version $Id: MacroParseException.java 703544 2008-10-10 18:15:53Z nbubna $
 */
public class MacroParseException
        extends ParseException
        implements ExtendedParseException
{
    private final String templateName;
    /**
     * Version Id for serializable
     */
    private static final long serialVersionUID = -4985224672336070689L;
    /**
     * @param msg
     * @param templateName
     * @param currentToken
     */
    public MacroParseException(final String msg, final String templateName, final Token currentToken)
    {
        super(msg);
        this.currentToken = currentToken;
        this.templateName = templateName;
    }
    /**
     * returns the Template name where this exception occured.
     * @return The Template name where this exception occured.
     * @since 1.5
     */
    public String getTemplateName()
    {
        return templateName;
    }
    /**
     * returns the line number where this exception occured.
     * @return The line number where this exception occured.
     * @since 1.5
     */
    public int getLineNumber()
    {
        if ((currentToken != null) && (currentToken.next != null))
        {
            return currentToken.next.beginLine;
        }
        else
        {
            return -1;
        }
    }
    /**
     * returns the column number where this exception occured.
     * @return The column number where this exception occured.
     * @since 1.5
     */
    public int getColumnNumber()
    {
        if ((currentToken != null) && (currentToken.next != null))
        {
            return currentToken.next.beginColumn;
        }
        else
        {
            return -1;
        }
    }
    /**
     * This method has the standard behavior when this object has been
     * created using the standard constructors.  Otherwise, it uses
     * ""currentToken"" and ""expectedTokenSequences"" to generate a parse
     * error message and returns it.  If this object has been created
     * due to a parse error, and you do not catch it (it gets thrown
     * from the parser), then this method is called during the printing
     * of the final stack trace, and hence the correct error message
     * gets displayed.
     * @return the current message.
     * @since 1.5
     */
    public String getMessage()
    {
        if (!specialConstructor)
        {
            StringBuffer sb = new StringBuffer(super.getMessage());
            appendTemplateInfo(sb);
            return sb.toString();
        }
        int maxSize = 0;
        StringBuffer expected = new StringBuffer();
        for (int i = 0; i < expectedTokenSequences.length; i++)
        {
            if (maxSize < expectedTokenSequences[i].length)
            {
                maxSize = expectedTokenSequences[i].length;
            }
            for (int j = 0; j < expectedTokenSequences[i].length; j++)
            {
                expected.append(tokenImage[expectedTokenSequences[i][j]]).append("" "");
            }
            if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0)
            {
                expected.append(""..."");
            }
            expected.append(eol).append(""    "");
        }
        StringBuffer retval = new StringBuffer(""Encountered \"""");
        Token tok = currentToken.next;
        for (int i = 0; i < maxSize; i++)
        {
            if (i != 0)
            {
                retval.append("" "");
            }
            if (tok.kind == 0)
            {
                retval.append(tokenImage[0]);
                break;
            }
            retval.append(add_escapes(tok.image));
            tok = tok.next;
        }
        retval.append(""\"""");
        appendTemplateInfo(retval);
        if (expectedTokenSequences.length == 1)
        {
            retval.append(""Was expecting:"").append(eol).append(""    "");
        }
        else
        {
            retval.append(""Was expecting one of:"").append(eol).append(""    "");
        }
        // avoid JDK 1.3 StringBuffer.append(Object o) vs 1.4 StringBuffer.append(StringBuffer sb) gotcha.
        retval.append(expected.toString());
        return retval.toString();
    }
    /**
     * @param sb
     * @since 1.5
     */
    protected void appendTemplateInfo(final StringBuffer sb)
    {
        sb.append(Log.formatFileString(getTemplateName(), getLineNumber(), getColumnNumber()));
        sb.append(eol);
    }
}
"
org.apache.velocity.runtime.directive.Parse,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import java.util.List;
import java.util.ArrayList;
import org.apache.velocity.Template;
import org.apache.velocity.app.event.EventHandlerUtil;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.SimpleNode;
/**
 * Pluggable directive that handles the <code>#parse()</code>
 * statement in VTL.
 *
 * <pre>
 * Notes:
 * -----
 *  1) The parsed source material can only come from somewhere in
 *    the TemplateRoot tree for security reasons. There is no way
 *    around this.  If you want to include content from elsewhere on
 *    your disk, use a link from somwhere under Template Root to that
 *    content.
 *
 *  2) There is a limited parse depth.  It is set as a property
 *    ""directive.parse.max.depth = 10"" by default.  This 10 deep
 *    limit is a safety feature to prevent infinite loops.
 * </pre>
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:Christoph.Reck@dlr.de"">Christoph Reck</a>
 * @version $Id: Parse.java 696387 2008-09-17 18:19:16Z nbubna $
 */
public class Parse extends InputBase
{
    private int maxDepth;
    /**
     * Return name of this directive.
     * @return The name of this directive.
     */
    public String getName()
    {
        return ""parse"";
    }
    /**
     * Return type of this directive.
     * @return The type of this directive.
     */
    public int getType()
    {
        return LINE;
    }
    /**
     * Init's the #parse directive.
     * @param rs
     * @param context
     * @param node
     * @throws TemplateInitException
     */
    public void init(RuntimeServices rs, InternalContextAdapter context, Node node)
        throws TemplateInitException
    {
        super.init(rs, context, node);
        this.maxDepth = rsvc.getInt(RuntimeConstants.PARSE_DIRECTIVE_MAXDEPTH, 10);
    }
    /**
     *  iterates through the argument list and renders every
     *  argument that is appropriate.  Any non appropriate
     *  arguments are logged, but render() continues.
     * @param context
     * @param writer
     * @param node
     * @return True if the directive rendered successfully.
     * @throws IOException
     * @throws ResourceNotFoundException
     * @throws ParseErrorException
     * @throws MethodInvocationException
     */
    public boolean render( InternalContextAdapter context,
                           Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException,
               MethodInvocationException
    {
    	/*
    	 * if rendering is no longer allowed (after a stop), we can safely
    	 * skip execution of all the parse directives.
    	 */
    	if(!context.getAllowRendering())
        {
    		return true;
    	}
        /*
         *  did we get an argument?
         */
        if ( node.jjtGetChild(0) == null)
        {
            rsvc.getLog().error(""#parse() null argument"");
            return false;
        }
        /*
         *  does it have a value?  If you have a null reference, then no.
         */
        Object value =  node.jjtGetChild(0).value( context );
        if ( value == null)
        {
            rsvc.getLog().error(""#parse() null argument"");
            return  false;
        }
        /*
         *  get the path
         */
        String sourcearg = value.toString();
        /*
         *  check to see if the argument will be changed by the event cartridge
         */
        String arg = EventHandlerUtil.includeEvent( rsvc, context, sourcearg, context.getCurrentTemplateName(), getName());
        /*
         *   a null return value from the event cartridge indicates we should not
         *   input a resource.
         */
        boolean blockinput = false;
        if (arg == null)
            blockinput = true;
        if (maxDepth > 0)
        {
            /* 
             * see if we have exceeded the configured depth.
             */
            Object[] templateStack = context.getTemplateNameStack();
            if (templateStack.length >= maxDepth)
            {
                StringBuffer path = new StringBuffer();
                for( int i = 0; i < templateStack.length; ++i)
                {
                    path.append( "" > "" + templateStack[i] );
                }
                rsvc.getLog().error(""Max recursion depth reached ("" +
                                    templateStack.length + ')' + "" File stack:"" +
                                    path);
                return false;
            }
        }
        /*
         *  now use the Runtime resource loader to get the template
         */
        Template t = null;
        try
        {
            if (!blockinput)
                t = rsvc.getTemplate( arg, getInputEncoding(context) );
        }
        catch ( ResourceNotFoundException rnfe )
        {
            /*
             * the arg wasn't found.  Note it and throw
             */
            rsvc.getLog().error(""#parse(): cannot find template '"" + arg +
                                ""', called from template "" +
                                context.getCurrentTemplateName() + "" at ("" +
                                getLine() + "", "" + getColumn() + "")"" );
            throw rnfe;
        }
        catch ( ParseErrorException pee )
        {
            /*
             * the arg was found, but didn't parse - syntax error
             *  note it and throw
             */
            rsvc.getLog().error(""#parse(): syntax error in #parse()-ed template '""
                                + arg + ""', called from template "" +
                                context.getCurrentTemplateName() + "" at ("" +
                                getLine() + "", "" + getColumn() + "")"" );
            throw pee;
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch ( Exception e)
        {
            String msg = ""#parse() : arg = "" + arg + '.';
            rsvc.getLog().error(msg, e);
            throw new VelocityException(msg, e);
        }
        /**
         * Add the template name to the macro libraries list
         */
        List macroLibraries = context.getMacroLibraries();
        /**
         * if macroLibraries are not set create a new one
         */
        if (macroLibraries == null)
        {
            macroLibraries = new ArrayList();
        }
        context.setMacroLibraries(macroLibraries);
        macroLibraries.add(arg);
        /*
         *  and render it
         */
        try
        {
            if (!blockinput) {
                context.pushCurrentTemplateName(arg);
                ((SimpleNode) t.getData()).render( context, writer );
            }
        }
        /*
         *  if it's a MIE, it came from the render.... throw it...
         */
        catch( MethodInvocationException e )
        {
            throw e;
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch ( Exception e )
        {
            String msg = ""Exception rendering #parse("" + arg + ')';
            rsvc.getLog().error(msg, e);
            throw new VelocityException(msg, e);
        }
        finally
        {
            if (!blockinput)
                context.popCurrentTemplateName();
        }
        /*
         *    note - a blocked input is still a successful operation as this is
         *    expected behavior.
         */
        return true;
    }
}
"
org.apache.velocity.runtime.directive.RuntimeMacro,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import org.apache.commons.lang.text.StrBuilder;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.Token;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.util.introspection.Info;
import java.io.Writer;
import java.io.IOException;
import java.util.List;
/**
 * This class acts as a proxy for potential macros.  When the AST is built
 * this class is inserted as a placeholder for the macro (whether or not
 * the macro is actually defined).  At render time we check whether there is
 * a implementation for the macro call. If an implementation cannot be
 * found the literal text is rendered.
 * @since 1.6
 */
public class RuntimeMacro extends Directive
{
    /**
     * Name of the macro
     */
    private String macroName;
    /**
     * source template name
     */
    private String sourceTemplate;
    /**
     * Literal text of the macro
     */
    private String literal = null;
    /**
     * Node of the macro call
     */
    private Node node = null;
    /**
     * Indicates if we are running in strict reference mode.
     */
    protected boolean strictRef = false;
    /**
     * Create a RuntimeMacro instance. Macro name and source
     * template stored for later use.
     *
     * @param macroName name of the macro
     * @param sourceTemplate template where macro call is made
     */
    public RuntimeMacro(String macroName, String sourceTemplate)
    {
        if (macroName == null || sourceTemplate == null)
        {
            throw new IllegalArgumentException(""Null arguments"");
        }
        this.macroName = macroName;
        this.sourceTemplate = sourceTemplate;
    }
    /**
     * Return name of this Velocimacro.
     *
     * @return The name of this Velocimacro.
     */
    public String getName()
    {
        return macroName;
    }
    /**
     * Velocimacros are always LINE
     * type directives.
     *
     * @return The type of this directive.
     */
    public int getType()
    {
        return LINE;
    }
    /**
     * Intialize the Runtime macro. At the init time no implementation so we
     * just save the values to use at the render time.
     *
     * @param rs runtime services
     * @param context InternalContextAdapter
     * @param node node containing the macro call
     */
    public void init(RuntimeServices rs, InternalContextAdapter context,
                     Node node)
    {
        super.init(rs, context, node);
        rsvc = rs;
        this.node = node;
        /**
         * Only check for strictRef setting if this really looks like a macro,
         * so strict mode doesn't balk at things like #E0E0E0 in a template.
         */
        Token t = node.getLastToken();
        if (t.image.charAt(0) == ')')
        {
            strictRef = rsvc.getBoolean(RuntimeConstants.RUNTIME_REFERENCES_STRICT, false);
        }
    }
    /**
     * It is probably quite rare that we need to render the macro literal
     * so do it only on-demand and then cache the value. This tactic helps to
     * reduce memory usage a bit.
     */
    private String getLiteral()
    {
        if (literal == null)
        {
            StrBuilder buffer = new StrBuilder();
            Token t = node.getFirstToken();
            while (t != null && t != node.getLastToken())
            {
                buffer.append(t.image);
                t = t.next;
            }
            if (t != null)
            {
                buffer.append(t.image);
            }
            literal = buffer.toString();
        }
        return literal;
    }
    /**
     * Velocimacro implementation is not known at the init time. So look for
     * a implementation in the macro libaries and if finds one renders it. The
     * actual rendering is delegated to the VelocimacroProxy object. When
     * looking for a macro we first loot at the template with has the
     * macro call then we look at the macro lbraries in the order they appear
     * in the list. If a macro has many definitions above look up will
     * determine the precedence.
     *
     * @param context
     * @param writer
     * @param node
     * @return true if the rendering is successfull
     * @throws IOException
     * @throws ResourceNotFoundException
     * @throws ParseErrorException
     * @throws MethodInvocationException
     */
    public boolean render(InternalContextAdapter context, Writer writer,
                          Node node)
            throws IOException, ResourceNotFoundException,
            ParseErrorException, MethodInvocationException
    {
        VelocimacroProxy vmProxy = null;
        String renderingTemplate = context.getCurrentTemplateName();
        /**
         * first look in the source template
         */
        Object o = rsvc.getVelocimacro(macroName, sourceTemplate, renderingTemplate);
        if( o != null )
        {
            // getVelocimacro can only return a VelocimacroProxy so we don't need the
            // costly instanceof check
            vmProxy = (VelocimacroProxy)o;
        }
        /**
         * if not found, look in the macro libraries.
         */
        if (vmProxy == null)
        {
            List macroLibraries = context.getMacroLibraries();
            if (macroLibraries != null)
            {
                for (int i = macroLibraries.size() - 1; i >= 0; i--)
                {
                    o = rsvc.getVelocimacro(macroName,
                            (String)macroLibraries.get(i), renderingTemplate);
                    // get the first matching macro
                    if (o != null)
                    {
                        vmProxy = (VelocimacroProxy) o;
                        break;
                    }
                }
            }
        }
        if (vmProxy != null)
        {
            try
            {
            	// mainly check the number of arguments
                vmProxy.init(rsvc, context, node);
            }
            catch (TemplateInitException die)
            {
                Info info = new Info(sourceTemplate, node.getLine(), node.getColumn());
                throw new ParseErrorException(die.getMessage() + "" at ""
                    + Log.formatFileString(info), info);
            }
            try
            {
                return vmProxy.render(context, writer, node);
            }
            catch (RuntimeException e)
            {
                /**
                 * We catch, the exception here so that we can record in
                 * the logs the template and line number of the macro call
                 * which generate the exception.  This information is
                 * especially important for multiple macro call levels.
                 * this is also true for the following catch blocks.
                 */
                rsvc.getLog().error(""Exception in macro #"" + macroName + "" at "" +
                  Log.formatFileString(sourceTemplate, getLine(), getColumn()));
                throw e;
            }
            catch (IOException e)
            {
                rsvc.getLog().error(""Exception in macro #"" + macroName + "" at "" +
                  Log.formatFileString(sourceTemplate, getLine(), getColumn()));
                throw e;
            }
        }
        else if (strictRef)
        {
            Info info = new Info(sourceTemplate, node.getLine(), node.getColumn());
            throw new ParseErrorException(""Macro '#"" + macroName + ""' is not defined at ""
                + Log.formatFileString(info), info);
        }
        /**
         * If we cannot find an implementation write the literal text
         */
        writer.write(getLiteral());
        return true;
    }
}
"
org.apache.velocity.runtime.directive.VelocimacroProxy,"package org.apache.velocity.runtime.directive;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.commons.lang.StringUtils;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.context.ProxyVMContext;
import org.apache.velocity.exception.MacroOverflowException;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.ParserTreeConstants;
import org.apache.velocity.runtime.parser.node.ASTDirective;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.SimpleNode;
/**
 *  VelocimacroProxy.java
 *
 *   a proxy Directive-derived object to fit with the current directive system
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelocimacroProxy.java 718424 2008-11-17 22:50:43Z nbubna $
 */
public class VelocimacroProxy extends Directive
{
    private String macroName;
    private String[] argArray = null;
    private String[] literalArgArray = null;
    private SimpleNode nodeTree = null;
    private int numMacroArgs = 0;
    private boolean preInit = false;
    private boolean strictArguments;
    private boolean localContextScope = false;
    private int maxCallDepth;
    /**
     * Return name of this Velocimacro.
     * @return The name of this Velocimacro.
     */
    public String getName()
    {
        return  macroName;
    }
    /**
     * Velocimacros are always LINE type directives.
     * @return The type of this directive.
     */
    public int getType()
    {
        return LINE;
    }
    /**
     * sets the directive name of this VM
     * 
     * @param name
     */
    public void setName(String name)
    {
        macroName = name;
    }
    /**
     * sets the array of arguments specified in the macro definition
     * 
     * @param arr
     */
    public void setArgArray(String[] arr)
    {
        argArray = arr;
        // for performance reasons we precache these strings - they are needed in
        // ""render literal if null"" functionality
        literalArgArray = new String[arr.length];
        for(int i = 0; i < arr.length; i++)
        {
            literalArgArray[i] = "".literal.$"" + argArray[i];
        }
        /*
         * get the arg count from the arg array. remember that the arg array has the macro name as
         * it's 0th element
         */
        numMacroArgs = argArray.length - 1;
    }
    /**
     * @param tree
     */
    public void setNodeTree(SimpleNode tree)
    {
        nodeTree = tree;
    }
    /**
     * returns the number of ars needed for this VM
     * 
     * @return The number of ars needed for this VM
     */
    public int getNumArgs()
    {
        return numMacroArgs;
    }
    /**
     * Renders the macro using the context.
     * 
     * @param context Current rendering context
     * @param writer Writer for output
     * @param node AST that calls the macro
     * @return True if the directive rendered successfully.
     * @throws IOException
     * @throws MethodInvocationException
     * @throws MacroOverflowException
     */
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
            throws IOException, MethodInvocationException, MacroOverflowException
    {
        // wrap the current context and add the macro arguments
        // the creation of this context is a major bottleneck (incl 2x HashMap)
        final ProxyVMContext vmc = new ProxyVMContext(context, rsvc, localContextScope);
        int callArguments = node.jjtGetNumChildren();
        if (callArguments > 0)
        {
            // the 0th element is the macro name
            for (int i = 1; i < argArray.length && i <= callArguments; i++)
            {
                Node macroCallArgument = node.jjtGetChild(i - 1);
                /*
                 * literalArgArray[i] is needed for ""render literal if null"" functionality.
                 * The value is used in ASTReference render-method.
                 * 
                 * The idea is to avoid generating the literal until absolutely necessary.
                 * 
                 * This makes VMReferenceMungeVisitor obsolete and it would not work anyway 
                 * when the macro AST is shared
                 */
                vmc.addVMProxyArg(context, argArray[i], literalArgArray[i], macroCallArgument);
            }
        }
        /*
         * check that we aren't already at the max call depth
         */
        if (maxCallDepth > 0 && maxCallDepth == vmc.getCurrentMacroCallDepth())
        {
            String templateName = vmc.getCurrentTemplateName();
            Object[] stack = vmc.getMacroNameStack();
            StringBuffer out = new StringBuffer(100)
                .append(""Max calling depth of "").append(maxCallDepth)
                .append("" was exceeded in Template:"").append(templateName)
                .append("" and Macro:"").append(macroName)
                .append("" with Call Stack:"");
            for (int i = 0; i < stack.length; i++)
            {
                if (i != 0)
                {
                    out.append(""->"");
                }
                out.append(stack[i]);
            }
            rsvc.getLog().error(out.toString());
            try
            {
                throw new MacroOverflowException(out.toString());
            }
            finally
            {
                // clean out the macro stack, since we just broke it
                while (vmc.getCurrentMacroCallDepth() > 0)
                {
                    vmc.popCurrentMacroName();
                }
            }
        }
        try
        {
            // render the velocity macro
            vmc.pushCurrentMacroName(macroName);
            nodeTree.render(vmc, writer);
            vmc.popCurrentMacroName();
            return true;
        }
        catch (RuntimeException e)
        {
            throw e;
        }
        catch (Exception e)
        {
            String msg = ""VelocimacroProxy.render() : exception VM = #"" + macroName + ""()"";
            rsvc.getLog().error(msg, e);
            throw new VelocityException(msg, e);
        }
    }
    /**
     * The major meat of VelocimacroProxy, init() checks the # of arguments.
     * 
     * @param rs
     * @param context
     * @param node
     * @throws TemplateInitException
     */
    public void init(RuntimeServices rs, InternalContextAdapter context, Node node)
            throws TemplateInitException
    {
        // there can be multiple threads here so avoid double inits
        synchronized (this)
        {
            if (!preInit)
            {
                super.init(rs, context, node);
                // this is a very expensive call (ExtendedProperties is very slow)
                strictArguments = rs.getConfiguration().getBoolean(
                        RuntimeConstants.VM_ARGUMENTS_STRICT, false);
                // support for local context scope feature, where all references are local
                // we do not have to check this at every invocation of ProxyVMContext
                localContextScope = rsvc.getBoolean(RuntimeConstants.VM_CONTEXT_LOCALSCOPE, false);
                // get the macro call depth limit
                maxCallDepth = rsvc.getInt(RuntimeConstants.VM_MAX_DEPTH);
                // initialize the parsed AST
                // since this is context independent we need to do this only once so
                // do it here instead of the render method
                nodeTree.init(context, rs);
                preInit = true;
            }
        }
        // check how many arguments we got
        int i = node.jjtGetNumChildren();
        // Throw exception for invalid number of arguments?
        if (getNumArgs() != i)
        {
            // If we have a not-yet defined macro, we do get no arguments because
            // the syntax tree looks different than with a already defined macro.
            // But we do know that we must be in a macro definition context somewhere up the
            // syntax tree.
            // Check for that, if it is true, suppress the error message.
            // Fixes VELOCITY-71.
            for (Node parent = node.jjtGetParent(); parent != null;)
            {
                if ((parent instanceof ASTDirective)
                        && StringUtils.equals(((ASTDirective) parent).getDirectiveName(), ""macro""))
                {
                    return;
                }
                parent = parent.jjtGetParent();
            }
            String msg = ""VM #"" + macroName + "": too ""
                    + ((getNumArgs() > i) ? ""few"" : ""many"") + "" arguments to macro. Wanted ""
                    + getNumArgs() + "" got "" + i;
            if (strictArguments)
            {
                /**
                 * indicate col/line assuming it starts at 0 - this will be corrected one call up
                 */
                throw new TemplateInitException(msg, context.getCurrentTemplateName(), 0, 0);
            }
            else
            {
                rsvc.getLog().debug(msg);
                return;
            }
        }
        /* now validate that none of the arguments are plain words, (VELOCITY-614)
         * they should be string literals, references, inline maps, or inline lists */
        for (int n=0; n < i; n++)
        {
            Node child = node.jjtGetChild(n);
            if (child.getType() == ParserTreeConstants.JJTWORD)
            {
                /* indicate col/line assuming it starts at 0
                 * this will be corrected one call up  */
                throw new TemplateInitException(""Invalid arg #""
                    + n + "" in VM #"" + macroName, context.getCurrentTemplateName(), 0, 0);
            }
        }
    }
}
"
org.apache.velocity.runtime.log.AvalonLogChute,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.lang.StringUtils;
import org.apache.log.Hierarchy;
import org.apache.log.LogTarget;
import org.apache.log.Logger;
import org.apache.log.Priority;
import org.apache.log.output.io.FileTarget;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Implementation of a Avalon logger.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:nbubna@apache.org"">Nathan Bubna</a>
 * @version $Id: AvalonLogChute.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class AvalonLogChute implements LogChute
{
    public static final String AVALON_LOGGER = ""runtime.log.logsystem.avalon.logger"";
    public static final String AVALON_LOGGER_FORMAT = ""runtime.log.logsystem.avalon.format"";
    public static final String AVALON_LOGGER_LEVEL = ""runtime.log.logsystem.avalon.level"";
    private Logger logger = null;
    private RuntimeServices rsvc = null;
    private static final Map logLevels = new HashMap();
    static
    {
        logLevels.put(""trace"", Priority.DEBUG);
        logLevels.put(""debug"", Priority.DEBUG);
        logLevels.put(""info"", Priority.INFO);
        logLevels.put(""warn"", Priority.WARN);
        logLevels.put(""error"", Priority.ERROR);
    }
    /**
     * @see org.apache.velocity.runtime.log.LogChute#init(org.apache.velocity.runtime.RuntimeServices)
     */
    public void init(RuntimeServices rs) throws Exception
    {
        this.rsvc = rs;
        // if a logger is specified, we will use this instead of the default
        String name = (String)rsvc.getProperty(AVALON_LOGGER);
        if (name != null)
        {
            this.logger = Hierarchy.getDefaultHierarchy().getLoggerFor(name);
        }
        else
        {
            // use the toString() of RuntimeServices to make a unique logger
            logger = Hierarchy.getDefaultHierarchy().getLoggerFor(rsvc.toString());
            // if we have a file property, use it to create a FileTarget
            String file = (String)rsvc.getProperty(RuntimeConstants.RUNTIME_LOG);
            if (StringUtils.isNotEmpty(file))
            {
                initTarget(file, rsvc);
            }
        }
    }
    // creates a file target using the specified file name
    private void initTarget(final String file, final RuntimeServices rsvc) throws Exception
    {
        try
        {
            String format = null;
            Priority level = null;
            if (rsvc != null)
            {
                format = rsvc.getString(AVALON_LOGGER_FORMAT, ""%{time} %{message}\\n%{throwable}"");
                level = (Priority) logLevels.get(rsvc.getString(AVALON_LOGGER_LEVEL, ""warn""));
            }
            VelocityFormatter vf = new VelocityFormatter(format);
            // make the target and keep the default behavior of not appending
            FileTarget target = new FileTarget(new File(file), false, vf);
            logger.setPriority(level);
            logger.setLogTargets(new LogTarget[] { target });
            log(DEBUG_ID, ""AvalonLogChute initialized using file '""+file+'\'');
        }
        catch (IOException ioe)
        {
            rsvc.getLog().error(""Unable to create log file for AvalonLogChute"", ioe);
            throw new Exception(""Error configuring AvalonLogChute : "" + ioe);
        }
    }
    /**
     * @param file
     * @throws Exception
     * @deprecated This method should not be used. It is here only to provide
     *             backwards compatibility for the deprecated AvalonLogSystem
     *             class, in case anyone used it and this method directly.
     */
    public void init(String file) throws Exception
    {
        logger = Hierarchy.getDefaultHierarchy().getLoggerFor(rsvc.toString());
        initTarget(file, null);
        // nag the theoretical user
        log(DEBUG_ID, ""You shouldn't be using the init(String file) method!"");
    }
    /**
     *  logs messages
     *
     *  @param level severity level
     *  @param message complete error message
     */
    public void log(int level, String message)
    {
        /*
         * based on level, call the right logger method
         * and prefix with the appropos prefix
         */
        switch (level)
        {
            case WARN_ID:
                logger.warn(WARN_PREFIX + message );
                break;
            case INFO_ID:
                logger.info(INFO_PREFIX + message);
                break;
            case DEBUG_ID:
                logger.debug(DEBUG_PREFIX + message);
                break;
            case TRACE_ID:
                logger.debug(TRACE_PREFIX + message);
                break;
            case ERROR_ID:
                logger.error(ERROR_PREFIX + message);
                break;
            default:
                logger.info(message);
                break;
        }
    }
    /**
     *  logs messages and error
     *
     *  @param level severity level
     *  @param message complete error message
     * @param t
     */
    public void log(int level, String message, Throwable t)
    {
        switch (level)
        {
            case WARN_ID:
                logger.warn(WARN_PREFIX + message, t);
                break;
            case INFO_ID:
                logger.info(INFO_PREFIX + message, t);
                break;
            case DEBUG_ID:
                logger.debug(DEBUG_PREFIX + message, t);
                break;
            case TRACE_ID:
                logger.debug(TRACE_PREFIX + message, t);
                break;
            case ERROR_ID:
                logger.error(ERROR_PREFIX + message, t);
                break;
            default:
                logger.info(message, t);
                break;
        }
    }
    /**
     * Checks to see whether the specified level is enabled.
     * @param level
     * @return True if the specified level is enabled.
     */
    public boolean isLevelEnabled(int level)
    {
        switch (level)
        {
            // For Avalon, no Trace exists. Log at debug level.
            case TRACE_ID:
            case DEBUG_ID:
                return logger.isDebugEnabled();
            case INFO_ID:
                return logger.isInfoEnabled();
            case WARN_ID:
                return logger.isWarnEnabled();
            case ERROR_ID:
                return logger.isErrorEnabled();
            default:
                return true;
        }
    }
    /**
     * Also do a shutdown if the object is destroy()'d.
     * @throws Throwable
     */
    protected void finalize() throws Throwable
    {
        shutdown();
    }
    /** Close all destinations*/
    public void shutdown()
    {
        logger.unsetLogTargets();
    }
}
"
org.apache.velocity.runtime.log.AvalonLogSystem,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * Implementation of a Avalon logger.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: AvalonLogSystem.java 463298 2006-10-12 16:10:32Z henning $
 */
public class AvalonLogSystem extends AvalonLogChute implements LogSystem
{
    /**
     *  @param level
     * @param message
     * @deprecated Use log(level, message).
     */
    public void logVelocityMessage(int level, String message)
    {
        log(level, message);
    }
}
"
org.apache.velocity.runtime.log.CommonsLogLogChute,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.log.LogChute;
/**
 * Redirects Velocity's LogChute messages to commons-logging.
 *
 * <p>To use, first set up commons-logging, then tell Velocity to use
 * this class for logging by adding the following to your velocity.properties:
 *
 * <code>
 * runtime.log.logsystem.class = org.apache.velocity.runtime.log.CommonsLogLogChute
 * </code>
 * </p>
 *
 * <p>You may also set this property to specify what log/name Velocity's
 * messages should be logged to (example below is default).
 * <code>
 * runtime.log.logsystem.commons.logging.name = org.apache.velocity
 * </code>
 * </p>
 * 
 * @author Nathan Bubna
 * @since 1.6
 * @version $Id: CommonsLogLogChute.java 71982 2004-02-18 20:11:07Z nbubna $
 */
public class CommonsLogLogChute implements LogChute
{
    /** Property key for specifying the name for the log instance */
    public static final String LOGCHUTE_COMMONS_LOG_NAME =
        ""runtime.log.logsystem.commons.logging.name"";
    /** Default name for the commons-logging instance */
    public static final String DEFAULT_LOG_NAME = ""org.apache.velocity"";
    /** the commons-logging Log instance */
    protected Log log;
    /********** LogChute methods *************/
    public void init(RuntimeServices rs) throws Exception
    {
        String name = 
            (String)rs.getProperty(LOGCHUTE_COMMONS_LOG_NAME);
        if (name == null)
        {
            name = DEFAULT_LOG_NAME;
        }
        log = LogFactory.getLog(name);
        log(LogChute.DEBUG_ID, ""CommonsLogLogChute name is '"" + name + ""'"");
    }
    /**
     * Send a log message from Velocity.
     */
    public void log(int level, String message)
    {
        switch (level) 
        {
            case LogChute.WARN_ID:
                log.warn(message);
                break;
            case LogChute.INFO_ID:
                log.info(message);
                break;
            case LogChute.TRACE_ID:
                log.trace(message);
                break;
            case LogChute.ERROR_ID:
                log.error(message);
                break;
            case LogChute.DEBUG_ID:
            default:
                log.debug(message);
                break;
        }
    }
    /**
     * Send a log message from Velocity with an error.
     */
    public void log(int level, String message, Throwable t)
    {
        switch (level) 
        {
            case LogChute.WARN_ID:
                log.warn(message, t);
                break;
            case LogChute.INFO_ID:
                log.info(message, t);
                break;
            case LogChute.TRACE_ID:
                log.trace(message, t);
                break;
            case LogChute.ERROR_ID:
                log.error(message, t);
                break;
            case LogChute.DEBUG_ID:
            default:
                log.debug(message, t);
                break;
        }
    }
    /**
     * Checks whether the specified log level is enabled.
     */
    public boolean isLevelEnabled(int level)
    {
        switch (level)
        {
            case LogChute.DEBUG_ID:
                return log.isDebugEnabled();
            case LogChute.INFO_ID:
                return log.isInfoEnabled();
            case LogChute.TRACE_ID:
                return log.isTraceEnabled();
            case LogChute.WARN_ID:
                return log.isWarnEnabled();
            case LogChute.ERROR_ID:
                return log.isErrorEnabled();
            default:
                return true;
        }
    }
}
"
org.apache.velocity.runtime.log.HoldingLogChute,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Vector;
import java.util.Iterator;
import org.apache.velocity.runtime.RuntimeServices;
/**
 *  Pre-init logger.  I believe that this was suggested by
 *  Carsten Ziegeler <cziegeler@sundn.de> and
 *  Jeroen C. van Gelderen.  If this isn't correct, let me
 *  know as this was a good idea...
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:nbubna@apache.org"">Nathan Bubna</a>
 * @version $Id: HoldingLogChute.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
class HoldingLogChute implements LogChute
{
    private Vector pendingMessages = new Vector();
    private volatile boolean transferring = false;
    /**
     * @see org.apache.velocity.runtime.log.LogChute#init(org.apache.velocity.runtime.RuntimeServices)
     */
    public void init(RuntimeServices rs) throws Exception
    {
    }
    /**
     * Logs messages. All we do is store them until 'later'.
     *
     * @param level severity level
     * @param message complete error message
     */
    public synchronized void log(int level, String message)
    {
        if (!transferring)
        {
            Object[] data = new Object[2];
            data[0] = new Integer(level);
            data[1] = message;
            pendingMessages.addElement(data);
        }
    }
    /**
     * Logs messages and errors. All we do is store them until 'later'.
     *
     * @param level severity level
     * @param message complete error message
     * @param t the accompanying java.lang.Throwable
     */
    public synchronized void log(int level, String message, Throwable t)
    {
        if (!transferring)
        {
            Object[] data = new Object[3];
            data[0] = new Integer(level);
            data[1] = message;
            data[2] = t;
            pendingMessages.addElement(data);
        }
    }
    /**
     * @see org.apache.velocity.runtime.log.LogChute#isLevelEnabled(int)
     */
    public boolean isLevelEnabled(int level)
    {
        return true;
    }
    /**
     * Dumps the log messages this chute is holding into a new chute
     * @param newChute
     */
    public synchronized void transferTo(LogChute newChute)
    {
        if (!transferring && !pendingMessages.isEmpty())
        {
            // let the other methods know what's up
            transferring = true;
            // iterate and log each individual message...
            for(Iterator i = pendingMessages.iterator(); i.hasNext();)
            {
                Object[] data = (Object[])i.next();
                int level = ((Integer)data[0]).intValue();
                String message = (String)data[1];
                if (data.length == 2)
                {
                    newChute.log(level, message);
                }
                else
                {
                    newChute.log(level, message, (Throwable)data[2]);
                }
            }
        }
    }
}
"
org.apache.velocity.runtime.log.JdkLogChute,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Implementation of a simple java.util.logging LogChute.
 *
 * @author <a href=""mailto:nbubna@apache.org>Nathan Bubna</a>
 * @version $Id: JdkLogChute.java 703541 2008-10-10 18:09:42Z nbubna $
 * @since 1.5
 */
public class JdkLogChute implements LogChute
{
    /** Property key for specifying the name for the logger instance */
    public static final String RUNTIME_LOG_JDK_LOGGER =
        ""runtime.log.logsystem.jdk.logger"";
    public static final String RUNTIME_LOG_JDK_LOGGER_LEVEL =
        ""runtime.log.logsystem.jdk.logger.level"";
    /** Default name for the JDK logger instance */
    public static final String DEFAULT_LOG_NAME = ""org.apache.velocity"";
    /**
     *
     */
    protected Logger logger = null;
    /**
     * @see org.apache.velocity.runtime.log.LogChute#init(org.apache.velocity.runtime.RuntimeServices)
     */
    public void init(RuntimeServices rs)
    {
        String name = (String)rs.getProperty(RUNTIME_LOG_JDK_LOGGER);
        if (name == null)
        {
            name = DEFAULT_LOG_NAME;
        }
        logger = Logger.getLogger(name);
        /* get and set specified level for this logger, */
        String lvl = rs.getString(RUNTIME_LOG_JDK_LOGGER_LEVEL);
        if (lvl != null)
        {
            Level level = Level.parse(lvl);
            logger.setLevel(level);
            log(LogChute.DEBUG_ID, ""JdkLogChute will use logger '""
                +name+'\''+"" at level '""+level+'\'');
        }
    }
    /**
     * Returns the java.util.logging.Level that matches
     * to the specified LogChute level.
     * @param level
     * @return The current log level of the JDK Logger.
     */
    protected Level getJdkLevel(int level)
    {
        switch (level)
        {
            case LogChute.WARN_ID:
                return Level.WARNING;
            case LogChute.INFO_ID:
                return Level.INFO;
            case LogChute.DEBUG_ID:
                return Level.FINE;
            case LogChute.TRACE_ID:
                return Level.FINEST;
            case LogChute.ERROR_ID:
                return Level.SEVERE;
            default:
                return Level.FINER;
        }
    }
    /**
     * Logs messages
     *
     * @param level severity level
     * @param message complete error message
     */
    public void log(int level, String message)
    {
        log(level, message, null);
    }
    /**
     * Send a log message from Velocity along with an exception or error
     * @param level
     * @param message
     * @param t
     */
    public void log(int level, String message, Throwable t)
    {
        Level jdkLevel = getJdkLevel(level);
        if (t == null)
        {
            logger.log(jdkLevel, message);
        }
        else
        {
            logger.log(jdkLevel, message, t);
        }
    }
    /**
     * @see org.apache.velocity.runtime.log.LogChute#isLevelEnabled(int)
     */
    public boolean isLevelEnabled(int level)
    {
        Level jdkLevel = getJdkLevel(level);
        return logger.isLoggable(jdkLevel);
    }
}
"
org.apache.velocity.runtime.log.Log,"package org.apache.velocity.runtime.log;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.util.introspection.Info;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * Convenient wrapper for LogChute functions. This implements
 * the RuntimeLogger methods (and then some).  It is hoped that
 * use of this will fully replace use of the RuntimeLogger.
 *
 * @author <a href=""mailto:nbubna@apache.org"">Nathan Bubna</a>
 * @version $Id: Log.java 720228 2008-11-24 16:58:33Z nbubna $
 * @since 1.5
 */
public class Log
{
    private LogChute chute;
    /**
     * Creates a new Log that wraps a HoldingLogChute.
     */
    public Log()
    {
        setLogChute(new HoldingLogChute());
    }
    /**
     * Creates a new Log that wraps the specified LogChute.
     * @param chute
     */
    public Log(final LogChute chute)
    {
        setLogChute(chute);
    }
    /**
     * Updates the LogChute wrapped by this Log instance.
     * @param chute The new value for the log chute.
     */
    protected void setLogChute(final LogChute chute)
    {
        if (chute == null)
        {
            throw new NullPointerException(""The LogChute cannot be set to null!"");
        }
        this.chute = chute;
    }
    /**
     * Returns the LogChute wrapped by this Log instance.
     * @return The LogChute wrapped by this Log instance.
     */
    protected LogChute getLogChute()
    {
        return this.chute;
    }
    protected void log(int level, Object message)
    {
        getLogChute().log(level, String.valueOf(message));
    }
    protected void log(int level, Object message, Throwable t)
    {
        getLogChute().log(level, String.valueOf(message), t);
    }
    /**
     * Returns true if trace level messages will be printed by the LogChute.
     * @return If trace level messages will be printed by the LogChute.
     */
    public boolean isTraceEnabled()
    {
        return getLogChute().isLevelEnabled(LogChute.TRACE_ID);
    }
    /**
     * Log a trace message.
     * @param message
     */
    public void trace(Object message)
    {
        log(LogChute.TRACE_ID, message);
    }
    /**
     * Log a trace message and accompanying Throwable.
     * @param message
     * @param t
     */
    public void trace(Object message, Throwable t)
    {
        log(LogChute.TRACE_ID, message, t);
    }
    /**
     * Returns true if debug level messages will be printed by the LogChute.
     * @return True if debug level messages will be printed by the LogChute.
     */
    public boolean isDebugEnabled()
    {
        return getLogChute().isLevelEnabled(LogChute.DEBUG_ID);
    }
    /**
     * Log a debug message.
     * @param message
     */
    public void debug(Object message)
    {
        log(LogChute.DEBUG_ID, message);
    }
    /**
     * Log a debug message and accompanying Throwable.
     * @param message
     * @param t
     */
    public void debug(Object message, Throwable t)
    {
        log(LogChute.DEBUG_ID, message, t);
    }
    /**
     * Returns true if info level messages will be printed by the LogChute.
     * @return True if info level messages will be printed by the LogChute.
     */
    public boolean isInfoEnabled()
    {
        return getLogChute().isLevelEnabled(LogChute.INFO_ID);
    }
    /**
     * Log an info message.
     * @param message
     */
    public void info(Object message)
    {
        log(LogChute.INFO_ID, message);
    }
    /**
     * Log an info message and accompanying Throwable.
     * @param message
     * @param t
     */
    public void info(Object message, Throwable t)
    {
        log(LogChute.INFO_ID, message, t);
    }
    /**
     * Returns true if warn level messages will be printed by the LogChute.
     * @return True if warn level messages will be printed by the LogChute.
     */
    public boolean isWarnEnabled()
    {
        return getLogChute().isLevelEnabled(LogChute.WARN_ID);
    }
    /**
     * Log a warning message.
     * @param message
     */
    public void warn(Object message)
    {
        log(LogChute.WARN_ID, message);
    }
    /**
     * Log a warning message and accompanying Throwable.
     * @param message
     * @param t
     */
    public void warn(Object message, Throwable t)
    {
        log(LogChute.WARN_ID, message, t);
    }
    /**
     * Returns true if error level messages will be printed by the LogChute.
     * @return True if error level messages will be printed by the LogChute.
     */
    public boolean isErrorEnabled()
    {
        return getLogChute().isLevelEnabled(LogChute.ERROR_ID);
    }
    /**
     * Log an error message.
     * @param message
     */
    public void error(Object message)
    {
        log(LogChute.ERROR_ID, message);
    }
    /**
     * Log an error message and accompanying Throwable.
     * @param message
     * @param t
     */
    public void error(Object message, Throwable t)
    {
        log(LogChute.ERROR_ID, message, t);
    }
    /**
     * Creates a string that formats the template filename with line number
     * and column of the given Node. We use this routine to provide a cosistent format for displaying 
     * file errors.
     */
    public static final String formatFileString(Node node)
    {
      return formatFileString(node.getTemplateName(), node.getLine(), node.getColumn());      
    }
    /**
     * Simply creates a string that formats the template filename with line number
     * and column. We use this routine to provide a cosistent format for displaying 
     * file errors.
     */
    public static final String formatFileString(Info info)
    {
        return formatFileString(info.getTemplateName(), info.getLine(), info.getColumn());
    }
    /**
     * Simply creates a string that formats the template filename with line number
     * and column. We use this routine to provide a cosistent format for displaying 
     * file errors.
     * @param template File name of template, can be null
     * @param linenum Line number within the file
     * @param colnum Column number withing the file at linenum
     */
    public static final String formatFileString(String template, int linenum, int colnum)
    {
        if (template == null || template.equals(""""))
        {
            template = ""<unknown template>"";
        }
        return template + ""[line "" + linenum + "", column "" + colnum + ""]"";
    }
}
"
org.apache.velocity.runtime.log.Log4JLogChute,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.lang.reflect.Field;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.apache.log4j.RollingFileAppender;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.ExceptionUtils;
/**
 * Implementation of a simple log4j system that will either latch onto
 * an existing category, or just do a simple rolling file log.
 *
 * @author <a href=""mailto:geirm@apache.org>Geir Magnusson Jr.</a>
 * @author <a href=""mailto:dlr@finemaltcoding.com>Daniel L. Rall</a>
 * @author <a href=""mailto:nbubna@apache.org>Nathan Bubna</a>
 * @version $Id: Log4JLogChute.java 718424 2008-11-17 22:50:43Z nbubna $
 * @since Velocity 1.5
 * @since 1.5
 */
public class Log4JLogChute implements LogChute
{
    public static final String RUNTIME_LOG_LOG4J_LOGGER =
            ""runtime.log.logsystem.log4j.logger"";
    public static final String RUNTIME_LOG_LOG4J_LOGGER_LEVEL =
            ""runtime.log.logsystem.log4j.logger.level"";
    private RuntimeServices rsvc = null;
    private boolean hasTrace = false;
    private RollingFileAppender appender = null;
    /**
     * <a href=""http://jakarta.apache.org/log4j/"">Log4J</a> logging API.
     */
    protected Logger logger = null;
    /**
     * @see org.apache.velocity.runtime.log.LogChute#init(org.apache.velocity.runtime.RuntimeServices)
     */
    public void init(RuntimeServices rs) throws Exception
    {
        rsvc = rs;
        /* first see if there is a category specified and just use that - it allows
         * the application to make us use an existing logger
         */
        String name = (String)rsvc.getProperty(RUNTIME_LOG_LOG4J_LOGGER);
        if (name != null)
        {
            logger = Logger.getLogger(name);
            log(DEBUG_ID, ""Log4JLogChute using logger '"" + name + '\'');
        }
        else
        {
            // create a logger with this class name to avoid conflicts
            logger = Logger.getLogger(this.getClass().getName());
            // if we have a file property, then create a separate
            // rolling file log for velocity messages only
            String file = rsvc.getString(RuntimeConstants.RUNTIME_LOG);
            if (file != null && file.length() > 0)
            {
                initAppender(file);
            }
        }
        /* get and set specified level for this logger */
        String lvl = rsvc.getString(RUNTIME_LOG_LOG4J_LOGGER_LEVEL);
        if (lvl != null)
        {
            Level level = Level.toLevel(lvl);
            logger.setLevel(level);
        }
        /* Ok, now let's see if this version of log4j supports the trace level. */
        try
        {
            Field traceLevel = Level.class.getField(""TRACE"");
            // we'll never get here in pre 1.2.12 log4j
            hasTrace = true;
        }
        catch (NoSuchFieldException e)
        {
            log(DEBUG_ID,
                ""The version of log4j being used does not support the \""trace\"" level."");
        }
    }
    // This tries to create a file appender for the specified file name.
    private void initAppender(String file) throws Exception
    {
        try
        {
            // to add the appender
            PatternLayout layout = new PatternLayout(""%d - %m%n"");
            this.appender = new RollingFileAppender(layout, file, true);
            // if we successfully created the file appender,
            // configure it and set the logger to use only it
            appender.setMaxBackupIndex(1);
            appender.setMaximumFileSize(100000);
            // don't inherit appenders from higher in the logger heirarchy
            logger.setAdditivity(false);
            logger.addAppender(appender);
            log(DEBUG_ID, ""Log4JLogChute initialized using file '""+file+'\'');
        }
        catch (IOException ioe)
        {
            rsvc.getLog().error(""Could not create file appender '""+file+'\'', ioe);
            throw ExceptionUtils.createRuntimeException(""Error configuring Log4JLogChute : "", ioe);
        }
    }
    /**
     *  logs messages
     *
     *  @param level severity level
     *  @param message complete error message
     */
    public void log(int level, String message)
    {
        switch (level)
        {
            case LogChute.WARN_ID:
                logger.warn(message);
                break;
            case LogChute.INFO_ID:
                logger.info(message);
                break;
            case LogChute.TRACE_ID:
                if (hasTrace)
                {
                    logger.trace(message);
                }
                else
                {
                    logger.debug(message);
                }
                break;
            case LogChute.ERROR_ID:
                logger.error(message);
                break;
            case LogChute.DEBUG_ID:
            default:
                logger.debug(message);
                break;
        }
    }
    /**
     * @see org.apache.velocity.runtime.log.LogChute#log(int, java.lang.String, java.lang.Throwable)
     */
    public void log(int level, String message, Throwable t)
    {
        switch (level)
        {
            case LogChute.WARN_ID:
                logger.warn(message, t);
                break;
            case LogChute.INFO_ID:
                logger.info(message, t);
                break;
            case LogChute.TRACE_ID:
                if (hasTrace)
                {
                    logger.trace(message, t);
                }
                else
                {
                    logger.debug(message, t);
                }
                break;
            case LogChute.ERROR_ID:
                logger.error(message, t);
                break;
            case LogChute.DEBUG_ID:
            default:
                logger.debug(message, t);
                break;
        }
    }
    /**
     * @see org.apache.velocity.runtime.log.LogChute#isLevelEnabled(int)
     */
    public boolean isLevelEnabled(int level)
    {
        switch (level)
        {
            case LogChute.DEBUG_ID:
                return logger.isDebugEnabled();
            case LogChute.INFO_ID:
                return logger.isInfoEnabled();
            case LogChute.TRACE_ID:
                if (hasTrace)
                {
                    return logger.isTraceEnabled();
                }
                else
                {
                    return logger.isDebugEnabled();
                }
            case LogChute.WARN_ID:
                return logger.isEnabledFor(Level.WARN);
            case LogChute.ERROR_ID:
                // can't be disabled in log4j
                return logger.isEnabledFor(Level.ERROR);
            default:
                return true;
        }
    }
    /**
     * Also do a shutdown if the object is destroy()'d.
     * @throws Throwable
     */
    protected void finalize() throws Throwable
    {
        shutdown();
    }
    /** Close all destinations*/
    public void shutdown()
    {
        if (appender != null)
        {
            logger.removeAppender(appender);
            appender.close();
            appender = null;
        }
    }
}
"
org.apache.velocity.runtime.log.Log4JLogSystem,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * Implementation of a simple log4j system that will either latch onto
 * an existing category, or just do a simple rolling file log.
 *
 * Use this one rather than {@link SimpleLog4JLogSystem}; it uses the
 * modern <code>Logger</code> concept of Log4J, rather than the
 * deprecated <code>Categeory</code> concept.
 *
 * @author <a href=""mailto:geirm@apache.org>Geir Magnusson Jr.</a>
 * @author <a href=""mailto:dlr@finemaltcoding.com>Daniel L. Rall</a>
 * @author <a href=""mailto:nbubna@apache.org>Nathan Bubna</a>
 * @version $Id: Log4JLogSystem.java 463298 2006-10-12 16:10:32Z henning $
 * @deprecated Use Log4JLogChute instead.
 * @since Velocity 1.5
 */
public class Log4JLogSystem extends Log4JLogChute implements LogSystem
{
    /**
     *  @param level
     * @param message
     * @deprecated Use log(level, message).
     */
    public void logVelocityMessage(int level, String message)
    {
        log(level, message);
    }
}
"
org.apache.velocity.runtime.log.LogChute,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Base interface that logging systems need to implement. This
 * is the blessed descendant of the old LogSystem interface.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:nbubna@apache.org"">Nathan Bubna</a>
 * @version $Id: LogChute.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public interface LogChute
{
    /** Prefix string for trace messages. */
    String TRACE_PREFIX = "" [trace] "";
    /** Prefix string for debug messages. */
    String DEBUG_PREFIX = "" [debug] "";
    /** Prefix string for info messages. */
    String INFO_PREFIX  = ""  [info] "";
    /** Prefix string for warn messages. */
    String WARN_PREFIX  = ""  [warn] "";
    /** Prefix string for error messages. */
    String ERROR_PREFIX = "" [error] "";
    /** ID for trace messages. */
    int TRACE_ID = -1;
    /** ID for debug messages. */
    int DEBUG_ID = 0;
    /** ID for info messages. */
    int INFO_ID = 1;
    /** ID for warning messages. */
    int WARN_ID = 2;
    /** ID for error messages. */
    int ERROR_ID = 3;
    /**
     * Initializes this LogChute.
     * @param rs
     * @throws Exception
     */
    void init(RuntimeServices rs) throws Exception;
    /**
     * Send a log message from Velocity.
     * @param level
     * @param message
     */
    void log(int level, String message);
    /**
     * Send a log message from Velocity along with an exception or error
     * @param level
     * @param message
     * @param t
     */
    void log(int level, String message, Throwable t);
    /**
     * Tell whether or not a log level is enabled.
     * @param level
     * @return True if a level is enabled.
     */
    boolean isLevelEnabled(int level);
}
"
org.apache.velocity.runtime.log.LogChuteSystem,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.StringUtils;
/**
 * Wrapper to make user's custom LogSystem implementations work
 * with the new LogChute setup.
 *
 * @author <a href=""mailto:nbubna@apache.org"">Nathan Bubna</a>
 * @version $Id: LogChuteSystem.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class LogChuteSystem implements LogChute
{
    private LogSystem logSystem;
    /**
     * Only classes in this package should be creating this.
     * Users should not have to mess with this class.
     * @param wrapMe
     */
    protected LogChuteSystem(LogSystem wrapMe)
    {
        this.logSystem = wrapMe;
    }
    /**
     * @see org.apache.velocity.runtime.log.LogChute#init(org.apache.velocity.runtime.RuntimeServices)
     */
    public void init(RuntimeServices rs) throws Exception
    {
        logSystem.init(rs);
    }
    /**
     * @see org.apache.velocity.runtime.log.LogChute#log(int, java.lang.String)
     */
    public void log(int level, String message)
    {
        logSystem.logVelocityMessage(level, message);
    }
    /**
     * First passes off the message at the specified level,
     * then passes off stack trace of the Throwable as a
     * 2nd message at the same level.
     * @param level
     * @param message
     * @param t
     */
    public void log(int level, String message, Throwable t)
    {
        logSystem.logVelocityMessage(level, message);
        logSystem.logVelocityMessage(level, StringUtils.stackTrace(t));
    }
    /**
     * @see org.apache.velocity.runtime.log.LogChute#isLevelEnabled(int)
     */
    public boolean isLevelEnabled(int level)
    {
        return true;
    }
}
"
org.apache.velocity.runtime.log.LogDisplayWrapper,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * This is a wrapper around a log object, that can add a prefix to log messages
 * and also turn logging on and off dynamically. It is mainly used to control the
 * logging of VelociMacro generation messages but is actually generic enough code.
 *
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: LogDisplayWrapper.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class LogDisplayWrapper
        extends Log
{
    /** The prefix to record with every log message */
    private final String prefix;
    /** log messages only if true */
    private final boolean outputMessages;
    /** The Log object we wrap */
    private final Log log;
    /**
     * Create a new LogDisplayWrapper
     * @param log The Log object to wrap.
     * @param prefix The prefix to record with all messages.
     * @param outputMessages True when messages should actually get logged.
     */
    public LogDisplayWrapper(final Log log, final String prefix, final boolean outputMessages)
    {
        super(log.getLogChute());
        this.log = log;
        this.prefix = prefix;
        this.outputMessages = outputMessages;
    }
    /**
     * make sure that we always use the right LogChute Object
     */
    protected LogChute getLogChute()
    {
        return log.getLogChute();
    }
    /**
     * @see Log#log(int, Object)
     */
    protected void log(final int level, final Object message)
    {
    	log(outputMessages, level, message);
    }
    protected void log(final boolean doLogging, final int level, final Object message)
    {
        if (doLogging)
        {
            getLogChute().log(level, prefix + String.valueOf(message));
        }
    }
    /**
     * @see Log#log(int, Object, Throwable)
     */
    protected void log(final int level, final Object message, final Throwable t)
    {
    	log(outputMessages, level, message);
    }
    protected void log(final boolean doLogging, final int level, final Object message, final Throwable t)
    {
        if (doLogging)
        {
            getLogChute().log(level, prefix + String.valueOf(message), t);
        }
    }
    /**
     * Log a trace message.
     * @param doLogging Log only if this parameter is true.
     * @param message
     */
    public void trace(final boolean doLogging, final Object message)
    {
        log(doLogging, LogChute.TRACE_ID, message);
    }
    /**
     * Log a trace message and accompanying Throwable.
     * @param doLogging Log only if this parameter is true.
     * @param message
     * @param t
     */
    public void trace(final boolean doLogging, final Object message, final Throwable t)
    {
        log(doLogging, LogChute.TRACE_ID, message, t);
    }
    /**
     * Log a debug message.
     * @param doLogging Log only if this parameter is true.
     * @param message
     */
    public void debug(final boolean doLogging, final Object message)
    {
        log(doLogging, LogChute.DEBUG_ID, message);
    }
    /**
     * Log a debug message and accompanying Throwable.
     * @param doLogging Log only if this parameter is true.
     * @param message
     * @param t
     */
    public void debug(final boolean doLogging, final Object message, final Throwable t)
    {
        log(doLogging, LogChute.DEBUG_ID, message, t);
    }
    /**
     * Log an info message.
     * @param doLogging Log only if this parameter is true.
     * @param message
     */
    public void info(final boolean doLogging, final Object message)
    {
        log(doLogging, LogChute.INFO_ID, message);
    }
    /**
     * Log an info message and accompanying Throwable.
     * @param doLogging Log only if this parameter is true.
     * @param message
     * @param t
     */
    public void info(final boolean doLogging, final Object message, final Throwable t)
    {
        log(doLogging, LogChute.INFO_ID, message, t);
    }
    /**
     * Log a warning message.
     * @param doLogging Log only if this parameter is true.
     * @param message
     */
    public void warn(final boolean doLogging, final Object message)
    {
        log(doLogging, LogChute.WARN_ID, message);
    }
    /**
     * Log a warning message and accompanying Throwable.
     * @param doLogging Log only if this parameter is true.
     * @param message
     * @param t
     */
    public void warn(final boolean doLogging, final Object message, final Throwable t)
    {
        log(doLogging, LogChute.WARN_ID, message, t);
    }
    /**
     * Log an error message.
     * @param doLogging Log only if this parameter is true.
     * @param message
     */
    public void error(final boolean doLogging, final Object message)
    {
        log(doLogging, LogChute.ERROR_ID, message);
    }
    /**
     * Log an error message and accompanying Throwable.
     * @param doLogging Log only if this parameter is true.
     * @param message
     * @param t
     */
    public void error(final boolean doLogging, final Object message, final Throwable t)
    {
        log(doLogging, LogChute.ERROR_ID, message, t);
    }
}
"
org.apache.velocity.runtime.log.LogManager,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.util.ClassUtils;
/**
 * <p>
 * This class is responsible for instantiating the correct LogChute
 * </p>
 *
 * <p>
 * The approach is :
 * </p>
 * <ul>
 * <li>
 *      First try to see if the user is passing in a living object
 *      that is a LogChute, allowing the app to give its living
 *      custom loggers.
 *  </li>
 *  <li>
 *       Next, run through the (possible) list of classes specified
 *       specified as loggers, taking the first one that appears to
 *       work.  This is how we support finding logkit, log4j or
 *       jdk logging, whichever is in the classpath and found first,
 *       as all three are listed as defaults.
 *  </li>
 *  <li>
 *      Finally, we turn to the System.err stream and print log messages
 *      to it if nothing else works.
 *  </li>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:nbubna@apache.org"">Nathan Bubna</a>
 * @version $Id: LogManager.java 699307 2008-09-26 13:16:05Z cbrisson $
 */
public class LogManager
{
    // Creates a new logging system or returns an existing one
    // specified by the application.
    private static LogChute createLogChute(RuntimeServices rsvc) throws Exception
    {
        Log log = rsvc.getLog();
        /* If a LogChute or LogSystem instance was set as a configuration
         * value, use that.  This is any class the user specifies.
         */
        Object o = rsvc.getProperty(RuntimeConstants.RUNTIME_LOG_LOGSYSTEM);
        if (o != null)
        {
            // first check for a LogChute
            if (o instanceof LogChute)
            {
                try
                {
                    ((LogChute)o).init(rsvc);
                    return (LogChute)o;
                }
                catch (Exception e)
                {
                    String msg = ""Could not init runtime.log.logsystem "" + o;
                    log.error(msg, e);
                    throw new VelocityException(msg, e);
                }
            }
            // then check for a LogSystem
            else if (o instanceof LogSystem)
            {
                // inform the user about the deprecation
                log.debug(""LogSystem has been deprecated. Please use a LogChute implementation."");
                try
                {
                    // wrap the LogSystem into a chute.
                    LogChute chute = new LogChuteSystem((LogSystem)o);
                    chute.init(rsvc);
                    return chute;
                }
                catch (Exception e)
                {
                    String msg = ""Could not init runtime.log.logsystem "" + o;
                    log.error(msg, e);
                    throw new VelocityException(msg, e);
                }
            }
            else
            {
                String msg = o.getClass().getName() + "" object set as runtime.log.logsystem is not a valid log implementation."";
                log.error(msg);
                throw new VelocityException(msg);
            }
        }
        /* otherwise, see if a class was specified.  You can put multiple
         * classes, and we use the first one we find.
         *
         * Note that the default value of this property contains the
         * AvalonLogChute, the Log4JLogChute, CommonsLogLogChute,
         * ServletLogChute, and the JdkLogChute for
         * convenience - so we use whichever we works first.
         */
        List classes = new ArrayList();
        Object obj = rsvc.getProperty( RuntimeConstants.RUNTIME_LOG_LOGSYSTEM_CLASS );
        /*
         *  we might have a list, or not - so check
         */
        if ( obj instanceof List)
        {
            classes = (List) obj;
        }
        else if ( obj instanceof String)
        {
            classes.add( obj );
        }
        /*
         *  now run through the list, trying each.  It's ok to
         *  fail with a class not found, as we do this to also
         *  search out a default simple file logger
         */
        for( Iterator ii = classes.iterator(); ii.hasNext(); )
        {
            String claz = (String) ii.next();
            if (claz != null && claz.length() > 0 )
            {
                log.debug(""Trying to use logger class "" + claz );
                try
                {
                    o = ClassUtils.getNewInstance( claz );
                    if (o instanceof LogChute)
                    {
                        ((LogChute)o).init(rsvc);
                        log.debug(""Using logger class "" + claz);
                        return (LogChute)o;
                    }
                    else if (o instanceof LogSystem)
                    {
                        // inform the user about the deprecation
                        log.debug(""LogSystem has been deprecated. Please use a LogChute implementation."");
                        LogChute chute = new LogChuteSystem((LogSystem)o);
                        chute.init(rsvc);
                        return chute;
                    }
                    else
                    {
                        String msg = ""The specified logger class "" + claz +
                                     "" does not implement the ""+LogChute.class.getName()+"" interface."";
                        log.error(msg);
                        // be extra informative if it appears to be a classloader issue
                        // this should match all our provided LogChutes
                        if (isProbablyProvidedLogChute(claz))
                        {
                            // if it's likely to be ours, tip them off about classloader stuff
                            log.error(""This appears to be a ClassLoader issue.  Check for multiple Velocity jars in your classpath."");
                        }
                        throw new VelocityException(msg);
                    }
                }
                catch(NoClassDefFoundError ncdfe)
                {
                    // note these errors for anyone debugging the app
                    if (isProbablyProvidedLogChute(claz))
                    {
                        log.debug(""Target log system for "" + claz +
                                  "" is not available ("" + ncdfe.toString() +
                                  "").  Falling back to next log system..."");
                    }
                    else
                    {
                        log.debug(""Couldn't find class "" + claz +
                                  "" or necessary supporting classes in classpath."",
                                  ncdfe);
                    }
                }
                catch(Exception e)
                {
                    String msg = ""Failed to initialize an instance of "" + claz +
                                 "" with the current runtime configuration."";
                    // log unexpected init exception at higher priority
                    log.error(msg, e);
                    throw new VelocityException(msg,e);
                }
            }
        }
        /* If the above failed, that means either the user specified a
         * logging class that we can't find, there weren't the necessary
         * dependencies in the classpath for it, or there were the same
         * problems for the default loggers, log4j and Java1.4+.
         * Since we really don't know and we want to be sure the user knows
         * that something went wrong with the logging, let's fall back to the
         * surefire SystemLogChute. No panicking or failing to log!!
         */
        LogChute slc = new SystemLogChute();
        slc.init(rsvc);
        log.debug(""Using SystemLogChute."");
        return slc;
    }
    /**
     * Simply tells whether the specified classname probably is provided
     * by Velocity or is implemented by someone else.  Not surefire, but
     * it'll probably always be right.  In any case, this method shouldn't
     * be relied upon for anything important.
     */
    private static boolean isProbablyProvidedLogChute(String claz)
    {
        if (claz == null)
        {
            return false;
        }
        else
        {
            return (claz.startsWith(""org.apache.velocity.runtime.log"")
                    && claz.endsWith(""LogChute""));
        }
    }
    /**
     * Update the Log instance with the appropriate LogChute and other
     * settings determined by the RuntimeServices.
     * @param log
     * @param rsvc
     * @throws Exception
     * @since 1.5
     */
    public static void updateLog(Log log, RuntimeServices rsvc) throws Exception
    {
        // create a new LogChute using the RuntimeServices
        LogChute newLogChute = createLogChute(rsvc);
        LogChute oldLogChute = log.getLogChute();
        // pass the new LogChute to the log first,
        // (if the old was a HoldingLogChute, we don't want it
        //  to accrue new messages during the transfer below)
        log.setLogChute(newLogChute);
        // If the old LogChute was the pre-Init logger,
        // dump its messages into the new system.
        if (oldLogChute instanceof HoldingLogChute)
        {
            HoldingLogChute hlc = (HoldingLogChute)oldLogChute;
            hlc.transferTo(newLogChute);
        }
    }
}
"
org.apache.velocity.runtime.log.LogSystem,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Old base interface that old logging systems needed to implement.
 *
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @deprecated Use LogChute instead!
 * @version $Id: LogSystem.java 463298 2006-10-12 16:10:32Z henning $
 */
public interface LogSystem
{
    /**
     * @deprecated This is unused and meaningless
     */
    public final static boolean DEBUG_ON = true;
    /**
     * ID for debug messages.
     */
    public final static int DEBUG_ID = 0;
    /**
     * ID for info messages.
     */
    public final static int INFO_ID = 1;
    /**
     * ID for warning messages.
     */
    public final static int WARN_ID = 2;
    /**
     * ID for error messages.
     */
    public final static int ERROR_ID = 3;
    /**
     * Initializes this LogSystem.
     * @param rs
     * @throws Exception
     */
    public void init( RuntimeServices rs ) throws Exception;
    /**
     * @param level
     * @param message
     * @deprecated Use log(level, message).
     */
    public void logVelocityMessage(int level, String message);
}
"
org.apache.velocity.runtime.log.NullLogChute,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.RuntimeServices;
/**
 *  Logger used in case of failure. Does nothing.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:nbubna@optonline.net"">Nathan Bubna.</a>
 * @version $Id: NullLogChute.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class NullLogChute implements LogChute
{
    /**
     * @see org.apache.velocity.runtime.log.LogChute#init(org.apache.velocity.runtime.RuntimeServices)
     */
    public void init(RuntimeServices rs) throws Exception
    {
    }
    /**
     * logs messages to the great Garbage Collector in the sky
     *
     *  @param level severity level
     *  @param message complete error message
     */
    public void log(int level, String message)
    {
    }
    /**
     * logs messages and their accompanying Throwables
     * to the great Garbage Collector in the sky
     *
     * @param level severity level
     * @param message complete error message
     * @param t the java.lang.Throwable
     */
    public void log(int level, String message, Throwable t)
    {
    }
    /**
     * @see org.apache.velocity.runtime.log.LogChute#isLevelEnabled(int)
     */
    public boolean isLevelEnabled(int level)
    {
        return false;
    }
}
"
org.apache.velocity.runtime.log.NullLogSystem,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Logger used in case of failure. Does nothing.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @deprecated Use NullLogChute.
 * @version $Id: NullLogSystem.java 463298 2006-10-12 16:10:32Z henning $
 */
public class NullLogSystem extends NullLogChute implements LogSystem
{
    /**
     *  @param level
     * @param message
     * @deprecated Use log(level, message).
     */
    public void logVelocityMessage(int level, String message)
    {
    }
}
"
org.apache.velocity.runtime.log.PrimordialLogSystem,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Pre-init logger.  I believe that this was suggested by
 *  Carsten Ziegeler <cziegeler@sundn.de> and
 *  Jeroen C. van Gelderen.  If this isn't correct, let me
 *  know as this was a good idea...
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: PrimordialLogSystem.java 463298 2006-10-12 16:10:32Z henning $
 * @deprecated Use HoldingLogChute instead!
 */
public class PrimordialLogSystem extends HoldingLogChute implements LogSystem
{
    /**
     * @param level
     * @param message
     * @deprecated Use log(level, message).
     */
    public void logVelocityMessage(int level, String message)
    {
        log(level, message);
    }
    /**
     * @param newLogger
     * @deprecated use transferTo(LogChute newChute)
     */
    public void dumpLogMessages( LogSystem newLogger )
    {
        transferTo(new LogChuteSystem(newLogger));
    }
}
"
org.apache.velocity.runtime.log.RuntimeLoggerLog,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.RuntimeLogger;
/**
 * A temporary RuntimeLogger wrapper to make the deprecation
 * of UberspectLoggable.setRuntimeLogger(RuntimeLogger) feasible.
 * This overrides all Log methods, either throwing
 * UnsupportedOperationExceptions or passing things off to the
 * theoretical RuntimeLogger used to create it.  Oh, and all the
 * is<Level>Enabled() methods return true.  Of course, ideally
 * there is no one out there who actually created their own
 * RuntimeLogger instance to use with UberspectLoggable.setRuntimeLogger()
 * and this class will therefore never be used.  But it's here just in case.
 *
 * @author <a href=""mailto:nbubna@apache.org"">Nathan Bubna</a>
 * @version $Id: RuntimeLoggerLog.java 685685 2008-08-13 21:43:27Z nbubna $
 * @deprecated This will be removed along with the RuntimeLogger interface.
 * @since 1.5
 */
public class RuntimeLoggerLog extends Log
{
    private RuntimeLogger rlog;
    /**
     * Creates a new Log that wraps a PrimordialLogChute.
     * @param rlog
     */
    public RuntimeLoggerLog(RuntimeLogger rlog)
    {
        if (rlog == null)
        {
            throw new NullPointerException(""RuntimeLogger cannot be null!"");
        }
        this.rlog = rlog;
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#setLogChute(org.apache.velocity.runtime.log.LogChute)
     */
    protected void setLogChute(LogChute newLogChute)
    {
        throw new UnsupportedOperationException(""RuntimeLoggerLog does not support this method."");
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#getLogChute()
     */
    protected LogChute getLogChute()
    {
        throw new UnsupportedOperationException(""RuntimeLoggerLog does not support this method."");
    }
    /**
     * @param showStacks
     */
    protected void setShowStackTraces(boolean showStacks)
    {
        throw new UnsupportedOperationException(""RuntimeLoggerLog does not support this method."");
    }
    /**
     * @return True if Stack traces should be shown.
     */
    public boolean getShowStackTraces()
    {
        throw new UnsupportedOperationException(""RuntimeLoggerLog does not support this method."");
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#isTraceEnabled()
     */
    public boolean isTraceEnabled()
    {
        return true;
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#trace(java.lang.Object)
     */
    public void trace(Object message)
    {
        debug(message);
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#trace(java.lang.Object, java.lang.Throwable)
     */
    public void trace(Object message, Throwable t)
    {
        debug(message, t);
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#isDebugEnabled()
     */
    public boolean isDebugEnabled()
    {
        return true;
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#debug(java.lang.Object)
     */
    public void debug(Object message)
    {
        rlog.debug(message);
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#debug(java.lang.Object, java.lang.Throwable)
     */
    public void debug(Object message, Throwable t)
    {
        rlog.debug(message);
        rlog.debug(t);
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#isInfoEnabled()
     */
    public boolean isInfoEnabled()
    {
        return true;
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#info(java.lang.Object)
     */
    public void info(Object message)
    {
        rlog.info(message);
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#info(java.lang.Object, java.lang.Throwable)
     */
    public void info(Object message, Throwable t)
    {
        rlog.info(message);
        rlog.info(t);
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#isWarnEnabled()
     */
    public boolean isWarnEnabled()
    {
        return true;
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#warn(java.lang.Object)
     */
    public void warn(Object message)
    {
        rlog.warn(message);
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#warn(java.lang.Object, java.lang.Throwable)
     */
    public void warn(Object message, Throwable t)
    {
        rlog.warn(message);
        rlog.warn(t);
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#isErrorEnabled()
     */
    public boolean isErrorEnabled()
    {
        return true;
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#error(java.lang.Object)
     */
    public void error(Object message)
    {
        rlog.error(message);
    }
    /**
     * @see org.apache.velocity.runtime.log.Log#error(java.lang.Object, java.lang.Throwable)
     */
    public void error(Object message, Throwable t)
    {
        rlog.error(message);
        rlog.error(t);
    }
}
"
org.apache.velocity.runtime.log.ServletLogChute,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.io.StringWriter;
import java.io.PrintWriter;
import javax.servlet.ServletContext;
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Simple wrapper for the servlet log.  This passes Velocity log
 * messages to ServletContext.log(String).  You may configure the
 * level of output in your velocity.properties by adding the
 * ""runtime.log.logsystem.servlet.level"" property with one of the
 * following values: error, warn, info, debug, or trace.  The default
 * is trace.
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @author Nathan Bubna
 * @version $Revision: 685685 $ $Date: 2008-08-13 14:43:27 -0700 (Wed, 13 Aug 2008) $
 * @since 1.6
 */
public class ServletLogChute implements LogChute
{
    public static final String RUNTIME_LOG_LEVEL_KEY = 
        ""runtime.log.logsystem.servlet.level"";
    private int enabled = TRACE_ID;
    protected ServletContext servletContext = null;
    public static final String PREFIX = "" Velocity "";
    /**
     * Construct a simple logger for a servlet environment.
     * <br>
     * NOTE: this class expects that the ServletContext has already
     *       been placed in the runtime's application attributes
     *       under its full class name (i.e. ""javax.servlet.ServletContext"").
     */
    public ServletLogChute()
    {
    }
    /**
     * init()
     *
     * @throws IllegalStateException if the ServletContext is not available
     *         in the application attributes under the appropriate key.
     */
    public void init(RuntimeServices rs) throws Exception
    {
        Object obj = rs.getApplicationAttribute(ServletContext.class.getName());
        if (obj == null)
        {
            throw new UnsupportedOperationException(""Could not retrieve ServletContext from application attributes"");
        }
        servletContext = (ServletContext)obj;
        // look for a level config property
        String level = (String)rs.getProperty(RUNTIME_LOG_LEVEL_KEY);
        if (level != null)
        {
            // and set it accordingly
            setEnabledLevel(toLevel(level));
        }
    }
    protected int toLevel(String level) {
        if (level.equalsIgnoreCase(""debug""))
        {
            return DEBUG_ID;
        }
        else if (level.equalsIgnoreCase(""info""))
        {
            return INFO_ID;
        }
        else if (level.equalsIgnoreCase(""warn""))
        {
            return WARN_ID;
        }
        else if (level.equalsIgnoreCase(""error""))
        {
            return ERROR_ID;
        }
        else
        {
            return TRACE_ID;
        }
    }
    /**
     * Set the minimum level at which messages will be printed.
     */
    public void setEnabledLevel(int level)
    {
        this.enabled = level;
    }
    /**
     * Returns the current minimum level at which messages will be printed.
     */
    public int getEnabledLevel()
    {
        return this.enabled;
    }
    /**
     * This will return true if the specified level
     * is equal to or higher than the level this
     * LogChute is enabled for.
     */
    public boolean isLevelEnabled(int level)
    {
        return (level >= this.enabled);
    }
    /**
     * Send a log message from Velocity.
     */
    public void log(int level, String message)
    {
        if (!isLevelEnabled(level))
        {
            return;
        }
        switch (level)
        {
            case WARN_ID:
                servletContext.log(PREFIX + WARN_PREFIX + message);
                break;
            case INFO_ID:
                servletContext.log(PREFIX + INFO_PREFIX + message);
                break;
            case DEBUG_ID:
                servletContext.log(PREFIX + DEBUG_PREFIX + message);
                break;
            case TRACE_ID:
                servletContext.log(PREFIX + TRACE_PREFIX + message);
                break;
            case ERROR_ID:
                servletContext.log(PREFIX + ERROR_PREFIX + message);
                break;
            default:
                servletContext.log(PREFIX + "" : "" + message);
                break;
        }
    }
    public void log(int level, String message, Throwable t)
    {
        if (!isLevelEnabled(level))
        {
            return;
        }
        message += "" - ""+t.toString();
        if (level >= ERROR_ID)
        {
            StringWriter sw = new StringWriter();
            t.printStackTrace(new PrintWriter(sw));
            message += ""\n"" + sw.toString();
        }
        log(level, message);
    }
}
"
org.apache.velocity.runtime.log.SimpleLog4JLogSystem,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.log4j.Category;
import org.apache.log4j.Level;
import org.apache.log4j.PatternLayout;
import org.apache.log4j.RollingFileAppender;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
/**
 * <p><em>This class is deprecated in favor of the new {@link Log4JLogChute},
 * which makes use of Log4J's <code>Logger</code> rather than its deprecated
 * <code>Category</code> class.</em></p>
 *
 *  Implementation of a simple log4j system that will either
 *  latch onto an existing category, or just do a simple
 *  rolling file log.  Derived from Jon's 'complicated'
 *  version :)
 *
 * @author <a href=""mailto:geirm@apache.org>Geir Magnusson Jr.</a>
 * @version $Id: SimpleLog4JLogSystem.java 718424 2008-11-17 22:50:43Z nbubna $
 * @deprecated Use Log4JLogChute instead.
 */
public class SimpleLog4JLogSystem implements LogSystem
{
    private RuntimeServices rsvc = null;
    private RollingFileAppender appender = null;
    /** log4java logging interface */
    protected Category logger = null;
    /**
     *
     */
    public SimpleLog4JLogSystem()
    {
    }
    /**
     * @see org.apache.velocity.runtime.log.LogSystem#init(org.apache.velocity.runtime.RuntimeServices)
     */
    public void init( RuntimeServices rs )
    {
        rsvc = rs;
        /*
         *  first see if there is a category specified and just use that - it allows
         *  the application to make us use an existing logger
         */
        String categoryname =  (String) rsvc.getProperty(""runtime.log.logsystem.log4j.category"");
        if ( categoryname != null )
        {
            logger = Category.getInstance( categoryname );
            logVelocityMessage( 0,
                                ""SimpleLog4JLogSystem using category '"" + categoryname + ""'"");
            return;
        }
        /*
         *  if not, use the file...
         */
        String logfile = rsvc.getString( RuntimeConstants.RUNTIME_LOG );
        /*
         *  now init.  If we can't, panic!
         */
        try
        {
            internalInit( logfile );
            logVelocityMessage( 0,
                ""SimpleLog4JLogSystem initialized using logfile '"" + logfile + ""'"" );
        }
        catch( Exception e )
        {
            System.err.println(
                ""PANIC : error configuring SimpleLog4JLogSystem : "" + e );
        }
    }
    /**
     *  initializes the log system using the logfile argument
     */
    private void internalInit( String logfile )
        throws Exception
    {
        /*
         *  do it by our classname to avoid conflicting with anything else
         *  that might be used...
         */
        logger = Category.getInstance(this.getClass().getName());
        logger.setAdditivity(false);
        /*
         * Priority is set for DEBUG becouse this implementation checks
         * log level.
         */
        logger.setLevel(Level.DEBUG);
        appender = new RollingFileAppender( new PatternLayout( ""%d - %m%n""), logfile, true);
        appender.setMaxBackupIndex( 1 );
        appender.setMaximumFileSize( 100000 );
        logger.addAppender(appender);
    }
    /**
     *  logs messages
     *
     *  @param level severity level
     *  @param message complete error message
     */
    public void logVelocityMessage(int level, String message)
    {
        switch (level)
        {
            case LogSystem.WARN_ID:
                logger.warn( message );
                break;
            case LogSystem.INFO_ID:
                logger.info(message);
                break;
            case LogSystem.ERROR_ID:
                logger.error(message);
                break;
            case LogSystem.DEBUG_ID:
            default:
                logger.debug(message);
                break;
        }
    }
    /**
     * Also do a shutdown if the object is destroy()'d.
     * @throws Throwable
     */
    protected void finalize() throws Throwable
    {
        shutdown();
    }
    /** Close all destinations*/
    public void shutdown()
    {
        if (appender != null)
        {
            logger.removeAppender(appender);
            appender.close();
            appender = null;
        }
    }
}
"
org.apache.velocity.runtime.log.SystemLogChute,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.PrintStream;
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Logger used when no other is configured.  By default, all messages
 * will be printed to the System.err output stream.
 *
 * @author <a href=""mailto:nbubna@apache.org"">Nathan Bubna</a>
 * @version $Id: SystemLogChute.java 718424 2008-11-17 22:50:43Z nbubna $
 * @since 1.5
 */
public class SystemLogChute implements LogChute
{
    public static final String RUNTIME_LOG_LEVEL_KEY = 
        ""runtime.log.logsystem.system.level"";
    public static final String RUNTIME_LOG_SYSTEM_ERR_LEVEL_KEY = 
        ""runtime.log.logsystem.system.err.level"";
    private int enabled = WARN_ID;
    private int errLevel = TRACE_ID;
    public void init(RuntimeServices rs) throws Exception
    {
        // look for a level config property
        String level = (String)rs.getProperty(RUNTIME_LOG_LEVEL_KEY);
        if (level != null)
        {
            // and set it accordingly
            setEnabledLevel(toLevel(level));
        }
        // look for an errLevel config property
        String errLevel = (String)rs.getProperty(RUNTIME_LOG_SYSTEM_ERR_LEVEL_KEY);
        if (errLevel != null)
        {
            setSystemErrLevel(toLevel(errLevel));
        }
    }
    protected int toLevel(String level) {
        if (level.equalsIgnoreCase(""debug""))
        {
            return DEBUG_ID;
        }
        else if (level.equalsIgnoreCase(""info""))
        {
            return INFO_ID;
        }
        else if (level.equalsIgnoreCase(""warn""))
        {
            return WARN_ID;
        }
        else if (level.equalsIgnoreCase(""error""))
        {
            return ERROR_ID;
        }
        else
        {
            return TRACE_ID;
        }
    }
    protected String getPrefix(int level)
    {
        switch (level)
        {
            case WARN_ID:
                return WARN_PREFIX;
            case DEBUG_ID:
                return DEBUG_PREFIX;
            case TRACE_ID:
                return TRACE_PREFIX;
            case ERROR_ID:
                return ERROR_PREFIX;
            case INFO_ID:
            default:
                return INFO_PREFIX;
        }
    }
    /**
     * Logs messages to either std.out or std.err
     * depending on their severity.
     *
     * @param level severity level
     * @param message complete error message
     */
    public void log(int level, String message)
    {
        // pass it off
        log(level, message, null);
    }
    /**
     * Logs messages to the system console so long as the specified level
     * is equal to or greater than the level this LogChute is enabled for.
     * If the level is equal to or greater than LogChute.ERROR_ID, 
     * messages will be printed to System.err. Otherwise, they will be 
     * printed to System.out. If a java.lang.Throwable accompanies the 
     * message, it's stack trace will be printed to the same stream
     * as the message.
     *
     * @param level severity level
     * @param message complete error message
     * @param t the java.lang.Throwable
     */
    public void log(int level, String message, Throwable t)
    {
        if (!isLevelEnabled(level))
        {
            return;
        }
        String prefix = getPrefix(level);
        if (level >= this.errLevel)
        {
            write(System.err, prefix, message, t);
        }
        else
        {
            write(System.out, prefix, message, t);
        }
    }
    protected void write(PrintStream stream, String prefix, String message, Throwable t)
    {
        stream.print(prefix);
        stream.println(message);
        if (t != null)
        {
            stream.println(t.getMessage());
            t.printStackTrace(stream);
        }
    }
    /**
     * Set the minimum level at which messages will be printed.
     */
    public void setEnabledLevel(int level)
    {
        this.enabled = level;
    }
    /**
     * Returns the current minimum level at which messages will be printed.
     */
    public int getEnabledLevel()
    {
        return this.enabled;
    }
    /**
     * Set the minimum level at which messages will be printed to System.err
     * instead of System.out.
     */
    public void setSystemErrLevel(int level)
    {
        this.errLevel = level;
    }
    /**
     * Returns the current minimum level at which messages will be printed
     * to System.err instead of System.out.
     */
    public int getSystemErrLevel()
    {
        return this.errLevel;
    }
    /**
     * This will return true if the specified level
     * is equal to or higher than the level this
     * LogChute is enabled for.
     */
    public boolean isLevelEnabled(int level)
    {
        return (level >= this.enabled);
    }
}
"
org.apache.velocity.runtime.log.VelocityFormatter,"package org.apache.velocity.runtime.log;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Date;
import org.apache.log.format.PatternFormatter;
/**
 *
 */
public class VelocityFormatter extends PatternFormatter
{
    /**
     * @param format
     */
    public VelocityFormatter( String format )
    {
	super( format );
    }
    /**
     * Utility method to format time.
     *
     * @param time the time
     * @param format ancilliary format parameter - allowed to be null
     * @return the formatted string
     */
    protected String getTime( final long time, final String format )
    {
        return new Date().toString();
    }
}
"
org.apache.velocity.runtime.parser.CharStream,"/* Generated By:JavaCC: Do not edit this line. CharStream.java Version 2.1 */
package org.apache.velocity.runtime.parser;
/**
 * This interface describes a character stream that maintains line and
 * column number positions of the characters.  It also has the capability
 * to backup the stream to some extent.  An implementation of this
 * interface is used in the TokenManager implementation generated by
 * JavaCCParser.
 *
 * All the methods except backup can be implemented in any fashion. backup
 * needs to be implemented correctly for the correct operation of the lexer.
 * Rest of the methods are all used to get information like line number,
 * column number and the String that constitutes a token and are not used
 * by the lexer. Hence their implementation won't affect the generated lexer's
 * operation.
 */
public interface CharStream {
  /**
   * Returns the next character from the selected input.  The method
   * of selecting the input is the responsibility of the class
   * implementing this interface.  Can throw any java.io.IOException.
   */
  char readChar() throws java.io.IOException;
  /**
   * Returns the column position of the character last read.
   * @deprecated 
   * @see #getEndColumn
   */
  int getColumn();
  /**
   * Returns the line number of the character last read.
   * @deprecated 
   * @see #getEndLine
   */
  int getLine();
  /**
   * Returns the column number of the last character for current token (being
   * matched after the last call to BeginTOken).
   */
  int getEndColumn();
  /**
   * Returns the line number of the last character for current token (being
   * matched after the last call to BeginTOken).
   */
  int getEndLine();
  /**
   * Returns the column number of the first character for current token (being
   * matched after the last call to BeginTOken).
   */
  int getBeginColumn();
  /**
   * Returns the line number of the first character for current token (being
   * matched after the last call to BeginTOken).
   */
  int getBeginLine();
  /**
   * Backs up the input stream by amount steps. Lexer calls this method if it
   * had already read some characters, but could not use them to match a
   * (longer) token. So, they will be used again as the prefix of the next
   * token and it is the implemetation's responsibility to do this right.
   */
  void backup(int amount);
  /**
   * Returns the next character that marks the beginning of the next token.
   * All characters must remain in the buffer between two successive calls
   * to this method to implement backup correctly.
   */
  char BeginToken() throws java.io.IOException;
  /**
   * Returns a string made up of characters from the marked token beginning 
   * to the current buffer position. Implementations have the choice of returning
   * anything that they want to. For example, for efficiency, one might decide
   * to just return null, which is a valid implementation.
   */
  String GetImage();
  /**
   * Returns an array of characters that make up the suffix of length 'len' for
   * the currently matched token. This is used to build up the matched string
   * for use in actions in the case of MORE. A simple and inefficient
   * implementation of this is as follows :
   *
   *   {
   *      String t = GetImage();
   *      return t.substring(t.length() - len, t.length()).toCharArray();
   *   }
   */
  char[] GetSuffix(int len);
  /**
   * The lexer calls this function to indicate that it is done with the stream
   * and hence implementations can free any resources held by this class.
   * Again, the body of this function can be just empty and it will not
   * affect the lexer's operation.
   */
  void Done();
}
"
org.apache.velocity.runtime.parser.JJTParserState,"/* Generated By:JavaCC: Do not edit this line. JJTParserState.java Version 4.1 */
package org.apache.velocity.runtime.parser;
import org.apache.velocity.runtime.parser.node.Node;
public class JJTParserState {
  private java.util.List nodes;
  private java.util.List marks;
  private int sp;        // number of nodes on stack
  private int mk;        // current mark
  private boolean node_created;
  public JJTParserState() {
    nodes = new java.util.ArrayList();
    marks = new java.util.ArrayList();
    sp = 0;
    mk = 0;
  }
  /* Determines whether the current node was actually closed and
     pushed.  This should only be called in the final user action of a
     node scope.  */
  public boolean nodeCreated() {
    return node_created;
  }
  /* Call this to reinitialize the node stack.  It is called
     automatically by the parser's ReInit() method. */
  public void reset() {
    nodes.clear();
    marks.clear();
    sp = 0;
    mk = 0;
  }
  /* Returns the root node of the AST.  It only makes sense to call
     this after a successful parse. */
  public Node rootNode() {
    return (Node)nodes.get(0);
  }
  /* Pushes a node on to the stack. */
  public void pushNode(Node n) {
    nodes.add(n);
    ++sp;
  }
  /* Returns the node on the top of the stack, and remove it from the
     stack.  */
  public Node popNode() {
    if (--sp < mk) {
      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
    }
    return (Node)nodes.remove(nodes.size()-1);
  }
  /* Returns the node currently on the top of the stack. */
  public Node peekNode() {
    return (Node)nodes.get(nodes.size()-1);
  }
  /* Returns the number of children on the stack in the current node
     scope. */
  public int nodeArity() {
    return sp - mk;
  }
  public void clearNodeScope(Node n) {
    while (sp > mk) {
      popNode();
    }
    mk = ((Integer)marks.remove(marks.size()-1)).intValue();
  }
  public void openNodeScope(Node n) {
    marks.add(new Integer(mk));
    mk = sp;
    n.jjtOpen();
  }
  /* A definite node is constructed from a specified number of
     children.  That number of nodes are popped from the stack and
     made the children of the definite node.  Then the definite node
     is pushed on to the stack. */
  public void closeNodeScope(Node n, int num) {
    mk = ((Integer)marks.remove(marks.size()-1)).intValue();
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }
  /* A conditional node is constructed if its condition is true.  All
     the nodes that have been pushed since the node was opened are
     made children of the conditional node, which is then pushed
     on to the stack.  If the condition is false the node is not
     constructed and they are left on the stack. */
  public void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
      while (a-- > 0) {
        Node c = popNode();
        c.jjtSetParent(n);
        n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = ((Integer)marks.remove(marks.size()-1)).intValue();
      node_created = false;
    }
  }
}
/* JavaCC - OriginalChecksum=8480fe4a1d30863ae6ba57f195d12191 (do not edit this line) */
"
org.apache.velocity.runtime.parser.ParseException,"/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
package org.apache.velocity.runtime.parser;
/**
 * This exception is thrown when parse errors are encountered.
 * It is intended to be caught and typically will be rethrown
 * as a ParseErrorException.
 * 
 * <p>You can explicitly create objects of this exception type by
 * calling the method generateParseException in the generated
 * parser.
 *
 * You can modify this class to customize your error reporting
 * mechanisms so long as you retain the public fields.
 */
public class ParseException extends Exception {
    private static final long serialVersionUID = -309603325673449381L;
/**
   * This constructor is used by the method ""generateParseException""
   * in the generated parser.  Calling this constructor generates
   * a new object of this type with the fields ""currentToken"",
   * ""expectedTokenSequences"", and ""tokenImage"" set.  The boolean
   * flag ""specialConstructor"" is also set to true to indicate that
   * this constructor was used to create this object.
   * This constructor calls its super class with the empty string
   * to force the ""toString"" method of parent class ""Throwable"" to
   * print the error message in the form:
   *     ParseException: <result of getMessage>
   */
  public ParseException(Token currentTokenVal,
                        int[][] expectedTokenSequencesVal,
                        String[] tokenImageVal
                       )
  {
    super("""");
    specialConstructor = true;
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
  }
  /**
   * The following constructors are for use by you for whatever
   * purpose you can think of.  Constructing the exception in this
   * manner makes the exception behave in the normal way - i.e., as
   * documented in the class ""Throwable"".  The fields ""errorToken"",
   * ""expectedTokenSequences"", and ""tokenImage"" do not contain
   * relevant information.  The JavaCC generated code does not use
   * these constructors.
   */
  public ParseException() {
    super();
    specialConstructor = false;
  }
  public ParseException(String message) {
    super(message);
    specialConstructor = false;
  }
  /**
   * This variable determines which constructor was used to create
   * this object and thereby affects the semantics of the
   * ""getMessage"" method (see below).
   */
  protected boolean specialConstructor;
  /**
   * This is the last token that has been consumed successfully.  If
   * this object has been created due to a parse error, the token
   * followng this token will (therefore) be the first error token.
   */
  public Token currentToken;
  /**
   * Each entry in this array is an array of integers.  Each array
   * of integers represents a sequence of tokens (by their ordinal
   * values) that is expected at this point of the parse.
   */
  public int[][] expectedTokenSequences;
  /**
   * This is a reference to the ""tokenImage"" array of the generated
   * parser within which the parse error occurred.  This array is
   * defined in the generated ...Constants interface.
   */
  public String[] tokenImage;
  /**
   * This method has the standard behavior when this object has been
   * created using the standard constructors.  Otherwise, it uses
   * ""currentToken"" and ""expectedTokenSequences"" to generate a parse
   * error message and returns it.  If this object has been created
   * due to a parse error, and you do not catch it (it gets thrown
   * from the parser), then this method is called during the printing
   * of the final stack trace, and hence the correct error message
   * gets displayed.
   */
  public String getMessage() {
    if (!specialConstructor) {
      return super.getMessage();
    }
    String expected = """";
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
        expected += ""..."";
      }
      expected += eol + ""    "";
    }
    String retval = ""Encountered \"""";
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) retval += "" "";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += add_escapes(tok.image);
      tok = tok.next; 
    }
    retval += ""\"" at line "" + currentToken.next.beginLine + "", column "" + currentToken.next.beginColumn;
    retval += ""."" + eol;
    if (expectedTokenSequences.length == 1) {
      retval += ""Was expecting:"" + eol + ""    "";
    } else {
      retval += ""Was expecting one of:"" + eol + ""    "";
    }
    retval += expected;
    return retval;
  }
  /**
   * The end of line string for this machine.
   */
  protected String eol = System.getProperty(""line.separator"", ""\n"");
  /**
   * Used to convert raw characters to their escaped version
   * when these raw version cannot be used as part of an ASCII
   * string literal.
   */
  protected String add_escapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append(""\\b"");
              continue;
           case '\t':
              retval.append(""\\t"");
              continue;
           case '\n':
              retval.append(""\\n"");
              continue;
           case '\f':
              retval.append(""\\f"");
              continue;
           case '\r':
              retval.append(""\\r"");
              continue;
           case '\""':
              retval.append(""\\\"""");
              continue;
           case '\'':
              retval.append(""\\\'"");
              continue;
           case '\\':
              retval.append(""\\\\"");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = ""0000"" + Integer.toString(ch, 16);
                 retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }
}
"
org.apache.velocity.runtime.parser.Parser,"/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package org.apache.velocity.runtime.parser;
import java.io.*;
import java.util.*;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.node.*;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.directive.Macro;
import org.apache.velocity.runtime.directive.MacroParseException;
import org.apache.velocity.util.StringUtils;
/**
 * This class is responsible for parsing a Velocity
 * template. This class was generated by JavaCC using
 * the JJTree extension to produce an Abstract
 * Syntax Tree (AST) of the template.
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""hps@intermeta.de"">Henning P. Schmiedehausen</a>
 * @version $Id: Parser.java 720228 2008-11-24 16:58:33Z nbubna $
*/
public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants, ParserConstants {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();/**
     *  This Hashtable contains a list of all of the dynamic directives.
     */
    private Hashtable directives = new Hashtable(0);
    /**
     *  Name of current template we are parsing.  Passed to us in parse()
     */
    public String currentTemplateName = """";
    VelocityCharStream velcharstream = null;
    private RuntimeServices rsvc = null;
    /**
     * This constructor was added to allow the re-use of parsers.
     * The normal constructor takes a single argument which
     * an InputStream. This simply creates a re-usable parser
     * object, we satisfy the requirement of an InputStream
     * by using a newline character as an input stream.
     */
    public Parser( RuntimeServices rs)
    {
        /*
         * need to call the CTOR first thing.
         */
        this(   new VelocityCharStream(
                new ByteArrayInputStream(""\n"".getBytes()), 1, 1 ));
        /*
         * now setup a VCS for later use
         */
        velcharstream = new VelocityCharStream(
                new ByteArrayInputStream(""\n"".getBytes()), 1, 1 );
        /*
         *  and save the RuntimeServices
         */
        rsvc = rs;
    }
    /**
     * This was also added to allow parsers to be
     * re-usable. Normal JavaCC use entails passing an
     * input stream to the constructor and the parsing
     * process is carried out once. We want to be able
     * to re-use parsers: we do this by adding this
     * method and re-initializing the lexer with
     * the new stream that we want parsed.
     */
    public SimpleNode parse( Reader reader, String templateName )
        throws ParseException
    {
        SimpleNode sn = null;
        currentTemplateName = templateName;
        try
        {
            token_source.clearStateVars();
            /*
             *  reinitialize the VelocityCharStream
             *  with the new reader
             */
            velcharstream.ReInit( reader, 1, 1 );
            /*
             * now reinit the Parser with this CharStream
             */
            ReInit( velcharstream  );
            /*
             *  do that voodoo...
             */
            sn = process();
        }
        catch (MacroParseException mee)
        {
            /*
             *  thrown by the Macro class when something is amiss in the
             *  Macro specification
             */
            rsvc.getLog().error(""Parser Error: "" + templateName, mee);
            throw mee;
        }
        catch (ParseException pe)
        {
            rsvc.getLog().error(""Parser Exception: "" + templateName, pe);
            throw new TemplateParseException (pe.currentToken,
                                pe.expectedTokenSequences, pe.tokenImage, currentTemplateName);
                }
        catch (TokenMgrError tme)
        {
            throw new ParseException(""Lexical error: "" + tme.toString());
        }
        catch (Exception e)
        {
            String msg = ""Parser Error: "" + templateName;
            rsvc.getLog().error(msg, e);
            throw new VelocityException(msg, e);
        }
        currentTemplateName = """";
        return sn;
    }
    /**
     *  This method sets the directives Hashtable
     */
    public void setDirectives(Hashtable directives)
    {
        this.directives = directives;
    }
    /**
     *  This method gets a Directive from the directives Hashtable
     */
    public Directive getDirective(String directive)
    {
        return (Directive) directives.get(directive);
    }
    /**
     *  This method finds out of the directive exists in the directives
     *  Hashtable.
     */
    public boolean isDirective(String directive)
    {
        return directives.containsKey(directive);
    }
    /**
     * Produces a processed output for an escaped control or
     * pluggable directive
     */
    private String escapedDirective( String strImage )
    {
        int iLast = strImage.lastIndexOf(""\\"");
        String strDirective = strImage.substring(iLast + 1);
        boolean bRecognizedDirective = false;
        // we don't have to call substring method all the time in this method
        String dirTag = strDirective.substring(1);
        if (dirTag.charAt(0) == '{')
        {
            dirTag = dirTag.substring(1, dirTag.length() - 1);
        }
        /*
         *  is this a PD or a control directive?
         */
        if ( isDirective(dirTag) )
        {
           bRecognizedDirective = true;
        }
        else if ( rsvc.isVelocimacro(dirTag, currentTemplateName))
        {
            bRecognizedDirective = true;
        }
        else
        {
            /* order for speed? */
            if ( dirTag.equals(""if"")
                || dirTag.equals(""end"")
                || dirTag.equals(""set"")
                || dirTag.equals(""else"")
                || dirTag.equals(""elseif"")
                || dirTag.equals(""stop"")
            )
            {
                bRecognizedDirective = true;
            }
        }
        /*
         *  if so, make the proper prefix string (let the escapes do their thing..)
         *  otherwise, just return what it is..
         */
        if (bRecognizedDirective)
            return ( strImage.substring(0,iLast/2) + strDirective);
        else
            return ( strImage );
    }
    /**
     * Check whether there is a left parenthesis with leading optional
     * whitespaces. This method is used in the semantic look ahead of
     * Directive method. This is done in code instead of as a production
     * for simplicity and efficiency.
     */
    private boolean isLeftParenthesis()
    {
        char c;
        int no = 0;
        try {
            while(true)
            {
                /**
                 * Read a character
                 */
                c = velcharstream.readChar();
                no++;
                if (c == '(')
                {
                    return true;
                }
                /**
                 * if not a white space return
                 */
                else if (c != ' ' && c != '\n' && c != '\r' && c != '\t')
                {
                    return false;
                }
            }
        }
        catch (IOException e)
        {
        }
        finally
        {
            /**
             * Backup the stream to the initial state
             */
            velcharstream.backup(no);
        }
        return false;
    }
/**
 * This method is what starts the whole parsing
 * process. After the parsing is complete and
 * the template has been turned into an AST,
 * this method returns the root of AST which
 * can subsequently be traversed by a visitor
 * which implements the ParserVisitor interface
 * which is generated automatically by JavaCC
 */
  final public SimpleNode process() throws ParseException {
                        /*@bgen(jjtree) process */
  ASTprocess jjtn000 = new ASTprocess(this, JJTPROCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
        case RPAREN:
        case ESCAPE_DIRECTIVE:
        case SET_DIRECTIVE:
        case SINGLE_LINE_COMMENT_START:
        case DOUBLE_ESCAPE:
        case ESCAPE:
        case TEXT:
        case FORMAL_COMMENT:
        case MULTI_LINE_COMMENT:
        case STRING_LITERAL:
        case IF_DIRECTIVE:
        case STOP_DIRECTIVE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case WORD:
        case BRACKETED_WORD:
        case IDENTIFIER:
        case DOT:
        case LCURLY:
        case RCURLY:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        Statement();
      }
      jj_consume_token(0);
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
    throw new Error(""Missing return statement in function"");
  }
/**
 * These are the types of statements that
 * are acceptable in Velocity templates.
 */
  final public void Statement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF_DIRECTIVE:
      IfStatement();
      break;
    case STOP_DIRECTIVE:
      StopStatement();
      break;
    default:
      jj_la1[1] = jj_gen;
      if (jj_2_1(2)) {
        Reference();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SINGLE_LINE_COMMENT_START:
        case FORMAL_COMMENT:
        case MULTI_LINE_COMMENT:
          Comment();
          break;
        case SET_DIRECTIVE:
          SetDirective();
          break;
        case ESCAPE_DIRECTIVE:
          EscapedDirective();
          break;
        case DOUBLE_ESCAPE:
          Escape();
          break;
        case WORD:
        case BRACKETED_WORD:
          Directive();
          break;
        case LPAREN:
        case RPAREN:
        case ESCAPE:
        case TEXT:
        case STRING_LITERAL:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case DOT:
        case LCURLY:
        case RCURLY:
          Text();
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }
/**
 *  used to separate the notion of a valid directive that has been
 *  escaped, versus something that looks like a directive and
 *  is just schmoo.  This is important to do as a separate production
 *  that creates a node, because we want this, in either case, to stop
 *  the further parsing of the Directive() tree.
 */
  final public void EscapedDirective() throws ParseException {
                           /*@bgen(jjtree) EscapedDirective */
  ASTEscapedDirective jjtn000 = new ASTEscapedDirective(this, JJTESCAPEDDIRECTIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
        Token t = null;
      t = jj_consume_token(ESCAPE_DIRECTIVE);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        /*
         *  churn and burn..
         */
        t.image = escapedDirective( t.image );
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 *  Used to catch and process escape sequences in grammatical constructs
 *  as escapes outside of VTL are just characters.  Right now we have both
 *  this and the EscapeDirective() construction because in the EscapeDirective()
 *  case, we want to suck in the #<directive> and here we don't.  We just want
 *  the escapes to render correctly
 */
  final public void Escape() throws ParseException {
                 /*@bgen(jjtree) Escape */
  ASTEscape jjtn000 = new ASTEscape(this, JJTESCAPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
        Token t = null;
        int count = 0;
        boolean control = false;
      label_2:
      while (true) {
        t = jj_consume_token(DOUBLE_ESCAPE);
        count++;
        if (jj_2_2(2)) {
          ;
        } else {
          break label_2;
        }
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        /*
         * first, check to see if we have a control directive
         */
        switch(t.next.kind ) {
            case IF_DIRECTIVE :
            case ELSE_DIRECTIVE :
            case ELSEIF_DIRECTIVE :
            case END :
            case STOP_DIRECTIVE :
                control = true;
                break;
        }
        /*
         * if that failed, lets lookahead to see if we matched a PD or a VM
         */
        String nTag = t.next.image.substring(1);
        if ( isDirective(nTag) )
            control = true;
        else if ( rsvc.isVelocimacro(nTag, currentTemplateName))
            control = true;
        jjtn000.val = """";
        for( int i = 0; i < count; i++)
            jjtn000.val += ( control ? ""\\"" : ""\\\\"");
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void Comment() throws ParseException {
                  /*@bgen(jjtree) Comment */
  ASTComment jjtn000 = new ASTComment(this, JJTCOMMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SINGLE_LINE_COMMENT_START:
        jj_consume_token(SINGLE_LINE_COMMENT_START);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SINGLE_LINE_COMMENT:
          jj_consume_token(SINGLE_LINE_COMMENT);
          break;
        default:
          jj_la1[3] = jj_gen;
          ;
        }
        break;
      case MULTI_LINE_COMMENT:
        jj_consume_token(MULTI_LINE_COMMENT);
        break;
      case FORMAL_COMMENT:
        jj_consume_token(FORMAL_COMMENT);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }
  final public void FloatingPointLiteral() throws ParseException {
                               /*@bgen(jjtree) FloatingPointLiteral */
  ASTFloatingPointLiteral jjtn000 = new ASTFloatingPointLiteral(this, JJTFLOATINGPOINTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(FLOATING_POINT_LITERAL);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void IntegerLiteral() throws ParseException {
                         /*@bgen(jjtree) IntegerLiteral */
  ASTIntegerLiteral jjtn000 = new ASTIntegerLiteral(this, JJTINTEGERLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(INTEGER_LITERAL);
    } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
    }
  }
  final public void StringLiteral() throws ParseException {
                        /*@bgen(jjtree) StringLiteral */
  ASTStringLiteral jjtn000 = new ASTStringLiteral(this, JJTSTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(STRING_LITERAL);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 * This method corresponds to variable
 * references in Velocity templates.
 * The following are examples of variable
 * references that may be found in a
 * template:
 *
 * $foo
 * $bar
 *
 */
  final public void Identifier() throws ParseException {
                     /*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IDENTIFIER);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void Word() throws ParseException {
               /*@bgen(jjtree) Word */
  ASTWord jjtn000 = new ASTWord(this, JJTWORD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(WORD);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 *   Supports the arguments for the Pluggable Directives
 */
  final public int DirectiveArg() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case LCURLY:
      Reference();
        {if (true) return ParserTreeConstants.JJTREFERENCE;}
      break;
    case WORD:
      Word();
        {if (true) return ParserTreeConstants.JJTWORD;}
      break;
    case STRING_LITERAL:
      StringLiteral();
        {if (true) return ParserTreeConstants.JJTSTRINGLITERAL;}
      break;
    case INTEGER_LITERAL:
      IntegerLiteral();
        {if (true) return ParserTreeConstants.JJTINTEGERLITERAL;}
      break;
    default:
      jj_la1[5] = jj_gen;
      if (jj_2_3(2147483647)) {
        IntegerRange();
        {if (true) return ParserTreeConstants.JJTINTEGERRANGE;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FLOATING_POINT_LITERAL:
          FloatingPointLiteral();
        {if (true) return ParserTreeConstants.JJTFLOATINGPOINTLITERAL;}
          break;
        case LEFT_CURLEY:
          Map();
        {if (true) return ParserTreeConstants.JJTMAP;}
          break;
        case LBRACKET:
          ObjectArray();
        {if (true) return ParserTreeConstants.JJTOBJECTARRAY;}
          break;
        case TRUE:
          True();
        {if (true) return ParserTreeConstants.JJTTRUE;}
          break;
        case FALSE:
          False();
        {if (true) return ParserTreeConstants.JJTFALSE;}
          break;
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error(""Missing return statement in function"");
  }
/**
 *   Supports the Pluggable Directives
 *     #foo( arg+ )
 */
  final public SimpleNode Directive() throws ParseException {
 /*@bgen(jjtree) Directive */
    ASTDirective jjtn000 = new ASTDirective(this, JJTDIRECTIVE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t = null;
    int argType;
    int argPos = 0;
    Directive d;
    int directiveType;
    boolean isVM = false;
    boolean doItNow = false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        t = jj_consume_token(WORD);
        break;
      case BRACKETED_WORD:
        t = jj_consume_token(BRACKETED_WORD);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        String directiveName;
        if (t.kind == ParserConstants.BRACKETED_WORD)
        {
            directiveName = t.image.substring(2, t.image.length() - 1);
        }
        else
        {
            directiveName = t.image.substring(1);
        }
        d = (Directive) directives.get(directiveName);
        /*
         *  Velocimacro support : if the directive is macro directive
         *   then set the flag so after the block parsing, we add the VM
         *   right then. (So available if used w/in the current template )
         */
        if (directiveName.equals(""macro""))
        {
             doItNow = true;
        }
        /*
         * set the directive name from here.  No reason for the thing to know
         * about parser tokens
         */
        jjtn000.setDirectiveName(directiveName);
        if ( d == null)
        {
            /*
             *  if null, then not a real directive, but maybe a Velocimacro
             */
            isVM = rsvc.isVelocimacro(directiveName, currentTemplateName);
            /*
             *  Currently, all VMs are LINE directives
             */
            directiveType = Directive.LINE;
        }
        else
        {
            directiveType = d.getType();
        }
        /*
         *  now, switch us out of PRE_DIRECTIVE
         */
        token_source.SwitchTo(DIRECTIVE);
        argPos = 0;
      if (isLeftParenthesis()) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          jj_consume_token(WHITESPACE);
          break;
        default:
          jj_la1[8] = jj_gen;
          ;
        }
        jj_consume_token(LPAREN);
        label_3:
        while (true) {
          if (jj_2_4(2)) {
            ;
          } else {
            break label_3;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WHITESPACE:
            jj_consume_token(WHITESPACE);
            break;
          default:
            jj_la1[9] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            jj_consume_token(COMMA);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case WHITESPACE:
              jj_consume_token(WHITESPACE);
              break;
            default:
              jj_la1[10] = jj_gen;
              ;
            }
            break;
          default:
            jj_la1[11] = jj_gen;
            ;
          }
          argType = DirectiveArg();
                if (argType == ParserTreeConstants.JJTWORD)
                {
                    if (doItNow && argPos == 0)
                    {
                        /* if #macro and it's the 0th arg, ok */
                    }
                    else if (isVM)
                    {
                        {if (true) throw new MacroParseException(""Invalid arg #""
                        + argPos + "" in VM "" + t.image, currentTemplateName, t);}
                    }
                                          /* if #foreach and it's the 2nd arg, ok */
                    else if (d != null && (!directiveName.equals(""foreach"") || argPos != 1))
                    {
                        {if (true) throw new MacroParseException(""Invalid arg #""
                        + argPos + "" in directive "" + t.image, currentTemplateName, t);}
                    }
                    else
                    {
                        /* either schmoo or a late-defined macro,
                         * VelocimacroProxy will have to check for latter. */
                    }
                }
                else
                {
                    if (doItNow && argPos == 0)
                    {
                        /* if a VM and it's the 0th arg, not ok */
                        {if (true) throw new MacroParseException(""Invalid first arg""
                        + "" in #macro() directive - must be a""
                        + "" word token (no \' or \"" surrounding)"", currentTemplateName, t);}
                    }
                }
                argPos++;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          jj_consume_token(WHITESPACE);
          break;
        default:
          jj_la1[12] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
        if (directiveType  == Directive.LINE)
        {
            {if (true) return jjtn000;}
        }
      } else {
        /**
         * Not a directive
         */
        token_source.stateStackPop();
        token_source.inDirective = false;
        {if (true) return jjtn000;}
      }
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      try {
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
          case RPAREN:
          case ESCAPE_DIRECTIVE:
          case SET_DIRECTIVE:
          case SINGLE_LINE_COMMENT_START:
          case DOUBLE_ESCAPE:
          case ESCAPE:
          case TEXT:
          case FORMAL_COMMENT:
          case MULTI_LINE_COMMENT:
          case STRING_LITERAL:
          case IF_DIRECTIVE:
          case STOP_DIRECTIVE:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case WORD:
          case BRACKETED_WORD:
          case IDENTIFIER:
          case DOT:
          case LCURLY:
          case RCURLY:
            ;
            break;
          default:
            jj_la1[13] = jj_gen;
            break label_4;
          }
          Statement();
        }
      } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
      }
      jj_consume_token(END);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        /*
         *  VM : if we are processing a #macro directive, we need to
         *     process the block.  In truth, I can just register the name
         *     and do the work later when init-ing.  That would work
         *     as long as things were always defined before use.  This way
         *     we don't have to worry about forward references and such...
         */
        if (doItNow)
        {
            Macro.processAndRegister(rsvc, t, jjtn000, currentTemplateName);
        }
        /*
         *  VM : end
         */
        {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error(""Missing return statement in function"");
  }
/**
 * for creating a map in a #set
 *
 *  #set($foo = {$foo : $bar, $blargh : $thingy})
 */
  final public void Map() throws ParseException {
              /*@bgen(jjtree) Map */
  ASTMap jjtn000 = new ASTMap(this, JJTMAP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LEFT_CURLEY);
      if (jj_2_5(2)) {
        Parameter();
        jj_consume_token(COLON);
        Parameter();
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[14] = jj_gen;
            break label_5;
          }
          jj_consume_token(COMMA);
          Parameter();
          jj_consume_token(COLON);
          Parameter();
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHITESPACE:
          jj_consume_token(WHITESPACE);
          break;
        default:
          jj_la1[15] = jj_gen;
          ;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RIGHT_CURLEY:
        jj_consume_token(RIGHT_CURLEY);
        break;
      case RCURLY:
        jj_consume_token(RCURLY);
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void ObjectArray() throws ParseException {
                      /*@bgen(jjtree) ObjectArray */
  ASTObjectArray jjtn000 = new ASTObjectArray(this, JJTOBJECTARRAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case LEFT_CURLEY:
      case WHITESPACE:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case IDENTIFIER:
      case LCURLY:
        Parameter();
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[17] = jj_gen;
            break label_6;
          }
          jj_consume_token(COMMA);
          Parameter();
        }
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      jj_consume_token(RBRACKET);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 *  supports the [n..m] vector generator for use in
 *  the #foreach() to generate measured ranges w/o
 *  needing explicit support from the app/servlet
 */
  final public void IntegerRange() throws ParseException {
                       /*@bgen(jjtree) IntegerRange */
  ASTIntegerRange jjtn000 = new ASTIntegerRange(this, JJTINTEGERRANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case LCURLY:
        Reference();
        break;
      case INTEGER_LITERAL:
        IntegerLiteral();
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      jj_consume_token(DOUBLEDOT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case LCURLY:
        Reference();
        break;
      case INTEGER_LITERAL:
        IntegerLiteral();
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      jj_consume_token(RBRACKET);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 * This method has yet to be fully implemented
 * but will allow arbitrarily nested method
 * calls
 */
  final public void Parameter() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHITESPACE:
      jj_consume_token(WHITESPACE);
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      StringLiteral();
      break;
    case INTEGER_LITERAL:
      IntegerLiteral();
      break;
    default:
      jj_la1[26] = jj_gen;
      if (jj_2_6(2147483647)) {
        IntegerRange();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEFT_CURLEY:
          Map();
          break;
        case LBRACKET:
          ObjectArray();
          break;
        case TRUE:
          True();
          break;
        case FALSE:
          False();
          break;
        case IDENTIFIER:
        case LCURLY:
          Reference();
          break;
        case FLOATING_POINT_LITERAL:
          FloatingPointLiteral();
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHITESPACE:
      jj_consume_token(WHITESPACE);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
  }
/**
 * This method has yet to be fully implemented
 * but will allow arbitrarily nested method
 * calls
 */
  final public void Method() throws ParseException {
                 /*@bgen(jjtree) Method */
  ASTMethod jjtn000 = new ASTMethod(this, JJTMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Identifier();
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case LEFT_CURLEY:
      case WHITESPACE:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case IDENTIFIER:
      case LCURLY:
        Parameter();
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[29] = jj_gen;
            break label_7;
          }
          jj_consume_token(COMMA);
          Parameter();
        }
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      jj_consume_token(REFMOD2_RPAREN);
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
  }
  final public void Reference() throws ParseException {
                    /*@bgen(jjtree) Reference */
  ASTReference jjtn000 = new ASTReference(this, JJTREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        label_8:
        while (true) {
          if (jj_2_7(2)) {
            ;
          } else {
            break label_8;
          }
          jj_consume_token(DOT);
          if (jj_2_8(3)) {
            Method();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IDENTIFIER:
              Identifier();
              break;
            default:
              jj_la1[31] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        break;
      case LCURLY:
        jj_consume_token(LCURLY);
        jj_consume_token(IDENTIFIER);
        label_9:
        while (true) {
          if (jj_2_9(2)) {
            ;
          } else {
            break label_9;
          }
          jj_consume_token(DOT);
          if (jj_2_10(3)) {
            Method();
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IDENTIFIER:
              Identifier();
              break;
            default:
              jj_la1[32] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        jj_consume_token(RCURLY);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
  }
  final public void True() throws ParseException {
               /*@bgen(jjtree) True */
  ASTTrue jjtn000 = new ASTTrue(this, JJTTRUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(TRUE);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void False() throws ParseException {
                /*@bgen(jjtree) False */
  ASTFalse jjtn000 = new ASTFalse(this, JJTFALSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(FALSE);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 * This method is responsible for allowing
 * all non-grammar text to pass through
 * unscathed.
 */
  final public void Text() throws ParseException {
               /*@bgen(jjtree) Text */
  ASTText jjtn000 = new ASTText(this, JJTTEXT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXT:
        jj_consume_token(TEXT);
        break;
      case DOT:
        jj_consume_token(DOT);
        break;
      case RPAREN:
        jj_consume_token(RPAREN);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        break;
      case INTEGER_LITERAL:
        jj_consume_token(INTEGER_LITERAL);
        break;
      case FLOATING_POINT_LITERAL:
        jj_consume_token(FLOATING_POINT_LITERAL);
        break;
      case STRING_LITERAL:
        jj_consume_token(STRING_LITERAL);
        break;
      case ESCAPE:
        jj_consume_token(ESCAPE);
        break;
      case LCURLY:
        jj_consume_token(LCURLY);
        break;
      case RCURLY:
        jj_consume_token(RCURLY);
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/* -----------------------------------------------------------------------
 *
 *  Defined Directive Syntax
 *
 * ----------------------------------------------------------------------*/
  final public void IfStatement() throws ParseException {
                      /*@bgen(jjtree) IfStatement */
  ASTIfStatement jjtn000 = new ASTIfStatement(this, JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IF_DIRECTIVE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      try {
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
          case RPAREN:
          case ESCAPE_DIRECTIVE:
          case SET_DIRECTIVE:
          case SINGLE_LINE_COMMENT_START:
          case DOUBLE_ESCAPE:
          case ESCAPE:
          case TEXT:
          case FORMAL_COMMENT:
          case MULTI_LINE_COMMENT:
          case STRING_LITERAL:
          case IF_DIRECTIVE:
          case STOP_DIRECTIVE:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case WORD:
          case BRACKETED_WORD:
          case IDENTIFIER:
          case DOT:
          case LCURLY:
          case RCURLY:
            ;
            break;
          default:
            jj_la1[36] = jj_gen;
            break label_10;
          }
          Statement();
        }
      } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSEIF_DIRECTIVE:
        label_11:
        while (true) {
          ElseIfStatement();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ELSEIF_DIRECTIVE:
            ;
            break;
          default:
            jj_la1[37] = jj_gen;
            break label_11;
          }
        }
        break;
      default:
        jj_la1[38] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE_DIRECTIVE:
        ElseStatement();
        break;
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      jj_consume_token(END);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
  final public void ElseStatement() throws ParseException {
                        /*@bgen(jjtree) ElseStatement */
  ASTElseStatement jjtn000 = new ASTElseStatement(this, JJTELSESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ELSE_DIRECTIVE);
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      try {
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
          case RPAREN:
          case ESCAPE_DIRECTIVE:
          case SET_DIRECTIVE:
          case SINGLE_LINE_COMMENT_START:
          case DOUBLE_ESCAPE:
          case ESCAPE:
          case TEXT:
          case FORMAL_COMMENT:
          case MULTI_LINE_COMMENT:
          case STRING_LITERAL:
          case IF_DIRECTIVE:
          case STOP_DIRECTIVE:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case WORD:
          case BRACKETED_WORD:
          case IDENTIFIER:
          case DOT:
          case LCURLY:
          case RCURLY:
            ;
            break;
          default:
            jj_la1[40] = jj_gen;
            break label_12;
          }
          Statement();
        }
      } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
  }
  final public void ElseIfStatement() throws ParseException {
                          /*@bgen(jjtree) ElseIfStatement */
  ASTElseIfStatement jjtn000 = new ASTElseIfStatement(this, JJTELSEIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(ELSEIF_DIRECTIVE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      ASTBlock jjtn001 = new ASTBlock(this, JJTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      try {
        label_13:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
          case RPAREN:
          case ESCAPE_DIRECTIVE:
          case SET_DIRECTIVE:
          case SINGLE_LINE_COMMENT_START:
          case DOUBLE_ESCAPE:
          case ESCAPE:
          case TEXT:
          case FORMAL_COMMENT:
          case MULTI_LINE_COMMENT:
          case STRING_LITERAL:
          case IF_DIRECTIVE:
          case STOP_DIRECTIVE:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case WORD:
          case BRACKETED_WORD:
          case IDENTIFIER:
          case DOT:
          case LCURLY:
          case RCURLY:
            ;
            break;
          default:
            jj_la1[42] = jj_gen;
            break label_13;
          }
          Statement();
        }
      } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte001;}
      }
      if (jjte001 instanceof ParseException) {
        {if (true) throw (ParseException)jjte001;}
      }
      {if (true) throw (Error)jjte001;}
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 *  Currently support both types of set :
 *   #set( expr )
 *   #set expr
 */
  final public void SetDirective() throws ParseException {
                       /*@bgen(jjtree) SetDirective */
  ASTSetDirective jjtn000 = new ASTSetDirective(this, JJTSETDIRECTIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(SET_DIRECTIVE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[43] = jj_gen;
        ;
      }
      Reference();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[44] = jj_gen;
        ;
      }
      jj_consume_token(EQUALS);
      Expression();
      jj_consume_token(RPAREN);
        /*
         * ensure that inSet is false.  Leads to some amusing bugs...
         */
        token_source.inSet = false;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NEWLINE:
        jj_consume_token(NEWLINE);
        break;
      default:
        jj_la1[45] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }
/**
 * This method corresponds to the #stop
 * directive which just simulates and EOF
 * so that parsing stops. The #stop directive
 * is useful for end-user debugging
 * purposes.
 */
  final public void StopStatement() throws ParseException {
                                /*@bgen(jjtree) #Stop( 0) */
  ASTStop jjtn000 = new ASTStop(this, JJTSTOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(STOP_DIRECTIVE);
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000,  0);
      }
    }
  }
/* -----------------------------------------------------------------------
 *
 *  Expression Syntax
 *
 * ----------------------------------------------------------------------*/
  final public void Expression() throws ParseException {
                     /*@bgen(jjtree) Expression */
  ASTExpression jjtn000 = new ASTExpression(this, JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ConditionalOrExpression();
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }
  final public void Assignment() throws ParseException {
                                    /*@bgen(jjtree) #Assignment( 2) */
  ASTAssignment jjtn000 = new ASTAssignment(this, JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      PrimaryExpression();
      jj_consume_token(EQUALS);
      Expression();
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000,  2);
      }
    }
  }
  final public void ConditionalOrExpression() throws ParseException {
    ConditionalAndExpression();
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_OR:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_14;
      }
      jj_consume_token(LOGICAL_OR);
                     ASTOrNode jjtn001 = new ASTOrNode(this, JJTORNODE);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
      try {
        ConditionalAndExpression();
      } catch (Throwable jjte001) {
                     if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte001 instanceof RuntimeException) {
                       {if (true) throw (RuntimeException)jjte001;}
                     }
                     if (jjte001 instanceof ParseException) {
                       {if (true) throw (ParseException)jjte001;}
                     }
                     {if (true) throw (Error)jjte001;}
      } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  2);
                     }
      }
    }
  }
  final public void ConditionalAndExpression() throws ParseException {
    EqualityExpression();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_AND:
        ;
        break;
      default:
        jj_la1[47] = jj_gen;
        break label_15;
      }
      jj_consume_token(LOGICAL_AND);
                    ASTAndNode jjtn001 = new ASTAndNode(this, JJTANDNODE);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
      try {
        EqualityExpression();
      } catch (Throwable jjte001) {
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte001 instanceof RuntimeException) {
                      {if (true) throw (RuntimeException)jjte001;}
                    }
                    if (jjte001 instanceof ParseException) {
                      {if (true) throw (ParseException)jjte001;}
                    }
                    {if (true) throw (Error)jjte001;}
      } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  2);
                    }
      }
    }
  }
  final public void EqualityExpression() throws ParseException {
    RelationalExpression();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_EQUALS:
      case LOGICAL_NOT_EQUALS:
        ;
        break;
      default:
        jj_la1[48] = jj_gen;
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_EQUALS:
        jj_consume_token(LOGICAL_EQUALS);
                          ASTEQNode jjtn001 = new ASTEQNode(this, JJTEQNODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
        try {
          RelationalExpression();
        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            {if (true) throw (RuntimeException)jjte001;}
                          }
                          if (jjte001 instanceof ParseException) {
                            {if (true) throw (ParseException)jjte001;}
                          }
                          {if (true) throw (Error)jjte001;}
        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
        }
        break;
      case LOGICAL_NOT_EQUALS:
        jj_consume_token(LOGICAL_NOT_EQUALS);
                              ASTNENode jjtn002 = new ASTNENode(this, JJTNENODE);
                              boolean jjtc002 = true;
                              jjtree.openNodeScope(jjtn002);
        try {
          RelationalExpression();
        } catch (Throwable jjte002) {
                              if (jjtc002) {
                                jjtree.clearNodeScope(jjtn002);
                                jjtc002 = false;
                              } else {
                                jjtree.popNode();
                              }
                              if (jjte002 instanceof RuntimeException) {
                                {if (true) throw (RuntimeException)jjte002;}
                              }
                              if (jjte002 instanceof ParseException) {
                                {if (true) throw (ParseException)jjte002;}
                              }
                              {if (true) throw (Error)jjte002;}
        } finally {
                              if (jjtc002) {
                                jjtree.closeNodeScope(jjtn002,  2);
                              }
        }
        break;
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void RelationalExpression() throws ParseException {
    AdditiveExpression();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_LT:
      case LOGICAL_LE:
      case LOGICAL_GT:
      case LOGICAL_GE:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_17;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOGICAL_LT:
        jj_consume_token(LOGICAL_LT);
                        ASTLTNode jjtn001 = new ASTLTNode(this, JJTLTNODE);
                        boolean jjtc001 = true;
                        jjtree.openNodeScope(jjtn001);
        try {
          AdditiveExpression();
        } catch (Throwable jjte001) {
                        if (jjtc001) {
                          jjtree.clearNodeScope(jjtn001);
                          jjtc001 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte001 instanceof RuntimeException) {
                          {if (true) throw (RuntimeException)jjte001;}
                        }
                        if (jjte001 instanceof ParseException) {
                          {if (true) throw (ParseException)jjte001;}
                        }
                        {if (true) throw (Error)jjte001;}
        } finally {
                        if (jjtc001) {
                          jjtree.closeNodeScope(jjtn001,  2);
                        }
        }
        break;
      case LOGICAL_GT:
        jj_consume_token(LOGICAL_GT);
                        ASTGTNode jjtn002 = new ASTGTNode(this, JJTGTNODE);
                        boolean jjtc002 = true;
                        jjtree.openNodeScope(jjtn002);
        try {
          AdditiveExpression();
        } catch (Throwable jjte002) {
                        if (jjtc002) {
                          jjtree.clearNodeScope(jjtn002);
                          jjtc002 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte002 instanceof RuntimeException) {
                          {if (true) throw (RuntimeException)jjte002;}
                        }
                        if (jjte002 instanceof ParseException) {
                          {if (true) throw (ParseException)jjte002;}
                        }
                        {if (true) throw (Error)jjte002;}
        } finally {
                        if (jjtc002) {
                          jjtree.closeNodeScope(jjtn002,  2);
                        }
        }
        break;
      case LOGICAL_LE:
        jj_consume_token(LOGICAL_LE);
                        ASTLENode jjtn003 = new ASTLENode(this, JJTLENODE);
                        boolean jjtc003 = true;
                        jjtree.openNodeScope(jjtn003);
        try {
          AdditiveExpression();
        } catch (Throwable jjte003) {
                        if (jjtc003) {
                          jjtree.clearNodeScope(jjtn003);
                          jjtc003 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte003 instanceof RuntimeException) {
                          {if (true) throw (RuntimeException)jjte003;}
                        }
                        if (jjte003 instanceof ParseException) {
                          {if (true) throw (ParseException)jjte003;}
                        }
                        {if (true) throw (Error)jjte003;}
        } finally {
                        if (jjtc003) {
                          jjtree.closeNodeScope(jjtn003,  2);
                        }
        }
        break;
      case LOGICAL_GE:
        jj_consume_token(LOGICAL_GE);
                        ASTGENode jjtn004 = new ASTGENode(this, JJTGENODE);
                        boolean jjtc004 = true;
                        jjtree.openNodeScope(jjtn004);
        try {
          AdditiveExpression();
        } catch (Throwable jjte004) {
                        if (jjtc004) {
                          jjtree.clearNodeScope(jjtn004);
                          jjtc004 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte004 instanceof RuntimeException) {
                          {if (true) throw (RuntimeException)jjte004;}
                        }
                        if (jjte004 instanceof ParseException) {
                          {if (true) throw (ParseException)jjte004;}
                        }
                        {if (true) throw (Error)jjte004;}
        } finally {
                        if (jjtc004) {
                          jjtree.closeNodeScope(jjtn004,  2);
                        }
        }
        break;
      default:
        jj_la1[51] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void AdditiveExpression() throws ParseException {
    MultiplicativeExpression();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
      case PLUS:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_18;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
                  ASTAddNode jjtn001 = new ASTAddNode(this, JJTADDNODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
          MultiplicativeExpression();
        } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte001;}
                  }
                  if (jjte001 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte001;}
                  }
                  {if (true) throw (Error)jjte001;}
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
        break;
      case MINUS:
        jj_consume_token(MINUS);
                  ASTSubtractNode jjtn002 = new ASTSubtractNode(this, JJTSUBTRACTNODE);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
        try {
          MultiplicativeExpression();
        } catch (Throwable jjte002) {
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte002 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte002;}
                  }
                  if (jjte002 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte002;}
                  }
                  {if (true) throw (Error)jjte002;}
        } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002,  2);
                  }
        }
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void MultiplicativeExpression() throws ParseException {
    UnaryExpression();
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
      case DIVIDE:
      case MODULUS:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_19;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
        jj_consume_token(MULTIPLY);
                          ASTMulNode jjtn001 = new ASTMulNode(this, JJTMULNODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
        try {
          UnaryExpression();
        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            {if (true) throw (RuntimeException)jjte001;}
                          }
                          if (jjte001 instanceof ParseException) {
                            {if (true) throw (ParseException)jjte001;}
                          }
                          {if (true) throw (Error)jjte001;}
        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                          }
        }
        break;
      case DIVIDE:
        jj_consume_token(DIVIDE);
                        ASTDivNode jjtn002 = new ASTDivNode(this, JJTDIVNODE);
                        boolean jjtc002 = true;
                        jjtree.openNodeScope(jjtn002);
        try {
          UnaryExpression();
        } catch (Throwable jjte002) {
                        if (jjtc002) {
                          jjtree.clearNodeScope(jjtn002);
                          jjtc002 = false;
                        } else {
                          jjtree.popNode();
                        }
                        if (jjte002 instanceof RuntimeException) {
                          {if (true) throw (RuntimeException)jjte002;}
                        }
                        if (jjte002 instanceof ParseException) {
                          {if (true) throw (ParseException)jjte002;}
                        }
                        {if (true) throw (Error)jjte002;}
        } finally {
                        if (jjtc002) {
                          jjtree.closeNodeScope(jjtn002,  2);
                        }
        }
        break;
      case MODULUS:
        jj_consume_token(MODULUS);
                         ASTModNode jjtn003 = new ASTModNode(this, JJTMODNODE);
                         boolean jjtc003 = true;
                         jjtree.openNodeScope(jjtn003);
        try {
          UnaryExpression();
        } catch (Throwable jjte003) {
                         if (jjtc003) {
                           jjtree.clearNodeScope(jjtn003);
                           jjtc003 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte003 instanceof RuntimeException) {
                           {if (true) throw (RuntimeException)jjte003;}
                         }
                         if (jjte003 instanceof ParseException) {
                           {if (true) throw (ParseException)jjte003;}
                         }
                         {if (true) throw (Error)jjte003;}
        } finally {
                         if (jjtc003) {
                           jjtree.closeNodeScope(jjtn003,  2);
                         }
        }
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void UnaryExpression() throws ParseException {
    if (jj_2_11(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      jj_consume_token(LOGICAL_NOT);
                                                    ASTNotNode jjtn001 = new ASTNotNode(this, JJTNOTNODE);
                                                    boolean jjtc001 = true;
                                                    jjtree.openNodeScope(jjtn001);
      try {
        UnaryExpression();
      } catch (Throwable jjte001) {
                                                    if (jjtc001) {
                                                      jjtree.clearNodeScope(jjtn001);
                                                      jjtc001 = false;
                                                    } else {
                                                      jjtree.popNode();
                                                    }
                                                    if (jjte001 instanceof RuntimeException) {
                                                      {if (true) throw (RuntimeException)jjte001;}
                                                    }
                                                    if (jjte001 instanceof ParseException) {
                                                      {if (true) throw (ParseException)jjte001;}
                                                    }
                                                    {if (true) throw (Error)jjte001;}
      } finally {
                                                    if (jjtc001) {
                                                      jjtree.closeNodeScope(jjtn001,  1);
                                                    }
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
      case LEFT_CURLEY:
      case LPAREN:
      case WHITESPACE:
      case STRING_LITERAL:
      case TRUE:
      case FALSE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case IDENTIFIER:
      case LCURLY:
        PrimaryExpression();
        break;
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void PrimaryExpression() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHITESPACE:
      jj_consume_token(WHITESPACE);
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      StringLiteral();
      break;
    case IDENTIFIER:
    case LCURLY:
      Reference();
      break;
    case INTEGER_LITERAL:
      IntegerLiteral();
      break;
    default:
      jj_la1[59] = jj_gen;
      if (jj_2_12(2147483647)) {
        IntegerRange();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FLOATING_POINT_LITERAL:
          FloatingPointLiteral();
          break;
        case LEFT_CURLEY:
          Map();
          break;
        case LBRACKET:
          ObjectArray();
          break;
        case TRUE:
          True();
          break;
        case FALSE:
          False();
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          Expression();
          jj_consume_token(RPAREN);
          break;
        default:
          jj_la1[60] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHITESPACE:
      jj_consume_token(WHITESPACE);
      break;
    default:
      jj_la1[61] = jj_gen;
      ;
    }
  }
  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }
  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }
  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }
  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }
  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }
  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }
  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }
  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }
  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }
  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }
  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }
  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }
  private boolean jj_3R_45() {
    if (jj_3R_65()) return true;
    return false;
  }
  private boolean jj_3_3() {
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    if (jj_scan_token(DOUBLEDOT)) return true;
    return false;
  }
  private boolean jj_3R_44() {
    if (jj_3R_64()) return true;
    return false;
  }
  private boolean jj_3R_43() {
    if (jj_3R_63()) return true;
    return false;
  }
  private boolean jj_3R_42() {
    if (jj_3R_62()) return true;
    return false;
  }
  private boolean jj_3R_41() {
    if (jj_3R_61()) return true;
    return false;
  }
  private boolean jj_3R_40() {
    if (jj_3R_36()) return true;
    return false;
  }
  private boolean jj_3R_39() {
    if (jj_3R_60()) return true;
    return false;
  }
  private boolean jj_3R_38() {
    if (jj_3R_59()) return true;
    return false;
  }
  private boolean jj_3R_23() {
    if (jj_scan_token(COMMA)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_37() {
    if (jj_3R_20()) return true;
    return false;
  }
  private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_59() {
    if (jj_scan_token(WORD)) return true;
    return false;
  }
  private boolean jj_3R_56() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3R_30() {
    if (jj_3R_56()) return true;
    return false;
  }
  private boolean jj_3_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) jj_scanpos = xsp;
    if (jj_3R_24()) return true;
    return false;
  }
  private boolean jj_3R_60() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_28() {
    if (jj_3R_56()) return true;
    return false;
  }
  private boolean jj_3R_33() {
    if (jj_3R_36()) return true;
    return false;
  }
  private boolean jj_3R_36() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_62() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_32() {
    if (jj_3R_20()) return true;
    return false;
  }
  private boolean jj_3R_27() {
    if (jj_3R_36()) return true;
    return false;
  }
  private boolean jj_3_10() {
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3R_82() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_25()) return true;
    return false;
  }
  private boolean jj_3_8() {
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3R_26() {
    if (jj_3R_20()) return true;
    return false;
  }
  private boolean jj_3R_66() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }
  private boolean jj_3R_65() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }
  private boolean jj_3_9() {
    if (jj_scan_token(DOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) return true;
    }
    return false;
  }
  private boolean jj_3R_57() {
    if (jj_3R_25()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_82()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3_7() {
    if (jj_scan_token(DOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) return true;
    }
    return false;
  }
  private boolean jj_3R_35() {
    if (jj_scan_token(LCURLY)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_9()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RCURLY)) return true;
    return false;
  }
  private boolean jj_3_12() {
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    if (jj_scan_token(DOUBLEDOT)) return true;
    return false;
  }
  private boolean jj_3R_34() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_7()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_81() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }
  private boolean jj_3R_80() {
    if (jj_3R_66()) return true;
    return false;
  }
  private boolean jj_3R_79() {
    if (jj_3R_65()) return true;
    return false;
  }
  private boolean jj_3_2() {
    if (jj_scan_token(DOUBLE_ESCAPE)) return true;
    return false;
  }
  private boolean jj_3R_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) return true;
    }
    return false;
  }
  private boolean jj_3R_78() {
    if (jj_3R_64()) return true;
    return false;
  }
  private boolean jj_3R_77() {
    if (jj_3R_63()) return true;
    return false;
  }
  private boolean jj_3R_76() {
    if (jj_3R_62()) return true;
    return false;
  }
  private boolean jj_3R_75() {
    if (jj_3R_61()) return true;
    return false;
  }
  private boolean jj_3R_74() {
    if (jj_3R_36()) return true;
    return false;
  }
  private boolean jj_3R_73() {
    if (jj_3R_20()) return true;
    return false;
  }
  private boolean jj_3_6() {
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_3R_27()) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    if (jj_scan_token(DOUBLEDOT)) return true;
    return false;
  }
  private boolean jj_3R_29() {
    if (jj_3R_56()) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_57()) jj_scanpos = xsp;
    if (jj_scan_token(REFMOD2_RPAREN)) return true;
    return false;
  }
  private boolean jj_3R_72() {
    if (jj_3R_60()) return true;
    return false;
  }
  private boolean jj_3R_67() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_55() {
    if (jj_3R_62()) return true;
    return false;
  }
  private boolean jj_3R_54() {
    if (jj_3R_20()) return true;
    return false;
  }
  private boolean jj_3R_53() {
    if (jj_3R_66()) return true;
    return false;
  }
  private boolean jj_3R_52() {
    if (jj_3R_65()) return true;
    return false;
  }
  private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    return false;
  }
  private boolean jj_3_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    if (jj_scan_token(LOGICAL_NOT)) return true;
    if (jj_3R_31()) return true;
    return false;
  }
  private boolean jj_3R_58() {
    if (jj_3R_67()) return true;
    return false;
  }
  private boolean jj_3R_51() {
    if (jj_3R_64()) return true;
    return false;
  }
  private boolean jj_3R_85() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_25()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_25()) return true;
    return false;
  }
  private boolean jj_3R_50() {
    if (jj_3R_63()) return true;
    return false;
  }
  private boolean jj_3R_49() {
    if (jj_3R_61()) return true;
    return false;
  }
  private boolean jj_3R_48() {
    if (jj_3R_36()) return true;
    return false;
  }
  private boolean jj_3R_47() {
    if (jj_3R_60()) return true;
    return false;
  }
  private boolean jj_3R_84() {
    if (jj_3R_36()) return true;
    return false;
  }
  private boolean jj_3R_69() {
    if (jj_3R_36()) return true;
    return false;
  }
  private boolean jj_3R_86() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_25()) return true;
    return false;
  }
  private boolean jj_3R_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_22() {
    if (jj_3R_36()) return true;
    return false;
  }
  private boolean jj_3R_83() {
    if (jj_3R_20()) return true;
    return false;
  }
  private boolean jj_3R_68() {
    if (jj_3R_20()) return true;
    return false;
  }
  private boolean jj_3R_71() {
    if (jj_3R_25()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_86()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_61() {
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    if (jj_scan_token(DOUBLEDOT)) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3_1() {
    if (jj_3R_20()) return true;
    return false;
  }
  private boolean jj_3R_21() {
    if (jj_3R_20()) return true;
    return false;
  }
  private boolean jj_3R_64() {
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_71()) jj_scanpos = xsp;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3R_70() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(26)) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3_5() {
    if (jj_3R_25()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_25()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_85()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_46() {
    if (jj_3R_66()) return true;
    return false;
  }
  private boolean jj_3R_63() {
    if (jj_scan_token(LEFT_CURLEY)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) return true;
    }
    xsp = jj_scanpos;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) return true;
    }
    return false;
  }
  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[62];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x9bc1b00,0x0,0x9bc1b00,0x400000,0x1840000,0x8000000,0x30000042,0x0,0x4000000,0x4000000,0x4000000,0x8,0x4000000,0x9bc1b00,0x8,0x4000000,0x80,0x8,0x3c000042,0x4000000,0x0,0x4000000,0x4000000,0x0,0x4000000,0x4000000,0x8000000,0x30000042,0x4000000,0x8,0x3c000042,0x0,0x0,0x0,0x8300300,0x4000000,0x9bc1b00,0x0,0x0,0x0,0x9bc1b00,0x4000000,0x9bc1b00,0x4000000,0x4000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x0,0x0,0x4000000,0x3c000142,0x4000000,0x8000000,0x30000142,0x4000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xc6348000,0x48000,0x86300000,0x0,0x0,0x42100000,0x200000,0x6000000,0x0,0x0,0x0,0x0,0x0,0xc6348000,0x0,0x0,0x0,0x0,0x40300000,0x0,0x40100000,0x0,0x0,0x40100000,0x0,0x0,0x100000,0x40200000,0x0,0x0,0x40300000,0x40000000,0x40000000,0x40000000,0x80300000,0x0,0xc6348000,0x10000,0x10000,0x20000,0xc6348000,0x0,0xc6348000,0x0,0x0,0x0,0x20,0x10,0xc00,0xc00,0x3c0,0x3c0,0x1,0x1,0xe,0xe,0x0,0x40300000,0x0,0x40100000,0x200000,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x3,0x0,0x3,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x2,0x0,0x1,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x1,0x3,0x0,0x3,0x0,0x0,0x0,0x3,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[12];
  private boolean jj_rescan = false;
  private int jj_gc = 0;
  /** Constructor with user supplied CharStream. */
  public Parser(CharStream stream) {
    token_source = new ParserTokenManager(stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 62; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  /** Reinitialise. */
  public void ReInit(CharStream stream) {
    token_source.ReInit(stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 62; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 62; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 62; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }
/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }
/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }
  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }
  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;
  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }
  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[68];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 62; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 68; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }
  /** Enable tracing. */
  final public void enable_tracing() {
  }
  /** Disable tracing. */
  final public void disable_tracing() {
  }
  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 12; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }
  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }
  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }
}
"
org.apache.velocity.runtime.parser.ParserConstants,"/* Generated By:JJTree&JavaCC: Do not edit this line. ParserConstants.java */
package org.apache.velocity.runtime.parser;
/**
 * Token literal values and constants.
 * Generated by org.javacc.parser.OtherFilesGen#start()
 */
public interface ParserConstants {
  /** End of File. */
  int EOF = 0;
  /** RegularExpression Id. */
  int LBRACKET = 1;
  /** RegularExpression Id. */
  int RBRACKET = 2;
  /** RegularExpression Id. */
  int COMMA = 3;
  /** RegularExpression Id. */
  int DOUBLEDOT = 4;
  /** RegularExpression Id. */
  int COLON = 5;
  /** RegularExpression Id. */
  int LEFT_CURLEY = 6;
  /** RegularExpression Id. */
  int RIGHT_CURLEY = 7;
  /** RegularExpression Id. */
  int LPAREN = 8;
  /** RegularExpression Id. */
  int RPAREN = 9;
  /** RegularExpression Id. */
  int REFMOD2_RPAREN = 10;
  /** RegularExpression Id. */
  int ESCAPE_DIRECTIVE = 11;
  /** RegularExpression Id. */
  int SET_DIRECTIVE = 12;
  /** RegularExpression Id. */
  int DOLLAR = 13;
  /** RegularExpression Id. */
  int DOLLARBANG = 14;
  /** RegularExpression Id. */
  int HASH = 17;
  /** RegularExpression Id. */
  int SINGLE_LINE_COMMENT_START = 18;
  /** RegularExpression Id. */
  int DOUBLE_ESCAPE = 19;
  /** RegularExpression Id. */
  int ESCAPE = 20;
  /** RegularExpression Id. */
  int TEXT = 21;
  /** RegularExpression Id. */
  int SINGLE_LINE_COMMENT = 22;
  /** RegularExpression Id. */
  int FORMAL_COMMENT = 23;
  /** RegularExpression Id. */
  int MULTI_LINE_COMMENT = 24;
  /** RegularExpression Id. */
  int WHITESPACE = 26;
  /** RegularExpression Id. */
  int STRING_LITERAL = 27;
  /** RegularExpression Id. */
  int TRUE = 28;
  /** RegularExpression Id. */
  int FALSE = 29;
  /** RegularExpression Id. */
  int NEWLINE = 30;
  /** RegularExpression Id. */
  int MINUS = 31;
  /** RegularExpression Id. */
  int PLUS = 32;
  /** RegularExpression Id. */
  int MULTIPLY = 33;
  /** RegularExpression Id. */
  int DIVIDE = 34;
  /** RegularExpression Id. */
  int MODULUS = 35;
  /** RegularExpression Id. */
  int LOGICAL_AND = 36;
  /** RegularExpression Id. */
  int LOGICAL_OR = 37;
  /** RegularExpression Id. */
  int LOGICAL_LT = 38;
  /** RegularExpression Id. */
  int LOGICAL_LE = 39;
  /** RegularExpression Id. */
  int LOGICAL_GT = 40;
  /** RegularExpression Id. */
  int LOGICAL_GE = 41;
  /** RegularExpression Id. */
  int LOGICAL_EQUALS = 42;
  /** RegularExpression Id. */
  int LOGICAL_NOT_EQUALS = 43;
  /** RegularExpression Id. */
  int LOGICAL_NOT = 44;
  /** RegularExpression Id. */
  int EQUALS = 45;
  /** RegularExpression Id. */
  int END = 46;
  /** RegularExpression Id. */
  int IF_DIRECTIVE = 47;
  /** RegularExpression Id. */
  int ELSEIF_DIRECTIVE = 48;
  /** RegularExpression Id. */
  int ELSE_DIRECTIVE = 49;
  /** RegularExpression Id. */
  int STOP_DIRECTIVE = 50;
  /** RegularExpression Id. */
  int DIGIT = 51;
  /** RegularExpression Id. */
  int INTEGER_LITERAL = 52;
  /** RegularExpression Id. */
  int FLOATING_POINT_LITERAL = 53;
  /** RegularExpression Id. */
  int EXPONENT = 54;
  /** RegularExpression Id. */
  int LETTER = 55;
  /** RegularExpression Id. */
  int DIRECTIVE_CHAR = 56;
  /** RegularExpression Id. */
  int WORD = 57;
  /** RegularExpression Id. */
  int BRACKETED_WORD = 58;
  /** RegularExpression Id. */
  int ALPHA_CHAR = 59;
  /** RegularExpression Id. */
  int ALPHANUM_CHAR = 60;
  /** RegularExpression Id. */
  int IDENTIFIER_CHAR = 61;
  /** RegularExpression Id. */
  int IDENTIFIER = 62;
  /** RegularExpression Id. */
  int DOT = 63;
  /** RegularExpression Id. */
  int LCURLY = 64;
  /** RegularExpression Id. */
  int RCURLY = 65;
  /** RegularExpression Id. */
  int REFERENCE_TERMINATOR = 66;
  /** RegularExpression Id. */
  int DIRECTIVE_TERMINATOR = 67;
  /** Lexical state. */
  int DIRECTIVE = 0;
  /** Lexical state. */
  int REFMOD2 = 1;
  /** Lexical state. */
  int REFMODIFIER = 2;
  /** Lexical state. */
  int DEFAULT = 3;
  /** Lexical state. */
  int REFERENCE = 4;
  /** Lexical state. */
  int PRE_DIRECTIVE = 5;
  /** Lexical state. */
  int IN_MULTI_LINE_COMMENT = 6;
  /** Lexical state. */
  int IN_FORMAL_COMMENT = 7;
  /** Lexical state. */
  int IN_SINGLE_LINE_COMMENT = 8;
  /** Literal token values. */
  String[] tokenImage = {
    ""<EOF>"",
    ""\""[\"""",
    ""\""]\"""",
    ""\"",\"""",
    ""\""..\"""",
    ""\"":\"""",
    ""\""{\"""",
    ""\""}\"""",
    ""\""(\"""",
    ""<RPAREN>"",
    ""\"")\"""",
    ""<ESCAPE_DIRECTIVE>"",
    ""<SET_DIRECTIVE>"",
    ""<DOLLAR>"",
    ""<DOLLARBANG>"",
    ""<token of kind 15>"",
    ""\""#*\"""",
    ""\""#\"""",
    ""\""##\"""",
    ""\""\\\\\\\\\"""",
    ""\""\\\\\"""",
    ""<TEXT>"",
    ""<SINGLE_LINE_COMMENT>"",
    ""\""*#\"""",
    ""\""*#\"""",
    ""<token of kind 25>"",
    ""<WHITESPACE>"",
    ""<STRING_LITERAL>"",
    ""\""true\"""",
    ""\""false\"""",
    ""<NEWLINE>"",
    ""\""-\"""",
    ""\""+\"""",
    ""\""*\"""",
    ""\""/\"""",
    ""\""%\"""",
    ""<LOGICAL_AND>"",
    ""<LOGICAL_OR>"",
    ""<LOGICAL_LT>"",
    ""<LOGICAL_LE>"",
    ""<LOGICAL_GT>"",
    ""<LOGICAL_GE>"",
    ""<LOGICAL_EQUALS>"",
    ""<LOGICAL_NOT_EQUALS>"",
    ""<LOGICAL_NOT>"",
    ""\""=\"""",
    ""<END>"",
    ""<IF_DIRECTIVE>"",
    ""<ELSEIF_DIRECTIVE>"",
    ""<ELSE_DIRECTIVE>"",
    ""<STOP_DIRECTIVE>"",
    ""<DIGIT>"",
    ""<INTEGER_LITERAL>"",
    ""<FLOATING_POINT_LITERAL>"",
    ""<EXPONENT>"",
    ""<LETTER>"",
    ""<DIRECTIVE_CHAR>"",
    ""<WORD>"",
    ""<BRACKETED_WORD>"",
    ""<ALPHA_CHAR>"",
    ""<ALPHANUM_CHAR>"",
    ""<IDENTIFIER_CHAR>"",
    ""<IDENTIFIER>"",
    ""<DOT>"",
    ""\""{\"""",
    ""\""}\"""",
    ""<REFERENCE_TERMINATOR>"",
    ""<DIRECTIVE_TERMINATOR>"",
  };
}
"
org.apache.velocity.runtime.parser.ParserTokenManager,"/* Generated By:JJTree&JavaCC: Do not edit this line. ParserTokenManager.java */
package org.apache.velocity.runtime.parser;
import java.io.*;
import java.util.*;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.parser.node.*;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.directive.Macro;
import org.apache.velocity.runtime.directive.MacroParseException;
import org.apache.velocity.util.StringUtils;
/** Token Manager. */
public class ParserTokenManager implements ParserConstants
{
    private int fileDepth = 0;
    private int lparen = 0;
    private int rparen = 0;
    Stack stateStack = new Stack();
    public boolean debugPrint = false;
    private boolean inReference;
    public boolean inDirective;
    private boolean inComment;
    public  boolean inSet;
    /**
     *  pushes the current state onto the 'state stack',
     *  and maintains the parens counts
     *  public because we need it in PD & VM handling
     *
     *  @return boolean : success.  It can fail if the state machine
     *     gets messed up (do don't mess it up :)
     */
    public boolean stateStackPop()
    {
        Hashtable h;
        try
        {
            h = (Hashtable) stateStack.pop();
        }
        catch( EmptyStackException e)
        {
            lparen=0;
            SwitchTo(DEFAULT);
            return false;
        }
        if( debugPrint )
            System.out.println(
                "" stack pop ("" + stateStack.size() + "") : lparen="" +
                    ( (Integer) h.get(""lparen"")).intValue() +
                        "" newstate="" + ( (Integer) h.get(""lexstate"")).intValue() );
        lparen = ( (Integer) h.get(""lparen"")).intValue();
        rparen = ( (Integer) h.get(""rparen"")).intValue();
        SwitchTo( ( (Integer) h.get(""lexstate"")).intValue() );
        return true;
    }
    /**
     *  pops a state off the stack, and restores paren counts
     *
     *  @return boolean : success of operation
     */
    public boolean stateStackPush()
    {
        if( debugPrint )
            System.out.println("" ("" + stateStack.size() + "") pushing cur state : "" +
                curLexState );
        Hashtable h = new Hashtable();
        h.put(""lexstate"", new Integer( curLexState ) );
        h.put(""lparen"", new Integer( lparen ));
        h.put(""rparen"", new Integer( rparen ));
        lparen = 0;
        stateStack.push( h );
        return true;
    }
    /**
     *  Clears all state variables, resets to
     *  start values, clears stateStack.  Call
     *  before parsing.
     *  @return void
     */
    public void clearStateVars()
    {
        stateStack.clear();
        lparen = 0;
        rparen = 0;
        inReference = false;
        inDirective = false;
        inComment = false;
        inSet = false;
        return;
    }
    /**
     *  handles the dropdown logic when encountering a RPAREN
     */
    private void RPARENHandler()
    {
        /*
         *  Ultimately, we want to drop down to the state below
         *  the one that has an open (if we hit bottom (DEFAULT),
         *  that's fine. It's just text schmoo.
         */
        boolean closed = false;
        if (inComment)
            closed = true;
        while( !closed )
        {
            /*
             * look at current state.  If we haven't seen a lparen
             * in this state then we drop a state, because this
             * lparen clearly closes our state
             */
            if( lparen > 0)
            {
                /*
                 *  if rparen + 1 == lparen, then this state is closed.
                 * Otherwise, increment and keep parsing
                 */
                 if( lparen == rparen + 1)
                 {
                       stateStackPop();
                 }
                else
                {
                    rparen++;
                }
                 closed = true;
            }
            else
            {
                /*
                 * now, drop a state
                 */
                if(!stateStackPop())
                    break;
            }
        }
    }
  /** Debug output. */
  public  java.io.PrintStream debugStream = System.out;
  /** Set debug output. */
  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
private final int jjStopStringLiteralDfa_0(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x10L) != 0L)
            return 58;
         if ((active0 & 0x80000000L) != 0L)
            return 101;
         if ((active0 & 0x40L) != 0L)
            return 65;
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 57;
            return 63;
         }
         if ((active0 & 0x200000000000L) != 0L)
            return 50;
         if ((active0 & 0x70000L) != 0L)
            return 7;
         return -1;
      case 1:
         if ((active0 & 0x10000L) != 0L)
            return 5;
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 57;
            jjmatchedPos = 1;
            return 63;
         }
         return -1;
      case 2:
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 57;
            jjmatchedPos = 2;
            return 63;
         }
         return -1;
      case 3:
         if ((active0 & 0x10000000L) != 0L)
            return 63;
         if ((active0 & 0x20000000L) != 0L)
         {
            jjmatchedKind = 57;
            jjmatchedPos = 3;
            return 63;
         }
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_0(int pos, long active0)
{
   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
}
private int jjStopAtPos(int pos, int kind)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   return pos + 1;
}
private int jjMoveStringLiteralDfa0_0()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 17;
         return jjMoveStringLiteralDfa1_0(0x50000L);
      case 37:
         return jjStopAtPos(0, 35);
      case 40:
         return jjStopAtPos(0, 8);
      case 42:
         return jjStopAtPos(0, 33);
      case 43:
         return jjStopAtPos(0, 32);
      case 44:
         return jjStopAtPos(0, 3);
      case 45:
         return jjStartNfaWithStates_0(0, 31, 101);
      case 46:
         return jjMoveStringLiteralDfa1_0(0x10L);
      case 47:
         return jjStopAtPos(0, 34);
      case 58:
         return jjStopAtPos(0, 5);
      case 61:
         return jjStartNfaWithStates_0(0, 45, 50);
      case 91:
         return jjStopAtPos(0, 1);
      case 93:
         return jjStopAtPos(0, 2);
      case 102:
         return jjMoveStringLiteralDfa1_0(0x20000000L);
      case 116:
         return jjMoveStringLiteralDfa1_0(0x10000000L);
      case 123:
         return jjStartNfaWithStates_0(0, 6, 65);
      case 125:
         return jjStopAtPos(0, 7);
      default :
         return jjMoveNfa_0(0, 0);
   }
}
private int jjMoveStringLiteralDfa1_0(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x40000L) != 0L)
            return jjStopAtPos(1, 18);
         break;
      case 42:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_0(1, 16, 5);
         break;
      case 46:
         if ((active0 & 0x10L) != 0L)
            return jjStopAtPos(1, 4);
         break;
      case 97:
         return jjMoveStringLiteralDfa2_0(active0, 0x20000000L);
      case 114:
         return jjMoveStringLiteralDfa2_0(active0, 0x10000000L);
      default :
         break;
   }
   return jjStartNfa_0(0, active0);
}
private int jjMoveStringLiteralDfa2_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(0, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(1, active0);
      return 2;
   }
   switch(curChar)
   {
      case 108:
         return jjMoveStringLiteralDfa3_0(active0, 0x20000000L);
      case 117:
         return jjMoveStringLiteralDfa3_0(active0, 0x10000000L);
      default :
         break;
   }
   return jjStartNfa_0(1, active0);
}
private int jjMoveStringLiteralDfa3_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(1, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(2, active0);
      return 3;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x10000000L) != 0L)
            return jjStartNfaWithStates_0(3, 28, 63);
         break;
      case 115:
         return jjMoveStringLiteralDfa4_0(active0, 0x20000000L);
      default :
         break;
   }
   return jjStartNfa_0(2, active0);
}
private int jjMoveStringLiteralDfa4_0(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_0(2, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(3, active0);
      return 4;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x20000000L) != 0L)
            return jjStartNfaWithStates_0(4, 29, 63);
         break;
      default :
         break;
   }
   return jjStartNfa_0(3, active0);
}
private int jjStartNfaWithStates_0(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_0(state, pos + 1);
}
static final long[] jjbitVec0 = {
   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
};
static final long[] jjbitVec2 = {
   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
};
private int jjMoveNfa_0(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 101;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 52)
                        kind = 52;
                     jjCheckNAddStates(0, 5);
                  }
                  else if ((0x100002600L & l) != 0L)
                  {
                     if (kind > 26)
                        kind = 26;
                     jjCheckNAdd(9);
                  }
                  else if (curChar == 45)
                     jjCheckNAddStates(6, 9);
                  else if (curChar == 36)
                  {
                     if (kind > 13)
                        kind = 13;
                     jjCheckNAddTwoStates(73, 74);
                  }
                  else if (curChar == 46)
                     jjCheckNAdd(58);
                  else if (curChar == 33)
                  {
                     if (kind > 44)
                        kind = 44;
                  }
                  else if (curChar == 61)
                     jjstateSet[jjnewStateCnt++] = 50;
                  else if (curChar == 62)
                     jjstateSet[jjnewStateCnt++] = 48;
                  else if (curChar == 60)
                     jjstateSet[jjnewStateCnt++] = 45;
                  else if (curChar == 38)
                     jjstateSet[jjnewStateCnt++] = 35;
                  else if (curChar == 39)
                     jjCheckNAddStates(10, 12);
                  else if (curChar == 34)
                     jjCheckNAddStates(13, 15);
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 7;
                  else if (curChar == 41)
                  {
                     if (kind > 9)
                        kind = 9;
                     jjCheckNAddStates(16, 18);
                  }
                  if ((0x2400L & l) != 0L)
                  {
                     if (kind > 30)
                        kind = 30;
                  }
                  else if (curChar == 33)
                     jjstateSet[jjnewStateCnt++] = 54;
                  else if (curChar == 62)
                  {
                     if (kind > 40)
                        kind = 40;
                  }
                  else if (curChar == 60)
                  {
                     if (kind > 38)
                        kind = 38;
                  }
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 33;
                  break;
               case 101:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(96, 97);
                  else if (curChar == 46)
                     jjCheckNAdd(58);
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(90, 91);
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 52)
                        kind = 52;
                     jjCheckNAddTwoStates(87, 89);
                  }
                  break;
               case 1:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddStates(16, 18);
                  break;
               case 2:
                  if ((0x2400L & l) != 0L && kind > 9)
                     kind = 9;
                  break;
               case 3:
                  if (curChar == 10 && kind > 9)
                     kind = 9;
                  break;
               case 4:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 3;
                  break;
               case 5:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 6;
                  break;
               case 6:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 15)
                     kind = 15;
                  break;
               case 7:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 8:
                  if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 7;
                  break;
               case 9:
                  if ((0x100002600L & l) == 0L)
                     break;
                  if (kind > 26)
                     kind = 26;
                  jjCheckNAdd(9);
                  break;
               case 10:
                  if (curChar == 34)
                     jjCheckNAddStates(13, 15);
                  break;
               case 11:
                  if ((0xfffffffbffffffffL & l) != 0L)
                     jjCheckNAddStates(13, 15);
                  break;
               case 12:
                  if (curChar == 34 && kind > 27)
                     kind = 27;
                  break;
               case 14:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAddStates(13, 15);
                  break;
               case 15:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(19, 22);
                  break;
               case 16:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(13, 15);
                  break;
               case 17:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 18;
                  break;
               case 18:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(16);
                  break;
               case 20:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 21;
                  break;
               case 21:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 22;
                  break;
               case 22:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 23;
                  break;
               case 23:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddStates(13, 15);
                  break;
               case 24:
                  if (curChar == 32)
                     jjAddStates(23, 24);
                  break;
               case 25:
                  if (curChar == 10)
                     jjCheckNAddStates(13, 15);
                  break;
               case 26:
                  if (curChar == 39)
                     jjCheckNAddStates(10, 12);
                  break;
               case 27:
                  if ((0xffffff7fffffffffL & l) != 0L)
                     jjCheckNAddStates(10, 12);
                  break;
               case 29:
                  if (curChar == 32)
                     jjAddStates(25, 26);
                  break;
               case 30:
                  if (curChar == 10)
                     jjCheckNAddStates(10, 12);
                  break;
               case 31:
                  if (curChar == 39 && kind > 27)
                     kind = 27;
                  break;
               case 32:
                  if ((0x2400L & l) != 0L && kind > 30)
                     kind = 30;
                  break;
               case 33:
                  if (curChar == 10 && kind > 30)
                     kind = 30;
                  break;
               case 34:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 33;
                  break;
               case 35:
                  if (curChar == 38 && kind > 36)
                     kind = 36;
                  break;
               case 36:
                  if (curChar == 38)
                     jjstateSet[jjnewStateCnt++] = 35;
                  break;
               case 44:
                  if (curChar == 60 && kind > 38)
                     kind = 38;
                  break;
               case 45:
                  if (curChar == 61 && kind > 39)
                     kind = 39;
                  break;
               case 46:
                  if (curChar == 60)
                     jjstateSet[jjnewStateCnt++] = 45;
                  break;
               case 47:
                  if (curChar == 62 && kind > 40)
                     kind = 40;
                  break;
               case 48:
                  if (curChar == 61 && kind > 41)
                     kind = 41;
                  break;
               case 49:
                  if (curChar == 62)
                     jjstateSet[jjnewStateCnt++] = 48;
                  break;
               case 50:
                  if (curChar == 61 && kind > 42)
                     kind = 42;
                  break;
               case 51:
                  if (curChar == 61)
                     jjstateSet[jjnewStateCnt++] = 50;
                  break;
               case 54:
                  if (curChar == 61 && kind > 43)
                     kind = 43;
                  break;
               case 55:
                  if (curChar == 33)
                     jjstateSet[jjnewStateCnt++] = 54;
                  break;
               case 56:
                  if (curChar == 33 && kind > 44)
                     kind = 44;
                  break;
               case 57:
                  if (curChar == 46)
                     jjCheckNAdd(58);
                  break;
               case 58:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAddTwoStates(58, 59);
                  break;
               case 60:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(61);
                  break;
               case 61:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAdd(61);
                  break;
               case 63:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 57)
                     kind = 57;
                  jjstateSet[jjnewStateCnt++] = 63;
                  break;
               case 66:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjAddStates(27, 28);
                  break;
               case 70:
                  if (curChar == 36 && kind > 13)
                     kind = 13;
                  break;
               case 72:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(73, 74);
                  break;
               case 74:
                  if (curChar == 33 && kind > 14)
                     kind = 14;
                  break;
               case 75:
                  if (curChar != 36)
                     break;
                  if (kind > 13)
                     kind = 13;
                  jjCheckNAddTwoStates(73, 74);
                  break;
               case 86:
                  if (curChar == 45)
                     jjCheckNAddStates(6, 9);
                  break;
               case 87:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAddTwoStates(87, 89);
                  break;
               case 88:
                  if (curChar == 46 && kind > 52)
                     kind = 52;
                  break;
               case 89:
                  if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 88;
                  break;
               case 90:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(90, 91);
                  break;
               case 91:
                  if (curChar != 46)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAddTwoStates(92, 93);
                  break;
               case 92:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAddTwoStates(92, 93);
                  break;
               case 94:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(95);
                  break;
               case 95:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAdd(95);
                  break;
               case 96:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(96, 97);
                  break;
               case 98:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(99);
                  break;
               case 99:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAdd(99);
                  break;
               case 100:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAddStates(0, 5);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 0:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 57)
                        kind = 57;
                     jjCheckNAdd(63);
                  }
                  else if (curChar == 92)
                     jjCheckNAddStates(29, 32);
                  else if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 65;
                  else if (curChar == 124)
                     jjstateSet[jjnewStateCnt++] = 40;
                  if (curChar == 110)
                     jjAddStates(33, 34);
                  else if (curChar == 103)
                     jjAddStates(35, 36);
                  else if (curChar == 108)
                     jjAddStates(37, 38);
                  else if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 52;
                  else if (curChar == 111)
                     jjstateSet[jjnewStateCnt++] = 42;
                  else if (curChar == 97)
                     jjstateSet[jjnewStateCnt++] = 38;
                  break;
               case 6:
                  if (kind > 15)
                     kind = 15;
                  break;
               case 11:
                  jjCheckNAddStates(13, 15);
                  break;
               case 13:
                  if (curChar == 92)
                     jjAddStates(39, 44);
                  break;
               case 14:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAddStates(13, 15);
                  break;
               case 19:
                  if (curChar == 117)
                     jjstateSet[jjnewStateCnt++] = 20;
                  break;
               case 20:
                  if ((0x7e0000007eL & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 21;
                  break;
               case 21:
                  if ((0x7e0000007eL & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 22;
                  break;
               case 22:
                  if ((0x7e0000007eL & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 23;
                  break;
               case 23:
                  if ((0x7e0000007eL & l) != 0L)
                     jjCheckNAddStates(13, 15);
                  break;
               case 27:
                  jjAddStates(10, 12);
                  break;
               case 28:
                  if (curChar == 92)
                     jjAddStates(25, 26);
                  break;
               case 37:
                  if (curChar == 100 && kind > 36)
                     kind = 36;
                  break;
               case 38:
                  if (curChar == 110)
                     jjstateSet[jjnewStateCnt++] = 37;
                  break;
               case 39:
                  if (curChar == 97)
                     jjstateSet[jjnewStateCnt++] = 38;
                  break;
               case 40:
                  if (curChar == 124 && kind > 37)
                     kind = 37;
                  break;
               case 41:
                  if (curChar == 124)
                     jjstateSet[jjnewStateCnt++] = 40;
                  break;
               case 42:
                  if (curChar == 114 && kind > 37)
                     kind = 37;
                  break;
               case 43:
                  if (curChar == 111)
                     jjstateSet[jjnewStateCnt++] = 42;
                  break;
               case 52:
                  if (curChar == 113 && kind > 42)
                     kind = 42;
                  break;
               case 53:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 52;
                  break;
               case 59:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(45, 46);
                  break;
               case 62:
               case 63:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 57)
                     kind = 57;
                  jjCheckNAdd(63);
                  break;
               case 64:
                  if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 65;
                  break;
               case 65:
               case 66:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                     jjCheckNAddTwoStates(66, 67);
                  break;
               case 67:
                  if (curChar == 125 && kind > 58)
                     kind = 58;
                  break;
               case 68:
                  if (curChar == 92)
                     jjCheckNAddStates(29, 32);
                  break;
               case 69:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(69, 70);
                  break;
               case 71:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(71, 72);
                  break;
               case 73:
                  if (curChar == 92)
                     jjAddStates(47, 48);
                  break;
               case 76:
                  if (curChar == 108)
                     jjAddStates(37, 38);
                  break;
               case 77:
                  if (curChar == 116 && kind > 38)
                     kind = 38;
                  break;
               case 78:
                  if (curChar == 101 && kind > 39)
                     kind = 39;
                  break;
               case 79:
                  if (curChar == 103)
                     jjAddStates(35, 36);
                  break;
               case 80:
                  if (curChar == 116 && kind > 40)
                     kind = 40;
                  break;
               case 81:
                  if (curChar == 101 && kind > 41)
                     kind = 41;
                  break;
               case 82:
                  if (curChar == 110)
                     jjAddStates(33, 34);
                  break;
               case 83:
                  if (curChar == 101 && kind > 43)
                     kind = 43;
                  break;
               case 84:
                  if (curChar == 116 && kind > 44)
                     kind = 44;
                  break;
               case 85:
                  if (curChar == 111)
                     jjstateSet[jjnewStateCnt++] = 84;
                  break;
               case 93:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(49, 50);
                  break;
               case 97:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(51, 52);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 6:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 15)
                     kind = 15;
                  break;
               case 11:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(13, 15);
                  break;
               case 27:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(10, 12);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 101 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_6(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x70000L) != 0L)
            return 2;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_6(int pos, long active0)
{
   return jjMoveNfa_6(jjStopStringLiteralDfa_6(pos, active0), pos + 1);
}
private int jjMoveStringLiteralDfa0_6()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 17;
         return jjMoveStringLiteralDfa1_6(0x50000L);
      case 42:
         return jjMoveStringLiteralDfa1_6(0x1000000L);
      default :
         return jjMoveNfa_6(3, 0);
   }
}
private int jjMoveStringLiteralDfa1_6(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_6(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x40000L) != 0L)
            return jjStopAtPos(1, 18);
         else if ((active0 & 0x1000000L) != 0L)
            return jjStopAtPos(1, 24);
         break;
      case 42:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_6(1, 16, 0);
         break;
      default :
         break;
   }
   return jjStartNfa_6(0, active0);
}
private int jjStartNfaWithStates_6(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_6(state, pos + 1);
}
private int jjMoveNfa_6(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 12;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 36)
                  {
                     if (kind > 13)
                        kind = 13;
                     jjCheckNAddTwoStates(9, 10);
                  }
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 0:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 15)
                     kind = 15;
                  break;
               case 2:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 6:
                  if (curChar == 36 && kind > 13)
                     kind = 13;
                  break;
               case 8:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(9, 10);
                  break;
               case 10:
                  if (curChar == 33 && kind > 14)
                     kind = 14;
                  break;
               case 11:
                  if (curChar != 36)
                     break;
                  if (kind > 13)
                     kind = 13;
                  jjCheckNAddTwoStates(9, 10);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 92)
                     jjCheckNAddStates(53, 56);
                  break;
               case 1:
                  if (kind > 15)
                     kind = 15;
                  break;
               case 5:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(5, 6);
                  break;
               case 7:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(7, 8);
                  break;
               case 9:
                  if (curChar == 92)
                     jjAddStates(57, 58);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 12 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_5(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x70000L) != 0L)
            return 2;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_5(int pos, long active0)
{
   return jjMoveNfa_5(jjStopStringLiteralDfa_5(pos, active0), pos + 1);
}
private int jjMoveStringLiteralDfa0_5()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 17;
         return jjMoveStringLiteralDfa1_5(0x50000L);
      default :
         return jjMoveNfa_5(3, 0);
   }
}
private int jjMoveStringLiteralDfa1_5(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_5(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x40000L) != 0L)
            return jjStopAtPos(1, 18);
         break;
      case 42:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_5(1, 16, 0);
         break;
      default :
         break;
   }
   return jjStartNfa_5(0, active0);
}
private int jjStartNfaWithStates_5(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_5(state, pos + 1);
}
private int jjMoveNfa_5(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 92;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 52)
                        kind = 52;
                     jjCheckNAddStates(59, 64);
                  }
                  else if (curChar == 45)
                     jjCheckNAddStates(65, 68);
                  else if (curChar == 36)
                  {
                     if (kind > 13)
                        kind = 13;
                     jjCheckNAddTwoStates(26, 27);
                  }
                  else if (curChar == 46)
                     jjCheckNAdd(11);
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 0:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 15)
                     kind = 15;
                  break;
               case 2:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 10:
                  if (curChar == 46)
                     jjCheckNAdd(11);
                  break;
               case 11:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAddTwoStates(11, 12);
                  break;
               case 13:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(14);
                  break;
               case 14:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAdd(14);
                  break;
               case 16:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 57)
                     kind = 57;
                  jjstateSet[jjnewStateCnt++] = 16;
                  break;
               case 19:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjAddStates(69, 70);
                  break;
               case 23:
                  if (curChar == 36 && kind > 13)
                     kind = 13;
                  break;
               case 25:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(26, 27);
                  break;
               case 27:
                  if (curChar == 33 && kind > 14)
                     kind = 14;
                  break;
               case 28:
                  if (curChar != 36)
                     break;
                  if (kind > 13)
                     kind = 13;
                  jjCheckNAddTwoStates(26, 27);
                  break;
               case 31:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddStates(71, 73);
                  break;
               case 32:
                  if ((0x2400L & l) != 0L && kind > 46)
                     kind = 46;
                  break;
               case 33:
                  if (curChar == 10 && kind > 46)
                     kind = 46;
                  break;
               case 34:
               case 51:
                  if (curChar == 13)
                     jjCheckNAdd(33);
                  break;
               case 42:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddStates(74, 76);
                  break;
               case 43:
                  if ((0x2400L & l) != 0L && kind > 49)
                     kind = 49;
                  break;
               case 44:
                  if (curChar == 10 && kind > 49)
                     kind = 49;
                  break;
               case 45:
               case 67:
                  if (curChar == 13)
                     jjCheckNAdd(44);
                  break;
               case 50:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddStates(77, 79);
                  break;
               case 66:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddStates(80, 82);
                  break;
               case 77:
                  if (curChar == 45)
                     jjCheckNAddStates(65, 68);
                  break;
               case 78:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAddTwoStates(78, 80);
                  break;
               case 79:
                  if (curChar == 46 && kind > 52)
                     kind = 52;
                  break;
               case 80:
                  if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 79;
                  break;
               case 81:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(81, 82);
                  break;
               case 82:
                  if (curChar != 46)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAddTwoStates(83, 84);
                  break;
               case 83:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAddTwoStates(83, 84);
                  break;
               case 85:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(86);
                  break;
               case 86:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAdd(86);
                  break;
               case 87:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(87, 88);
                  break;
               case 89:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(90);
                  break;
               case 90:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAdd(90);
                  break;
               case 91:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAddStates(59, 64);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 57)
                        kind = 57;
                     jjCheckNAdd(16);
                  }
                  else if (curChar == 123)
                     jjAddStates(83, 87);
                  else if (curChar == 92)
                     jjCheckNAddStates(88, 91);
                  if (curChar == 101)
                     jjAddStates(92, 94);
                  else if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 18;
                  else if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 8;
                  else if (curChar == 105)
                     jjstateSet[jjnewStateCnt++] = 4;
                  break;
               case 1:
                  if (kind > 15)
                     kind = 15;
                  break;
               case 4:
                  if (curChar == 102 && kind > 47)
                     kind = 47;
                  break;
               case 5:
                  if (curChar == 105)
                     jjstateSet[jjnewStateCnt++] = 4;
                  break;
               case 6:
                  if (curChar == 112 && kind > 50)
                     kind = 50;
                  break;
               case 7:
                  if (curChar == 111)
                     jjstateSet[jjnewStateCnt++] = 6;
                  break;
               case 8:
                  if (curChar == 116)
                     jjstateSet[jjnewStateCnt++] = 7;
                  break;
               case 9:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 8;
                  break;
               case 12:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(95, 96);
                  break;
               case 15:
               case 16:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 57)
                     kind = 57;
                  jjCheckNAdd(16);
                  break;
               case 17:
                  if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 18;
                  break;
               case 18:
               case 19:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                     jjCheckNAddTwoStates(19, 20);
                  break;
               case 20:
                  if (curChar == 125 && kind > 58)
                     kind = 58;
                  break;
               case 21:
                  if (curChar == 92)
                     jjCheckNAddStates(88, 91);
                  break;
               case 22:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(22, 23);
                  break;
               case 24:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(24, 25);
                  break;
               case 26:
                  if (curChar == 92)
                     jjAddStates(97, 98);
                  break;
               case 29:
                  if (curChar == 101)
                     jjAddStates(92, 94);
                  break;
               case 30:
                  if (curChar != 100)
                     break;
                  if (kind > 46)
                     kind = 46;
                  jjCheckNAddStates(71, 73);
                  break;
               case 35:
                  if (curChar == 110)
                     jjstateSet[jjnewStateCnt++] = 30;
                  break;
               case 36:
                  if (curChar == 102 && kind > 48)
                     kind = 48;
                  break;
               case 37:
                  if (curChar == 105)
                     jjstateSet[jjnewStateCnt++] = 36;
                  break;
               case 38:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 37;
                  break;
               case 39:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 38;
                  break;
               case 40:
                  if (curChar == 108)
                     jjstateSet[jjnewStateCnt++] = 39;
                  break;
               case 41:
                  if (curChar != 101)
                     break;
                  if (kind > 49)
                     kind = 49;
                  jjCheckNAddStates(74, 76);
                  break;
               case 46:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 41;
                  break;
               case 47:
                  if (curChar == 108)
                     jjstateSet[jjnewStateCnt++] = 46;
                  break;
               case 48:
                  if (curChar == 123)
                     jjAddStates(83, 87);
                  break;
               case 49:
                  if (curChar != 125)
                     break;
                  if (kind > 46)
                     kind = 46;
                  jjCheckNAddStates(77, 79);
                  break;
               case 52:
                  if (curChar == 100)
                     jjstateSet[jjnewStateCnt++] = 49;
                  break;
               case 53:
                  if (curChar == 110)
                     jjstateSet[jjnewStateCnt++] = 52;
                  break;
               case 54:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 53;
                  break;
               case 55:
                  if (curChar == 125 && kind > 47)
                     kind = 47;
                  break;
               case 56:
                  if (curChar == 102)
                     jjstateSet[jjnewStateCnt++] = 55;
                  break;
               case 57:
                  if (curChar == 105)
                     jjstateSet[jjnewStateCnt++] = 56;
                  break;
               case 58:
                  if (curChar == 125 && kind > 48)
                     kind = 48;
                  break;
               case 59:
                  if (curChar == 102)
                     jjstateSet[jjnewStateCnt++] = 58;
                  break;
               case 60:
                  if (curChar == 105)
                     jjstateSet[jjnewStateCnt++] = 59;
                  break;
               case 61:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 60;
                  break;
               case 62:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 61;
                  break;
               case 63:
                  if (curChar == 108)
                     jjstateSet[jjnewStateCnt++] = 62;
                  break;
               case 64:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 63;
                  break;
               case 65:
                  if (curChar != 125)
                     break;
                  if (kind > 49)
                     kind = 49;
                  jjCheckNAddStates(80, 82);
                  break;
               case 68:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 65;
                  break;
               case 69:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 68;
                  break;
               case 70:
                  if (curChar == 108)
                     jjstateSet[jjnewStateCnt++] = 69;
                  break;
               case 71:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 70;
                  break;
               case 72:
                  if (curChar == 125 && kind > 50)
                     kind = 50;
                  break;
               case 73:
                  if (curChar == 112)
                     jjstateSet[jjnewStateCnt++] = 72;
                  break;
               case 74:
                  if (curChar == 111)
                     jjstateSet[jjnewStateCnt++] = 73;
                  break;
               case 75:
                  if (curChar == 116)
                     jjstateSet[jjnewStateCnt++] = 74;
                  break;
               case 76:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 75;
                  break;
               case 84:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(99, 100);
                  break;
               case 88:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(101, 102);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 92 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_3(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x180000L) != 0L)
            return 14;
         if ((active0 & 0x70000L) != 0L)
            return 33;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_3(int pos, long active0)
{
   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
}
private int jjMoveStringLiteralDfa0_3()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 17;
         return jjMoveStringLiteralDfa1_3(0x50000L);
      case 92:
         jjmatchedKind = 20;
         return jjMoveStringLiteralDfa1_3(0x80000L);
      default :
         return jjMoveNfa_3(22, 0);
   }
}
private int jjMoveStringLiteralDfa1_3(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_3(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x40000L) != 0L)
            return jjStopAtPos(1, 18);
         break;
      case 42:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_3(1, 16, 31);
         break;
      case 92:
         if ((active0 & 0x80000L) != 0L)
            return jjStartNfaWithStates_3(1, 19, 34);
         break;
      default :
         break;
   }
   return jjStartNfa_3(0, active0);
}
private int jjStartNfaWithStates_3(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_3(state, pos + 1);
}
private int jjMoveNfa_3(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 34;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 22:
                  if ((0xffffffe7ffffffffL & l) != 0L)
                  {
                     if (kind > 21)
                        kind = 21;
                     jjCheckNAdd(12);
                  }
                  else if (curChar == 35)
                     jjCheckNAddStates(103, 105);
                  else if (curChar == 36)
                  {
                     if (kind > 13)
                        kind = 13;
                     jjCheckNAddTwoStates(27, 28);
                  }
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddTwoStates(0, 1);
                  break;
               case 14:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(27, 28);
                  else if (curChar == 35)
                     jjAddStates(106, 107);
                  if (curChar == 36)
                  {
                     if (kind > 13)
                        kind = 13;
                  }
                  break;
               case 34:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(27, 28);
                  if (curChar == 36)
                  {
                     if (kind > 13)
                        kind = 13;
                  }
                  break;
               case 33:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 31;
                  break;
               case 0:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddTwoStates(0, 1);
                  break;
               case 1:
                  if (curChar == 35)
                     jjCheckNAddTwoStates(6, 11);
                  break;
               case 3:
                  if (curChar == 32)
                     jjAddStates(108, 109);
                  break;
               case 4:
                  if (curChar == 40 && kind > 12)
                     kind = 12;
                  break;
               case 12:
                  if ((0xffffffe7ffffffffL & l) == 0L)
                     break;
                  if (kind > 21)
                     kind = 21;
                  jjCheckNAdd(12);
                  break;
               case 15:
                  if (curChar == 35)
                     jjAddStates(106, 107);
                  break;
               case 17:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 11)
                     kind = 11;
                  jjstateSet[jjnewStateCnt++] = 17;
                  break;
               case 20:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjAddStates(110, 111);
                  break;
               case 24:
                  if (curChar == 36 && kind > 13)
                     kind = 13;
                  break;
               case 26:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(27, 28);
                  break;
               case 28:
                  if (curChar == 33 && kind > 14)
                     kind = 14;
                  break;
               case 29:
                  if (curChar != 36)
                     break;
                  if (kind > 13)
                     kind = 13;
                  jjCheckNAddTwoStates(27, 28);
                  break;
               case 30:
                  if (curChar == 35)
                     jjCheckNAddStates(103, 105);
                  break;
               case 31:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 32;
                  break;
               case 32:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 22:
                  if ((0xffffffffefffffffL & l) != 0L)
                  {
                     if (kind > 21)
                        kind = 21;
                     jjCheckNAdd(12);
                  }
                  else if (curChar == 92)
                     jjCheckNAddStates(112, 115);
                  if (curChar == 92)
                     jjAddStates(116, 117);
                  break;
               case 14:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(25, 26);
                  if (curChar == 92)
                     jjCheckNAddTwoStates(23, 24);
                  if (curChar == 92)
                     jjstateSet[jjnewStateCnt++] = 13;
                  break;
               case 34:
                  if (curChar == 92)
                     jjAddStates(116, 117);
                  if (curChar == 92)
                     jjCheckNAddTwoStates(25, 26);
                  if (curChar == 92)
                     jjCheckNAddTwoStates(23, 24);
                  break;
               case 33:
                  if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 10;
                  else if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 2:
                  if (curChar == 116)
                     jjCheckNAddTwoStates(3, 4);
                  break;
               case 5:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 6:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 7:
                  if (curChar == 125)
                     jjCheckNAddTwoStates(3, 4);
                  break;
               case 8:
                  if (curChar == 116)
                     jjstateSet[jjnewStateCnt++] = 7;
                  break;
               case 9:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 8;
                  break;
               case 10:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 9;
                  break;
               case 11:
                  if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 10;
                  break;
               case 12:
                  if ((0xffffffffefffffffL & l) == 0L)
                     break;
                  if (kind > 21)
                     kind = 21;
                  jjCheckNAdd(12);
                  break;
               case 13:
                  if (curChar == 92)
                     jjAddStates(116, 117);
                  break;
               case 16:
               case 17:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 11)
                     kind = 11;
                  jjCheckNAdd(17);
                  break;
               case 18:
                  if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 19;
                  break;
               case 19:
               case 20:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                     jjCheckNAddTwoStates(20, 21);
                  break;
               case 21:
                  if (curChar == 125 && kind > 11)
                     kind = 11;
                  break;
               case 23:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(23, 24);
                  break;
               case 25:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(25, 26);
                  break;
               case 27:
                  if (curChar == 92)
                     jjAddStates(118, 119);
                  break;
               case 32:
                  if (kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 22:
               case 12:
                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                     break;
                  if (kind > 21)
                     kind = 21;
                  jjCheckNAdd(12);
                  break;
               case 32:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 34 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_7(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x70000L) != 0L)
            return 2;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_7(int pos, long active0)
{
   return jjMoveNfa_7(jjStopStringLiteralDfa_7(pos, active0), pos + 1);
}
private int jjMoveStringLiteralDfa0_7()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 17;
         return jjMoveStringLiteralDfa1_7(0x50000L);
      case 42:
         return jjMoveStringLiteralDfa1_7(0x800000L);
      default :
         return jjMoveNfa_7(3, 0);
   }
}
private int jjMoveStringLiteralDfa1_7(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_7(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x40000L) != 0L)
            return jjStopAtPos(1, 18);
         else if ((active0 & 0x800000L) != 0L)
            return jjStopAtPos(1, 23);
         break;
      case 42:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_7(1, 16, 0);
         break;
      default :
         break;
   }
   return jjStartNfa_7(0, active0);
}
private int jjStartNfaWithStates_7(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_7(state, pos + 1);
}
private int jjMoveNfa_7(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 12;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 36)
                  {
                     if (kind > 13)
                        kind = 13;
                     jjCheckNAddTwoStates(9, 10);
                  }
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 0:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 15)
                     kind = 15;
                  break;
               case 2:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 6:
                  if (curChar == 36 && kind > 13)
                     kind = 13;
                  break;
               case 8:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(9, 10);
                  break;
               case 10:
                  if (curChar == 33 && kind > 14)
                     kind = 14;
                  break;
               case 11:
                  if (curChar != 36)
                     break;
                  if (kind > 13)
                     kind = 13;
                  jjCheckNAddTwoStates(9, 10);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 92)
                     jjCheckNAddStates(53, 56);
                  break;
               case 1:
                  if (kind > 15)
                     kind = 15;
                  break;
               case 5:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(5, 6);
                  break;
               case 7:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(7, 8);
                  break;
               case 9:
                  if (curChar == 92)
                     jjAddStates(57, 58);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 12 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_8(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x70000L) != 0L)
            return 2;
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_8(int pos, long active0)
{
   return jjMoveNfa_8(jjStopStringLiteralDfa_8(pos, active0), pos + 1);
}
private int jjMoveStringLiteralDfa0_8()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 17;
         return jjMoveStringLiteralDfa1_8(0x50000L);
      default :
         return jjMoveNfa_8(3, 0);
   }
}
private int jjMoveStringLiteralDfa1_8(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_8(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x40000L) != 0L)
            return jjStopAtPos(1, 18);
         break;
      case 42:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_8(1, 16, 0);
         break;
      default :
         break;
   }
   return jjStartNfa_8(0, active0);
}
private int jjStartNfaWithStates_8(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_8(state, pos + 1);
}
private int jjMoveNfa_8(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 15;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if ((0x2400L & l) != 0L)
                  {
                     if (kind > 22)
                        kind = 22;
                  }
                  else if (curChar == 36)
                  {
                     if (kind > 13)
                        kind = 13;
                     jjCheckNAddTwoStates(12, 13);
                  }
                  else if (curChar == 35)
                     jjstateSet[jjnewStateCnt++] = 2;
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 0:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 1;
                  break;
               case 1:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 15)
                     kind = 15;
                  break;
               case 2:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 0;
                  break;
               case 4:
                  if ((0x2400L & l) != 0L && kind > 22)
                     kind = 22;
                  break;
               case 5:
                  if (curChar == 10 && kind > 22)
                     kind = 22;
                  break;
               case 6:
                  if (curChar == 13)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 9:
                  if (curChar == 36 && kind > 13)
                     kind = 13;
                  break;
               case 11:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(12, 13);
                  break;
               case 13:
                  if (curChar == 33 && kind > 14)
                     kind = 14;
                  break;
               case 14:
                  if (curChar != 36)
                     break;
                  if (kind > 13)
                     kind = 13;
                  jjCheckNAddTwoStates(12, 13);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 3:
                  if (curChar == 92)
                     jjCheckNAddStates(120, 123);
                  break;
               case 1:
                  if (kind > 15)
                     kind = 15;
                  break;
               case 8:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(8, 9);
                  break;
               case 10:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(10, 11);
                  break;
               case 12:
                  if (curChar == 92)
                     jjAddStates(124, 125);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 1:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 15 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_4(int pos, long active0, long active1)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x70000L) != 0L)
            return 27;
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 62;
            return 13;
         }
         return -1;
      case 1:
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 62;
            jjmatchedPos = 1;
            return 13;
         }
         if ((active0 & 0x10000L) != 0L)
            return 25;
         return -1;
      case 2:
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 62;
            jjmatchedPos = 2;
            return 13;
         }
         return -1;
      case 3:
         if ((active0 & 0x10000000L) != 0L)
            return 13;
         if ((active0 & 0x20000000L) != 0L)
         {
            jjmatchedKind = 62;
            jjmatchedPos = 3;
            return 13;
         }
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_4(int pos, long active0, long active1)
{
   return jjMoveNfa_4(jjStopStringLiteralDfa_4(pos, active0, active1), pos + 1);
}
private int jjMoveStringLiteralDfa0_4()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 17;
         return jjMoveStringLiteralDfa1_4(0x50000L);
      case 102:
         return jjMoveStringLiteralDfa1_4(0x20000000L);
      case 116:
         return jjMoveStringLiteralDfa1_4(0x10000000L);
      case 123:
         return jjStopAtPos(0, 64);
      case 125:
         return jjStopAtPos(0, 65);
      default :
         return jjMoveNfa_4(12, 0);
   }
}
private int jjMoveStringLiteralDfa1_4(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_4(0, active0, 0L);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x40000L) != 0L)
            return jjStopAtPos(1, 18);
         break;
      case 42:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_4(1, 16, 25);
         break;
      case 97:
         return jjMoveStringLiteralDfa2_4(active0, 0x20000000L);
      case 114:
         return jjMoveStringLiteralDfa2_4(active0, 0x10000000L);
      default :
         break;
   }
   return jjStartNfa_4(0, active0, 0L);
}
private int jjMoveStringLiteralDfa2_4(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_4(0, old0, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_4(1, active0, 0L);
      return 2;
   }
   switch(curChar)
   {
      case 108:
         return jjMoveStringLiteralDfa3_4(active0, 0x20000000L);
      case 117:
         return jjMoveStringLiteralDfa3_4(active0, 0x10000000L);
      default :
         break;
   }
   return jjStartNfa_4(1, active0, 0L);
}
private int jjMoveStringLiteralDfa3_4(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_4(1, old0, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_4(2, active0, 0L);
      return 3;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x10000000L) != 0L)
            return jjStartNfaWithStates_4(3, 28, 13);
         break;
      case 115:
         return jjMoveStringLiteralDfa4_4(active0, 0x20000000L);
      default :
         break;
   }
   return jjStartNfa_4(2, active0, 0L);
}
private int jjMoveStringLiteralDfa4_4(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_4(2, old0, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_4(3, active0, 0L);
      return 4;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x20000000L) != 0L)
            return jjStartNfaWithStates_4(4, 29, 13);
         break;
      default :
         break;
   }
   return jjStartNfa_4(3, active0, 0L);
}
private int jjStartNfaWithStates_4(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_4(state, pos + 1);
}
private int jjMoveNfa_4(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 28;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 12:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddTwoStates(0, 1);
                  else if (curChar == 35)
                     jjCheckNAddStates(126, 128);
                  else if (curChar == 36)
                  {
                     if (kind > 13)
                        kind = 13;
                     jjCheckNAddTwoStates(21, 22);
                  }
                  else if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 15;
                  break;
               case 27:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 25;
                  break;
               case 0:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddTwoStates(0, 1);
                  break;
               case 1:
                  if (curChar == 35)
                     jjCheckNAddTwoStates(6, 11);
                  break;
               case 3:
                  if (curChar == 32)
                     jjAddStates(108, 109);
                  break;
               case 4:
                  if (curChar == 40 && kind > 12)
                     kind = 12;
                  break;
               case 13:
                  if ((0x3ff200000000000L & l) == 0L)
                     break;
                  if (kind > 62)
                     kind = 62;
                  jjstateSet[jjnewStateCnt++] = 13;
                  break;
               case 14:
                  if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 15;
                  break;
               case 18:
                  if (curChar == 36 && kind > 13)
                     kind = 13;
                  break;
               case 20:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(21, 22);
                  break;
               case 22:
                  if (curChar == 33 && kind > 14)
                     kind = 14;
                  break;
               case 23:
                  if (curChar != 36)
                     break;
                  if (kind > 13)
                     kind = 13;
                  jjCheckNAddTwoStates(21, 22);
                  break;
               case 24:
                  if (curChar == 35)
                     jjCheckNAddStates(126, 128);
                  break;
               case 25:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 26;
                  break;
               case 26:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 12:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 62)
                        kind = 62;
                     jjCheckNAdd(13);
                  }
                  else if (curChar == 92)
                     jjCheckNAddStates(129, 132);
                  break;
               case 27:
                  if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 10;
                  else if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 2:
                  if (curChar == 116)
                     jjCheckNAddTwoStates(3, 4);
                  break;
               case 5:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 6:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 7:
                  if (curChar == 125)
                     jjCheckNAddTwoStates(3, 4);
                  break;
               case 8:
                  if (curChar == 116)
                     jjstateSet[jjnewStateCnt++] = 7;
                  break;
               case 9:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 8;
                  break;
               case 10:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 9;
                  break;
               case 11:
                  if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 10;
                  break;
               case 13:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 62)
                     kind = 62;
                  jjCheckNAdd(13);
                  break;
               case 15:
                  if ((0x7fffffe07fffffeL & l) != 0L && kind > 63)
                     kind = 63;
                  break;
               case 16:
                  if (curChar == 92)
                     jjCheckNAddStates(129, 132);
                  break;
               case 17:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(17, 18);
                  break;
               case 19:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(19, 20);
                  break;
               case 21:
                  if (curChar == 92)
                     jjAddStates(133, 134);
                  break;
               case 26:
                  if (kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 26:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 28 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_1(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x70000L) != 0L)
            return 48;
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 62;
            return 36;
         }
         if ((active0 & 0x10L) != 0L)
            return 70;
         return -1;
      case 1:
         if ((active0 & 0x10000L) != 0L)
            return 46;
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 62;
            jjmatchedPos = 1;
            return 36;
         }
         return -1;
      case 2:
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 62;
            jjmatchedPos = 2;
            return 36;
         }
         return -1;
      case 3:
         if ((active0 & 0x10000000L) != 0L)
            return 36;
         if ((active0 & 0x20000000L) != 0L)
         {
            jjmatchedKind = 62;
            jjmatchedPos = 3;
            return 36;
         }
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_1(int pos, long active0)
{
   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
}
private int jjMoveStringLiteralDfa0_1()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 17;
         return jjMoveStringLiteralDfa1_1(0x50000L);
      case 41:
         return jjStopAtPos(0, 10);
      case 44:
         return jjStopAtPos(0, 3);
      case 46:
         return jjMoveStringLiteralDfa1_1(0x10L);
      case 58:
         return jjStopAtPos(0, 5);
      case 91:
         return jjStopAtPos(0, 1);
      case 93:
         return jjStopAtPos(0, 2);
      case 102:
         return jjMoveStringLiteralDfa1_1(0x20000000L);
      case 116:
         return jjMoveStringLiteralDfa1_1(0x10000000L);
      case 123:
         return jjStopAtPos(0, 6);
      case 125:
         return jjStopAtPos(0, 7);
      default :
         return jjMoveNfa_1(13, 0);
   }
}
private int jjMoveStringLiteralDfa1_1(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_1(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x40000L) != 0L)
            return jjStopAtPos(1, 18);
         break;
      case 42:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_1(1, 16, 46);
         break;
      case 46:
         if ((active0 & 0x10L) != 0L)
            return jjStopAtPos(1, 4);
         break;
      case 97:
         return jjMoveStringLiteralDfa2_1(active0, 0x20000000L);
      case 114:
         return jjMoveStringLiteralDfa2_1(active0, 0x10000000L);
      default :
         break;
   }
   return jjStartNfa_1(0, active0);
}
private int jjMoveStringLiteralDfa2_1(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(0, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_1(1, active0);
      return 2;
   }
   switch(curChar)
   {
      case 108:
         return jjMoveStringLiteralDfa3_1(active0, 0x20000000L);
      case 117:
         return jjMoveStringLiteralDfa3_1(active0, 0x10000000L);
      default :
         break;
   }
   return jjStartNfa_1(1, active0);
}
private int jjMoveStringLiteralDfa3_1(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(1, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_1(2, active0);
      return 3;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x10000000L) != 0L)
            return jjStartNfaWithStates_1(3, 28, 36);
         break;
      case 115:
         return jjMoveStringLiteralDfa4_1(active0, 0x20000000L);
      default :
         break;
   }
   return jjStartNfa_1(2, active0);
}
private int jjMoveStringLiteralDfa4_1(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_1(2, old0);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_1(3, active0);
      return 4;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x20000000L) != 0L)
            return jjStartNfaWithStates_1(4, 29, 36);
         break;
      default :
         break;
   }
   return jjStartNfa_1(3, active0);
}
private int jjStartNfaWithStates_1(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_1(state, pos + 1);
}
private int jjMoveNfa_1(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 71;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 13:
                  if ((0x3ff000000000000L & l) != 0L)
                  {
                     if (kind > 52)
                        kind = 52;
                     jjCheckNAddStates(135, 140);
                  }
                  else if ((0x100002600L & l) != 0L)
                  {
                     if (kind > 26)
                        kind = 26;
                     jjCheckNAdd(12);
                  }
                  else if (curChar == 46)
                     jjCheckNAddTwoStates(60, 70);
                  else if (curChar == 45)
                     jjCheckNAddStates(141, 144);
                  else if (curChar == 35)
                     jjCheckNAddStates(145, 147);
                  else if (curChar == 36)
                  {
                     if (kind > 13)
                        kind = 13;
                     jjCheckNAddTwoStates(42, 43);
                  }
                  else if (curChar == 39)
                     jjCheckNAddStates(148, 150);
                  else if (curChar == 34)
                     jjCheckNAddStates(151, 153);
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddTwoStates(0, 1);
                  break;
               case 70:
               case 60:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAddTwoStates(60, 61);
                  break;
               case 48:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 46;
                  break;
               case 0:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddTwoStates(0, 1);
                  break;
               case 1:
                  if (curChar == 35)
                     jjCheckNAddTwoStates(6, 11);
                  break;
               case 3:
                  if (curChar == 32)
                     jjAddStates(108, 109);
                  break;
               case 4:
                  if (curChar == 40 && kind > 12)
                     kind = 12;
                  break;
               case 12:
                  if ((0x100002600L & l) == 0L)
                     break;
                  if (kind > 26)
                     kind = 26;
                  jjCheckNAdd(12);
                  break;
               case 14:
                  if ((0xfffffffbffffffffL & l) != 0L)
                     jjCheckNAddStates(151, 153);
                  break;
               case 15:
                  if (curChar == 34 && kind > 27)
                     kind = 27;
                  break;
               case 17:
                  if ((0x8400000000L & l) != 0L)
                     jjCheckNAddStates(151, 153);
                  break;
               case 18:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(154, 157);
                  break;
               case 19:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAddStates(151, 153);
                  break;
               case 20:
                  if ((0xf000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 21;
                  break;
               case 21:
                  if ((0xff000000000000L & l) != 0L)
                     jjCheckNAdd(19);
                  break;
               case 23:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 24;
                  break;
               case 24:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 25;
                  break;
               case 25:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 26;
                  break;
               case 26:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddStates(151, 153);
                  break;
               case 27:
                  if (curChar == 32)
                     jjAddStates(118, 119);
                  break;
               case 28:
                  if (curChar == 10)
                     jjCheckNAddStates(151, 153);
                  break;
               case 29:
                  if (curChar == 39)
                     jjCheckNAddStates(148, 150);
                  break;
               case 30:
                  if ((0xffffff7fffffffffL & l) != 0L)
                     jjCheckNAddStates(148, 150);
                  break;
               case 32:
                  if (curChar == 32)
                     jjAddStates(158, 159);
                  break;
               case 33:
                  if (curChar == 10)
                     jjCheckNAddStates(148, 150);
                  break;
               case 34:
                  if (curChar == 39 && kind > 27)
                     kind = 27;
                  break;
               case 36:
                  if ((0x3ff200000000000L & l) == 0L)
                     break;
                  if (kind > 62)
                     kind = 62;
                  jjstateSet[jjnewStateCnt++] = 36;
                  break;
               case 39:
                  if (curChar == 36 && kind > 13)
                     kind = 13;
                  break;
               case 41:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(42, 43);
                  break;
               case 43:
                  if (curChar == 33 && kind > 14)
                     kind = 14;
                  break;
               case 44:
                  if (curChar != 36)
                     break;
                  if (kind > 13)
                     kind = 13;
                  jjCheckNAddTwoStates(42, 43);
                  break;
               case 45:
                  if (curChar == 35)
                     jjCheckNAddStates(145, 147);
                  break;
               case 46:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 47;
                  break;
               case 47:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 15)
                     kind = 15;
                  break;
               case 49:
                  if (curChar == 45)
                     jjCheckNAddStates(141, 144);
                  break;
               case 50:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAddTwoStates(50, 52);
                  break;
               case 51:
                  if (curChar == 46 && kind > 52)
                     kind = 52;
                  break;
               case 52:
                  if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 51;
                  break;
               case 53:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(53, 54);
                  break;
               case 54:
                  if (curChar != 46)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAddTwoStates(55, 56);
                  break;
               case 55:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAddTwoStates(55, 56);
                  break;
               case 57:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(58);
                  break;
               case 58:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAdd(58);
                  break;
               case 59:
                  if (curChar == 46)
                     jjCheckNAdd(60);
                  break;
               case 62:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(63);
                  break;
               case 63:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAdd(63);
                  break;
               case 64:
                  if ((0x3ff000000000000L & l) != 0L)
                     jjCheckNAddTwoStates(64, 65);
                  break;
               case 66:
                  if ((0x280000000000L & l) != 0L)
                     jjCheckNAdd(67);
                  break;
               case 67:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 53)
                     kind = 53;
                  jjCheckNAdd(67);
                  break;
               case 68:
                  if ((0x3ff000000000000L & l) == 0L)
                     break;
                  if (kind > 52)
                     kind = 52;
                  jjCheckNAddStates(135, 140);
                  break;
               case 69:
                  if (curChar == 46)
                     jjCheckNAddTwoStates(60, 70);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 13:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 62)
                        kind = 62;
                     jjCheckNAdd(36);
                  }
                  else if (curChar == 92)
                     jjCheckNAddStates(160, 163);
                  break;
               case 70:
                  if ((0x7fffffe07fffffeL & l) != 0L && kind > 63)
                     kind = 63;
                  break;
               case 48:
                  if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 10;
                  else if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 2:
                  if (curChar == 116)
                     jjCheckNAddTwoStates(3, 4);
                  break;
               case 5:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 6:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 7:
                  if (curChar == 125)
                     jjCheckNAddTwoStates(3, 4);
                  break;
               case 8:
                  if (curChar == 116)
                     jjstateSet[jjnewStateCnt++] = 7;
                  break;
               case 9:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 8;
                  break;
               case 10:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 9;
                  break;
               case 11:
                  if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 10;
                  break;
               case 14:
                  jjCheckNAddStates(151, 153);
                  break;
               case 16:
                  if (curChar == 92)
                     jjAddStates(164, 169);
                  break;
               case 17:
                  if ((0x14404410000000L & l) != 0L)
                     jjCheckNAddStates(151, 153);
                  break;
               case 22:
                  if (curChar == 117)
                     jjstateSet[jjnewStateCnt++] = 23;
                  break;
               case 23:
                  if ((0x7e0000007eL & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 24;
                  break;
               case 24:
                  if ((0x7e0000007eL & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 25;
                  break;
               case 25:
                  if ((0x7e0000007eL & l) != 0L)
                     jjstateSet[jjnewStateCnt++] = 26;
                  break;
               case 26:
                  if ((0x7e0000007eL & l) != 0L)
                     jjCheckNAddStates(151, 153);
                  break;
               case 30:
                  jjAddStates(148, 150);
                  break;
               case 31:
                  if (curChar == 92)
                     jjAddStates(158, 159);
                  break;
               case 35:
               case 36:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 62)
                     kind = 62;
                  jjCheckNAdd(36);
                  break;
               case 37:
                  if (curChar == 92)
                     jjCheckNAddStates(160, 163);
                  break;
               case 38:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(38, 39);
                  break;
               case 40:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(40, 41);
                  break;
               case 42:
                  if (curChar == 92)
                     jjAddStates(170, 171);
                  break;
               case 47:
                  if (kind > 15)
                     kind = 15;
                  break;
               case 56:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(172, 173);
                  break;
               case 61:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(174, 175);
                  break;
               case 65:
                  if ((0x2000000020L & l) != 0L)
                     jjAddStates(27, 28);
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 14:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(151, 153);
                  break;
               case 30:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
                     jjAddStates(148, 150);
                  break;
               case 47:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 71 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
private final int jjStopStringLiteralDfa_2(int pos, long active0, long active1)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x70000L) != 0L)
            return 27;
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 62;
            return 13;
         }
         return -1;
      case 1:
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 62;
            jjmatchedPos = 1;
            return 13;
         }
         if ((active0 & 0x10000L) != 0L)
            return 25;
         return -1;
      case 2:
         if ((active0 & 0x30000000L) != 0L)
         {
            jjmatchedKind = 62;
            jjmatchedPos = 2;
            return 13;
         }
         return -1;
      case 3:
         if ((active0 & 0x10000000L) != 0L)
            return 13;
         if ((active0 & 0x20000000L) != 0L)
         {
            jjmatchedKind = 62;
            jjmatchedPos = 3;
            return 13;
         }
         return -1;
      default :
         return -1;
   }
}
private final int jjStartNfa_2(int pos, long active0, long active1)
{
   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0, active1), pos + 1);
}
private int jjMoveStringLiteralDfa0_2()
{
   switch(curChar)
   {
      case 35:
         jjmatchedKind = 17;
         return jjMoveStringLiteralDfa1_2(0x50000L);
      case 40:
         return jjStopAtPos(0, 8);
      case 102:
         return jjMoveStringLiteralDfa1_2(0x20000000L);
      case 116:
         return jjMoveStringLiteralDfa1_2(0x10000000L);
      case 123:
         return jjStopAtPos(0, 64);
      case 125:
         return jjStopAtPos(0, 65);
      default :
         return jjMoveNfa_2(12, 0);
   }
}
private int jjMoveStringLiteralDfa1_2(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_2(0, active0, 0L);
      return 1;
   }
   switch(curChar)
   {
      case 35:
         if ((active0 & 0x40000L) != 0L)
            return jjStopAtPos(1, 18);
         break;
      case 42:
         if ((active0 & 0x10000L) != 0L)
            return jjStartNfaWithStates_2(1, 16, 25);
         break;
      case 97:
         return jjMoveStringLiteralDfa2_2(active0, 0x20000000L);
      case 114:
         return jjMoveStringLiteralDfa2_2(active0, 0x10000000L);
      default :
         break;
   }
   return jjStartNfa_2(0, active0, 0L);
}
private int jjMoveStringLiteralDfa2_2(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(0, old0, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_2(1, active0, 0L);
      return 2;
   }
   switch(curChar)
   {
      case 108:
         return jjMoveStringLiteralDfa3_2(active0, 0x20000000L);
      case 117:
         return jjMoveStringLiteralDfa3_2(active0, 0x10000000L);
      default :
         break;
   }
   return jjStartNfa_2(1, active0, 0L);
}
private int jjMoveStringLiteralDfa3_2(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(1, old0, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_2(2, active0, 0L);
      return 3;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x10000000L) != 0L)
            return jjStartNfaWithStates_2(3, 28, 13);
         break;
      case 115:
         return jjMoveStringLiteralDfa4_2(active0, 0x20000000L);
      default :
         break;
   }
   return jjStartNfa_2(2, active0, 0L);
}
private int jjMoveStringLiteralDfa4_2(long old0, long active0)
{
   if (((active0 &= old0)) == 0L)
      return jjStartNfa_2(2, old0, 0L);
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_2(3, active0, 0L);
      return 4;
   }
   switch(curChar)
   {
      case 101:
         if ((active0 & 0x20000000L) != 0L)
            return jjStartNfaWithStates_2(4, 29, 13);
         break;
      default :
         break;
   }
   return jjStartNfa_2(3, active0, 0L);
}
private int jjStartNfaWithStates_2(int pos, int kind, int state)
{
   jjmatchedKind = kind;
   jjmatchedPos = pos;
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) { return pos + 1; }
   return jjMoveNfa_2(state, pos + 1);
}
private int jjMoveNfa_2(int startState, int curPos)
{
   int startsAt = 0;
   jjnewStateCnt = 28;
   int i = 1;
   jjstateSet[0] = startState;
   int kind = 0x7fffffff;
   for (;;)
   {
      if (++jjround == 0x7fffffff)
         ReInitRounds();
      if (curChar < 64)
      {
         long l = 1L << curChar;
         do
         {
            switch(jjstateSet[--i])
            {
               case 12:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddTwoStates(0, 1);
                  else if (curChar == 35)
                     jjCheckNAddStates(126, 128);
                  else if (curChar == 36)
                  {
                     if (kind > 13)
                        kind = 13;
                     jjCheckNAddTwoStates(21, 22);
                  }
                  else if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 15;
                  break;
               case 27:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 25;
                  break;
               case 0:
                  if ((0x100000200L & l) != 0L)
                     jjCheckNAddTwoStates(0, 1);
                  break;
               case 1:
                  if (curChar == 35)
                     jjCheckNAddTwoStates(6, 11);
                  break;
               case 3:
                  if (curChar == 32)
                     jjAddStates(108, 109);
                  break;
               case 4:
                  if (curChar == 40 && kind > 12)
                     kind = 12;
                  break;
               case 13:
                  if ((0x3ff200000000000L & l) == 0L)
                     break;
                  if (kind > 62)
                     kind = 62;
                  jjstateSet[jjnewStateCnt++] = 13;
                  break;
               case 14:
                  if (curChar == 46)
                     jjstateSet[jjnewStateCnt++] = 15;
                  break;
               case 18:
                  if (curChar == 36 && kind > 13)
                     kind = 13;
                  break;
               case 20:
                  if (curChar == 36)
                     jjCheckNAddTwoStates(21, 22);
                  break;
               case 22:
                  if (curChar == 33 && kind > 14)
                     kind = 14;
                  break;
               case 23:
                  if (curChar != 36)
                     break;
                  if (kind > 13)
                     kind = 13;
                  jjCheckNAddTwoStates(21, 22);
                  break;
               case 24:
                  if (curChar == 35)
                     jjCheckNAddStates(126, 128);
                  break;
               case 25:
                  if (curChar == 42)
                     jjstateSet[jjnewStateCnt++] = 26;
                  break;
               case 26:
                  if ((0xfffffff7ffffffffL & l) != 0L && kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else if (curChar < 128)
      {
         long l = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 12:
                  if ((0x7fffffe87fffffeL & l) != 0L)
                  {
                     if (kind > 62)
                        kind = 62;
                     jjCheckNAdd(13);
                  }
                  else if (curChar == 92)
                     jjCheckNAddStates(129, 132);
                  break;
               case 27:
                  if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 10;
                  else if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 2:
                  if (curChar == 116)
                     jjCheckNAddTwoStates(3, 4);
                  break;
               case 5:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 2;
                  break;
               case 6:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 5;
                  break;
               case 7:
                  if (curChar == 125)
                     jjCheckNAddTwoStates(3, 4);
                  break;
               case 8:
                  if (curChar == 116)
                     jjstateSet[jjnewStateCnt++] = 7;
                  break;
               case 9:
                  if (curChar == 101)
                     jjstateSet[jjnewStateCnt++] = 8;
                  break;
               case 10:
                  if (curChar == 115)
                     jjstateSet[jjnewStateCnt++] = 9;
                  break;
               case 11:
                  if (curChar == 123)
                     jjstateSet[jjnewStateCnt++] = 10;
                  break;
               case 13:
                  if ((0x7fffffe87fffffeL & l) == 0L)
                     break;
                  if (kind > 62)
                     kind = 62;
                  jjCheckNAdd(13);
                  break;
               case 15:
                  if ((0x7fffffe07fffffeL & l) != 0L && kind > 63)
                     kind = 63;
                  break;
               case 16:
                  if (curChar == 92)
                     jjCheckNAddStates(129, 132);
                  break;
               case 17:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(17, 18);
                  break;
               case 19:
                  if (curChar == 92)
                     jjCheckNAddTwoStates(19, 20);
                  break;
               case 21:
                  if (curChar == 92)
                     jjAddStates(133, 134);
                  break;
               case 26:
                  if (kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      else
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               case 26:
                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 15)
                     kind = 15;
                  break;
               default : break;
            }
         } while(i != startsAt);
      }
      if (kind != 0x7fffffff)
      {
         jjmatchedKind = kind;
         jjmatchedPos = curPos;
         kind = 0x7fffffff;
      }
      ++curPos;
      if ((i = jjnewStateCnt) == (startsAt = 28 - (jjnewStateCnt = startsAt)))
         return curPos;
      try { curChar = input_stream.readChar(); }
      catch(java.io.IOException e) { return curPos; }
   }
}
static final int[] jjnextStates = {
   87, 89, 90, 91, 96, 97, 87, 90, 57, 96, 27, 28, 31, 11, 12, 13, 
   1, 2, 4, 11, 16, 12, 13, 24, 25, 29, 30, 66, 67, 69, 70, 71, 
   72, 83, 85, 80, 81, 77, 78, 14, 15, 17, 19, 24, 25, 60, 61, 73, 
   74, 94, 95, 98, 99, 5, 6, 7, 8, 9, 10, 78, 80, 81, 82, 87, 
   88, 78, 81, 10, 87, 19, 20, 31, 32, 34, 42, 43, 45, 50, 32, 51, 
   66, 43, 67, 54, 57, 64, 71, 76, 22, 23, 24, 25, 35, 40, 47, 13, 
   14, 26, 27, 85, 86, 89, 90, 6, 11, 33, 16, 18, 3, 4, 20, 21, 
   23, 24, 25, 26, 14, 15, 27, 28, 8, 9, 10, 11, 12, 13, 6, 11, 
   27, 17, 18, 19, 20, 21, 22, 50, 52, 53, 54, 64, 65, 50, 53, 59, 
   64, 6, 11, 48, 30, 31, 34, 14, 15, 16, 14, 19, 15, 16, 32, 33, 
   38, 39, 40, 41, 17, 18, 20, 22, 27, 28, 42, 43, 57, 58, 62, 63, 
};
private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
{
   switch(hiByte)
   {
      case 0:
         return ((jjbitVec2[i2] & l2) != 0L);
      default :
         if ((jjbitVec0[i1] & l1) != 0L)
            return true;
         return false;
   }
}
/** Token literal values. */
public static final String[] jjstrLiteralImages = {
null, null, null, null, null, null, null, null, null, null, null, null, null, 
null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
null, null, null, null, null, null, null, null, null, null, null, null, null, };
/** Lexer state names. */
public static final String[] lexStateNames = {
   ""DIRECTIVE"",
   ""REFMOD2"",
   ""REFMODIFIER"",
   ""DEFAULT"",
   ""REFERENCE"",
   ""PRE_DIRECTIVE"",
   ""IN_MULTI_LINE_COMMENT"",
   ""IN_FORMAL_COMMENT"",
   ""IN_SINGLE_LINE_COMMENT"",
};
/** Lex State array. */
public static final int[] jjnewLexState = {
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
};
static final long[] jjtoToken = {
   0xc637fffffdfc1fffL, 0x3L, 
};
static final long[] jjtoSkip = {
   0x2000000L, 0xcL, 
};
static final long[] jjtoSpecial = {
   0x0L, 0xcL, 
};
static final long[] jjtoMore = {
   0x3e000L, 0x0L, 
};
protected CharStream input_stream;
private final int[] jjrounds = new int[101];
private final int[] jjstateSet = new int[202];
private final StringBuffer jjimage = new StringBuffer();
private StringBuffer image = jjimage;
private int jjimageLen;
private int lengthOfMatch;
protected char curChar;
/** Constructor. */
public ParserTokenManager(CharStream stream){
   input_stream = stream;
}
/** Constructor. */
public ParserTokenManager(CharStream stream, int lexState){
   this(stream);
   SwitchTo(lexState);
}
/** Reinitialise parser. */
public void ReInit(CharStream stream)
{
   jjmatchedPos = jjnewStateCnt = 0;
   curLexState = defaultLexState;
   input_stream = stream;
   ReInitRounds();
}
private void ReInitRounds()
{
   int i;
   jjround = 0x80000001;
   for (i = 101; i-- > 0;)
      jjrounds[i] = 0x80000000;
}
/** Reinitialise parser. */
public void ReInit(CharStream stream, int lexState)
{
   ReInit(stream);
   SwitchTo(lexState);
}
/** Switch to specified lex state. */
public void SwitchTo(int lexState)
{
   if (lexState >= 9 || lexState < 0)
      throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
   else
      curLexState = lexState;
}
protected Token jjFillToken()
{
   final Token t;
   final String curTokenImage;
   final int beginLine;
   final int endLine;
   final int beginColumn;
   final int endColumn;
   String im = jjstrLiteralImages[jjmatchedKind];
   curTokenImage = (im == null) ? input_stream.GetImage() : im;
   beginLine = input_stream.getBeginLine();
   beginColumn = input_stream.getBeginColumn();
   endLine = input_stream.getEndLine();
   endColumn = input_stream.getEndColumn();
   t = Token.newToken(jjmatchedKind);
   t.kind = jjmatchedKind;
   t.image = curTokenImage;
   t.beginLine = beginLine;
   t.endLine = endLine;
   t.beginColumn = beginColumn;
   t.endColumn = endColumn;
   return t;
}
int curLexState = 3;
int defaultLexState = 3;
int jjnewStateCnt;
int jjround;
int jjmatchedPos;
int jjmatchedKind;
/** Get the next Token. */
public Token getNextToken() 
{
  Token specialToken = null;
  Token matchedToken;
  int curPos = 0;
  EOFLoop :
  for (;;)
  {
   try
   {
      curChar = input_stream.BeginToken();
   }
   catch(java.io.IOException e)
   {
      jjmatchedKind = 0;
      matchedToken = jjFillToken();
      matchedToken.specialToken = specialToken;
      return matchedToken;
   }
   image = jjimage;
   image.setLength(0);
   jjimageLen = 0;
   for (;;)
   {
     switch(curLexState)
     {
       case 0:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_0();
         break;
       case 1:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_1();
         if (jjmatchedPos == 0 && jjmatchedKind > 66)
         {
            jjmatchedKind = 66;
         }
         break;
       case 2:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_2();
         if (jjmatchedPos == 0 && jjmatchedKind > 66)
         {
            jjmatchedKind = 66;
         }
         break;
       case 3:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_3();
         break;
       case 4:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_4();
         if (jjmatchedPos == 0 && jjmatchedKind > 66)
         {
            jjmatchedKind = 66;
         }
         break;
       case 5:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_5();
         if (jjmatchedPos == 0 && jjmatchedKind > 67)
         {
            jjmatchedKind = 67;
         }
         break;
       case 6:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_6();
         if (jjmatchedPos == 0 && jjmatchedKind > 25)
         {
            jjmatchedKind = 25;
         }
         break;
       case 7:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_7();
         if (jjmatchedPos == 0 && jjmatchedKind > 25)
         {
            jjmatchedKind = 25;
         }
         break;
       case 8:
         jjmatchedKind = 0x7fffffff;
         jjmatchedPos = 0;
         curPos = jjMoveStringLiteralDfa0_8();
         if (jjmatchedPos == 0 && jjmatchedKind > 25)
         {
            jjmatchedKind = 25;
         }
         break;
     }
     if (jjmatchedKind != 0x7fffffff)
     {
        if (jjmatchedPos + 1 < curPos)
           input_stream.backup(curPos - jjmatchedPos - 1);
        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
        {
           matchedToken = jjFillToken();
           matchedToken.specialToken = specialToken;
           TokenLexicalActions(matchedToken);
       if (jjnewLexState[jjmatchedKind] != -1)
         curLexState = jjnewLexState[jjmatchedKind];
           return matchedToken;
        }
        else if ((jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
        {
           if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
           {
              matchedToken = jjFillToken();
              if (specialToken == null)
                 specialToken = matchedToken;
              else
              {
                 matchedToken.specialToken = specialToken;
                 specialToken = (specialToken.next = matchedToken);
              }
              SkipLexicalActions(matchedToken);
           }
           else
              SkipLexicalActions(null);
         if (jjnewLexState[jjmatchedKind] != -1)
           curLexState = jjnewLexState[jjmatchedKind];
           continue EOFLoop;
        }
        MoreLexicalActions();
      if (jjnewLexState[jjmatchedKind] != -1)
        curLexState = jjnewLexState[jjmatchedKind];
        curPos = 0;
        jjmatchedKind = 0x7fffffff;
        try {
           curChar = input_stream.readChar();
           continue;
        }
        catch (java.io.IOException e1) { }
     }
     int error_line = input_stream.getEndLine();
     int error_column = input_stream.getEndColumn();
     String error_after = null;
     boolean EOFSeen = false;
     try { input_stream.readChar(); input_stream.backup(1); }
     catch (java.io.IOException e1) {
        EOFSeen = true;
        error_after = curPos <= 1 ? """" : input_stream.GetImage();
        if (curChar == '\n' || curChar == '\r') {
           error_line++;
           error_column = 0;
        }
        else
           error_column++;
     }
     if (!EOFSeen) {
        input_stream.backup(1);
        error_after = curPos <= 1 ? """" : input_stream.GetImage();
     }
     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
   }
  }
}
void SkipLexicalActions(Token matchedToken)
{
   switch(jjmatchedKind)
   {
      case 66 :
         image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        /*
         * push every terminator character back into the stream
         */
        input_stream.backup(1);
        inReference = false;
        if ( debugPrint )
            System.out.print(""REF_TERM :"");
        stateStackPop();
         break;
      case 67 :
         image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        if ( debugPrint )
            System.out.print(""DIRECTIVE_TERM :"");
        input_stream.backup(1);
        inDirective = false;
        stateStackPop();
         break;
      default :
         break;
   }
}
void MoreLexicalActions()
{
   jjimageLen += (lengthOfMatch = jjmatchedPos + 1);
   switch(jjmatchedKind)
   {
      case 13 :
         image.append(input_stream.GetSuffix(jjimageLen));
         jjimageLen = 0;
        if (! inComment)
        {
            /*
             * if we find ourselves in REFERENCE, we need to pop down
             * to end the previous ref
             */
            if (curLexState == REFERENCE)
            {
                inReference = false;
                stateStackPop();
            }
            inReference = true;
            if ( debugPrint )
                System.out.print( ""$  : going to "" + REFERENCE );
            stateStackPush();
            SwitchTo(REFERENCE);
        }
         break;
      case 14 :
         image.append(input_stream.GetSuffix(jjimageLen));
         jjimageLen = 0;
        if (! inComment)
        {
            /*
             * if we find ourselves in REFERENCE, we need to pop down
             * to end the previous ref
             */
            if (curLexState == REFERENCE)
            {
                inReference = false;
                stateStackPop();
            }
            inReference = true;
            if ( debugPrint )
                System.out.print( ""$!  : going to "" + REFERENCE );
            stateStackPush();
            SwitchTo(REFERENCE);
        }
         break;
      case 15 :
         image.append(input_stream.GetSuffix(jjimageLen));
         jjimageLen = 0;
        if (!inComment)
        {
                input_stream.backup(1);
                inComment = true;
                stateStackPush();
                SwitchTo( IN_FORMAL_COMMENT);
        }
         break;
      case 16 :
         image.append(input_stream.GetSuffix(jjimageLen));
         jjimageLen = 0;
        if (!inComment)
        {
                inComment=true;
                stateStackPush();
                SwitchTo( IN_MULTI_LINE_COMMENT );
        }
         break;
      case 17 :
         image.append(input_stream.GetSuffix(jjimageLen));
         jjimageLen = 0;
        if (! inComment)
        {
            /*
             * We can have the situation where #if($foo)$foo#end.
             * We need to transition out of REFERENCE before going to DIRECTIVE.
             * I don't really like this, but I can't think of a legal way
             * you are going into DIRECTIVE while in REFERENCE.  -gmj
             */
            if (curLexState == REFERENCE || curLexState == REFMODIFIER )
            {
                inReference = false;
                stateStackPop();
            }
            inDirective = true;
            if ( debugPrint )
                System.out.print(""# :  going to "" + DIRECTIVE );
            stateStackPush();
            SwitchTo(PRE_DIRECTIVE);
        }
         break;
      default :
         break;
   }
}
void TokenLexicalActions(Token matchedToken)
{
   switch(jjmatchedKind)
   {
      case 8 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        if (!inComment)
            lparen++;
        /*
         * If in REFERENCE and we have seen the dot, then move
         * to REFMOD2 -> Modifier()
         */
        if (curLexState == REFMODIFIER )
            SwitchTo( REFMOD2 );
         break;
      case 9 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
       RPARENHandler();
         break;
      case 10 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        /*
         * need to simply switch back to REFERENCE, not drop down the stack
         * because we can (infinitely) chain, ala
         * $foo.bar().blargh().woogie().doogie()
         */
        SwitchTo( REFERENCE );
         break;
      case 12 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        if (! inComment)
        {
            inDirective = true;
            if ( debugPrint )
                System.out.print(""#set :  going to "" + DIRECTIVE );
            stateStackPush();
            inSet = true;
            SwitchTo(DIRECTIVE);
        }
        /*
         *  need the LPAREN action
         */
        if (!inComment)
        {
            lparen++;
            /*
             * If in REFERENCE and we have seen the dot, then move
             * to REFMOD2 -> Modifier()
             */
            if (curLexState == REFMODIFIER )
                SwitchTo( REFMOD2 );
        }
         break;
      case 18 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        if (!inComment)
        {
            if (curLexState == REFERENCE)
            {
                inReference = false;
                stateStackPop();
            }
            inComment = true;
            stateStackPush();
            SwitchTo(IN_SINGLE_LINE_COMMENT);
        }
         break;
      case 22 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
     inComment = false;
     stateStackPop();
         break;
      case 23 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
    inComment = false;
    stateStackPop();
         break;
      case 24 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
    inComment = false;
    stateStackPop();
         break;
      case 27 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        /*
         *  - if we are in DIRECTIVE and haven't seen ( yet, then also drop out.
         *      don't forget to account for the beloved yet wierd #set
         *  - finally, if we are in REFMOD2 (remember : $foo.bar( ) then "" is ok!
         */
         if( curLexState == DIRECTIVE && !inSet && lparen == 0)
            stateStackPop();
         break;
      case 30 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        if ( debugPrint )
            System.out.println("" NEWLINE :"");
        stateStackPop();
        if (inSet)
            inSet = false;
        if (inDirective)
            inDirective = false;
         break;
      case 46 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        inDirective = false;
        stateStackPop();
         break;
      case 47 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        SwitchTo(DIRECTIVE);
         break;
      case 48 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        SwitchTo(DIRECTIVE);
         break;
      case 49 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        inDirective = false;
        stateStackPop();
         break;
      case 50 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        inDirective = false;
        stateStackPop();
         break;
      case 52 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        /*
         * Remove the double period if it is there
         */
        if (matchedToken.image.endsWith("".."")) {
            input_stream.backup(2);
            matchedToken.image = matchedToken.image.substring(0,matchedToken.image.length()-2);
        }
        /*
         * check to see if we are in set
         *    ex.  #set $foo = $foo + 3
         *  because we want to handle the \n after
         */
        if ( lparen == 0 && !inSet && curLexState != REFMOD2)
        {
            stateStackPop();
        }
         break;
      case 53 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        /*
         * check to see if we are in set
         *    ex.  #set $foo = $foo + 3
         *  because we want to handle the \n after
         */
        if ( lparen == 0 && !inSet && curLexState != REFMOD2)
        {
            stateStackPop();
    }
         break;
      case 63 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        /*
         * push the alpha char back into the stream so the following identifier
         * is complete
         */
        input_stream.backup(1);
        /*
         * and munge the <DOT> so we just get a . when we have normal text that
         * looks like a ref.ident
         */
        matchedToken.image = ""."";
        if ( debugPrint )
            System.out.print(""DOT : switching to "" + REFMODIFIER);
        SwitchTo(REFMODIFIER);
         break;
      case 65 :
        image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
        stateStackPop();
         break;
      default :
         break;
   }
}
private void jjCheckNAdd(int state)
{
   if (jjrounds[state] != jjround)
   {
      jjstateSet[jjnewStateCnt++] = state;
      jjrounds[state] = jjround;
   }
}
private void jjAddStates(int start, int end)
{
   do {
      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
   } while (start++ != end);
}
private void jjCheckNAddTwoStates(int state1, int state2)
{
   jjCheckNAdd(state1);
   jjCheckNAdd(state2);
}
private void jjCheckNAddStates(int start, int end)
{
   do {
      jjCheckNAdd(jjnextStates[start]);
   } while (start++ != end);
}
}
"
org.apache.velocity.runtime.parser.ParserTreeConstants,"/* Generated By:JavaCC: Do not edit this line. ParserTreeConstants.java Version 4.1 */
package org.apache.velocity.runtime.parser;
public interface ParserTreeConstants
{
  public int JJTPROCESS = 0;
  public int JJTVOID = 1;
  public int JJTESCAPEDDIRECTIVE = 2;
  public int JJTESCAPE = 3;
  public int JJTCOMMENT = 4;
  public int JJTFLOATINGPOINTLITERAL = 5;
  public int JJTINTEGERLITERAL = 6;
  public int JJTSTRINGLITERAL = 7;
  public int JJTIDENTIFIER = 8;
  public int JJTWORD = 9;
  public int JJTDIRECTIVE = 10;
  public int JJTBLOCK = 11;
  public int JJTMAP = 12;
  public int JJTOBJECTARRAY = 13;
  public int JJTINTEGERRANGE = 14;
  public int JJTMETHOD = 15;
  public int JJTREFERENCE = 16;
  public int JJTTRUE = 17;
  public int JJTFALSE = 18;
  public int JJTTEXT = 19;
  public int JJTIFSTATEMENT = 20;
  public int JJTELSESTATEMENT = 21;
  public int JJTELSEIFSTATEMENT = 22;
  public int JJTSETDIRECTIVE = 23;
  public int JJTSTOP = 24;
  public int JJTEXPRESSION = 25;
  public int JJTASSIGNMENT = 26;
  public int JJTORNODE = 27;
  public int JJTANDNODE = 28;
  public int JJTEQNODE = 29;
  public int JJTNENODE = 30;
  public int JJTLTNODE = 31;
  public int JJTGTNODE = 32;
  public int JJTLENODE = 33;
  public int JJTGENODE = 34;
  public int JJTADDNODE = 35;
  public int JJTSUBTRACTNODE = 36;
  public int JJTMULNODE = 37;
  public int JJTDIVNODE = 38;
  public int JJTMODNODE = 39;
  public int JJTNOTNODE = 40;
  public String[] jjtNodeName = {
    ""process"",
    ""void"",
    ""EscapedDirective"",
    ""Escape"",
    ""Comment"",
    ""FloatingPointLiteral"",
    ""IntegerLiteral"",
    ""StringLiteral"",
    ""Identifier"",
    ""Word"",
    ""Directive"",
    ""Block"",
    ""Map"",
    ""ObjectArray"",
    ""IntegerRange"",
    ""Method"",
    ""Reference"",
    ""True"",
    ""False"",
    ""Text"",
    ""IfStatement"",
    ""ElseStatement"",
    ""ElseIfStatement"",
    ""SetDirective"",
    ""Stop"",
    ""Expression"",
    ""Assignment"",
    ""OrNode"",
    ""AndNode"",
    ""EQNode"",
    ""NENode"",
    ""LTNode"",
    ""GTNode"",
    ""LENode"",
    ""GENode"",
    ""AddNode"",
    ""SubtractNode"",
    ""MulNode"",
    ""DivNode"",
    ""ModNode"",
    ""NotNode"",
  };
}
/* JavaCC - OriginalChecksum=3c1632cd7e231249279dbb78c45031b8 (do not edit this line) */
"
org.apache.velocity.runtime.parser.TemplateParseException,"package org.apache.velocity.runtime.parser;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.exception.ExtendedParseException;
import org.apache.velocity.runtime.log.Log;
/**
 * This is an extension of the ParseException, which also takes a
 * template name.
 *
 * @see org.apache.velocity.runtime.parser.ParseException
 *
 * @author <a href=""hps@intermeta.de"">Henning P. Schmiedehausen</a>
 * @version $Id: TemplateParseException.java 703544 2008-10-10 18:15:53Z nbubna $
 * @since 1.5
 */
public class TemplateParseException
        extends ParseException
        implements ExtendedParseException
{
    private static final long serialVersionUID = -3146323135623083918L;
    /**
     * This is the name of the template which contains the parsing error, or
     * null if not defined.
     */
    private final String templateName;
    /**
     * This constructor is used to add a template name
     * to info cribbed from a ParseException generated in the parser.
     * @param currentTokenVal
     * @param expectedTokenSequencesVal
     * @param tokenImageVal
     * @param templateNameVal
     */
    public TemplateParseException(Token currentTokenVal, int [][] expectedTokenSequencesVal, String [] tokenImageVal,
        String templateNameVal)
    {
        super(currentTokenVal, expectedTokenSequencesVal, tokenImageVal);
        this.templateName = templateNameVal;
    }
    /**
     * This constructor is used by the method ""generateParseException""
     * in the generated parser.  Calling this constructor generates
     * a new object of this type with the fields ""currentToken"",
     * ""expectedTokenSequences"", and ""tokenImage"" set.  The boolean
     * flag ""specialConstructor"" is also set to true to indicate that
     * this constructor was used to create this object.
     * This constructor calls its super class with the empty string
     * to force the ""toString"" method of parent class ""Throwable"" to
     * print the error message in the form:
     *     ParseException: <result of getMessage>
     * @param currentTokenVal
     * @param expectedTokenSequencesVal
     * @param tokenImageVal
     */
    public TemplateParseException(Token currentTokenVal, int [][] expectedTokenSequencesVal, String [] tokenImageVal)
    {
        super(currentTokenVal, expectedTokenSequencesVal, tokenImageVal);
        templateName = ""*unset*"";
    }
    /**
     * The following constructors are for use by you for whatever
     * purpose you can think of.  Constructing the exception in this
     * manner makes the exception behave in the normal way - i.e., as
     * documented in the class ""Throwable"".  The fields ""errorToken"",
     * ""expectedTokenSequences"", and ""tokenImage"" do not contain
     * relevant information.  The JavaCC generated code does not use
     * these constructors.
     */
    public TemplateParseException()
    {
        super();
        templateName = ""*unset*"";
    }
    /**
     * Creates a new TemplateParseException object.
     *
     * @param message TODO: DOCUMENT ME!
     */
    public TemplateParseException(String message)
    {
        super(message);
        templateName = ""*unset*"";
    }
    /**
     * returns the Template name where this exception occured.
     * @return The Template name where this exception occured.
     */
    public String getTemplateName()
    {
        return templateName;
    }
    /**
     * returns the line number where this exception occured.
     * @return The line number where this exception occured.
     */
    public int getLineNumber()
    {
        if ((currentToken != null) && (currentToken.next != null))
        {
            return currentToken.next.beginLine;
        }
        else
        {
            return -1;
        }
    }
    /**
     * returns the column number where this exception occured.
     * @return The column number where this exception occured.
     */
    public int getColumnNumber()
    {
        if ((currentToken != null) && (currentToken.next != null))
        {
            return currentToken.next.beginColumn;
        }
        else
        {
            return -1;
        }
    }
    /**
     * This method has the standard behavior when this object has been
     * created using the standard constructors.  Otherwise, it uses
     * ""currentToken"" and ""expectedTokenSequences"" to generate a parse
     * error message and returns it.  If this object has been created
     * due to a parse error, and you do not catch it (it gets thrown
     * from the parser), then this method is called during the printing
     * of the final stack trace, and hence the correct error message
     * gets displayed.
     * @return The error message.
     */
    public String getMessage()
    {
        if (!specialConstructor)
        {
            StringBuffer sb = new StringBuffer(super.getMessage());
            appendTemplateInfo(sb);
            return sb.toString();
        }
        int maxSize = 0;
        StringBuffer expected = new StringBuffer();
        for (int i = 0; i < expectedTokenSequences.length; i++)
        {
            if (maxSize < expectedTokenSequences[i].length)
            {
                maxSize = expectedTokenSequences[i].length;
            }
            for (int j = 0; j < expectedTokenSequences[i].length; j++)
            {
                expected.append(tokenImage[expectedTokenSequences[i][j]]).append("" "");
            }
            if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0)
            {
                expected.append(""..."");
            }
            expected.append(eol).append(""    "");
        }
        StringBuffer retval = new StringBuffer(""Encountered \"""");
        Token tok = currentToken.next;
        for (int i = 0; i < maxSize; i++)
        {
            if (i != 0)
            {
                retval.append("" "");
            }
            if (tok.kind == 0)
            {
                retval.append(tokenImage[0]);
                break;
            }
            retval.append(add_escapes(tok.image));
            tok = tok.next;
        }
        retval.append(""\"" at "");
        appendTemplateInfo(retval);
        if (expectedTokenSequences.length == 1)
        {
            retval.append(""Was expecting:"").append(eol).append(""    "");
        }
        else
        {
            retval.append(""Was expecting one of:"").append(eol).append(""    "");
        }
        // avoid JDK 1.3 StringBuffer.append(Object o) vs 1.4 StringBuffer.append(StringBuffer sb) gotcha.
        retval.append(expected.toString());
        return retval.toString();
    }
    /**
     * @param sb
     */
    protected void appendTemplateInfo(final StringBuffer sb)
    {
        sb.append(Log.formatFileString(getTemplateName(), getLineNumber(), getColumnNumber()));
        sb.append(eol);
    }
}
"
org.apache.velocity.runtime.parser.Token,"/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */
package org.apache.velocity.runtime.parser;
/**
 * Describes the input token stream.
 */
public class Token {
  /**
   * An integer that describes the kind of this token.  This numbering
   * system is determined by JavaCCParser, and a table of these numbers is
   * stored in the file ...Constants.java.
   */
  public int kind;
  /**
   * beginLine and beginColumn describe the position of the first character
   * of this token; endLine and endColumn describe the position of the
   * last character of this token.
   */
  public int beginLine, beginColumn, endLine, endColumn;
  /**
   * The string image of the token.
   */
  public String image;
  /**
   * A reference to the next regular (non-special) token from the input
   * stream.  If this is the last token from the input stream, or if the
   * token manager has not read tokens beyond this one, this field is
   * set to null.  This is true only if this token is also a regular
   * token.  Otherwise, see below for a description of the contents of
   * this field.
   */
  public Token next;
  /**
   * This field is used to access special tokens that occur prior to this
   * token, but after the immediately preceding regular (non-special) token.
   * If there are no such special tokens, this field is set to null.
   * When there are more than one such special token, this field refers
   * to the last of these special tokens, which in turn refers to the next
   * previous special token through its specialToken field, and so on
   * until the first special token (whose specialToken field is null).
   * The next fields of special tokens refer to other special tokens that
   * immediately follow it (without an intervening regular token).  If there
   * is no such token, this field is null.
   */
  public Token specialToken;
  /**
   * Returns the image.
   */
  public String toString()
  {
     return image;
  }
  /**
   * Returns a new Token object, by default. However, if you want, you
   * can create and return subclass objects based on the value of ofKind.
   * Simply add the cases to the switch for all those special cases.
   * For example, if you have a subclass of Token called IDToken that
   * you want to create if ofKind is ID, simlpy add something like :
   *
   *    case MyParserConstants.ID : return new IDToken();
   *
   * to the following switch statement. Then you can cast matchedToken
   * variable to the appropriate type and use it in your lexical actions.
   */
  public static final Token newToken(int ofKind)
  {
     switch(ofKind)
     {
       default : return new Token();
     }
  }
}
"
org.apache.velocity.runtime.parser.TokenMgrError,"/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */
package org.apache.velocity.runtime.parser;
public class TokenMgrError extends Error
{
   /*
    * Ordinals for various reasons why an Error of this type can be thrown.
    */
   /**
    * Lexical error occured.
    */
   static final int LEXICAL_ERROR = 0;
   /**
    * An attempt wass made to create a second instance of a static token manager.
    */
   static final int STATIC_LEXER_ERROR = 1;
   /**
    * Tried to change to an invalid lexical state.
    */
   static final int INVALID_LEXICAL_STATE = 2;
   /**
    * Detected (and bailed out of) an infinite loop in the token manager.
    */
   static final int LOOP_DETECTED = 3;
   /**
    * Indicates the reason why the exception is thrown. It will have
    * one of the above 4 values.
    */
   int errorCode;
   /**
    * Replaces unprintable characters by their espaced (or unicode escaped)
    * equivalents in the given string
    */
   protected static final String addEscapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append(""\\b"");
              continue;
           case '\t':
              retval.append(""\\t"");
              continue;
           case '\n':
              retval.append(""\\n"");
              continue;
           case '\f':
              retval.append(""\\f"");
              continue;
           case '\r':
              retval.append(""\\r"");
              continue;
           case '\""':
              retval.append(""\\\"""");
              continue;
           case '\'':
              retval.append(""\\\'"");
              continue;
           case '\\':
              retval.append(""\\\\"");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = ""0000"" + Integer.toString(ch, 16);
                 retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }
   /**
    * Returns a detailed message for the Error when it is thrown by the
    * token manager to indicate a lexical error.
    * Parameters :
    *    EOFSeen     : indicates if EOF caused the lexicl error
    *    curLexState : lexical state in which this error occured
    *    errorLine   : line number when the error occured
    *    errorColumn : column number when the error occured
    *    errorAfter  : prefix that was seen before this error occured
    *    curchar     : the offending character
    * Note: You can customize the lexical error message by modifying this method.
    */
   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
      return(""Lexical error at line "" +
           errorLine + "", column "" +
           errorColumn + "".  Encountered: "" +
           (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""") + "" ("" + (int)curChar + ""), "") +
           ""after : \"""" + addEscapes(errorAfter) + ""\"""");
   }
   /**
    * You can also modify the body of this method to customize your error messages.
    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
    * of end-users concern, so you can return something like :
    *
    *     ""Internal Error : Please file a bug report .... ""
    *
    * from this method for such cases in the release version of your parser.
    */
   public String getMessage() {
      return super.getMessage();
   }
   /*
    * Constructors of various flavors follow.
    */
   public TokenMgrError() {
   }
   public TokenMgrError(String message, int reason) {
      super(message);
      errorCode = reason;
   }
   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
   }
}
"
org.apache.velocity.runtime.parser.VelocityCharStream,"package org.apache.velocity.runtime.parser;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  NOTE : This class was originally an ASCII_CharStream autogenerated
 *  by Javacc.  It was then modified via changing class name with appropriate
 *  fixes for CTORS, and mods to readChar().
 *
 *  This is safe because we *always* use Reader with this class, and never a
 *  InputStream.  This guarantees that we have a correct stream of 16-bit
 *  chars - all encoding transformations have been done elsewhere, so we
 *  believe that there is no risk in doing this.  Time will tell :)
 */
/**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */
public final class VelocityCharStream
implements CharStream
{
    public static final boolean staticFlag = false;
    int bufsize;
    private int nextBufExpand;
    int available;
    int tokenBegin;
    public int bufpos = -1;
    private int bufline[];
    private int bufcolumn[];
    private int column = 0;
    private int line = 1;
    private boolean prevCharIsCR = false;
    private boolean prevCharIsLF = false;
    private java.io.Reader inputStream;
    private char[] buffer;
    private int maxNextCharInd = 0;
    private int inBuf = 0;
    private final void ExpandBuff(boolean wrapAround)
    {
        char[] newbuffer = new char[bufsize + nextBufExpand];
        int newbufline[] = new int[bufsize + nextBufExpand];
        int newbufcolumn[] = new int[bufsize + nextBufExpand];
        try
        {
            if (wrapAround)
            {
                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
                System.arraycopy(buffer, 0, newbuffer,
                        bufsize - tokenBegin, bufpos);
                buffer = newbuffer;
                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
                System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
                bufline = newbufline;
                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
                System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
                bufcolumn = newbufcolumn;
                maxNextCharInd = (bufpos += (bufsize - tokenBegin));
            }
            else
            {
                System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
                buffer = newbuffer;
                System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
                bufline = newbufline;
                System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
                bufcolumn = newbufcolumn;
                maxNextCharInd = (bufpos -= tokenBegin);
            }
        }
        catch (Throwable t)
        {
            throw new Error(t.getMessage());
        }
        bufsize += nextBufExpand;
        nextBufExpand = bufsize;
        available = bufsize;
        tokenBegin = 0;
    }
    private final void FillBuff() throws java.io.IOException
    {
        if (maxNextCharInd == available)
        {
            if (available == bufsize)
            {
                if (tokenBegin > nextBufExpand)
                {
                    bufpos = maxNextCharInd = 0;
                    available = tokenBegin;
                }
                else if (tokenBegin < 0)
                {
                    bufpos = maxNextCharInd = 0;
                }
                else
                {
                    ExpandBuff(false);
                }
            }
            else if (available > tokenBegin)
            {
                available = bufsize;
            }
            else if ((tokenBegin - available) < nextBufExpand)
            {
                ExpandBuff(true);
            }
            else
            {
                available = tokenBegin;
            }
        }
        int i;
        try 
        {
            if ((i = inputStream.read(buffer, maxNextCharInd,
                    available - maxNextCharInd)) == -1)
            {
                inputStream.close();
                throw new java.io.IOException();
            }
            else
            {
                maxNextCharInd += i;
            }
            return;
        }
        catch(java.io.IOException e) 
        {
            --bufpos;
            backup(0);
            if (tokenBegin == -1)
            {
                tokenBegin = bufpos;
            }
            throw e;
        }
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#BeginToken()
     */
    public final char BeginToken() throws java.io.IOException
    {
        tokenBegin = -1;
        char c = readChar();
        tokenBegin = bufpos;
        return c;
    }
    private final void UpdateLineColumn(char c)
    {
        column++;
        if (prevCharIsLF)
        {
            prevCharIsLF = false;
            line += (column = 1);
        }
        else if (prevCharIsCR)
        {
            prevCharIsCR = false;
            if (c == '\n')
            {
                prevCharIsLF = true;
            }
            else
            {
                line += (column = 1);
            }
        }
        switch (c)
        {
        case '\r' :
            prevCharIsCR = true;
            break;
        case '\n' :
            prevCharIsLF = true;
            break;
        case '\t' :
            column--;
            column += (8 - (column & 07));
            break;
        default :
            break;
        }
        bufline[bufpos] = line;
        bufcolumn[bufpos] = column;
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#readChar()
     */
    public final char readChar() throws java.io.IOException
    {
        if (inBuf > 0)
        {
            --inBuf;
            /*
             *  was : return (char)((char)0xff & buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos]);
             */
            return  buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos];
        }
        if (++bufpos >= maxNextCharInd)
        {
            FillBuff();
        }
        /*
         *  was : char c = (char)((char)0xff & buffer[bufpos]);
         */
        char c = buffer[bufpos];
        UpdateLineColumn(c);
        return (c);
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#getColumn()
     * @deprecated
     */
    public final int getColumn() 
    {
        return bufcolumn[bufpos];
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#getLine()
     * @deprecated
     */
    public final int getLine() 
    {
        return bufline[bufpos];
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#getEndColumn()
     */
    public final int getEndColumn() 
    {
        return bufcolumn[bufpos];
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#getEndLine()
     */
    public final int getEndLine() 
    {
        return bufline[bufpos];
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#getBeginColumn()
     */
    public final int getBeginColumn() 
    {
        return bufcolumn[tokenBegin];
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#getBeginLine()
     */
    public final int getBeginLine() 
    {
        return bufline[tokenBegin];
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#backup(int)
     */
    public final void backup(int amount) 
    {
        inBuf += amount;
        if ((bufpos -= amount) < 0)
            bufpos += bufsize;
    }
    /**
     * @param dstream
     * @param startline
     * @param startcolumn
     * @param buffersize
     */
    public VelocityCharStream(java.io.Reader dstream, int startline,
            int startcolumn, int buffersize)
    {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;
        available = bufsize = nextBufExpand = buffersize;
        buffer = new char[buffersize];
        bufline = new int[buffersize];
        bufcolumn = new int[buffersize];
    }
    /**
     * @param dstream
     * @param startline
     * @param startcolumn
     */
    public VelocityCharStream(java.io.Reader dstream, int startline,
            int startcolumn)
    {
        this(dstream, startline, startcolumn, 4096);
    }
    /**
     * @param dstream
     * @param startline
     * @param startcolumn
     * @param buffersize
     */
    public void ReInit(java.io.Reader dstream, int startline,
            int startcolumn, int buffersize)
    {
        inputStream = dstream;
        line = startline;
        column = startcolumn - 1;
        if (buffer == null || buffersize != buffer.length)
        {
            available = bufsize = nextBufExpand = buffersize;
            buffer = new char[buffersize];
            bufline = new int[buffersize];
            bufcolumn = new int[buffersize];
        }
        prevCharIsLF = prevCharIsCR = false;
        tokenBegin = inBuf = maxNextCharInd = 0;
        bufpos = -1;
    }
    /**
     * @param dstream
     * @param startline
     * @param startcolumn
     */
    public void ReInit(java.io.Reader dstream, int startline,
            int startcolumn)
    {
        ReInit(dstream, startline, startcolumn, 4096);
    }
    /**
     * @param dstream
     * @param startline
     * @param startcolumn
     * @param buffersize
     */
    public VelocityCharStream(java.io.InputStream dstream, int startline,
            int startcolumn, int buffersize)
    {
        this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
    }
    /**
     * @param dstream
     * @param startline
     * @param startcolumn
     */
    public VelocityCharStream(java.io.InputStream dstream, int startline,
            int startcolumn)
    {
        this(dstream, startline, startcolumn, 4096);
    }
    /**
     * @param dstream
     * @param startline
     * @param startcolumn
     * @param buffersize
     */
    public void ReInit(java.io.InputStream dstream, int startline,
            int startcolumn, int buffersize)
    {
        ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
    }
    /**
     * @param dstream
     * @param startline
     * @param startcolumn
     */
    public void ReInit(java.io.InputStream dstream, int startline,
            int startcolumn)
    {
        ReInit(dstream, startline, startcolumn, 4096);
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#GetImage()
     */
    public final String GetImage()
    {
        if (bufpos >= tokenBegin)
        {
            return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
        }
        else
        {
            return new String(buffer, tokenBegin, bufsize - tokenBegin) +
            new String(buffer, 0, bufpos + 1);
        }
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#GetSuffix(int)
     */
    public final char[] GetSuffix(int len)
    {
        char[] ret = new char[len];
        if ((bufpos + 1) >= len)
        {
            System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
        }
        else
        {
            System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
                    len - bufpos - 1);
            System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
        }
        return ret;
    }
    /**
     * @see org.apache.velocity.runtime.parser.CharStream#Done()
     */
    public void Done()
    {
        buffer = null;
        bufline = null;
        bufcolumn = null;
    }
    /**
     * Method to adjust line and column numbers for the start of a token.<BR>
     * @param newLine
     * @param newCol
     */
    public void adjustBeginLineColumn(int newLine, int newCol)
    {
        int start = tokenBegin;
        int len;
        if (bufpos >= tokenBegin)
        {
            len = bufpos - tokenBegin + inBuf + 1;
        }
        else
        {
            len = bufsize - tokenBegin + bufpos + 1 + inBuf;
        }
        int i = 0, j = 0, k = 0;
        int nextColDiff = 0, columnDiff = 0;
        while (i < len &&
                bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
        {
            bufline[j] = newLine;
            nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
            bufcolumn[j] = newCol + columnDiff;
            columnDiff = nextColDiff;
            i++;
        }
        if (i < len)
        {
            bufline[j] = newLine++;
            bufcolumn[j] = newCol + columnDiff;
            while (i++ < len)
            {
                if (bufline[j = start % bufsize] != bufline[++start % bufsize])
                    bufline[j] = newLine++;
                else
                    bufline[j] = newLine;
            }
        }
        line = bufline[j];
        column = bufcolumn[j];
    }
}
"
org.apache.velocity.runtime.parser.node.AbstractExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.velocity.runtime.log.Log;
/**
 * Abstract class that is used to execute an arbitrary
 * method that is in introspected. This is the superclass
 * for the GetExecutor and PropertyExecutor.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @version $Id: AbstractExecutor.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public abstract class AbstractExecutor
{
    /** */
    protected Log log = null;
    /**
     * Method to be executed.
     */
    private Method method = null;
    /**
     * Execute method against context.
     * @param o
     * @return The resulting object.
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
     public abstract Object execute(Object o)
         throws IllegalAccessException, InvocationTargetException;
    /**
     * Tell whether the executor is alive by looking
     * at the value of the method.
     *
     * @return True if executor is alive.
     */
    public boolean isAlive()
    {
        return (method != null);
    }
    /**
     * @return The current method.
     */
    public Method getMethod()
    {
        return method;
    }
    /**
     * @param method
     * @since 1.5
     */
    protected void setMethod(final Method method)
    {
        this.method = method;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTAddNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
/**
 * Handles number addition of nodes.<br><br>
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTAddNode.java 712887 2008-11-11 00:27:50Z nbubna $
 */
public class ASTAddNode extends ASTMathNode
{
    /**
     * @param id
     */
    public ASTAddNode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTAddNode(Parser p, int id)
    {
        super(p, id);
    }
    //@Override
    protected Object handleSpecial(Object left, Object right, InternalContextAdapter context)
    {
        /*
         * shall we try for strings?
         */
        if (left instanceof String || right instanceof String)
        {
            if (left == null)
            {
                left = jjtGetChild(0).literal();
            }
            else if (right == null)
            {
                right = jjtGetChild(1).literal();
            }
            return left.toString().concat(right.toString());
        }
        return null;
    }
    public Number perform(Number left, Number right, InternalContextAdapter context)
    {
        return MathUtils.add(left, right);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTAndNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.parser.Parser;
/**
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTAndNode.java 687184 2008-08-19 22:16:39Z nbubna $
 */
public class ASTAndNode extends SimpleNode
{
    /**
     * @param id
     */
    public ASTAndNode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTAndNode(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  Returns the value of the expression.
     *  Since the value of the expression is simply the boolean
     *  result of evaluate(), lets return that.
     * @param context
     * @return The value of the expression.
     * @throws MethodInvocationException
     */
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        // TODO: JDK 1.4+ -> valueOf()
        // return new Boolean(evaluate(context));
        return evaluate(context) ? Boolean.TRUE : Boolean.FALSE;
    }
    /**
     * logical and :
     *   null && right = false
     *   left && null = false
     *   null && null = false
     * @param context
     * @return True if both sides are true.
     * @throws MethodInvocationException
     */
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException
    {
        Node left = jjtGetChild(0);
        Node right = jjtGetChild(1);
        /*
         * null == false
         */
        if (left == null || right == null)
        {
            return false;
        }
        /*
         *  short circuit the test.  Don't eval the RHS if the LHS is false
         */
        if( left.evaluate( context ) )
        {
            if ( right.evaluate( context ) )
            {
                return true;
            }
        }
        return false;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTAssignment,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTAssignment extends SimpleNode
{
    /**
     * @param id
     */
    public ASTAssignment(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTAssignment(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTBlock,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTBlock extends SimpleNode
{
    /**
     * @param id
     */
    public ASTBlock(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTBlock(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#render(org.apache.velocity.context.InternalContextAdapter, java.io.Writer)
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException, MethodInvocationException,
        	ResourceNotFoundException, ParseErrorException
    {
        int i, k = jjtGetNumChildren();
        for (i = 0; i < k; i++)
            jjtGetChild(i).render(context, writer);
        return true;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTComment,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.Token;
/**
 *  Represents all comments...
 *
 *  @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 *  @version $Id: ASTComment.java 517553 2007-03-13 06:09:58Z wglass $
 */
public class ASTComment extends SimpleNode
{
    private static final char[] ZILCH = """".toCharArray();
    private char[] carr;
    /**
     * @param id
     */
    public ASTComment(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTComment(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  We need to make sure we catch any of the dreaded MORE tokens.
     * @param context
     * @param data
     * @return The data object.
     */
    public Object init(InternalContextAdapter context, Object data)
    {
        Token t = getFirstToken();
        int loc1 = t.image.indexOf(""##"");
        int loc2 = t.image.indexOf(""#*"");
        if (loc1 == -1 && loc2 == -1)
        {
            carr = ZILCH;
        }
        else
        {
            carr = t.image.substring(0, (loc1 == -1) ? loc2 : loc1).toCharArray();
        }
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#render(org.apache.velocity.context.InternalContextAdapter, java.io.Writer)
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException, MethodInvocationException, ParseErrorException, ResourceNotFoundException
    {
        if (context.getAllowRendering())
        {
            writer.write(carr);
        }
        return true;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTDirective,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.directive.Directive;
import org.apache.velocity.runtime.directive.RuntimeMacro;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.ExceptionUtils;
/**
 * This class is responsible for handling the pluggable
 * directives in VTL.
 *
 * For example :  #foreach()
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:kav@kav.dk"">Kasper Nielsen</a>
 * @version $Id: ASTDirective.java 720228 2008-11-24 16:58:33Z nbubna $
 */
public class ASTDirective extends SimpleNode
{
    private Directive directive = null;
    private String directiveName = """";
    private boolean isDirective;
    private boolean isInitialized;
    /**
     * @param id
     */
    public ASTDirective(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTDirective(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#init(org.apache.velocity.context.InternalContextAdapter, java.lang.Object)
     */
    public synchronized Object init( InternalContextAdapter context, Object data)
    throws TemplateInitException
    {
        /** method is synchronized to avoid concurrent directive initialization **/
        if (!isInitialized)
        {
            super.init( context, data );
            /*
             *  only do things that are not context dependent
             */
            if (parser.isDirective( directiveName ))
            {
                isDirective = true;
                try
                {
                    directive = (Directive) parser.getDirective( directiveName )
                        .getClass().newInstance();
                } 
                catch (InstantiationException e)
                {
                    throw ExceptionUtils.createRuntimeException(""Couldn't initialize "" +
                            ""directive of class "" +
                            parser.getDirective(directiveName).getClass().getName(),
                            e);
                }
                catch (IllegalAccessException e)
                {
                    throw ExceptionUtils.createRuntimeException(""Couldn't initialize "" +
                            ""directive of class "" +
                            parser.getDirective(directiveName).getClass().getName(),
                            e);
                }
                directive.setLocation( getLine(), getColumn() );
                directive.init(rsvc, context,this);
            }
            else
            {
                /**
                 * Create a new RuntimeMacro
                 */
                directive = new RuntimeMacro(directiveName, getTemplateName());
                directive.setLocation( getLine(), getColumn() );
                /**
                 * Initialize it
                 */
                try
                {
                    directive.init( rsvc, context, this );
                }
                /**
                 * correct the line/column number if an exception is caught
                 */
                catch (TemplateInitException die)
                {
                    throw new TemplateInitException(die.getMessage(),
                            (ParseException) die.getWrappedThrowable(),
                            die.getTemplateName(),
                            die.getColumnNumber() + getColumn(),
                            die.getLineNumber() + getLine());
                }
                isDirective = true;
            }
            isInitialized = true;
        }
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#render(org.apache.velocity.context.InternalContextAdapter, java.io.Writer)
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException,MethodInvocationException, ResourceNotFoundException, ParseErrorException
    {
        /*
         *  normal processing
         */
        if (isDirective)
        {
            directive.render(context, writer, this);
        }
        else
        {
            if (context.getAllowRendering())
            {
                writer.write( ""#"");
                writer.write( directiveName );
            }
        }
        return true;
    }
    /**
     *   Sets the directive name.  Used by the parser.  This keeps us from having to
     *   dig it out of the token stream and gives the parse the change to override.
     * @param str
     */
    public void setDirectiveName( String str )
    {
        directiveName = str;
    }
    /**
     *  Gets the name of this directive.
     *  @return The name of this directive.
     */
    public String getDirectiveName()
    {
        return directiveName;
    }
    /**
     * @since 1.5
     */
    public String toString()
    {
        return new ToStringBuilder(this)
            .appendSuper(super.toString())
            .append(""directiveName"", getDirectiveName())
            .toString();
    }
}
"
org.apache.velocity.runtime.parser.node.ASTDivNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MathException;
import org.apache.velocity.runtime.parser.Parser;
/**
 * Handles number division of nodes<br><br>
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTDivNode.java 691048 2008-09-01 20:26:11Z nbubna $
 */
public class ASTDivNode extends ASTMathNode
{
    /**
     * @param id
     */
    public ASTDivNode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTDivNode(Parser p, int id)
    {
        super(p, id);
    }
    public Number perform(Number left, Number right, InternalContextAdapter context)
    {
        /*
         * check for divide by 0
         */
        if (MathUtils.isZero(right))
        {
            String msg = ""Right side of division operation is zero. Must be non-zero. ""
                          + getLocation(context);
            if (strictMode)
            {
                log.error(msg);
                throw new MathException(msg);
            }
            else
            {
                log.debug(msg);
                return null;
            }
        }
        return MathUtils.divide(left, right);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTElseIfStatement,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.parser.Parser;
/**
 * This class is responsible for handling the ElseIf VTL control statement.
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTElseIfStatement.java 517553 2007-03-13 06:09:58Z wglass $
*/
public class ASTElseIfStatement extends SimpleNode
{
    /**
     * @param id
     */
    public ASTElseIfStatement(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTElseIfStatement(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * An ASTElseStatement is true if the expression
     * it contains evaluates to true. Expressions know
     * how to evaluate themselves, so we do that
     * here and return the value back to ASTIfStatement
     * where this node was originally asked to evaluate
     * itself.
     * @param context
     * @return True if all childs are true.
     * @throws MethodInvocationException
     */
    public boolean evaluate ( InternalContextAdapter context)
        throws MethodInvocationException
    {
        return jjtGetChild(0).evaluate(context);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#render(org.apache.velocity.context.InternalContextAdapter, java.io.Writer)
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException,MethodInvocationException,
        	ResourceNotFoundException, ParseErrorException
    {
        return jjtGetChild(1).render( context, writer );
    }
}
"
org.apache.velocity.runtime.parser.node.ASTElseStatement,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
/**
 * This class is responsible for handling the Else VTL control statement.
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTElseStatement.java 517553 2007-03-13 06:09:58Z wglass $
 */
public class ASTElseStatement extends SimpleNode
{
    /**
     * @param id
     */
    public ASTElseStatement(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTElseStatement(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * An ASTElseStatement always evaluates to
     * true. Basically behaves like an #if(true).
     * @param context
     * @return Always true.
     */
    public boolean evaluate( InternalContextAdapter context)
    {
        return true;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTEQNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.TemplateNumber;
/**
 *  Handles <code>arg1  == arg2</code>
 *
 *  This operator requires that the LHS and RHS are both of the
 *  same Class OR both are subclasses of java.lang.Number
 *
 *  @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 *  @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 *  @version $Id: ASTEQNode.java 691048 2008-09-01 20:26:11Z nbubna $
 */
public class ASTEQNode extends SimpleNode
{
    /**
     * @param id
     */
    public ASTEQNode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTEQNode(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *   Calculates the value of the logical expression
     *
     *     arg1 == arg2
     *
     *   All class types are supported.   Uses equals() to
     *   determine equivalence.  This should work as we represent
     *   with the types we already support, and anything else that
     *   implements equals() to mean more than identical references.
     *
     *
     *  @param context  internal context used to evaluate the LHS and RHS
     *  @return true if equivalent, false if not equivalent,
     *          false if not compatible arguments, or false
     *          if either LHS or RHS is null
     * @throws MethodInvocationException
     */
    public boolean evaluate(InternalContextAdapter context)
        throws MethodInvocationException
    {
        Object left = jjtGetChild(0).value(context);
        Object right = jjtGetChild(1).value(context);
        /*
         *  convert to Number if applicable
         */
        if (left instanceof TemplateNumber)
        {
           left = ( (TemplateNumber) left).getAsNumber();
        }
        if (right instanceof TemplateNumber)
        {
           right = ( (TemplateNumber) right).getAsNumber();
        }
       /*
        * If comparing Numbers we do not care about the Class.
        */
       if (left instanceof Number && right instanceof Number)
       {
           return MathUtils.compare( (Number)left, (Number)right) == 0;
       }
        /**
         * if both are not null, then assume that if one class
         * is a subclass of the other that we should use the equals operator
         */
        if (left != null && right != null &&
            (left.getClass().isAssignableFrom(right.getClass()) ||
             right.getClass().isAssignableFrom(left.getClass())))
        {
            return left.equals( right );
        }
        /*
         * Ok, time to compare string values
         */
        left = (left == null) ? null : left.toString();
        right = (right == null) ? null: right.toString();
        if (left == null && right == null)
        {
            if (log.isDebugEnabled())
            {
                log.debug(""Both right ("" + getLiteral(false) + "" and left ""
                          + getLiteral(true) + "" sides of '==' operation returned null.""
                          + ""If references, they may not be in the context.""
                          + getLocation(context));
            }
            return true;
        }
        else if (left == null || right == null)
        {
            if (log.isDebugEnabled())
            {
                log.debug((left == null ? ""Left"" : ""Right"")
                        + "" side ("" + getLiteral(left == null)
                        + "") of '==' operation has null value. If it is a ""
                        + ""reference, it may not be in the context or its ""
                        + ""toString() returned null. "" + getLocation(context));
            }
            return false;
        }
        else
        {
            return left.equals(right);
        }
    }
    private String getLiteral(boolean left)
    {
        return jjtGetChild(left ? 0 : 1).literal();
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        return evaluate(context) ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTEscape,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
/**
 * This class is responsible for handling Escapes
 *  in VTL.
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTEscape.java 517553 2007-03-13 06:09:58Z wglass $
 */
public class ASTEscape extends SimpleNode
{
    /** Used by the parser */
    public String val;
    private char[] ctext;
    /**
     * @param id
     */
    public ASTEscape(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTEscape(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#init(org.apache.velocity.context.InternalContextAdapter, java.lang.Object)
     */
    public Object init( InternalContextAdapter context, Object data)
    {
        ctext =  val.toCharArray();
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#render(org.apache.velocity.context.InternalContextAdapter, java.io.Writer)
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException
    {
        if (context.getAllowRendering())
        {
            writer.write(ctext);
        }
        return true;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTEscapedDirective,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
/**
 * This class is responsible for handling EscapedDirectives
 *  in VTL.
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTEscapedDirective.java 517553 2007-03-13 06:09:58Z wglass $
 */
public class ASTEscapedDirective extends SimpleNode
{
    /**
     * @param id
     */
    public ASTEscapedDirective(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTEscapedDirective(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#render(org.apache.velocity.context.InternalContextAdapter, java.io.Writer)
     */
    public boolean render(InternalContextAdapter context, Writer writer)
        throws IOException
    {
        if (context.getAllowRendering())
        {
            writer.write(getFirstToken().image);
        }
        return true;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTExpression,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTExpression extends SimpleNode
{
    /**
     * @param id
     */
    public ASTExpression(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTExpression(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#evaluate(org.apache.velocity.context.InternalContextAdapter)
     */
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException
    {
        return jjtGetChild(0).evaluate(context);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        return jjtGetChild(0).value(context);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTFalse,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTFalse extends SimpleNode
{
    private static Boolean value = Boolean.FALSE;
    /**
     * @param id
     */
    public ASTFalse(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTFalse(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#evaluate(org.apache.velocity.context.InternalContextAdapter)
     */
    public boolean evaluate( InternalContextAdapter context)
    {
        return false;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value( InternalContextAdapter context)
    {
        return value;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTFloatingPointLiteral,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.math.BigDecimal;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.parser.Parser;
/**
 * Handles floating point numbers.  The value will be either a Double
 * or a BigDecimal.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @since 1.5
 */
public class ASTFloatingPointLiteral extends SimpleNode
{
    // This may be of type Double or BigDecimal
    private Number value = null;
    /**
     * @param id
     */
    public ASTFloatingPointLiteral(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTFloatingPointLiteral(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  Initialization method - doesn't do much but do the object
     *  creation.  We only need to do it once.
     * @param context
     * @param data
     * @return The data object.
     * @throws TemplateInitException
     */
    public Object init( InternalContextAdapter context, Object data)
        throws TemplateInitException
    {
        /*
         *  init the tree correctly
         */
        super.init( context, data );
        /**
         * Determine the size of the item and make it a Double or BigDecimal as appropriate.
         */
         String str = getFirstToken().image;
         try
         {
             value = new Double( str );
         } catch ( NumberFormatException E1 )
         {
            // if there's still an Exception it will propogate out
            value = new BigDecimal( str );
        }
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value( InternalContextAdapter context)
    {
        return value;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTGENode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.TemplateNumber;
/**
 * Handles arg1 &gt;= arg2<br><br>
 *
 * Only subclasses of Number can be compared.<br><br>
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 */
public class ASTGENode extends SimpleNode
{
    /**
     * @param id
     */
    public ASTGENode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTGENode(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#evaluate(org.apache.velocity.context.InternalContextAdapter)
     */
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            log.error((left == null ? ""Left"" : ""Right"")
                           + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of '>=' operation has null value.""
                           + "" Operation not possible. ""
                           + Log.formatFileString(this));
            return false;
        }
        /*
         *  convert to Number if applicable
         */
        if (left instanceof TemplateNumber)
        {
           left = ( (TemplateNumber) left).getAsNumber();
        }
        if (right instanceof TemplateNumber)
        {
           right = ( (TemplateNumber) right).getAsNumber();
        }
        /*
         *  Only compare Numbers
         */
        if ( !( left instanceof Number )  || !( right instanceof Number ))
        {
            log.error((!(left instanceof Number) ? ""Left"" : ""Right"")
                           + "" side of '>=' operation is not a Number. ""
                           + Log.formatFileString(this));
            return false;
        }
       return MathUtils.compare ( (Number)left,(Number)right) >= 0;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        boolean val = evaluate(context);
        return val ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTGTNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.TemplateNumber;
/**
 * Handles arg1 &gt; arg2<br><br>
 *
 * Only subclasses of Number can be compared.<br><br>
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 */
public class ASTGTNode extends SimpleNode
{
    /**
     * @param id
     */
    public ASTGTNode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTGTNode(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#evaluate(org.apache.velocity.context.InternalContextAdapter)
     */
    public boolean evaluate(InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            log.error((left == null ? ""Left"" : ""Right"")
                           + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of '>' operation has null value.""
                           + "" Operation not possible. ""
                           + Log.formatFileString(this));
            return false;
        }
        /*
         *  convert to Number if applicable
         */
        if (left instanceof TemplateNumber)
        {
           left = ( (TemplateNumber) left).getAsNumber();
        }
        if (right instanceof TemplateNumber)
        {
           right = ( (TemplateNumber) right).getAsNumber();
        }
        /*
         *  Only compare Numbers
         */
        if ( !( left instanceof Number )  || !( right instanceof Number ))
        {
            log.error((!(left instanceof Number) ? ""Left"" : ""Right"")
                           + "" side of '>=' operation is not a Numbere. ""
                           + Log.formatFileString(this));
            return false;
        }
        return MathUtils.compare ( (Number)left,(Number)right) == 1;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        boolean val = evaluate(context);
        return val ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTIdentifier,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.InvocationTargetException;
import org.apache.velocity.app.event.EventHandlerUtil;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.introspection.Info;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
import org.apache.velocity.util.introspection.VelPropertyGet;
/**
 *  ASTIdentifier.java
 *
 *  Method support for identifiers :  $foo
 *
 *  mainly used by ASTRefrence
 *
 *  Introspection is now moved to 'just in time' or at render / execution
 *  time. There are many reasons why this has to be done, but the
 *  primary two are   thread safety, to remove any context-derived
 *  information from class member  variables.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTIdentifier.java 720228 2008-11-24 16:58:33Z nbubna $
 */
public class ASTIdentifier extends SimpleNode
{
    private String identifier = """";
    /**
     *  This is really immutable after the init, so keep one for this node
     */
    protected Info uberInfo;
    /**
     * Indicates if we are running in strict reference mode.
     */
    protected boolean strictRef = false;
    /**
     * @param id
     */
    public ASTIdentifier(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTIdentifier(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  simple init - don't do anything that is context specific.
     *  just get what we need from the AST, which is static.
     * @param context
     * @param data
     * @return The data object.
     * @throws TemplateInitException
     */
    public  Object init(InternalContextAdapter context, Object data)
        throws TemplateInitException
    {
        super.init(context, data);
        identifier = getFirstToken().image;
        uberInfo = new Info(getTemplateName(), getLine(), getColumn());
        strictRef = rsvc.getBoolean(RuntimeConstants.RUNTIME_REFERENCES_STRICT, false);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#execute(java.lang.Object, org.apache.velocity.context.InternalContextAdapter)
     */
    public Object execute(Object o, InternalContextAdapter context)
        throws MethodInvocationException
    {
        VelPropertyGet vg = null;
        try
        {
            /*
             *  first, see if we have this information cached.
             */
            IntrospectionCacheData icd = context.icacheGet(this);
            /*
             * if we have the cache data and the class of the object we are
             * invoked with is the same as that in the cache, then we must
             * be allright.  The last 'variable' is the method name, and
             * that is fixed in the template :)
             */
            if ( icd != null && (o != null) && (icd.contextData == o.getClass()) )
            {
                vg = (VelPropertyGet) icd.thingy;
            }
            else
            {
                /*
                 *  otherwise, do the introspection, and cache it.  Use the
                 *  uberspector
                 */
                vg = rsvc.getUberspect().getPropertyGet(o,identifier, uberInfo);
                if (vg != null && vg.isCacheable() && (o != null))
                {
                    icd = new IntrospectionCacheData();
                    icd.contextData = o.getClass();
                    icd.thingy = vg;
                    context.icachePut(this,icd);
                }
            }
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch(Exception e)
        {
            String msg = ""ASTIdentifier.execute() : identifier = ""+identifier;
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
        /*
         *  we have no getter... punt...
         */
        if (vg == null)
        {
            if (strictRef)
            {
                throw new MethodInvocationException(""Object '"" + o.getClass().getName() +              
                    ""' does not contain property '"" + identifier + ""'"", null, identifier,
                    uberInfo.getTemplateName(), uberInfo.getLine(), uberInfo.getColumn());
            }
            else
            {
                return null;
            }
        }
        /*
         *  now try and execute.  If we get a MIE, throw that
         *  as the app wants to get these.  If not, log and punt.
         */
        try
        {
            return vg.invoke(o);
        }
        catch(InvocationTargetException ite)
        {
            /*
             *  if we have an event cartridge, see if it wants to veto
             *  also, let non-Exception Throwables go...
             */
            Throwable t = ite.getTargetException();
            if (t instanceof Exception)
            {
                try
                {
                    return EventHandlerUtil.methodException(rsvc, context, o.getClass(), vg.getMethodName(),
                            (Exception) t);
                }
                /**
                 * If the event handler throws an exception, then wrap it
                 * in a MethodInvocationException.  Don't pass through RuntimeExceptions like other
                 * similar catchall code blocks.
                 */
                catch( Exception e )
                {
                    throw new MethodInvocationException(
                      ""Invocation of method '"" + vg.getMethodName() + ""'""
                      + "" in  "" + o.getClass()
                      + "" threw exception ""
                      + ite.getTargetException().toString(),
                      ite.getTargetException(), vg.getMethodName(), getTemplateName(), this.getLine(), this.getColumn());
                }
            }
            else
            {
                /*
                 * no event cartridge to override. Just throw
                 */
                throw  new MethodInvocationException(
                ""Invocation of method '"" + vg.getMethodName() + ""'""
                + "" in  "" + o.getClass()
                + "" threw exception ""
                + ite.getTargetException().toString(),
                ite.getTargetException(), vg.getMethodName(), getTemplateName(), this.getLine(), this.getColumn());
            }
        }
        catch(IllegalArgumentException iae)
        {
            return null;
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch(Exception e)
        {
            String msg = ""ASTIdentifier() : exception invoking method ""
                        + ""for identifier '"" + identifier + ""' in ""
                        + o.getClass();
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
    }
}
"
org.apache.velocity.runtime.parser.node.ASTIfStatement,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTIfStatement.java 517553 2007-03-13 06:09:58Z wglass $
*/
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTIfStatement extends SimpleNode
{
    /**
     * @param id
     */
    public ASTIfStatement(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTIfStatement(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#render(org.apache.velocity.context.InternalContextAdapter, java.io.Writer)
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException,MethodInvocationException,
        	ResourceNotFoundException, ParseErrorException
    {
        /*
         * Check if the #if(expression) construct evaluates to true:
         * if so render and leave immediately because there
         * is nothing left to do!
         */
        if (jjtGetChild(0).evaluate(context))
        {
            jjtGetChild(1).render(context, writer);
            return true;
        }
        int totalNodes = jjtGetNumChildren();
        /*
         * Now check the remaining nodes left in the
         * if construct. The nodes are either elseif
         *  nodes or else nodes. Each of these node
         * types knows how to evaluate themselves. If
         * a node evaluates to true then the node will
         * render itself and this method will return
         * as there is nothing left to do.
         */
        for (int i = 2; i < totalNodes; i++)
        {
            if (jjtGetChild(i).evaluate(context))
            {
                jjtGetChild(i).render(context, writer);
                return true;
            }
        }
        /*
         * This is reached when an ASTIfStatement
         * consists of an if/elseif sequence where
         * none of the nodes evaluate to true.
         */
        return true;
    }
    /**
     * @param context
     * @param visitor
     */
    public void process( InternalContextAdapter context, ParserVisitor visitor)
    {
    }
}
"
org.apache.velocity.runtime.parser.node.ASTIncludeStatement,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTIncludeStatement extends SimpleNode
{
    /**
     * @param id
     */
    public ASTIncludeStatement(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTIncludeStatement(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTIntegerLiteral,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.math.BigInteger;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.parser.Parser;
/**
 * Handles integer numbers.  The value will be either an Integer, a Long, or a BigInteger.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @since 1.5
 */
public class ASTIntegerLiteral extends SimpleNode
{
    // This may be of type Integer, Long or BigInteger
    private Number value = null;
    /**
     * @param id
     */
    public ASTIntegerLiteral(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTIntegerLiteral(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#init(org.apache.velocity.context.InternalContextAdapter, java.lang.Object)
     */
    public Object init( InternalContextAdapter context, Object data)
        throws TemplateInitException
    {
        /*
         *  init the tree correctly
         */
        super.init( context, data );
        /**
         * Determine the size of the item and make it an Integer, Long, or BigInteger as appropriate.
         */
         String str = getFirstToken().image;
         try
         {
             value = new Integer( str );
         }
         catch ( NumberFormatException E1 )
         {
            try
            {
                value = new Long( str );
            }
            catch ( NumberFormatException E2 )
            {
                // if there's still an Exception it will propogate out
                value = new BigInteger( str );
            }
        }
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value( InternalContextAdapter context)
    {
        return value;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTIntegerRange,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.ArrayList;
import java.util.List;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.Parser;
/**
 * handles the range 'operator'  [ n .. m ]
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 */
public class ASTIntegerRange extends SimpleNode
{
    /**
     * @param id
     */
    public ASTIntegerRange(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTIntegerRange(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  does the real work.  Creates an Vector of Integers with the
     *  right value range
     *
     *  @param context  app context used if Left or Right of .. is a ref
     *  @return Object array of Integers
     * @throws MethodInvocationException
     */
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  get the two range ends
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            log.error((left == null ? ""Left"" : ""Right"")
                           + "" side of range operator [n..m] has null value.""
                           + "" Operation not possible. ""
                           + Log.formatFileString(this));
            return null;
        }
        /*
         *  if not a Number, not much we can do either
         */
        if ( !( left instanceof Number )  || !( right instanceof Number ))
        {
            log.error((!(left instanceof Number) ? ""Left"" : ""Right"")
                           + "" side of range operator is not a valid type. ""
                           + ""Currently only integers (1,2,3...) and the Number type are supported. ""
                           + Log.formatFileString(this));
            return null;
        }
        /*
         *  get the two integer values of the ends of the range
         */
        int l = ((Number) left).intValue() ;
        int r = ((Number) right).intValue();
        /*
         *  find out how many there are
         */
        int nbrElements = Math.abs( l - r );
        nbrElements += 1;
        /*
         *  Determine whether the increment is positive or negative.
         */
        int delta = ( l >= r ) ? -1 : 1;
        /*
         * Fill the range with the appropriate values.
         */
        List elements = new ArrayList(nbrElements);
        int value = l;
        for (int i = 0; i < nbrElements; i++)
        {
            // TODO: JDK 1.4+ -> valueOf()
            elements.add(new Integer(value));
            value += delta;
        }
        return elements;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTLENode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.TemplateNumber;
/**
 * Handles arg1 &lt;= arg2<br><br>
 *
 * Only subclasses of Number can be compared.<br><br>
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 */
public class ASTLENode extends SimpleNode
{
    /**
     * @param id
     */
    public ASTLENode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTLENode(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#evaluate(org.apache.velocity.context.InternalContextAdapter)
     */
    public boolean evaluate( InternalContextAdapter context)
      throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            log.error((left == null ? ""Left"" : ""Right"")
                           + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of '<=' operation has null value.""
                           + "" Operation not possible. ""
                           + Log.formatFileString(this));
            return false;
        }
        /*
         *  convert to Number if applicable
         */
        if (left instanceof TemplateNumber)
        {
           left = ( (TemplateNumber) left).getAsNumber();
        }
        if (right instanceof TemplateNumber)
        {
           right = ( (TemplateNumber) right).getAsNumber();
        }
        /*
         *  Only compare Numbers
         */
        if ( !( left instanceof Number )  || !( right instanceof Number ))
        {
            log.error((!(left instanceof Number) ? ""Left"" : ""Right"")
                           + "" side of '>=' operation is not a Number. ""
                           + Log.formatFileString(this));
            return false;
        }
        return MathUtils.compare ( (Number)left,(Number)right) <= 0;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        boolean val = evaluate(context);
        return val ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTLTNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.TemplateNumber;
/**
 * Handles arg1 &lt; arg2<br><br>
 *
 * Only subclasses of Number can be compared.<br><br>
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 */
public class ASTLTNode extends SimpleNode
{
    /**
     * @param id
     */
    public ASTLTNode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTLTNode(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#evaluate(org.apache.velocity.context.InternalContextAdapter)
     */
    public boolean evaluate(InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  get the two args
         */
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  if either is null, lets log and bail
         */
        if (left == null || right == null)
        {
            log.error((left == null ? ""Left"" : ""Right"")
                           + "" side (""
                           + jjtGetChild( (left == null? 0 : 1) ).literal()
                           + "") of '<' operation has null value.""
                           + "" Operation not possible. ""
                           + Log.formatFileString(this));
            return false;
        }
        /*
         *  convert to Number if applicable
         */
        if (left instanceof TemplateNumber)
        {
           left = ( (TemplateNumber) left).getAsNumber();
        }
        if (right instanceof TemplateNumber)
        {
           right = ( (TemplateNumber) right).getAsNumber();
        }
        /*
         *  Only compare Numbers
         */
        if ( !( left instanceof Number )  || !( right instanceof Number ))
        {
            log.error((!(left instanceof Number) ? ""Left"" : ""Right"")
                           + "" side of '>=' operation is not a valid Number. ""
                           + Log.formatFileString(this));
            return false;
        }
        return MathUtils.compare ( (Number)left,(Number)right) == -1;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        boolean val = evaluate(context);
        return val ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTMap,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.HashMap;
import java.util.Map;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.parser.Parser;
/**
 * AST Node for creating a map / dictionary.
 *
 * This class was originally generated from Parset.jjt.
 *
 * @version $Id: ASTMap.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class ASTMap extends SimpleNode
{
    /**
     * @param id
     */
    public ASTMap(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTMap(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        int size = jjtGetNumChildren();
        Map objectMap = new HashMap();
        for (int i = 0; i < size; i += 2)
        {
            SimpleNode keyNode = (SimpleNode) jjtGetChild(i);
            SimpleNode valueNode = (SimpleNode) jjtGetChild(i+1);
            Object key = (keyNode == null ? null : keyNode.value(context));
            Object value = (valueNode == null ? null : valueNode.value(context));
            objectMap.put(key, value);
        }
        return objectMap;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTMathNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MathException;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.TemplateNumber;
/**
 * Helps handle math<br><br>
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author Nathan Bubna
 * @version $Id: ASTMathNode.java 517553 2007-03-13 06:09:58Z wglass $
 */
public abstract class ASTMathNode extends SimpleNode
{
    protected boolean strictMode = false;
    public ASTMathNode(int id)
    {
        super(id);
    }
    public ASTMathNode(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * {@inheritDoc}
     */
    public Object init(InternalContextAdapter context, Object data) throws TemplateInitException
    {
        super.init(context, data);
        strictMode = rsvc.getBoolean(RuntimeConstants.STRICT_MATH, false);
        return data;
    }
    /**
     * {@inheritDoc}
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * gets the two args and performs the operation on them
     *
     * @param context
     * @return result or null
     * @throws MethodInvocationException
     */
    public Object value(InternalContextAdapter context) throws MethodInvocationException
    {
        Object left = jjtGetChild(0).value(context);
        Object right = jjtGetChild(1).value(context);
        /*
         * should we do anything special here?
         */
        Object special = handleSpecial(left, right, context);
        if (special != null)
        {
            return special;
        }
        /*
         * convert to Number if applicable
         */
        if (left instanceof TemplateNumber)
        {
           left = ((TemplateNumber)left).getAsNumber();
        }
        if (right instanceof TemplateNumber)
        {
           right = ((TemplateNumber)right).getAsNumber();
        }
        /*
         * if not a Number, not much we can do
         */
        if (!(left instanceof Number) || !(right instanceof Number))
        {
            boolean wrongright = (left instanceof Number);
            boolean wrongtype = wrongright ? right != null : left != null;
            String msg = (wrongright ? ""Right"" : ""Left"")
                        + "" side of math operation (""
                        + jjtGetChild(wrongright ? 1 : 0).literal() + "") ""
                        + (wrongtype ? ""is not a Number. "" : ""has a null value. "")
                        + getLocation(context);
            if (strictMode)
            {
                log.error(msg);
                throw new MathException(msg);
            }
            else
            {
                log.debug(msg);
                return null;
            }
        }
        return perform((Number)left, (Number)right, context);
    }
    /**
     * Extension hook to allow special behavior by subclasses
     * If this method returns a non-null value, that is returned,
     * rather than the result of the math operation.
     * @see ASTAddNode#handleSpecial
     */
    protected Object handleSpecial(Object left, Object right, InternalContextAdapter context)
    {
        // do nothing, this is an extension hook
        return null;
    }
    /**
     * Performs the math operation represented by this node.
     */
    public abstract Number perform(Number left, Number right, InternalContextAdapter context);
}
"
org.apache.velocity.runtime.parser.node.ASTMethod,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.InvocationTargetException;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.velocity.app.event.EventHandlerUtil;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.introspection.Info;
import org.apache.velocity.util.introspection.IntrospectionCacheData;
import org.apache.velocity.util.introspection.VelMethod;
/**
 *  ASTMethod.java
 *
 *  Method support for references :  $foo.method()
 *
 *  NOTE :
 *
 *  introspection is now done at render time.
 *
 *  Please look at the Parser.jjt file which is
 *  what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTMethod.java 720228 2008-11-24 16:58:33Z nbubna $
 */
public class ASTMethod extends SimpleNode
{
    private String methodName = """";
    private int paramCount = 0;
    protected Info uberInfo;
    /**
     * Indicates if we are running in strict reference mode.
     */
    protected boolean strictRef = false;
    /**
     * @param id
     */
    public ASTMethod(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTMethod(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  simple init - init our subtree and get what we can from
     *  the AST
     * @param context
     * @param data
     * @return The init result
     * @throws TemplateInitException
     */
    public Object init(  InternalContextAdapter context, Object data)
        throws TemplateInitException
    {
        super.init(  context, data );
        /*
         * make an uberinfo - saves new's later on
         */
        uberInfo = new Info(getTemplateName(),
                getLine(),getColumn());
        /*
         *  this is about all we can do
         */
        methodName = getFirstToken().image;
        paramCount = jjtGetNumChildren() - 1;
        strictRef = rsvc.getBoolean(RuntimeConstants.RUNTIME_REFERENCES_STRICT, false);
        return data;
    }
    /**
     *  invokes the method.  Returns null if a problem, the
     *  actual return if the method returns something, or
     *  an empty string """" if the method returns void
     * @param o
     * @param context
     * @return Result or null.
     * @throws MethodInvocationException
     */
    public Object execute(Object o, InternalContextAdapter context)
        throws MethodInvocationException
    {
        /*
         *  new strategy (strategery!) for introspection. Since we want
         *  to be thread- as well as context-safe, we *must* do it now,
         *  at execution time.  There can be no in-node caching,
         *  but if we are careful, we can do it in the context.
         */
        VelMethod method = null;
        Object [] params = new Object[paramCount];
        try
        {
            /*
             * sadly, we do need recalc the values of the args, as this can
             * change from visit to visit
             */
            final Class[] paramClasses = paramCount > 0 ? new Class[paramCount] : ArrayUtils.EMPTY_CLASS_ARRAY;
            for (int j = 0; j < paramCount; j++)
            {
                params[j] = jjtGetChild(j + 1).value(context);
                if (params[j] != null)
                {
                    paramClasses[j] = params[j].getClass();
                }
            }
            /*
             *   check the cache
             */
            MethodCacheKey mck = new MethodCacheKey(methodName, paramClasses);
            IntrospectionCacheData icd =  context.icacheGet( mck );
            /*
             *  like ASTIdentifier, if we have cache information, and the
             *  Class of Object o is the same as that in the cache, we are
             *  safe.
             */
            if ( icd != null && (o != null && icd.contextData == o.getClass()) )
            {
                /*
                 * get the method from the cache
                 */
                method = (VelMethod) icd.thingy;
            }
            else
            {
                /*
                 *  otherwise, do the introspection, and then
                 *  cache it
                 */
                method = rsvc.getUberspect().getMethod(o, methodName, params, new Info(getTemplateName(), getLine(), getColumn()));
                if ((method != null) && (o != null))
                {
                    icd = new IntrospectionCacheData();
                    icd.contextData = o.getClass();
                    icd.thingy = method;
                    context.icachePut( mck, icd );
                }
            }
            /*
             *  if we still haven't gotten the method, either we are calling
             *  a method that doesn't exist (which is fine...)  or I screwed
             *  it up.
             */
            if (method == null)
            {
                if (strictRef)                  
                {
                    // Create a parameter list for the exception error message
                    StringBuffer plist = new StringBuffer();
                    for (int i=0; i<params.length; i++)
                    {
                      Class param = paramClasses[i];
                      plist.append(param == null ? ""null"" : param.getName());
                      if (i < params.length -1) plist.append("", "");
                    }
                    throw new MethodInvocationException(""Object '"" + o.getClass().getName() +
                      ""' does not contain method "" + methodName + ""("" + plist + "")"", 
                      null, methodName, uberInfo.getTemplateName(), uberInfo.getLine(), uberInfo.getColumn());
                }
                else
                {
                    return null;
                }
            }
        }
        catch( MethodInvocationException mie )
        {
            /*
             *  this can come from the doIntrospection(), as the arg values
             *  are evaluated to find the right method signature.  We just
             *  want to propogate it here, not do anything fancy
             */
            throw mie;
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch( Exception e )
        {
            /*
             *  can come from the doIntropection() also, from Introspector
             */
            String msg = ""ASTMethod.execute() : exception from introspection"";
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
        try
        {
            /*
             *  get the returned object.  It may be null, and that is
             *  valid for something declared with a void return type.
             *  Since the caller is expecting something to be returned,
             *  as long as things are peachy, we can return an empty
             *  String so ASTReference() correctly figures out that
             *  all is well.
             */
            Object obj = method.invoke(o, params);
            if (obj == null)
            {
                if( method.getReturnType() == Void.TYPE)
                {
                    return """";
                }
            }
            return obj;
        }
        catch( InvocationTargetException ite )
        {
            return handleInvocationException(o, context, ite.getTargetException());
        }
        /** Can also be thrown by method invocation **/
        catch( IllegalArgumentException t )
        {
            return handleInvocationException(o, context, t);
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch( Exception e )
        {
            String msg = ""ASTMethod.execute() : exception invoking method '""
                         + methodName + ""' in "" + o.getClass();
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
    }
    private Object handleInvocationException(Object o, InternalContextAdapter context, Throwable t)
    {
        /*
         *  In the event that the invocation of the method
         *  itself throws an exception, we want to catch that
         *  wrap it, and throw.  We don't log here as we want to figure
         *  out which reference threw the exception, so do that
         *  above
         */
        /*
         *  let non-Exception Throwables go...
         */
        if (t instanceof Exception)
        {
            try
            {
                return EventHandlerUtil.methodException( rsvc, context, o.getClass(), methodName, (Exception) t );
            }
            /**
             * If the event handler throws an exception, then wrap it
             * in a MethodInvocationException.  Don't pass through RuntimeExceptions like other
             * similar catchall code blocks.
             */
            catch( Exception e )
            {
                throw new MethodInvocationException(
                    ""Invocation of method '""
                    + methodName + ""' in  "" + o.getClass()
                    + "" threw exception ""
                    + e.toString(),
                    e, methodName, getTemplateName(), this.getLine(), this.getColumn());
            }
        }
        else
        {
            /*
             * no event cartridge to override. Just throw
             */
            throw new MethodInvocationException(
            ""Invocation of method '""
            + methodName + ""' in  "" + o.getClass()
            + "" threw exception ""
            + t.toString(),
            t, methodName, getTemplateName(), this.getLine(), this.getColumn());
        }
    }
    /**
     * Internal class used as key for method cache.  Combines
     * ASTMethod fields with array of parameter classes.  Has
     * public access (and complete constructor) for unit test 
     * purposes.
     * @since 1.5
     */
    public static class MethodCacheKey
    {
        private final String methodName;  
        private final Class[] params;
        public MethodCacheKey(String methodName, Class[] params)
        {
            /** 
             * Should never be initialized with nulls, but to be safe we refuse 
             * to accept them.
             */
            this.methodName = (methodName != null) ? methodName : StringUtils.EMPTY;
            this.params = (params != null) ? params : ArrayUtils.EMPTY_CLASS_ARRAY;
        }
        /**
         * @see java.lang.Object#equals(java.lang.Object)
         */
        public boolean equals(Object o)
        {
            /** 
             * note we skip the null test for methodName and params
             * due to the earlier test in the constructor
             */            
            if (o instanceof MethodCacheKey) 
            {
                final MethodCacheKey other = (MethodCacheKey) o;                
                if (params.length == other.params.length && 
                        methodName.equals(other.methodName)) 
                {              
                    for (int i = 0; i < params.length; ++i) 
                    {
                        if (params[i] == null)
                        {
                            if (params[i] != other.params[i])
                            {
                                return false;
                            }
                        }
                        else if (!params[i].equals(other.params[i]))
                        {
                            return false;
                        }
                    }
                    return true;
                }
            }
            return false;
        }
        /**
         * @see java.lang.Object#hashCode()
         */
        public int hashCode()
        {
            int result = 17;
            /** 
             * note we skip the null test for methodName and params
             * due to the earlier test in the constructor
             */            
            for (int i = 0; i < params.length; ++i)
            {
                final Class param = params[i];
                if (param != null)
                {
                    result = result * 37 + param.hashCode();
                }
            }
            result = result * 37 + methodName.hashCode();
            return result;
        } 
    }
    /**
     * @return Returns the methodName.
     * @since 1.5
     */
    public String getMethodName()
    {
        return methodName;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTModNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MathException;
import org.apache.velocity.runtime.parser.Parser;
/**
 * Handles modulus division<br><br>
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTModNode.java 691048 2008-09-01 20:26:11Z nbubna $
 */
public class ASTModNode extends ASTMathNode
{
    /**
     * @param id
     */
    public ASTModNode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTModNode(Parser p, int id)
    {
        super(p, id);
    }
    public Number perform(Number left, Number right, InternalContextAdapter context)
    {
        /*
         * check for divide / modulo by 0
         */
        if (MathUtils.isZero(right))
        {
            String msg = ""Right side of modulus operation is zero. Must be non-zero. ""
                        + getLocation(context);
            if (strictMode)
            {
                log.error(msg);
                throw new MathException(msg);
            }
            else
            {
                log.debug(msg);
                return null;
            }
        }
        return MathUtils.modulo(left, right);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTMulNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
/**
 * Handles multiplication<br><br>
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTMulNode.java 691048 2008-09-01 20:26:11Z nbubna $
 */
public class ASTMulNode extends ASTMathNode
{
    /**
     * @param id
     */
    public ASTMulNode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTMulNode(Parser p, int id)
    {
        super(p, id);
    }
    public Number perform(Number left, Number right, InternalContextAdapter context)
    {
        return MathUtils.multiply(left, right);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTNENode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.TemplateNumber;
/**
 *  Handles <code>arg1  != arg2</code>
 *
 *  This operator requires that the LHS and RHS are both of the
 *  same Class OR both are subclasses of java.lang.Number
 *
 *  @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 *  @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 */
public class ASTNENode extends SimpleNode
{
    /**
     * @param id
     */
    public ASTNENode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTNENode(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#evaluate(org.apache.velocity.context.InternalContextAdapter)
     */
    public boolean evaluate(  InternalContextAdapter context)
        throws MethodInvocationException
    {
        Object left = jjtGetChild(0).value( context );
        Object right = jjtGetChild(1).value( context );
        /*
         *  convert to Number if applicable
         */
        if (left instanceof TemplateNumber)
        {
           left = ( (TemplateNumber) left).getAsNumber();
        }
        if (right instanceof TemplateNumber)
        {
           right = ( (TemplateNumber) right).getAsNumber();
        }
       /*
        * If comparing Numbers we do not care about the Class.
        */
       if (left instanceof Number && right instanceof Number)
       {
            return MathUtils.compare ( (Number)left,(Number)right) != 0;
       }
        /**
         * if both are not null, then assume that if one class
         * is a subclass of the other that we should use the equals operator
         */
        if (left != null && right != null &&
            (left.getClass().isAssignableFrom(right.getClass()) ||
             right.getClass().isAssignableFrom(left.getClass())))
        {
            return !left.equals( right );
        }
        /*
         * Ok, time to compare string values
         */
        left = (left == null) ? null : left.toString();
        right = (right == null) ? null: right.toString();
        if (left == null && right == null)
        {
            if (log.isDebugEnabled())
            {
                log.debug(""Both right ("" + getLiteral(false) + "" and left ""
                          + getLiteral(true) + "" sides of '!=' operation returned null.""
                          + ""If references, they may not be in the context.""
                          + getLocation(context));
            }
            return false;
        }
        else if (left == null || right == null)
        {
            if (log.isDebugEnabled())
            {
                log.debug((left == null ? ""Left"" : ""Right"")
                        + "" side ("" + getLiteral(left == null)
                        + "") of '!=' operation has null value. If it is a ""
                        + ""reference, it may not be in the context or its ""
                        + ""toString() returned null. "" + getLocation(context));
            }
            return true;
        }
        else
        {
            return !left.equals(right);
        }
    }
    private String getLiteral(boolean left)
    {
        return jjtGetChild(left ? 0 : 1).literal();
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        boolean val = evaluate(context);
        return val ? Boolean.TRUE : Boolean.FALSE;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTNotNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTNotNode extends SimpleNode
{
    /**
     * @param id
     */
    public ASTNotNode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTNotNode(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#evaluate(org.apache.velocity.context.InternalContextAdapter)
     */
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException
    {
        if (jjtGetChild(0).evaluate(context))
            return false;
        else
            return true;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        return (jjtGetChild(0).evaluate( context ) ? Boolean.FALSE : Boolean.TRUE) ;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTObjectArray,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.ArrayList;
import java.util.List;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTObjectArray extends SimpleNode
{
    /**
     * @param id
     */
    public ASTObjectArray(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTObjectArray(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        int size = jjtGetNumChildren();
        // since we know the amount of elements, initialize arraylist with proper size
        List objectArray = new ArrayList(size);
        for (int i = 0; i < size; i++)
        {
            objectArray.add(jjtGetChild(i).value(context));
        }
        return objectArray;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTOrNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.parser.Parser;
/**
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTOrNode.java 685370 2008-08-12 23:36:35Z nbubna $
*/
public class ASTOrNode extends SimpleNode
{
    /**
     * @param id
     */
    public ASTOrNode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTOrNode(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  Returns the value of the expression.
     *  Since the value of the expression is simply the boolean
     *  result of evaluate(), lets return that.
     * @param context
     * @return The Expression value.
     * @throws MethodInvocationException
     */
    public Object value(InternalContextAdapter context )
        throws MethodInvocationException
    {
        // TODO: JDK 1.4+ -> valueOf()
        // return new Boolean(evaluate(context));
        return evaluate(context) ? Boolean.TRUE : Boolean.FALSE;
    }
    /**
     *  the logical or :
     *    the rule :
     *      left || null -> left
     *      null || right -> right
     *      null || null -> false
     *      left || right ->  left || right
     * @param context
     * @return The evaluation result.
     * @throws MethodInvocationException
     */
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException
    {
        Node left = jjtGetChild(0);
        Node right = jjtGetChild(1);
        /*
         *  if the left is not null and true, then true
         */
        if (left != null && left.evaluate( context ) )
            return true;
        /*
         *  same for right
         */
        if ( right != null && right.evaluate( context ) )
            return true;
        return false;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTParameters,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTParameters extends SimpleNode
{
    /**
     * @param id
     */
    public ASTParameters(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTParameters(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTprocess,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTprocess extends SimpleNode
{
    /**
     * @param id
     */
    public ASTprocess(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTprocess(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTReference,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import java.lang.reflect.InvocationTargetException;
import org.apache.velocity.app.event.EventHandlerUtil;
import org.apache.velocity.context.Context;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.Renderable;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.Token;
import org.apache.velocity.util.introspection.Info;
import org.apache.velocity.util.introspection.VelPropertySet;
/**
 * This class is responsible for handling the references in
 * VTL ($foo).
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:Christoph.Reck@dlr.de"">Christoph Reck</a>
 * @author <a href=""mailto:kjohnson@transparent.com>Kent Johnson</a>
 * @version $Id: ASTReference.java 720228 2008-11-24 16:58:33Z nbubna $
*/
public class ASTReference extends SimpleNode
{
    /* Reference types */
    private static final int NORMAL_REFERENCE = 1;
    private static final int FORMAL_REFERENCE = 2;
    private static final int QUIET_REFERENCE = 3;
    private static final int RUNT = 4;
    private int referenceType;
    private String nullString;
    private String rootString;
    private boolean escaped = false;
    private boolean computableReference = true;
    private boolean logOnNull = true;
    private String escPrefix = """";
    private String morePrefix = """";
    private String identifier = """";
    private String literal = null;
    /**
     * Indicates if we are running in strict reference mode.
     */
    public boolean strictRef = false;
    private int numChildren = 0;
    protected Info uberInfo;
    /**
     * @param id
     */
    public ASTReference(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTReference(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#init(org.apache.velocity.context.InternalContextAdapter, java.lang.Object)
     */
    public Object init(InternalContextAdapter context, Object data)
    throws TemplateInitException
    {
        /*
         *  init our children
         */
        super.init(context, data);
        /*
         *  the only thing we can do in init() is getRoot()
         *  as that is template based, not context based,
         *  so it's thread- and context-safe
         */
        rootString = getRoot();
        numChildren = jjtGetNumChildren();
        /*
         * and if appropriate...
         */
        if (numChildren > 0 )
        {
            identifier = jjtGetChild(numChildren - 1).getFirstToken().image;
        }
        /*
         * make an uberinfo - saves new's later on
         */
        uberInfo = new Info(getTemplateName(), getLine(),getColumn());
        /*
         * track whether we log invalid references
         */
        logOnNull =
            rsvc.getBoolean(RuntimeConstants.RUNTIME_LOG_REFERENCE_LOG_INVALID, true);
        strictRef = rsvc.getBoolean(RuntimeConstants.RUNTIME_REFERENCES_STRICT, false);
        /**
         * In the case we are referencing a variable with #if($foo) or
         * #if( ! $foo) then we allow variables to be undefined and we 
         * set strictRef to false so that if the variable is undefined
         * an exception is not thrown. 
         */
        if (strictRef && numChildren == 0)
        {
            logOnNull = false; // Strict mode allows nulls
            Node node = this.jjtGetParent();
            if (node instanceof ASTNotNode     // #if( ! $foo)
             || node instanceof ASTExpression  // #if( $foo )
             || node instanceof ASTOrNode      // #if( $foo || ...
             || node instanceof ASTAndNode)    // #if( $foo && ...
            {
                // Now scan up tree to see if we are in an If statement
                while (node != null)
                {
                    if (node instanceof ASTIfStatement)
                    {
                       strictRef = false;
                       break;
                    }
                    node = node.jjtGetParent();
                }
            }
        }
        return data;
    }
    /**
     *  Returns the 'root string', the reference key
     * @return the root string.
     */
     public String getRootString()
     {
        return rootString;
     }
    /**
     *   gets an Object that 'is' the value of the reference
     *
     *   @param o   unused Object parameter
     *   @param context context used to generate value
     * @return The execution result.
     * @throws MethodInvocationException
     */
    public Object execute(Object o, InternalContextAdapter context)
        throws MethodInvocationException
    {
        if (referenceType == RUNT)
            return null;
        /*
         *  get the root object from the context
         */
        Object result = getVariableValue(context, rootString);
        if (result == null && !strictRef)
        {
            return EventHandlerUtil.invalidGetMethod(rsvc, context, 
                    ""$"" + rootString, null, null, uberInfo);
        }
        /*
         * Iteratively work 'down' (it's flat...) the reference
         * to get the value, but check to make sure that
         * every result along the path is valid. For example:
         *
         * $hashtable.Customer.Name
         *
         * The $hashtable may be valid, but there is no key
         * 'Customer' in the hashtable so we want to stop
         * when we find a null value and return the null
         * so the error gets logged.
         */
        try
        {
            Object previousResult = result; 
            int failedChild = -1;
            for (int i = 0; i < numChildren; i++)
            {
                if (strictRef && result == null)
                {
                    /**
                     * At this point we know that an attempt is about to be made
                     * to call a method or property on a null value.
                     */
                    String name = jjtGetChild(i).getFirstToken().image;
                    throw new VelocityException(""Attempted to access '""  
                        + name + ""' on a null value at ""
                        + Log.formatFileString(uberInfo.getTemplateName(),
                        + jjtGetChild(i).getLine(), jjtGetChild(i).getColumn()));                  
                }
                previousResult = result;
                result = jjtGetChild(i).execute(result,context);
                if (result == null && !strictRef)  // If strict and null then well catch this
                                                   // next time through the loop
                {
                    failedChild = i;
                    break;
                }
            }
            if (result == null)
            {
                if (failedChild == -1)
                {
                    result = EventHandlerUtil.invalidGetMethod(rsvc, context, 
                            ""$"" + rootString, previousResult, null, uberInfo);                    
                }
                else
                {
                    StringBuffer name = new StringBuffer(""$"").append(rootString);
                    for (int i = 0; i <= failedChild; i++)
                    {
                        Node node = jjtGetChild(i);
                        if (node instanceof ASTMethod)
                        {
                            name.append(""."").append(((ASTMethod) node).getMethodName()).append(""()"");
                        }
                        else
                        {
                            name.append(""."").append(node.getFirstToken().image);
                        }
                    }
                    if (jjtGetChild(failedChild) instanceof ASTMethod)
                    {
                        String methodName = ((ASTMethod) jjtGetChild(failedChild)).getMethodName();
                        result = EventHandlerUtil.invalidMethod(rsvc, context, 
                                name.toString(), previousResult, methodName, uberInfo);                                                                
                    }
                    else
                    {
                        String property = jjtGetChild(failedChild).getFirstToken().image;
                        result = EventHandlerUtil.invalidGetMethod(rsvc, context, 
                                name.toString(), previousResult, property, uberInfo);                        
                    }
                }
            }
            return result;
        }
        catch(MethodInvocationException mie)
        {
            /*
             *  someone tossed their cookies
             */
            log.error(""Method "" + mie.getMethodName()
                      + "" threw exception for reference $"" + rootString + "" in ""
                      + Log.formatFileString(this));
            mie.setReferenceName(rootString);
            throw mie;
        }
    }
    /**
     *  gets the value of the reference and outputs it to the
     *  writer.
     *
     *  @param context  context of data to use in getting value
     *  @param writer   writer to render to
     * @return True if rendering was successful.
     * @throws IOException
     * @throws MethodInvocationException
     */
    public boolean render(InternalContextAdapter context, Writer writer) throws IOException,
            MethodInvocationException
    {
        if (referenceType == RUNT)
        {
            if (context.getAllowRendering())
            {
                writer.write(rootString);
            }
            return true;
        }
        Object value = execute(null, context);
        String localNullString = null;
        /*
         * if this reference is escaped (\$foo) then we want to do one of two things : 1) if this is
         * a reference in the context, then we want to print $foo 2) if not, then \$foo (its
         * considered schmoo, not VTL)
         */
        if (escaped)
        {
            localNullString = getNullString(context);
            if (value == null)
            {
                if (context.getAllowRendering())
                {
                    writer.write(escPrefix);
                    writer.write(""\\"");
                    writer.write(localNullString);
                }
            }
            else
            {
                if (context.getAllowRendering())
                {
                    writer.write(escPrefix);
                    writer.write(localNullString);
                }
            }
            return true;
        }
        /*
         * the normal processing
         * 
         * if we have an event cartridge, get a new value object
         */
        value = EventHandlerUtil.referenceInsert(rsvc, context, literal(), value);
        String toString = null;
        if (value != null)
        {
            if(value instanceof Renderable && ((Renderable)value).render(context,writer))
            {
                return true;
            }
            toString = value.toString();
        }
        if (value == null || toString == null)
        {
            /*
             * write prefix twice, because it's schmoo, so the \ don't escape each other...
             */
            if (context.getAllowRendering())
            {
                localNullString = getNullString(context);
                writer.write(escPrefix);
                writer.write(escPrefix);
                writer.write(morePrefix);
                writer.write(localNullString);
            }
            if (logOnNull && referenceType != QUIET_REFERENCE && log.isDebugEnabled())
            {
                log.debug(""Null reference [template '"" + getTemplateName()
                        + ""', line "" + this.getLine() + "", column "" + this.getColumn() + ""] : ""
                        + this.literal() + "" cannot be resolved."");
            }
            return true;
        }
        else
        {
            /*
             * non-null processing
             */
            if (context.getAllowRendering())
            {
                writer.write(escPrefix);
                writer.write(morePrefix);
                writer.write(toString);
            }
            return true;
        }
    }
    /**
     * This method helps to implement the ""render literal if null"" functionality.
     * 
     * VelocimacroProxy saves references to macro arguments (AST nodes) so that if we have a macro
     * #foobar($a $b) then there is key ""$a.literal"" which points to the literal presentation of the
     * argument provided to variable $a. If the value of $a is null, we render the string that was
     * provided as the argument.
     * 
     * @param context
     * @return
     */
    private String getNullString(InternalContextAdapter context)
    {
        Object callingArgument = context.get("".literal."" + nullString);
        if (callingArgument != null)
            return ((Node) callingArgument).literal();
        else
            return nullString;
    }
    /**
     *   Computes boolean value of this reference
     *   Returns the actual value of reference return type
     *   boolean, and 'true' if value is not null
     *
     *   @param context context to compute value with
     * @return True if evaluation was ok.
     * @throws MethodInvocationException
     */
    public boolean evaluate(InternalContextAdapter context)
        throws MethodInvocationException
    {
        Object value = execute(null, context);
        if (value == null)
        {
            return false;
        }
        else if (value instanceof Boolean)
        {
            if (((Boolean) value).booleanValue())
                return true;
            else
                return false;
        }
        else if (value.toString() == null)
        {
            return false;
        }
        else
            return true;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value(InternalContextAdapter context)
        throws MethodInvocationException
    {
        return (computableReference ? execute(null, context) : null);
    }
    /**
     *  Sets the value of a complex reference (something like $foo.bar)
     *  Currently used by ASTSetReference()
     *
     *  @see ASTSetDirective
     *
     *  @param context context object containing this reference
     *  @param value Object to set as value
     *  @return true if successful, false otherwise
     * @throws MethodInvocationException
     */
    public boolean setValue( InternalContextAdapter context, Object value)
      throws MethodInvocationException
    {
        if (jjtGetNumChildren() == 0)
        {
            context.put(rootString, value);
            return true;
        }
        /*
         *  The rootOfIntrospection is the object we will
         *  retrieve from the Context. This is the base
         *  object we will apply reflection to.
         */
        Object result = getVariableValue(context, rootString);
        if (result == null)
        {
            String msg = ""reference set is not a valid reference at ""
                    + Log.formatFileString(uberInfo);
            log.error(msg);
            return false;
        }
        /*
         * How many child nodes do we have?
         */
        for (int i = 0; i < numChildren - 1; i++)
        {
            result = jjtGetChild(i).execute(result, context);
            if (result == null)
            {
                if (strictRef)
                {
                    String name = jjtGetChild(i+1).getFirstToken().image;
                    throw new MethodInvocationException(""Attempted to access '""  
                        + name + ""' on a null value"", null, name, uberInfo.getTemplateName(),
                        jjtGetChild(i+1).getLine(), jjtGetChild(i+1).getColumn());
                }            
                String msg = ""reference set is not a valid reference at ""
                    + Log.formatFileString(uberInfo);
                log.error(msg);
                return false;
            }
        }
        /*
         *  We support two ways of setting the value in a #set($ref.foo = $value ) :
         *  1) ref.setFoo( value )
         *  2) ref,put(""foo"", value ) to parallel the get() map introspection
         */
        try
        {
            VelPropertySet vs =
                    rsvc.getUberspect().getPropertySet(result, identifier,
                            value, uberInfo);
            if (vs == null)
            {
                if (strictRef)
                {
                    throw new MethodInvocationException(""Object '"" + result.getClass().getName() +
                       ""' does not contain property '"" + identifier + ""'"", null, identifier,
                       uberInfo.getTemplateName(), uberInfo.getLine(), uberInfo.getColumn());
                }
                else
                {
                  return false;
                }
            }
            vs.invoke(result, value);
        }
        catch(InvocationTargetException ite)
        {
            /*
             *  this is possible
             */
            throw  new MethodInvocationException(
                ""ASTReference : Invocation of method '""
                + identifier + ""' in  "" + result.getClass()
                + "" threw exception ""
                + ite.getTargetException().toString(),
               ite.getTargetException(), identifier, getTemplateName(), this.getLine(), this.getColumn());
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch(Exception e)
        {
            /*
             *  maybe a security exception?
             */
            String msg = ""ASTReference setValue() : exception : "" + e
                          + "" template at "" + Log.formatFileString(uberInfo);
            log.error(msg, e);
            throw new VelocityException(msg, e);
         }
        return true;
    }
    private String getRoot()
    {
        Token t = getFirstToken();
        /*
         *  we have a special case where something like
         *  $(\\)*!, where the user want's to see something
         *  like $!blargh in the output, but the ! prevents it from showing.
         *  I think that at this point, this isn't a reference.
         */
        /* so, see if we have ""\\!"" */
        int slashbang = t.image.indexOf(""\\!"");
        if (slashbang != -1)
        {
            /*
             *  lets do all the work here.  I would argue that if this occurrs,
             *  it's not a reference at all, so preceeding \ characters in front
             *  of the $ are just schmoo.  So we just do the escape processing
             *  trick (even | odd) and move on.  This kind of breaks the rule
             *  pattern of $ and # but '!' really tosses a wrench into things.
             */
             /*
              *  count the escapes : even # -> not escaped, odd -> escaped
              */
            int i = 0;
            int len = t.image.length();
            i = t.image.indexOf('$');
            if (i == -1)
            {
                /* yikes! */
                log.error(""ASTReference.getRoot() : internal error : ""
                            + ""no $ found for slashbang."");
                computableReference = false;
                nullString = t.image;
                return nullString;
            }
            while (i < len && t.image.charAt(i) != '\\')
            {
                i++;
            }
            /*  ok, i is the first \ char */
            int start = i;
            int count = 0;
            while (i < len && t.image.charAt(i++) == '\\')
            {
                count++;
            }
            /*
             *  now construct the output string.  We really don't care about
             *  leading  slashes as this is not a reference.  It's quasi-schmoo
             */
            nullString = t.image.substring(0,start); // prefix up to the first
            nullString += t.image.substring(start, start + count-1 ); // get the slashes
            nullString += t.image.substring(start+count); // and the rest, including the
            /*
             *  this isn't a valid reference, so lets short circuit the value
             *  and set calcs
             */
            computableReference = false;
            return nullString;
        }
        /*
         *  we need to see if this reference is escaped.  if so
         *  we will clean off the leading \'s and let the
         *  regular behavior determine if we should output this
         *  as \$foo or $foo later on in render(). Lazyness..
         */
        escaped = false;
        if (t.image.startsWith(""\\""))
        {
            /*
             *  count the escapes : even # -> not escaped, odd -> escaped
             */
            int i = 0;
            int len = t.image.length();
            while (i < len && t.image.charAt(i) == '\\')
            {
                i++;
            }
            if ((i % 2) != 0)
                escaped = true;
            if (i > 0)
                escPrefix = t.image.substring(0, i / 2 );
            t.image = t.image.substring(i);
        }
        /*
         *  Look for preceeding stuff like '#' and '$'
         *  and snip it off, except for the
         *  last $
         */
        int loc1 = t.image.lastIndexOf('$');
        /*
         *  if we have extra stuff, loc > 0
         *  ex. '#$foo' so attach that to
         *  the prefix.
         */
        if (loc1 > 0)
        {
            morePrefix = morePrefix + t.image.substring(0, loc1);
            t.image = t.image.substring(loc1);
        }
        /*
         *  Now it should be clean. Get the literal in case this reference
         *  isn't backed by the context at runtime, and then figure out what
         *  we are working with.
         */
        // FIXME: this is the key to render nulls as literals, we need to look at context(refname+"".literal"") 
        nullString = literal();
        if (t.image.startsWith(""$!""))
        {
            referenceType = QUIET_REFERENCE;
            /*
             *  only if we aren't escaped do we want to null the output
             */
            if (!escaped)
                nullString = """";
            if (t.image.startsWith(""$!{""))
            {
                /*
                 *  ex : $!{provider.Title}
                 */
                return t.next.image;
            }
            else
            {
                /*
                 *  ex : $!provider.Title
                 */
                return t.image.substring(2);
            }
        }
        else if (t.image.equals(""${""))
        {
            /*
             *  ex : ${provider.Title}
             */
            referenceType = FORMAL_REFERENCE;
            return t.next.image;
        }
        else if (t.image.startsWith(""$""))
        {
            /*
             *  just nip off the '$' so we have
             *  the root
             */
            referenceType = NORMAL_REFERENCE;
            return t.image.substring(1);
        }
        else
        {
            /*
             * this is a 'RUNT', which can happen in certain circumstances where
             *  the parser is fooled into believeing that an IDENTIFIER is a real
             *  reference.  Another 'dreaded' MORE hack :).
             */
            referenceType = RUNT;
            return t.image;
        }
    }
    /**
     * @param context
     * @param variable
     * @return The evaluated value of the variable.
     * @throws MethodInvocationException
     */
    public Object getVariableValue(Context context, String variable) throws MethodInvocationException
    {
        Object obj = null;
        try
        {
            obj = context.get(variable);
        }
        catch(RuntimeException e)
        {
            log.error(""Exception calling reference $"" + variable + "" at ""
                      + Log.formatFileString(uberInfo));
            throw e;
        }
        if (strictRef && obj == null)
        {
          if (!context.containsKey(variable))
          {
              log.error(""Variable $"" + variable + "" has not been set at ""
                        + Log.formatFileString(uberInfo));
              throw new MethodInvocationException(""Variable $"" + variable +
                  "" has not been set"", null, identifier,
                  uberInfo.getTemplateName(), uberInfo.getLine(), uberInfo.getColumn());            
          }
        }
        return obj;        
    }
    /**
     *  Routine to allow the literal representation to be
     *  externally overridden.  Used now in the VM system
     *  to override a reference in a VM tree with the
     *  literal of the calling arg to make it work nicely
     *  when calling arg is null.  It seems a bit much, but
     *  does keep things consistant.
     *
     *  Note, you can only set the literal once...
     *
     *  @param literal String to render to when null
     */
    public void setLiteral(String literal)
    {
        /*
         * do only once
         */
        if( this.literal == null)
            this.literal = literal;
    }
    /**
     *  Override of the SimpleNode method literal()
     *  Returns the literal representation of the
     *  node.  Should be something like
     *  $<token>.
     * @return A literal string.
     */
    public String literal()
    {
        if (literal != null)
            return literal;
        // this value could be cached in this.literal but it increases memory usage
        return super.literal();
    }
}
"
org.apache.velocity.runtime.parser.node.ASTSetDirective,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.app.event.EventHandlerUtil;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.util.introspection.Info;
/**
 * Node for the #set directive
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTSetDirective.java 720228 2008-11-24 16:58:33Z nbubna $
 */
public class ASTSetDirective extends SimpleNode
{
    private String leftReference = """";
    private Node right = null;
    private ASTReference left = null;
    boolean logOnNull = false;
    private boolean allowNull = false;
    private boolean isInitialized;
    /**
     *  This is really immutable after the init, so keep one for this node
     */
    protected Info uberInfo;
    /**
     * Indicates if we are running in strict reference mode.
     */
    protected boolean strictRef = false;
    /**
     * @param id
     */
    public ASTSetDirective(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTSetDirective(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     *  simple init.  We can get the RHS and LHS as the the tree structure is static
     * @param context
     * @param data
     * @return Init result.
     * @throws TemplateInitException
     */
    public synchronized Object init(InternalContextAdapter context, Object data)
    throws TemplateInitException
    {
        /** This method is synchronized to prevent double initialization or initialization while rendering **/
        if (!isInitialized)
        {
            /*
             *  init the tree correctly
             */
            super.init( context, data );
            uberInfo = new Info(getTemplateName(),
                    getLine(), getColumn());
            right = getRightHandSide();
            left = getLeftHandSide();
            logOnNull = rsvc.getBoolean(RuntimeConstants.RUNTIME_LOG_REFERENCE_LOG_INVALID, true);
            allowNull = rsvc.getBoolean(RuntimeConstants.SET_NULL_ALLOWED, false);
            strictRef = rsvc.getBoolean(RuntimeConstants.RUNTIME_REFERENCES_STRICT, false);
            if (strictRef) allowNull = true;  // strictRef implies allowNull
            /*
             *  grab this now.  No need to redo each time
             */
            leftReference = left.getFirstToken().image.substring(1);
            isInitialized = true;
        }
        return data;
    }
    /**
     *   puts the value of the RHS into the context under the key of the LHS
     * @param context
     * @param writer
     * @return True if rendering was sucessful.
     * @throws IOException
     * @throws MethodInvocationException
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException, MethodInvocationException
    {
        /*
         *  get the RHS node, and its value
         */
        Object value = right.value(context);
        /*
         * it's an error if we don't have a value of some sort AND
         * it is not allowed by configuration
         */
        if( !allowNull )
        {
            if ( value == null )
            {                
                /*
                 *  first, are we supposed to say anything anyway?
                 */
                if(logOnNull)
                {
                    boolean doit = EventHandlerUtil.shouldLogOnNullSet( rsvc, context, left.literal(), right.literal() );
                    if (doit && rsvc.getLog().isDebugEnabled())
                    {
                        rsvc.getLog().debug(""RHS of #set statement is null. Context will not be modified. ""
                                      + Log.formatFileString(this));
                    }
                }
                String rightReference = null;
                if (right instanceof ASTExpression)
                {
                    rightReference = ((ASTExpression) right).getLastToken().image;
                }
                EventHandlerUtil.invalidSetMethod(rsvc, context, leftReference, rightReference, uberInfo);
                return false;
            }
        }
        if ( value == null && !strictRef)
        {
            String rightReference = null;
            if (right instanceof ASTExpression)
            {
                rightReference = ((ASTExpression) right).getLastToken().image;
            }
            EventHandlerUtil.invalidSetMethod(rsvc, context, leftReference, rightReference, uberInfo);
            /*
             * if RHS is null, remove simple LHS from context
             * or call setValue() with a null value for complex LHS
             */
            if (left.jjtGetNumChildren() == 0)
            {
                context.remove( leftReference );
            }
            else
            {
                left.setValue(context, null);
            }
            return false;
        }
        else
        {
            /*
             *  if the LHS is simple, just punch the value into the context
             *  otherwise, use the setValue() method do to it.
             *  Maybe we should always use setValue()
             */
            if (left.jjtGetNumChildren() == 0)
            {
                context.put( leftReference, value);
            }
            else
            {
                left.setValue(context, value);
            }
        }
        return true;
    }
    /**
     *  returns the ASTReference that is the LHS of the set statememt
     *  
     *  @return left hand side of #set statement
     */
    private ASTReference getLeftHandSide()
    {
        return (ASTReference) jjtGetChild(0);
    }
    /**
     *  returns the RHS Node of the set statement
     *  
     *  @return right hand side of #set statement
     */
    private Node getRightHandSide()
    {
        return jjtGetChild(1);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTStop,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.parser.Parser;
/**
 * This class is responsible for handling the #stop directive
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: ASTStop.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class ASTStop extends SimpleNode
{
    /**
     * @param id
     */
    public ASTStop(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTStop(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * Do not output anything, just shut off the rendering.
     * @param context
     * @param writer
     * @return Always true.
     * @throws IOException
     * @throws MethodInvocationException
     * @throws ParseErrorException
     * @throws ResourceNotFoundException
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException, MethodInvocationException, ParseErrorException, ResourceNotFoundException
    {
        context.setAllowRendering(false);
        return true;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTStringLiteral,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import org.apache.commons.lang.text.StrBuilder;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.ParseException;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.Token;
import org.apache.velocity.runtime.visitor.BaseVisitor;
/**
 * ASTStringLiteral support. Will interpolate!
 * 
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: ASTStringLiteral.java 705297 2008-10-16 17:59:24Z nbubna $
 */
public class ASTStringLiteral extends SimpleNode
{
    /* cache the value of the interpolation switch */
    private boolean interpolate = true;
    private SimpleNode nodeTree = null;
    private String image = """";
    private String interpolateimage = """";
    /** true if the string contains a line comment (##) */
    private boolean containsLineComment;
    /**
     * @param id
     */
    public ASTStringLiteral(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTStringLiteral(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * init : we don't have to do much. Init the tree (there shouldn't be one)
     * and then see if interpolation is turned on.
     * 
     * @param context
     * @param data
     * @return Init result.
     * @throws TemplateInitException
     */
    public Object init(InternalContextAdapter context, Object data)
            throws TemplateInitException
    {
        /*
         * simple habit... we prollie don't have an AST beneath us
         */
        super.init(context, data);
        /*
         * the stringlit is set at template parse time, so we can do this here
         * for now. if things change and we can somehow create stringlits at
         * runtime, this must move to the runtime execution path
         * 
         * so, only if interpolation is turned on AND it starts with a "" AND it
         * has a directive or reference, then we can interpolate. Otherwise,
         * don't bother.
         */
        interpolate = rsvc.getBoolean(
                RuntimeConstants.INTERPOLATE_STRINGLITERALS, true)
                && getFirstToken().image.startsWith(""\"""")
                && ((getFirstToken().image.indexOf('$') != -1) || (getFirstToken().image
                        .indexOf('#') != -1));
        /*
         * get the contents of the string, minus the '/"" at each end
         */
        image = getFirstToken().image.substring(1, getFirstToken().image
                .length() - 1);
        if (getFirstToken().image.startsWith(""\""""))
        {
            image = unescape(image);
        }
        /**
         * note. A kludge on a kludge. The first part, Geir calls this the
         * dreaded <MORE> kludge. Basically, the use of the <MORE> token eats
         * the last character of an interpolated string. EXCEPT when a line
         * comment (##) is in the string this isn't an issue.
         * 
         * So, to solve this we look for a line comment. If it isn't found we
         * add a space here and remove it later.
         */
        /**
         * Note - this should really use a regexp to look for [^\]## but
         * apparently escaping of line comments isn't working right now anyway.
         */
        containsLineComment = (image.indexOf(""##"") != -1);
        /*
         * if appropriate, tack a space on the end (dreaded <MORE> kludge)
         */
        if (!containsLineComment)
        {
            interpolateimage = image + "" "";
        }
        else
        {
            interpolateimage = image;
        }
        if (interpolate)
        {
            /*
             * now parse and init the nodeTree
             */
            StringReader br = new StringReader(interpolateimage);
            /*
             * it's possible to not have an initialization context - or we don't
             * want to trust the caller - so have a fallback value if so
             * 
             * Also, do *not* dump the VM namespace for this template
             */
            String templateName =
                (context != null) ? context.getCurrentTemplateName() : ""StringLiteral"";
            try
            {
                nodeTree = rsvc.parse(br, templateName, false);
            }
            catch (ParseException e)
            {
                String msg = ""Failed to parse String literal at ""+
                    Log.formatFileString(templateName, getLine(), getColumn());
                throw new TemplateInitException(msg, e, templateName, getColumn(), getLine());
            }
            adjTokenLineNums(nodeTree);
            /*
             * init with context. It won't modify anything
             */
            nodeTree.init(context, rsvc);
        }
        return data;
    }
    /**
     * Adjust all the line and column numbers that comprise a node so that they
     * are corrected for the string literals position within the template file.
     * This is neccessary if an exception is thrown while processing the node so
     * that the line and column position reported reflects the error position
     * within the template and not just relative to the error position within
     * the string literal.
     */
    public void adjTokenLineNums(Node node)
    {
        Token tok = node.getFirstToken();
        // Test against null is probably not neccessary, but just being safe
        while(tok != null && tok != node.getLastToken())
        {
            // If tok is on the first line, then the actual column is 
            // offset by the template column.
            if (tok.beginLine == 1)
                tok.beginColumn += getColumn();
            if (tok.endLine == 1)
                tok.endColumn += getColumn();
            tok.beginLine += getLine()- 1;
            tok.endLine += getLine() - 1;
            tok = tok.next;
        }
    }
    /**
     * @since 1.6
     */
    public static String unescape(final String string)
    {
        int u = string.indexOf(""\\u"");
        if (u < 0) return string;
        StrBuilder result = new StrBuilder();
        int lastCopied = 0;
        for (;;)
        {
            result.append(string.substring(lastCopied, u));
            /* we don't worry about an exception here,
             * because the lexer checked that string is correct */
            char c = (char) Integer.parseInt(string.substring(u + 2, u + 6), 16);
            result.append(c);
            lastCopied = u + 6;
            u = string.indexOf(""\\u"", lastCopied);
            if (u < 0)
            {
                result.append(string.substring(lastCopied));
                return result.toString();
            }
        }
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor,
     *      java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * Check to see if this is an interpolated string.
     * @return true if this is constant (not an interpolated string)
     * @since 1.6
     */
    public boolean isConstant()
    {
        return !interpolate;
    }
    /**
     * renders the value of the string literal If the properties allow, and the
     * string literal contains a $ or a # the literal is rendered against the
     * context Otherwise, the stringlit is returned.
     * 
     * @param context
     * @return result of the rendering.
     */
    public Object value(InternalContextAdapter context)
    {
        if (interpolate)
        {
            try
            {
                /*
                 * now render against the real context
                 */
                StringWriter writer = new StringWriter();
                nodeTree.render(context, writer);
                /*
                 * and return the result as a String
                 */
                String ret = writer.toString();
                /*
                 * if appropriate, remove the space from the end (dreaded <MORE>
                 * kludge part deux)
                 */
                if (!containsLineComment && ret.length() > 0)
                {
                    return ret.substring(0, ret.length() - 1);
                }
                else
                {
                    return ret;
                }
            }
            /**
             * pass through application level runtime exceptions
             */
            catch (RuntimeException e)
            {
                throw e;
            }
            catch (IOException e)
            {
                String msg = ""Error in interpolating string literal"";
                log.error(msg, e);
                throw new VelocityException(msg, e);
            }
        }
        /*
         * ok, either not allowed to interpolate, there wasn't a ref or
         * directive, or we failed, so just output the literal
         */
        return image;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTSubtractNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
/**
 * Handles subtraction of nodes (in #set() )<br><br>
 *
 * Please look at the Parser.jjt file which is
 * what controls the generation of this class.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ASTSubtractNode.java 691048 2008-09-01 20:26:11Z nbubna $
 */
public class ASTSubtractNode extends ASTMathNode
{
    /**
     * @param id
     */
    public ASTSubtractNode(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTSubtractNode(Parser p, int id)
    {
        super(p, id);
    }
    public Number perform(Number left, Number right, InternalContextAdapter context)
    {
        return MathUtils.subtract(left, right);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTText,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.Token;
/**
 *
 */
public class ASTText extends SimpleNode
{
    private char[] ctext;
    /**
     * @param id
     */
    public ASTText(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTText(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#init(org.apache.velocity.context.InternalContextAdapter, java.lang.Object)
     */
    public Object init( InternalContextAdapter context, Object data)
    throws TemplateInitException
    {
        Token t = getFirstToken();
        String text = NodeUtils.tokenLiteral( t );
        ctext = text.toCharArray();
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#render(org.apache.velocity.context.InternalContextAdapter, java.io.Writer)
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException
    {
        if (context.getAllowRendering())
        {
            writer.write(ctext);
        }
        return true;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTTrue,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTTrue extends SimpleNode
{
    private static Boolean value = Boolean.TRUE;
    /**
     * @param id
     */
    public ASTTrue(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTTrue(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#evaluate(org.apache.velocity.context.InternalContextAdapter)
     */
    public boolean evaluate(InternalContextAdapter context)
    {
        return true;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value(InternalContextAdapter context)
    {
        return value;
    }
}
"
org.apache.velocity.runtime.parser.node.ASTVariable,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTVariable extends SimpleNode
{
    /**
     * @param id
     */
    public ASTVariable(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTVariable(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.ASTWord,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.parser.Parser;
/**
 *
 */
public class ASTWord extends SimpleNode
{
    /**
     * @param id
     */
    public ASTWord(int id)
    {
        super(id);
    }
    /**
     * @param p
     * @param id
     */
    public ASTWord(Parser p, int id)
    {
        super(p, id);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SimpleNode#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
}
"
org.apache.velocity.runtime.parser.node.BooleanPropertyExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeLogger;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.log.RuntimeLoggerLog;
import org.apache.velocity.util.introspection.Introspector;
/**
 *  Handles discovery and valuation of a
 *  boolean object property, of the
 *  form public boolean is<property> when executed.
 *
 *  We do this separately as to preserve the current
 *  quasi-broken semantics of get<as is property>
 *  get< flip 1st char> get(""property"") and now followed
 *  by is<Property>
 *
 *  @author <a href=""geirm@apache.org"">Geir Magnusson Jr.</a>
 *  @version $Id: BooleanPropertyExecutor.java 687502 2008-08-20 23:19:52Z nbubna $
 */
public class BooleanPropertyExecutor extends PropertyExecutor
{
    /**
     * @param log
     * @param introspector
     * @param clazz
     * @param property
     * @since 1.5
     */
    public BooleanPropertyExecutor(final Log log, final Introspector introspector,
            final Class clazz, final String property)
    {
        super(log, introspector, clazz, property);
    }
    /**
     * @param rlog
     * @param introspector
     * @param clazz
     * @param property
     * @deprecated RuntimeLogger is deprecated. Use the other constructor.
     */
    public BooleanPropertyExecutor(final RuntimeLogger rlog, final Introspector introspector,
            final Class clazz, final String property)
    {
        super(new RuntimeLoggerLog(rlog), introspector, clazz, property);
    }
    protected void discover(final Class clazz, final String property)
    {
        try
        {
            Object [] params = {};
            StringBuffer sb = new StringBuffer(""is"");
            sb.append(property);
            setMethod(getIntrospector().getMethod(clazz, sb.toString(), params));
            if (!isAlive())
            {
                /*
                 *  now the convenience, flip the 1st character
                 */
                char c = sb.charAt(2);
                if (Character.isLowerCase(c))
                {
                    sb.setCharAt(2, Character.toUpperCase(c));
                }
                else
                {
                    sb.setCharAt(2, Character.toLowerCase(c));
                }
                setMethod(getIntrospector().getMethod(clazz, sb.toString(), params));
            }
            if (isAlive())
            {
                if( getMethod().getReturnType() != Boolean.TYPE &&
                    getMethod().getReturnType() != Boolean.class )
                {
                    setMethod(null);
                }
            }
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch(Exception e)
        {
            String msg = ""Exception while looking for boolean property getter for '"" + property;
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
    }
}
"
org.apache.velocity.runtime.parser.node.GetExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.InvocationTargetException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeLogger;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.log.RuntimeLoggerLog;
import org.apache.velocity.util.introspection.Introspector;
/**
 * Executor that simply tries to execute a get(key)
 * operation. This will try to find a get(key) method
 * for any type of object, not just objects that
 * implement the Map interface as was previously
 * the case.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: GetExecutor.java 687177 2008-08-19 22:00:32Z nbubna $
 */
public class GetExecutor extends AbstractExecutor
{
    private final Introspector introspector;
    // This is still threadsafe because this object is only read except in the C'tor.
    private Object [] params = {};
    /**
     * @param log
     * @param introspector
     * @param clazz
     * @param property
     * @since 1.5
     */
    public GetExecutor(final Log log, final Introspector introspector,
            final Class clazz, final String property)
    {
        this.log = log;
        this.introspector = introspector;
        // If you passed in null as property, we don't use the value
        // for parameter lookup. Instead we just look for get() without
        // any parameters.
        //
        // In any other case, the following condition will set up an array
        // for looking up get(String) on the class.
        if (property != null)
        {
            this.params = new Object[] { property };
        }
        discover(clazz);
    }
    /**
     * @param rlog
     * @param introspector
     * @param clazz
     * @param property
     * @deprecated RuntimeLogger is deprecated. Use the other constructor.
     */
    public GetExecutor(final RuntimeLogger rlog, final Introspector introspector,
            final Class clazz, final String property)
    {
        this(new RuntimeLoggerLog(rlog), introspector, clazz, property);
    }
    /**
     * @since 1.5
     */
    protected void discover(final Class clazz)
    {
        try
        {
            setMethod(introspector.getMethod(clazz, ""get"", params));
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch(Exception e)
        {
            String msg = ""Exception while looking for get('"" + params[0] + ""') method"";
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.AbstractExecutor#execute(java.lang.Object)
     */
    public Object execute(final Object o)
        throws IllegalAccessException,  InvocationTargetException
    {
        return isAlive() ? getMethod().invoke(o, params) : null;
    }
}
"
org.apache.velocity.runtime.parser.node.MapGetExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Map;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.log.Log;
/**
 * GetExecutor that is smart about Maps. If it detects one, it does not
 * use Reflection but a cast to access the getter. 
 *
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: MapGetExecutor.java 687177 2008-08-19 22:00:32Z nbubna $
 * @since 1.5
 */
public class MapGetExecutor
        extends AbstractExecutor 
{
    private final String property;
    public MapGetExecutor(final Log log, final Class clazz, final String property)
    {
        this.log = log;
        this.property = property;
        discover(clazz);
    }
    protected void discover (final Class clazz)
    {
        Class [] interfaces = clazz.getInterfaces();
        for (int i = 0 ; i < interfaces.length; i++)
        {
            if (interfaces[i].equals(Map.class))
            {
                try
                {
                    if (property != null)
                    {
                        setMethod(Map.class.getMethod(""get"", new Class [] { Object.class }));
                    }
                }
                /**
                 * pass through application level runtime exceptions
                 */
                catch( RuntimeException e )
                {
                    throw e;
                }
                catch(Exception e)
                {
                    String msg = ""Exception while looking for get('"" + property + ""') method"";
                    log.error(msg, e);
                    throw new VelocityException(msg, e);
                }
                break;
            }
        }
    }
    public Object execute(final Object o)
    {
        return ((Map) o).get(property);
    } 
}
"
org.apache.velocity.runtime.parser.node.MapSetExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Map;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.log.Log;
/**
 * SetExecutor that is smart about Maps. If it detects one, it does not
 * use Reflection but a cast to access the setter. 
 *
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: MapSetExecutor.java 687177 2008-08-19 22:00:32Z nbubna $
 * @since 1.5
 */
public class MapSetExecutor
        extends SetExecutor 
{
    private final String property;
    public MapSetExecutor(final Log log, final Class clazz, final String property)
    {
        this.log = log;
        this.property = property;
        discover(clazz);
    }
    protected void discover (final Class clazz)
    {
        Class [] interfaces = clazz.getInterfaces();
        for (int i = 0 ; i < interfaces.length; i++)
        {
            if (interfaces[i].equals(Map.class))
            {
                try
                {
                    if (property != null)
                    {
                        setMethod(Map.class.getMethod(""put"", new Class [] { Object.class, Object.class }));
                    }
                }
                /**
                 * pass through application level runtime exceptions
                 */
                catch( RuntimeException e )
                {
                    throw e;
                }
                catch(Exception e)
                {
                    String msg = ""Exception while looking for put('"" + property + ""') method"";
                    log.error(msg, e);
                    throw new VelocityException(msg, e);
                }
                break;
            }
        }
    }
    public Object execute(final Object o, final Object arg)
    {
        return ((Map) o).put(property, arg);
    } 
}
"
org.apache.velocity.runtime.parser.node.MathUtils,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
/**
 * Utility-class for all arithmetic-operations.<br><br>
 *
 * All operations (+ - / *) return a Number which type is the type of the bigger argument.<br>
 * Example:<br>
 * <code>add ( new Integer(10), new Integer(1))</code> will return an <code>Integer</code>-Object with the value 11<br>
 * <code>add ( new Long(10), new Integer(1))</code> will return an <code>Long</code>-Object with the value 11<br>
 * <code>add ( new Integer(10), new Float(1))</code> will return an <code>Float</code>-Object with the value 11<br><br>
 *
 * Overflow checking:<br>
 * For integral values (byte, short, int) there is an implicit overflow correction (the next ""bigger""
 * type will be returned). For example, if you call <code>add (new Integer (Integer.MAX_VALUE), 1)</code> a
 * <code>Long</code>-object will be returned with the correct value of <code>Integer.MAX_VALUE+1</code>.<br>
 * In addition to that the methods <code>multiply</code>,<code>add</code> and <code>substract</code> implement overflow
 * checks for <code>long</code>-values. That means that if an overflow occurs while working with long values a BigInteger
 * will be returned.<br>
 * For all other operations and types (such as Float and Double) there is no overflow checking.
 *
 * @author <a href=""mailto:pero@antaramusic.de"">Peter Romianowski</a>
 * @since 1.5
 */
public abstract class MathUtils
{
    /**
     * A BigDecimal representing the number 0
     */
    protected static final BigDecimal DECIMAL_ZERO    = new BigDecimal ( BigInteger.ZERO );
    /**
     * The constants are used to determine in which context we have to calculate.
     */
    protected static final int BASE_LONG          = 0;
    protected static final int BASE_FLOAT         = 1;
    protected static final int BASE_DOUBLE        = 2;
    protected static final int BASE_BIGINTEGER    = 3;
    protected static final int BASE_BIGDECIMAL    = 4;
    /**
     * The <code>Class</code>-object is key, the maximum-value is the value
     */
    protected static final Map ints = new HashMap();
    static
    {
        ints.put (Byte.class, BigDecimal.valueOf (Byte.MAX_VALUE));
        ints.put (Short.class, BigDecimal.valueOf (Short.MAX_VALUE));
        ints.put (Integer.class, BigDecimal.valueOf (Integer.MAX_VALUE));
        ints.put (Long.class, BigDecimal.valueOf (Long.MAX_VALUE));
        ints.put (BigInteger.class, BigDecimal.valueOf (-1));
    }
    /**
     * The ""size"" of the number-types - ascending.
     */
    protected static final List typesBySize = new ArrayList();
    static
    {
        typesBySize.add (Byte.class);
        typesBySize.add (Short.class);
        typesBySize.add (Integer.class);
        typesBySize.add (Long.class);
        typesBySize.add (Float.class);
        typesBySize.add (Double.class);
    }
    /**
     * Convert the given Number to a BigDecimal
     * @param n
     * @return The number as BigDecimal
     */
    public static BigDecimal toBigDecimal (Number n)
    {
        if (n instanceof BigDecimal)
        {
            return (BigDecimal)n;
        }
        if (n instanceof BigInteger)
        {
            return new BigDecimal ( (BigInteger)n );
        }
        return new BigDecimal (n.doubleValue());
    }
    /**
     * Convert the given Number to a BigInteger
     * @param n
     * @return The number as BigInteger
     */
    public static BigInteger toBigInteger (Number n)
    {
        if (n instanceof BigInteger)
        {
            return (BigInteger)n;
        }
        return BigInteger.valueOf (n.longValue());
    }
    /**
     * Compare the given Number to 0.
     * @param n
     * @return True if number is 0.
     */
    public static boolean isZero (Number n)
    {
        if (isInteger( n ) )
        {
            if (n instanceof BigInteger)
            {
                return ((BigInteger)n).compareTo (BigInteger.ZERO) == 0;
            }
            return n.doubleValue() == 0;
        }
        if (n instanceof Float)
        {
            return n.floatValue() == 0f;
        }
        if (n instanceof Double)
        {
            return n.doubleValue() == 0d;
        }
        return toBigDecimal( n ).compareTo( DECIMAL_ZERO) == 0;
    }
    /**
     * Test, whether the given object is an integer value
     * (Byte, Short, Integer, Long, BigInteger)
     * @param n
     * @return True if n is an integer.
     */
    public static boolean isInteger (Number n)
    {
        return ints.containsKey (n.getClass());
    }
    /**
     * Wrap the given primitive into the given class if the value is in the
     * range of the destination type. If not the next bigger type will be chosen.
     * @param value
     * @param type
     * @return Number object representing the primitive.
     */
    public static Number wrapPrimitive (long value, Class type)
    {
        if (type == Byte.class)
        {
            if (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE)
            {
                type = Short.class;
            }
            else
            {
                // TODO: JDK 1.4+ -> valueOf()
                return new Byte ((byte)value);
            }
        }
        if (type == Short.class)
        {
            if (value > Short.MAX_VALUE || value < Short.MIN_VALUE)
            {
                type = Integer.class;
            }
            else
            {
                // TODO: JDK 1.4+ -> valueOf()
                return new Short((short)value);
            }
        }
        if (type == Integer.class)
        {
            if (value > Integer.MAX_VALUE || value < Integer.MIN_VALUE)
            {
                type = Long.class;
            }
            else
            {
                // TODO: JDK 1.4+ -> valueOf()
                return new Integer ((int)value);
            }
        }
        if (type == Long.class)
        {
            // TODO: JDK 1.4+ -> valueOf()
            return new Long (value);
        }
        return BigInteger.valueOf( value);
    }
    /**
     * Wrap the result in the object of the bigger type.
     * 
     * @param value result of operation (as a long) - used to check size
     * @param op1 first operand of binary operation
     * @param op2 second operand of binary operation
     * @return Number object of appropriate size to fit the value and operators
     */
    private static Number wrapPrimitive (long value, Number op1, Number op2)
    {
        if ( typesBySize.indexOf( op1.getClass()) > typesBySize.indexOf( op2.getClass()))
        {
            return wrapPrimitive( value, op1.getClass());
        }
        return wrapPrimitive( value, op2.getClass());
    }
    /**
     * Find the common Number-type to be used in calculations.
     * 
     * @param op1 first operand of binary operation
     * @param op2 second operand of binary operation
     * @return constant indicating type of Number to use in calculations
     */
    private static int findCalculationBase (Number op1, Number op2)
    {
        boolean op1Int = isInteger(op1);
        boolean op2Int = isInteger(op2);
        if ( (op1 instanceof BigDecimal || op2 instanceof BigDecimal) ||
             ( (!op1Int || !op2Int) && (op1 instanceof BigInteger || op2 instanceof BigInteger)) )
        {
            return BASE_BIGDECIMAL;
        }
        if (op1Int && op2Int) {
            if (op1 instanceof BigInteger || op2 instanceof BigInteger)
            {
                return BASE_BIGINTEGER;
            }
            return BASE_LONG;
        }
        if ((op1 instanceof Double) || (op2 instanceof Double))
        {
            return BASE_DOUBLE;
        }
        return BASE_FLOAT;
    }
    /**
     * Add two numbers and return the correct value / type.
     * Overflow detection is done for integer values (byte, short, int, long) only!
     * @param op1
     * @param op2
     * @return Addition result.
     */
    public static Number add (Number op1, Number op2)
    {
        int calcBase = findCalculationBase( op1, op2);
        switch (calcBase)
        {
            case BASE_BIGINTEGER:
                return toBigInteger( op1 ).add( toBigInteger( op2 ));
            case BASE_LONG:
                long l1 = op1.longValue();
                long l2 = op2.longValue();
                long result = l1+l2;
                // Overflow check
                if ((result ^ l1) < 0 && (result ^ l2) < 0)
                {
                    return toBigInteger( op1).add( toBigInteger( op2));
                }
                return wrapPrimitive( result, op1, op2);
            case BASE_FLOAT:
                return new Float (op1.floatValue()+op2.floatValue());
            case BASE_DOUBLE:
                return new Double (op1.doubleValue()+op2.doubleValue());
            // Default is BigDecimal operation
            default:
                return toBigDecimal( op1 ).add( toBigDecimal( op2 ));
        }
    }
    /**
     * Subtract two numbers and return the correct value / type.
     * Overflow detection is done for integer values (byte, short, int, long) only!
     * @param op1
     * @param op2
     * @return Subtraction result.
     */
    public static Number subtract (Number op1, Number op2) {
        int calcBase = findCalculationBase( op1, op2);
        switch (calcBase) {
            case BASE_BIGINTEGER:
                return toBigInteger( op1 ).subtract( toBigInteger( op2 ));
            case BASE_LONG:
                long l1 = op1.longValue();
                long l2 = op2.longValue();
                long result = l1-l2;
                // Overflow check
                if ((result ^ l1) < 0 && (result ^ ~l2) < 0) {
                    return toBigInteger( op1).subtract( toBigInteger( op2));
                }
                return wrapPrimitive( result, op1, op2);
            case BASE_FLOAT:
                return new Float (op1.floatValue()-op2.floatValue());
            case BASE_DOUBLE:
                return new Double (op1.doubleValue()-op2.doubleValue());
            // Default is BigDecimal operation
            default:
                return toBigDecimal( op1 ).subtract( toBigDecimal( op2 ));
        }
    }
    /**
     * Multiply two numbers and return the correct value / type.
     * Overflow detection is done for integer values (byte, short, int, long) only!
     * @param op1
     * @param op2
     * @return Multiplication result.
     */
    public static Number multiply (Number op1, Number op2) {
        int calcBase = findCalculationBase( op1, op2);
        switch (calcBase) {
            case BASE_BIGINTEGER:
                return toBigInteger( op1 ).multiply( toBigInteger( op2 ));
            case BASE_LONG:
                long l1 = op1.longValue();
                long l2 = op2.longValue();
                long result = l1*l2;
                // Overflow detection
                if ((l2 != 0) && (result / l2 != l1)) {
                    return toBigInteger( op1).multiply( toBigInteger( op2));
                }
                return wrapPrimitive( result, op1, op2);
            case BASE_FLOAT:
                return new Float (op1.floatValue()*op2.floatValue());
            case BASE_DOUBLE:
                return new Double (op1.doubleValue()*op2.doubleValue());
            // Default is BigDecimal operation
            default:
                return toBigDecimal( op1 ).multiply( toBigDecimal( op2 ));
        }
    }
    /**
     * Divide two numbers. The result will be returned as Integer-type if and only if
     * both sides of the division operator are Integer-types. Otherwise a Float, Double,
     * or BigDecimal will be returned.
     * @param op1
     * @param op2
     * @return Division result.
     */
    public static Number divide (Number op1, Number op2) {
        int calcBase = findCalculationBase( op1, op2);
        switch (calcBase) {
            case BASE_BIGINTEGER:
                BigInteger b1 = toBigInteger( op1 );
                BigInteger b2 = toBigInteger( op2 );
                return b1.divide( b2);
            case BASE_LONG:
                long l1 = op1.longValue();
                long l2 = op2.longValue();
                return wrapPrimitive( l1 / l2, op1, op2);
            case BASE_FLOAT:
                return new Float (op1.floatValue()/op2.floatValue());
            case BASE_DOUBLE:
                return new Double (op1.doubleValue()/op2.doubleValue());
            // Default is BigDecimal operation
            default:
                return toBigDecimal( op1 ).divide( toBigDecimal( op2 ), BigDecimal.ROUND_HALF_DOWN);
        }
    }
    /**
     * Modulo two numbers.
     * @param op1
     * @param op2
     * @return Modulo result.
     *
     * @throws ArithmeticException If at least one parameter is a BigDecimal
     */
    public static Number modulo (Number op1, Number op2) throws ArithmeticException {
        int calcBase = findCalculationBase( op1, op2);
        switch (calcBase) {
            case BASE_BIGINTEGER:
                return toBigInteger( op1 ).mod( toBigInteger( op2 ));
            case BASE_LONG:
                return wrapPrimitive( op1.longValue() % op2.longValue(), op1, op2);
            case BASE_FLOAT:
                return new Float (op1.floatValue() % op2.floatValue());
            case BASE_DOUBLE:
                return new Double (op1.doubleValue() % op2.doubleValue());
            // Default is BigDecimal operation
            default:
                throw new ArithmeticException( ""Cannot calculate the modulo of BigDecimals."");
        }
    }
    /**
     * Compare two numbers.
     * @param op1
     * @param op2
     * @return 1 if n1 > n2, -1 if n1 < n2 and 0 if equal.
     */
    public static int compare (Number op1, Number op2) {
        int calcBase = findCalculationBase( op1, op2);
        switch (calcBase) {
            case BASE_BIGINTEGER:
                return toBigInteger( op1 ).compareTo( toBigInteger( op2 ));
            case BASE_LONG:
                long l1 = op1.longValue();
                long l2 = op2.longValue();
                if (l1 < l2) {
                    return -1;
                }
                if (l1 > l2) {
                    return 1;
                }
                return 0;
            case BASE_FLOAT:
                float f1 = op1.floatValue();
                float f2 = op2.floatValue();
                if (f1 < f2) {
                    return -1;
                }
                if (f1 > f2) {
                    return 1;
                }
                return 0;
            case BASE_DOUBLE:
                double d1 = op1.doubleValue();
                double d2 = op2.doubleValue();
                if (d1 < d2) {
                    return -1;
                }
                if (d1 > d2) {
                    return 1;
                }
                return 0;
            // Default is BigDecimal operation
            default:
                return toBigDecimal( op1 ).compareTo( toBigDecimal ( op2 ));
        }
    }
}
"
org.apache.velocity.runtime.parser.node.Node,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.parser.Token;
/**
 *  This file describes the interface between the Velocity code
 *  and the JavaCC generated code.
 *
 * @author <a href=""mailto:hps@intermeta.de"">Henning P. Schmiedehausen</a>
 * @version $Id: Node.java 720228 2008-11-24 16:58:33Z nbubna $
 */
public interface Node
{
    /** This method is called after the node has been made the current
     * node.  It indicates that child nodes can now be added to it. */
    public void jjtOpen();
    /** This method is called after all the child nodes have been
      added.
     */
    public void jjtClose();
    /**
     * This pair of methods are used to inform the node of its
     * parent.
     * @param n
     *
     */
    public void jjtSetParent(Node n);
    /**
     * @return The node parent.
     */
    public Node jjtGetParent();
    /**
     * This method tells the node to add its argument to the node's
     * list of children.
     * @param n
     * @param i
     */
    public void jjtAddChild(Node n, int i);
    /**
     * This method returns a child node.  The children are numbered
     * from zero, left to right.
     * @param i
     * @return A child node.
     */
    public Node jjtGetChild(int i);
    /**
     * Return the number of children the node has.
     * @return The number of children of this node.
     */
    public int jjtGetNumChildren();
    /**
     * @param visitor
     * @param data
     * @return The Node execution result object.
     */
    public Object jjtAccept(ParserVisitor visitor, Object data);
    /*
     * ========================================================================
     *
     * The following methods are not generated automatically be the Parser but
     * added manually to be used by Velocity.
     *
     * ========================================================================
     */
    /**
     * @see #jjtAccept(ParserVisitor, Object)
     * @param visitor
     * @param data
     * @return The node execution result.
     */
    public Object childrenAccept(ParserVisitor visitor, Object data);
    /**
     * @return The first token.
     */
    public Token getFirstToken();
    /**
     * @return The last token.
     */
    public Token getLastToken();
    /**
     * @return The NodeType.
     */
    public int getType();
    /**
     * @param context
     * @param data
     * @return The init result.
     * @throws TemplateInitException
     */
    public Object init( InternalContextAdapter context, Object data) throws TemplateInitException;
    /**
     * @param context
     * @return The evaluation result.
     * @throws MethodInvocationException
     */
    public boolean evaluate( InternalContextAdapter context)
        throws MethodInvocationException;
    /**
     * @param context
     * @return The node value.
     * @throws MethodInvocationException
     */
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException;
    /**
     * @param context
     * @param writer
     * @return True if the node rendered successfully.
     * @throws IOException
     * @throws MethodInvocationException
     * @throws ParseErrorException
     * @throws ResourceNotFoundException
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException,MethodInvocationException, ParseErrorException, ResourceNotFoundException;
    /**
     * @param o
     * @param context
     * @return The execution result.
     * @throws MethodInvocationException
     */
    public Object execute(Object o, InternalContextAdapter context)
      throws MethodInvocationException;
    /**
     * @param info
     */
    public void setInfo(int info);
    /**
     * @return The current node info.
     */
    public int getInfo();
    /**
     * @return A literal.
     */
    public String literal();
    /**
     * Mark the node as invalid.
     */
    public void setInvalid();
    /**
     * @return True if the node is invalid.
     */
    public boolean isInvalid();
    /**
     * @return The current line position.
     */
    public int getLine();
    /**
     * @return The current column position.
     */
    public int getColumn();
    /**
     * @return the file name of the template
     */
    public String getTemplateName();
}
"
org.apache.velocity.runtime.parser.node.NodeUtils,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.commons.lang.text.StrBuilder;
import org.apache.velocity.context.Context;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.runtime.parser.ParserConstants;
import org.apache.velocity.runtime.parser.Token;
/**
 * Utilities for dealing with the AST node structure.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: NodeUtils.java 687386 2008-08-20 16:57:07Z nbubna $
 */
public class NodeUtils
{
    /**
     * @deprecated use getSpecialText(Token t)
     */
    public static String specialText(Token t)
    {
        if (t.specialToken == null || t.specialToken.image.startsWith(""##"") )
        {
            return """";
        }
        return getSpecialText(t).toString();
    }
    /**
     * Collect all the <SPECIAL_TOKEN>s that
     * are carried along with a token. Special
     * tokens do not participate in parsing but
     * can still trigger certain lexical actions.
     * In some cases you may want to retrieve these
     * special tokens, this is simply a way to
     * extract them.
     * @param t the Token
     * @return StrBuilder with the special tokens.
     */
    public static StrBuilder getSpecialText(Token t)
    {
        StrBuilder sb = new StrBuilder();
        Token tmp_t = t.specialToken;
        while (tmp_t.specialToken != null)
        {
            tmp_t = tmp_t.specialToken;
        }
        while (tmp_t != null)
        {
            String st = tmp_t.image;
            for(int i = 0, is = st.length(); i < is; i++)
            {
                char c = st.charAt(i);
                if ( c == '#' || c == '$' )
                {
                    sb.append( c );
                }
                /*
                 *  more dreaded MORE hack :)
                 *
                 *  looking for (""\\"")*""$"" sequences
                 */
                if ( c == '\\')
                {
                    boolean ok = true;
                    boolean term = false;
                    int j = i;
                    for( ok = true; ok && j < is; j++)
                    {
                        char cc = st.charAt( j );
                        if (cc == '\\')
                        {
                            /*
                             *  if we see a \, keep going
                             */
                            continue;
                        }
                        else if( cc == '$' )
                        {
                            /*
                             *  a $ ends it correctly
                             */
                            term = true;
                            ok = false;
                        }
                        else
                        {
                            /*
                             *  nah...
                             */
                            ok = false;
                        }
                    }
                    if (term)
                    {
                        String foo =  st.substring( i, j );
                        sb.append( foo );
                        i = j;
                    }
                }
            }
            tmp_t = tmp_t.next;
        }
        return sb;
    }
    /**
     *  complete node literal
     * @param t
     * @return A node literal.
     */
    public static String tokenLiteral( Token t )
    {
        // Look at kind of token and return """" when it's a multiline comment
        if (t.kind == ParserConstants.MULTI_LINE_COMMENT) 
        {
            return """";
        } 
        else if (t.specialToken == null || t.specialToken.image.startsWith(""##""))
        {
            return t.image;
        }
        else 
        {
            StrBuilder special = getSpecialText(t);
            if (special.length() > 0)
            {
                return special.append(t.image).toString();
            }
            return t.image;
        }
    } 
    /**
     * Utility method to interpolate context variables
     * into string literals. So that the following will
     * work:
     *
     * #set $name = ""candy""
     * $image.getURI(""${name}.jpg"")
     *
     * And the string literal argument will
     * be transformed into ""candy.jpg"" before
     * the method is executed.
     * 
     * @deprecated this method isn't called by any class
     * 
     * @param argStr
     * @param vars
     * @return Interpoliation result.
     * @throws MethodInvocationException
     */
    public static String interpolate(String argStr, Context vars) throws MethodInvocationException
    {
        // if there's nothing to replace, skip this (saves buffer allocation)
        if( argStr.indexOf('$') == -1 )
            return argStr;
        StrBuilder argBuf = new StrBuilder();
        for (int cIdx = 0, is = argStr.length(); cIdx < is;)
        {
            char ch = argStr.charAt(cIdx);
            if( ch == '$' )
            {
                StrBuilder nameBuf = new StrBuilder();
                for (++cIdx ; cIdx < is; ++cIdx)
                {
                    ch = argStr.charAt(cIdx);
                    if (ch == '_' || ch == '-'
                        || Character.isLetterOrDigit(ch))
                        nameBuf.append(ch);
                    else if (ch == '{' || ch == '}')
                        continue;
                    else
                        break;
                }
                if (nameBuf.length() > 0)
                {
                    Object value = vars.get(nameBuf.toString());
                    if (value == null)
                        argBuf.append(""$"").append(nameBuf.toString());
                    else
                        argBuf.append(value.toString());
                }
            }
            else
            {
                argBuf.append(ch);
                ++cIdx;
            }
        }
        return argBuf.toString();
    }
}
"
org.apache.velocity.runtime.parser.node.ParserVisitor,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * Interface used in implementation of visitor pattern.  Based on
 * code autogenerated by JavaCC. Formerly found in package
 * org.apache.velocity.runtime.parser.
 *
 * @version $Id: ParserVisitor.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public interface ParserVisitor
{
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(SimpleNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTprocess node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTEscapedDirective node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTEscape node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTComment node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTFloatingPointLiteral node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTIntegerLiteral node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTStringLiteral node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTIdentifier node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTWord node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTDirective node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTBlock node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTMap node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTObjectArray node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTIntegerRange node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTMethod node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTReference node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTTrue node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTFalse node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTText node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTIfStatement node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTElseStatement node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTElseIfStatement node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTSetDirective node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTStop node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTExpression node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTAssignment node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTOrNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTAndNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTEQNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTNENode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTLTNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTGTNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTLENode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTGENode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTAddNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTSubtractNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTMulNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTDivNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTModNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
  public Object visit(ASTNotNode node, Object data);
  /**
   * @param node
   * @param data
   * @return The object rendered by this node.
   */
}
"
org.apache.velocity.runtime.parser.node.PropertyExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.InvocationTargetException;
import org.apache.commons.lang.StringUtils;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeLogger;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.log.RuntimeLoggerLog;
import org.apache.velocity.util.introspection.Introspector;
/**
 * Returned the value of object property when executed.
 */
public class PropertyExecutor extends AbstractExecutor
{
    private final Introspector introspector;
    /**
     * @param log
     * @param introspector
     * @param clazz
     * @param property
     * @since 1.5
     */
    public PropertyExecutor(final Log log, final Introspector introspector,
            final Class clazz, final String property)
    {
        this.log = log;
        this.introspector = introspector;
        // Don't allow passing in the empty string or null because
        // it will either fail with a StringIndexOutOfBounds error
        // or the introspector will get confused.
        if (StringUtils.isNotEmpty(property))
        {
            discover(clazz, property);
        }
    }
    /**
     * @param r
     * @param introspector
     * @param clazz
     * @param property
     * @deprecated RuntimeLogger is deprecated. Use the other constructor.
     */
    public PropertyExecutor(final RuntimeLogger r, final Introspector introspector,
            final Class clazz, final String property)
    {
        this(new RuntimeLoggerLog(r), introspector, clazz, property);
    }
    /**
     * @return The current introspector.
     * @since 1.5
     */
    protected Introspector getIntrospector()
    {
        return this.introspector;
    }
    /**
     * @param clazz
     * @param property
     */
    protected void discover(final Class clazz, final String property)
    {
        /*
         *  this is gross and linear, but it keeps it straightforward.
         */
        try
        {
            Object [] params = {};
            StringBuffer sb = new StringBuffer(""get"");
            sb.append(property);
            setMethod(introspector.getMethod(clazz, sb.toString(), params));
            if (!isAlive())
            {
                /*
                 *  now the convenience, flip the 1st character
                 */
                char c = sb.charAt(3);
                if (Character.isLowerCase(c))
                {
                    sb.setCharAt(3, Character.toUpperCase(c));
                }
                else
                {
                    sb.setCharAt(3, Character.toLowerCase(c));
                }
                setMethod(introspector.getMethod(clazz, sb.toString(), params));
            }
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch(Exception e)
        {
            String msg = ""Exception while looking for property getter for '"" + property;
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.AbstractExecutor#execute(java.lang.Object)
     */
    public Object execute(Object o)
        throws IllegalAccessException,  InvocationTargetException
    {
        return isAlive() ? getMethod().invoke(o, ((Object []) null)) : null;
    }
}
"
org.apache.velocity.runtime.parser.node.PutExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.InvocationTargetException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.util.introspection.Introspector;
/**
 * Executor that simply tries to execute a put(key, value)
 * operation. This will try to find a put(key) method
 * for any type of object, not just objects that
 * implement the Map interface as was previously
 * the case.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: PutExecutor.java 687177 2008-08-19 22:00:32Z nbubna $
 * @since 1.5
 */
public class PutExecutor extends SetExecutor
{
    private final Introspector introspector;
    private final String property;
    /**
     * @param log
     * @param introspector
     * @param clazz
     * @param arg
     * @param property
     */
    public PutExecutor(final Log log, final Introspector introspector,
            final Class clazz, final Object arg, final String property)
    {
        this.log = log;
        this.introspector = introspector;
        this.property = property;
        discover(clazz, arg);
    }
    /**
     * @param clazz
     * @param arg
     */
    protected void discover(final Class clazz, final Object arg)
    {
        Object [] params;
        // If you passed in null as property, we don't use the value
        // for parameter lookup. Instead we just look for put(Object) without
        // any parameters.
        //
        // In any other case, the following condition will set up an array
        // for looking up put(String, Object) on the class.
        if (property == null)
        {
            // The passed in arg object is used by the Cache to look up the method.
            params = new Object[] { arg };
        }
        else
        {
            params = new Object[] { property, arg };
        }
        try
        {
            setMethod(introspector.getMethod(clazz, ""put"", params));
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch(Exception e)
        {
            String msg = ""Exception while looking for put('"" + params[0] + ""') method"";
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.SetExecutor#execute(java.lang.Object, java.lang.Object)
     */
    public Object execute(final Object o, final Object value)
        throws IllegalAccessException,  InvocationTargetException
    {
        Object [] params;
        if (isAlive())
        {
            // If property != null, pass in the name for put(key, value). Else just put(value).
            if (property == null)
            {
                params = new Object [] { value };
            }
            else
            {
                params = new Object [] { property, value };
            }
            return getMethod().invoke(o, params);
        }
        return null;
    }
}
"
org.apache.velocity.runtime.parser.node.SetExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import org.apache.velocity.runtime.log.Log;
/**
 * Abstract class that is used to execute an arbitrary
 * method that is in introspected. This is the superclass
 * for the PutExecutor and SetPropertyExecutor.
 *
 * There really should be a superclass for this and AbstractExecutor (which should
 * be refactored to GetExecutor) because they differ only in the execute() method.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: SetExecutor.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public abstract class SetExecutor
{
    /** Class logger */
    protected Log log = null;
    /**
     * Method to be executed.
     */
    private Method method = null;
    /**
     * Execute method against context.
     * @param o
     * @param value
     * @return The result of the invocation.
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    public abstract Object execute(Object o, Object value)
         throws IllegalAccessException, InvocationTargetException;
    /**
     * Tell whether the executor is alive by looking
     * at the value of the method.
     * @return True if the executor is alive.
     */
    public boolean isAlive()
    {
        return (method != null);
    }
    /**
     * @return The method to invoke.
     */
    public Method getMethod()
    {
        return method;
    }
    /**
     * @param method
     */
    protected void setMethod(final Method method)
    {
        this.method = method;
    }
}
"
org.apache.velocity.runtime.parser.node.SetPropertyExecutor,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.InvocationTargetException;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.text.StrBuilder;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.util.introspection.Introspector;
/**
 * Executor for looking up property names in the passed in class
 * This will try to find a set&lt;foo&gt;(key, value) method
 *
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: SetPropertyExecutor.java 687177 2008-08-19 22:00:32Z nbubna $
 * @since 1.5
 */
public class SetPropertyExecutor
        extends SetExecutor
{
    private final Introspector introspector;
    /**
     * @param log
     * @param introspector
     * @param clazz
     * @param property
     * @param arg
     */
    public SetPropertyExecutor(final Log log, final Introspector introspector,
            final Class clazz, final String property, final Object arg)
    {
        this.log = log;
        this.introspector = introspector;
        // Don't allow passing in the empty string or null because
        // it will either fail with a StringIndexOutOfBounds error
        // or the introspector will get confused.
        if (StringUtils.isNotEmpty(property))
        {
            discover(clazz, property, arg);
        }
    }
    /**
     * @return The current introspector.
     */
    protected Introspector getIntrospector()
    {
        return this.introspector;
    }
    /**
     * @param clazz
     * @param property
     * @param arg
     */
    protected void discover(final Class clazz, final String property, final Object arg)
    {
        Object [] params = new Object [] { arg };
        try
        {
            StrBuilder sb = new StrBuilder(""set"");
            sb.append(property);
            setMethod(introspector.getMethod(clazz, sb.toString(), params));
            if (!isAlive())
            {
                /*
                 *  now the convenience, flip the 1st character
                 */
                char c = sb.charAt(3);
                if (Character.isLowerCase(c))
                {
                    sb.setCharAt(3, Character.toUpperCase(c));
                }
                else
                {
                    sb.setCharAt(3, Character.toLowerCase(c));
                }
                setMethod(introspector.getMethod(clazz, sb.toString(), params));
            }
        }
        /**
         * pass through application level runtime exceptions
         */
        catch( RuntimeException e )
        {
            throw e;
        }
        catch(Exception e)
        {
            String msg = ""Exception while looking for property setter for '"" + property;
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
    }
    /**
     * Execute method against context.
     * @param o
     * @param value
     * @return The value of the invocation.
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    public Object execute(final Object o, final Object value)
        throws IllegalAccessException,  InvocationTargetException
    {
        Object [] params = new Object [] { value };
        return isAlive() ? getMethod().invoke(o, params) : null;
    }
}
"
org.apache.velocity.runtime.parser.node.SimpleNode,"package org.apache.velocity.runtime.parser.node;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.Writer;
import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.commons.lang.text.StrBuilder;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.TemplateInitException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.parser.Parser;
import org.apache.velocity.runtime.parser.Token;
/**
 *
 */
public class SimpleNode implements Node
{
    /** */
    protected RuntimeServices rsvc = null;
    /** */
    protected Log log = null;
    /** */
    protected Node parent;
    /** */
    protected Node[] children;
    /** */
    protected int id;
    /** */
    // TODO - It seems that this field is only valid when parsing, and should not be kept around.    
    protected Parser parser;
    /** */
    protected int info; // added
    /** */
    public boolean state;
    /** */
    protected boolean invalid = false;
    /** */
    protected Token first;
    /** */
    protected Token last;
    protected String templateName;
    /**
     * @param i
     */
    public SimpleNode(int i)
    {
        id = i;
    }
    /**
     * @param p
     * @param i
     */
    public SimpleNode(Parser p, int i)
    {
        this(i);
        parser = p;
        templateName = parser.currentTemplateName;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#jjtOpen()
     */
    public void jjtOpen()
    {
        first = parser.getToken(1); // added
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#jjtClose()
     */
    public void jjtClose()
    {
        last = parser.getToken(0); // added
    }
    /**
     * @param t
     */
    public void setFirstToken(Token t)
    {
        this.first = t;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#getFirstToken()
     */
    public Token getFirstToken()
    {
        return first;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#getLastToken()
     */
    public Token getLastToken()
    {
        return last;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#jjtSetParent(org.apache.velocity.runtime.parser.node.Node)
     */
    public void jjtSetParent(Node n)
    {
        parent = n;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#jjtGetParent()
     */
    public Node jjtGetParent()
    {
        return parent;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#jjtAddChild(org.apache.velocity.runtime.parser.node.Node, int)
     */
    public void jjtAddChild(Node n, int i)
    {
        if (children == null)
        {
            children = new Node[i + 1];
        }
        else if (i >= children.length)
        {
            Node c[] = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }
        children[i] = n;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#jjtGetChild(int)
     */
    public Node jjtGetChild(int i)
    {
        return children[i];
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#jjtGetNumChildren()
     */
    public int jjtGetNumChildren()
    {
        return (children == null) ? 0 : children.length;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#jjtAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object jjtAccept(ParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#childrenAccept(org.apache.velocity.runtime.parser.node.ParserVisitor, java.lang.Object)
     */
    public Object childrenAccept(ParserVisitor visitor, Object data)
    {
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                children[i].jjtAccept(visitor, data);
            }
        }
        return data;
    }
    /* You can override these two methods in subclasses of SimpleNode to
        customize the way the node appears when the tree is dumped.  If
        your output uses more than one line you should override
        toString(String), otherwise overriding toString() is probably all
        you need to do. */
    //    public String toString()
    // {
    //    return ParserTreeConstants.jjtNodeName[id];
    // }
    /**
     * @param prefix
     * @return String representation of this node.
     */
    public String toString(String prefix)
    {
        return prefix + toString();
    }
    /**
     * Override this method if you want to customize how the node dumps
     * out its children.
     *
     * @param prefix
     */
    public void dump(String prefix)
    {
        System.out.println(toString(prefix));
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null)
                {
                    n.dump(prefix + "" "");
                }
            }
        }
    }
    /**
     * Return a string that tells the current location of this node.
     */
    protected String getLocation(InternalContextAdapter context)
    {
        return Log.formatFileString(this);
    }
    // All additional methods
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#literal()
     */
    public String literal()
    {
        // if we have only one string, just return it and avoid
        // buffer allocation. VELOCITY-606
        if (first == last)
        {
            return NodeUtils.tokenLiteral(first);
        }
        Token t = first;
        StrBuilder sb = new StrBuilder(NodeUtils.tokenLiteral(t));
        while (t != last)
        {
            t = t.next;
            sb.append(NodeUtils.tokenLiteral(t));
        }
        return sb.toString();
    }
    /**
     * @throws TemplateInitException 
     * @see org.apache.velocity.runtime.parser.node.Node#init(org.apache.velocity.context.InternalContextAdapter, java.lang.Object)
     */
    public Object init( InternalContextAdapter context, Object data) throws TemplateInitException
    {
        /*
         * hold onto the RuntimeServices
         */
        rsvc = (RuntimeServices) data;
        log = rsvc.getLog();
        int i, k = jjtGetNumChildren();
        for (i = 0; i < k; i++)
        {
            jjtGetChild(i).init( context, data);
        }
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#evaluate(org.apache.velocity.context.InternalContextAdapter)
     */
    public boolean evaluate( InternalContextAdapter  context)
        throws MethodInvocationException
    {
        return false;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#value(org.apache.velocity.context.InternalContextAdapter)
     */
    public Object value( InternalContextAdapter context)
        throws MethodInvocationException
    {
        return null;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#render(org.apache.velocity.context.InternalContextAdapter, java.io.Writer)
     */
    public boolean render( InternalContextAdapter context, Writer writer)
        throws IOException, MethodInvocationException, ParseErrorException, ResourceNotFoundException
    {
        int i, k = jjtGetNumChildren();
        for (i = 0; i < k; i++)
            jjtGetChild(i).render(context, writer);
        return true;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#execute(java.lang.Object, org.apache.velocity.context.InternalContextAdapter)
     */
    public Object execute(Object o, InternalContextAdapter context)
      throws MethodInvocationException
    {
        return null;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#getType()
     */
    public int getType()
    {
        return id;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#setInfo(int)
     */
    public void setInfo(int info)
    {
        this.info = info;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#getInfo()
     */
    public int getInfo()
    {
        return info;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#setInvalid()
     */
    public void setInvalid()
    {
        invalid = true;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#isInvalid()
     */
    public boolean isInvalid()
    {
        return invalid;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#getLine()
     */
    public int getLine()
    {
        return first.beginLine;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.Node#getColumn()
     */
    public int getColumn()
    {
        return first.beginColumn;
    }
    /**
     * @since 1.5
     */
    public String toString()
    {
        StrBuilder tokens = new StrBuilder();
        for (Token t = getFirstToken(); t != null; )
        {
            tokens.append(""["").append(t.image).append(""]"");
            if (t.next != null)
            {
                if (t.equals(getLastToken()))
                {
                    break;
                }
                else
                {
                    tokens.append("", "");
                }
            }
            t = t.next;
        }
        return new ToStringBuilder(this)
            .append(""id"", getType())
            .append(""info"", getInfo())
            .append(""invalid"", isInvalid())
            .append(""children"", jjtGetNumChildren())
            .append(""tokens"", tokens)
            .toString();
    }
    public String getTemplateName()
    {
      return templateName;
    }
}
"
org.apache.velocity.runtime.resource.ContentResource,"package org.apache.velocity.runtime.resource;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.StringWriter;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.VelocityException;
/**
 * This class represent a general text resource that may have been
 * retrieved from any number of possible sources.
 *
 * Also of interest is Velocity's {@link org.apache.velocity.Template}
 * <code>Resource</code>.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ContentResource.java 687177 2008-08-19 22:00:32Z nbubna $
 */
public class ContentResource extends Resource
{
    /** Default empty constructor */
    public ContentResource()
    {
        super();
        setType(ResourceManager.RESOURCE_CONTENT);
    }
    /**
     * Pull in static content and store it.
     * @return True if everything went ok.
     *
     * @exception ResourceNotFoundException Resource could not be
     * found.
     */
    public boolean process()
        throws ResourceNotFoundException
    {
        BufferedReader reader = null;
        try
        {
            StringWriter sw = new StringWriter();
            reader = new BufferedReader(
                new InputStreamReader(resourceLoader.getResourceStream(name),
                                      encoding));
            char buf[] = new char[1024];
            int len = 0;
            while ( ( len = reader.read( buf, 0, 1024 )) != -1)
                sw.write( buf, 0, len );
            setData(sw.toString());
            return true;
        }
        catch ( ResourceNotFoundException e )
        {
            // Tell the ContentManager to continue to look through any
            // remaining configured ResourceLoaders.
            throw e;
        }
        catch ( Exception e )
        {
            String msg = ""Cannot process content resource"";
            rsvc.getLog().error(msg, e);
            throw new VelocityException(msg, e);
        }
        finally
        {
            if (reader != null)
            {
                try
                {
                    reader.close();
                }
                catch (Exception ignored)
                {
                }
            }
        }
    }
}
"
org.apache.velocity.runtime.resource.Resource,"package org.apache.velocity.runtime.resource;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.resource.loader.ResourceLoader;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
/**
 * This class represent a general text resource that
 * may have been retrieved from any number of possible
 * sources.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: Resource.java 685724 2008-08-13 23:12:12Z nbubna $
 */
public abstract class Resource
{
    protected RuntimeServices rsvc = null;
    /**
     * The template loader that initially loaded the input
     * stream for this template, and knows how to check the
     * source of the input stream for modification.
     */
    protected ResourceLoader resourceLoader;
    /**
     * The number of milliseconds in a minute, used to calculate the
     * check interval.
     */
    protected static final long MILLIS_PER_SECOND =  1000;
    /**
     * How often the file modification time is checked (in seconds).
     */
    protected long modificationCheckInterval = 0;
    /**
     * The file modification time (in milliseconds) for the cached template.
     */
    protected long lastModified = 0;
    /**
     * The next time the file modification time will be checked (in
     * milliseconds).
     */
    protected long nextCheck = 0;
    /**
     *  Name of the resource
     */
    protected String name;
    /**
     *  Character encoding of this resource
     */
    protected String encoding = RuntimeConstants.ENCODING_DEFAULT;
    /**
     *  Resource might require ancillary storage of some kind
     */
    protected Object data = null;
    /**
     *  Resource type (RESOURCE_TEMPLATE or RESOURCE_CONTENT)
     */
    protected int type;
    /**
     *  Default constructor
     */
    public Resource()
    {
    }
    /**
     * @param rs
     */
    public void setRuntimeServices( RuntimeServices rs )
    {
        rsvc = rs;
    }
    /**
     * Perform any subsequent processing that might need
     * to be done by a resource. In the case of a template
     * the actual parsing of the input stream needs to be
     * performed.
     *
     * @return Whether the resource could be processed successfully.
     * For a {@link org.apache.velocity.Template} or {@link
     * org.apache.velocity.runtime.resource.ContentResource}, this
     * indicates whether the resource could be read.
     * @exception ResourceNotFoundException Similar in semantics as
     * returning <code>false</code>.
     * @throws ParseErrorException
     * @throws Exception
     */
    public abstract boolean process()
        throws ResourceNotFoundException, ParseErrorException, Exception;
    /**
     * @return True if source has been modified.
     */
    public boolean isSourceModified()
    {
        return resourceLoader.isSourceModified(this);
    }
    /**
     * Set the modification check interval.
     * @param modificationCheckInterval The interval (in seconds).
     */
    public void setModificationCheckInterval(long modificationCheckInterval)
    {
        this.modificationCheckInterval = modificationCheckInterval;
    }
    /**
     * Is it time to check to see if the resource
     * source has been updated?
     * @return True if resource must be checked.
     */
    public boolean requiresChecking()
    {
        /*
         *  short circuit this if modificationCheckInterval == 0
         *  as this means ""don't check""
         */
        if (modificationCheckInterval <= 0 )
        {
           return false;
        }
        /*
         *  see if we need to check now
         */
        return ( System.currentTimeMillis() >= nextCheck );
    }
    /**
     * 'Touch' this template and thereby resetting
     * the nextCheck field.
     */
    public void touch()
    {
        nextCheck = System.currentTimeMillis() + ( MILLIS_PER_SECOND *  modificationCheckInterval);
    }
    /**
     * Set the name of this resource, for example
     * test.vm.
     * @param name
     */
    public void setName(String name)
    {
        this.name = name;
    }
    /**
     * Get the name of this template.
     * @return The name of this template.
     */
    public String getName()
    {
        return name;
    }
    /**
     *  set the encoding of this resource
     *  for example, ""ISO-8859-1""
     * @param encoding
     */
    public void setEncoding( String encoding )
    {
        this.encoding = encoding;
    }
    /**
     *  get the encoding of this resource
     *  for example, ""ISO-8859-1""
     * @return The encoding of this resource.
     */
    public String getEncoding()
    {
        return encoding;
    }
    /**
     * Return the lastModifed time of this
     * resource.
     * @return The lastModifed time of this resource.
     */
    public long getLastModified()
    {
        return lastModified;
    }
    /**
     * Set the last modified time for this
     * resource.
     * @param lastModified
     */
    public void setLastModified(long lastModified)
    {
        this.lastModified = lastModified;
    }
    /**
     * Return the template loader that pulled
     * in the template stream
     * @return The resource loader for this resource.
     */
    public ResourceLoader getResourceLoader()
    {
        return resourceLoader;
    }
    /**
     * Set the template loader for this template. Set
     * when the Runtime determines where this template
     * came from the list of possible sources.
     * @param resourceLoader
     */
    public void setResourceLoader(ResourceLoader resourceLoader)
    {
        this.resourceLoader = resourceLoader;
    }
    /**
     * Set arbitrary data object that might be used
     * by the resource.
     * @param data
     */
    public void setData(Object data)
    {
        this.data = data;
    }
    /**
     * Get arbitrary data object that might be used
     * by the resource.
     * @return The data object for this resource.
     */
    public Object getData()
    {
        return data;
    }
    /**
     * Sets the type of this Resource (RESOURCE_TEMPLATE or RESOURCE_CONTENT)
     * @since 1.6
     */
    public void setType(int type)
    {
        this.type = type;
    }
    /**
     * @return type code of the Resource
     * @since 1.6
     */
    public int getType()
    {
        return type;
    }
}
"
org.apache.velocity.runtime.resource.ResourceCache,"package org.apache.velocity.runtime.resource;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Iterator;
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Interface that defines the shape of a pluggable resource cache
 *  for the included ResourceManager
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ResourceCache.java 463298 2006-10-12 16:10:32Z henning $
 */
public interface ResourceCache
{
    /**
     *  initializes the ResourceCache.  Will be
     *  called before any utilization
     *
     *  @param rs RuntimeServices to use for logging, etc
     */
    public void initialize( RuntimeServices rs );
    /**
     *  retrieves a Resource from the
     *  cache
     *
     *  @param resourceKey key for Resource to be retrieved
     *  @return Resource specified or null if not found
     */
    public Resource get( Object resourceKey );
    /**
     *  stores a Resource in the cache
     *
     *  @param resourceKey key to associate with the Resource
     *  @param resource Resource to be stored
     *  @return existing Resource stored under this key, or null if none
     */
    public Resource put( Object resourceKey, Resource resource );
    /**
     *  removes a Resource from the cache
     *
     *  @param resourceKey resource to be removed
     *  @return stored under key
     */
    public Resource remove( Object resourceKey );
    /**
     *  returns an Iterator of Keys in the cache.
     * @return An Iterator of Keys in the cache.
     */
     public Iterator enumerateKeys();
}
"
org.apache.velocity.runtime.resource.ResourceCacheImpl,"package org.apache.velocity.runtime.resource;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import java.util.Iterator;
import org.apache.commons.collections.map.LRUMap;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.MapFactory;
/**
 * Default implementation of the resource cache for the default
 * ResourceManager.  The cache uses a <i>least recently used</i> (LRU)
 * algorithm, with a maximum size specified via the
 * <code>resource.manager.cache.size</code> property (idenfied by the
 * {@link
 * org.apache.velocity.runtime.RuntimeConstants#RESOURCE_MANAGER_DEFAULTCACHE_SIZE}
 * constant).  This property get be set to <code>0</code> or less for
 * a greedy, unbounded cache (the behavior from pre-v1.5).
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 * @version $Id: ResourceCacheImpl.java 685385 2008-08-12 23:59:06Z nbubna $
 */
public class ResourceCacheImpl implements ResourceCache
{
    /**
     * Cache storage, assumed to be thread-safe.
     */
    protected Map cache = MapFactory.create(512, 0.5f, 30, false);
    /**
     * Runtime services, generally initialized by the
     * <code>initialize()</code> method.
     */
    protected RuntimeServices rsvc = null;
    /**
     * @see org.apache.velocity.runtime.resource.ResourceCache#initialize(org.apache.velocity.runtime.RuntimeServices)
     */
    public void initialize( RuntimeServices rs )
    {
        rsvc = rs;
        int maxSize =
            rsvc.getInt(RuntimeConstants.RESOURCE_MANAGER_DEFAULTCACHE_SIZE, 89);
        if (maxSize > 0)
        {
            // Create a whole new Map here to avoid hanging on to a
            // handle to the unsynch'd LRUMap for our lifetime.
            Map lruCache = Collections.synchronizedMap(new LRUMap(maxSize));
            lruCache.putAll(cache);
            cache = lruCache;
        }
        rsvc.getLog().debug(""ResourceCache: initialized (""+this.getClass()+"") with ""+
               cache.getClass()+"" cache map."");
    }
    /**
     * @see org.apache.velocity.runtime.resource.ResourceCache#get(java.lang.Object)
     */
    public Resource get( Object key )
    {
        return (Resource) cache.get( key );
    }
    /**
     * @see org.apache.velocity.runtime.resource.ResourceCache#put(java.lang.Object, org.apache.velocity.runtime.resource.Resource)
     */
    public Resource put( Object key, Resource value )
    {
        return (Resource) cache.put( key, value );
    }
    /**
     * @see org.apache.velocity.runtime.resource.ResourceCache#remove(java.lang.Object)
     */
    public Resource remove( Object key )
    {
        return (Resource) cache.remove( key );
    }
    /**
     * @see org.apache.velocity.runtime.resource.ResourceCache#enumerateKeys()
     */
    public Iterator enumerateKeys()
    {
        return cache.keySet().iterator();
    }
}
"
org.apache.velocity.runtime.resource.ResourceFactory,"package org.apache.velocity.runtime.resource;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.Template;
/**
 * Class responsible for instantiating <code>Resource</code> objects,
 * given name and type.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ResourceFactory.java 463298 2006-10-12 16:10:32Z henning $
 */
public class ResourceFactory
{
    /**
     * @param resourceName
     * @param resourceType
     * @return The resource described by name and type.
     */
    public static Resource getResource(String resourceName, int resourceType)
    {
        Resource resource = null;
        switch (resourceType)
        {
            case ResourceManager.RESOURCE_TEMPLATE:
                resource = new Template();
                break;
            case ResourceManager.RESOURCE_CONTENT:
                resource = new ContentResource();
                break;
        }
        return resource;
    }
}
"
org.apache.velocity.runtime.resource.ResourceManager,"package org.apache.velocity.runtime.resource;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.ParseErrorException;
/**
 * Class to manage the text resource for the Velocity
 * Runtime.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:paulo.gaspar@krankikom.de"">Paulo Gaspar</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ResourceManager.java 463298 2006-10-12 16:10:32Z henning $
 */
public interface ResourceManager
{
    /**
     * A template resources.
     */
    public static final int RESOURCE_TEMPLATE = 1;
    /**
     * A static content resource.
     */
    public static final int RESOURCE_CONTENT = 2;
    /**
     * Initialize the ResourceManager.
     * @param rs
     * @throws Exception
     */
    public void initialize( RuntimeServices rs ) throws Exception;
    /**
     * Gets the named resource.  Returned class type corresponds to specified type
     * (i.e. <code>Template</code> to <code>RESOURCE_TEMPLATE</code>).
     *
     * @param resourceName The name of the resource to retrieve.
     * @param resourceType The type of resource (<code>RESOURCE_TEMPLATE</code>,
     *                     <code>RESOURCE_CONTENT</code>, etc.).
     * @param encoding  The character encoding to use.
     * @return Resource with the template parsed and ready.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if a problem in parse
     */
    public Resource getResource(String resourceName, int resourceType, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception;
    /**
     *  Determines is a template exists, and returns name of the loader that
     *  provides it.  This is a slightly less hokey way to support
     *  the Velocity.templateExists() utility method, which was broken
     *  when per-template encoding was introduced.  We can revisit this.
     *
     *  @param resourceName Name of template or content resource
     *  @return class name of loader than can provide it
     */
    public String getLoaderNameForResource(String resourceName );
}
"
org.apache.velocity.runtime.resource.ResourceManagerImpl,"package org.apache.velocity.runtime.resource;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.resource.loader.ResourceLoader;
import org.apache.velocity.runtime.resource.loader.ResourceLoaderFactory;
import org.apache.velocity.util.ClassUtils;
import org.apache.velocity.util.StringUtils;
/**
 * Class to manage the text resource for the Velocity Runtime.
 *
 * @author  <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author  <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author  <a href=""mailto:paulo.gaspar@krankikom.de"">Paulo Gaspar</a>
 * @author  <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author  <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version  $Id: ResourceManagerImpl.java 692505 2008-09-05 18:21:51Z nbubna $
 */
public class ResourceManagerImpl
    implements ResourceManager
{
    /** A template resources. */
    public static final int RESOURCE_TEMPLATE = 1;
    /** A static content resource. */
    public static final int RESOURCE_CONTENT = 2;
    /** token used to identify the loader internally. */
    private static final String RESOURCE_LOADER_IDENTIFIER = ""_RESOURCE_LOADER_IDENTIFIER_"";
    /** Object implementing ResourceCache to be our resource manager's Resource cache. */
    protected ResourceCache globalCache = null;
    /** The List of templateLoaders that the Runtime will use to locate the InputStream source of a template. */
    protected final List resourceLoaders = new ArrayList();
    /**
     * This is a list of the template input stream source initializers, basically properties for a particular template stream
     * source. The order in this list reflects numbering of the properties i.e.
     *
     * <p>&lt;loader-id&gt;.resource.loader.&lt;property&gt; = &lt;value&gt;</p>
     */
    private final List sourceInitializerList = new ArrayList();
    /**
     * Has this Manager been initialized?
     */
    private boolean isInit = false;
    /** switch to turn off log notice when a resource is found for the first time. */
    private boolean logWhenFound = true;
    /** The internal RuntimeServices object. */
    protected RuntimeServices rsvc = null;
    /** Logging. */
    protected Log log = null;
    /**
     * Initialize the ResourceManager.
     *
     * @param  rsvc  The Runtime Services object which is associated with this Resource Manager.
     *
     * @throws  Exception
     */
    public synchronized void initialize(final RuntimeServices rsvc)
        throws Exception
    {
        if (isInit)
        {
            log.debug(""Re-initialization of ResourceLoader attempted and ignored."");
            return;
        }
        ResourceLoader resourceLoader = null;
        this.rsvc = rsvc;
        log = rsvc.getLog();
        log.trace(""Default ResourceManager initializing. ("" + this.getClass() + "")"");
        assembleResourceLoaderInitializers();
        for (Iterator it = sourceInitializerList.iterator(); it.hasNext();)
        {
            /**
             * Resource loader can be loaded either via class name or be passed
             * in as an instance.
             */
            ExtendedProperties configuration = (ExtendedProperties) it.next();
            String loaderClass = StringUtils.nullTrim(configuration.getString(""class""));
            ResourceLoader loaderInstance = (ResourceLoader) configuration.get(""instance"");
            if (loaderInstance != null)
            {
                resourceLoader = loaderInstance;
            }
            else if (loaderClass != null)
            {
                resourceLoader = ResourceLoaderFactory.getLoader(rsvc, loaderClass);
            }
            else
            {
                String msg = ""Unable to find '"" +
                          configuration.getString(RESOURCE_LOADER_IDENTIFIER) +
                          "".resource.loader.class' specification in configuration."" +
                          "" This is a critical value.  Please adjust configuration."";
                log.error(msg);
                throw new Exception(msg);
            }
            resourceLoader.commonInit(rsvc, configuration);
            resourceLoader.init(configuration);
            resourceLoaders.add(resourceLoader);
        }
        /*
         * now see if this is overridden by configuration
         */
        logWhenFound = rsvc.getBoolean(RuntimeConstants.RESOURCE_MANAGER_LOGWHENFOUND, true);
        /*
         *  now, is a global cache specified?
         */
        String cacheClassName = rsvc.getString(RuntimeConstants.RESOURCE_MANAGER_CACHE_CLASS);
        Object cacheObject = null;
        if (org.apache.commons.lang.StringUtils.isNotEmpty(cacheClassName))
        {
            try
            {
                cacheObject = ClassUtils.getNewInstance(cacheClassName);
            }
            catch (ClassNotFoundException cnfe)
            {
                String msg = ""The specified class for ResourceCache ("" + cacheClassName +
                          "") does not exist or is not accessible to the current classloader."";
                log.error(msg, cnfe);
                throw cnfe;
            }
            if (!(cacheObject instanceof ResourceCache))
            {
                String msg = ""The specified resource cache class ("" + cacheClassName +
                          "") must implement "" + ResourceCache.class.getName();
                log.error(msg);
                throw new RuntimeException(msg);
            }
        }
        /*
         *  if we didn't get through that, just use the default.
         */
        if (cacheObject == null)
        {
            cacheObject = new ResourceCacheImpl();
        }
        globalCache = (ResourceCache) cacheObject;
        globalCache.initialize(rsvc);
        log.trace(""Default ResourceManager initialization complete."");
    }
    /**
     * This will produce a List of Hashtables, each hashtable contains the intialization info for a particular resource loader. This
     * Hashtable will be passed in when initializing the the template loader.
     */
    private void assembleResourceLoaderInitializers()
    {
        Vector resourceLoaderNames = rsvc.getConfiguration().getVector(RuntimeConstants.RESOURCE_LOADER);
        StringUtils.trimStrings(resourceLoaderNames);
        for (Iterator it = resourceLoaderNames.iterator(); it.hasNext(); )
        {
            /*
             * The loader id might look something like the following:
             *
             * file.resource.loader
             *
             * The loader id is the prefix used for all properties
             * pertaining to a particular loader.
             */
            String loaderName = (String) it.next();
            StringBuffer loaderID = new StringBuffer(loaderName);
            loaderID.append(""."").append(RuntimeConstants.RESOURCE_LOADER);
            ExtendedProperties loaderConfiguration = 
        		rsvc.getConfiguration().subset(loaderID.toString());
            /*
             *  we can't really count on ExtendedProperties to give us an empty set
             */
            if (loaderConfiguration == null)
            {
                log.debug(""ResourceManager : No configuration information found ""+
                          ""for resource loader named '"" + loaderName +
                          ""' (id is ""+loaderID+""). Skipping it..."");
                continue;
            }
            /*
             *  add the loader name token to the initializer if we need it
             *  for reference later. We can't count on the user to fill
             *  in the 'name' field
             */
            loaderConfiguration.setProperty(RESOURCE_LOADER_IDENTIFIER, loaderName);
            /*
             * Add resources to the list of resource loader
             * initializers.
             */
            sourceInitializerList.add(loaderConfiguration);
        }
    }
    /**
     * Gets the named resource. Returned class type corresponds to specified type (i.e. <code>Template</code> to <code>
     * RESOURCE_TEMPLATE</code>).
     *
     * This method is now unsynchronized which requires that ResourceCache
     * implementations be thread safe (as the default is).
     *
     * @param  resourceName  The name of the resource to retrieve.
     * @param  resourceType  The type of resource (<code>RESOURCE_TEMPLATE</code>, <code>RESOURCE_CONTENT</code>, etc.).
     * @param  encoding  The character encoding to use.
     *
     * @return  Resource with the template parsed and ready.
     *
     * @throws  ResourceNotFoundException  if template not found from any available source.
     * @throws  ParseErrorException  if template cannot be parsed due to syntax (or other) error.
     * @throws  Exception  if a problem in parse
     */
    public Resource getResource(final String resourceName, final int resourceType, final String encoding)
        throws ResourceNotFoundException,
            ParseErrorException,
            Exception
    {
        /*
         * Check to see if the resource was placed in the cache.
         * If it was placed in the cache then we will use
         * the cached version of the resource. If not we
         * will load it.
         *
         * Note: the type is included in the key to differentiate ContentResource
         * (static content from #include) with a Template.
         */
        String resourceKey = resourceType + resourceName;
        Resource resource = globalCache.get(resourceKey);
        if (resource != null)
        {
            try
            {
                // avoids additional method call to refreshResource
                if (resource.requiresChecking())
                {
                    /*
                     * both loadResource() and refreshResource() now return
                     * a new Resource instance when they are called
                     * (put in the cache when appropriate) in order to allow
                     * several threads to parse the same template simultaneously.
                     * It is redundant work and will cause more garbage collection but the
                     * benefit is that it allows concurrent parsing and processing
                     * without race conditions when multiple requests try to
                     * refresh/load the same template at the same time.
                     *
                     * Another alternative is to limit template parsing/retrieval
                     * so that only one thread can parse each template at a time
                     * but that creates a scalability bottleneck.
                     *
                     * See VELOCITY-606, VELOCITY-595 and VELOCITY-24
                     */
                    resource = refreshResource(resource, encoding);
                }
            }
            catch (ResourceNotFoundException rnfe)
            {
                /*
                 *  something exceptional happened to that resource
                 *  this could be on purpose,
                 *  so clear the cache and try again
                 */
                globalCache.remove(resourceKey);
                return getResource(resourceName, resourceType, encoding);
            }
            catch (ParseErrorException pee)
            {
                log.error(""ResourceManager.getResource() exception"", pee);
                throw pee;
            }
            catch (RuntimeException re)
            {
                log.error(""ResourceManager.getResource() exception"", re);
        	    throw re;
            }
            catch (Exception e)
            {
                log.error(""ResourceManager.getResource() exception"", e);
                throw e;
            }
        }
        else
        {
            try
            {
                /*
                 *  it's not in the cache, so load it.
                 */    
                resource = loadResource(resourceName, resourceType, encoding);
                if (resource.getResourceLoader().isCachingOn())
                {
                    globalCache.put(resourceKey, resource);
                }
            }
            catch (ResourceNotFoundException rnfe)
            {
                log.error(""ResourceManager : unable to find resource '"" +
                          resourceName + ""' in any resource loader."");
                throw rnfe;
            }
            catch (ParseErrorException pee)
            {
                log.error(""ResourceManager.getResource() parse exception"", pee);
                throw pee;
            }
            catch (RuntimeException re)
            {
                log.error(""ResourceManager.getResource() load exception"", re);
    		    throw re;
            }
            catch (Exception e)
            {
                log.error(""ResourceManager.getResource() exception new"", e);
                throw e;
            }
        }
        return resource;
    }
    /**
     * Create a new Resource of the specified type.
     *
     * @param  resourceName  The name of the resource to retrieve.
     * @param  resourceType  The type of resource (<code>RESOURCE_TEMPLATE</code>, <code>RESOURCE_CONTENT</code>, etc.).
     * @return  new instance of appropriate resource type
     * @since 1.6
     */
    protected Resource createResource(String resourceName, int resourceType)
    {
        return ResourceFactory.getResource(resourceName, resourceType);
    }
    /**
     * Loads a resource from the current set of resource loaders.
     *
     * @param  resourceName  The name of the resource to retrieve.
     * @param  resourceType  The type of resource (<code>RESOURCE_TEMPLATE</code>, <code>RESOURCE_CONTENT</code>, etc.).
     * @param  encoding  The character encoding to use.
     *
     * @return  Resource with the template parsed and ready.
     *
     * @throws  ResourceNotFoundException  if template not found from any available source.
     * @throws  ParseErrorException  if template cannot be parsed due to syntax (or other) error.
     * @throws  Exception  if a problem in parse
     */
    protected Resource loadResource(String resourceName, int resourceType, String encoding)
        throws ResourceNotFoundException,
            ParseErrorException,
            Exception
    {
        Resource resource = createResource(resourceName, resourceType);
        resource.setRuntimeServices(rsvc);
        resource.setName(resourceName);
        resource.setEncoding(encoding);
        /*
         * Now we have to try to find the appropriate
         * loader for this resource. We have to cycle through
         * the list of available resource loaders and see
         * which one gives us a stream that we can use to
         * make a resource with.
         */
        long howOldItWas = 0;
        for (Iterator it = resourceLoaders.iterator(); it.hasNext();)
        {
            ResourceLoader resourceLoader = (ResourceLoader) it.next();
            resource.setResourceLoader(resourceLoader);
            /*
             *  catch the ResourceNotFound exception
             *  as that is ok in our new multi-loader environment
             */
            try
            {
                if (resource.process())
                {
                    /*
                     *  FIXME  (gmj)
                     *  moved in here - technically still
                     *  a problem - but the resource needs to be
                     *  processed before the loader can figure
                     *  it out due to to the new
                     *  multi-path support - will revisit and fix
                     */
                    if (logWhenFound && log.isDebugEnabled())
                    {
                        log.debug(""ResourceManager : found "" + resourceName +
                                  "" with loader "" +
                                  resourceLoader.getClassName());
                    }
                    howOldItWas = resourceLoader.getLastModified(resource);
                    break;
                }
            }
            catch (ResourceNotFoundException rnfe)
            {
                /*
                 *  that's ok - it's possible to fail in
                 *  multi-loader environment
                 */
            }
        }
        /*
         * Return null if we can't find a resource.
         */
        if (resource.getData() == null)
        {
            throw new ResourceNotFoundException(""Unable to find resource '"" + resourceName + ""'"");
        }
        /*
         *  some final cleanup
         */
        resource.setLastModified(howOldItWas);
        resource.setModificationCheckInterval(resource.getResourceLoader().getModificationCheckInterval());
        resource.touch();
        return resource;
    }
    /**
     * Takes an existing resource, and 'refreshes' it. This generally means that the source of the resource is checked for changes
     * according to some cache/check algorithm and if the resource changed, then the resource data is reloaded and re-parsed.
     *
     * @param  resource  resource to refresh
     * @param  encoding  character encoding of the resource to refresh.
     *
     * @throws  ResourceNotFoundException  if template not found from current source for this Resource
     * @throws  ParseErrorException  if template cannot be parsed due to syntax (or other) error.
     * @throws  Exception  if a problem in parse
     */
    protected Resource refreshResource(Resource resource, final String encoding)
        throws ResourceNotFoundException,
            ParseErrorException,
            Exception
    {
        /*
         * The resource knows whether it needs to be checked
         * or not, and the resource's loader can check to
         * see if the source has been modified. If both
         * these conditions are true then we must reload
         * the input stream and parse it to make a new
         * AST for the resource.
         */
        /*
         *  touch() the resource to reset the counters
         */
        resource.touch();
        if (resource.isSourceModified())
        {
            /*
             *  now check encoding info.  It's possible that the newly declared
             *  encoding is different than the encoding already in the resource
             *  this strikes me as bad...
             */
            if (!org.apache.commons.lang.StringUtils.equals(resource.getEncoding(), encoding))
            {
                log.warn(""Declared encoding for template '"" +
                             resource.getName() +
                             ""' is different on reload. Old = '"" +
                             resource.getEncoding() + ""' New = '"" + encoding);
                resource.setEncoding(encoding);
            }
            /*
             *  read how old the resource is _before_
             *  processing (=>reading) it
             */
            long howOldItWas = resource.getResourceLoader().getLastModified(resource);
            String resourceKey = resource.getType() + resource.getName();
            /* 
             * we create a copy to avoid partially overwriting a
             * template which may be in use in another thread
             */ 
            Resource newResource = 
                ResourceFactory.getResource(resource.getName(), resource.getType());
            newResource.setRuntimeServices(rsvc);
            newResource.setName(resource.getName());
            newResource.setEncoding(resource.getEncoding());
            newResource.setResourceLoader(resource.getResourceLoader());
            newResource.setModificationCheckInterval(resource.getResourceLoader().getModificationCheckInterval());
            newResource.process();
            newResource.setLastModified(howOldItWas);
            resource = newResource;
            globalCache.put(resourceKey, newResource);
        }
        return resource;
    }
    /**
     * Gets the named resource. Returned class type corresponds to specified type (i.e. <code>Template</code> to <code>
     * RESOURCE_TEMPLATE</code>).
     *
     * @param  resourceName  The name of the resource to retrieve.
     * @param  resourceType  The type of resource (<code>RESOURCE_TEMPLATE</code>, <code>RESOURCE_CONTENT</code>, etc.).
     *
     * @return  Resource with the template parsed and ready.
     *
     * @throws  ResourceNotFoundException  if template not found from any available source.
     * @throws  ParseErrorException  if template cannot be parsed due to syntax (or other) error.
     * @throws  Exception  if a problem in parse
     *
     * @deprecated  Use {@link #getResource(String resourceName, int resourceType, String encoding )}
     */
    public Resource getResource(String resourceName, int resourceType)
        throws ResourceNotFoundException,
            ParseErrorException,
            Exception
    {
        return getResource(resourceName, resourceType, RuntimeConstants.ENCODING_DEFAULT);
    }
    /**
     * Determines if a template exists, and returns name of the loader that provides it. This is a slightly less hokey way to
     * support the Velocity.templateExists() utility method, which was broken when per-template encoding was introduced. We can
     * revisit this.
     *
     * @param  resourceName  Name of template or content resource
     *
     * @return  class name of loader than can provide it
     */
    public String getLoaderNameForResource(String resourceName)
    {
        /*
         *  loop through our loaders...
         */
        for (Iterator it = resourceLoaders.iterator(); it.hasNext(); )
        {
            ResourceLoader resourceLoader = (ResourceLoader) it.next();
            if (resourceLoader.resourceExists(resourceName))
            {
                return resourceLoader.getClass().toString();
            }
        }
        return null;
    }
}
"
org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.InputStream;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.commons.lang.StringUtils;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.util.ClassUtils;
import org.apache.velocity.util.ExceptionUtils;
/**
 *  ClasspathResourceLoader is a simple loader that will load
 *  templates from the classpath.
 *  <br>
 *  <br>
 *  Will load templates from  from multiple instances of
 *  and arbitrary combinations of :
 *  <ul>
 *  <li> jar files
 *  <li> zip files
 *  <li> template directories (any directory containing templates)
 *  </ul>
 *  This is a configuration-free loader, in that there are no
 *  parameters to be specified in the configuration properties,
 *  other than specifying this as the loader to use.  For example
 *  the following is all that the loader needs to be functional :
 *  <br>
 *  <br>
 *  resource.loader = class
 *  class.resource.loader.class =
 *    org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader
 *  <br>
 *  <br>
 *  To use, put your template directories, jars
 *  and zip files into the classpath or other mechanisms that make
 *  resources accessable to the classloader.
 *  <br>
 *  <br>
 *  This makes deployment trivial for web applications running in
 *  any Servlet 2.2 compliant servlet runner, such as Tomcat 3.2
 *  and others.
 *  <br>
 *  <br>
 *  For a Servlet Spec v2.2 servlet runner,
 *  just drop the jars of template files into the WEB-INF/lib
 *  directory of your webapp, and you won't have to worry about setting
 *  template paths or altering them with the root of the webapp
 *  before initializing.
 *  <br>
 *  <br>
 *  I have also tried it with a WAR deployment, and that seemed to
 *  work just fine.
 *
 * @author <a href=""mailto:mailmur@yahoo.com"">Aki Nieminen</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ClasspathResourceLoader.java 471259 2006-11-04 20:26:57Z henning $
 */
public class ClasspathResourceLoader extends ResourceLoader
{
    /**
     *  This is abstract in the base class, so we need it
     * @param configuration
     */
    public void init( ExtendedProperties configuration)
    {
        if (log.isTraceEnabled())
        {
            log.trace(""ClasspathResourceLoader : initialization complete."");
        }
    }
    /**
     * Get an InputStream so that the Runtime can build a
     * template with it.
     *
     * @param name name of template to get
     * @return InputStream containing the template
     * @throws ResourceNotFoundException if template not found
     *         in  classpath.
     */
    public InputStream getResourceStream( String name )
        throws ResourceNotFoundException
    {
        InputStream result = null;
        if (StringUtils.isEmpty(name))
        {
            throw new ResourceNotFoundException (""No template name provided"");
        }
        /**
         * look for resource in thread classloader first (e.g. WEB-INF\lib in
         * a servlet container) then fall back to the system classloader.
         */
        try
        {
            result = ClassUtils.getResourceAsStream( getClass(), name );
        }
        catch( Exception fnfe )
        {
            throw (ResourceNotFoundException) ExceptionUtils.createWithCause(ResourceNotFoundException.class, ""problem with template: "" + name, fnfe );
        }
        if (result == null)
        {
             String msg = ""ClasspathResourceLoader Error: cannot find resource "" +
              name;
             throw new ResourceNotFoundException( msg );
        }
        return result;
    }
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#isSourceModified(org.apache.velocity.runtime.resource.Resource)
     */
    public boolean isSourceModified(Resource resource)
    {
        return false;
    }
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#getLastModified(org.apache.velocity.runtime.resource.Resource)
     */
    public long getLastModified(Resource resource)
    {
        return 0;
    }
}
"
org.apache.velocity.runtime.resource.loader.DataSourceResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.BufferedInputStream;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.util.ExceptionUtils;
import org.apache.velocity.util.StringUtils;
/**
 * <P>This is a simple template file loader that loads templates
 * from a DataSource instead of plain files.
 *
 * <P>It can be configured with a datasource name, a table name,
 * id column (name), content column (the template body) and a
 * datetime column (for last modification info).
 * <br>
 * <br>
 * Example configuration snippet for velocity.properties:
 * <br>
 * <br>
 * resource.loader = file, ds <br>
 * <br>
 * ds.resource.loader.public.name = DataSource <br>
 * ds.resource.loader.description = Velocity DataSource Resource Loader <br>
 * ds.resource.loader.class = org.apache.velocity.runtime.resource.loader.DataSourceResourceLoader <br>
 * ds.resource.loader.resource.datasource = java:comp/env/jdbc/Velocity <br>
 * ds.resource.loader.resource.table = tb_velocity_template <br>
 * ds.resource.loader.resource.keycolumn = id_template <br>
 * ds.resource.loader.resource.templatecolumn = template_definition <br>
 * ds.resource.loader.resource.timestampcolumn = template_timestamp <br>
 * ds.resource.loader.cache = false <br>
 * ds.resource.loader.modificationCheckInterval = 60 <br>
 * <br>
 * <P>Optionally, the developer can instantiate the DataSourceResourceLoader and set the DataSource via code in
 * a manner similar to the following:
 * <BR>
 * <BR>
 * DataSourceResourceLoader ds = new DataSourceResourceLoader();<BR>
 * ds.setDataSource(DATASOURCE);<BR>
 * Velocity.setProperty(""ds.resource.loader.instance"",ds);<BR>
 * <P> The property <code>ds.resource.loader.class</code> should be left out, otherwise all the other
 * properties in velocity.properties would remain the same.
 * <BR>
 * <BR>
 *
 * Example WEB-INF/web.xml: <br>
 * <br>
 *  <resource-ref> <br>
 *   <description>Velocity template DataSource</description> <br>
 *   <res-ref-name>jdbc/Velocity</res-ref-name> <br>
 *   <res-type>javax.sql.DataSource</res-type> <br>
 *   <res-auth>Container</res-auth> <br>
 *  </resource-ref> <br>
 * <br>
 *  <br>
 * and Tomcat 4 server.xml file: <br>
 *  [...] <br>
 *  <Context path=""/exampleVelocity"" docBase=""exampleVelocity"" debug=""0""> <br>
 *  [...] <br>
 *   <ResourceParams name=""jdbc/Velocity""> <br>
 *    <parameter> <br>
 *      <name>driverClassName</name> <br>
 *      <value>org.hsql.jdbcDriver</value> <br>
 *    </parameter> <br>
 *    <parameter> <br>
 *     <name>driverName</name> <br>
 *     <value>jdbc:HypersonicSQL:database</value> <br>
 *    </parameter> <br>
 *    <parameter> <br>
 *     <name>user</name> <br>
 *     <value>database_username</value> <br>
 *    </parameter> <br>
 *    <parameter> <br>
 *     <name>password</name> <br>
 *     <value>database_password</value> <br>
 *    </parameter> <br>
 *   </ResourceParams> <br>
 *  [...] <br>
 *  </Context> <br>
 *  [...] <br>
 * <br>
 *  Example sql script:<br>
 *  CREATE TABLE tb_velocity_template ( <br>
 *  id_template varchar (40) NOT NULL , <br>
 *  template_definition text (16) NOT NULL , <br>
 *  template_timestamp datetime NOT NULL  <br>
 *  ) <br>
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:matt@raibledesigns.com"">Matt Raible</a>
 * @author <a href=""mailto:david.kinnvall@alertir.com"">David Kinnvall</a>
 * @author <a href=""mailto:paulo.gaspar@krankikom.de"">Paulo Gaspar</a>
 * @author <a href=""mailto:lachiewicz@plusnet.pl"">Sylwester Lachiewicz</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: DataSourceResourceLoader.java 687177 2008-08-19 22:00:32Z nbubna $
 * @since 1.5
 */
public class DataSourceResourceLoader extends ResourceLoader
{
    private String dataSourceName;
    private String tableName;
    private String keyColumn;
    private String templateColumn;
    private String timestampColumn;
    private InitialContext ctx;
    private DataSource dataSource;
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#init(org.apache.commons.collections.ExtendedProperties)
     */
    public void init(ExtendedProperties configuration)
    {
        dataSourceName  = StringUtils.nullTrim(configuration.getString(""resource.datasource""));
        tableName       = StringUtils.nullTrim(configuration.getString(""resource.table""));
        keyColumn       = StringUtils.nullTrim(configuration.getString(""resource.keycolumn""));
        templateColumn  = StringUtils.nullTrim(configuration.getString(""resource.templatecolumn""));
        timestampColumn = StringUtils.nullTrim(configuration.getString(""resource.timestampcolumn""));
        if (dataSource != null)
        {
            if (log.isDebugEnabled())
            {
                log.debug(""DataSourceResourceLoader: using dataSource instance with table \""""
                          + tableName + ""\"""");
                log.debug(""DataSourceResourceLoader: using columns \""""
                          + keyColumn + ""\"", \"""" + templateColumn + ""\"" and \""""
                          + timestampColumn + ""\"""");
            }
            log.trace(""DataSourceResourceLoader initialized."");
        }
        else if (dataSourceName != null)
        {
            if (log.isDebugEnabled())
            {
                log.debug(""DataSourceResourceLoader: using \"""" + dataSourceName
                          + ""\"" datasource with table \"""" + tableName + ""\"""");
                log.debug(""DataSourceResourceLoader: using columns \""""
                          + keyColumn + ""\"", \"""" + templateColumn + ""\"" and \""""
                          + timestampColumn + ""\"""");
            }
            log.trace(""DataSourceResourceLoader initialized."");
        }
        else
        {
            String msg = ""DataSourceResourceLoader not properly initialized. No DataSource was identified."";
            log.error(msg);
            throw new RuntimeException(msg);
        }
    }
    /**
     * Set the DataSource used by this resource loader.  Call this as an alternative to
     * specifying the data source name via properties.
     * @param dataSource The data source for this ResourceLoader.
     */
    public void setDataSource(final DataSource dataSource)
    {
        this.dataSource = dataSource;
    }
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#isSourceModified(org.apache.velocity.runtime.resource.Resource)
     */
    public boolean isSourceModified(final Resource resource)
    {
        return (resource.getLastModified() !=
                readLastModified(resource, ""checking timestamp""));
    }
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#getLastModified(org.apache.velocity.runtime.resource.Resource)
     */
    public long getLastModified(final Resource resource)
    {
        return readLastModified(resource, ""getting timestamp"");
    }
    /**
     * Get an InputStream so that the Runtime can build a
     * template with it.
     *
     *  @param name name of template
     *  @return InputStream containing template
     * @throws ResourceNotFoundException
     */
    public synchronized InputStream getResourceStream(final String name)
        throws ResourceNotFoundException
    {
        if (org.apache.commons.lang.StringUtils.isEmpty(name))
        {
            throw new ResourceNotFoundException(""DataSourceResourceLoader: Template name was empty or null"");
        }
        Connection conn = null;
        ResultSet rs = null;
        try
        {
            conn = openDbConnection();
            rs = readData(conn, templateColumn, name);
            if (rs.next())
            {
                InputStream stream = rs.getBinaryStream(templateColumn);
                if (stream == null)
                {
                    throw new ResourceNotFoundException(""DataSourceResourceLoader: ""
                                                        + ""template column for '""
                                                        + name + ""' is null"");
                }
                return new BufferedInputStream(stream);
            }
            else
            {
                throw new ResourceNotFoundException(""DataSourceResourceLoader: ""
                                                    + ""could not find resource '""
                                                    + name + ""'"");
            }
        }
        catch (SQLException sqle)
        {
            String msg = ""DataSourceResourceLoader: database problem while getting resource '""
                         + name + ""': "";
            log.error(msg, sqle);
            throw new ResourceNotFoundException(msg);
        }
        catch (NamingException ne)
        {
            String msg = ""DataSourceResourceLoader: database problem while getting resource '""
                         + name + ""': "";
            log.error(msg, ne);
            throw new ResourceNotFoundException(msg);
        }
        finally
        {
            closeResultSet(rs);
            closeDbConnection(conn);
        }
    }
    /**
     * Fetches the last modification time of the resource
     *
     * @param resource Resource object we are finding timestamp of
     * @param operation string for logging, indicating caller's intention
     *
     * @return timestamp as long
     */
    private long readLastModified(final Resource resource, final String operation)
    {
        long timeStamp = 0;
        /* get the template name from the resource */
        String name = resource.getName();
        if (name == null || name.length() == 0)
        {
            String msg = ""DataSourceResourceLoader: Template name was empty or null"";
            log.error(msg);
            throw new NullPointerException(msg);
        }
        else
        {
            Connection conn = null;
            ResultSet rs = null;
            try
            {
                conn = openDbConnection();
                rs = readData(conn, timestampColumn, name);
                if (rs.next())
                {
                    Timestamp ts = rs.getTimestamp(timestampColumn);
                    timeStamp = ts != null ? ts.getTime() : 0;
                }
                else
                {
                    String msg = ""DataSourceResourceLoader: could not find resource ""
                              + name + "" while "" + operation;
                    log.error(msg);
                    throw new ResourceNotFoundException(msg);
                }
            }
            catch (SQLException sqle)
            {
                String msg = ""DataSourceResourceLoader: database problem while ""
                            + operation + "" of '"" + name + ""': "";
                log.error(msg, sqle);
                throw ExceptionUtils.createRuntimeException(msg, sqle);
            }
            catch (NamingException ne)
            {
                String msg = ""DataSourceResourceLoader: database problem while ""
                             + operation + "" of '"" + name + ""': "";
                log.error(msg, ne);
                throw ExceptionUtils.createRuntimeException(msg, ne);
            }
            finally
            {
                closeResultSet(rs);
                closeDbConnection(conn);
            }
        }
        return timeStamp;
    }
    /**
     * Gets connection to the datasource specified through the configuration
     * parameters.
     *
     * @return connection
     */
    private Connection openDbConnection() throws NamingException, SQLException
    {
         if (dataSource != null)
         {
            return dataSource.getConnection();
         }
         if (ctx == null)
         {
            ctx = new InitialContext();
         }
         dataSource = (DataSource) ctx.lookup(dataSourceName);
         return dataSource.getConnection();
     }
    /**
     * Closes connection to the datasource
     */
    private void closeDbConnection(final Connection conn)
    {
        if (conn != null)
        {
            try
            {
                conn.close();
            }
            catch (RuntimeException re)
            {
                throw re;
            }
            catch (Exception e)
            {
                String msg = ""DataSourceResourceLoader: problem when closing connection"";
                log.error(msg, e);
                throw new VelocityException(msg, e);
            }
        }
    }
    /**
     * Closes the result set.
     */
    private void closeResultSet(final ResultSet rs)
    {
        if (rs != null)
        {
            try
            {
                rs.close();
            }
            catch (RuntimeException re)
            {
                throw re;
            }
            catch (Exception e)
            {
                String msg = ""DataSourceResourceLoader: problem when closing result set"";
                log.error(msg, e);
                throw new VelocityException(msg, e);
            }
        }
    }
    /**
     * Reads the data from the datasource.  It simply does the following query :
     * <br>
     *  SELECT <i>columnNames</i> FROM <i>tableName</i> WHERE <i>keyColumn</i>
     *     = '<i>templateName</i>'
     * <br>
     * where <i>keyColumn</i> is a class member set in init()
     *
     * @param conn connection to datasource
     * @param columnNames columns to fetch from datasource
     * @param templateName name of template to fetch
     * @return result set from query
     */
    private ResultSet readData(final Connection conn,
                               final String columnNames,
                               final String templateName) throws SQLException
    {
        PreparedStatement ps = conn.prepareStatement(""SELECT "" + columnNames + "" FROM ""+ tableName + "" WHERE "" + keyColumn + "" = ?"");
        ps.setString(1, templateName);
        return ps.executeQuery();
    }
}
"
org.apache.velocity.runtime.resource.loader.FileResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.io.UnicodeInputStream;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.util.StringUtils;
/**
 * A loader for templates stored on the file system.  Treats the template
 * as relative to the configured root path.  If the root path is empty
 * treats the template name as an absolute path.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @author <a href=""mailto:mailmur@yahoo.com"">Aki Nieminen</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: FileResourceLoader.java 687518 2008-08-21 00:18:03Z nbubna $
 */
public class FileResourceLoader extends ResourceLoader
{
    /**
     * The paths to search for templates.
     */
    private List paths = new ArrayList();
    /**
     * Used to map the path that a template was found on
     * so that we can properly check the modification
     * times of the files. This is synchronizedMap
     * instance.
     */
    private Map templatePaths = Collections.synchronizedMap(new HashMap());
    /** Shall we inspect unicode files to see what encoding they contain?. */
    private boolean unicode = false;
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#init(org.apache.commons.collections.ExtendedProperties)
     */
    public void init( ExtendedProperties configuration)
    {
        if (log.isTraceEnabled())
        {
            log.trace(""FileResourceLoader : initialization starting."");
        }
        paths.addAll( configuration.getVector(""path"") );
        // unicode files may have a BOM marker at the start, but Java
        // has problems recognizing the UTF-8 bom. Enabling unicode will
        // recognize all unicode boms.
        unicode = configuration.getBoolean(""unicode"", false);
        if (log.isDebugEnabled())
        {
            log.debug(""Do unicode file recognition:  "" + unicode);
        }
        if (log.isDebugEnabled())
        {
            // trim spaces from all paths
            StringUtils.trimStrings(paths);
            // this section lets tell people what paths we will be using
            int sz = paths.size();
            for( int i=0; i < sz; i++)
            {
                log.debug(""FileResourceLoader : adding path '"" + (String) paths.get(i) + ""'"");
            }
            log.trace(""FileResourceLoader : initialization complete."");
        }
    }
    /**
     * Get an InputStream so that the Runtime can build a
     * template with it.
     *
     * @param templateName name of template to get
     * @return InputStream containing the template
     * @throws ResourceNotFoundException if template not found
     *         in the file template path.
     */
    public InputStream getResourceStream(String templateName)
        throws ResourceNotFoundException
    {
        /*
         * Make sure we have a valid templateName.
         */
        if (org.apache.commons.lang.StringUtils.isEmpty(templateName))
        {
            /*
             * If we don't get a properly formed templateName then
             * there's not much we can do. So we'll forget about
             * trying to search any more paths for the template.
             */
            throw new ResourceNotFoundException(
                ""Need to specify a file name or file path!"");
        }
        String template = StringUtils.normalizePath(templateName);
        if ( template == null || template.length() == 0 )
        {
            String msg = ""File resource error : argument "" + template +
                "" contains .. and may be trying to access "" +
                ""content outside of template root.  Rejected."";
            log.error(""FileResourceLoader : "" + msg);
            throw new ResourceNotFoundException ( msg );
        }
        int size = paths.size();
        for (int i = 0; i < size; i++)
        {
            String path = (String) paths.get(i);
            InputStream inputStream = null;
            try
            {
                inputStream = findTemplate(path, template);
            }
            catch (IOException ioe)
            {
                String msg = ""Exception while loading Template "" + template;
                log.error(msg, ioe);
                throw new VelocityException(msg, ioe);
            }
            if (inputStream != null)
            {
                /*
                 * Store the path that this template came
                 * from so that we can check its modification
                 * time.
                 */
                templatePaths.put(templateName, path);
                return inputStream;
            }
        }
        /*
         * We have now searched all the paths for
         * templates and we didn't find anything so
         * throw an exception.
         */
         throw new ResourceNotFoundException(""FileResourceLoader : cannot find "" + template);
    }
    /**
     * Overrides superclass for better performance.
     * @since 1.6
     */
    public boolean resourceExists(String name)
    {
        if (name == null)
        {
            return false;
        }
        name = StringUtils.normalizePath(name);
        if (name == null || name.length() == 0)
        {
            return false;
        }
        int size = paths.size();
        for (int i = 0; i < size; i++)
        {
            String path = (String)paths.get(i);
            try
            {
                File file = getFile(path, name);
                return file.canRead();
            }
            catch (Exception ioe)
            {
                String msg = ""Exception while checking for template "" + name;
                log.debug(msg, ioe);
            }
        }
        return false;
    }
    /**
     * Try to find a template given a normalized path.
     *
     * @param path a normalized path
     * @param template name of template to find
     * @return InputStream input stream that will be parsed
     *
     */
    private InputStream findTemplate(final String path, final String template)
        throws IOException
    {
        try
        {
            File file = getFile(path,template);
            if (file.canRead())
            {
                FileInputStream fis = null;
                try
                {
                    fis = new FileInputStream(file.getAbsolutePath());
                    if (unicode)
                    {
                        UnicodeInputStream uis = null;
                        try
                        {
                            uis = new UnicodeInputStream(fis, true);
                            if (log.isDebugEnabled())
                            {
                                log.debug(""File Encoding for "" + file + "" is: "" + uis.getEncodingFromStream());
                            }
                            return new BufferedInputStream(uis);
                        }
                        catch(IOException e)
                        {
                            closeQuiet(uis);
                            throw e;
                        }
                    }
                    else
                    {
                        return new BufferedInputStream(fis);
                    }
                }
                catch (IOException e)
                {
                    closeQuiet(fis);
                    throw e;
                }
            }
            else
            {
                return null;
            }
        }
        catch(FileNotFoundException fnfe)
        {
            /*
             *  log and convert to a general Velocity ResourceNotFoundException
             */
            return null;
        }
    }
    private void closeQuiet(final InputStream is)
    {
        if (is != null)
        {
            try
            {
                is.close();
            }
            catch(IOException ioe)
            {
                // Ignore
            }
        }
    }
    /**
     * How to keep track of all the modified times
     * across the paths.  Note that a file might have
     * appeared in a directory which is earlier in the
     * path; so we should search the path and see if
     * the file we find that way is the same as the one
     * that we have cached.
     * @param resource
     * @return True if the source has been modified.
     */
    public boolean isSourceModified(Resource resource)
    {
        /*
         * we assume that the file needs to be reloaded;
         * if we find the original file and it's unchanged,
         * then we'll flip this.
         */
        boolean modified = true;
        String fileName = resource.getName();
        String path = (String) templatePaths.get(fileName);
        File currentFile = null;
        for (int i = 0; currentFile == null && i < paths.size(); i++)
        {
            String testPath = (String) paths.get(i);
            File testFile = getFile(testPath, fileName);
            if (testFile.canRead())
            {
                currentFile = testFile;
            }
        }
        File file = getFile(path, fileName);
        if (currentFile == null || !file.exists())
        {
            /*
             * noop: if the file is missing now (either the cached
             * file is gone, or the file can no longer be found)
             * then we leave modified alone (it's set to true); a
             * reload attempt will be done, which will either use
             * a new template or fail with an appropriate message
             * about how the file couldn't be found.
             */
        }
        else if (currentFile.equals(file) && file.canRead())
        {
            /*
             * if only if currentFile is the same as file and
             * file.lastModified() is the same as
             * resource.getLastModified(), then we should use the
             * cached version.
             */
            modified = (file.lastModified() != resource.getLastModified());
        }
        /*
         * rsvc.debug(""isSourceModified for "" + fileName + "": "" + modified);
         */
        return modified;
    }
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#getLastModified(org.apache.velocity.runtime.resource.Resource)
     */
    public long getLastModified(Resource resource)
    {
        String path = (String) templatePaths.get(resource.getName());
        File file = getFile(path, resource.getName());
        if (file.canRead())
        {
            return file.lastModified();
        }
        else
        {
            return 0;
        }
    }
    /**
     * Create a File based on either a relative path if given, or absolute path otherwise
     */
    private File getFile(String path, String template)
    {
        File file = null;
        if("""".equals(path))
        {
            file = new File( template );
        }
        else
        {
            /*
             *  if a / leads off, then just nip that :)
             */
            if (template.startsWith(""/""))
            {
                template = template.substring(1);
            }
            file = new File ( path, template );
        }
        return file;
    }
}
"
org.apache.velocity.runtime.resource.loader.JarHolder,"package org.apache.velocity.runtime.resource.loader;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.IOException;
import java.io.InputStream;
import java.net.JarURLConnection;
import java.net.URL;
import java.util.Enumeration;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.Hashtable;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.VelocityException;
/**
 * A small wrapper around a Jar
 *
 * @author <a href=""mailto:daveb@miceda-data.com"">Dave Bryson</a>
 * @version $Id: JarHolder.java 687177 2008-08-19 22:00:32Z nbubna $
 */
public class JarHolder
{
    private String urlpath = null;
    private JarFile theJar = null;
    private JarURLConnection conn = null;
    private Log log = null;
    /**
     * @param rs
     * @param urlpath
     */
    public JarHolder( RuntimeServices rs, String urlpath )
    {
        this.log = rs.getLog();
        this.urlpath=urlpath;
        init();
        if (log.isDebugEnabled())
        {
            log.debug(""JarHolder: initialized JAR: "" + urlpath);
        }
    }
    /**
     *
     */
    public void init()
    {
        try
        {
            if (log.isDebugEnabled())
            {
                log.debug(""JarHolder: attempting to connect to "" + urlpath);
            }
            URL url = new URL( urlpath );
            conn = (JarURLConnection) url.openConnection();
            conn.setAllowUserInteraction(false);
            conn.setDoInput(true);
            conn.setDoOutput(false);
            conn.connect();
            theJar = conn.getJarFile();
        }
        catch (IOException ioe)
        {
            String msg = ""JarHolder: error establishing connection to JAR at \""""
                         + urlpath + ""\"""";
            log.error(msg, ioe);
            throw new VelocityException(msg, ioe);
        }
    }
    /**
     *
     */
    public void close()
    {
        try
        {
            theJar.close();
        }
        catch ( Exception e )
        {
            String msg = ""JarHolder: error closing the JAR file"";
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
        theJar = null;
        conn = null;
        log.trace(""JarHolder: JAR file closed"");
    }
    /**
     * @param theentry
     * @return The requested resource.
     * @throws ResourceNotFoundException
     */
    public InputStream getResource( String theentry )
     throws ResourceNotFoundException {
        InputStream data = null;
        try
        {
            JarEntry entry = theJar.getJarEntry( theentry );
            if ( entry != null )
            {
                data =  theJar.getInputStream( entry );
            }
        }
        catch(Exception fnfe)
        {
            log.error(""JarHolder: getResource() error"", fnfe);
            throw new ResourceNotFoundException(fnfe);
        }
        return data;
    }
    /**
     * @return The entries of the jar as a hashtable.
     */
    public Hashtable getEntries()
    {
        Hashtable allEntries = new Hashtable(559);
        Enumeration all  = theJar.entries();
        while ( all.hasMoreElements() )
        {
            JarEntry je = (JarEntry)all.nextElement();
            // We don't map plain directory entries
            if ( !je.isDirectory() )
            {
                allEntries.put( je.getName(), this.urlpath );
            }
        }
        return allEntries;
    }
    /**
     * @return The URL path of this jar holder.
     */
    public String getUrlPath()
    {
        return urlpath;
    }
}
"
org.apache.velocity.runtime.resource.loader.JarResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.InputStream;
import java.util.Hashtable;
import java.util.Vector;
import java.util.Map;
import java.util.HashMap;
import org.apache.velocity.util.StringUtils;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * <p>
 * ResourceLoader to load templates from multiple Jar files.
 * </p>
 * <p>
 * The configuration of the JarResourceLoader is straightforward -
 * You simply add the JarResourceLoader to the configuration via
 * </p>
 * <p><pre>
 *    resource.loader = jar
 *    jar.resource.loader.class = org.apache.velocity.runtime.resource.loader.JarResourceLoader
 *    jar.resource.loader.path = list of JAR &lt;URL&gt;s
 * </pre></p>
 *
 * <p> So for example, if you had a jar file on your local filesystem, you could simply do
 *    <pre>
 *    jar.resource.loader.path = jar:file:/opt/myfiles/jar1.jar
 *    </pre>
 * </p>
 * <p> Note that jar specification for the <code>.path</code> configuration property
 * conforms to the same rules for the java.net.JarUrlConnection class.
 * </p>
 *
 * <p> For a working example, see the unit test case,
 *  org.apache.velocity.test.MultiLoaderTestCase class
 * </p>
 *
 * @author <a href=""mailto:mailmur@yahoo.com"">Aki Nieminen</a>
 * @author <a href=""mailto:daveb@miceda-data.com"">Dave Bryson</a>
 * @version $Id: JarResourceLoader.java 691884 2008-09-04 06:46:51Z nbubna $
 */
public class JarResourceLoader extends ResourceLoader
{
    /**
     * Maps entries to the parent JAR File
     * Key = the entry *excluding* plain directories
     * Value = the JAR URL
     */
    private Map entryDirectory = new HashMap(559);
    /**
     * Maps JAR URLs to the actual JAR
     * Key = the JAR URL
     * Value = the JAR
     */
    private Map jarfiles = new HashMap(89);
    /**
     * Called by Velocity to initialize the loader
     * @param configuration
     */
    public void init( ExtendedProperties configuration)
    {
        log.trace(""JarResourceLoader : initialization starting."");
        // rest of Velocity engine still use legacy Vector
        // and Hashtable classes. Classes are implicitly
        // synchronized even if we don't need it.
        Vector paths = configuration.getVector(""path"");
        StringUtils.trimStrings(paths);
        /*
         *  support the old version but deprecate with a log message
         */
        if( paths == null || paths.size() == 0)
        {
            paths = configuration.getVector(""resource.path"");
            StringUtils.trimStrings(paths);
            if (paths != null && paths.size() > 0)
            {
                log.debug(""JarResourceLoader : you are using a deprecated configuration""
                          + "" property for the JarResourceLoader -> '<name>.resource.loader.resource.path'.""
                          + "" Please change to the conventional '<name>.resource.loader.path'."");
            }
        }
        if (paths != null)
        {
            log.debug(""JarResourceLoader # of paths : "" + paths.size() );
            for ( int i=0; i<paths.size(); i++ )
            {
                loadJar( (String)paths.get(i) );
            }
        }
        log.trace(""JarResourceLoader : initialization complete."");
    }
    private void loadJar( String path )
    {
        if (log.isDebugEnabled())
        {
            log.debug(""JarResourceLoader : trying to load \"""" + path + ""\"""");
        }
        // Check path information
        if ( path == null )
        {
            String msg = ""JarResourceLoader : can not load JAR - JAR path is null"";
            log.error(msg);
            throw new RuntimeException(msg);
        }
        if ( !path.startsWith(""jar:"") )
        {
            String msg = ""JarResourceLoader : JAR path must start with jar: -> see java.net.JarURLConnection for information"";
            log.error(msg);
            throw new RuntimeException(msg);
        }
        if ( path.indexOf(""!/"") < 0 )
        {
            path += ""!/"";
        }
        // Close the jar if it's already open
        // this is useful for a reload
        closeJar( path );
        // Create a new JarHolder
        JarHolder temp = new JarHolder( rsvc,  path );
        // Add it's entries to the entryCollection
        addEntries( temp.getEntries() );
        // Add it to the Jar table
        jarfiles.put( temp.getUrlPath(), temp );
    }
    /**
     * Closes a Jar file and set its URLConnection
     * to null.
     */
    private void closeJar( String path )
    {
        if ( jarfiles.containsKey(path) )
        {
            JarHolder theJar = (JarHolder)jarfiles.get(path);
            theJar.close();
        }
    }
    /**
     * Copy all the entries into the entryDirectory
     * It will overwrite any duplicate keys.
     */
    private void addEntries( Hashtable entries )
    {
        entryDirectory.putAll( entries );
    }
    /**
     * Get an InputStream so that the Runtime can build a
     * template with it.
     *
     * @param source name of template to get
     * @return InputStream containing the template
     * @throws ResourceNotFoundException if template not found
     *         in the file template path.
     */
    public InputStream getResourceStream( String source )
        throws ResourceNotFoundException
    {
        InputStream results = null;
        if (org.apache.commons.lang.StringUtils.isEmpty(source))
        {
            throw new ResourceNotFoundException(""Need to have a resource!"");
        }
        String normalizedPath = StringUtils.normalizePath( source );
        if ( normalizedPath == null || normalizedPath.length() == 0 )
        {
            String msg = ""JAR resource error : argument "" + normalizedPath +
                "" contains .. and may be trying to access "" +
                ""content outside of template root.  Rejected."";
            log.error( ""JarResourceLoader : "" + msg );
            throw new ResourceNotFoundException ( msg );
        }
        /*
         *  if a / leads off, then just nip that :)
         */
        if ( normalizedPath.startsWith(""/"") )
        {
            normalizedPath = normalizedPath.substring(1);
        }
        if ( entryDirectory.containsKey( normalizedPath ) )
        {
            String jarurl  = (String)entryDirectory.get( normalizedPath );
            if ( jarfiles.containsKey( jarurl ) )
            {
                JarHolder holder = (JarHolder)jarfiles.get( jarurl );
                results =  holder.getResource( normalizedPath );
                return results;
            }
        }
        throw new ResourceNotFoundException( ""JarResourceLoader Error: cannot find resource "" +
          source );
    }
    // TODO: SHOULD BE DELEGATED TO THE JARHOLDER
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#isSourceModified(org.apache.velocity.runtime.resource.Resource)
     */
    public boolean isSourceModified(Resource resource)
    {
        return true;
    }
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#getLastModified(org.apache.velocity.runtime.resource.Resource)
     */
    public long getLastModified(Resource resource)
    {
        return 0;
    }
}
"
org.apache.velocity.runtime.resource.loader.ResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.InputStream;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.runtime.resource.ResourceCacheImpl;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.VelocityException;
import org.apache.commons.collections.ExtendedProperties;
/**
 * This is abstract class the all text resource loaders should
 * extend.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: ResourceLoader.java 687518 2008-08-21 00:18:03Z nbubna $
 */
public abstract class ResourceLoader
{
    /**
     * Does this loader want templates produced with it
     * cached in the Runtime.
     */
     protected boolean isCachingOn = false;
    /**
     * This property will be passed on to the templates
     * that are created with this loader.
     */
    protected long modificationCheckInterval = 2;
    /**
     * Class name for this loader, for logging/debuggin
     * purposes.
     */
    protected String className = null;
    protected RuntimeServices rsvc = null;
    protected Log log = null;
    /**
     * This initialization is used by all resource
     * loaders and must be called to set up common
     * properties shared by all resource loaders
     * @param rs
     * @param configuration
     */
    public void commonInit( RuntimeServices rs, ExtendedProperties configuration)
    {
        this.rsvc = rs;
        this.log = rsvc.getLog();
        /*
         *  these two properties are not required for all loaders.
         *  For example, for ClasspathLoader, what would cache mean?
         *  so adding default values which I think are the safest
         *
         *  don't cache, and modCheckInterval irrelevant...
         */
        try
        {
            isCachingOn = configuration.getBoolean(""cache"", false);
        }
        catch (Exception e)
        {
            isCachingOn = false;
            String msg = ""Exception parsing cache setting: ""+configuration.getString(""cache"");
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
        try
        {
            modificationCheckInterval = configuration.getLong(""modificationCheckInterval"", 0);
        }
        catch (Exception e)
        {
            modificationCheckInterval = 0;
            String msg = ""Exception parsing modificationCheckInterval setting: ""+configuration.getString(""modificationCheckInterval"");
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
        /*
         * this is a must!
         */
        className = ResourceCacheImpl.class.getName();
        try
        {
            className = configuration.getString(""class"", className);
        }
        catch (Exception e)
        {
            String msg = ""Exception retrieving resource cache class name"";
            log.error(msg, e);
            throw new VelocityException(msg, e);
        }
    }
    /**
     * Initialize the template loader with a
     * a resources class.
     * @param configuration
     */
    public abstract void init( ExtendedProperties configuration);
    /**
     * Get the InputStream that the Runtime will parse
     * to create a template.
     * @param source
     * @return The input stream for the requested resource.
     * @throws ResourceNotFoundException
     */
    public abstract InputStream getResourceStream( String source )
        throws ResourceNotFoundException;
    /**
     * Given a template, check to see if the source of InputStream
     * has been modified.
     * @param resource
     * @return True if the resource has been modified.
     */
    public abstract boolean isSourceModified(Resource resource);
    /**
     * Get the last modified time of the InputStream source
     * that was used to create the template. We need the template
     * here because we have to extract the name of the template
     * in order to locate the InputStream source.
     * @param resource
     * @return Time in millis when the resource has been modified.
     */
    public abstract long getLastModified(Resource resource);
    /**
     * Return the class name of this resource Loader
     * @return Class name of the resource loader.
     */
    public String getClassName()
    {
        return className;
    }
    /**
     * Set the caching state. If true, then this loader
     * would like the Runtime to cache templates that
     * have been created with InputStreams provided
     * by this loader.
     * @param value
     */
    public void setCachingOn(boolean value)
    {
        isCachingOn = value;
    }
    /**
     * The Runtime uses this to find out whether this
     * template loader wants the Runtime to cache
     * templates created with InputStreams provided
     * by this loader.
     * @return True if this resource loader caches.
     */
    public boolean isCachingOn()
    {
        return isCachingOn;
    }
    /**
     * Set the interval at which the InputStream source
     * should be checked for modifications.
     * @param modificationCheckInterval
     */
    public void setModificationCheckInterval(long modificationCheckInterval)
    {
        this.modificationCheckInterval = modificationCheckInterval;
    }
    /**
     * Get the interval at which the InputStream source
     * should be checked for modifications.
     * @return The modification check interval.
     */
    public long getModificationCheckInterval()
    {
        return modificationCheckInterval;
    }
    /**
     * Check whether any given resource exists. This is not really
     * a very efficient test and it can and should be overridden in the
     * subclasses extending ResourceLoader. 
     *
     * @param resourceName The name of a resource.
     * @return true if a resource exists and can be accessed.
     * @since 1.6
     */
    public boolean resourceExists(final String resourceName)
    {
        InputStream is = null;
        try
        {
            is = getResourceStream(resourceName);
        }
        catch (ResourceNotFoundException e)
        {
            if (log.isDebugEnabled())
            {
                log.debug(""Could not load resource '"" + resourceName 
                        + ""' from ResourceLoader "" + this.getClass().getName() 
                        + "": "", e);
            }
        }
        finally
        {
            try
            {
                if (is != null)
                {
                    is.close();
                }
            }
            catch (Exception e)
            {
                if (log.isErrorEnabled())
                {
                    String msg = ""While closing InputStream for resource '"" + resourceName
                        + ""' from ResourceLoader ""+this.getClass().getName();
                    log.error(msg, e);
                    throw new VelocityException(msg, e);
                }
            }
        }
        return (is != null);
    }
}
"
org.apache.velocity.runtime.resource.loader.ResourceLoaderFactory,"package org.apache.velocity.runtime.resource.loader;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.ClassUtils;
import org.apache.velocity.util.StringUtils;
/**
 * Factory to grab a template loader.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: ResourceLoaderFactory.java 687177 2008-08-19 22:00:32Z nbubna $
 */
public class ResourceLoaderFactory
{
    /**
     * Gets the loader specified in the configuration file.
     * @param rs
     * @param loaderClassName
     * @return TemplateLoader
     * @throws Exception
     */
    public static ResourceLoader getLoader(RuntimeServices rs, String loaderClassName)
     throws Exception
    {
        ResourceLoader loader = null;
        try
        {
            loader = (ResourceLoader) ClassUtils.getNewInstance( loaderClassName );
            rs.getLog().debug(""ResourceLoader instantiated: ""
                              + loader.getClass().getName());
            return loader;
        }
        // The ugly three strike again: ClassNotFoundException,IllegalAccessException,InstantiationException
        catch(Exception e)
        {
            String msg = ""Problem instantiating the template loader: ""+loaderClassName+"".\n"" +
                         ""Look at your properties file and make sure the\n"" +
                         ""name of the template loader is correct."";
            rs.getLog().error(msg, e);
            throw new VelocityException(msg, e);
        }
    }
}
"
org.apache.velocity.runtime.resource.loader.StringResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.commons.lang.StringUtils;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.runtime.resource.Resource;
import org.apache.velocity.runtime.resource.util.StringResource;
import org.apache.velocity.runtime.resource.util.StringResourceRepository;
import org.apache.velocity.runtime.resource.util.StringResourceRepositoryImpl;
import org.apache.velocity.util.ClassUtils;
/**
 * Resource loader that works with Strings. Users should manually add
 * resources to the repository that is used by the resource loader instance.
 *
 * Below is an example configuration for this loader.
 * Note that 'repository.class' is not necessary;
 * if not provided, the factory will fall back on using 
 * {@link StringResourceRepositoryImpl} as the default.
 * <pre>
 * resource.loader = string
 * string.resource.loader.description = Velocity StringResource loader
 * string.resource.loader.class = org.apache.velocity.runtime.resource.loader.StringResourceLoader
 * string.resource.loader.repository.class = org.apache.velocity.runtime.resource.loader.StringResourceRepositoryImpl
 * </pre>
 * Resources can be added to the repository like this:
 * <pre><code>
 *   StringResourceRepository repo = StringResourceLoader.getRepository();
 *
 *   String myTemplateName = ""/some/imaginary/path/hello.vm"";
 *   String myTemplate = ""Hi, ${username}... this is some template!"";
 *   repo.putStringResource(myTemplateName, myTemplate);
 * </code></pre>
 *
 * After this, the templates can be retrieved as usual.
 * <br>
 * <p>If there will be multiple StringResourceLoaders used in an application,
 * you should consider specifying a 'string.resource.loader.repository.name = foo'
 * property in order to keep you string resources in a non-default repository.
 * This can help to avoid conflicts between different frameworks or components
 * that are using StringResourceLoader.
 * You can then retrieve your named repository like this:
 * <pre><code>
 *   StringResourceRepository repo = StringResourceLoader.getRepository(""foo"");
 * </code></pre>
 * and add string resources to the repo just as in the previous example.
 * </p>
 * <p>If you have concerns about memory leaks or for whatever reason do not wish
 * to have your string repository stored statically as a class member, then you
 * should set 'string.resource.loader.repository.static = false' in your properties.
 * This will tell the resource loader that the string repository should be stored
 * in the Velocity application attributes.  To retrieve the repository, do:
 * <pre><code>
 *   StringResourceRepository repo = velocityEngine.getApplicationAttribute(""foo"");
 * </code></pre>
 * If you did not specify a name for the repository, then it will be stored under the
 * class name of the repository implementation class (for which the default is 
 * 'org.apache.velocity.runtime.resource.util.StringResourceRepositoryImpl'). 
 * Incidentally, this is also true for the default statically stored repository.
 * </p>
 * <p>Whether your repository is stored statically or in Velocity's application
 * attributes, you can also manually create and set it prior to Velocity
 * initialization.  For a static repository, you can do something like this:
 * <pre><code>
 *   StringResourceRepository repo = new MyStringResourceRepository();
 *   repo.magicallyAddSomeStringResources();
 *   StringResourceLoader.setRepository(""foo"", repo);
 * </code></pre>
 * Or for a non-static repository:
 * <pre><code>
 *   StringResourceRepository repo = new MyStringResourceRepository();
 *   repo.magicallyAddSomeStringResources();
 *   velocityEngine.setApplicationAttribute(""foo"", repo);
 * </code></pre>
 * Then, assuming the 'string.resource.loader.repository.name' property is
 * set to 'some.name', the StringResourceLoader will use that already created
 * repository, rather than creating a new one.
 * </p>
 *
 * @author <a href=""mailto:eelco.hillenius@openedge.nl"">Eelco Hillenius</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @author Nathan Bubna
 * @version $Id: StringResourceLoader.java 687518 2008-08-21 00:18:03Z nbubna $
 * @since 1.5
 */
public class StringResourceLoader extends ResourceLoader
{
    /**
     * Key to determine whether the repository should be set as the static one or not.
     * @since 1.6
     */
    public static final String REPOSITORY_STATIC = ""repository.static"";
    /**
     * By default, repositories are stored statically (shared across the VM).
     * @since 1.6
     */
    public static final boolean REPOSITORY_STATIC_DEFAULT = true;
    /** Key to look up the repository implementation class. */
    public static final String REPOSITORY_CLASS = ""repository.class"";
    /** The default implementation class. */
    public static final String REPOSITORY_CLASS_DEFAULT =
        StringResourceRepositoryImpl.class.getName();
    /**
     * Key to look up the name for the repository to be used.
     * @since 1.6
     */
    public static final String REPOSITORY_NAME = ""repository.name"";
    /** The default name for string resource repositories
     * ('org.apache.velocity.runtime.resource.util.StringResourceRepository').
     * @since 1.6
     */
    public static final String REPOSITORY_NAME_DEFAULT =
        StringResourceRepository.class.getName();
    /** Key to look up the repository char encoding. */
    public static final String REPOSITORY_ENCODING = ""repository.encoding"";
    /** The default repository encoding. */
    public static final String REPOSITORY_ENCODING_DEFAULT = ""UTF-8"";
    protected static final Map STATIC_REPOSITORIES =
        Collections.synchronizedMap(new HashMap());
    /**
     * Returns a reference to the default static repository.
     */
    public static StringResourceRepository getRepository()
    {
        return getRepository(REPOSITORY_NAME_DEFAULT);
    }
    /**
     * Returns a reference to the repository stored statically under the
     * specified name.
     * @since 1.6
     */
    public static StringResourceRepository getRepository(String name)
    {
        return (StringResourceRepository)STATIC_REPOSITORIES.get(name);
    }
    /**
     * Sets the specified {@link StringResourceRepository} in static storage
     * under the specified name.
     * @since 1.6
     */
    public static void setRepository(String name, StringResourceRepository repo)
    {
        STATIC_REPOSITORIES.put(name, repo);
    }
    /**
     * Removes the {@link StringResourceRepository} stored under the specified
     * name.
     * @since 1.6
     */
    public static StringResourceRepository removeRepository(String name)
    {
        return (StringResourceRepository)STATIC_REPOSITORIES.remove(name);
    }
    /**
     * Removes all statically stored {@link StringResourceRepository}s.
     * @since 1.6
     */
    public static void clearRepositories()
    {
        STATIC_REPOSITORIES.clear();
    }
    // the repository used internally by this resource loader
    protected StringResourceRepository repository;
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#init(org.apache.commons.collections.ExtendedProperties)
     */
    public void init(final ExtendedProperties configuration)
    {
        log.trace(""StringResourceLoader : initialization starting."");
        // get the repository configuration info
        String repoClass = configuration.getString(REPOSITORY_CLASS, REPOSITORY_CLASS_DEFAULT);
        String repoName = configuration.getString(REPOSITORY_NAME, REPOSITORY_NAME_DEFAULT);
        boolean isStatic = configuration.getBoolean(REPOSITORY_STATIC, REPOSITORY_STATIC_DEFAULT);
        String encoding = configuration.getString(REPOSITORY_ENCODING);
        // look for an existing repository of that name and isStatic setting
        if (isStatic)
        {
            this.repository = getRepository(repoName);
            if (repository != null && log.isDebugEnabled())
            {
                log.debug(""Loaded repository '""+repoName+""' from static repo store"");
            }
        }
        else
        {
            this.repository = (StringResourceRepository)rsvc.getApplicationAttribute(repoName);
            if (repository != null && log.isDebugEnabled())
            {
                log.debug(""Loaded repository '""+repoName+""' from application attributes"");
            }
        }
        if (this.repository == null)
        {
            // since there's no repository under the repo name, create a new one
            this.repository = createRepository(repoClass, encoding);
            // and store it according to the isStatic setting
            if (isStatic)
            {
                setRepository(repoName, this.repository);
            }
            else
            {
                rsvc.setApplicationAttribute(repoName, this.repository);
            }
        }
        else
        {
            // ok, we already have a repo
            // warn them if they are trying to change the class of the repository
            if (!this.repository.getClass().getName().equals(repoClass))
            {
                log.debug(""Cannot change class of string repository '""+repoName+
                          ""' from ""+this.repository.getClass().getName()+"" to ""+repoClass+
                          "". The change will be ignored."");
            }
            // allow them to change the default encoding of the repo
            if (encoding != null &&
                !this.repository.getEncoding().equals(encoding))
            {
                if (log.isDebugEnabled())
                {
                    log.debug(""Changing the default encoding of string repository '""+repoName+
                              ""' from ""+this.repository.getEncoding()+"" to ""+encoding);
                }
                this.repository.setEncoding(encoding);
            }
        }
        log.trace(""StringResourceLoader : initialization complete."");
    }
    /**
     * @since 1.6
     */
    public StringResourceRepository createRepository(final String className,
                                                     final String encoding)
    {
        if (log.isDebugEnabled())
        {
            log.debug(""Creating string repository using class ""+className+""..."");
        }
        StringResourceRepository repo;
        try
        {
            repo = (StringResourceRepository) ClassUtils.getNewInstance(className);
        }
        catch (ClassNotFoundException cnfe)
        {
            throw new VelocityException(""Could not find '"" + className + ""'"", cnfe);
        }
        catch (IllegalAccessException iae)
        {
            throw new VelocityException(""Could not access '"" + className + ""'"", iae);
        }
        catch (InstantiationException ie)
        {
            throw new VelocityException(""Could not instantiate '"" + className + ""'"", ie);
        }
        if (encoding != null)
        {
            repo.setEncoding(encoding);
        }
        else
        {
            repo.setEncoding(REPOSITORY_ENCODING_DEFAULT);
        }
        if (log.isDebugEnabled())
        {
            log.debug(""Default repository encoding is "" + repo.getEncoding());
        }
        return repo;
    }
    /**
     * Overrides superclass for better performance.
     * @since 1.6
     */
    public boolean resourceExists(final String name)
    {
        if (name == null)
        {
            return false;
        }
        return (this.repository.getStringResource(name) != null);
    }
    /**
     * Get an InputStream so that the Runtime can build a
     * template with it.
     *
     * @param name name of template to get.
     * @return InputStream containing the template.
     * @throws ResourceNotFoundException Ff template not found
     *         in the RepositoryFactory.
     */
    public InputStream getResourceStream(final String name)
            throws ResourceNotFoundException
    {
        if (StringUtils.isEmpty(name))
        {
            throw new ResourceNotFoundException(""No template name provided"");
        }
        StringResource resource = this.repository.getStringResource(name);
        if(resource == null)
        {
            throw new ResourceNotFoundException(""Could not locate resource '"" + name + ""'"");
        }
        byte [] byteArray = null;
        try
        {
            byteArray = resource.getBody().getBytes(resource.getEncoding());
            return new ByteArrayInputStream(byteArray);
        }
        catch(UnsupportedEncodingException ue)
        {
            throw new VelocityException(""Could not convert String using encoding "" + resource.getEncoding(), ue);
        }
    }
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#isSourceModified(org.apache.velocity.runtime.resource.Resource)
     */
    public boolean isSourceModified(final Resource resource)
    {
        StringResource original = null;
        boolean result = true;
        original = this.repository.getStringResource(resource.getName());
        if (original != null)
        {
            result =  original.getLastModified() != resource.getLastModified();
        }
        return result;
    }
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#getLastModified(org.apache.velocity.runtime.resource.Resource)
     */
    public long getLastModified(final Resource resource)
    {
        StringResource original = null;
        original = this.repository.getStringResource(resource.getName());
        return (original != null)
                ? original.getLastModified()
                : 0;
    }
}
"
org.apache.velocity.runtime.resource.loader.URLResourceLoader,"package org.apache.velocity.runtime.resource.loader;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.InputStream;
import java.io.IOException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLConnection;
import java.util.HashMap;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.commons.lang.StringUtils;
import org.apache.velocity.exception.VelocityException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.resource.Resource;
/**
 * This is a simple URL-based loader.
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:nbubna@apache.org"">Nathan Bubna</a>
 * @version $Id: URLResourceLoader.java 191743 2005-06-21 23:22:20Z dlr $
 * @since 1.5
 */
public class URLResourceLoader extends ResourceLoader
{
    private String[] roots = null;
    protected HashMap templateRoots = null;
    private int timeout = -1;
    private Method[] timeoutMethods;
    /**
     * @see org.apache.velocity.runtime.resource.loader.ResourceLoader#init(org.apache.commons.collections.ExtendedProperties)
     */
    public void init(ExtendedProperties configuration)
    {
        log.trace(""URLResourceLoader : initialization starting."");
        roots = configuration.getStringArray(""root"");
        if (log.isDebugEnabled())
        {
            for (int i=0; i < roots.length; i++)
            {
                log.debug(""URLResourceLoader : adding root '"" + roots[i] + ""'"");
            }
        }
        timeout = configuration.getInt(""timeout"", -1);
        if (timeout > 0)
        {
            try
            {
                Class[] types = new Class[] { Integer.TYPE };
                Method conn = URLConnection.class.getMethod(""setConnectTimeout"", types);
                Method read = URLConnection.class.getMethod(""setReadTimeout"", types);
                timeoutMethods = new Method[] { conn, read };
                log.debug(""URLResourceLoader : timeout set to ""+timeout);
            }
            catch (NoSuchMethodException nsme)
            {
                log.debug(""URLResourceLoader : Java 1.5+ is required to customize timeout!"", nsme);
                timeout = -1;
            }
        }
        // init the template paths map
        templateRoots = new HashMap();
        log.trace(""URLResourceLoader : initialization complete."");
    }
    /**
     * Get an InputStream so that the Runtime can build a
     * template with it.
     *
     * @param name name of template to fetch bytestream of
     * @return InputStream containing the template
     * @throws ResourceNotFoundException if template not found
     *         in the file template path.
     */
    public synchronized InputStream getResourceStream(String name)
        throws ResourceNotFoundException
    {
        if (StringUtils.isEmpty(name))
        {
            throw new ResourceNotFoundException(""URLResourceLoader : No template name provided"");
        }
        InputStream inputStream = null;
        Exception exception = null;
        for(int i=0; i < roots.length; i++)
        {
            try
            {
                URL u = new URL(roots[i] + name);
                URLConnection conn = u.openConnection();
                tryToSetTimeout(conn);
                inputStream = conn.getInputStream();
                if (inputStream != null)
                {
                    if (log.isDebugEnabled()) log.debug(""URLResourceLoader: Found '""+name+""' at '""+roots[i]+""'"");
                    // save this root for later re-use
                    templateRoots.put(name, roots[i]);
                    break;
                }
            }
            catch(IOException ioe)
            {
                if (log.isDebugEnabled()) log.debug(""URLResourceLoader: Exception when looking for '""+name+""' at '""+roots[i]+""'"", ioe);
                // only save the first one for later throwing
                if (exception == null)
                {
                    exception = ioe;
                }
            }
        }
        // if we never found the template
        if (inputStream == null)
        {
            String msg;
            if (exception == null)
            {
                msg = ""URLResourceLoader : Resource '"" + name + ""' not found."";
            }
            else
            {
                msg = exception.getMessage();
            }
            // convert to a general Velocity ResourceNotFoundException
            throw new ResourceNotFoundException(msg);
        }
        return inputStream;
    }
    /**
     * Checks to see if a resource has been deleted, moved or modified.
     *
     * @param resource Resource  The resource to check for modification
     * @return boolean  True if the resource has been modified, moved, or unreachable
     */
    public boolean isSourceModified(Resource resource)
    {
        long fileLastModified = getLastModified(resource);
        // if the file is unreachable or otherwise changed
        if (fileLastModified == 0 ||
            fileLastModified != resource.getLastModified())
        {
            return true;
        }
        return false;
    }
    /**
     * Checks to see when a resource was last modified
     *
     * @param resource Resource the resource to check
     * @return long The time when the resource was last modified or 0 if the file can't be reached
     */
    public long getLastModified(Resource resource)
    {
        // get the previously used root
        String name = resource.getName();
        String root = (String)templateRoots.get(name);
        try
        {
            // get a connection to the URL
            URL u = new URL(root + name);
            URLConnection conn = u.openConnection();
            tryToSetTimeout(conn);
            return conn.getLastModified();
        }
        catch (IOException ioe)
        {
            // the file is not reachable at its previous address
            String msg = ""URLResourceLoader: '""+name+""' is no longer reachable at '""+root+""'"";
            log.error(msg, ioe);
            throw new ResourceNotFoundException(msg, ioe);
        }
    }
    /**
     * Returns the current, custom timeout setting. If negative, there is no custom timeout.
     * @since 1.6
     */
    public int getTimeout()
    {
        return timeout;
    }
    private void tryToSetTimeout(URLConnection conn)
    {
        if (timeout > 0)
        {
            Object[] arg = new Object[] { new Integer(timeout) };
            try
            {
                timeoutMethods[0].invoke(conn, arg);
                timeoutMethods[1].invoke(conn, arg);
            }
            catch (Exception e)
            {
                String msg = ""Unexpected exception while setting connection timeout for ""+conn;
                log.error(msg, e);
                throw new VelocityException(msg, e);
            }
        }
    }
}
"
org.apache.velocity.runtime.resource.util.StringResource,"package org.apache.velocity.runtime.resource.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * Wrapper for Strings containing templates, allowing to add additional meta
 * data like timestamps.
 *
 * @author <a href=""mailto:eelco.hillenius@openedge.nl"">Eelco Hillenius</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: StringResource.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public final class StringResource
{
    /** template body */
    private String body;
    /** encoding */
    private String encoding;
    /** last modified ts */
    private long lastModified;
    /**
     * convenience constructor; sets body to 'body' and sets lastModified to now
     * @param body
     */
    public StringResource(final String body, final String encoding)
    {
        setBody(body);
        setEncoding(encoding);
    }
    /**
     * Sets the template body.
     * @return String containing the template body.
     */
    public String getBody()
    {
        return body;
    }
    /**
     * Returns the modification date of the template.
     * @return Modification date in milliseconds.
     */
    public long getLastModified()
    {
        return lastModified;
    }
    /**
     * Sets a new  value for the template body.
     * @param body New body value
     */
    public void setBody(final String body)
    {
        this.body = body;
        this.lastModified = System.currentTimeMillis();
    }
    /**
     * Changes the last modified parameter.
     * @param lastModified The modification time in millis.
     */
    public void setLastModified(final long lastModified)
    {
        this.lastModified = lastModified;
    }
    /**
     * Returns the encoding of this String resource.
     * 
     * @return The encoding of this String resource.
     */
    public String getEncoding() {
        return this.encoding;
    }
    /**
     * Sets the encoding of this string resource.
     * 
     * @param encoding The new encoding of this resource.
     */
    public void setEncoding(final String encoding)
    {
        this.encoding = encoding;
    }
}
"
org.apache.velocity.runtime.resource.util.StringResourceRepository,"package org.apache.velocity.runtime.resource.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * A StringResourceRepository functions as a central repository for Velocity templates
 * stored in Strings.
 *
 * @author <a href=""mailto:eelco.hillenius@openedge.nl"">Eelco Hillenius</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: StringResourceRepository.java 685724 2008-08-13 23:12:12Z nbubna $
 * @since 1.5
 */
public interface StringResourceRepository
{
    /**
     * get the string resource that is stored with given key
     * @param name String name to retrieve from the repository.
     * @return A StringResource containing the template.
     */
    StringResource getStringResource(String name);
    /**
     * add a string resource with given key.
     * @param name The String name to store the template under.
     * @param body A String containing a template.
     */
    void putStringResource(String name, String body);
    /**
     * add a string resource with given key.
     * @param name The String name to store the template under.
     * @param body A String containing a template.
     * @param encoding The encoding of this string template
     * @since 1.6
     */
    void putStringResource(String name, String body, String encoding);
    /**
     * delete a string resource with given key.
     * @param name The string name to remove from the repository.
     */
    void removeStringResource(String name);
    /**
     * Sets the default encoding of the repository. Encodings can also be stored per
     * template string. The default implementation does this correctly.
     * 
     * @param encoding The encoding to use.
     */
    void setEncoding(String encoding);
    /**
     * Returns the current encoding of this repository.
     * 
     * @return The current encoding of this repository.
     */
    String getEncoding();
}
"
org.apache.velocity.runtime.resource.util.StringResourceRepositoryImpl,"package org.apache.velocity.runtime.resource.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.apache.velocity.runtime.resource.loader.StringResourceLoader;
/**
 * Default implementation of StringResourceRepository.
 * Uses a HashMap for storage
 *
 * @author <a href=""mailto:eelco.hillenius@openedge.nl"">Eelco Hillenius</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: StringResourceRepositoryImpl.java 685724 2008-08-13 23:12:12Z nbubna $
 * @since 1.5
 */
public class StringResourceRepositoryImpl implements StringResourceRepository
{
    /**
     * mem store
     */
    protected Map resources = Collections.synchronizedMap(new HashMap());
    /**
     * Current Repository encoding.
     */
    private String encoding = StringResourceLoader.REPOSITORY_ENCODING_DEFAULT;
    /**
     * @see StringResourceRepository#getStringResource(java.lang.String)
     */
    public StringResource getStringResource(final String name)
    {
        return (StringResource)resources.get(name);
    }
    /**
     * @see StringResourceRepository#putStringResource(java.lang.String, java.lang.String)
     */
    public void putStringResource(final String name, final String body)
    {
        resources.put(name, new StringResource(body, getEncoding()));
    }
    /**
     * @see StringResourceRepository#putStringResource(java.lang.String, java.lang.String, java.lang.String)
     * @since 1.6
     */
    public void putStringResource(final String name, final String body, final String encoding)
    {
        resources.put(name, new StringResource(body, encoding));
    }
    /**
     * @see StringResourceRepository#removeStringResource(java.lang.String)
     */
    public void removeStringResource(final String name)
    {
        resources.remove(name);
    }
    /**
     * @see org.apache.velocity.runtime.resource.util.StringResourceRepository#getEncoding()
     */
    public String getEncoding()
    {
	    return encoding;
    }
    /**
     * @see org.apache.velocity.runtime.resource.util.StringResourceRepository#setEncoding(java.lang.String)
     */
    public void setEncoding(final String encoding)
    {
	    this.encoding = encoding;
    }
}
"
org.apache.velocity.runtime.visitor.BaseVisitor,"package org.apache.velocity.runtime.visitor;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.Writer;
import org.apache.velocity.context.InternalContextAdapter;
import org.apache.velocity.runtime.parser.node.ASTAddNode;
import org.apache.velocity.runtime.parser.node.ASTAndNode;
import org.apache.velocity.runtime.parser.node.ASTAssignment;
import org.apache.velocity.runtime.parser.node.ASTBlock;
import org.apache.velocity.runtime.parser.node.ASTComment;
import org.apache.velocity.runtime.parser.node.ASTDirective;
import org.apache.velocity.runtime.parser.node.ASTDivNode;
import org.apache.velocity.runtime.parser.node.ASTEQNode;
import org.apache.velocity.runtime.parser.node.ASTElseIfStatement;
import org.apache.velocity.runtime.parser.node.ASTElseStatement;
import org.apache.velocity.runtime.parser.node.ASTEscape;
import org.apache.velocity.runtime.parser.node.ASTEscapedDirective;
import org.apache.velocity.runtime.parser.node.ASTExpression;
import org.apache.velocity.runtime.parser.node.ASTFalse;
import org.apache.velocity.runtime.parser.node.ASTFloatingPointLiteral;
import org.apache.velocity.runtime.parser.node.ASTGENode;
import org.apache.velocity.runtime.parser.node.ASTGTNode;
import org.apache.velocity.runtime.parser.node.ASTIdentifier;
import org.apache.velocity.runtime.parser.node.ASTIfStatement;
import org.apache.velocity.runtime.parser.node.ASTIntegerLiteral;
import org.apache.velocity.runtime.parser.node.ASTIntegerRange;
import org.apache.velocity.runtime.parser.node.ASTLENode;
import org.apache.velocity.runtime.parser.node.ASTLTNode;
import org.apache.velocity.runtime.parser.node.ASTMap;
import org.apache.velocity.runtime.parser.node.ASTMethod;
import org.apache.velocity.runtime.parser.node.ASTModNode;
import org.apache.velocity.runtime.parser.node.ASTMulNode;
import org.apache.velocity.runtime.parser.node.ASTNENode;
import org.apache.velocity.runtime.parser.node.ASTNotNode;
import org.apache.velocity.runtime.parser.node.ASTObjectArray;
import org.apache.velocity.runtime.parser.node.ASTOrNode;
import org.apache.velocity.runtime.parser.node.ASTReference;
import org.apache.velocity.runtime.parser.node.ASTSetDirective;
import org.apache.velocity.runtime.parser.node.ASTStop;
import org.apache.velocity.runtime.parser.node.ASTStringLiteral;
import org.apache.velocity.runtime.parser.node.ASTSubtractNode;
import org.apache.velocity.runtime.parser.node.ASTText;
import org.apache.velocity.runtime.parser.node.ASTTrue;
import org.apache.velocity.runtime.parser.node.ASTWord;
import org.apache.velocity.runtime.parser.node.ASTprocess;
import org.apache.velocity.runtime.parser.node.ParserVisitor;
import org.apache.velocity.runtime.parser.node.SimpleNode;
/**
 * This is the base class for all visitors.
 * For each AST node, this class will provide
 * a bare-bones method for traversal.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: BaseVisitor.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public abstract class BaseVisitor implements ParserVisitor
{
    /** Context used during traversal */
    protected InternalContextAdapter context;
    /** Writer used as the output sink */
    protected Writer writer;
    /**
     * @param writer
     */
    public void setWriter( Writer writer )
    {
        this.writer = writer;
    }
    /**
     * @param context
     */
    public void setContext( InternalContextAdapter context)
    {
        this.context = context;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.SimpleNode, java.lang.Object)
     */
    public Object visit(SimpleNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTprocess, java.lang.Object)
     */
    public Object visit(ASTprocess node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTExpression, java.lang.Object)
     */
    public Object visit(ASTExpression node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTAssignment, java.lang.Object)
     */
    public Object visit(ASTAssignment node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTOrNode, java.lang.Object)
     */
    public Object visit(ASTOrNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTAndNode, java.lang.Object)
     */
    public Object visit(ASTAndNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTEQNode, java.lang.Object)
     */
    public Object visit(ASTEQNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTNENode, java.lang.Object)
     */
    public Object visit(ASTNENode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTLTNode, java.lang.Object)
     */
    public Object visit(ASTLTNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTGTNode, java.lang.Object)
     */
    public Object visit(ASTGTNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTLENode, java.lang.Object)
     */
    public Object visit(ASTLENode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTGENode, java.lang.Object)
     */
    public Object visit(ASTGENode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTAddNode, java.lang.Object)
     */
    public Object visit(ASTAddNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTSubtractNode, java.lang.Object)
     */
    public Object visit(ASTSubtractNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTMulNode, java.lang.Object)
     */
    public Object visit(ASTMulNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTDivNode, java.lang.Object)
     */
    public Object visit(ASTDivNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTModNode, java.lang.Object)
     */
    public Object visit(ASTModNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTNotNode, java.lang.Object)
     */
    public Object visit(ASTNotNode node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTIntegerLiteral, java.lang.Object)
     */
    public Object visit(ASTIntegerLiteral node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTFloatingPointLiteral, java.lang.Object)
     * @since 1.5
     */
    public Object visit(ASTFloatingPointLiteral node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTStringLiteral, java.lang.Object)
     */
    public Object visit(ASTStringLiteral node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTIdentifier, java.lang.Object)
     */
    public Object visit(ASTIdentifier node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTMethod, java.lang.Object)
     */
    public Object visit(ASTMethod node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTReference, java.lang.Object)
     */
    public Object visit(ASTReference node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTTrue, java.lang.Object)
     */
    public Object visit(ASTTrue node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTFalse, java.lang.Object)
     */
    public Object visit(ASTFalse node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTBlock, java.lang.Object)
     */
    public Object visit(ASTBlock node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTText, java.lang.Object)
     */
    public Object visit(ASTText node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTIfStatement, java.lang.Object)
     */
    public Object visit(ASTIfStatement node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTElseStatement, java.lang.Object)
     */
    public Object visit(ASTElseStatement node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTElseIfStatement, java.lang.Object)
     */
    public Object visit(ASTElseIfStatement node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTComment, java.lang.Object)
     */
    public Object visit(ASTComment node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTObjectArray, java.lang.Object)
     */
    public Object visit(ASTObjectArray node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTWord, java.lang.Object)
     */
    public Object visit(ASTWord node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTSetDirective, java.lang.Object)
     */
    public Object visit(ASTSetDirective node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTDirective, java.lang.Object)
     */
    public Object visit(ASTDirective node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTEscapedDirective, java.lang.Object)
     * @since 1.5
     */
    public Object visit(ASTEscapedDirective node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTEscape, java.lang.Object)
     * @since 1.5
     */
    public Object visit(ASTEscape node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTMap, java.lang.Object)
     * @since 1.5
     */
    public Object visit(ASTMap node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTIntegerRange, java.lang.Object)
     * @since 1.5
     */
    public Object visit(ASTIntegerRange node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.parser.node.ParserVisitor#visit(org.apache.velocity.runtime.parser.node.ASTStop, java.lang.Object)
     * @since 1.5
     */
    public Object visit(ASTStop node, Object data)
    {
        data = node.childrenAccept(this, data);
        return data;
    }
}
"
org.apache.velocity.runtime.visitor.NodeViewMode,"package org.apache.velocity.runtime.visitor;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.parser.Token;
import org.apache.velocity.runtime.parser.node.ASTAddNode;
import org.apache.velocity.runtime.parser.node.ASTAndNode;
import org.apache.velocity.runtime.parser.node.ASTAssignment;
import org.apache.velocity.runtime.parser.node.ASTBlock;
import org.apache.velocity.runtime.parser.node.ASTDirective;
import org.apache.velocity.runtime.parser.node.ASTDivNode;
import org.apache.velocity.runtime.parser.node.ASTEQNode;
import org.apache.velocity.runtime.parser.node.ASTElseIfStatement;
import org.apache.velocity.runtime.parser.node.ASTElseStatement;
import org.apache.velocity.runtime.parser.node.ASTEscape;
import org.apache.velocity.runtime.parser.node.ASTEscapedDirective;
import org.apache.velocity.runtime.parser.node.ASTExpression;
import org.apache.velocity.runtime.parser.node.ASTFalse;
import org.apache.velocity.runtime.parser.node.ASTFloatingPointLiteral;
import org.apache.velocity.runtime.parser.node.ASTGENode;
import org.apache.velocity.runtime.parser.node.ASTGTNode;
import org.apache.velocity.runtime.parser.node.ASTIdentifier;
import org.apache.velocity.runtime.parser.node.ASTIfStatement;
import org.apache.velocity.runtime.parser.node.ASTIntegerLiteral;
import org.apache.velocity.runtime.parser.node.ASTIntegerRange;
import org.apache.velocity.runtime.parser.node.ASTLENode;
import org.apache.velocity.runtime.parser.node.ASTLTNode;
import org.apache.velocity.runtime.parser.node.ASTMap;
import org.apache.velocity.runtime.parser.node.ASTMethod;
import org.apache.velocity.runtime.parser.node.ASTModNode;
import org.apache.velocity.runtime.parser.node.ASTMulNode;
import org.apache.velocity.runtime.parser.node.ASTNENode;
import org.apache.velocity.runtime.parser.node.ASTNotNode;
import org.apache.velocity.runtime.parser.node.ASTObjectArray;
import org.apache.velocity.runtime.parser.node.ASTOrNode;
import org.apache.velocity.runtime.parser.node.ASTReference;
import org.apache.velocity.runtime.parser.node.ASTSetDirective;
import org.apache.velocity.runtime.parser.node.ASTStop;
import org.apache.velocity.runtime.parser.node.ASTStringLiteral;
import org.apache.velocity.runtime.parser.node.ASTSubtractNode;
import org.apache.velocity.runtime.parser.node.ASTText;
import org.apache.velocity.runtime.parser.node.ASTTrue;
import org.apache.velocity.runtime.parser.node.ASTWord;
import org.apache.velocity.runtime.parser.node.ASTprocess;
import org.apache.velocity.runtime.parser.node.Node;
import org.apache.velocity.runtime.parser.node.SimpleNode;
/**
 * This class is simply a visitor implementation
 * that traverses the AST, produced by the Velocity
 * parsing process, and creates a visual structure
 * of the AST. This is primarily used for
 * debugging, but it useful for documentation
 * as well.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: NodeViewMode.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public class NodeViewMode extends BaseVisitor
{
    private int indent = 0;
    private boolean showTokens = true;
    /** Indent child nodes to help visually identify
      *  the structure of the AST.
      */
    private String indentString()
    {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < indent; ++i)
        {
            sb.append(""  "");
        }
        return sb.toString();
    }
    /**
      * Display the type of nodes and optionally the
      * first token.
      */
    private Object showNode(Node node, Object data)
    {
        String tokens = """";
        String special = """";
        Token t;
        if (showTokens)
        {
            t = node.getFirstToken();
            if (t.specialToken != null && ! t.specialToken.image.startsWith(""##""))
                special = t.specialToken.image;
            tokens = "" -> "" + special + t.image;
        }
        System.out.println(indentString() + node + tokens);
        ++indent;
        data = node.childrenAccept(this, data);
        --indent;
        return data;
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.SimpleNode, java.lang.Object)
     */
    public Object visit(SimpleNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTprocess, java.lang.Object)
     */
    public Object visit(ASTprocess node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTExpression, java.lang.Object)
     */
    public Object visit(ASTExpression node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTAssignment, java.lang.Object)
     */
    public Object visit(ASTAssignment node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTOrNode, java.lang.Object)
     */
    public Object visit(ASTOrNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTAndNode, java.lang.Object)
     */
    public Object visit(ASTAndNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTEQNode, java.lang.Object)
     */
    public Object visit(ASTEQNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTNENode, java.lang.Object)
     */
    public Object visit(ASTNENode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTLTNode, java.lang.Object)
     */
    public Object visit(ASTLTNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTGTNode, java.lang.Object)
     */
    public Object visit(ASTGTNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTLENode, java.lang.Object)
     */
    public Object visit(ASTLENode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTGENode, java.lang.Object)
     */
    public Object visit(ASTGENode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTAddNode, java.lang.Object)
     */
    public Object visit(ASTAddNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTSubtractNode, java.lang.Object)
     */
    public Object visit(ASTSubtractNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTMulNode, java.lang.Object)
     */
    public Object visit(ASTMulNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTDivNode, java.lang.Object)
     */
    public Object visit(ASTDivNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTModNode, java.lang.Object)
     */
    public Object visit(ASTModNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTNotNode, java.lang.Object)
     */
    public Object visit(ASTNotNode node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTFloatingPointLiteral, java.lang.Object)
     */
    public Object visit(ASTFloatingPointLiteral node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTIntegerLiteral, java.lang.Object)
     * @since 1.5
     */
    public Object visit(ASTIntegerLiteral node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTStringLiteral, java.lang.Object)
     */
    public Object visit(ASTStringLiteral node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTIdentifier, java.lang.Object)
     */
    public Object visit(ASTIdentifier node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTMethod, java.lang.Object)
     */
    public Object visit(ASTMethod node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTReference, java.lang.Object)
     */
    public Object visit(ASTReference node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTTrue, java.lang.Object)
     */
    public Object visit(ASTTrue node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTFalse, java.lang.Object)
     */
    public Object visit(ASTFalse node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTBlock, java.lang.Object)
     */
    public Object visit(ASTBlock node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTText, java.lang.Object)
     */
    public Object visit(ASTText node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTIfStatement, java.lang.Object)
     */
    public Object visit(ASTIfStatement node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTElseStatement, java.lang.Object)
     */
    public Object visit(ASTElseStatement node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTElseIfStatement, java.lang.Object)
     */
    public Object visit(ASTElseIfStatement node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTObjectArray, java.lang.Object)
     */
    public Object visit(ASTObjectArray node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTDirective, java.lang.Object)
     */
    public Object visit(ASTDirective node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTWord, java.lang.Object)
     */
    public Object visit(ASTWord node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTSetDirective, java.lang.Object)
     */
    public Object visit(ASTSetDirective node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTEscapedDirective, java.lang.Object)
     * @since 1.5
     */
    public Object visit(ASTEscapedDirective node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTEscape, java.lang.Object)
     * @since 1.5
     */
    public Object visit(ASTEscape node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTMap, java.lang.Object)
     * @since 1.5
     */
    public Object visit(ASTMap node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTIntegerRange, java.lang.Object)
     */
    public Object visit(ASTIntegerRange node, Object data)
    {
        return showNode(node,data);
    }
    /**
     * @see org.apache.velocity.runtime.visitor.BaseVisitor#visit(org.apache.velocity.runtime.parser.node.ASTStop, java.lang.Object)
     * @since 1.5
     */
    public Object visit(ASTStop node, Object data)
    {
        return showNode(node,data);
    }
}
"
org.apache.velocity.servlet.VelocityServlet,"package org.apache.velocity.servlet;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Properties;
import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.velocity.Template;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.context.Context;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.io.VelocityWriter;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeSingleton;
import org.apache.velocity.util.SimplePool;
/**
 * Base class which simplifies the use of Velocity with Servlets.
 * Extend this class, implement the <code>handleRequest()</code> method,
 * and add your data to the context.  Then call
 * <code>getTemplate(""myTemplate.wm"")</code>.
 *
 * This class puts some things into the context object that you should
 * be aware of:
 * <pre>
 * ""req"" - The HttpServletRequest object
 * ""res"" - The HttpServletResponse object
 * </pre>
 *
 * There are other methods you can override to access, alter or control
 * any part of the request processing chain.  Please see the javadocs for
 * more information on :
 * <ul>
 * <li> loadConfiguration() : for setting up the Velocity runtime
 * <li> createContext() : for creating and loading the Context
 * <li> setContentType() : for changing the content type on a request
 *                         by request basis
 * <li> handleRequest() : you <b>must</b> implement this
 * <li> mergeTemplate()  : the template rendering process
 * <li> requestCleanup() : post rendering resource or other cleanup
 * <li> error() : error handling
 * </ul>
 * <br>
 * If you put a String with key ""contentType"" object into the context within either your
 * servlet or within your template, then that will be used to override
 * the default content type specified in the properties file.
 *
 * @deprecated This servlet has been replaced by VelocityViewServlet,
 * available from the Velocity-Tools sub-project.  VelocityViewServlet
 * provides support for quick, clean MVC web development.
 * VelocityServlet will be removed in a future version of Velocity.
 *
 * @author Dave Bryson
 * @author <a href=""mailto:jon@latchkey.com"">Jon S. Stevens</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""kjohnson@transparent.com"">Kent Johnson</a>
 * @author <a href=""dlr@finemaltcoding.com"">Daniel Rall</a>
 * $Id: VelocityServlet.java 463298 2006-10-12 16:10:32Z henning $
 */
public abstract class VelocityServlet extends HttpServlet
{
    /**
     * The context key for the HTTP request object.
     */
    public static final String REQUEST = ""req"";
    /**
     * The context key for the HTTP response object.
     */
    public static final String RESPONSE = ""res"";
    /**
     * The HTTP content type context key.
     */
    public static final String CONTENT_TYPE = ""default.contentType"";
    /**
     *  The default content type for the response
     */
    public static final String DEFAULT_CONTENT_TYPE = ""text/html"";
    /**
     *  Encoding for the output stream
     */
    public static final String DEFAULT_OUTPUT_ENCODING = ""ISO-8859-1"";
    /**
     * The default content type, itself defaulting to {@link
     * #DEFAULT_CONTENT_TYPE} if not configured.
     */
    private static String defaultContentType;
    /**
     * This is the string that is looked for when getInitParameter is
     * called (<code>org.apache.velocity.properties</code>).
     */
    protected static final String INIT_PROPS_KEY =
        ""org.apache.velocity.properties"";
    /**
     * Use of this properties key has been deprecated, and will be
     * removed in Velocity version 1.5.
     */
    private static final String OLD_INIT_PROPS_KEY = ""properties"";
    /**
     * Cache of writers
     */
    private static SimplePool writerPool = new SimplePool(40);
    /**
     * Performs initialization of this servlet.  Called by the servlet
     * container on loading.
     *
     * @param config The servlet configuration to apply.
     *
     * @exception ServletException
     */
    public void init( ServletConfig config )
        throws ServletException
    {
        super.init( config );
        /*
         *  do whatever we have to do to init Velocity
         */
        initVelocity( config );
        /*
         *  Now that Velocity is initialized, cache some config.
         */
        VelocityServlet.defaultContentType =
                RuntimeSingleton.getString(CONTENT_TYPE, DEFAULT_CONTENT_TYPE);
    }
    /**
     *  Initializes the Velocity runtime, first calling
     *  loadConfiguration(ServletConvig) to get a
     *  java.util.Properties of configuration information
     *  and then calling Velocity.init().  Override this
     *  to do anything to the environment before the
     *  initialization of the singelton takes place, or to
     *  initialize the singleton in other ways.
     * @param config
     * @throws ServletException
     */
    protected void initVelocity( ServletConfig config )
         throws ServletException
    {
        try
        {
            /*
             *  call the overridable method to allow the
             *  derived classes a shot at altering the configuration
             *  before initializing Runtime
             */
            Properties props = loadConfiguration( config );
            Velocity.init( props );
        }
        catch( Exception e )
        {
            throw new ServletException(""Error initializing Velocity: "" + e, e);
        }
    }
    /**
     *  Loads the configuration information and returns that
     *  information as a Properties, which will be used to
     *  initialize the Velocity runtime.
     *  <br><br>
     *  Currently, this method gets the initialization parameter
     *  VelocityServlet.INIT_PROPS_KEY, which should be a file containing
     *  the configuration information.
     *  <br><br>
     *  To configure your Servlet Spec 2.2 compliant servlet runner to pass
     *  this to you, put the following in your WEB-INF/web.xml file
     *  <br>
     *  <pre>
     *    &lt;servlet&gt;
     *      &lt;servlet-name&gt; YourServlet &lt/servlet-name&gt;
     *      &lt;servlet-class&gt; your.package.YourServlet &lt;/servlet-class&gt;
     *      &lt;init-param&gt;
     *         &lt;param-name&gt; org.apache.velocity.properties &lt;/param-name&gt;
     *         &lt;param-value&gt; velocity.properties &lt;/param-value&gt;
     *      &lt;/init-param&gt;
     *    &lt;/servlet&gt;
     *   </pre>
     *
     * Alternately, if you wish to configure an entire context in this
     * fashion, you may use the following:
     *  <br>
     *  <pre>
     *    &lt;context-param&gt;
     *       &lt;param-name&gt; org.apache.velocity.properties &lt;/param-name&gt;
     *       &lt;param-value&gt; velocity.properties &lt;/param-value&gt;
     *       &lt;description&gt; Path to Velocity configuration &lt;/description&gt;
     *    &lt;/context-param&gt;
     *   </pre>
     *
     *  Derived classes may do the same, or take advantage of this code to do the loading for them via :
     *   <pre>
     *      Properties p = super.loadConfiguration( config );
     *   </pre>
     *  and then add or modify the configuration values from the file.
     *  <br>
     *
     *  @param config ServletConfig passed to the servlets init() function
     *                Can be used to access the real path via ServletContext (hint)
     *  @return java.util.Properties loaded with configuration values to be used
     *          to initialize the Velocity runtime.
     *  @throws FileNotFoundException if a specified file is not found.
     *  @throws IOException I/O problem accessing the specified file, if specified.
     * @deprecated Use VelocityViewServlet from the Velocity Tools
     * library instead.
     */
    protected Properties loadConfiguration(ServletConfig config)
        throws IOException, FileNotFoundException
    {
        // This is a little overly complex because of legacy support
        // for the initialization properties key ""properties"".
        // References to OLD_INIT_PROPS_KEY should be removed at
        // Velocity version 1.5.
        String propsFile = config.getInitParameter(INIT_PROPS_KEY);
        if (propsFile == null || propsFile.length() == 0)
        {
            ServletContext sc = config.getServletContext();
            propsFile = config.getInitParameter(OLD_INIT_PROPS_KEY);
            if (propsFile == null || propsFile.length() == 0)
            {
                propsFile = sc.getInitParameter(INIT_PROPS_KEY);
                if (propsFile == null || propsFile.length() == 0)
                {
                    propsFile = sc.getInitParameter(OLD_INIT_PROPS_KEY);
                    if (propsFile != null && propsFile.length() > 0)
                    {
                        sc.log(""Use of the properties initialization "" +
                               ""parameter '"" + OLD_INIT_PROPS_KEY + ""' has "" +
                               ""been deprecated by '"" + INIT_PROPS_KEY + '\'');
                    }
                }
            }
            else
            {
                sc.log(""Use of the properties initialization parameter '"" +
                       OLD_INIT_PROPS_KEY + ""' has been deprecated by '"" +
                       INIT_PROPS_KEY + '\'');
            }
        }
        /*
         * This will attempt to find the location of the properties
         * file from the relative path to the WAR archive (ie:
         * docroot). Since JServ returns null for getRealPath()
         * because it was never implemented correctly, then we know we
         * will not have an issue with using it this way. I don't know
         * if this will break other servlet engines, but it probably
         * shouldn't since WAR files are the future anyways.
         */
        Properties p = new Properties();
        if ( propsFile != null )
        {
            p.load(getServletContext().getResourceAsStream(propsFile));
        }
        return p;
    }
    /**
     * Handles HTTP <code>GET</code> requests by calling {@link
     * #doRequest(HttpServletRequest, HttpServletResponse)}.
     * @param request
     * @param response
     * @throws ServletException
     * @throws IOException
     */
    public void doGet( HttpServletRequest request, HttpServletResponse response )
        throws ServletException, IOException
    {
        doRequest(request, response);
    }
    /**
     * Handles HTTP <code>POST</code> requests by calling {@link
     * #doRequest(HttpServletRequest, HttpServletResponse)}.
     * @param request
     * @param response
     * @throws ServletException
     * @throws IOException
     */
    public void doPost( HttpServletRequest request, HttpServletResponse response )
        throws ServletException, IOException
    {
        doRequest(request, response);
    }
    /**
     *  Handles all requests (by default).
     *
     *  @param request  HttpServletRequest object containing client request
     *  @param response HttpServletResponse object for the response
     * @throws ServletException
     * @throws IOException
     */
    protected void doRequest(HttpServletRequest request, HttpServletResponse response )
         throws ServletException, IOException
    {
        Context context = null;
        try
        {
            /*
             *  first, get a context
             */
            context = createContext( request, response );
            /*
             *   set the content type
             */
            setContentType( request, response );
            /*
             *  let someone handle the request
             */
            Template template = handleRequest( request, response, context );
            /*
             *  bail if we can't find the template
             */
            if ( template == null )
            {
                return;
            }
            /*
             *  now merge it
             */
            mergeTemplate( template, context, response );
        }
        catch (Exception e)
        {
            /*
             *  call the error handler to let the derived class
             *  do something useful with this failure.
             */
            error( request, response, e);
        }
        finally
        {
            /*
             *  call cleanup routine to let a derived class do some cleanup
             */
            requestCleanup( request, response, context );
        }
    }
    /**
     *  A cleanup routine which is called at the end of the {@link
     *  #doRequest(HttpServletRequest, HttpServletResponse)}
     *  processing sequence, allowing a derived class to do resource
     *  cleanup or other end of process cycle tasks.
     *
     *  @param request servlet request from client
     *  @param response servlet reponse
     *  @param context  context created by the createContext() method
     */
    protected void requestCleanup( HttpServletRequest request, HttpServletResponse response, Context context )
    {
    }
    /**
     *  merges the template with the context.  Only override this if you really, really
     *  really need to. (And don't call us with questions if it breaks :)
     *
     *  @param template template object returned by the handleRequest() method
     *  @param context  context created by the createContext() method
     *  @param response servlet reponse (use this to get the output stream or Writer
     * @throws ResourceNotFoundException
     * @throws ParseErrorException
     * @throws MethodInvocationException
     * @throws IOException
     * @throws UnsupportedEncodingException
     * @throws Exception
     */
    protected void mergeTemplate( Template template, Context context, HttpServletResponse response )
        throws ResourceNotFoundException, ParseErrorException,
               MethodInvocationException, IOException, UnsupportedEncodingException, Exception
    {
        ServletOutputStream output = response.getOutputStream();
        VelocityWriter vw = null;
        // ASSUMPTION: response.setContentType() has been called.
        String encoding = response.getCharacterEncoding();
        try
        {
            vw = (VelocityWriter) writerPool.get();
            if (vw == null)
            {
                vw = new VelocityWriter(new OutputStreamWriter(output,
                                                               encoding),
                                        4 * 1024, true);
            }
            else
            {
                vw.recycle(new OutputStreamWriter(output, encoding));
            }
            template.merge(context, vw);
        }
        finally
        {
            if (vw != null)
            {
                try
                {
                    /*
                     *  flush and put back into the pool
                     *  don't close to allow us to play
                     *  nicely with others.
                     */
                    vw.flush();
                }
                catch (IOException e)
                {
                    // do nothing
                }
                /*
                 * Clear the VelocityWriter's reference to its
                 * internal OutputStreamWriter to allow the latter
                 * to be GC'd while vw is pooled.
                 */
                vw.recycle(null);
                writerPool.put(vw);
            }
        }
    }
    /**
     * Sets the content type of the response, defaulting to {@link
     * #defaultContentType} if not overriden.  Delegates to {@link
     * #chooseCharacterEncoding(HttpServletRequest)} to select the
     * appropriate character encoding.
     *
     * @param request The servlet request from the client.
     * @param response The servlet reponse to the client.
     */
    protected void setContentType(HttpServletRequest request,
                                  HttpServletResponse response)
    {
        String contentType = VelocityServlet.defaultContentType;
        int index = contentType.lastIndexOf(';') + 1;
        if (index <= 0 || (index < contentType.length() &&
                           contentType.indexOf(""charset"", index) == -1))
        {
            // Append the character encoding which we'd like to use.
            String encoding = chooseCharacterEncoding(request);
            //RuntimeSingleton.debug(""Chose output encoding of '"" +
            //                       encoding + '\'');
            if (!DEFAULT_OUTPUT_ENCODING.equalsIgnoreCase(encoding))
            {
                contentType += ""; charset="" + encoding;
            }
        }
        response.setContentType(contentType);
        //RuntimeSingleton.debug(""Response Content-Type set to '"" +
        //                       contentType + '\'');
    }
    /**
     * Chooses the output character encoding to be used as the value
     * for the ""charset="" portion of the HTTP Content-Type header (and
     * thus returned by <code>response.getCharacterEncoding()</code>).
     * Called by {@link #setContentType(HttpServletRequest,
     * HttpServletResponse)} if an encoding isn't already specified by
     * Content-Type.  By default, chooses the value of
     * RuntimeSingleton's <code>output.encoding</code> property.
     *
     * @param request The servlet request from the client.
     * @return The chosen character encoding.
     */
    protected String chooseCharacterEncoding(HttpServletRequest request)
    {
        return RuntimeSingleton.getString(RuntimeConstants.OUTPUT_ENCODING,
                                          DEFAULT_OUTPUT_ENCODING);
    }
    /**
     *  Returns a context suitable to pass to the handleRequest() method
     *  <br><br>
     *  Default implementation will create a VelocityContext object,
     *   put the HttpServletRequest and HttpServletResponse
     *  into the context accessable via the keys VelocityServlet.REQUEST and
     *  VelocityServlet.RESPONSE, respectively.
     *
     *  @param request servlet request from client
     *  @param response servlet reponse to client
     *
     *  @return context
     */
    protected Context createContext(HttpServletRequest request,  HttpServletResponse response )
    {
        /*
         *   create a new context
         */
        VelocityContext context = new VelocityContext();
        /*
         *   put the request/response objects into the context
         *   wrap the HttpServletRequest to solve the introspection
         *   problems
         */
        context.put( REQUEST,  request );
        context.put( RESPONSE, response );
        return context;
    }
    /**
     * Retrieves the requested template.
     *
     * @param name The file name of the template to retrieve relative to the
     *             template root.
     * @return     The requested template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     */
    public Template getTemplate( String name )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate(name);
    }
    /**
     * Retrieves the requested template with the specified
     * character encoding.
     *
     * @param name The file name of the template to retrieve relative to the
     *             template root.
     * @param encoding the character encoding of the template
     *
     * @return     The requested template.
     * @throws ResourceNotFoundException if template not found
     *          from any available source.
     * @throws ParseErrorException if template cannot be parsed due
     *          to syntax (or other) error.
     * @throws Exception if an error occurs in template initialization
     *
     *  @since Velocity v1.1
     */
    public Template getTemplate( String name, String encoding )
        throws ResourceNotFoundException, ParseErrorException, Exception
    {
        return RuntimeSingleton.getTemplate( name, encoding );
    }
    /**
     * Implement this method to add your application data to the context,
     * calling the <code>getTemplate()</code> method to produce your return
     * value.
     * <br><br>
     * In the event of a problem, you may handle the request directly
     * and return <code>null</code> or throw a more meaningful exception
     * for the error handler to catch.
     *
     *  @param request servlet request from client
     *  @param response servlet reponse
     *  @param ctx The context to add your data to.
     *  @return    The template to merge with your context or null, indicating
     *    that you handled the processing.
     * @throws Exception
     *
     *  @since Velocity v1.1
     */
    protected Template handleRequest( HttpServletRequest request, HttpServletResponse response, Context ctx )
        throws Exception
    {
        /*
         * invoke handleRequest
         */
        Template t =  handleRequest( ctx );
        /*
         *  if it returns null, this is the 'old' deprecated
         *  way, and we want to mimic the behavior for a little
         *  while anyway
         */
        if (t == null)
        {
            throw new Exception (""handleRequest(Context) returned null - no template selected!"" );
        }
        return t;
    }
    /**
     * Implement this method to add your application data to the context,
     * calling the <code>getTemplate()</code> method to produce your return
     * value.
     * <br><br>
     * In the event of a problem, you may simple return <code>null</code>
     * or throw a more meaningful exception.
     *
     * @deprecated Use
     * {@link #handleRequest( HttpServletRequest request,
     * HttpServletResponse response, Context ctx )}
     *
     * @param ctx The context to add your data to.
     * @return    The template to merge with your context.
     * @throws Exception
     */
    protected Template handleRequest( Context ctx )
        throws Exception
    {
        throw new Exception (""You must override VelocityServlet.handleRequest( Context) ""
                             + "" or VelocityServlet.handleRequest( HttpServletRequest, ""
                             + "" HttpServletResponse, Context)"" );
    }
    /**
     * Invoked when there is an error thrown in any part of doRequest() processing.
     * <br><br>
     * Default will send a simple HTML response indicating there was a problem.
     *
     * @param request original HttpServletRequest from servlet container.
     * @param response HttpServletResponse object from servlet container.
     * @param cause  Exception that was thrown by some other part of process.
     * @throws ServletException
     * @throws IOException
     */
    protected void error( HttpServletRequest request, HttpServletResponse response, Exception cause )
        throws ServletException, IOException
    {
        StringBuffer html = new StringBuffer();
        html.append(""<html>"");
        html.append(""<title>Error</title>"");
        html.append(""<body bgcolor=\""#ffffff\"">"");
        html.append(""<h2>VelocityServlet: Error processing the template</h2>"");
        html.append(""<pre>"");
        String why = cause.getMessage();
        if (why != null && why.trim().length() > 0)
        {
            html.append(why);
            html.append(""<br>"");
        }
        StringWriter sw = new StringWriter();
        cause.printStackTrace( new PrintWriter( sw ) );
        html.append( sw.toString()  );
        html.append(""</pre>"");
        html.append(""</body>"");
        html.append(""</html>"");
        response.getOutputStream().print( html.toString() );
    }
}
"
org.apache.velocity.texen.Generator,"package org.apache.velocity.texen;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.File;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.BufferedInputStream;
import java.io.Writer;
import java.io.FileWriter;
import java.io.IOException;
import java.io.StringWriter;
import java.io.OutputStreamWriter;
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Properties;
import org.apache.velocity.Template;
import org.apache.velocity.context.Context;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.util.ClassUtils;
/**
 * A text/code generator class
 *
 * @author <a href=""mailto:leon@opticode.co.za"">Leon Messerschmidt</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: Generator.java 463298 2006-10-12 16:10:32Z henning $
 */
public class Generator
{
    /**
     * Where the texen output will placed.
     */
    public static final String OUTPUT_PATH = ""output.path"";
    /**
     * Where the velocity templates live.
     */
    public static final String TEMPLATE_PATH = ""template.path"";
    /**
     * Default properties file used for controlling the
     * tools placed in the context.
     */
    private static final String DEFAULT_TEXEN_PROPERTIES =
        ""org/apache/velocity/texen/defaults/texen.properties"";
    /**
     * Default properties used by texen.
     */
    private Properties props = new Properties();
    /**
     * Context used for generating the texen output.
     */
    private Context controlContext;
    /**
     * Keep track of the file writers used for outputting
     * to files. If we come across a file writer more
     * then once then the additional output will be
     * appended to the file instead of overwritting
     * the contents.
     */
    private Hashtable writers = new Hashtable();
    /**
     * The generator tools used for creating additional
     * output withing the control template. This could
     * use some cleaning up.
     */
    private static Generator instance = new Generator();
    /**
     * This is the encoding for the output file(s).
     */
    protected String outputEncoding;
    /**
     * This is the encoding for the input file(s)
     * (templates).
     */
    protected String inputEncoding;
    /**
     * Velocity engine.
     */
    protected VelocityEngine ve;
    /**
     * Default constructor.
     */
    private Generator()
    {
        setDefaultProps();
    }
    /**
     * Create a new generator object with default properties.
     *
     * @return Generator generator used in the control context.
     */
    public static Generator getInstance()
    {
        return instance;
    }
    /**
     * Set the velocity engine.
     * @param ve
     */
    public void setVelocityEngine(VelocityEngine ve)
    {
        this.ve = ve;
    }
    /**
     * Create a new generator object with properties loaded from
     * a file.  If the file does not exist or any other exception
     * occurs during the reading operation the default properties
     * are used.
     *
     * @param propFile properties used to help populate the control context.
     */
    public Generator (String propFile)
    {
        try
        {
            BufferedInputStream bi = null;
            try
            {
                bi = new BufferedInputStream (new FileInputStream (propFile));
                props.load (bi);
            }
            finally
            {
                if (bi != null)
                {
                    bi.close();
                }
            }
        }
        catch (IOException e)
        {
            System.err.println(""Could not load "" + propFile
                    + "", falling back to defaults. (""
                    + e.getMessage() + "")"");
            /*
             * If something goes wrong we use default properties
             */
            setDefaultProps();
        }
    }
    /**
     * Create a new Generator object with a given property
     * set. The property set will be duplicated.
     *
     * @param props properties object to help populate the control context.
     */
    public Generator (Properties props)
    {
        this.props = (Properties)props.clone();
    }
    /**
     * Set default properties.
     */
    protected void setDefaultProps()
    {
        ClassLoader classLoader = VelocityEngine.class.getClassLoader();
        try
        {
            InputStream inputStream = null;
            try
            {
                inputStream = classLoader.getResourceAsStream(
                    DEFAULT_TEXEN_PROPERTIES);
                props.load( inputStream );
            }
            finally
            {
                if (inputStream != null)
                {
                    inputStream.close();
                }
            }
        }
        catch (IOException ioe)
        {
            System.err.println(""Cannot get default properties: "" + ioe.getMessage());
        }
    }
    /**
     * Set the template path, where Texen will look
     * for Velocity templates.
     *
     * @param templatePath template path for velocity templates.
     */
    public void setTemplatePath(String templatePath)
    {
        props.put(TEMPLATE_PATH, templatePath);
    }
    /**
     * Get the template path.
     *
     * @return String template path for velocity templates.
     */
    public String getTemplatePath()
    {
        return props.getProperty(TEMPLATE_PATH);
    }
    /**
     * Set the output path for the generated
     * output.
     * @param outputPath
     */
    public void setOutputPath(String outputPath)
    {
        props.put(OUTPUT_PATH, outputPath);
    }
    /**
     * Get the output path for the generated
     * output.
     *
     * @return String output path for texen output.
     */
    public String getOutputPath()
    {
        return props.getProperty(OUTPUT_PATH);
    }
    /**
     * Set the output encoding.
     * @param outputEncoding
     */
    public void setOutputEncoding(String outputEncoding)
    {
        this.outputEncoding = outputEncoding;
    }
    /**
     * Set the input (template) encoding.
     * @param inputEncoding
     */
    public void setInputEncoding(String inputEncoding)
    {
        this.inputEncoding = inputEncoding;
    }
    /**
     * Returns a writer, based on encoding and path.
     *
     * @param path      path to the output file
     * @param encoding  output encoding
     * @return A Writer for this generator.
     * @throws Exception
     */
    public Writer getWriter(String path, String encoding) throws Exception {
        Writer writer;
        if (encoding == null || encoding.length() == 0 || encoding.equals(""8859-1"") || encoding.equals(""8859_1"")) {
            writer = new FileWriter(path);
        }
        else
        {
            writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(path), encoding));
        }
        return writer;
    }
    /**
     * Returns a template, based on encoding and path.
     *
     * @param templateName  name of the template
     * @param encoding      template encoding
     * @return A Template.
     * @throws Exception
     */
    public Template getTemplate(String templateName, String encoding) throws Exception {
        Template template;
        if (encoding == null || encoding.length() == 0 || encoding.equals(""8859-1"") || encoding.equals(""8859_1"")) {
            template = ve.getTemplate(templateName);
        }
        else {
            template = ve.getTemplate(templateName, encoding);
        }
        return template;
    }
    /**
     * Parse an input and write the output to an output file.  If the
     * output file parameter is null or an empty string the result is
     * returned as a string object.  Otherwise an empty string is returned.
     *
     * @param inputTemplate input template
     * @param outputFile output file
     * @return The parsed file.
     * @throws Exception
     */
    public String parse (String inputTemplate, String outputFile)
        throws Exception
    {
        return parse(inputTemplate, outputFile, null, null);
    }
    /**
     * Parse an input and write the output to an output file.  If the
     * output file parameter is null or an empty string the result is
     * returned as a string object.  Otherwise an empty string is returned.
     * You can add objects to the context with the objs Hashtable.
     *
     * @param inputTemplate input template
     * @param outputFile output file
     * @param objectID id for object to be placed in the control context
     * @param object object to be placed in the context
     * @return String generated output from velocity
     * @throws Exception
     */
    public String parse (String inputTemplate,
                         String outputFile,
                         String objectID,
                         Object object)
        throws Exception
    {
        return parse(inputTemplate, null, outputFile, null, objectID, object);
    }
    /**
     * Parse an input and write the output to an output file.  If the
     * output file parameter is null or an empty string the result is
     * returned as a string object.  Otherwise an empty string is returned.
     * You can add objects to the context with the objs Hashtable.
     *
     * @param inputTemplate input template
     * @param inputEncoding template encoding
     * @param outputFile output file
     * @param outputEncoding outputEncoding encoding of output file
     * @param objectID id for object to be placed in the control context
     * @param object object to be placed in the context
     * @return String generated output from velocity
     * @throws Exception
     */
    public String parse (String inputTemplate,
                         String inputEncoding,
                         String outputFile,
                         String outputEncoding,
                         String objectID,
                         Object object)
        throws Exception
    {
        if (objectID != null && object != null)
        {
            controlContext.put(objectID, object);
        }
        Template template = getTemplate(inputTemplate, inputEncoding != null ? inputEncoding : this.inputEncoding);
        if (outputFile == null || outputFile.equals(""""))
        {
            StringWriter sw = new StringWriter();
            template.merge (controlContext,sw);
            return sw.toString();
        }
        else
        {
            Writer writer = null;
            if (writers.get(outputFile) == null)
            {
                /*
                 * We have never seen this file before so create
                 * a new file writer for it.
                 */
                writer = getWriter(
                            getOutputPath() + File.separator + outputFile,
                            outputEncoding != null ? outputEncoding : this.outputEncoding
                         );
                /*
                 * Place the file writer in our collection
                 * of file writers.
                 */
                writers.put(outputFile, writer);
            }
            else
            {
                writer = (Writer) writers.get(outputFile);
            }
            VelocityContext vc = new VelocityContext( controlContext );
            template.merge (vc,writer);
            // commented because it is closed in shutdown();
            //fw.close();
            return """";
        }
    }
    /**
     * Parse the control template and merge it with the control
     * context. This is the starting point in texen.
     *
     * @param controlTemplate control template
     * @param controlContext control context
     * @return String generated output
     * @throws Exception
     */
    public String parse (String controlTemplate, Context controlContext)
        throws Exception
    {
        this.controlContext = controlContext;
        fillContextDefaults(this.controlContext);
        fillContextProperties(this.controlContext);
        Template template = getTemplate(controlTemplate, inputEncoding);
        StringWriter sw = new StringWriter();
        template.merge (controlContext,sw);
        return sw.toString();
    }
    /**
     * Create a new context and fill it with the elements of the
     * objs Hashtable.  Default objects and objects that comes from
     * the properties of this Generator object is also added.
     *
     * @param objs objects to place in the control context
     * @return Context context filled with objects
     */
    protected Context getContext (Hashtable objs)
    {
        fillContextHash (controlContext,objs);
        return controlContext;
    }
    /**
     * Add all the contents of a Hashtable to the context.
     *
     * @param context context to fill with objects
     * @param objs source of objects
     */
    protected void fillContextHash (Context context, Hashtable objs)
    {
        Enumeration enumeration = objs.keys();
        while (enumeration.hasMoreElements())
        {
            String key = enumeration.nextElement().toString();
            context.put (key, objs.get(key));
        }
    }
    /**
     * Add properties that will aways be in the context by default
     *
     * @param context control context to fill with default values.
     */
    protected void fillContextDefaults (Context context)
    {
        context.put (""generator"", instance);
        context.put (""outputDirectory"", getOutputPath());
    }
    /**
     * Add objects to the context from the current properties.
     *
     * @param context control context to fill with objects
     *                that are specified in the default.properties
     *                file
     */
    protected void fillContextProperties (Context context)
    {
        Enumeration enumeration = props.propertyNames();
        while (enumeration.hasMoreElements())
        {
            String nm = (String) enumeration.nextElement();
            if (nm.startsWith (""context.objects.""))
            {
                String contextObj = props.getProperty (nm);
                int colon = nm.lastIndexOf ('.');
                String contextName = nm.substring (colon+1);
                try
                {
                    Object o = ClassUtils.getNewInstance(contextObj);
                    context.put (contextName,o);
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                    //TO DO: Log Something Here
                }
            }
        }
    }
    /**
     * Properly shut down the generator, right now
     * this is simply flushing and closing the file
     * writers that we have been holding on to.
     */
    public void shutdown()
    {
        Iterator iterator = writers.values().iterator();
        while(iterator.hasNext())
        {
            Writer writer = (Writer) iterator.next();
            try
            {
                writer.flush();
            }
            catch (IOException e)
            {
                /* do nothing */
            }
            try
            {
                writer.close();
            }
            catch (IOException e)
            {
                /* do nothing */
            }
        }
        // clear the file writers cache
        writers.clear();
    }
}
"
org.apache.velocity.texen.ant.TexenTask,"package org.apache.velocity.texen.ant;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.util.Date;
import java.util.Iterator;
import java.util.StringTokenizer;
import org.apache.commons.collections.ExtendedProperties;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.context.Context;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.texen.Generator;
import org.apache.velocity.util.StringUtils;
/**
 * An ant task for generating output by using Velocity
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""robertdonkin@mac.com"">Robert Burrell Donkin</a>
 * @version $Id: TexenTask.java 463298 2006-10-12 16:10:32Z henning $
 */
public class TexenTask
    extends Task
{
    /**
     * This message fragment (telling users to consult the log or
     * invoke ant with the -debug flag) is appended to rethrown
     * exception messages.
     */
    private final static String ERR_MSG_FRAGMENT =
        "". For more information consult the velocity log, or invoke ant "" +
        ""with the -debug flag."";
    /**
     * This is the control template that governs the output.
     * It may or may not invoke the services of worker
     * templates.
     */
    protected String controlTemplate;
    /**
     * This is where Velocity will look for templates
     * using the file template loader.
     */
    protected String templatePath;
    /**
     * This is where texen will place all the output
     * that is a product of the generation process.
     */
    protected String outputDirectory;
    /**
     * This is the file where the generated text
     * will be placed.
     */
    protected String outputFile;
    /**
     * This is the encoding for the output file(s).
     */
    protected String outputEncoding;
    /**
     * This is the encoding for the input file(s)
     * (templates).
     */
    protected String inputEncoding;
    /**
     * <p>
     * These are properties that are fed into the
     * initial context from a properties file. This
     * is simply a convenient way to set some values
     * that you wish to make available in the context.
     * </p>
     * <p>
     * These values are not critical, like the template path
     * or output path, but allow a convenient way to
     * set a value that may be specific to a particular
     * generation task.
     * </p>
     * <p>
     * For example, if you are generating scripts to allow
     * user to automatically create a database, then
     * you might want the <code>$databaseName</code>
     * to be placed
     * in the initial context so that it is available
     * in a script that might look something like the
     * following:
     * <code><pre>
     * #!bin/sh
     *
     * echo y | mysqladmin create $databaseName
     * </pre></code>
     * The value of <code>$databaseName</code> isn't critical to
     * output, and you obviously don't want to change
     * the ant task to simply take a database name.
     * So initial context values can be set with
     * properties file.
     */
    protected ExtendedProperties contextProperties;
    /**
     * Property which controls whether the classpath
     * will be used when trying to locate templates.
     */
    protected boolean useClasspath;
    /**
     * The LogFile (incl. path) to log to.
     */
    protected String logFile;
    /**
     *   Property which controls whether the resource
     *   loader will be told to cache.  Default false
     */
    protected String useResourceLoaderCache = ""false"";
    /**
     *
     */
    protected String resourceLoaderModificationCheckInterval = ""2"";
    /**
     * [REQUIRED] Set the control template for the
     * generating process.
     * @param controlTemplate
     */
    public void setControlTemplate (String controlTemplate)
    {
        this.controlTemplate = controlTemplate;
    }
    /**
     * Get the control template for the
     * generating process.
     * @return The current control template.
     */
    public String getControlTemplate()
    {
        return controlTemplate;
    }
    /**
     * [REQUIRED] Set the path where Velocity will look
     * for templates using the file template
     * loader.
     * @param templatePath
     * @throws Exception
     */
    public void setTemplatePath(String templatePath) throws Exception
    {
        StringBuffer resolvedPath = new StringBuffer();
        StringTokenizer st = new StringTokenizer(templatePath, "","");
        while ( st.hasMoreTokens() )
        {
            // resolve relative path from basedir and leave
            // absolute path untouched.
            File fullPath = project.resolveFile(st.nextToken());
            resolvedPath.append(fullPath.getCanonicalPath());
            if ( st.hasMoreTokens() )
            {
                resolvedPath.append("","");
            }
        }
        this.templatePath = resolvedPath.toString();
        System.out.println(templatePath);
     }
    /**
     * Get the path where Velocity will look
     * for templates using the file template
     * loader.
     * @return The template path.
     */
    public String getTemplatePath()
    {
        return templatePath;
    }
    /**
     * [REQUIRED] Set the output directory. It will be
     * created if it doesn't exist.
     * @param outputDirectory
     */
    public void setOutputDirectory(File outputDirectory)
    {
        try
        {
            this.outputDirectory = outputDirectory.getCanonicalPath();
        }
        catch (java.io.IOException ioe)
        {
            throw new BuildException(ioe);
        }
    }
    /**
     * Get the output directory.
     * @return The output directory.
     */
    public String getOutputDirectory()
    {
        return outputDirectory;
    }
    /**
     * [REQUIRED] Set the output file for the
     * generation process.
     * @param outputFile
     */
    public void setOutputFile(String outputFile)
    {
        this.outputFile = outputFile;
    }
    /**
     * Set the output encoding.
     * @param outputEncoding
     */
    public void setOutputEncoding(String outputEncoding)
    {
        this.outputEncoding = outputEncoding;
    }
    /**
     * Set the input (template) encoding.
     * @param inputEncoding
     */
    public void setInputEncoding(String inputEncoding)
    {
        this.inputEncoding = inputEncoding;
    }
    /**
     * Get the output file for the
     * generation process.
     * @return The output file.
     */
    public String getOutputFile()
    {
        return outputFile;
    }
    /**
     * Sets the log file.
     * @param log
     */
    public void setLogFile(String log)
    {
        this.logFile = log;
    }
    /**
     * Gets the log file.
     * @return The log file.
     */
    public String getLogFile()
    {
        return this.logFile;
    }
    /**
     * Set the context properties that will be
     * fed into the initial context be the
     * generating process starts.
     * @param file
     */
    public void setContextProperties( String file )
    {
        String[] sources = StringUtils.split(file,"","");
        contextProperties = new ExtendedProperties();
        // Always try to get the context properties resource
        // from a file first. Templates may be taken from a JAR
        // file but the context properties resource may be a
        // resource in the filesystem. If this fails than attempt
        // to get the context properties resource from the
        // classpath.
        for (int i = 0; i < sources.length; i++)
        {
            ExtendedProperties source = new ExtendedProperties();
            try
            {
                // resolve relative path from basedir and leave
                // absolute path untouched.
                File fullPath = project.resolveFile(sources[i]);
                log(""Using contextProperties file: "" + fullPath);
                source.load(new FileInputStream(fullPath));
            }
            catch (IOException e)
            {
                ClassLoader classLoader = this.getClass().getClassLoader();
                try
                {
                    InputStream inputStream = classLoader.getResourceAsStream(sources[i]);
                    if (inputStream == null)
                    {
                        throw new BuildException(""Context properties file "" + sources[i] +
                            "" could not be found in the file system or on the classpath!"");
                    }
                    else
                    {
                        source.load(inputStream);
                    }
                }
                catch (IOException ioe)
                {
                    source = null;
                }
            }
            if (source != null)
            {
                for (Iterator j = source.getKeys(); j.hasNext(); )
                {
                    String name = (String) j.next();
                    String value = StringUtils.nullTrim(source.getString(name));
                    contextProperties.setProperty(name,value);
                }
            }
        }
    }
    /**
     * Get the context properties that will be
     * fed into the initial context be the
     * generating process starts.
     * @return The current context properties.
     */
    public ExtendedProperties getContextProperties()
    {
        return contextProperties;
    }
    /**
     * Set the use of the classpath in locating templates
     *
     * @param useClasspath true means the classpath will be used.
     */
    public void setUseClasspath(boolean useClasspath)
    {
        this.useClasspath = useClasspath;
    }
    /**
     * @param useResourceLoaderCache
     */
    public void setUseResourceLoaderCache(String useResourceLoaderCache)
    {
        this.useResourceLoaderCache = useResourceLoaderCache;
    }
    /**
     * @param resourceLoaderModificationCheckInterval
     */
    public void setResourceLoaderModificationCheckInterval(String resourceLoaderModificationCheckInterval)
    {
        this.resourceLoaderModificationCheckInterval = resourceLoaderModificationCheckInterval;
    }
    /**
     * Creates a VelocityContext.
     *
     * @return new Context
     * @throws Exception the execute method will catch
     *         and rethrow as a <code>BuildException</code>
     */
    public Context initControlContext()
        throws Exception
    {
        return new VelocityContext();
    }
    /**
     * Execute the input script with Velocity
     *
     * @throws BuildException
     * BuildExceptions are thrown when required attributes are missing.
     * Exceptions thrown by Velocity are rethrown as BuildExceptions.
     */
    public void execute ()
        throws BuildException
    {
        // Make sure the template path is set.
        if (templatePath == null && useClasspath == false)
        {
            throw new BuildException(
                ""The template path needs to be defined if you are not using "" +
                ""the classpath for locating templates!"");
        }
        // Make sure the control template is set.
        if (controlTemplate == null)
        {
            throw new BuildException(""The control template needs to be defined!"");
        }
        // Make sure the output directory is set.
        if (outputDirectory == null)
        {
            throw new BuildException(""The output directory needs to be defined!"");
        }
        // Make sure there is an output file.
        if (outputFile == null)
        {
            throw new BuildException(""The output file needs to be defined!"");
        }
        VelocityEngine ve = new VelocityEngine();
        try
        {
            // Setup the Velocity Runtime.
            if (templatePath != null)
            {
                log(""Using templatePath: "" + templatePath, Project.MSG_VERBOSE);
                ve.setProperty(
                    RuntimeConstants.FILE_RESOURCE_LOADER_PATH, templatePath);
            }
            if (useClasspath)
            {
                log(""Using classpath"");
                ve.addProperty(
                    VelocityEngine.RESOURCE_LOADER, ""classpath"");
                ve.setProperty(
                    ""classpath."" + VelocityEngine.RESOURCE_LOADER + "".class"",
                        ""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
                ve.setProperty(
                    ""classpath."" + VelocityEngine.RESOURCE_LOADER +
                        "".cache"", useResourceLoaderCache);
                ve.setProperty(
                    ""classpath."" + VelocityEngine.RESOURCE_LOADER +
                        "".modificationCheckInterval"", resourceLoaderModificationCheckInterval);
            }
            if (this.logFile != null)
            {
                ve.setProperty(RuntimeConstants.RUNTIME_LOG, this.logFile);
            }
            ve.init();
            // Create the text generator.
            Generator generator = Generator.getInstance();
            generator.setVelocityEngine(ve);
            generator.setOutputPath(outputDirectory);
            generator.setInputEncoding(inputEncoding);
            generator.setOutputEncoding(outputEncoding);
            if (templatePath != null)
            {
                generator.setTemplatePath(templatePath);
            }
            // Make sure the output directory exists, if it doesn't
            // then create it.
            File file = new File(outputDirectory);
            if (! file.exists())
            {
                file.mkdirs();
            }
            String path = outputDirectory + File.separator + outputFile;
            log(""Generating to file "" + path, Project.MSG_INFO);
            Writer writer = generator.getWriter(path, outputEncoding);
            // The generator and the output path should
            // be placed in the init context here and
            // not in the generator class itself.
            Context c = initControlContext();
            // Everything in the generator class should be
            // pulled out and placed in here. What the generator
            // class does can probably be added to the Velocity
            // class and the generator class can probably
            // be removed all together.
            populateInitialContext(c);
            // Feed all the options into the initial
            // control context so they are available
            // in the control/worker templates.
            if (contextProperties != null)
            {
                Iterator i = contextProperties.getKeys();
                while (i.hasNext())
                {
                    String property = (String) i.next();
                    String value = StringUtils.nullTrim(contextProperties.getString(property));
                    // Now lets quickly check to see if what
                    // we have is numeric and try to put it
                    // into the context as an Integer.
                    try
                    {
                        c.put(property, new Integer(value));
                    }
                    catch (NumberFormatException nfe)
                    {
                        // Now we will try to place the value into
                        // the context as a boolean value if it
                        // maps to a valid boolean value.
                        String booleanString =
                            contextProperties.testBoolean(value);
                        if (booleanString != null)
                        {
                            c.put(property, Boolean.valueOf(booleanString));
                        }
                        else
                        {
                            // We are going to do something special
                            // for properties that have a ""file.contents""
                            // suffix: for these properties will pull
                            // in the contents of the file and make
                            // them available in the context. So for
                            // a line like the following in a properties file:
                            //
                            // license.file.contents = license.txt
                            //
                            // We will pull in the contents of license.txt
                            // and make it available in the context as
                            // $license. This should make texen a little
                            // more flexible.
                            if (property.endsWith(""file.contents""))
                            {
                                // We need to turn the license file from relative to
                                // absolute, and let Ant help :)
                                value = StringUtils.fileContentsToString(
                                    project.resolveFile(value).getCanonicalPath());
                                property = property.substring(
                                    0, property.indexOf(""file.contents"") - 1);
                            }
                            c.put(property, value);
                        }
                    }
                }
            }
            writer.write(generator.parse(controlTemplate, c));
            writer.flush();
            writer.close();
            generator.shutdown();
            cleanup();
        }
        catch( BuildException e)
        {
            throw e;
        }
        catch( MethodInvocationException e )
        {
            throw new BuildException(
                ""Exception thrown by '"" + e.getReferenceName() + ""."" +
                    e.getMethodName() +""'"" + ERR_MSG_FRAGMENT,
                        e.getWrappedThrowable());
        }
        catch( ParseErrorException e )
        {
            throw new BuildException(""Velocity syntax error"" + ERR_MSG_FRAGMENT ,e);
        }
        catch( ResourceNotFoundException e )
        {
            throw new BuildException(""Resource not found"" + ERR_MSG_FRAGMENT,e);
        }
        catch( Exception e )
        {
            throw new BuildException(""Generation failed"" + ERR_MSG_FRAGMENT ,e);
        }
    }
    /**
     * <p>Place useful objects into the initial context.</p>
     *
     * <p>TexenTask places <code>Date().toString()</code> into the
     * context as <code>$now</code>.  Subclasses who want to vary the
     * objects in the context should override this method.</p>
     *
     * <p><code>$generator</code> is not put into the context in this
     * method.</p>
     *
     * @param context The context to populate, as retrieved from
     * {@link #initControlContext()}.
     *
     * @throws Exception Error while populating context.  The {@link
     * #execute()} method will catch and rethrow as a
     * <code>BuildException</code>.
     */
    protected void populateInitialContext(Context context)
        throws Exception
    {
        context.put(""now"", new Date().toString());
    }
    /**
     * A hook method called at the end of {@link #execute()} which can
     * be overridden to perform any necessary cleanup activities (such
     * as the release of database connections, etc.).  By default,
     * does nothing.
     *
     * @exception Exception Problem cleaning up.
     */
    protected void cleanup()
        throws Exception
    {
    }
}
"
org.apache.velocity.texen.util.FileUtil,"package org.apache.velocity.texen.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.File;
/**
 * A general file utility for use in the context
 *
 * @author <a href=""mailto:leon@opticode.co.za"">Leon Messerschmidt</a>
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @version $Id: FileUtil.java 463298 2006-10-12 16:10:32Z henning $
 */
public class FileUtil
{
    /**
     * Creates the directory s (and any parent directories needed).
     *
     * @param s path/directory to create.
     * @return report of path/directory creation.
     */
    static public String mkdir (String s)
    {
        try
        {
            if ((new File(s)).mkdirs())
                return ""Created dir: ""+s;
            else
                return ""Failed to create dir or dir already exists: ""+s;
        }
        catch (Exception e)
        {
            return e.toString();
        }
    }
    /**
     * A method to get a File object.
     *
     * @param s path to file object to create.
     * @return File created file object.
     */
    public static File file(String s)
    {
        File f = new File(s);
        return f;
    }
    /**
     * A method to get a File object.
     *
     * @param base base path
     * @param s file name
     * @return File created file object.
     */
    public static File file(String base, String s)
    {
        File f = new File(base, s);
        return f;
    }
}
"
org.apache.velocity.texen.util.PropertiesUtil,"package org.apache.velocity.texen.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Properties;
import java.util.StringTokenizer;
import org.apache.velocity.texen.Generator;
/**
 * A property utility class for the texen text/code generator
 * Usually this class is only used from a Velocity context.
 *
 * @author <a href=""mailto:leon@opticode.co.za"">Leon Messerschmidt</a>
 * @author <a href=""mailto:sbailliez@apache.org"">Stephane Bailliez</a>
 * @version $Id: PropertiesUtil.java 510628 2007-02-22 19:07:59Z nbubna $
 */
public class PropertiesUtil
{
    /**
     * Load properties from either a file in the templatePath if there
     * is one or the classPath.
     *
     * @param propertiesFile the properties file to load through
     * either the templatePath or the classpath.
     * @return a properties instance filled with the properties found
     * in the file or an empty instance if no file was found.
     */
    public Properties load(final String propertiesFile)
    {
        Properties properties = null;
        String templatePath = Generator.getInstance().getTemplatePath();
        try
        {
            if (templatePath != null)
            {
                properties = loadFromTemplatePath(propertiesFile);
            }
            else
            {
                properties = loadFromClassPath(propertiesFile);
            }
        }
        catch (RuntimeException e)
        {
            throw e;
        }
        catch (Exception e)
        {
            throw new RuntimeException(""Could not load properties: "" + e.getMessage());
        }
        return properties;
    }
    /**
     * Load a properties file from the templatePath defined in the
     * generator. As the templatePath can contains multiple paths,
     * it will cycle through them to find the file. The first file
     * that can be successfully loaded is considered. (kind of
     * like the java classpath), it is done to clone the Velocity
     * process of loading templates.
     *
     * @param propertiesFile the properties file to load. It must be
     * a relative pathname.
     * @return a properties instance loaded with the properties from
     * the file. If no file can be found it returns an empty instance.
     * @throws Exception
     */
    protected Properties loadFromTemplatePath(final String propertiesFile)
    	throws Exception
    {
        Properties properties = new Properties();
        String templatePath = Generator.getInstance().getTemplatePath();
        // We might have something like the following:
        //
        // #set ($dbprops = $properties.load(""$generator.templatePath/path/props"")
        //
        // as we have in Torque but we want people to start using
        //
        // #set ($dbprops = $properties.load(""path/props"")
        //
        // so that everything works from the filesystem or from
        // a JAR. So the actual Generator.getTemplatePath()
        // is not deprecated but it's use in templates
        // should be.
        StringTokenizer st = new StringTokenizer(templatePath, "","");
        while (st.hasMoreTokens())
        {
            String templateDir = st.nextToken();
            InputStream stream = null;
            try
            {
                // If the properties file is being pulled from the
                // file system and someone is using the method whereby
                // the properties file is assumed to be in the template
                // path and they are simply using:
                //
                // #set ($dbprops = $properties.load(""props"") (1)
                //
                // than we have to tack on the templatePath in order
                // for the properties file to be found. We want (1)
                // to work whether the generation is being run from
                // the file system or from a JAR file.
                String fullPath = propertiesFile;
                // FIXME probably not that clever since there could be
                // a mix of file separators and the test will fail :-(
                if (!fullPath.startsWith(templateDir))
                {
                    fullPath = templateDir + ""/"" + propertiesFile;
                }
                stream = new FileInputStream(fullPath);
                properties.load(stream);
                // first pick wins, we don't need to go further since
                // we found a valid file.
                break;
            }
            finally
            {
        	if (stream != null)
        	{
        	    stream.close();
        	}
            }
        }
        return properties;
    }
    /**
     * Load a properties file from the classpath
     *
     * @param propertiesName the properties file to load.
     * @return a properties instance loaded with the properties from
     * the file. If no file can be found it returns an empty instance.
     * @throws Exception
     */
    protected Properties loadFromClassPath(final String propertiesName)
    	throws Exception
    {
        Properties properties = new Properties();
        ClassLoader classLoader = this.getClass().getClassLoader();
        InputStream inputStream = null;
        try
        {
            // This is a hack for now to make sure that properties
            // files referenced in the filesystem work in
            // a JAR file. We have to deprecate the use
            // of $generator.templatePath in templates first
            // and this hack will allow those same templates
            // that use $generator.templatePath to work in
            // JAR files.
            String propertiesFile = propertiesName.startsWith(""$generator"")
        	    ? propertiesName.substring(""$generator.templatePath/"".length())
    		    : propertiesName;
    	    inputStream = classLoader.getResourceAsStream(propertiesFile);
            properties.load(inputStream);
        }
        finally
        {
            if (inputStream != null)
            {
        	inputStream.close();
            }
        }
        return properties;
    }
}
"
org.apache.velocity.util.ArrayIterator,"package org.apache.velocity.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.lang.reflect.Array;
/**
 *  <p>
 *  An Iterator wrapper for an Object[]. This will
 *  allow us to deal with all array like structures
 *  in a consistent manner.
 *  </p>
 *  <p>
 *  WARNING : this class's operations are NOT synchronized.
 *  It is meant to be used in a single thread, newly created
 *  for each use in the #foreach() directive.
 *  If this is used or shared, synchronize in the
 *  next() method.
 *  </p>
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @version $Id: ArrayIterator.java 463298 2006-10-12 16:10:32Z henning $
 */
public class ArrayIterator implements Iterator
{
    /**
     * The objects to iterate.
     */
    private Object array;
    /**
     * The current position and size in the array.
     */
    private int pos;
    private int size;
    /**
     * Creates a new iterator instance for the specified array.
     *
     * @param array The array for which an iterator is desired.
     */
    public ArrayIterator(Object array)
    {
        /*
         * if this isn't an array, then throw.  Note that this is
         * for internal use - so this should never happen - if it does
         *  we screwed up.
         */
        if ( !array.getClass().isArray() )
        {
            throw new IllegalArgumentException(
                ""Programmer error : internal ArrayIterator invoked w/o array"");
        }
        this.array = array;
        pos = 0;
        size = Array.getLength( this.array );
    }
    /**
     * Move to next element in the array.
     *
     * @return The next object in the array.
     */
    public Object next()
    {
        if (pos < size )
            return Array.get( array, pos++);
        /*
         *  we screwed up...
         */
        throw new NoSuchElementException(""No more elements: "" + pos +
                                         "" / "" + size);
    }
    /**
     * Check to see if there is another element in the array.
     *
     * @return Whether there is another element.
     */
    public boolean hasNext()
    {
        return (pos < size );
    }
    /**
     * No op--merely added to satify the <code>Iterator</code> interface.
     */
    public void remove()
    {
        throw new UnsupportedOperationException();
    }
}
"
org.apache.velocity.util.ArrayListWrapper,"package org.apache.velocity.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.lang.reflect.Array;
import java.util.AbstractList;
/**
 * A class that wraps an array with a List interface.
 *
 * @author Chris Schultz &lt;chris@christopherschultz.net$gt;
 * @version $Revision: 685685 $ $Date: 2006-04-14 19:40:41 $
 * @since 1.6
 */
public class ArrayListWrapper extends AbstractList
{
    private Object array;
    public ArrayListWrapper(Object array)
    {
        this.array = array;
    }
    public Object get(int index)
    {
        return Array.get(array, index);
    }
    public Object set(int index, Object element)
    {
        Object old = get(index);
        Array.set(array, index, element);
        return old;
    }
    public int size()
    {
        return Array.getLength(array);
    }
}
"
org.apache.velocity.util.ClassUtils,"package org.apache.velocity.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.InputStream;
/**
 * Simple utility functions for manipulating classes and resources
 * from the classloader.
 *
 *  @author <a href=""mailto:wglass@apache.org"">Will Glass-Husain</a>
 *  @version $Id: ClassUtils.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public class ClassUtils {
    /**
     * Utility class; cannot be instantiated.
     */
    private ClassUtils()
    {
    }
    /**
     * Return the specified class.  Checks the ThreadContext classloader first,
     * then uses the System classloader.  Should replace all calls to
     * <code>Class.forName( claz )</code> (which only calls the System class
     * loader) when the class might be in a different classloader (e.g. in a
     * webapp).
     *
     * @param clazz the name of the class to instantiate
     * @return the requested Class object
     * @throws ClassNotFoundException
     */
    public static Class getClass(String clazz) throws ClassNotFoundException
    {
        /**
         * Use the Thread context classloader if possible
         */
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        if (loader != null)
        {
            try
            {
                return Class.forName(clazz, true, loader);
            }
            catch (ClassNotFoundException E)
            {
                /**
                 * If not found with ThreadContext loader, fall thru to
                 * try System classloader below (works around bug in ant).
                 */
            }
        }
        /**
         * Thread context classloader isn't working out, so use system loader.
         */
        return Class.forName(clazz);
    }
    /**
     * Return a new instance of the given class.  Checks the ThreadContext
     * classloader first, then uses the System classloader.  Should replace all
     * calls to <code>Class.forName( claz ).newInstance()</code> (which only
     * calls the System class loader) when the class might be in a different
     * classloader (e.g. in a webapp).
     *
     * @param clazz the name of the class to instantiate
     * @return an instance of the specified class
     * @throws ClassNotFoundException
     * @throws IllegalAccessException
     * @throws InstantiationException
     */
    public static Object getNewInstance(String clazz)
        throws ClassNotFoundException,IllegalAccessException,InstantiationException
    {
        return getClass(clazz).newInstance();
    }
    /**
     * Finds a resource with the given name.  Checks the Thread Context
     * classloader, then uses the System classloader.  Should replace all
     * calls to <code>Class.getResourceAsString</code> when the resource
     * might come from a different classloader.  (e.g. a webapp).
     * @param claz Class to use when getting the System classloader (used if no Thread
     * Context classloader available or fails to get resource).
     * @param name name of the resource
     * @return InputStream for the resource.
     */
    public static InputStream getResourceAsStream(Class claz, String name)
    {
        InputStream result = null;
        /**
         * remove leading slash so path will work with classes in a JAR file
         */
        while (name.startsWith(""/""))
        {
            name = name.substring(1);
        }
        ClassLoader classLoader = Thread.currentThread()
                                    .getContextClassLoader();
        if (classLoader == null)
        {
            classLoader = claz.getClassLoader();
            result = classLoader.getResourceAsStream( name );
        }
        else
        {
            result= classLoader.getResourceAsStream( name );
            /**
            * for compatibility with texen / ant tasks, fall back to
            * old method when resource is not found.
            */
            if (result == null)
            {
                classLoader = claz.getClassLoader();
                if (classLoader != null)
                    result = classLoader.getResourceAsStream( name );
            }
        }
        return result;
    }
}
"
org.apache.velocity.util.ContextAware,"package org.apache.velocity.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.context.Context;
/**
 * Event handlers implementing this interface will automatically
 * have the method setContext called before each event.  This
 * allows the event handler to use information in the latest context
 * when responding to the event.
 *
 * <P>Important Note: Only local event handlers attached to the context
 * (as opposed to global event handlers initialized in the velocity.properties
 * file) should implement ContextAware.  Since global event handlers are
 * singletons individual requests will not be able to count on the
 * correct context being loaded before a request.
 *
 * @author <a href=""mailto:wglass@wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: ContextAware.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public interface  ContextAware
{
    /**
     * Initialize the EventHandler.
     * @param context
     */
    public void setContext( Context context );
}
"
org.apache.velocity.util.EnumerationIterator,"package org.apache.velocity.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Iterator;
import java.util.Enumeration;
/**
 * An Iterator wrapper for an Enumeration.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: EnumerationIterator.java 463298 2006-10-12 16:10:32Z henning $
 */
public class EnumerationIterator implements Iterator
{
    /**
     * The enumeration to iterate.
     */
    private Enumeration enumeration = null;
    /**
     * Creates a new iteratorwrapper instance for the specified
     * Enumeration.
     *
     * @param enumeration  The Enumeration to wrap.
     */
    public EnumerationIterator(Enumeration enumeration)
    {
        this.enumeration = enumeration;
    }
    /**
     * Move to next element in the array.
     *
     * @return The next object in the array.
     */
    public Object next()
    {
        return enumeration.nextElement();
    }
    /**
     * Check to see if there is another element in the array.
     *
     * @return Whether there is another element.
     */
    public boolean hasNext()
    {
        return enumeration.hasMoreElements();
    }
    /**
     *  Unimplemented.  No analogy in Enumeration
     */
    public void remove()
    {
        // not implemented
    }
}
"
org.apache.velocity.util.ExceptionUtils,"package org.apache.velocity.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
/**
 * Use this to create a new Exception.  This will run under JDK 1.3 or greater.
 * However, it running under JDK 1.4 it will set the cause.
 *
 * @author <a href=""mailto:isidore@setgame.com"">Llewellyn Falco</a>
 * @since 1.5
 */
public class ExceptionUtils
{
    private static boolean causesAllowed = true;
    /**
     * Create a new RuntimeException, setting the cause if possible.
     * @param message
     * @param cause
     * @return A runtime exception object.
     */
    public static RuntimeException createRuntimeException(
            String message, Throwable cause)
    {
        return (RuntimeException) createWithCause(
                RuntimeException.class, message, cause);
    }
    /**
     * Create a new Exception, setting the cause if possible.
     * @param clazz
     * @param message
     * @param cause
     * @return A Throwable.
     */
    public static Throwable createWithCause(Class clazz,
            String message, Throwable cause)
    {
        Throwable re = null;
        if (causesAllowed)
        {
            try
            {
                Constructor constructor = clazz
                        .getConstructor(new Class[]{String.class,
                                Throwable.class});
                re = (Throwable) constructor
                        .newInstance(new Object[]{message, cause});
            }
            catch (RuntimeException e)
            {
                throw e;
            }
            catch (Exception e)
            {
                causesAllowed = false;
            }
        }
        if (re == null)
        {
            try
            {
                Constructor constructor = clazz
                        .getConstructor(new Class[]{String.class});
                re = (Throwable) constructor
                        .newInstance(new Object[]{message
                                + "" caused by "" + cause});
            }
            catch (RuntimeException e)
            {
                throw e;
            }
            catch (Exception e)
            {
                throw new RuntimeException(""Error caused "" + e); // should be impossible
            }
        }
        return re;
    }
    /**
     * Set the cause of the Exception.  Will detect if this is not allowed.
     * @param onObject
     * @param cause
     */
    public static void setCause(Throwable onObject, Throwable cause)
    {
        if (causesAllowed)
        {
            try
            {
                Method method = onObject.getClass().getMethod(""initCause"", new Class[]{Throwable.class});
                method.invoke(onObject, new Object[]{cause});
            }
            catch (RuntimeException e)
            {
                throw e;
            }
            catch (Exception e)
            {
                causesAllowed = false;
            }
        }
    }
}
"
org.apache.velocity.util.MapFactory,"package org.apache.velocity.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.Constructor;
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
/**
 * Factory class for creating Maps.
 * 
 * The main purpose of this class is to take advantage of Java 5
 * Concurrent classes if they are available. We use reflection to instantiate
 * java.util.concurrent classes to avoid compile time dependency on Java 5.
 * 
 * See <a href=""http://issues.apache.org/jira/browse/VELOCITY-607"">Issue 607</a>
 * for more info on this class.
 * @author <a href=""mailto:wyla@sci.fi"">Jarkko Viinamaki</a>
 * @since 1.6
 */
public class MapFactory
{
    private static Constructor concurrentHashMapConstructor;
    static
    {
        try
        {
            concurrentHashMapConstructor =
                Class.forName(""java.util.concurrent.ConcurrentHashMap"")
                     .getConstructor(new Class[] { int.class, float.class, int.class } );
        }
        catch (Exception ex)
        {
            // not running under JRE 1.5+
        }
    }
    /**
     * Creates a new instance of a class that implements Map interface.
     * 
     * Note that there is a small performance penalty because concurrent
     * maps are created using reflection.
     * 
     * @param size initial size of the map
     * @param loadFactor smaller value = better performance, 
     *          larger value = better memory utilization
     * @param concurrencyLevel estimated number of writer Threads. 
     *          If this is smaller than 1, HashMap is always returned which is not 
     *          threadsafe.
     * @param allowNullKeys if true, the returned Map instance supports null keys         
     *          
     * @return one of ConcurrentHashMap, HashMap, Hashtable
     */
    public static Map create(int size, float loadFactor,
                             int concurrencyLevel, boolean allowNullKeys)
    {
        Map map = null;
        if (concurrencyLevel <= 1)
        {
            map = new HashMap(size, loadFactor);
        }
        else
        {
            if (concurrentHashMapConstructor != null)
            {
                // running under JRE 1.5+
                try
                {
                    map = (Map)concurrentHashMapConstructor.newInstance(
                        new Object[] { new Integer(size), new Float(loadFactor), new Integer(concurrencyLevel) });
                }
                catch (Exception ex)
                {
                    throw new RuntimeException(""this should not happen"", ex);
                }
            }
            else
            {
                /*
                 * Hashtable should be faster than
                 * Collections.synchronizedMap(new HashMap());
                 * so favor it if there is no need for null key support
                 */
                if (allowNullKeys)
                {
                    map = Collections.synchronizedMap(new HashMap(size, loadFactor));
                }
                else
                {
                    map = new Hashtable(size, loadFactor);
                }
            }
        }
        return map;
    }
}
"
org.apache.velocity.util.RuntimeServicesAware,"package org.apache.velocity.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.RuntimeServices;
/**
 * Use this interface to automatically
 * have the method setRuntimeServices called at initialization.  
 * Applies to EventHandler and Uberspect implementations.
 *
 * @author <a href=""mailto:wglass@wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: RuntimeServicesAware.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public interface  RuntimeServicesAware
{
    /**
     * Called automatically when event cartridge is initialized.
     * @param rs RuntimeServices object assigned during initialization
     */
    public void setRuntimeServices( RuntimeServices rs );
}
"
org.apache.velocity.util.SimplePool,"package org.apache.velocity.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * Simple object pool. Based on ThreadPool and few other classes
 *
 * The pool will ignore overflow and return null if empty.
 *
 * @author Gal Shachor
 * @author Costin
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: SimplePool.java 463298 2006-10-12 16:10:32Z henning $
 */
public final class SimplePool
{
    /*
     * Where the objects are held.
     */
    private Object pool[];
    /**
     *  max amount of objects to be managed
     *  set via CTOR
     */
    private int max;
    /**
     *  index of previous to next
     *  free slot
     */
    private int current=-1;
    /**
     * @param max
     */
    public SimplePool(int max)
    {
        this.max = max;
        pool = new Object[max];
    }
    /**
     * Add the object to the pool, silent nothing if the pool is full
     * @param o
     */
    public void put(Object o)
    {
        int idx=-1;
        synchronized(this)
        {
            /*
             *  if we aren't full
             */
            if (current < max - 1)
            {
                /*
                 *  then increment the
                 *  current index.
                 */
                idx = ++current;
            }
            if (idx >= 0)
            {
                pool[idx] = o;
            }
        }
    }
    /**
     * Get an object from the pool, null if the pool is empty.
     * @return The object from the pool.
     */
    public Object get()
    {
        synchronized(this)
        {
            /*
             *  if we have any in the pool
             */
            if( current >= 0 )
            {
                /*
                 *  remove the current one
                 */
                Object o = pool[current];
                pool[current] = null;
                current--;
                return o;
            }
        }
        return null;
    }
    /**
     * Return the size of the pool
     * @return The pool size.
     */
    public int getMax()
    {
        return max;
    }
    /**
     *   for testing purposes, so we can examine the pool
     *
     * @return Array of Objects in the pool.
     */
    Object[] getPool()
    {
        return pool;
    }
}
"
org.apache.velocity.util.StringUtils,"package org.apache.velocity.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
/**
 * This class provides some methods for dynamically
 * invoking methods in objects, and some string
 * manipulation methods used by torque. The string
 * methods will soon be moved into the turbine
 * string utilities class.
 *
 *  @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 *  @author <a href=""mailto:dlr@finemaltcoding.com"">Daniel Rall</a>
 *  @version $Id: StringUtils.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public class StringUtils
{
    /**
     * Line separator for the OS we are operating on.
     */
    private static final String EOL = System.getProperty(""line.separator"");
    /**
     * Concatenates a list of objects as a String.
     *
     * @param list The list of objects to concatenate.
     * @return     A text representation of the concatenated objects.
     */
    public String concat(List list)
    {
        StringBuffer sb = new StringBuffer();
        int size = list.size();
        for (int i = 0; i < size; i++)
        {
            sb.append(list.get(i).toString());
        }
        return sb.toString();
    }
    /**
     * Return a package name as a relative path name
     *
     * @param pckge package name to convert to a directory.
     * @return String directory path.
     */
    static public String getPackageAsPath(String pckge)
    {
        return pckge.replace( '.', File.separator.charAt(0) ) + File.separator;
    }
    /**
     * <p>
     * Remove underscores from a string and replaces first
     * letters with capitals.  Other letters are changed to lower case.
     * </p>
     *
     * <p>
     * For example <code>foo_bar</code> becomes <code>FooBar</code>
     * but <code>foo_barBar</code> becomes <code>FooBarbar</code>.
     * </p>
     *
     * @param data string to remove underscores from.
     * @return String
     * @deprecated Use the org.apache.commons.util.StringUtils class
     * instead.  Using its firstLetterCaps() method in conjunction
     * with a StringTokenizer will achieve the same result.
     */
    static public String removeUnderScores (String data)
    {
        String temp = null;
        StringBuffer out = new StringBuffer();
        temp = data;
        StringTokenizer st = new StringTokenizer(temp, ""_"");
        while (st.hasMoreTokens())
        {
            String element = (String) st.nextElement();
            out.append ( firstLetterCaps(element));
        }
        return out.toString();
    }
    /**
     * <p>
     *  'Camels Hump' replacement of underscores.
     * </p>
     *
     * <p>
     * Remove underscores from a string but leave the capitalization of the
     * other letters unchanged.
     * </p>
     *
     * <p>
     * For example <code>foo_barBar</code> becomes <code>FooBarBar</code>.
     * </p>
     *
     * @param data string to hump
     * @return String
     */
    static public String removeAndHump (String data)
    {
        return removeAndHump(data,""_"");
    }
    /**
     * <p>
     * 'Camels Hump' replacement.
     * </p>
     *
     * <p>
     * Remove one string from another string but leave the capitalization of the
     * other letters unchanged.
     * </p>
     *
     * <p>
     * For example, removing ""_"" from <code>foo_barBar</code> becomes <code>FooBarBar</code>.
     * </p>
     *
     * @param data string to hump
     * @param replaceThis string to be replaced
     * @return String
     */
    static public String removeAndHump (String data,String replaceThis)
    {
        String temp = null;
        StringBuffer out = new StringBuffer();
        temp = data;
        StringTokenizer st = new StringTokenizer(temp, replaceThis);
        while (st.hasMoreTokens())
        {
            String element = (String) st.nextElement();
            out.append ( capitalizeFirstLetter(element));
        }//while
        return out.toString();
    }
    /**
     * <p>
     *  Makes the first letter caps and the rest lowercase.
     * </p>
     *
     * <p>
     *  For example <code>fooBar</code> becomes <code>Foobar</code>.
     * </p>
     *
     * @param data capitalize this
     * @return String
     */
    static public String firstLetterCaps ( String data )
    {
        String firstLetter = data.substring(0,1).toUpperCase();
        String restLetters = data.substring(1).toLowerCase();
        return firstLetter + restLetters;
    }
    /**
     * <p>
     * Capitalize the first letter but leave the rest as they are.
     * </p>
     *
     * <p>
     *  For example <code>fooBar</code> becomes <code>FooBar</code>.
     * </p>
     *
     * @param data capitalize this
     * @return String
     */
    static public String capitalizeFirstLetter ( String data )
    {
        String firstLetter = data.substring(0,1).toUpperCase();
        String restLetters = data.substring(1);
        return firstLetter + restLetters;
    }
    /**
     * Create a string array from a string separated by delim
     *
     * @param line the line to split
     * @param delim the delimter to split by
     * @return a string array of the split fields
     */
    public static String [] split(String line, String delim)
    {
        List list = new ArrayList();
        StringTokenizer t = new StringTokenizer(line, delim);
        while (t.hasMoreTokens())
        {
            list.add(t.nextToken());
        }
        return (String []) list.toArray(new String[list.size()]);
    }
    /**
     * Chop i characters off the end of a string.
     * This method assumes that any EOL characters in String s
     * and the platform EOL will be the same.
     * A 2 character EOL will count as 1 character.
     *
     * @param s String to chop.
     * @param i Number of characters to chop.
     * @return String with processed answer.
     */
    public static String chop(String s, int i)
    {
        return chop(s, i, EOL);
    }
    /**
     * Chop i characters off the end of a string.
     * A 2 character EOL will count as 1 character.
     *
     * @param s String to chop.
     * @param i Number of characters to chop.
     * @param eol A String representing the EOL (end of line).
     * @return String with processed answer.
     */
    public static String chop(String s, int i, String eol)
    {
        if ( i == 0 || s == null || eol == null )
        {
           return s;
        }
        int length = s.length();
        /*
         * if it is a 2 char EOL and the string ends with
         * it, nip it off.  The EOL in this case is treated like 1 character
         */
        if ( eol.length() == 2 && s.endsWith(eol ))
        {
            length -= 2;
            i -= 1;
        }
        if ( i > 0)
        {
            length -= i;
        }
        if ( length < 0)
        {
            length = 0;
        }
        return s.substring( 0, length);
    }
    /**
     * @param argStr
     * @param vars
     * @return Substituted String.
     */
    public static StringBuffer stringSubstitution( String argStr,
                                                   Hashtable vars )
    {
        return stringSubstitution( argStr, (Map) vars );
    }
    /**
     * Perform a series of substitutions. The substitions
     * are performed by replacing $variable in the target
     * string with the value of provided by the key ""variable""
     * in the provided hashtable.
     *
     * @param argStr target string
     * @param vars name/value pairs used for substitution
     * @return String target string with replacements.
     */
    public static StringBuffer stringSubstitution(String argStr,
            Map vars)
    {
        StringBuffer argBuf = new StringBuffer();
        for (int cIdx = 0 ; cIdx < argStr.length();)
        {
            char ch = argStr.charAt(cIdx);
            switch (ch)
            {
                case '$':
                    StringBuffer nameBuf = new StringBuffer();
                    for (++cIdx ; cIdx < argStr.length(); ++cIdx)
                    {
                        ch = argStr.charAt(cIdx);
                        if (ch == '_' || Character.isLetterOrDigit(ch))
                            nameBuf.append(ch);
                        else
                            break;
                    }
                    if (nameBuf.length() > 0)
                    {
                        String value =
                                (String) vars.get(nameBuf.toString());
                        if (value != null)
                        {
                            argBuf.append(value);
                        }
                    }
                    break;
                default:
                    argBuf.append(ch);
                    ++cIdx;
                    break;
            }
        }
        return argBuf;
    }
    /**
     * Read the contents of a file and place them in
     * a string object.
     *
     * @param file path to file.
     * @return String contents of the file.
     */
    public static String fileContentsToString(String file)
    {
        String contents = """";
        File f = null;
        try
        {
            f = new File(file);
            if (f.exists())
            {
                FileReader fr = null;
                try
                {
                    fr = new FileReader(f);
                    char[] template = new char[(int) f.length()];
                    fr.read(template);
                    contents = new String(template);
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
                finally
                {
                    if (fr != null)
                    {
                        fr.close();
                    }
                }
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return contents;
    }
    /**
     * Remove/collapse multiple newline characters.
     *
     * @param argStr string to collapse newlines in.
     * @return String
     */
    public static String collapseNewlines(String argStr)
    {
        char last = argStr.charAt(0);
        StringBuffer argBuf = new StringBuffer();
        for (int cIdx = 0 ; cIdx < argStr.length(); cIdx++)
        {
            char ch = argStr.charAt(cIdx);
            if (ch != '\n' || last != '\n')
            {
                argBuf.append(ch);
                last = ch;
            }
        }
        return argBuf.toString();
    }
    /**
     * Remove/collapse multiple spaces.
     *
     * @param argStr string to remove multiple spaces from.
     * @return String
     */
    public static String collapseSpaces(String argStr)
    {
        char last = argStr.charAt(0);
        StringBuffer argBuf = new StringBuffer();
        for (int cIdx = 0 ; cIdx < argStr.length(); cIdx++)
        {
            char ch = argStr.charAt(cIdx);
            if (ch != ' ' || last != ' ')
            {
                argBuf.append(ch);
                last = ch;
            }
        }
        return argBuf.toString();
    }
    /**
      * Replaces all instances of oldString with newString in line.
      * Taken from the Jive forum package.
      *
      * @param line original string.
      * @param oldString string in line to replace.
      * @param newString replace oldString with this.
      * @return String string with replacements.
      */
    public static final String sub(String line, String oldString,
            String newString)
    {
        int i = 0;
        if ((i = line.indexOf(oldString, i)) >= 0)
        {
            char [] line2 = line.toCharArray();
            char [] newString2 = newString.toCharArray();
            int oLength = oldString.length();
            StringBuffer buf = new StringBuffer(line2.length);
            buf.append(line2, 0, i).append(newString2);
            i += oLength;
            int j = i;
            while ((i = line.indexOf(oldString, i)) > 0)
            {
                buf.append(line2, j, i - j).append(newString2);
                i += oLength;
                j = i;
            }
            buf.append(line2, j, line2.length - j);
            return buf.toString();
        }
        return line;
    }
    /**
     * Returns the output of printStackTrace as a String.
     *
     * @param e A Throwable.
     * @return A String.
     */
    public static final String stackTrace(Throwable e)
    {
        String foo = null;
        try
        {
            // And show the Error Screen.
            ByteArrayOutputStream ostr = new ByteArrayOutputStream();
            e.printStackTrace( new PrintWriter(ostr,true) );
            foo = ostr.toString();
        }
        catch (Exception f)
        {
            // Do nothing.
        }
        return foo;
    }
    /**
     * Return a context-relative path, beginning with a ""/"", that represents
     * the canonical version of the specified path after "".."" and ""."" elements
     * are resolved out.  If the specified path attempts to go outside the
     * boundaries of the current context (i.e. too many "".."" path elements
     * are present), return <code>null</code> instead.
     *
     * @param path Path to be normalized
     * @return String normalized path
     */
    public static final String normalizePath(String path)
    {
        // Normalize the slashes and add leading slash if necessary
        String normalized = path;
        if (normalized.indexOf('\\') >= 0)
        {
            normalized = normalized.replace('\\', '/');
        }
        if (!normalized.startsWith(""/""))
        {
            normalized = ""/"" + normalized;
        }
        // Resolve occurrences of ""//"" in the normalized path
        while (true)
        {
            int index = normalized.indexOf(""//"");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index) +
            normalized.substring(index + 1);
        }
        // Resolve occurrences of ""%20"" in the normalized path
        while (true)
        {
            int index = normalized.indexOf(""%20"");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index) + "" "" +
            normalized.substring(index + 3);
        }
        // Resolve occurrences of ""/./"" in the normalized path
        while (true)
        {
            int index = normalized.indexOf(""/./"");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index) +
            normalized.substring(index + 2);
        }
        // Resolve occurrences of ""/../"" in the normalized path
        while (true)
        {
            int index = normalized.indexOf(""/../"");
            if (index < 0)
                break;
            if (index == 0)
                return (null);  // Trying to go outside our context
            int index2 = normalized.lastIndexOf('/', index - 1);
            normalized = normalized.substring(0, index2) +
            normalized.substring(index + 3);
        }
        // Return the normalized path that we have completed
        return (normalized);
    }
    /**
     * If state is true then return the trueString, else
     * return the falseString.
     *
     * @param state
     * @param trueString
     * @param falseString
     * @return Selected result.
     */
    public String select(boolean state, String trueString, String falseString)
    {
        if (state)
        {
            return trueString;
        }
        else
        {
            return falseString;
        }
    }
    /**
     * Check to see if all the string objects passed
     * in are empty.
     *
     * @param list A list of {@link java.lang.String} objects.
     * @return     Whether all strings are empty.
     */
    public boolean allEmpty(List list)
    {
        int size = list.size();
        for (int i = 0; i < size; i++)
        {
            if (list.get(i) != null && list.get(i).toString().length() > 0)
            {
                return false;
            }
        }
        return true;
    }
    /**
     * Trim all strings in a List.  Changes the strings in the existing list.
     * @param list
     * @return List of trimmed strings.
     * @since 1.5
     */
    public static List trimStrings(List list)
    {
        if (list == null)
            return null;
        int sz = list.size();
        for (int i = 0; i < sz; i++)
            list.set(i,nullTrim((String) list.get(i)));
        return list;
    }
    /**
     * Trim the string, but pass a null through.
     * @param s
     * @return List of trimmed Strings.
     * @since 1.5
     */
    public static String nullTrim(String s)
    {
        if (s == null)
        {
            return null;
        }
        else
        {
            return s.trim();
        }
    }
}
"
org.apache.velocity.util.TemplateNumber,"package org.apache.velocity.util;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * Any object in the context which implements TemplateNumber will be treated
 * as a number for the purposes of arithmetic operations and comparison.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @since 1.5
 */
public interface TemplateNumber
{
   /**
    * Returns a Number that can be used in a template.
    * @return A Number that can be used in a template.
    */
   public Number getAsNumber();
}
"
org.apache.velocity.util.introspection.AbstractChainableUberspector,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.util.Iterator;
/**
 * Default implementation of a {@link ChainableUberspector chainable uberspector} that forwards all calls to the wrapped
 * uberspector (when that is possible). It should be used as the base class for all chainable uberspectors.
 * 
 * @version $Id: $
 * @since 1.6
 * @see ChainableUberspector
 */
public abstract class AbstractChainableUberspector extends UberspectImpl implements ChainableUberspector
{
    /** The wrapped (decorated) uberspector. */
    protected Uberspect inner;
    /**
     * {@inheritDoc}
     * 
     * @see ChainableUberspector#wrap(org.apache.velocity.util.introspection.Uberspect)
     * @see #inner
     */
    public void wrap(Uberspect inner)
    {
        this.inner = inner;
    }
    /**
     * init - the chainable uberspector is responsible for the initialization of the wrapped uberspector
     * 
     * @see org.apache.velocity.util.introspection.Uberspect#init()
     */
    //@Override
    public void init() throws Exception
    {
        if (this.inner != null) {
            this.inner.init();
        }
    }
    /**
     * {@inheritDoc}
     * 
     * @see org.apache.velocity.util.introspection.Uberspect#getIterator(java.lang.Object,
     *      org.apache.velocity.util.introspection.Info)
     */
    //@SuppressWarnings(""unchecked"")
    //@Override
    public Iterator getIterator(Object obj, Info i) throws Exception
    {
        return (this.inner != null) ? this.inner.getIterator(obj, i) : null;
    }
    /**
     * {@inheritDoc}
     * 
     * @see org.apache.velocity.util.introspection.Uberspect#getMethod(java.lang.Object, java.lang.String,
     *      java.lang.Object[], org.apache.velocity.util.introspection.Info)
     */
    //@Override
    public VelMethod getMethod(Object obj, String methodName, Object[] args, Info i) throws Exception
    {
        return (this.inner != null) ? this.inner.getMethod(obj, methodName, args, i) : null;
    }
    /**
     * {@inheritDoc}
     * 
     * @see org.apache.velocity.util.introspection.Uberspect#getPropertyGet(java.lang.Object, java.lang.String,
     *      org.apache.velocity.util.introspection.Info)
     */
    //@Override
    public VelPropertyGet getPropertyGet(Object obj, String identifier, Info i) throws Exception
    {
        return (this.inner != null) ? this.inner.getPropertyGet(obj, identifier, i) : null;
    }
    /**
     * {@inheritDoc}
     * 
     * @see org.apache.velocity.util.introspection.Uberspect#getPropertySet(java.lang.Object, java.lang.String,
     *      java.lang.Object, org.apache.velocity.util.introspection.Info)
     */
    //@Override
    public VelPropertySet getPropertySet(Object obj, String identifier, Object arg, Info i) throws Exception
    {
        return (this.inner != null) ? this.inner.getPropertySet(obj, identifier, arg, i) : null;
    }
}
"
org.apache.velocity.util.introspection.ChainableUberspector,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * Interface that marks uberspectors as chainable, meaning that multiple uberspectors can be
 * combined in a chain (using the Decorator pattern).
 * 
 * @version $Id: $
 * @since 1.6
 */
public interface ChainableUberspector extends Uberspect
{
    /**
     * Specify the decorated Uberspector
     * 
     * @param inner The decorated uberspector.
     */
    public void wrap(Uberspect inner);
}
"
org.apache.velocity.util.introspection.ClassMap,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.lang.text.StrBuilder;
import org.apache.velocity.runtime.log.Log;
/**
 * A cache of introspection information for a specific class instance.
 * Keys {@link java.lang.reflect.Method} objects by a concatenation of the
 * method name and the names of classes that make up the parameters.
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:bob@werken.com"">Bob McWhirter</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @author Nathan Bubna
 * @version $Id: ClassMap.java 698376 2008-09-23 22:15:49Z nbubna $
 */
public class ClassMap
{
    /** Set true if you want to debug the reflection code */
    private static final boolean debugReflection = false;
    /** Class logger */
    private final Log log;
    /**
     * Class passed into the constructor used to as
     * the basis for the Method map.
     */
    private final Class clazz;
    private final MethodCache methodCache;
    /**
     * Standard constructor
     * @param clazz The class for which this ClassMap gets constructed.
     */
    public ClassMap(final Class clazz, final Log log)
    {
        this.clazz = clazz;
        this.log = log;
        if (debugReflection && log.isDebugEnabled())
        {
            log.debug(""================================================================="");
            log.debug(""== Class: "" + clazz);
        }
        methodCache = createMethodCache();
        if (debugReflection && log.isDebugEnabled())
        {
            log.debug(""================================================================="");
        }
    }
    /**
     * Returns the class object whose methods are cached by this map.
     *
     * @return The class object whose methods are cached by this map.
     */
    public Class getCachedClass()
    {
        return clazz;
    }
    /**
     * Find a Method using the method name and parameter objects.
     *
     * @param name The method name to look up.
     * @param params An array of parameters for the method.
     * @return A Method object representing the method to invoke or null.
     * @throws MethodMap.AmbiguousException When more than one method is a match for the parameters.
     */
    public Method findMethod(final String name, final Object[] params)
            throws MethodMap.AmbiguousException
    {
        return methodCache.get(name, params);
    }
    /**
     * Populate the Map of direct hits. These
     * are taken from all the public methods
     * that our class, its parents and their implemented interfaces provide.
     */
    private MethodCache createMethodCache()
    {
        MethodCache methodCache = new MethodCache(log);
	//
	// Looks through all elements in the class hierarchy. This one is bottom-first (i.e. we start
	// with the actual declaring class and its interfaces and then move up (superclass etc.) until we
	// hit java.lang.Object. That is important because it will give us the methods of the declaring class
	// which might in turn be abstract further up the tree.
	//
	// We also ignore all SecurityExceptions that might happen due to SecurityManager restrictions (prominently 
	// hit with Tomcat 5.5).
	//
	// We can also omit all that complicated getPublic, getAccessible and upcast logic that the class map had up
	// until Velocity 1.4. As we always reflect all elements of the tree (that's what we have a cache for), we will
	// hit the public elements sooner or later because we reflect all the public elements anyway.
	//
        // Ah, the miracles of Java for(;;) ... 
        for (Class classToReflect = getCachedClass(); classToReflect != null ; classToReflect = classToReflect.getSuperclass())
        {
            if (Modifier.isPublic(classToReflect.getModifiers()))
            {
                populateMethodCacheWith(methodCache, classToReflect);
            }
            Class [] interfaces = classToReflect.getInterfaces();
            for (int i = 0; i < interfaces.length; i++)
            {
                if (Modifier.isPublic(interfaces[i].getModifiers()))
                {
                    populateMethodCacheWith(methodCache, interfaces[i]);
                }
            }
        }
        // return the already initialized cache
        return methodCache;
    }
    private void populateMethodCacheWith(MethodCache methodCache, Class classToReflect)
    {
        if (debugReflection && log.isDebugEnabled())
        {
            log.debug(""Reflecting "" + classToReflect);
        }
        try
        {
            Method[] methods = classToReflect.getDeclaredMethods();
            for (int i = 0; i < methods.length; i++)
            {
                // Strictly spoken that check shouldn't be necessary
                // because getMethods only returns public methods.
                int modifiers = methods[i].getModifiers();
                if (Modifier.isPublic(modifiers)) //  && !)
                {
                    // Some of the interfaces contain abstract methods. That is fine, because the actual object must 
                    // implement them anyway (else it wouldn't be implementing the interface). If we find an abstract
                    // method in a non-interface, we skip it, because we do want to make sure that no abstract methods end up in
                    // the cache.                       
                    if (classToReflect.isInterface() || !Modifier.isAbstract(modifiers))
                    {
                        methodCache.put(methods[i]);
                    }
                }
            }
        }
        catch (SecurityException se) // Everybody feels better with...
        {
            if (log.isDebugEnabled())
            {
                log.debug(""While accessing methods of "" + classToReflect + "": "", se);
            }
        }
    }
    /**
     * This is the cache to store and look up the method information. 
     * 
     * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
     * @version $Id: ClassMap.java 698376 2008-09-23 22:15:49Z nbubna $
     */
    private static final class MethodCache
    {
        private static final Object CACHE_MISS = new Object();
        private static final String NULL_ARG = Object.class.getName();
        private static final Map convertPrimitives = new HashMap();
        static
        {
            convertPrimitives.put(Boolean.TYPE,   Boolean.class.getName());
            convertPrimitives.put(Byte.TYPE,      Byte.class.getName());
            convertPrimitives.put(Character.TYPE, Character.class.getName());
            convertPrimitives.put(Double.TYPE,    Double.class.getName());
            convertPrimitives.put(Float.TYPE,     Float.class.getName());
            convertPrimitives.put(Integer.TYPE,   Integer.class.getName());
            convertPrimitives.put(Long.TYPE,      Long.class.getName());
            convertPrimitives.put(Short.TYPE,     Short.class.getName());
        }
    	/** Class logger */
	    private final Log log;
        /**
         * Cache of Methods, or CACHE_MISS, keyed by method
         * name and actual arguments used to find it.
         */
        private final Map cache = new HashMap();
        /** Map of methods that are searchable according to method parameters to find a match */
        private final MethodMap methodMap = new MethodMap();
        private MethodCache(Log log)
        {
            this.log = log;
        }
        /**
         * Find a Method using the method name and parameter objects.
         *
         * Look in the methodMap for an entry.  If found,
         * it'll either be a CACHE_MISS, in which case we
         * simply give up, or it'll be a Method, in which
         * case, we return it.
         *
         * If nothing is found, then we must actually go
         * and introspect the method from the MethodMap.
         *
         * @param name The method name to look up.
         * @param params An array of parameters for the method.
         * @return A Method object representing the method to invoke or null.
         * @throws MethodMap.AmbiguousException When more than one method is a match for the parameters.
         */
        public Method get(final String name, final Object [] params)
                throws MethodMap.AmbiguousException
        {
            String methodKey = makeMethodKey(name, params);
            Object cacheEntry = cache.get(methodKey);
            if (cacheEntry == CACHE_MISS)
            {
                // We looked this up before and failed. 
                return null;
            }
            if (cacheEntry == null)
            {
                try
                {
                    // That one is expensive...
                    cacheEntry = methodMap.find(name, params);
                }
                catch(MethodMap.AmbiguousException ae)
                {
                    /*
                     *  that's a miss :-)
                     */
                    cache.put(methodKey, CACHE_MISS);
                    throw ae;
                }
                cache.put(methodKey, 
                        (cacheEntry != null) ? cacheEntry : CACHE_MISS);
            }
            // Yes, this might just be null.
            return (Method) cacheEntry;
        }
        private void put(Method method)
        {
            String methodKey = makeMethodKey(method);
            // We don't overwrite methods because we fill the
            // cache from defined class towards java.lang.Object
            // and that would cause overridden methods to appear
            // as if they were not overridden.
            if (cache.get(methodKey) == null)
            {
                cache.put(methodKey, method);
                methodMap.add(method);
                if (debugReflection && log.isDebugEnabled())
                {
                    log.debug(""Adding "" + method);
                }
            }
        }
        /**
         * Make a methodKey for the given method using
         * the concatenation of the name and the
         * types of the method parameters.
         * 
         * @param method to be stored as key
         * @return key for ClassMap
         */
        private String makeMethodKey(final Method method)
        {
            Class[] parameterTypes = method.getParameterTypes();
            int args = parameterTypes.length;
            if (args == 0)
            {
                return method.getName();
            }
            StrBuilder methodKey = new StrBuilder((args+1)*16).append(method.getName());
            for (int j = 0; j < args; j++)
            {
                /*
                 * If the argument type is primitive then we want
                 * to convert our primitive type signature to the
                 * corresponding Object type so introspection for
                 * methods with primitive types will work correctly.
                 *
                 * The lookup map (convertPrimitives) contains all eight
                 * primitives (boolean, byte, char, double, float, int, long, short)
                 * known to Java. So it should never return null for the key passed in.
                 */
                if (parameterTypes[j].isPrimitive())
                {
                    methodKey.append((String) convertPrimitives.get(parameterTypes[j]));
                }
                else
                {
                    methodKey.append(parameterTypes[j].getName());
                }
            }
            return methodKey.toString();
        }
        private String makeMethodKey(String method, Object[] params)
        {
            int args = params.length;
            if (args == 0)
            {
                return method;
            }
            StrBuilder methodKey = new StrBuilder((args+1)*16).append(method);
            for (int j = 0; j < args; j++)
            {
                Object arg = params[j];
                if (arg == null)
                {
                    methodKey.append(NULL_ARG);
                }
                else
                {
                    methodKey.append(arg.getClass().getName());
                }
            }
            return methodKey.toString();
        }
    }
}
"
org.apache.velocity.util.introspection.Info,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.log.Log;
/**
 *  Little class to carry in info such as template name, line and column
 *  for information error reporting from the uberspector implementations
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: Info.java 704179 2008-10-13 17:42:11Z nbubna $
 */
public class Info
{
    private int line;
    private int column;
    private String templateName;
    /**
     * @param source Usually a template name.
     * @param line The line number from <code>source</code>.
     * @param column The column number from <code>source</code>.
     */
    public Info(String source, int line, int column)
    {
        this.templateName = source;
        this.line = line;
        this.column = column;
    }
    /**
     * Force callers to set the location information.
     */
    private Info()
    {
    }
    /**
     * @return The template name.
     */
    public String getTemplateName()
    {
        return templateName;
    }
    /**
     * @return The line number.
     */
    public int getLine()
    {
        return line;
    }
    /**
     * @return The column number.
     */
    public int getColumn()
    {
        return column;
    }
    /**
     * Formats a textual representation of this object as <code>SOURCE
     * [line X, column Y]</code>.
     *
     * @return String representing this object.
     * @since 1.5
     */
    public String toString()
    {
        return Log.formatFileString(getTemplateName(), getLine(), getColumn());
    }
}
"
org.apache.velocity.util.introspection.IntrospectionCacheData,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Holds information for node-local context data introspection
 *  information.
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: IntrospectionCacheData.java 463298 2006-10-12 16:10:32Z henning $
 */
public class IntrospectionCacheData
{
    /**
     *  Object to pair with class - currently either a Method or
     *  AbstractExecutor. It can be used in any way the using node
     *  wishes.
     */
    public Object thingy;
    /**
     *  Class of context data object associated with the introspection
     *  information
     */
    public Class  contextData;
}
"
org.apache.velocity.util.introspection.IntrospectionUtils,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:bob@werken.com"">Bob McWhirter</a>
 * @author <a href=""mailto:Christoph.Reck@dlr.de"">Christoph Reck</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @author Nathan Bubna
 * @version $Id: IntrospectionUtils.java 476785 2006-11-19 10:06:21Z henning $
 * @since 1.6
 */
public class IntrospectionUtils
{
    /**
     * Determines whether a type represented by a class object is
     * convertible to another type represented by a class object using a
     * method invocation conversion, treating object types of primitive
     * types as if they were primitive types (that is, a Boolean actual
     * parameter type matches boolean primitive formal type). This behavior
     * is because this method is used to determine applicable methods for
     * an actual parameter list, and primitive types are represented by
     * their object duals in reflective method calls.
     *
     * @param formal the formal parameter type to which the actual
     * parameter type should be convertible
     * @param actual the actual parameter type.
     * @param possibleVarArg whether or not we're dealing with the last parameter
     * in the method declaration
     * @return true if either formal type is assignable from actual type,
     * or formal is a primitive type and actual is its corresponding object
     * type or an object type of a primitive type that can be converted to
     * the formal type.
     */
    public static boolean isMethodInvocationConvertible(Class formal,
                                                        Class actual,
                                                        boolean possibleVarArg)
    {
        /* if it's a null, it means the arg was null */
        if (actual == null && !formal.isPrimitive())
        {
            return true;
        }
        /* Check for identity or widening reference conversion */
        if (actual != null && formal.isAssignableFrom(actual))
        {
            return true;
        }
        /* Check for boxing with widening primitive conversion. Note that
         * actual parameters are never primitives. */
        if (formal.isPrimitive())
        {
            if(formal == Boolean.TYPE && actual == Boolean.class)
                return true;
            if(formal == Character.TYPE && actual == Character.class)
                return true;
            if(formal == Byte.TYPE && actual == Byte.class)
                return true;
            if(formal == Short.TYPE &&
               (actual == Short.class || actual == Byte.class))
                return true;
            if(formal == Integer.TYPE &&
               (actual == Integer.class || actual == Short.class ||
                actual == Byte.class))
                return true;
            if(formal == Long.TYPE &&
               (actual == Long.class || actual == Integer.class ||
                actual == Short.class || actual == Byte.class))
                return true;
            if(formal == Float.TYPE &&
               (actual == Float.class || actual == Long.class ||
                actual == Integer.class || actual == Short.class ||
                actual == Byte.class))
                return true;
            if(formal == Double.TYPE &&
               (actual == Double.class || actual == Float.class ||
                actual == Long.class || actual == Integer.class ||
                actual == Short.class || actual == Byte.class))
                return true;
        }
        /* Check for vararg conversion. */
        if (possibleVarArg && formal.isArray())
        {
            if (actual.isArray())
            {
                actual = actual.getComponentType();
            }
            return isMethodInvocationConvertible(formal.getComponentType(),
                                                 actual, false);
        }
        return false;
    }
    /**
     * Determines whether a type represented by a class object is
     * convertible to another type represented by a class object using a
     * method invocation conversion, without matching object and primitive
     * types. This method is used to determine the more specific type when
     * comparing signatures of methods.
     *
     * @param formal the formal parameter type to which the actual
     * parameter type should be convertible
     * @param actual the actual parameter type.
     * @param possibleVarArg whether or not we're dealing with the last parameter
     * in the method declaration
     * @return true if either formal type is assignable from actual type,
     * or formal and actual are both primitive types and actual can be
     * subject to widening conversion to formal.
     */
    public static boolean isStrictMethodInvocationConvertible(Class formal,
                                                              Class actual,
                                                              boolean possibleVarArg)
    {
        /* we shouldn't get a null into, but if so */
        if (actual == null && !formal.isPrimitive())
        {
            return true;
        }
        /* Check for identity or widening reference conversion */
        if(formal.isAssignableFrom(actual))
        {
            return true;
        }
        /* Check for widening primitive conversion. */
        if(formal.isPrimitive())
        {
            if(formal == Short.TYPE && (actual == Byte.TYPE))
                return true;
            if(formal == Integer.TYPE &&
               (actual == Short.TYPE || actual == Byte.TYPE))
                return true;
            if(formal == Long.TYPE &&
               (actual == Integer.TYPE || actual == Short.TYPE ||
                actual == Byte.TYPE))
                return true;
            if(formal == Float.TYPE &&
               (actual == Long.TYPE || actual == Integer.TYPE ||
                actual == Short.TYPE || actual == Byte.TYPE))
                return true;
            if(formal == Double.TYPE &&
               (actual == Float.TYPE || actual == Long.TYPE ||
                actual == Integer.TYPE || actual == Short.TYPE ||
                actual == Byte.TYPE))
                return true;
        }
        /* Check for vararg conversion. */
        if (possibleVarArg && formal.isArray())
        {
            if (actual.isArray())
            {
                actual = actual.getComponentType();
            }
            return isStrictMethodInvocationConvertible(formal.getComponentType(),
                                                       actual, false);
        }
        return false;
    }
}
"
org.apache.velocity.util.introspection.Introspector,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.Method;
import org.apache.velocity.runtime.RuntimeLogger;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.log.RuntimeLoggerLog;
/**
 * This basic function of this class is to return a Method
 * object for a particular class given the name of a method
 * and the parameters to the method in the form of an Object[]
 *
 * The first time the Introspector sees a
 * class it creates a class method map for the
 * class in question. Basically the class method map
 * is a Hastable where Method objects are keyed by a
 * concatenation of the method name and the names of
 * classes that make up the parameters.
 *
 * For example, a method with the following signature:
 *
 * public void method(String a, StringBuffer b)
 *
 * would be mapped by the key:
 *
 * ""method"" + ""java.lang.String"" + ""java.lang.StringBuffer""
 *
 * This mapping is performed for all the methods in a class
 * and stored for
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:bob@werken.com"">Bob McWhirter</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @author <a href=""mailto:paulo.gaspar@krankikom.de"">Paulo Gaspar</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: Introspector.java 687177 2008-08-19 22:00:32Z nbubna $
 */
public class Introspector extends IntrospectorBase
{
    /**
     * @param log A Log object to use for the introspector.
     * @since 1.5
     */
    public Introspector(final Log log)
    {
        super(log);
    }
    /**
     * @param logger A runtime logger object.
     * @deprecated RuntimeLogger is deprecated. Use Introspector(Log log).
     */
    public Introspector(final RuntimeLogger logger)
    {
        this(new RuntimeLoggerLog(logger));
    }
    /**
     * Gets the method defined by <code>name</code> and
     * <code>params</code> for the Class <code>c</code>.
     *
     * @param c Class in which the method search is taking place
     * @param name Name of the method being searched for
     * @param params An array of Objects (not Classes) that describe the
     *               the parameters
     *
     * @return The desired Method object.
     * @throws IllegalArgumentException When the parameters passed in can not be used for introspection.
     */
    public Method getMethod(final Class c, final String name, final Object[] params)
        throws IllegalArgumentException
    {
        try
        {
            return super.getMethod(c, name, params);
        }
        catch(MethodMap.AmbiguousException ae)
        {
            /*
             *  whoops.  Ambiguous.  Make a nice log message and return null...
             */
            StringBuffer msg = new StringBuffer(""Introspection Error : Ambiguous method invocation "")
                    .append(name)
                    .append(""("");
            for (int i = 0; i < params.length; i++)
            {
                if (i > 0)
                {
                    msg.append("", "");
                }
                if (params[i] == null)
                {
                    msg.append(""null"");
                }
                else
                {
                    msg.append(params[i].getClass().getName());
                }
            }
            msg.append("") for class "")
                    .append(c);
            log.debug(msg.toString());
        }
        return null;
    }
}
"
org.apache.velocity.util.introspection.IntrospectorBase,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.Method;
import org.apache.velocity.runtime.log.Log;
/**
 * Lookup a a Method object for a particular class given the name of a method
 * and its parameters.
 *
 * The first time the Introspector sees a
 * class it creates a class method map for the
 * class in question. Basically the class method map
 * is a Hashtable where Method objects are keyed by a
 * concatenation of the method name and the names of
 * classes that make up the parameters.
 *
 * For example, a method with the following signature:
 *
 * public void method(String a, StringBuffer b)
 *
 * would be mapped by the key:
 *
 * ""method"" + ""java.lang.String"" + ""java.lang.StringBuffer""
 *
 * This mapping is performed for all the methods in a class
 * and stored for.
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:bob@werken.com"">Bob McWhirter</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @author <a href=""mailto:paulo.gaspar@krankikom.de"">Paulo Gaspar</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: IntrospectorBase.java 685685 2008-08-13 21:43:27Z nbubna $
 */
public abstract class IntrospectorBase
{
    /** Class logger */
    protected final Log log;
    /** The Introspector Cache */
    private final IntrospectorCache introspectorCache;
    /**
     * C'tor.
     */
    protected IntrospectorBase(final Log log)
    {
        this.log = log;
        introspectorCache = new IntrospectorCacheImpl(log); // TODO: Load that from properties.
    }
    /**
     * Gets the method defined by <code>name</code> and
     * <code>params</code> for the Class <code>c</code>.
     *
     * @param c Class in which the method search is taking place
     * @param name Name of the method being searched for
     * @param params An array of Objects (not Classes) that describe the
     *               the parameters
     *
     * @return The desired Method object.
     * @throws IllegalArgumentException When the parameters passed in can not be used for introspection.
     * @throws MethodMap.AmbiguousException When the method map contains more than one match for the requested signature.
     */
    public Method getMethod(final Class c, final String name, final Object[] params)
            throws IllegalArgumentException,MethodMap.AmbiguousException
    {
        if (c == null)
        {
            throw new IllegalArgumentException (""class object is null!"");
        }
        if (params == null)
        {
            throw new IllegalArgumentException(""params object is null!"");
        }
        IntrospectorCache ic = getIntrospectorCache();
        ClassMap classMap = ic.get(c);
        if (classMap == null)
        {
            classMap = ic.put(c);
        }
        return classMap.findMethod(name, params);
    }
    /**
     * Return the internal IntrospectorCache object.
     * 
     * @return The internal IntrospectorCache object.
     * @since 1.5
     */
    protected IntrospectorCache getIntrospectorCache()
    {
	    return introspectorCache;
    }
}
"
org.apache.velocity.util.introspection.IntrospectorCache,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * The introspector cache API definition.
 *
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: IntrospectorCache.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public interface IntrospectorCache {
    /**
     * Clears the internal cache.
     */
    void clear();
    /**
     * Lookup a given Class object in the cache. If it does not exist, 
     * check whether this is due to a class change and purge the caches
     * eventually.
     *
     * @param c The class to look up.
     * @return A ClassMap object or null if it does not exist in the cache.
     */
    ClassMap get(Class c);
    /**
     * Creates a class map for specific class and registers it in the
     * cache.  Also adds the qualified name to the name-&gt;class map
     * for later Classloader change detection.
     *
     * @param c The class for which the class map gets generated.
     * @return A ClassMap object.
     */
    ClassMap put(Class c);
}
"
org.apache.velocity.util.introspection.IntrospectorCacheImpl,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import org.apache.velocity.runtime.log.Log;
/**
 * This is the internal introspector cache implementation.
 *
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: IntrospectorCacheImpl.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public final class IntrospectorCacheImpl implements IntrospectorCache
{
    /**
     * define a public string so that it can be looked for if interested
     */
    public final static String CACHEDUMP_MSG =
        ""IntrospectorCache detected classloader change. Dumping cache."";
    /** Class logger */
    private final Log log;
    /**
     * Holds the method maps for the classes we know about. Map: Class --&gt; ClassMap object.
     */
    private final Map classMapCache = new HashMap();
    /**
     * Keep the names of the classes in another map. This is needed for a multi-classloader environment where it is possible
     * to have Class 'Foo' loaded by a classloader and then get asked to introspect on 'Foo' from another class loader. While these
     * two Class objects have the same name, a <code>classMethodMaps.get(Foo.class)</code> will return null. For that case, we
     * keep a set of class names to recognize this case.  
     */
    private final Set classNameCache = new HashSet();
    /**
     * C'tor
     */
    public IntrospectorCacheImpl(final Log log)
    {
	    this.log = log;
    }
    /**
     * Clears the internal cache.
     */
    public void clear()
    {
        synchronized (classMapCache)
        {
            classMapCache.clear();
            classNameCache.clear();
            log.debug(CACHEDUMP_MSG);
        }
    }
    /**
     * Lookup a given Class object in the cache. If it does not exist, 
     * check whether this is due to a class change and purge the caches
     * eventually.
     *
     * @param c The class to look up.
     * @return A ClassMap object or null if it does not exist in the cache.
     */
    public ClassMap get(final Class c)
    {
        if (c == null)
        {
            throw new IllegalArgumentException(""class is null!"");
        }
        ClassMap classMap = (ClassMap)classMapCache.get(c);
        if (classMap == null)
        {
            /*
             * check to see if we have it by name.
             * if so, then we have an object with the same
             * name but loaded through a different class loader.
             * In that case, we will just dump the cache to be sure.
             */
            synchronized (classMapCache)
            {
                if (classNameCache.contains(c.getName()))
                {
                    clear();
                }
            }
        }
        return classMap;
    }
    /**
     * Creates a class map for specific class and registers it in the
     * cache.  Also adds the qualified name to the name-&gt;class map
     * for later Classloader change detection.
     *
     * @param c The class for which the class map gets generated.
     * @return A ClassMap object.
     */
    public ClassMap put(final Class c)
    {
        final ClassMap classMap = new ClassMap(c, log);
        synchronized (classMapCache)
        {
            classMapCache.put(c, classMap);
            classNameCache.add(c.getName());
        }
        return classMap;
    }
}
"
org.apache.velocity.util.introspection.LinkingUberspector,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Iterator;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.RuntimeServicesAware;
/**
 * <p>
 * When the runtime.introspection.uberspect configuration property contains several
 * uberspector class names, it means those uberspectors will be chained. When an
 * uberspector in the list other than the leftmost does not implement ChainableUberspector,
 * then this utility class is used to provide a basic default chaining where the
 * first non-null result is kept for each introspection call.
 * </p>
 * 
 * @since 1.6
 * @see ChainableUberspector
 * @version $Id: LinkingUberspector.java 10959 2008-07-01 00:12:29Z sdumitriu $
 */
public class LinkingUberspector extends AbstractChainableUberspector
{
    private Uberspect leftUberspect;
    private Uberspect rightUberspect;
    /**
     * Constructor that takes the two uberspectors to link
     */
    public LinkingUberspector(Uberspect left,Uberspect right) {
        leftUberspect = left;
        rightUberspect = right;
    }
    /**
     * {@inheritDoc}
     * <p>
     * Init both wrapped uberspectors
     * </p>
     * 
     * @see org.apache.velocity.util.introspection.Uberspect#init()
     */
    //@Override
    public void init() throws Exception
    {
        leftUberspect.init();
        rightUberspect.init();
    }
    /**
     * {@inheritDoc}
     * 
     * @see org.apache.velocity.util.introspection.Uberspect#getIterator(java.lang.Object,
     *      org.apache.velocity.util.introspection.Info)
     */
    //@SuppressWarnings(""unchecked"")
    //@Override
    public Iterator getIterator(Object obj, Info i) throws Exception
    {
        Iterator it = leftUberspect.getIterator(obj,i);
        return it != null ? it : rightUberspect.getIterator(obj,i);
    }
    /**
     * {@inheritDoc}
     * 
     * @see org.apache.velocity.util.introspection.Uberspect#getMethod(java.lang.Object, java.lang.String,
     *      java.lang.Object[], org.apache.velocity.util.introspection.Info)
     */
    //@Override
    public VelMethod getMethod(Object obj, String methodName, Object[] args, Info i) throws Exception
    {
        VelMethod method = leftUberspect.getMethod(obj,methodName,args,i);
        return method != null ? method : rightUberspect.getMethod(obj,methodName,args,i);
    }
    /**
     * {@inheritDoc}
     * 
     * @see org.apache.velocity.util.introspection.Uberspect#getPropertyGet(java.lang.Object, java.lang.String,
     *      org.apache.velocity.util.introspection.Info)
     */
    //@Override
    public VelPropertyGet getPropertyGet(Object obj, String identifier, Info i) throws Exception
    {
        VelPropertyGet getter = leftUberspect.getPropertyGet(obj,identifier,i);
        return getter != null ? getter : rightUberspect.getPropertyGet(obj,identifier,i);
    }
    /**
     * {@inheritDoc}
     * 
     * @see org.apache.velocity.util.introspection.Uberspect#getPropertySet(java.lang.Object, java.lang.String,
     *      java.lang.Object, org.apache.velocity.util.introspection.Info)
     */
    //@Override
    public VelPropertySet getPropertySet(Object obj, String identifier, Object arg, Info i) throws Exception
    {
        VelPropertySet setter = leftUberspect.getPropertySet(obj,identifier,arg,i);
        return setter != null ? setter : rightUberspect.getPropertySet(obj,identifier,arg,i);
    }
}
"
org.apache.velocity.util.introspection.MethodMap,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
/**
 *
 * @author <a href=""mailto:jvanzyl@apache.org"">Jason van Zyl</a>
 * @author <a href=""mailto:bob@werken.com"">Bob McWhirter</a>
 * @author <a href=""mailto:Christoph.Reck@dlr.de"">Christoph Reck</a>
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:szegedia@freemail.hu"">Attila Szegedi</a>
 * @version $Id: MethodMap.java 679922 2008-07-25 22:58:13Z nbubna $
 */
public class MethodMap
{
    private static final int MORE_SPECIFIC = 0;
    private static final int LESS_SPECIFIC = 1;
    private static final int INCOMPARABLE = 2;
    /**
     * Keep track of all methods with the same name.
     */
    Map methodByNameMap = new HashMap();
    /**
     * Add a method to a list of methods by name.
     * For a particular class we are keeping track
     * of all the methods with the same name.
     * @param method
     */
    public void add(Method method)
    {
        String methodName = method.getName();
        List l = get( methodName );
        if ( l == null)
        {
            l = new ArrayList();
            methodByNameMap.put(methodName, l);
        }
        l.add(method);
    }
    /**
     * Return a list of methods with the same name.
     *
     * @param key
     * @return List list of methods
     */
    public List get(String key)
    {
        return (List) methodByNameMap.get(key);
    }
    /**
     *  <p>
     *  Find a method.  Attempts to find the
     *  most specific applicable method using the
     *  algorithm described in the JLS section
     *  15.12.2 (with the exception that it can't
     *  distinguish a primitive type argument from
     *  an object type argument, since in reflection
     *  primitive type arguments are represented by
     *  their object counterparts, so for an argument of
     *  type (say) java.lang.Integer, it will not be able
     *  to decide between a method that takes int and a
     *  method that takes java.lang.Integer as a parameter.
     *  </p>
     *
     *  <p>
     *  This turns out to be a relatively rare case
     *  where this is needed - however, functionality
     *  like this is needed.
     *  </p>
     *
     *  @param methodName name of method
     *  @param args the actual arguments with which the method is called
     *  @return the most specific applicable method, or null if no
     *  method is applicable.
     *  @throws AmbiguousException if there is more than one maximally
     *  specific applicable method
     */
    public Method find(String methodName, Object[] args)
        throws AmbiguousException
    {
        List methodList = get(methodName);
        if (methodList == null)
        {
            return null;
        }
        int l = args.length;
        Class[] classes = new Class[l];
        for(int i = 0; i < l; ++i)
        {
            Object arg = args[i];
            /*
             * if we are careful down below, a null argument goes in there
             * so we can know that the null was passed to the method
             */
            classes[i] =
                    arg == null ? null : arg.getClass();
        }
        return getBestMatch(methodList, classes);
    }
    private static Method getBestMatch(List methods, Class[] args)
    {
        List equivalentMatches = null;
        Method bestMatch = null;
        Class[] bestMatchTypes = null;
        for (Iterator i = methods.iterator(); i.hasNext(); )
        {
            Method method = (Method)i.next();
            if (isApplicable(method, args))
            {
                if (bestMatch == null)
                {
                    bestMatch = method;
                    bestMatchTypes = method.getParameterTypes();
                }
                else
                {
                    Class[] methodTypes = method.getParameterTypes();
                    switch (compare(methodTypes, bestMatchTypes))
                    {
                        case MORE_SPECIFIC:
                            if (equivalentMatches == null)
                            {
                                bestMatch = method;
                                bestMatchTypes = methodTypes;
                            }
                            else
                            {
                                // have to beat all other ambiguous ones...
                                int ambiguities = equivalentMatches.size();
                                for (int a=0; a < ambiguities; a++)
                                {
                                    Method other = (Method)equivalentMatches.get(a);
                                    switch (compare(methodTypes, other.getParameterTypes()))
                                    {
                                        case MORE_SPECIFIC:
                                            // ...and thus replace them all...
                                            bestMatch = method;
                                            bestMatchTypes = methodTypes;
                                            equivalentMatches = null;
                                            ambiguities = 0;
                                            break;
                                        case INCOMPARABLE:
                                            // ...join them...
                                            equivalentMatches.add(method);
                                            break;
                                        case LESS_SPECIFIC:
                                            // ...or just go away.
                                            break;
                                    }
                                }
                            }
                            break;
                        case INCOMPARABLE:
                            if (equivalentMatches == null)
                            {
                                equivalentMatches = new ArrayList(bestMatchTypes.length);
                            }
                            equivalentMatches.add(method);
                            break;
                        case LESS_SPECIFIC:
                            // do nothing
                            break;
                    }
                }
            }
        }
        if (equivalentMatches != null)
        {
            throw new AmbiguousException();
        }
        return bestMatch;
    }
    /**
     *  Simple distinguishable exception, used when
     *  we run across ambiguous overloading.  Caught
     *  by the introspector.
     */
    public static class AmbiguousException extends RuntimeException
    {
        /**
         * Version Id for serializable
         */
        private static final long serialVersionUID = -2314636505414551663L;
    }
    /**
     * Determines which method signature (represented by a class array) is more
     * specific. This defines a partial ordering on the method signatures.
     * @param c1 first signature to compare
     * @param c2 second signature to compare
     * @return MORE_SPECIFIC if c1 is more specific than c2, LESS_SPECIFIC if
     * c1 is less specific than c2, INCOMPARABLE if they are incomparable.
     */
    private static int compare(Class[] c1, Class[] c2)
    {
        boolean c1MoreSpecific = false;
        boolean c2MoreSpecific = false;
        // compare lengths to handle comparisons where the size of the arrays
        // doesn't match, but the methods are both applicable due to the fact
        // that one is a varargs method
        if (c1.length > c2.length)
        {
            return MORE_SPECIFIC;
        }
        if (c2.length > c1.length)
        {
            return LESS_SPECIFIC;
        }
        // ok, move on and compare those of equal lengths
        for(int i = 0; i < c1.length; ++i)
        {
            if(c1[i] != c2[i])
            {
                boolean last = (i == c1.length - 1);
                c1MoreSpecific =
                    c1MoreSpecific ||
                    isStrictConvertible(c2[i], c1[i], last);
                c2MoreSpecific =
                    c2MoreSpecific ||
                    isStrictConvertible(c1[i], c2[i], last);
            }
        }
        if(c1MoreSpecific)
        {
            if(c2MoreSpecific)
            {
                /*
                 * If one method accepts varargs and the other does not,
                 * call the non-vararg one more specific.
                 */
                boolean last1Array = c1[c1.length - 1].isArray();
                boolean last2Array = c2[c2.length - 1].isArray();
                if (last1Array && !last2Array)
                {
                    return LESS_SPECIFIC;
                }
                if (!last1Array && last2Array)
                {
                    return MORE_SPECIFIC;
                }
                /*
                 *  Incomparable due to cross-assignable arguments (i.e.
                 * foo(String, Object) vs. foo(Object, String))
                 */
                return INCOMPARABLE;
            }
            return MORE_SPECIFIC;
        }
        if(c2MoreSpecific)
        {
            return LESS_SPECIFIC;
        }
        /*
         * Incomparable due to non-related arguments (i.e.
         * foo(Runnable) vs. foo(Serializable))
         */
        return INCOMPARABLE;
    }
    /**
     * Returns true if the supplied method is applicable to actual
     * argument types.
     * 
     * @param method method that will be called
     * @param classes arguments to method
     * @return true if method is applicable to arguments
     */
    private static boolean isApplicable(Method method, Class[] classes)
    {
        Class[] methodArgs = method.getParameterTypes();
        if (methodArgs.length > classes.length)
        {
            // if there's just one more methodArg than class arg
            // and the last methodArg is an array, then treat it as a vararg
            if (methodArgs.length == classes.length + 1 &&
                methodArgs[methodArgs.length - 1].isArray())
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else if (methodArgs.length == classes.length)
        {
            // this will properly match when the last methodArg
            // is an array/varargs and the last class is the type of array
            // (e.g. String when the method is expecting String...)
            for(int i = 0; i < classes.length; ++i)
            {
                if(!isConvertible(methodArgs[i], classes[i], false))
                {
                    // if we're on the last arg and the method expects an array
                    if (i == classes.length - 1 && methodArgs[i].isArray())
                    {
                        // check to see if the last arg is convertible
                        // to the array's component type
                        return isConvertible(methodArgs[i], classes[i], true);
                    }
                    return false;
                }
            }
        }
        else if (methodArgs.length > 0) // more arguments given than the method accepts; check for varargs
        {
            // check that the last methodArg is an array
            Class lastarg = methodArgs[methodArgs.length - 1];
            if (!lastarg.isArray())
            {
                return false;
            }
            // check that they all match up to the last method arg
            for (int i = 0; i < methodArgs.length - 1; ++i)
            {
                if (!isConvertible(methodArgs[i], classes[i], false))
                {
                    return false;
                }
            }
            // check that all remaining arguments are convertible to the vararg type
            Class vararg = lastarg.getComponentType();
            for (int i = methodArgs.length - 1; i < classes.length; ++i)
            {
                if (!isConvertible(vararg, classes[i], false))
                {
                    return false;
                }
            }
        }
        return true;
    }
    private static boolean isConvertible(Class formal, Class actual,
                                         boolean possibleVarArg)
    {
        return IntrospectionUtils.
            isMethodInvocationConvertible(formal, actual, possibleVarArg);
    }
    private static boolean isStrictConvertible(Class formal, Class actual,
                                               boolean possibleVarArg)
    {
        return IntrospectionUtils.
            isStrictMethodInvocationConvertible(formal, actual, possibleVarArg);
    }
}
"
org.apache.velocity.util.introspection.SecureIntrospectorControl,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 * Interface used to determine which methods are allowed to be executed.
 *
 * @author <a href=""Will Glass-Husain"">wglass@forio.com</a>
 * @version $Id: SecureIntrospectorControl.java 685685 2008-08-13 21:43:27Z nbubna $
 * @since 1.5
 */
public interface SecureIntrospectorControl
{
    /**
     * Determine which methods and classes to prevent from executing.  
     * 
     * @param clazz Class for which method is being called
     * @param method method being called.  This may be null in the case of a call to iterator, get, or set method
     *
     * @return true if method may be called on object
     */
    public boolean checkObjectExecutePermission(Class clazz, String method);
}
"
org.apache.velocity.util.introspection.SecureIntrospectorImpl,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import java.lang.reflect.Method;
import org.apache.velocity.runtime.log.Log;
/**
 * <p>Prevent ""dangerous"" classloader/reflection related calls.  Use this
 * introspector for situations in which template writers are numerous
 * or untrusted.  Specifically, this introspector prevents creation of
 * arbitrary objects and prevents reflection on objects.
 *
 * <p>See documentation of checkObjectExecutePermission() for
 * more information on specific classes and methods blocked.
 *
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: SecureIntrospectorImpl.java 705375 2008-10-16 22:06:30Z nbubna $
 * @since 1.5
 */
public class SecureIntrospectorImpl extends Introspector implements SecureIntrospectorControl
{
    private String[] badClasses;
    private String[] badPackages;
    public SecureIntrospectorImpl(String[] badClasses, String[] badPackages, Log log)
    {
        super(log);
        this.badClasses = badClasses;
        this.badPackages = badPackages;
    }
    /**
     * Get the Method object corresponding to the given class, name and parameters.
     * Will check for appropriate execute permissions and return null if the method
     * is not allowed to be executed.
     *
     * @param clazz Class on which method will be called
     * @param methodName Name of method to be called
     * @param params array of parameters to method
     * @return Method object retrieved by Introspector
     * @throws IllegalArgumentException The parameter passed in were incorrect.
     */
    public Method getMethod(Class clazz, String methodName, Object[] params)
        throws IllegalArgumentException
    {
        if (!checkObjectExecutePermission(clazz, methodName))
        {
            log.warn(""Cannot retrieve method "" + methodName +
                     "" from object of class "" + clazz.getName() +
                     "" due to security restrictions."");
            return null;
        }
        else
        {
            return super.getMethod(clazz, methodName, params);
        }
    }
    /**
     * Determine which methods and classes to prevent from executing.  Always blocks
     * methods wait() and notify().  Always allows methods on Number, Boolean, and String.
     * Prohibits method calls on classes related to reflection and system operations.
     * For the complete list, see the properties <code>introspector.restrict.classes</code>
     * and <code>introspector.restrict.packages</code>.
     *
     * @param clazz Class on which method will be called
     * @param methodName Name of method to be called
     * @see org.apache.velocity.util.introspection.SecureIntrospectorControl#checkObjectExecutePermission(java.lang.Class, java.lang.String)
     */
    public boolean checkObjectExecutePermission(Class clazz, String methodName)
    {
		/**
		 * check for wait and notify
		 */
        if (methodName != null &&
            (methodName.equals(""wait"") || methodName.equals(""notify"")) )
		{
			return false;
		}
		/**
		 * Always allow the most common classes - Number, Boolean and String
		 */
		else if (Number.class.isAssignableFrom(clazz))
		{
			return true;
		}
		else if (Boolean.class.isAssignableFrom(clazz))
		{
			return true;
		}
		else if (String.class.isAssignableFrom(clazz))
		{
			return true;
		}
        /**
         * Always allow Class.getName()
         */
        else if (Class.class.isAssignableFrom(clazz) &&
                 (methodName != null) && methodName.equals(""getName""))
        {
            return true;
        }
        /**
         * check the classname (minus any array info)
         * whether it matches disallowed classes or packages
         */
        String className = clazz.getName();
        if (className.startsWith(""[L"") && className.endsWith("";""))
        {
            className = className.substring(2, className.length() - 1);
        }
        int dotPos = className.lastIndexOf('.');
        String packageName = (dotPos == -1) ? """" : className.substring(0, dotPos);
        for (int i = 0, size = badPackages.length; i < size; i++)
        {
            if (packageName.equals(badPackages[i]))
            {
                return false;
            }
        }
        for (int i = 0, size = badClasses.length; i < size; i++)
        {
            if (className.equals(badClasses[i]))
            {
                return false;
            }
        }
        return true;
    }
}
"
org.apache.velocity.util.introspection.SecureUberspector,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Iterator;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.RuntimeServices;
import org.apache.velocity.util.RuntimeServicesAware;
/**
 * Use a custom introspector that prevents classloader related method 
 * calls.  Use this introspector for situations in which template 
 * writers are numerous or untrusted.  Specifically, this introspector 
 * prevents creation of arbitrary objects or reflection on objects.
 * 
 * <p>To use this introspector, set the following property:
 * <pre>
 * runtime.introspector.uberspect = org.apache.velocity.util.introspection.SecureUberspector
 * </pre>
 * 
 * @author <a href=""mailto:wglass@forio.com"">Will Glass-Husain</a>
 * @version $Id: SecureUberspector.java 718443 2008-11-18 00:01:56Z nbubna $
 * @since 1.5
 */
public class SecureUberspector extends UberspectImpl implements RuntimeServicesAware
{
    RuntimeServices runtimeServices;
    public SecureUberspector()
    {
        super();
    }
    /**
     *  init - generates the Introspector. As the setup code
     *  makes sure that the log gets set before this is called,
     *  we can initialize the Introspector using the log object.
     */
    public void init()
    {
        String [] badPackages = runtimeServices.getConfiguration()
                        .getStringArray(RuntimeConstants.INTROSPECTOR_RESTRICT_PACKAGES);
        String [] badClasses = runtimeServices.getConfiguration()
                        .getStringArray(RuntimeConstants.INTROSPECTOR_RESTRICT_CLASSES);
        introspector = new SecureIntrospectorImpl(badClasses, badPackages, log);
    }
    /**
     * Get an iterator from the given object.  Since the superclass method
     * this secure version checks for execute permission.
     * 
     * @param obj object to iterate over
     * @param i line, column, template info
     * @return Iterator for object
     * @throws Exception
     */
    public Iterator getIterator(Object obj, Info i)
        throws Exception
    {
        if (obj != null)
        {
            SecureIntrospectorControl sic = (SecureIntrospectorControl)introspector;
            if (sic.checkObjectExecutePermission(obj.getClass(), null))
            {
                return super.getIterator(obj, i);
            }
            else
            {
                log.warn(""Cannot retrieve iterator from "" + obj.getClass() +
                         "" due to security restrictions."");
            }
        }
        return null;
    }
    /**
     * Store the RuntimeServices before the object is initialized..
     * @param rs RuntimeServices object for initialization
     */
    public void setRuntimeServices(RuntimeServices rs)
    {
        this.runtimeServices = rs;
    }
}
"
org.apache.velocity.util.introspection.Uberspect,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.util.Iterator;
/**
 * 'Federated' introspection/reflection interface to allow the introspection
 *  behavior in Velocity to be customized.
 *
 * @author <a href=""mailto:geirm@apache.org"">Geir Magusson Jr.</a>
 * @version $Id: Uberspect.java 463298 2006-10-12 16:10:32Z henning $
 */
public interface Uberspect
{
    /**
     *  Initializer - will be called before use
     * @throws Exception
     */
    public void init() throws Exception;
    /**
     *  To support iteratives - #foreach()
     * @param obj
     * @param info
     * @return An Iterator.
     * @throws Exception
     */
    public Iterator getIterator(Object obj, Info info) throws Exception;
    /**
     *  Returns a general method, corresponding to $foo.bar( $woogie )
     * @param obj
     * @param method
     * @param args
     * @param info
     * @return A Velocity Method.
     * @throws Exception
     */
    public VelMethod getMethod(Object obj, String method, Object[] args, Info info) throws Exception;
    /**
     * Property getter - returns VelPropertyGet appropos for #set($foo = $bar.woogie)
     * @param obj
     * @param identifier
     * @param info
     * @return A Velocity Getter.
     * @throws Exception
     */
    public VelPropertyGet getPropertyGet(Object obj, String identifier, Info info) throws Exception;
    /**
     * Property setter - returns VelPropertySet appropos for #set($foo.bar = ""geir"")
     * @param obj
     * @param identifier
     * @param arg
     * @param info
     * @return A Velocity Setter.
     * @throws Exception
     */
    public VelPropertySet getPropertySet(Object obj, String identifier, Object arg, Info info) throws Exception;
}
"
org.apache.velocity.util.introspection.UberspectImpl,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Map;
import org.apache.velocity.runtime.RuntimeLogger;
import org.apache.velocity.runtime.log.Log;
import org.apache.velocity.runtime.log.RuntimeLoggerLog;
import org.apache.velocity.runtime.parser.node.AbstractExecutor;
import org.apache.velocity.runtime.parser.node.BooleanPropertyExecutor;
import org.apache.velocity.runtime.parser.node.GetExecutor;
import org.apache.velocity.runtime.parser.node.MapGetExecutor;
import org.apache.velocity.runtime.parser.node.MapSetExecutor;
import org.apache.velocity.runtime.parser.node.PropertyExecutor;
import org.apache.velocity.runtime.parser.node.PutExecutor;
import org.apache.velocity.runtime.parser.node.SetExecutor;
import org.apache.velocity.runtime.parser.node.SetPropertyExecutor;
import org.apache.velocity.util.ArrayIterator;
import org.apache.velocity.util.ArrayListWrapper;
import org.apache.velocity.util.EnumerationIterator;
/**
 *  Implementation of Uberspect to provide the default introspective
 *  functionality of Velocity
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @author <a href=""mailto:henning@apache.org"">Henning P. Schmiedehausen</a>
 * @version $Id: UberspectImpl.java 720351 2008-11-24 23:35:13Z nbubna $
 */
public class UberspectImpl implements Uberspect, UberspectLoggable
{
    /**
     *  Our runtime logger.
     */
    protected Log log;
    /**
     *  the default Velocity introspector
     */
    protected Introspector introspector;
    /**
     *  init - generates the Introspector. As the setup code
     *  makes sure that the log gets set before this is called,
     *  we can initialize the Introspector using the log object.
     */
    public void init() throws Exception
    {
        introspector = new Introspector(log);
    }
    /**
     *  Sets the runtime logger - this must be called before anything
     *  else.
     *
     * @param log The logger instance to use.
     * @since 1.5
     */
    public void setLog(Log log)
    {
        this.log = log;
    }
    /**
     * @param runtimeLogger
     * @deprecated Use setLog(Log log) instead.
     */
    public void setRuntimeLogger(RuntimeLogger runtimeLogger)
    {
        // in the off chance anyone still uses this method
        // directly, use this hack to keep it working
        setLog(new RuntimeLoggerLog(runtimeLogger));
    }
    /**
     *  To support iterative objects used in a <code>#foreach()</code>
     *  loop.
     *
     * @param obj The iterative object.
     * @param i Info about the object's location.
     * @return An {@link Iterator} object.
     * @throws Exception
     */
    public Iterator getIterator(Object obj, Info i)
            throws Exception
    {
        if (obj.getClass().isArray())
        {
            return new ArrayIterator(obj);
        }
        else if (obj instanceof Collection)
        {
            return ((Collection) obj).iterator();
        }
        else if (obj instanceof Map)
        {
            return ((Map) obj).values().iterator();
        }
        else if (obj instanceof Iterator)
        {
            if (log.isDebugEnabled())
            {
                log.debug(""The iterative object in the #foreach() loop at "" +
                           i + "" is of type java.util.Iterator.  Because "" +
                           ""it is not resettable, if used in more than once it "" +
                           ""may lead to unexpected results."");
            }
            return ((Iterator) obj);
        }
        else if (obj instanceof Enumeration)
        {
            if (log.isDebugEnabled())
            {
                log.debug(""The iterative object in the #foreach() loop at "" +
                           i + "" is of type java.util.Enumeration.  Because "" +
                           ""it is not resettable, if used in more than once it "" +
                           ""may lead to unexpected results."");
            }
            return new EnumerationIterator((Enumeration) obj);
        }
        else
        {
            // look for an iterator() method to support the JDK5 Iterable
            // interface or any user tools/DTOs that want to work in
            // foreach without implementing the Collection interface
            Class type = obj.getClass();
            try
            {
                Method iter = type.getMethod(""iterator"", null);
                Class returns = iter.getReturnType();
                if (Iterator.class.isAssignableFrom(returns))
                {
                    return (Iterator)iter.invoke(obj, null);
                }
                else
                {
                    log.debug(""iterator() method of reference in #foreach loop at ""
                              + i + "" does not return a true Iterator."");
                }
            }
            catch (NoSuchMethodException nsme)
            {
                // eat this one, but let all other exceptions thru
            }
        }
        /*  we have no clue what this is  */
        log.debug(""Could not determine type of iterator in #foreach loop at "" + i);
        return null;
    }
    /**
     *  Method
     * @param obj
     * @param methodName
     * @param args
     * @param i
     * @return A Velocity Method.
     * @throws Exception
     */
    public VelMethod getMethod(Object obj, String methodName, Object[] args, Info i)
            throws Exception
    {
        if (obj == null)
        {
            return null;
        }
        Method m = introspector.getMethod(obj.getClass(), methodName, args);
        if (m != null)
        {
            return new VelMethodImpl(m);
        }
        Class cls = obj.getClass();
        // if it's an array
        if (cls.isArray())
        {
            // check for support via our array->list wrapper
            m = introspector.getMethod(ArrayListWrapper.class, methodName, args);
            if (m != null)
            {
                // and create a method that knows to wrap the value
                // before invoking the method
                return new VelMethodImpl(m, true);
            }
        }
        // watch for classes, to allow calling their static methods (VELOCITY-102)
        else if (cls == Class.class)
        {
            m = introspector.getMethod((Class)obj, methodName, args);
            if (m != null)
            {
                return new VelMethodImpl(m);
            }
        }
        return null;
    }
    /**
     * Property  getter
     * @param obj
     * @param identifier
     * @param i
     * @return A Velocity Getter Method.
     * @throws Exception
     */
    public VelPropertyGet getPropertyGet(Object obj, String identifier, Info i)
            throws Exception
    {
        if (obj == null)
        {
            return null;
        }
        Class claz = obj.getClass();
        /*
         *  first try for a getFoo() type of property
         *  (also getfoo() )
         */
        AbstractExecutor executor = new PropertyExecutor(log, introspector, claz, identifier);
        /*
         * Let's see if we are a map...
         */
        if (!executor.isAlive()) 
        {
            executor = new MapGetExecutor(log, claz, identifier);
        }
        /*
         *  if that didn't work, look for get(""foo"")
         */
        if (!executor.isAlive())
        {
            executor = new GetExecutor(log, introspector, claz, identifier);
        }
        /*
         *  finally, look for boolean isFoo()
         */
        if (!executor.isAlive())
        {
            executor = new BooleanPropertyExecutor(log, introspector, claz,
                                                   identifier);
        }
        return (executor.isAlive()) ? new VelGetterImpl(executor) : null;
    }
    /**
     * Property setter
     * @param obj
     * @param identifier
     * @param arg
     * @param i
     * @return A Velocity Setter method.
     * @throws Exception
     */
    public VelPropertySet getPropertySet(Object obj, String identifier,
                                         Object arg, Info i)
            throws Exception
    {
        if (obj == null)
        {
            return null;
        }
        Class claz = obj.getClass();
        /*
         *  first try for a setFoo() type of property
         *  (also setfoo() )
         */
        SetExecutor executor = new SetPropertyExecutor(log, introspector, claz, identifier, arg);
        /*
         * Let's see if we are a map...
         */
        if (!executor.isAlive())  {
            executor = new MapSetExecutor(log, claz, identifier);
        }
        /*
         *  if that didn't work, look for put(""foo"", arg)
         */
        if (!executor.isAlive())
        {
            executor = new PutExecutor(log, introspector, claz, arg, identifier);
        }
        return (executor.isAlive()) ? new VelSetterImpl(executor) : null;
    }
    /**
     *  Implementation of VelMethod
     */
    public static class VelMethodImpl implements VelMethod
    {
        final Method method;
        Boolean isVarArg;
        boolean wrapArray;
        /**
         * @param m
         */
        public VelMethodImpl(Method m)
        {
            this(m, false);
        }
        /**
         * @since 1.6
         */
        public VelMethodImpl(Method method, boolean wrapArray)
        {
            this.method = method;
            this.wrapArray = wrapArray;
        }
        private VelMethodImpl()
        {
            method = null;
        }
        /**
         * @see VelMethod#invoke(java.lang.Object, java.lang.Object[])
         */
        public Object invoke(Object o, Object[] actual)
            throws Exception
        {
            // if we're pretending an array is a list...
            if (wrapArray)
            {
                o = new ArrayListWrapper(o);
            }
            if (isVarArg())
            {
                Class[] formal = method.getParameterTypes();
                int index = formal.length - 1;
                if (actual.length >= index)
                {
                    Class type = formal[index].getComponentType();
                    actual = handleVarArg(type, index, actual);
                }
            }
            // call extension point invocation
            return doInvoke(o, actual);
        }
        /**
         * Offers an extension point for subclasses (in alternate Uberspects)
         * to alter the invocation after any array wrapping or varargs handling
         * has already been completed.
         * @since 1.6
         */
        protected Object doInvoke(Object o, Object[] actual) throws Exception
        {
            return method.invoke(o, actual);
        }
        /**
         * @return true if this method can accept a variable number of arguments
         * @since 1.6
         */
        public boolean isVarArg()
        {
            if (isVarArg == null)
            {
                Class[] formal = method.getParameterTypes();
                if (formal == null || formal.length == 0)
                {
                    this.isVarArg = Boolean.FALSE;
                }
                else
                {
                    Class last = formal[formal.length - 1];
                    // if the last arg is an array, then
                    // we consider this a varargs method
                    this.isVarArg = Boolean.valueOf(last.isArray());
                }
            }
            return isVarArg.booleanValue();
        }
        /**
         * @param type The vararg class type (aka component type
         *             of the expected array arg)
         * @param index The index of the vararg in the method declaration
         *              (This will always be one less than the number of
         *               expected arguments.)
         * @param actual The actual parameters being passed to this method
         * @returns The actual parameters adjusted for the varargs in order
         *          to fit the method declaration.
         */
        private Object[] handleVarArg(final Class type,
                                      final int index,
                                      Object[] actual)
        {
            // if no values are being passed into the vararg
            if (actual.length == index)
            {
                // create an empty array of the expected type
                actual = new Object[] { Array.newInstance(type, 0) };
            }
            // if one value is being passed into the vararg
            else if (actual.length == index + 1 && actual[index] != null)
            {
                // make sure the last arg is an array of the expected type
                Class argClass = actual[index].getClass();
                if (!argClass.isArray() &&
                    IntrospectionUtils.isMethodInvocationConvertible(type,
                                                                     argClass,
                                                                     false))
                {
                    // create a 1-length array to hold and replace the last param
                    Object lastActual = Array.newInstance(type, 1);
                    Array.set(lastActual, 0, actual[index]);
                    actual[index] = lastActual;
                }
            }
            // if multiple values are being passed into the vararg
            else if (actual.length > index + 1)
            {
                // put the last and extra actual in an array of the expected type
                int size = actual.length - index;
                Object lastActual = Array.newInstance(type, size);
                for (int i = 0; i < size; i++)
                {
                    Array.set(lastActual, i, actual[index + i]);
                }
                // put all into a new actual array of the appropriate size
                Object[] newActual = new Object[index + 1];
                for (int i = 0; i < index; i++)
                {
                    newActual[i] = actual[i];
                }
                newActual[index] = lastActual;
                // replace the old actual array
                actual = newActual;
            }
            return actual;
        }
        /**
         * @see org.apache.velocity.util.introspection.VelMethod#isCacheable()
         */
        public boolean isCacheable()
        {
            return true;
        }
        /**
         * @see org.apache.velocity.util.introspection.VelMethod#getMethodName()
         */
        public String getMethodName()
        {
            return method.getName();
        }
        /**
         * @see org.apache.velocity.util.introspection.VelMethod#getReturnType()
         */
        public Class getReturnType()
        {
            return method.getReturnType();
        }
    }
    /**
     *
     *
     */
    public static class VelGetterImpl implements VelPropertyGet
    {
        final AbstractExecutor getExecutor;
        /**
         * @param exec
         */
        public VelGetterImpl(AbstractExecutor exec)
        {
            getExecutor = exec;
        }
        private VelGetterImpl()
        {
            getExecutor = null;
        }
        /**
         * @see org.apache.velocity.util.introspection.VelPropertyGet#invoke(java.lang.Object)
         */
        public Object invoke(Object o)
            throws Exception
        {
            return getExecutor.execute(o);
        }
        /**
         * @see org.apache.velocity.util.introspection.VelPropertyGet#isCacheable()
         */
        public boolean isCacheable()
        {
            return true;
        }
        /**
         * @see org.apache.velocity.util.introspection.VelPropertyGet#getMethodName()
         */
        public String getMethodName()
        {
            return getExecutor.isAlive() ? getExecutor.getMethod().getName() : null;
        }
    }
    /**
     *
     */
    public static class VelSetterImpl implements VelPropertySet
    {
        private final SetExecutor setExecutor;
        /**
         * @param setExecutor
         */
        public VelSetterImpl(final SetExecutor setExecutor)
        {
            this.setExecutor = setExecutor;
        }
        private VelSetterImpl()
        {
            setExecutor = null;
        }
        /**
         * Invoke the found Set Executor.
         *
         * @param o is the Object to invoke it on.
         * @param value in the Value to set.
         * @return The resulting Object.
         * @throws Exception
         */
        public Object invoke(final Object o, final Object value)
            throws Exception
        {
            return setExecutor.execute(o, value);
        }
        /**
         * @see org.apache.velocity.util.introspection.VelPropertySet#isCacheable()
         */
        public boolean isCacheable()
        {
            return true;
        }
        /**
         * @see org.apache.velocity.util.introspection.VelPropertySet#getMethodName()
         */
        public String getMethodName()
        {
            return setExecutor.isAlive() ? setExecutor.getMethod().getName() : null;
        }
    }
}
"
org.apache.velocity.util.introspection.UberspectLoggable,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
import org.apache.velocity.runtime.RuntimeLogger;
import org.apache.velocity.runtime.log.Log;
/**
 *  Marker interface to let an uberspector indicate it can and wants to
 *  log
 *
 *  Thanks to Paulo for the suggestion
 *
 * @author <a href=""mailto:nbubna@apache.org"">Nathan Bubna</a>
 * @author <a href=""mailto:geirm@apache.org"">Geir Magnusson Jr.</a>
 * @version $Id: UberspectLoggable.java 463298 2006-10-12 16:10:32Z henning $
 *
 */
public interface UberspectLoggable
{
    /**
     * Sets the logger.  This will be called before any calls to the
     * uberspector
     * @param log
     */
    public void setLog(Log log);
    /**
     * @param logger
     * @deprecated Use setLog(Log log) instead.
     */
    public void setRuntimeLogger(RuntimeLogger logger);
}
"
org.apache.velocity.util.introspection.VelMethod,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Method used for regular method invocation
 *
 *    $foo.bar()
 *
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelMethod.java 510625 2007-02-22 19:06:28Z nbubna $
 */
public interface VelMethod
{
    /**
     *  invocation method - called when the method invocation should be
     *  performed and a value returned
     * @param o
     * @param params
     * @return The resulting object.
     * @throws Exception
     */
    public Object invoke(Object o, Object[] params)
        throws Exception;
    /**
     *  specifies if this VelMethod is cacheable and able to be
     *  reused for this class of object it was returned for
     *
     *  @return true if can be reused for this class, false if not
     */
    public boolean isCacheable();
    /**
     *  returns the method name used
     * @return The method name used
     */
    public String getMethodName();
    /**
     *  returns the return type of the method invoked
     * @return The return type of the method invoked
     */
    public Class getReturnType();
}
"
org.apache.velocity.util.introspection.VelPropertyGet,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Interface defining a 'getter'.  For uses when looking for resolution of
 *  property references
 *
 *       $foo.bar
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelPropertyGet.java 463298 2006-10-12 16:10:32Z henning $
 */
public interface VelPropertyGet
{
    /**
     *  invocation method - called when the 'get action' should be
     *  preformed and a value returned
     * @param o
     * @return The resulting Object.
     * @throws Exception
     */
    public Object invoke(Object o) throws Exception;
    /**
     *  specifies if this VelPropertyGet is cacheable and able to be
     *  reused for this class of object it was returned for
     *
     *  @return true if can be reused for this class, false if not
     */
    public boolean isCacheable();
    /**
     *  returns the method name used to return this 'property'
     * @return The method name used to return this 'property'
     */
    public String getMethodName();
}
"
org.apache.velocity.util.introspection.VelPropertySet,"package org.apache.velocity.util.introspection;
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.    
 */
/**
 *  Interface used for setting values that appear to be properties in
 *  Velocity.  Ex.
 *
 *      #set($foo.bar = ""hello"")
 *
 * @author <a href=""mailto:geirm@optonline.net"">Geir Magnusson Jr.</a>
 * @version $Id: VelPropertySet.java 463298 2006-10-12 16:10:32Z henning $
 */
public interface VelPropertySet
{
    /**
     *  method used to set the value in the object
     *
     *  @param o Object on which the method will be called with the arg
     *  @param arg value to be set
     *  @return the value returned from the set operation (impl specific)
     * @throws Exception
     */
    public Object invoke(Object o, Object arg) throws Exception;
    /**
     *  specifies if this VelPropertySet is cacheable and able to be
     *  reused for this class of object it was returned for
     *
     *  @return true if can be reused for this class, false if not
     */
    public boolean isCacheable();
    /**
     *  returns the method name used to set this 'property'
     * @return The method name used to set this 'property'
     */
    public String getMethodName();
}
"
